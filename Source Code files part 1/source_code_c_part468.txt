game->removePlayerPending = FALSE;
	}
	else
	{
		if (msg->response == 0)
			wsprintf(str, zRemovePlayerRejectStr, game->players[msg->seat].name,
					game->players[msg->requestSeat].name, game->players[msg->targetSeat].name);
		else if (msg->response == 1)
			wsprintf(str, zRemovePlayerAcceptStr, game->players[msg->seat].name,
					game->players[msg->requestSeat].name, game->players[msg->targetSeat].name);
		ZDisplayText(str, &gRemovePlayerRect, game->gameDrawPort);
	}
}


static void PlayerPlayedCard(Game game, int16 seat, ZCard card)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

	int16			i;
	
	
	if (game->playerType != zGamePlayer)
		UnselectCards(game);
	
	game->cardsPlayed[seat] = card;
	UpdatePlayedCard(game, seat);
	
	/* Update kibitzer's hand. */
	if (seat == game->seat && game->playerType != zGamePlayer)
	{
		for (i = 0; i < game->numCardsDealt; i++)
			if (game->cardsInHand[i] == card)
			{
				game->cardsInHand[i] = zNoCard;
				game->numCardsInHand--;
				break;
			}
		
		UpdateHand(game);
	}
	
	if (IsPointCard(card))
		game->pointsBroken = TRUE;
	
	ClearPlayerCardOutline(game, game->playerToPlay);
	
	game->playerToPlay = (game->playerToPlay + 1) % zNumPlayersPerTable;
	
	if (game->playerToPlay == game->leadPlayer)
	{
		game->leadPlayer = TrickWinner(game);
		game->playerToPlay = game->leadPlayer;
		
		game->playButtonWasEnabled = ZRolloverButtonIsEnabled(game->playButton);
		game->lastTrickButtonWasEnabled = ZRolloverButtonIsEnabled(game->lastTrickButton);
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDisable(game->lastTrickButton);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        EnableLastTrickAcc(game, false);
		
		/* Enable the last trick button after the first trick; only if not kibitzing. */
		game->numTricksTaken[game->leadPlayer]++;
		if (game->lastTrickButtonWasEnabled == FALSE && game->playerType == zGamePlayer)
			game->lastTrickButtonWasEnabled = TRUE;
		
		/* Save the last trick. */
		for (i = 0; i < zNumPlayersPerTable; i++)
			game->cardsLastTrick[i] = game->cardsPlayed[i];
		
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zHeartsMsgTalk);
		InitTrickWinner(game, game->leadPlayer);
		
		/* Show the winner of the trick. */
		OutlinePlayerCard(game, game->leadPlayer, TRUE);
		
		game->timerType = zGameTimerShowTrickWinner;
		ZTimerSetTimeout(game->timer, zShowTrickWinnerTimeout);
	}
	else
	{
		OutlinePlayerCard(game, game->playerToPlay, FALSE);
			
		if (game->numCardsInHand > 0 && game->playerToPlay == game->seat)
		{
			if (game->autoPlay)
			{
				AutoPlayCard(game);
			}
			else
			{
				ZRolloverButtonEnable(game->playButton);
                gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
				if (game->beepOnTurn)
                {
					ZBeep();
                    ZShellGameShell()->MyTurn();
                }
			}
		}
		else
		{
			ZRolloverButtonDisable(game->playButton);
            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
		}
	}
}


static void OutlinePlayerCard(Game game, int16 seat, ZBool winner)
{
	
	if (winner)
	{
		ZColor color;
		color.red = 255;
		color.green = 255;
		color.blue = 204;
		ZBeginDrawing(game->gameDrawPort);
		OutlineCard(game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]], &color);
		ZEndDrawing(game->gameDrawPort);
	}
	else
	{
		ZColor	color;
		color.red = 153;
		color.green = 153;
		color.blue = 255;
		ZBeginDrawing(game->gameDrawPort);
		OutlineCard(game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]], &color);
		ZEndDrawing(game->gameDrawPort);
	}
	
	
	
}


static void ClearPlayerCardOutline(Game game, int16 seat)
{
	ZRect		rect;
	
	
	ZBeginDrawing(game->gameDrawPort);
	
	rect = gRects[gCardRectIndex[LocalSeat(game, seat)]];
	ZRectInset(&rect, zCardOutlineInset, zCardOutlineInset);
	DrawBackground(game, game->gameDrawPort, &rect);

	DrawPlayedCard(game, seat);
	
	ZEndDrawing(game->gameDrawPort);
}


static void OutlineCard(ZGrafPort grafPort, ZRect* rect, ZColor* color)
{
	ZColor		oldColor;
	ZRect		tempRect;
	
	
	ZGetForeColor(grafPort, &oldColor);
	
	ZSetPenWidth(grafPort, zCardOutlinePenWidth);
	
	if (color != NULL)
		ZSetForeColor(grafPort, color);
	
	tempRect = *rect;
	ZRectInset(&tempRect, zCardOutlineInset, zCardOutlineInset);
	ZRoundRectDraw(grafPort, &tempRect, zCardOutlineRadius);
	
	ZSetForeColor(grafPort, &oldColor);
}


/*******************************************************************************
	HAND SCORE WINDOW ROUTINES
*******************************************************************************/
static void ShowHandScores(Game game)
{
	ZWindowShow(game->handScoreWindow);
}


static ZBool HandScoreWindowFunc(ZWindow window, ZMessage* pMessage)
{
	Game		game = I(pMessage->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (pMessage->messageType) 
	{
		case zMessageWindowDraw:
			HandScoreWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
			ZWindowHide(game->handScoreWindow);
            AccPop();
            game->fSetFocusToHandASAP = true;
			UpdateTable(game);
			UpdatePlayers(game);
			UpdateHand(game);
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			game->fEndGameBlocked = FALSE;
			ZCRoomUnblockMessages(game->tableID);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			DeleteHandScoreWindow(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void DeleteHandScoreWindow(Game game)
{
	if (game->handScoreWindow != NULL)
	{
		ZWindowDelete(game->handScoreWindow);
		game->handScoreWindow = NULL;
	}
}


static void HandScoreWindowDraw(ZWindow window, ZMessage* message)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZRect				rect;
	ZRect				oldClipRect;
	Game				game = (Game) message->userData;
	int16				i;
	TCHAR				tempStr[100];
	_assume( game != NULL );
	
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		rect = gHandScoreWindowRect;
	}
		
	ZBeginDrawing(window);
	ZGetClipRect(window, &oldClipRect);
	ZSetClipRect(window, &rect);

	// reverse layout for Right-to-left layouts
	if(ZIsLayoutRTL())
	{
		ZImageDraw(gGameImages[zImageHandScoreBack], window, &gHandScoreWindowRect, NULL, zDrawCopy|zDrawMirrorHorizontal);
		
		if (game != NULL)
		{
			HDC hdc = ZGrafPortGetWinDC(window);
			HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontScoreTitle].m_hFont );
			COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontScoreTitle].m_zColor );
			
			// draw scores title
			ZDrawText(window, &gHandScoreTitleRectRTL, zTextJustifyLeft, gszString[zScores]);
			
			hOldFont = SelectObject( hdc, gHeartsFont[zFontScoreText].m_hFont );
			colorOld = SetTextColor( hdc, gHeartsFont[zFontScoreText].m_zColor );
			
			// draw points label
			ZDrawText(window, &gHandScorePtsRectRTL, zTextJustifyRight, gszString[zPoints]);
			
			for (i = 0; i < zNumPlayersPerTable; i++)
			{
				ZDrawText(window, &gHandScoreNamesRTL[i], zTextJustifyLeft,
						game->seat == game->handScoreOrder[i] ? gszString[zYou] : game->players[game->handScoreOrder[i]].name);
				wsprintf(tempStr, _T("%d"), game->handScores[i]);
				ZDrawText(window, &gHandScoreScoresRTL[i], zTextJustifyRight, tempStr);
			}
		}
	}
	else
	{
		ZImageDraw(gGameImages[zImageHandScoreBack], window, &gHandScoreWindowRect, NULL, zDrawCopy);
		
		HDC hdc = ZGrafPortGetWinDC(window);
		HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontScoreTitle].m_hFont );
		COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontScoreTitle].m_zColor );
		
		// draw scores title
		ZDrawText(window, &gHandScoreTitleRect, zTextJustifyLeft, gszString[zScores]);
		
		hOldFont = SelectObject( hdc, gHeartsFont[zFontScoreText].m_hFont );
		colorOld = SetTextColor( hdc, gHeartsFont[zFontScoreText].m_zColor );
		
		// draw points label
		ZDrawText(window, &gHandScorePtsRect, zTextJustifyRight, gszString[zPoints]);
		
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			ZDrawText(window, &gHandScoreNames[i], zTextJustifyLeft,
					game->seat == game->handScoreOrder[i] ? gszString[zYou] : game->players[game->handScoreOrder[i]].name);
			wsprintf(tempStr, _T("%d"), game->handScores[i]);
			ZDrawText(window, &gHandScoreScores[i], zTextJustifyRight, tempStr);
		}
	}

    if( !IsRectEmpty(&game->rcFocus) && game->eFocusType == zAccRectClose)
    {
        HDC	hdc = ZGrafPortGetWinDC(window);
        SetROP2(hdc, R2_COPYPEN);
        SetBkMode(hdc, TRANSPARENT);
        HBRUSH hBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
        HPEN hPen = SelectObject(hdc, gFocusPen);
        Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
        SelectObject(hdc, hPen);
        SelectObject(hdc, hBrush);
    }

	ZSetClipRect(window, &oldClipRect);
	ZEndDrawing(window);
}


static void OrderHandScore(Game game)
{
	int16			i, j, high, curPlayer, temp;
	
	
	for (i = 0; i < zNumPlayersPerTable - 1; i++)
	{
		high = game->handScores[i];
		curPlayer = i;
		
		for (j = i + 1; j < zNumPlayersPerTable; j++)
		{
			if (game->handScores[j] > high)
			{
				high = game->handScores[j];
				curPlayer = j;
			}
		}
		
		if (i != curPlayer)
		{
			temp = game->handScores[i];
			game->handScores[i] = high;
			game->handScores[curPlayer] = temp;
			
			temp = game->handScoreOrder[i];
			game->handScoreOrder[i] = game->handScoreOrder[curPlayer];
			game->handScoreOrder[curPlayer] = temp;
		}
	}
}


/*******************************************************************************
	GAME SCORE WINDOW ROUTINES
*******************************************************************************/
static void ShowGameScores(Game game)
{
	ZWindowShow(game->gameScoreWindow);
//	ZWindowModal(game->gameScoreWindow);
}


static ZBool GameScoreWindowFunc(ZWindow window, ZMessage* pMessage)
{
	Game		game = I(pMessage->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (pMessage->messageType) 
	{
		case zMessageWindowDraw:
			GameScoreWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
			ZWindowNonModal(game->gameScoreWindow);
			ZWindowHide(game->gameScoreWindow);
            AccPop();
            game->fSetFocusToHandASAP = true;
			UpdateTable(game);
			UpdatePlayers(game);
			UpdateHand(game);
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			game->fEndGameBlocked = FALSE;
			ZCRoomUnblockMessages(game->tableID);
			
			if(game->playerType == zGamePlayer && !game->nCloseRequested && !game->quitGamePrompted)
			{
#ifndef MILL_VER
				/* Prompt the user for another game. */
				ZPrompt(zNewGamePromptStr, &gGameNewGameWindowRect, game->gameWindow, TRUE,
						zPromptYes | zPromptNo, NULL, NULL, NULL, NewGamePromptFunc, game);
#endif
			}
			else
			{
				game->fNeedNewGameConf = TRUE;
			}
			
			msgHandled = TRUE;

			ZShellGameShell()->GameOver(Z(game));

			break;
		case zMessageWindowClose:
			DeleteGameScoreWindow(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void DeleteGameScoreWindow(Game game)
{
	if (game->gameScoreWindow != NULL)
	{
		ZWindowDelete(game->gameScoreWindow);
		game->gameScoreWindow = NULL;
	}
}


static void GameScoreWindowDraw(ZWindow window, ZMessage* message)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZRect				rect;
	ZRect				oldClipRect;
	Game				game = (Game) message->userData;;
	int16				i;
	TCHAR				tempStr[100];
	
	
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		rect = gGameScoreWindowRect;
	}
		
	ZBeginDrawing(window);
	ZGetClipRect(window, &oldClipRect);
	ZSetClipRect(window, &rect);

	// reverse layout for right-to-left systems
	if(ZIsLayoutRTL())
	{
		ZImageDraw(gGameImages[zImageGameScoreBack], window, &gGameScoreWindowRect, NULL, zDrawCopy|zDrawMirrorHorizontal);
		
		if (game != NULL)
		{
			HDC hdc = ZGrafPortGetWinDC(window);
			HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontGameOverTitle].m_hFont );
			COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontGameOverTitle].m_zColor );
			
			ZDrawText(window, &gGameScoreTitleRectRTL, zTextJustifyLeft, gszString[zGameOver]);
			
			hOldFont = SelectObject( hdc, gHeartsFont[zFontGameOverText].m_hFont );
			colorOld = SetTextColor( hdc, gHeartsFont[zFontGameOverText].m_zColor );
			
			ZDrawText(window, &gGameScorePtsRectRTL, zTextJustifyRight, gszString[zPoints]);
			
			/* Draw player name and score. */
			for (i = 0; i < zNumPlayersPerTable; i++)
			{
				ZDrawText(window, &gGameScoreNamesRTL[i], zTextJustifyLeft,
						game->seat == game->gameScoreOrder[i] ? gszString[zYou] : game->players[game->gameScoreOrder[i]].name);
				wsprintf(tempStr, _T("%d"), game->gameScores[i]);
				ZDrawText(window, &gGameScoreScoresRTL[i], zTextJustifyRight, tempStr);
			}
			
			/* Draw winnner marks. */
			for (i = 0; i < zNumPlayersPerTable; i++)
			{
				if (game->gameScores[i] == game->gameScores[0])
				{
					ZSetRect(&rect, 0, 0, ZImageGetWidth(gGameImages[zImageSmallHeart]),
							ZImageGetWidth(gGameImages[zImageSmallHeart]));
					ZCenterRectToRect(&rect, &gGameScoreWinnersRTL[i], zCenterBoth);
					ZImageDraw(gGameImages[zImageSmallHeart], window, &rect, NULL, zDrawCopy);
				}
			}
		}
	}
	else
	{
		ZImageDraw(gGameImages[zImageGameScoreBack], window, &gGameScoreWindowRect, NULL, zDrawCopy);
		
		if (game != NULL)
		{
			HDC hdc = ZGrafPortGetWinDC(window);
			HFONT hOldFont = SelectObject( hdc, gHeartsFont[zFontGameOverTitle].m_hFont );
			COLORREF colorOld = SetTextColor( hdc, gHeartsFont[zFontGameOverTitle].m_zColor );
			
			ZDrawText(window, &gGameScoreTitleRect, zTextJustifyLeft, gszString[zGameOver]);
			
			hOldFont = SelectObject( hdc, gHeartsFont[zFontGameOverText].m_hFont );
			colorOld = SetTextColor( hdc, gHeartsFont[zFontGameOverText].m_zColor );
			
			ZDrawText(window, &gGameScorePtsRect, zTextJustifyRight, gszString[zPoints]);
			
			/* Draw player name and score. */
			for (i = 0; i < zNumPlayersPerTable; i++)
			{
				ZDrawText(window, &gGameScoreNames[i], zTextJustifyLeft,
						game->seat == game->gameScoreOrder[i] ? gszString[zYou] : game->players[game->gameScoreOrder[i]].name);
				wsprintf(tempStr, _T("%d"), game->gameScores[i]);
				ZDrawText(window, &gGameScoreScores[i], zTextJustifyRight, tempStr);
			}
			
			/* Draw winnner marks. */
			for (i = 0; i < zNumPlayersPerTable; i++)
			{
				if (game->gameScores[i] == game->gameScores[0])
				{
					ZSetRect(&rect, 0, 0, ZImageGetWidth(gGameImages[zImageSmallHeart]),
							ZImageGetWidth(gGameImages[zImageSmallHeart]));
					ZCenterRectToRect(&rect, &gGameScoreWinners[i], zCenterBoth);
					ZImageDraw(gGameImages[zImageSmallHeart], window, &rect, NULL, zDrawCopy);
				}
			}
		}
	}

    if( game != NULL && !IsRectEmpty(&game->rcFocus) && game->eFocusType == zAccRectClose)
    {
        HDC	hdc = ZGrafPortGetWinDC(window);
        SetROP2(hdc, R2_COPYPEN);
        SetBkMode(hdc, TRANSPARENT);
        HBRUSH hBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
        HPEN hPen = SelectObject(hdc, gFocusPen);
        Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
        SelectObject(hdc, hPen);
        SelectObject(hdc, hBrush);
    }

	ZSetClipRect(window, &oldClipRect);
	ZEndDrawing(window);
}


static void OrderGameScore(Game game)
{
	int16			i, j, low, curPlayer, temp;
	
	
	for (i = 0; i < zNumPlayersPerTable - 1; i++)
	{
		low = game->gameScores[i];
		curPlayer = i;
		
		for (j = i + 1; j < zNumPlayersPerTable; j++)
		{
			if (game->gameScores[j] < low)
			{
				low = game->gameScores[j];
				curPlayer = j;
			}
		}
		
		if (i != curPlayer)
		{
			temp = game->gameScores[i];
			game->gameScores[i] = low;
			game->gameScores[curPlayer] = temp;
			
			temp = game->gameScoreOrder[i];
			game->gameScoreOrder[i] = game->gameScoreOrder[curPlayer];
			game->gameScoreOrder[curPlayer] = temp;
		}
	}
}


/*******************************************************************************
	GAME LOGIC ROUTINES
*******************************************************************************/
static ZError ValidCardToPlay(Game game, ZCard card)
{
	ZError			valid;
	int16			counts[zDeckNumSuits];
	
	
	valid = zNoCardError;
	
	CountCardSuits(game, counts);
	
	/* If leading. */
	if (game->leadPlayer == game->seat)
	{
		/* Is it the first trick? */
		if (game->numCardsInHand == game->numCardsDealt)
		{
			/* Must play 2C. */
			if (card != zCard2C)
			{
				valid = zMustLead2COnFirstTrick;
				goto Exit;
			}
		}
		else
		{
			/* Can lead anything if points are broken. */
			if (game->pointsBroken == FALSE)
			{
				/* Can't lead hearts if points not broken. */
				if (ZSuit(card) == zSuitHearts)
				{
					/* But can lead hearts if there are no other cards to play. */
					if (counts[zSuitHearts] != game->numCardsInHand)
					{
						valid = zCantLeadHearts;
						goto Exit;
					}
				}
			}
		}
	}
	else
	{
		/* Must follow suit if any. */
		if (counts[ZSuit(game->cardsPlayed[game->leadPlayer])] != 0 &&
				ZSuit(card) != ZSuit(game->cardsPlayed[game->leadPlayer]))
		{
			valid = zMustFollowSuit;
			goto Exit;
		}
		
		/* Is it the first trick? */
		if (game->numCardsInHand == game->numCardsDealt)
		{
			/* Can't play a point unless allowed. */
			if ((game->gameOptions & zHeartsPointsOnFirstTrick) == 0)
			{
				if (ZSuit(card) == zSuitHearts)
				{
					if (counts[zSuitHearts] != zDeckNumCardsInSuit)
					{
						valid = zCantPlayPointsInFirstTrick;
						goto Exit;
					}
				}
				else if (card == zCardQS)
				{
					valid = zCantPlayPointsInFirstTrick;
					goto Exit;
				}
			}
		}
	}

Exit:
	
	return (valid);
}


static int16 GetAutoPlayCard(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			counts[zDeckNumSuits];
	int16			card;
	int16			i, high;
	
	
	card = zNoCard;
	
	CountCardSuits(game, counts);
	
	/* If leading. */
	if (game->leadPlayer == game->seat)
	{
		/* Is it the first trick? */
		if (game->numCardsInHand == game->numCardsDealt)
		{
			/* First card must be 2C. */
			card = 0;
			if (game->cardsInHand[card] != zCard2C)
				ZShellGameShell()->ZoneAlert(ErrorTextUnknown);
			goto Exit;
		}
		else
		{
			/* Can lead anything if points are broken. */
			if (game->pointsBroken == FALSE)
			{
				/* Pick Hearts only if no other suit available. */
				if (counts[zSuitHearts] != game->numCardsInHand)
				{
					/* Pick the highest non-Heart. */
					high = -1;
					for (i = game->numCardsDealt - 1; i >= 0; i--)
						if (ZSuit(game->cardsInHand[i]) != zSuitHearts &&
								game->cardsInHand[i] != zNoCard &&
								ZRank(game->cardsInHand[i]) > high)
						{
							card = i;
							high = ZRank(game->cardsInHand[i]);
						}
					if (card != zNoCard)
						goto Exit;
				}
			}
		}
	}
	else
	{
		/* Must follow suit if any. */
		if (counts[ZSuit(game->cardsPlayed[game->leadPlayer])] != 0)
		{
			if ((card = GetCardHighestUnder(game, ZSuit(game->cardsPlayed[game->leadPlayer]),
					GetCardHighestPlayed(game))) == zNoCard)
				card = GetCardHighest(game, ZSuit(game->cardsPlayed[game->leadPlayer]));
			goto Exit;
		}
		
		/* Is it the first trick? */
		if (game->numCardsInHand == game->numCardsDealt)
		{
			/* Can't play a point unless allowed. */
			if ((game->gameOptions & zHeartsPointsOnFirstTrick) == 0)
			{
				/* Pick a non-point card to play. */
				high = -1;
				for (i = game->numCardsDealt - 1; i >= 0; i--)
					if (ZSuit(game->cardsInHand[i]) != zSuitHearts &&
							game->cardsInHand[i] != zCardQS &&
							game->cardsInHand[i] != zNoCard &&
							ZRank(game->cardsInHand[i]) > high)
					{
						card = i;
						high = ZRank(game->cardsInHand[i]);
					}
				if (card != zNoCard)
					goto Exit;
			}
		}
	}

PickAny:
	/* Pick highest card in hand. It's dumb. */
	high = -1;
	for (i = game->numCardsDealt - 1; i >= 0; i--)
		if (game->cardsInHand[i] != zNoCard &&
				ZRank(game->cardsInHand[i]) > high)
		{
			card = i;
			high = ZRank(game->cardsInHand[i]);
		}
	
Exit:
	if (card == zNoCard)
	{
		/* No card picked. Problem. */
		ZShellGameShell()->ZoneAlert(ErrorTextUnknown);
	}
	
	return (card);
}


static int16 TrickWinner(Game game)
{
	int16			i, winner;
	int16			suit, rank;
	
	
	winner = game->leadPlayer;
	
	/* Get the lead player's suit and rank of the card. */
	suit = ZSuit(game->cardsPlayed[winner]);
	rank = ZRank(game->cardsPlayed[winner]);
	
	/* Look for a highest ranking card among the other played cards. */
	for (i = 0; i < zNumPlayersPerTable; i++)
		if (ZSuit(game->cardsPlayed[i]) == suit)
			if (ZRank(game->cardsPlayed[i]) > rank)
			{
				winner = i;
				rank = ZRank(game->cardsPlayed[i]);
			}
			
	return (winner);
}


static void CountCardSuits(Game game, int16* counts)
{
	int16			i;
	
	
	for (i = 0; i < zDeckNumSuits; i++)
		counts[i] = 0;
	for (i = 0; i < game->numCardsDealt; i++)
		if (game->cardsInHand[i] != zNoCard)
			counts[ZSuit(game->cardsInHand[i])]++;
}


static ZBool IsPointCard(ZCard card)
{
	return (ZSuit(card) == zSuitHearts || card == zCardQS);
}


/*
	Returns card index number.
*/
static int16 GetCardHighestUnder(Game game, int16 suit, int16 rank)
{
	int16			i;
	ZCard			card;
	
	
	for (i = game->numCardsDealt - 1; i >= 0; i--)
	{
		card = game->cardsInHand[i];
		if (ZSuit(card) == suit && card != zNoCard && ZRank(card) < rank)
			return (i);
	}
	
	return (zNoCard);
}


/*
	Returns card index number.
*/
static int16 GetCardHighest(Game game, int16 suit)
{
	int16			i;
	ZCard			card;
	
	
	/* Pick highest card of the suit. */
	for (i = game->numCardsDealt - 1; i >= 0; i--)
	{
		card = game->cardsInHand[i];
		if (ZSuit(card) == suit && card != zNoCard)
			return (i);
	}
	
	return (zNoCard);
}


/*
	Returns card rank.
*/
static int16 GetCardHighestPlayed(Game game)
{
	int16			i;
	ZCard			card, leadCard, high;
	
	
	/* Pick highest card of lead suit. */
	leadCard = game->cardsPlayed[game->leadPlayer];
	high = leadCard;
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		card = game->cardsPlayed[i];
		if (ZSuit(card) == ZSuit(leadCard) && card != zNoCard && card > high)
			high = card;
	}
	
	return (ZRank(high));
}

#ifdef HEARTS_ANIMATION
// Shoot the moon animation
static void ShowRunAnimation(Game game, int16 player )
{
	ZResource			resFile;
	ZRect				rect;
    TCHAR               szTitle[ZLARGESTRING];
    HeartsFormatMessage( szTitle, ZLARGESTRING, IDS_PLAYERSHOTTHEMOON, game->players[player].name );
	
	resFile = ZResourceNew();
	if (ZResourceInit(resFile, ZGetProgramDataFileName(zGameImageFileName)) == zErrNone)
	{
		if ((game->runAnimation = ZResourceGetAnimation(resFile, BIN_MOON-100)) != NULL)
		{
			if ((game->runAnimationWindow = ZWindowNew()) != NULL)
			{
				rect = gRunAnimationWindowRect;
				ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
				ZWindowInit(game->runAnimationWindow, &rect, zWindowDialogType, game->gameDrawPort,
						szTitle, TRUE, FALSE, FALSE, FALSE, 0, NULL);

				if(ZIsLayoutRTL())
				{
					HWND hWnd = ZWindowGetHWND(game->runAnimationWindow);
					if(hWnd)
					{
						long lExStyles = GetWindowLongA(hWnd, GWL_EXSTYLE) ;

						lExStyles |= WS_EX_LAYOUTRTL ; 

						SetWindowLongA(hWnd, GWL_EXSTYLE, lExStyles) ;
					}
				}

				ZWindowModal(game->runAnimationWindow);
				
				ZAnimationSetParams(game->runAnimation, game->runAnimationWindow,
						&gRunAnimationWindowRect, TRUE, RunAnimationCheckFunc, NULL, game);
				ZAnimationStart(game->runAnimation);
				
				ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zHeartsMsgTalk);
				game->deleteRunAnimation = FALSE;
				ZTimerSetTimeout(game->timer, 0);		// Stop the timer for now.
			}
			else
			{
				ZAnimationDelete(game->runAnimation);
				game->runAnimation = NULL;
			}
		}
		
		ZResourceDelete(resFile);
	}

}


static void RunAnimationCheckFunc(ZAnimation animation, uint16 frame, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I(userData);
    static int nNumTimesRun = 0;	
	
	if (frame == 0)
	{
        if ( nNumTimesRun < zAnimationNumTimesToRun )
        {
            nNumTimesRun++;
            ZAnimationStart(game->runAnimation);
        }
        else
        {
            nNumTimesRun = 0;
		    ZAnimationStop(game->runAnimation);
		    ZWindowNonModal(game->runAnimationWindow);
		    ZWindowHide(game->runAnimationWindow);
		    
		    game->deleteRunAnimation = TRUE;

            if ( !g_fDebugRunAnimation )
            {
		        // Display hand scores. 
		        ShowHandScores(game);
		        game->timerType = zGameTimerShowHandScore;
		        if (game->playerType == zGamePlayer)
			        ZTimerSetTimeout(game->timer, zHandScoreTimeout);
		        else
			        ZTimerSetTimeout(game->timer, zKibitzerTimeout);
		        
                // set up a different accessibility;
                GACCITEM accClose;

                CopyACC(accClose, ZACCESS_DefaultACCITEM);
                accClose.oAccel.cmd = IDC_CLOSE_BOX;
                accClose.oAccel.key = VK_ESCAPE;
                accClose.oAccel.fVirt = FVIRTKEY;

                accClose.fGraphical = true;
                accClose.pvCookie = (void *) zAccRectClose;
                if(!ZIsLayoutRTL())
                    ZRectToWRect(&accClose.rc, &gHandScoreCloseBox);
                else
                    ZRectToWRect(&accClose.rc, &gHandScoreCloseBoxRTL);

                gGAcc->PushItemlistG(&accClose, 1, 0, true, NULL);

		        UpdatePlayers(game);
            }
        }
	}
}


static void DeleteTemporaryObjects(Game game)
{
	/* Delete run animation. */
	if (game->deleteRunAnimation && game->runAnimation != NULL)
	{
		game->deleteRunAnimation = FALSE;

		ZAnimationDelete(game->runAnimation);
		ZWindowDelete(game->runAnimationWindow);
		game->runAnimation = NULL;
		game->runAnimationWindow = NULL;
	}
}
#endif

static void NewGamePromptFunc(int16 result, void* userData)
{
	Game					game = I(userData);
	ZHeartsMsgNewGame		msg;
	
	
	/* If yes, then send the new game message. */
	if (result == zPromptYes)
	{
		msg.seat = game->seat;
		ZHeartsMsgNewGameEndian(&msg);
		ZCRoomSendMessage(game->tableID, zHeartsMsgNewGame, &msg, sizeof(ZHeartsMsgNewGame));
		game->fNeedNewGameConf = FALSE;
	}
	else
	{
		game->nCloseRequested = zCloseClosing;
		//ZCRoomGameTerminated(game->tableID);
		ZShellGameShell()->ZoneExit();		
	}
}

#ifndef MILL_VER
static void HelpButtonFunc( ZHelpButton helpButton, void* userData )
{
	ZLaunchHelp( zGameHelpID );
}
#endif

// JRB: changed from LoadRoomImages to LoadRoomResources to reflect loading of string resources
static ZBool LoadRoomResources(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;

	// Load all string resources from the resource dll
	if(!ZShellResourceManager()->LoadString(IDS_GAME_NAME, gstrGameName, ZLARGESTRING))
		return FALSE;

	// Load player names
	if(!ZShellResourceManager()->LoadString(IDS_PLAYER_1, gstrPlayer1, ZLARGESTRING))
		return FALSE;
	if(!ZShellResourceManager()->LoadString(IDS_PLAYER_2, gstrPlayer2, ZLARGESTRING))
		return FALSE;
	if(!ZShellResourceManager()->LoadString(IDS_PLAYER_3, gstrPlayer3, ZLARGESTRING))
		return FALSE;
	if(!ZShellResourceManager()->LoadString(IDS_PLAYER_4, gstrPlayer4, ZLARGESTRING))
		return FALSE;

	for(int i = 0; i < zNumStrings; i++)
		ZShellResourceManager()->LoadString(IDS_SCORE_HISTORY + i, gszString[i], ZLARGESTRING);

	// The first index value is reserved for a "no error" message which never gets displayed.
	// This is done so that the error number corresponds directly with the error value to
	// avoid potential confusion.
	for(i = 1; i < zNumValidCardErrors; i++)
		ZShellResourceManager()->LoadString(IDS_ERR_LEAD_2C + i - 1, gValidCardErrStr[i], ZLARGESTRING);


	if(!LoadGameFonts())
		return FALSE;
	
	return TRUE;
}


static ZBool LoadGameFonts(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	for(int i = 0; i < zNumFonts; i++)
	{
		if(!LoadFontFromDataStore(&gHeartsFont[i], (TCHAR*)g_aszFontLabel[i]))
			return FALSE;
	}
    TCHAR tagFont [64];
	MAKEAKEY (tagFont, zFontRscTyp, (TCHAR*)g_szRolloverText, L"");
	if ( FAILED( LoadZoneMultiStateFont( ZShellDataStoreUI(), tagFont, &gpButtonFont ) ) )
		ZShellGameShell()->ZoneAlert(_T("Font loading falied"), NULL);

	return TRUE;
}


static ZBool HeartsGetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

/*
	switch (objectType)
	{
		case zRoomObjectGameMarker:
			if (image != NULL)
			{
				if (modifier == zRoomObjectIdle)
					*image = gGameIdle;
				else if (modifier == zRoomObjectGaming)
					*image = gGaming;
			}
			return (TRUE);
	}
*/	
	return (FALSE);
}


static void HeartsDeleteObjectsFunc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif

/*	
	if (gGameIdle != NULL)
		ZImageDelete(gGameIdle);
	gGameIdle = NULL;
	if (gGaming != NULL)
		ZImageDelete(gGaming);
	gGaming = NULL;
*/
}


static void QuitGamePromptFunc(int16 result, void* userData)
{
	Game			this_object = (Game) userData;
	ZHeartsMsgNewGame		msg;
	
	this_object->quitGamePrompted = zCloseNone;

	if(result == zPromptYes)
	{
		this_object->nCloseRequested = zCloseClosing;
		//ZCRoomGameTerminated(this_object->tableID);
		ZShellGameShell()->ZoneExit();		
	}
	else if(this_object->fNeedNewGameConf)
	{
		msg.seat = this_object->seat;
		ZHeartsMsgNewGameEndian(&msg);
		ZCRoomSendMessage(this_object->tableID, zHeartsMsgNewGame, &msg, sizeof(ZHeartsMsgNewGame));
		this_object->fNeedNewGameConf = FALSE;
	}
}


static void QuitRatedGamePromptFunc(int16 result, void* userData)
{
	Game this_object = (Game) userData;
	ZHeartsMsgCloseRequest msg;
	ZHeartsMsgNewGame msgNG;

	msg.nClose = this_object->quitGamePrompted;
	this_object->quitGamePrompted = zCloseNone;

	if(result == zPromptNo)
	{
		if(this_object->fNeedNewGameConf)
		{
			msgNG.seat = this_object->seat;
			ZHeartsMsgNewGameEndian(&msgNG);
			ZCRoomSendMessage(this_object->tableID, zHeartsMsgNewGame, &msgNG, sizeof(ZHeartsMsgNewGame));
			this_object->fNeedNewGameConf = FALSE;
		}
		return;
	}

	if(!this_object->fEndGameBlocked)
	{
		if(this_object->infoDisconnecting)
			ZInfoDelete(this_object->infoDisconnecting);
		this_object->infoDisconnecting = ZInfoNew();
		if(this_object->infoDisconnecting)
		{
			ZInfoInit(this_object->infoDisconnecting, this_object->gameWindow, zDisconnectingInfoStr, zDisconnectingInfoWidth, FALSE, 0);
			ZInfoShow(this_object->infoDisconnecting);
		}
	}

	msg.seat = this_object->seat;
	this_object->nCloseRequested = msg.nClose;

	ZHeartsMsgCloseRequestEndian(&msg);
	ZCRoomSendMessage(this_object->tableID, zHeartsMsgCloseRequest, &msg, sizeof(msg));
}


static void RemovePlayerPromptFunc(int16 result, void* userData)
{
	RemovePlayer					this_object = (RemovePlayer) userData;
	ZHeartsMsgRemovePlayerResponse	response;
	
	
	response.seat = this_object->game->seat;
	response.requestSeat = this_object->requestSeat;
	response.targetSeat = this_object->targetSeat;
	if (result == zPromptYes)
		response.response = 1;
	else
		response.response = 0;
	ZHeartsMsgRemovePlayerResponseEndian(&response);
	ZCRoomSendMessage(this_object->game->tableID, zHeartsMsgRemovePlayerResponse,
			&response, sizeof(response));
	ZFree(userData);
}


static ZBool ScoreButtonFunc(ZRolloverButton pictButton, int16 state, void* userData)
{
	Game game = (Game) userData;

	if ( state != zRolloverButtonClicked )
        return TRUE;

	if(!ZRolloverButtonIsEnabled(game->scoreButton))
		return TRUE;

	ShowScores(I(userData));
	return TRUE;
}


static void ShowScores(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();
#endif
	int16			width, height;
	TCHAR			tcBuffer[128];
	
	
	if ( IsWindow( game->hWndScoreWindow ) )
    {
        BringWindowToTop( game->hWndScoreWindow );
    }
    else
    {
        game->hWndScoreWindow = ZShellResourceManager()->CreateDialogParam( NULL,
                                                            MAKEINTRESOURCE( IDD_SCORES ),
                                                            ZWindowWinGetWnd( game->gameWindow ),
                                                            ScoreHistoryDialogProc,
                                                            (LPARAM)game );
        if ( !game->hWndScoreWindow )
        {
            ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound );
        }
    }
}


long GetScoreHistoryColumnWidth( HWND hWnd, const TCHAR *pszKey, long lDefault )
{
    const TCHAR *arKeys[3] = { zHearts, zHistoryDialog, pszKey };
    long lWidth;
    RECT rc;

    if ( FAILED( ZShellDataStoreUI()->GetLong( arKeys, 3, &lWidth ) ) )
    {
       return lDefault;
    }
    SetRect( &rc, 0, 0, lWidth, 0 );
    MapDialogRect( hWnd, &rc );
    return rc.right;
}


static void UpdateScoreHistoryDialogScores( Game game )
{
    if ( ::IsWindow( game->hWndScoreWindow ) )
    {
        ::PostMessage( game->hWndScoreWindow, WM_UPDATESCORES, 0, 0 );
    }
}
static void UpdateScoreHistoryDialogNames( Game game )
{
    if ( ::IsWindow( game->hWndScoreWindow ) )
    {
        ::PostMessage( game->hWndScoreWindow, WM_UPDATENAMES, 0, 0 );
    }
}

static void CloseScoreHistoryDialog(Game game)
{
    if ( ::IsWindow( game->hWndScoreWindow ) )
    {
        ::PostMessage( game->hWndScoreWindow, WM_CLOSE, 0, 0 );
    }
}

void AddScoreHistoryGameData( HWND hWnd, Game game )
{
    if ( !game->scoreHistory )
    {
        return;
    }
    HWND hWndList = GetDlgItem( hWnd, IDC_SCORES_HISTORY );
    LVITEM lvi;
    int nWinningScore, nScore;
    TCHAR szTemp[256];

    for ( int i=0; i < game->numHandsPlayed; i++ )
    {
        nWinningScore = 8000;
        // add the item
        lvi.iItem = i;
        lvi.mask = LVIF_TEXT|LVIF_IMAGE;
        lvi.iImage = zImageListIconBlank;
        _itot( lvi.iItem+1, szTemp, 10 );
        lvi.pszText = szTemp;
        lvi.iSubItem = 0;
        ListView_InsertItem( hWndList, &lvi );

        for ( int j=0; j < zNumPlayersPerTable; j++ )
        {
            nScore = game->scoreHistory[i*zNumPlayersPerTable+j];
            _itot( nScore, szTemp, 10 ); 
            lvi.iSubItem = j+1;

            // is this a lower score?
            if ( nScore < nWinningScore )
            {
                nWinningScore = nScore;    
            }
            ListView_SetItem( hWndList, &lvi );
        }
        lvi.mask = LVIF_IMAGE;
        // for everyone who has the winning score, give them a heart
        for ( j=0; j < zNumPlayersPerTable; j++ )
        {
            lvi.iSubItem = j+1;
            if ( game->scoreHistory[i*zNumPlayersPerTable+j] == nWinningScore )
            {
                lvi.iImage = zImageListIconHeart;
            }
            else
            {
                lvi.iImage = zImageListIconBlank;
            }
            ListView_SetItem( hWndList, &lvi );
        }
    }

}


INT_PTR CALLBACK ScoreHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	GameGlobals pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();

    BOOL fHandled = TRUE;
    LVCOLUMN lvc;
    HWND hWndList;
    TCHAR szHands[256];
    int i;
    Game game;

    if ( !ConvertMessage( hWnd, message, &wParam, &lParam ) )
    {
        return FALSE;
    }

    if(message != WM_INITDIALOG)
        game = (Game) GetWindowLong(hWnd, GWL_USERDATA);

    switch ( message )
    {
    case WM_INITDIALOG:
        game = (Game) lParam;
        SetWindowLong(hWnd, GWL_USERDATA, (long) game);

        if(game->m_hImageList)
            ImageList_Destroy(game->m_hImageList);
        game->m_hImageList = ImageList_Create( 16, 16, ILC_MASK, zNumImageListIcons, 0 );

        // keyboard accelators (what little we have)
        ZShellZoneShell()->AddDialog(hWnd, true);

        // create the image list for this dialog.
        for ( i=0; i < zNumImageListIcons; i++ )
        {
            HICON hIcon = ZShellResourceManager()->LoadImage(MAKEINTRESOURCE(IMAGELIST_ICONS[i]), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
            if ( !hIcon )
            {
                ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound );
                return FALSE;
            }
            ImageList_AddIcon(game->m_hImageList, hIcon);
        }

        hWndList = GetDlgItem( hWnd, IDC_SCORES_HISTORY );
        ListView_SetExtendedListViewStyle( hWndList, LVS_EX_SUBITEMIMAGES );
        ListView_SetImageList( hWndList, game->m_hImageList, LVSIL_SMALL );

        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvc.fmt = LVCFMT_LEFT;

        ZShellResourceManager()->LoadString( IDS_HISTORY_HANDS, szHands, NUMELEMENTS(szHands) );

		lvc.cx = GetScoreHistoryColumnWidth( hWnd, zHistoryDialogHandWidth, 65 );
		lvc.pszText = szHands;
		ListView_InsertColumn( hWndList, 0, &lvc );

		lvc.cx = GetScoreHistoryColumnWidth( hWnd, zHistoryDialogPlayerWidth, 100 );
		for ( i=0; i < zNumPlayersPerTable; i++ )
		{
			lvc.pszText = (game->seat == i ? gszString[zYou] : game->players[i].name);
			ListView_InsertColumn( hWndList, i+1, &lvc );
		}
        AddScoreHistoryGameData( hWnd, game );

        break;

    case WM_DESTROY:
        ZShellZoneShell()->RemoveDialog( hWnd, true );

        if(game->m_hImageList)
            ImageList_Destroy(game->m_hImageList);
        game->m_hImageList = NULL;

        break;

    case WM_CLOSE:
        DestroyWindow( hWnd );
        break;

    case WM_UPDATESCORES:
        hWndList = GetDlgItem( hWnd, IDC_SCORES_HISTORY );
        ListView_DeleteAllItems( hWndList );
        AddScoreHistoryGameData( hWnd, game );
        break;

    case WM_UPDATENAMES:
        hWndList = GetDlgItem( hWnd, IDC_SCORES_HISTORY );
        lvc.mask = LVCF_TEXT;
        for ( i=0; i < zNumPlayersPerTable; i++ )
        {
            lvc.pszText = (game->seat == i ? gszString[zYou] : game->players[i].name);
            ListView_SetColumn( hWndList, i+1, &lvc );
        }
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDCANCEL:
            DestroyWindow( hWnd );
            break;
        }
        break;
    default:
        fHandled = FALSE;
    }
    return fHandled;
}


#ifndef MILL_VER
static void OptionsButtonFunc(ZButton button, void* userData)
{
	GameGlobals			pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();

	int32 x;

	ShowOptions(I(userData));
}
#endif

static void ShowOptions(Game game)
{
#ifndef MILL_VER

	int16			i;
	ZBool			enabled, checked;
	
	
	game->optionsWindow = ZWindowNew();
	if (game->optionsWindow == NULL)
		goto OutOfMemoryExit;
	if (ZWindowInit(game->optionsWindow, &gOptionsRects[zRectOptions],
			zWindowDialogType, game->gameWindow, "Options", TRUE, FALSE, TRUE,
			OptionsWindowFunc, zWantAllMessages, game) != zErrNone)
		goto OutOfMemoryExit;
	
	// Create the check boxes. 
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		enabled = (i == game->seat) && !(game->tableOptions[i] & zRoomTableOptionTurnedOff);
		
		checked = !(game->tableOptions[i] & zRoomTableOptionNoKibitzing);
		if ((game->optionsKibitzing[i] = ZCheckBoxNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZCheckBoxInit(game->optionsKibitzing[i], game->optionsWindow,
				&gOptionsRects[gOptionsKibitzingRectIndex[i]], NULL, checked, TRUE, enabled,
				OptionsCheckBoxFunc, game) != zErrNone)
			goto OutOfMemoryExit;
		
		checked = !(game->tableOptions[i] & zRoomTableOptionNoJoining);
		if ((game->optionsJoining[i] = ZCheckBoxNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZCheckBoxInit(game->optionsJoining[i], game->optionsWindow,
				&gOptionsRects[gOptionsJoiningRectIndex[i]], NULL, checked, TRUE, enabled,
				OptionsCheckBoxFunc, game) != zErrNone)
			goto OutOfMemoryExit;
		
		checked = game->tableOptions[i] & zRoomTableOptionSilentKibitzing ? TRUE : FALSE;
		if ((game->optionsSilent[i] = ZCheckBoxNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZCheckBoxInit(game->optionsSilent[i], game->optionsWindow,
				&gOptionsRects[gOptionsSilentRectIndex[i]], NULL, checked, TRUE, enabled,
				OptionsCheckBoxFunc, game) != zErrNone)
			goto OutOfMemoryExit;
		
		checked = game->fIgnore[i];
		if ((game->optionsIgnore[i] = ZCheckBoxNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZCheckBoxInit(game->optionsIgnore[i], game->optionsWindow,
				&gOptionsRects[gOptionsIgnoreRectIndex[i]], NULL, checked, TRUE, i != game->seat,
				OptionsCheckBoxFunc, game) != zErrNone)
			goto OutOfMemoryExit;
		
		if ((game->optionsRemove[i] = ZButtonNew()) == NULL)
			goto OutOfMemoryExit;
		if (ZButtonInit(game->optionsRemove[i], game->optionsWindow,
				&gOptionsRects[gOptionsRemoveRectIndex[i]], zRemoveStr, TRUE,
				ZIsComputerPlayer(game->players[i].userID) == FALSE && i != game->seat && !game->fRatings,
				OptionsWindowButtonFunc, game) != zErrNone)
			goto OutOfMemoryExit;
	}
	
	if ((game->optionsBeep = ZCheckBoxNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZCheckBoxInit(game->optionsBeep, game->optionsWindow,
			&gOptionsRects[zRectOptionsBeep], zBeepOnTurnStr, game->beepOnTurn, TRUE, TRUE,
			OptionsCheckBoxFunc, game) != zErrNone)
		goto OutOfMemoryExit;
	
	if ((game->optionsAnimateCards = ZCheckBoxNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZCheckBoxInit(game->optionsAnimateCards, game->optionsWindow,
			&gOptionsRects[zRectOptionsAnimation], zAnimateCardsStr, game->animateCards, TRUE, TRUE,
			OptionsCheckBoxFunc, game) != zErrNone)
		goto OutOfMemoryExit;
	
	checked = (game->tableOptions[game->seat] & zHeartsOptionsHideCards) == 0 ? FALSE : TRUE;
	if ((game->optionsHideCards = ZCheckBoxNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZCheckBoxInit(game->optionsHideCards, game->optionsWindow,
			&gOptionsRects[zRectOptionsHideCards], zHideCardsStr, checked, TRUE, TRUE,
			OptionsCheckBoxFunc, game) != zErrNone)
		goto OutOfMemoryExit;
		
	// Create button. 
	if ((game->optionsWindowButton = ZButtonNew()) == NULL)
		goto OutOfMemoryExit;
	if (ZButtonInit(game->optionsWindowButton, game->optionsWindow,
			&gOptionsRects[zRectOptionsOkButton], "Done", TRUE,
			TRUE, OptionsWindowButtonFunc, game) != zErrNone)
		goto OutOfMemoryExit;
	ZWindowSetDefaultButton(game->optionsWindow, game->optionsWindowButton);
	
	// Make the window modal. 
	ZWindowModal(game->optionsWindow);
	
	goto Exit;

OutOfMemoryExit:
	ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	
Exit:
#endif	
	return;
}


static void OptionsWindowDelete(Game game)
{
	int16			i;
	
	
	if (game->optionsWindow != NULL)
	{
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			if (game->optionsKibitzing[i] != NULL)
				ZCheckBoxDelete(game->optionsKibitzing[i]);
			if (game->optionsJoining[i] != NULL)
				ZCheckBoxDelete(game->optionsJoining[i]);
			if (game->optionsSilent[i] != NULL)
				ZCheckBoxDelete(game->optionsSilent[i]);
			if (game->optionsRemove[i] != NULL)
				ZButtonDelete(game->optionsRemove[i]);
		}
	
		if (game->optionsBeep != NULL)
			ZCheckBoxDelete(game->optionsBeep);
	
		if (game->optionsAnimateCards != NULL)
			ZCheckBoxDelete(game->optionsAnimateCards);
	
		if (game->optionsHideCards != NULL)
			ZCheckBoxDelete(game->optionsHideCards);
	
		if (game->optionsWindowButton != NULL)
			ZButtonDelete(game->optionsWindowButton);
	
		if (game->optionsWindow != NULL)
			ZWindowDelete(game->optionsWindow);
		game->optionsWindow = NULL;
	}
}


static ZBool OptionsWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(game->optionsWindow);
			ZRectErase(game->optionsWindow, &message->drawRect);
			ZEndDrawing(game->optionsWindow);
			OptionsWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			OptionsWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void OptionsWindowUpdate(Game game, int16 seat)
{
	if (game->optionsWindow != NULL)
	{
		if (game->tableOptions[seat] & zRoomTableOptionNoKibitzing)
			ZCheckBoxUnCheck(game->optionsKibitzing[seat]);
		else
			ZCheckBoxCheck(game->optionsKibitzing[seat]);
		
		if (game->tableOptions[seat] & zRoomTableOptionNoJoining)
			ZCheckBoxUnCheck(game->optionsJoining[seat]);
		else
			ZCheckBoxCheck(game->optionsJoining[seat]);
		
		if (game->tableOptions[seat] & zRoomTableOptionSilentKibitzing)
			ZCheckBoxCheck(game->optionsSilent[seat]);
		else
			ZCheckBoxUnCheck(game->optionsSilent[seat]);

		if (game->fIgnore[seat])
			ZCheckBoxCheck(game->optionsIgnore[seat]);
		else
			ZCheckBoxUnCheck(game->optionsIgnore[seat]);
	}
}


static void OptionsWindowButtonFunc(ZButton button, void* userData)
{
	Game							game = I(userData);
	int16							i;
	ZHeartsMsgRemovePlayerRequest	removePlayer;
	
	
	if (button == game->optionsWindowButton)
	{
		/* Hide the window and send a close window message. */
		ZWindowNonModal(game->optionsWindow);
		ZWindowHide(game->optionsWindow);
		ZPostMessage(game->optionsWindow, OptionsWindowFunc, zMessageWindowClose, NULL, NULL,
				0, NULL, 0, game);
	}
	else
	{
		/* Check all remove buttons. */
		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			if (button == game->optionsRemove[i])
			{
				if (game->removePlayerPending == FALSE)
				{
					removePlayer.seat = game->seat;
					removePlayer.targetSeat = i;
					ZHeartsMsgRemovePlayerRequestEndian(&removePlayer);
					ZCRoomSendMessage(game->tableID, zHeartsMsgRemovePlayerRequest,
							(void*) &removePlayer, sizeof(removePlayer));
					
					game->removePlayerPending = TRUE;
				}
				else
				{
					ZShellGameShell()->ZoneAlert(zRemovePendingStr);
				}
			}
		}
	}
}


static void OptionsWindowDraw(Game game)
{
	int16			i;


	ZBeginDrawing(game->optionsWindow);

	ZSetFont(game->optionsWindow, (ZFont) ZGetStockObject(zObjectFontSystem12Normal));
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));

	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsKibitzingText],
			zTextJustifyCenter, zKibitzingStr);
	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsJoiningText],
			zTextJustifyCenter, zJoiningStr);
	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsSilent1Text],
			zTextJustifyCenter, zSilentStr);
	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsSilent2Text],
			zTextJustifyCenter, zKibitzingStr);
	ZDrawText(game->optionsWindow, &gOptionsRects[zRectOptionsIgnoreText],
			zTextJustifyCenter, zIgnoreStr);
	
	/* Draw player names. */
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorGray));
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		if (i != game->seat)
			ZDrawText(game->optionsWindow, &gOptionsRects[gOptionsNameRects[i]],
					zTextJustifyLeft, game->players[i].name);
	}
	ZSetForeColor(game->optionsWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));
	ZDrawText(game->optionsWindow, &gOptionsRects[gOptionsNameRects[game->seat]],
			zTextJustifyLeft, game->players[game->seat].name);
	
	ZEndDrawing(game->optionsWindow);
}


static void OptionsCheckBoxFunc(ZCheckBox checkBox, ZBool checked, void* userData)
{
	Game				game = (Game) userData;
	ZHeartsMsgOptions	msg;
	ZBool				optionsChanged = FALSE;
	int16 i;
	

	if (game->optionsKibitzing[game->seat] == checkBox)
	{
		if (checked)
			game->tableOptions[game->seat] &= ~zRoomTableOptionNoKibitzing;
		else
			game->tableOptions[game->seat] |= zRoomTableOptionNoKibitzing;
		optionsChanged = TRUE;
	}
	else if (game->optionsJoining[game->seat] == checkBox)
	{
		if (checked)  
			game->tableOptions[game->seat] &= ~zRoomTableOptionNoJoining;
		else if( !game->fVotingLock ) //only allow no joining if this isn't a rated game.
			game->tableOptions[game->seat] |= zRoomTableOptionNoJoining;

		if(game->fVotingLock)  //don't send any messages or change the icon
			return;
			
		optionsChanged = TRUE;
	}
	else if (game->optionsSilent[game->seat] == checkBox)
	{
		if (checked)
			game->tableOptions[game->seat] |= zRoomTableOptionSilentKibitzing;
		else
			game->tableOptions[game->seat] &= ~zRoomTableOptionSilentKibitzing;
		optionsChanged = TRUE;
	}
	else if (game->optionsBeep == checkBox)
	{
		game->beepOnTurn = checked;
	}
	else if (game->optionsAnimateCards == checkBox)
	{
		game->animateCards = checked;
	}
	else if (game->optionsHideCards == checkBox)
	{
		if (checked)
			game->tableOptions[game->seat] |= zHeartsOptionsHideCards;
		else
			game->tableOptions[game->seat] &= ~zHeartsOptionsHideCards;
		optionsChanged = TRUE;
	}
	else
	{
		for(i = 0; i < zNumPlayersPerTable; i++)
			if(game->optionsIgnore[i] == checkBox && i != game->seat)
				game->fIgnore[i] = checked;
	}
	
	if (optionsChanged)
	{
		msg.seat = game->seat;
		msg.options = game->tableOptions[game->seat];
		ZHeartsMsgOptionsEndian(&msg);
		ZCRoomSendMessage(game->tableID, zHeartsMsgOptions, &msg, sizeof(msg));
	}
}


/*******************************************************************************
	SHOW KIBITZER/JOINER WINDOW ROUTINES
*******************************************************************************/
static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point)
{
	int16			i, seat = -1;
	
	
	for (i = 0; i < zNumPlayersPerTable && seat == -1; i++)
	{
		if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][0]]) ||
				ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][1]]))
			seat = i;
	}
	
	return (seat);
}


static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point)
{
	int16				playerType = zGamePlayer;
	ZPlayerInfoType		playerInfo;
	int16				i;
	ZLListItem			listItem;
	ZRect				rect;


	if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, seat)][0]]))
	{
		if (game->playersToJoin[seat] != 0 && game->numKibitzers[seat] == 0)
			playerType = zGamePlayerJoiner;
		else if (game->numKibitzers[seat] > 0)
			playerType = zGamePlayerKibitzer;
	}
	else if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, seat)][1]]))
	{
		if (game->playersToJoin[seat] != 0 && game->numKibitzers[seat] != 0)
			playerType = zGamePlayerJoiner;
	}
	
	if (playerType != zGamePlayer)
	{
		if (game->showPlayerWindow != NULL)
			ShowPlayerWindowDelete(game);
		
		/* Create player list. */
		if (playerType == zGamePlayerJoiner)
		{
			game->showPlayerCount = 1;
			if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), 1)) == NULL)
				goto OutOfMemoryExit;
			ZCRoomGetPlayerInfo(game->playersToJoin[seat], &playerInfo);
			game->showPlayerList[0] = (TCHAR*) ZCalloc(1, lstrlen(playerInfo.userName) + 1);
			lstrcpy(game->showPlayerList[0], playerInfo.userName);
		}
		else
		{
			game->showPlayerCount = game->numKibitzers[seat];
			if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), game->numKibitzers[seat])) == NULL)
				goto OutOfMemoryExit;
			for (i = 0; i < game->showPlayerCount; i++)
			{
				if ((listItem = ZLListGetNth(game->kibitzers[seat], i, zLListAnyType)) != NULL)
				{
					ZCRoomGetPlayerInfo((ZUserID) ZLListGetData(listItem, NULL), &playerInfo);
					game->showPlayerList[i] = (TCHAR*) ZCalloc(1, lstrlen(playerInfo.userName) + 1);
					lstrcpy(game->showPlayerList[i], playerInfo.userName);
				}
			}
		}
		
		/* Create the window. */
		if ((game->showPlayerWindow = ZWindowNew()) == NULL)
			goto OutOfMemoryExit;
		ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight * game->showPlayerCount + 4);
		ZRectOffset(&rect, point->x, point->y);
		if (rect.right > gRects[zRectWindow].right)
			ZRectOffset(&rect, gRects[zRectWindow].right - rect.right, 0);
		if (rect.left < 0)
			ZRectOffset(&rect, -rect.left, 0);
		if (rect.bottom > gRects[zRectWindow].bottom)
			ZRectOffset(&rect, 0, gRects[zRectWindow].bottom - rect.bottom);
		if (rect.top < 0)
			ZRectOffset(&rect, -rect.top, 0);
		if (ZWindowInit(game->showPlayerWindow, &rect,
				zWindowPlainType, game->gameWindow, NULL, TRUE, FALSE, FALSE,
				ShowPlayerWindowFunc, zWantAllMessages, game)!= zErrNone)
			goto OutOfMemoryExit;
		ZWindowTrackCursor(game->showPlayerWindow, ShowPlayerWindowFunc, game);
	}

	goto Exit;

OutOfMemoryExit:
	ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	
Exit:
	
	return;
}


static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(game->showPlayerWindow);
			ZRectErase(game->showPlayerWindow, &message->drawRect);
			ZEndDrawing(game->showPlayerWindow);
			ShowPlayerWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonUp:
			ZWindowHide(game->showPlayerWindow);
			ZPostMessage(game->showPlayerWindow, ShowPlayerWindowFunc, zMessageWindowClose,
					NULL, NULL, 0, NULL, 0, game);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			ShowPlayerWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void ShowPlayerWindowDraw(Game game)
{
	int16			i;
	ZRect			rect;


	ZBeginDrawing(game->showPlayerWindow);

//	ZSetFont(game->showPlayerWindow, (ZFont) ZGetStockObject(zObjectFontApp9Normal));
	
	ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight);
	ZRectOffset(&rect, 0, 2);
	ZRectInset(&rect, 4, 0);
	for (i = 0; i < game->showPlayerCount; i++)
	{
		ZDrawText(game->showPlayerWindow, &rect, zTextJustifyLeft, game->showPlayerList[i]);
		ZRectOffset(&rect, 0, zShowPlayerLineHeight);
	}
	
	ZEndDrawing(game->showPlayerWindow);
}


static void ShowPlayerWindowDelete(Game game)
{
	int16			i;
	
	
	if (game->showPlayerList != NULL)
	{
		for (i = 0; i < game->showPlayerCount; i++)
			ZFree(game->showPlayerList[i]);
		ZFree(game->showPlayerList);
		game->showPlayerList = NULL;
	}
	
	if (game->showPlayerWindow != NULL)
	{
		ZWindowDelete(game->showPlayerWindow);
		game->showPlayerWindow = NULL;
	}
}



INT_PTR CALLBACK DossierDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	ZHeartsMsgDossierVote	voteMsg;
	HWND hwnd;

	Game game = (Game)GetWindowLong(hDlg,DWL_USER);
	if(game)
		voteMsg.seat = game->seat;
	
	switch(iMsg)
    {
        case WM_INITDIALOG:
            return TRUE;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				
                case IDYES:
					ASSERT(game);
					if(game == NULL)
						break;
					voteMsg.vote = zVotedYes;
               		ZHeartsMsgDossierVoteEndian(&voteMsg);
			     	ZCRoomSendMessage(game->tableID, zHeartsMsgDossierVote, (void*) &voteMsg,sizeof(voteMsg));

					hwnd = GetDlgItem(game->voteDialog,IDYES);
					if( hwnd != NULL )
					{
						EnableWindow(hwnd,FALSE);
					}
					hwnd = GetDlgItem(game->voteDialog,IDNO);
					if( hwnd != NULL )
					{
						EnableWindow(hwnd,TRUE);
					}

                    break;
                case IDNO:
	                ASSERT(game);
					if(game == NULL)
						break;
                	voteMsg.vote = zVotedNo;            
					ZHeartsMsgDossierVoteEndian(&voteMsg);
					ZCRoomSendMessage(game->tableID, zHeartsMsgDossierVote, (void*) &voteMsg,sizeof(voteMsg));

					hwnd = GetDlgItem(game->voteDialog,IDNO);
					EnableWindow(hwnd,FALSE);
					hwnd = GetDlgItem(game->voteDialog,IDYES);
					EnableWindow(hwnd,TRUE);

                    break;	
            }
            break;
     }

	return FALSE;
}


// helper function
static BOOL UIButtonInit( ZRolloverButton *pButton, Game game, ZRect *bounds, 
                   LPCTSTR pszText, ZRolloverButtonFunc func )
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    ZError err;
    ZRolloverButton rollover;
    rollover = ZRolloverButtonNew();

    if ( !rollover )
    {
        return FALSE;
    }
    err = ZRolloverButtonInit2( rollover, game->gameWindow, bounds, FALSE, FALSE,
                                gButtonIdle, gButtonHighlighted, gButtonSelected, gButtonDisabled, NULL,
                                pszText, NULL, func, (void *)game );

    if ( err != zErrNone )
    {
        ZRolloverButtonDelete( rollover );
        *pButton = NULL;
        return FALSE;
    }
	ZRolloverButtonSetMultiStateFont( rollover, gpButtonFont );

    *pButton = rollover;

    return TRUE;
}

static int HeartsFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... )
{
    int nRet;
    va_list list;
    TCHAR szFmt[1024];
    ZShellResourceManager()->LoadString(idMessage, szFmt, NUMELEMENTS(szFmt) );
    // our arguments really really really better be strings,
    // TODO: Figure out why FORMAT_MESSAGE_FROR_MODULE doesn't work.
    va_start( list, idMessage );
    nRet = FormatMessage( FORMAT_MESSAGE_FROM_STRING, szFmt, 
                          idMessage, 0, pszBuf, cchBuf, &list );
    va_end( list );     
    return nRet;
}

static ZBool LoadFontFromDataStore(LPHeartsColorFont* ccFont, TCHAR* pszFontName)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGameGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	IDataStore *pIDS = ZShellDataStoreUI(); 
	const TCHAR* tagFont [] = {zHearts, zFontRscTyp, pszFontName, NULL };
	
    tagFont[3] = zFontId;
	if ( FAILED( pIDS->GetFONT( tagFont, 4, &ccFont->m_zFont ) ) )
    {
        return FALSE;
    }

    tagFont[3] = zColorId;
	if ( FAILED( pIDS->GetRGB( tagFont, 4, &ccFont->m_zColor ) ) )
    {
        return FALSE;
    }
    // create the HFONT
	/*
	LOGFONT logFont;
	ZeroMemory(&logFont, sizeof(LOGFONT));
	logFont.lfCharSet = DEFAULT_CHARSET;
	logFont.lfHeight = -MulDiv(ccFont->m_zFont.lfHeight, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
	logFont.lfWeight = ccFont->m_zFont.lfWeight;
	logFont.lfItalic = FALSE;
	logFont.lfUnderline = FALSE;
	logFont.lfStrikeOut = FALSE;
	lstrcpy( logFont.lfFaceName, ccFont->m_zFont.lfFaceName );
	*/
    ccFont->m_hFont = ZCreateFontIndirect( &ccFont->m_zFont );
    if ( !ccFont->m_hFont )
    {
        return FALSE;
    }
    return TRUE;
}


static void MAKEAKEY(LPCTSTR dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3)
{  
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	lstrcpy( (TCHAR*)dest, gGameName );
	lstrcat( (TCHAR*)dest, _T("/") );
	lstrcat( (TCHAR*)dest, key1);
	lstrcat( (TCHAR*)dest, _T("/") );
	lstrcat( (TCHAR*)dest, key2);
	lstrcat( (TCHAR*)dest, _T("/") );
	lstrcat( (TCHAR*)dest, key3);
}


BOOL InitAccessibility(Game game, IGameGame *pIGG)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals) ZGetGameGlobalPointer();
#endif

	GACCITEM	listHeartsAccItems[zNumberAccItems]; 
    ZRect rect;
    ZRolloverButton but = NULL;
    long nArrows;

	// Load accelerator table defined in Rsc
	HACCEL hAccel = ZShellResourceManager()->LoadAccelerators(MAKEINTRESOURCE(IDR_HEARTS_ACCELERATOR));

	for(int i = 0; i < zNumberAccItems; i++)
	{
		CopyACC(listHeartsAccItems[i], ZACCESS_DefaultACCITEM);
        listHeartsAccItems[i].fGraphical = true;
        listHeartsAccItems[i].fEnabled = false;
        listHeartsAccItems[i].pvCookie = (void *) zAccRectButton;
        nArrows = ZACCESS_InvalidItem;

		switch(i)
		{
		    case zAccScore:
			    listHeartsAccItems[i].wID = IDC_SCORE_BUTTON;
//                nArrows = zAccAutoPlay;
                but = game->scoreButton;
			    break;

		    case zAccAutoPlay:
			    listHeartsAccItems[i].wID = IDC_AUTOPLAY_BUTTON;
//                nArrows = zAccStop;
                but = game->autoPlayButton;
			    break;

		    case zAccStop:
			    listHeartsAccItems[i].wID = IDC_STOP_BUTTON;
//                nArrows = zAccScore;
                but = game->autoPlayButton;
			    break;

		    case zAccPlay:
			    listHeartsAccItems[i].wID = IDC_PLAY_BUTTON;
//                nArrows = zAccLastTrick;
                but = game->playButton;
			    break;

		    case zAccLastTrick:
			    listHeartsAccItems[i].wID = IDC_LAST_TRICK_BUTTON;
//                nArrows = zAccDone;
                but = game->lastTrickButton;
			    break;

		    case zAccDone:
			    listHeartsAccItems[i].wID = IDC_DONE_BUTTON;
//                nArrows = zAccPlay;
                but = game->lastTrickButton;
			    break;

            case zAccHand:
                listHeartsAccItems[i].wID = IDC_HAND;
                listHeartsAccItems[i].eAccelBehavior = ZACCESS_FocusGroup;
                listHeartsAccItems[i].nArrowDown = i + 1;
                listHeartsAccItems[i].nArrowRight = i + 1;
                listHeartsAccItems[i].nArrowUp = ZACCESS_ArrowNone;
                listHeartsAccItems[i].nArrowLeft = ZACCESS_ArrowNone;
                listHeartsAccItems[i].pvCookie = (void *) zAccRectCard;
                break;

            // cards besides the first
		    default:
                listHeartsAccItems[i].fTabstop = false;
                listHeartsAccItems[i].nArrowUp = i - 1;
                listHeartsAccItems[i].nArrowLeft = i - 1;
                if(i < zAccHand + 12)
                {
                    listHeartsAccItems[i].nArrowDown = i + 1;
                    listHeartsAccItems[i].nArrowRight = i + 1;
                }
                else
                {
                    listHeartsAccItems[i].nArrowDown = ZACCESS_ArrowNone;
                    listHeartsAccItems[i].nArrowRight = ZACCESS_ArrowNone;
                }
                listHeartsAccItems[i].pvCookie = (void *) zAccRectCard;
			    break;
		}

        if(nArrows != ZACCESS_InvalidItem)
        {
            listHeartsAccItems[i].nArrowUp = nArrows;
            listHeartsAccItems[i].nArrowDown = nArrows;
            listHeartsAccItems[i].nArrowLeft = nArrows;
            listHeartsAccItems[i].nArrowRight = nArrows;
        }

        if(but)
        {
            ZRolloverButtonGetRect(but, &rect);
            listHeartsAccItems[i].rc.left = rect.left - 7;
            listHeartsAccItems[i].rc.top = rect.top - 4;
            listHeartsAccItems[i].rc.right = rect.right + 1;
            listHeartsAccItems[i].rc.bottom = rect.bottom + 1;
        }
	}

	CComQIPtr<IGraphicallyAccControl> pIGAC = pIGG;
	if(!pIGAC)
        return FALSE;

	gGAcc->InitAccG(pIGAC, ZWindowGetHWND(game->gameWindow), 0, game);

	// push the list of items to be tab ordered
	gGAcc->PushItemlistG(listHeartsAccItems, zNumberAccItems, 0, true, hAccel);

	return TRUE;
}


// accessibility callback functions
DWORD CGameGameHearts::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
    Game game = (Game) pvCookie;

    if(nIndex != ZACCESS_InvalidItem)
    {
        HWND hWnd = ZWindowGetHWND(((Game) pvCookie)->gameWindow);
        SetFocus(hWnd);

        int16 card = nIndex - zAccHand;
        if(nIndex >= zAccHand && nIndex < zAccHand + 13 && !game->cardsSelected[card] &&
            (rgfContext & ZACCESS_ContextKeyboard) && game->gameState == zGameStateWaitForPlay)  // need to select the card
        {
            UnselectCards(game);
		    game->cardsSelected[card] = TRUE;
	        UpdateHand(game);
        }
    }

	return 0;
}


DWORD CGameGameHearts::Select(long nIndex, DWORD rgfContext, void* pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    Game game = (Game) pvCookie;

    if(nIndex < zAccHand || nIndex >= zAccHand + 13)
        return Activate(nIndex, rgfContext, pvCookie);

    if(game->gameState != zGameStatePassCards && game->gameState != zGameStateWaitForPlay)
        return 0;

    if (game->gameState == zGameStateWaitForPlay &&
        game->numCardsInHand == game->numCardsDealt &&
        GetNumCardsSelected(game) == game->numCardsToPass)
        UnselectCards(game);

    int16 card = nIndex - zAccHand;

	if (game->cardsSelected[card])
	{
		game->cardsSelected[card] = FALSE;
	}
	else
	{
		if (game->gameState == zGameStateWaitForPlay)
			UnselectCards(game);
		game->cardsSelected[card] = TRUE;
	}

	game->lastClickedCard = zCardNone;

	UpdateHand(game);

	return 0;
}


// Activate gets called when an Alt-<accelerator> has been pressed.
DWORD CGameGameHearts::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = (Game) pvCookie;
    long wID = gGAcc->GetItemID(nIndex);

    // cards
    if(nIndex >= zAccHand && nIndex < zAccHand + 13)
    {
        if(game->gameState == zGameStatePassCards)
        {
            PlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
            return 0;
        }

		if (game->gameState == zGameStateWaitForPlay &&
			game->playerToPlay == game->seat &&
			game->autoPlay == FALSE &&
			game->animatingTrickWinner == FALSE &&
			game->lastTrickShowing == FALSE)
		{
			UnselectCards(game);
			PlayACard(game, nIndex - zAccHand);
		}

        return 0;
    }

    // big buttons with accelerators
    switch(wID)
    {
        case IDC_SCORE_BUTTON:
	        ScoreButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_AUTOPLAY_BUTTON:
	        ASSERT(!game->autoPlay);
		    AutoPlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_STOP_BUTTON:
	        ASSERT(game->autoPlay);
		    AutoPlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_PLAY_BUTTON:
	        PlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_LAST_TRICK_BUTTON:
	        ASSERT(!game->lastTrickShowing);
		    LastTrickButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_DONE_BUTTON:
	        ASSERT(game->lastTrickShowing);
		    LastTrickButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_CLOSE_BOX:
		    // Simulate timeout.
    	    if(game->gameState == zGameStateHandOver || game->gameState == zGameStateGameOver)
			    GameTimerFunc(game->timer, game);
            break;

        default:
            ASSERT(!"Should never hit this case.  Something is wrong.");
            break;
    }

	return 0;
}


DWORD CGameGameHearts::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
	return 0;
}


void CGameGameHearts::DrawFocus(RECT *prc, long nIndex, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    Game game = (Game) pvCookie;
    ZRect rect;

    if(!IsRectEmpty(&game->rcFocus))
    {
        WRectToZRect(&rect, &game->rcFocus);
        if(game->eFocusType == (DWORD) zAccRectClose)
        {
            if(ZWindowIsVisible(game->gameScoreWindow))
                ZWindowInvalidate(game->gameScoreWindow, &rect);
            if(ZWindowIsVisible(game->handScoreWindow))
                ZWindowInvalidate(game->handScoreWindow, &rect);
        }
        else
            ZWindowInvalidate(game->gameWindow, &rect);
    }

    if(prc)
    {
        CopyRect(&game->rcFocus, prc);
        game->eFocusType = (DWORD) gGAcc->GetItemCookie(nIndex);
        game->iFocus = nIndex;
    }
    else
    {
        SetRectEmpty(&game->rcFocus);
        game->iFocus = -1;
    }

    if(!IsRectEmpty(&game->rcFocus))
    {
        WRectToZRect(&rect, &game->rcFocus);
        if(game->eFocusType == (DWORD) zAccRectClose)
        {
            if(ZWindowIsVisible(game->gameScoreWindow))
                ZWindowInvalidate(game->gameScoreWindow, &rect);
            if(ZWindowIsVisible(game->handScoreWindow))
                ZWindowInvalidate(game->handScoreWindow, &rect);
        }
        else
            ZWindowInvalidate(game->gameWindow, &rect);
    }
}


void CGameGameHearts::DrawDragOrig(RECT *prc, long nIndex, void *pvCookie)
{
}


static void EnableAutoplayAcc(Game game, bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(!fEnable)
    {
        gGAcc->SetItemEnabled(false, IDC_AUTOPLAY_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_STOP_BUTTON, false, 0);
    }
    else
    {
        gGAcc->SetItemEnabled(game->autoPlay ? false : true, IDC_AUTOPLAY_BUTTON, false, 0);
        gGAcc->SetItemEnabled(game->autoPlay ? true : false, IDC_STOP_BUTTON, false, 0);
    }
}


static void EnableLastTrickAcc(Game game, bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(!fEnable)
    {
        gGAcc->SetItemEnabled(false, IDC_LAST_TRICK_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_DONE_BUTTON, false, 0);
    }
    else
    {
        gGAcc->SetItemEnabled(game->lastTrickShowing ? false : true, IDC_LAST_TRICK_BUTTON, false, 0);
        gGAcc->SetItemEnabled(game->lastTrickShowing ? true : false, IDC_DONE_BUTTON, false, 0);
    }
}


static void AccPop()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    while(gGAcc->GetStackSize() > 1)
        gGAcc->PopItemlist();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\client.h ===
#ifndef _REVERSICLIENT_H
#define _REVERSICLIENT_H

#include "frx.h"

#define I(object)					((Game) (object))
#define Z(object)					((ZCGame) (object))

#define zGameNameLen				63
#define zNumPlayersPerTable			2
#define zGameVersion				0x00010204
#define zRscOffset					13000 

#define zSmallStrLen				128
#define zMediumStrLen				512
#define zLargeStrLen				640

#define zShowPlayerWindowWidth		120
#define zShowPlayerLineHeight		12
#define	zDragSquareOutlineWidth		3
									
#define zCellWidth					37
#define zCellRealWidth				38		/* Added a grid line between cells. */

#define zReversiPieceImageWidth		zCellWidth
#define zReversiPieceImageHeight	zCellWidth
#define zReversiPieceSquareWidth	zCellRealWidth
#define zReversiPieceSquareHeight	zCellRealWidth

/* animation interval in 100ths of sec, time to animate flipping of pieces */
#define zAnimateInterval			15
#define zResultBoxTimeout			800 /*8 Sec*/

#define zNumFonts					3

#define zGameName					_T("Reversi")
#define zGameImageFileName			_T("rvseres.dll")

#define zReversiAccessibleComponents	65

/*---------- keys to read rsc control strings from ui.txt-----------*/

#define zKey_FontRscTyp				_T("Fonts")
#define zKey_FontId					_T("Font")
#define zKey_ColorId				_T("Color")
#define zKey_RESULTBOX				_T("ResultBox")
#define zKey_INDICATETURN			_T("IndicateTurn")
#define zKey_PLAYERNAME				_T("PlayerName")
#define zKey_ROLLOVERTEXT			_T("RolloverText")


/*------------ Strings loaded from resource------------------*/

static TCHAR gButtonResignStr[zSmallStrLen];
static TCHAR gYourTurnStr[zSmallStrLen];
static TCHAR gOppsTurnStr[zSmallStrLen];
static TCHAR gPlayerWinsStr[zSmallStrLen];
static TCHAR gDrawStr[zSmallStrLen];
//static TCHAR gIllegalMoveSynchErrorStr[zLargeStrLen];
static TCHAR gResignConfirmStr[ZONE_MaxString];
static TCHAR gResignConfirmStrCap[zLargeStrLen];


/*-------------- Text foreground colors------------------*/
static ZColor gPlayerTextColor = { 0, 255 ,204 ,102 }; 

/*--------- sound information -----------------*/
typedef struct
{
	TCHAR	SoundName[128];
	TCHAR	WavFile[MAX_PATH];
	ZBool	force_default_sound;
	ZBool	played;
} ZReversiSound;

enum
{
	zSndTurnAlert = 0,
	zSndIllegalMove,
	zSndPieceFlip,
	zSndWin,
	zSndLose,
	zSndDraw,
	zSndLastEntry
};

static ZReversiSound gSounds[ zSndLastEntry ] =
{
	{ _T("TurnAlert"),		_T(""), TRUE,	FALSE },
	{ _T("IllegalMove"),	_T(""), TRUE,	FALSE },
	{ _T("PieceFlip"),		_T(""), FALSE,	FALSE },
	{ _T("Win"),			_T(""), FALSE,	FALSE },
	{ _T("Lose"),			_T(""), FALSE,  FALSE },
	{ _T("Draw"),			_T(""), FALSE,	FALSE }
};


/*--------------- UI component positions -----------------------*/
static RECT     zCloseButtonRect =          { 343, 150, 354, 162 };
static RECT     zCloseButtonRectRTL =       { 187, 150, 198, 162 };

static ZRect	gQuitGamePromptRect = {0, 0, 280, 100};
static ZRect	gRects[] =	{
								{0, 0, 540, 360},
								{118, 28, 421, 331},
								{0, 50, 114, 74},
								{424, 309, 540, 333},
								{0, 26, 114, 50},
								{424, 285, 540, 309},
								{426, 227, 539, 263}, // sequence button
								{7, 314, 107, 334},
								{86, 77, 110, 101},
								{429, 258, 453, 282},
								{512, 4, 536, 28},
								{512, 30, 536, 54},
								{180, 149, 360, 209}, // result window rect
								{189, 154, 351, 204}, // result string rect
								{64, 160, 103, 199},
								{436, 160, 475, 199},
								{163, 336, 223, 358},
								{315, 336, 375, 358},
								{188, 338, 220, 356},
								{340, 338, 372, 356}
							};

enum
{
	zRectWindow,
	zRectCells,
	zRectName1,
	zRectName2,
	zRectNamePlate1,
	zRectNamePlate2,
	zRectSequenceButton,
	zRectOptionsButton,
	zRectKibitzer1,
	zRectKibitzer2,
	zRectHelp,
	zRectKibitzerOption,
	zRectResultBox,
	zRectResultBoxName,
	zRectMove1,
	zRectMove2,
	zRectCounterWhite,
	zRectCounterBlack,
	zRectCounterWhiteText,
	zRectCounterBlackText
};

static int16			gKibitzerRectIndex[] =	{
													zRectKibitzer1,
													zRectKibitzer2,
												};


static int16 gNameRects[] = { zRectName1, zRectName2 };
static int16 gNamePlateRects[] = { zRectNamePlate1, zRectNamePlate2 };

static int16 gCounterRects[] = { zRectCounterWhite, zRectCounterBlack };
static int16 gCounterTextRects[] = { zRectCounterWhiteText, zRectCounterBlackText };

static ZRect gHelpWindowRect = {0, 0, 400, 300};

static int16 gActEvt; //leonp - Big 535 flag for a mouse activation, prevents a piece from
					  //being played on an activate event.

/*---------------------- game Imags ----------------------------*/
enum
{
	zNumGameImages = 10,

	/* Game Images */
	zImageBackground = 0,
	zImageBlackPiece,
	zImageWhitePiece,
	zImageBlackPlate,
	zImageWhitePlate,
	zImageBlackMarker,
	zImageWhiteMarker,
	zImageCounterBlack,
	zImageCounterWhite,

	zImageResult,

	// For some reason whoever wrote this originally loads these images seperately so they aren't counted in zNumGameImages

	/* room images */
	zImageGameIdle,
	zImageGaming,
	
	/* button images */
	zImageButton
};

// Barna 091599
/*------------Rollover button states------------------*/
#define zNumRolloverStates 4
enum
{
	zButtonInactive = 0,
	zButtonActive,
	zButtonPressed,
	zButtonDisabled
};
// Barna 091599

/* -------- Game States -------- */
enum
{
	zGameStateNotInited = 0,
	zGameStateMove,
	zGameStateDragPiece,
	zGameStateGameOver,
	zGameStateKibitzerInit,
	zGameStateAnimatePiece,
	zGameStateWaitNew,
	zGameStateFinishMove,
};

/*---- Dynamic Font read from UI.TXT ---------*/
struct LPReversiColorFont
{
	HFONT			m_hFont;
	ZONEFONT		m_zFont;
    COLORREF		m_zColor;

    LPReversiColorFont() : m_hFont(NULL) { }
    ~LPReversiColorFont()
    {
        if(m_hFont)
            DeleteObject(m_hFont);
        m_hFont = NULL;
    }
};


/* -------- Dynamic Font Ids -------- */
enum{
	zFontResultBox,
	zFontIndicateTurn,
	zFontPlayerName
	//zFontRolloverText
};

/* -------- Game Prompt Cookies -------- */
enum{
	zQuitprompt,
	zResignConfirmPrompt
};


class CBadMoveDialog;

/* -------- Game Info -------- */
typedef struct
{
	int16			tableID;
	int16			seat;
	ZWindow			gameWindow;
	ZRolloverButton	sequenceButton;
	ZHelpButton		helpButton;
	ZBool			kibitzer;
	ZBool			ignoreMessages;
	TPlayerInfo		players[zNumPlayersPerTable];

	/* the reversi object */
	ZReversi reversi;

	/* Game Options */
	uint32			gameOptions;

	/* stuff used for dragging of pieces */
	ZOffscreenPort	offscreenSaveDragBackground;

	ZRect			rectSaveDragBackground;
	ZReversiPiece		dragPiece;
	ZPoint			dragPoint; /* current point of drag */
    bool            dragOn;

    // used for hiding drag while focus is visible
    bool            fLastPunted;
    bool            fLastPuntedSq;
    ZReversiSquare  sqLastPuntedSq;

	/* used for quick display of score */
	int16			finalScore; /* black wins,  white wins, draw */
	int16			whiteScore;
	int16			blackScore;


	/* -- stuff below here needs be transferred as game state to kibitzer */
	/* Current Game State Info */
	int16			gameState;
    int16			gameCloseReason;

	/* new game voting */
	ZBool			newGameVote[2];

	/* flag for beep sound after opponents move */
	ZBool			beepOnTurn;
	ZUserID			playersToJoin[zNumPlayersPerTable];
	int16			numKibitzers[zNumPlayersPerTable];
	ZLList			kibitzers[zNumPlayersPerTable];
	uint32			tableOptions[zNumPlayersPerTable];

	/* Show Player Items */
	ZWindow			showPlayerWindow;
	TCHAR**			showPlayerList;
	int16			showPlayerCount;

	/* stuff used for Animate of opponents piece move */
	ZReversiMove animateMove;
	ZReversiPiece animatePiece;
	int16 animateDx;
	int16 animateDy;
	int16 animateStepsLeft;
	ZTimer animateTimer;
	// Barna 091599
	ZTimer resultBoxTimer;

	//new ratings and move timeout flags
	ZBool					bStarted;
	ZBool					bEndLogReceived;
	ZBool					bOpponentTimeout;
	ZInfo					exitInfo;
	LPReversiColorFont		gReversiFont[zNumFonts];
	ZBool					bMoveNotStarted;

    CBadMoveDialog  *m_pBadMoveDialog;

	// Rectangles for accelerator
	RECT			m_FocusRect;
} GameType, *Game;


/*typedef struct
{
	ZWindow					ownerWindow;
	BYTE					msgTitle[zMediumStrLen];
	BYTE					msgText[zLargeStrLen];
	UINT					btnStytle;
	ZPromptResponseFunc		responseFunc;
	void*					userData;
} MsgBoxInfoType, *MsgBoxInfo;*/


#define ZReversiPieceImageNum(x) \
	((x) == zReversiPieceWhite ? \
			(zImageWhitePiece) : \
			(zImageBlackPiece) )
/* traslation for the seatId to the index for rectangles */
#define GetLocalSeat(game,seatId) (seatId - game->seat + zNumPlayersPerTable +1) % zNumPlayersPerTable

#define ZReversiPlayerIsWhite(g) ((g)->seat == zReversiPlayerWhite)
#define ZReversiPlayerIsBlack(g) ((g)->seat == zReversiPlayerBlack)
#define ZReversiPlayerIsMyMove(g) ((g)->seat == ZReversiPlayerToMove(g->reversi))

/* -------- Globals -------- */
#ifndef ZONECLI_DLL

static TCHAR			gGameDir[zGameNameLen + 1];
static TCHAR			gGameName[zGameNameLen + 1];
static TCHAR			gGameDataFile[zGameNameLen + 1];
static TCHAR			gGameServerName[zGameNameLen + 1];
static uint32			gGameServerPort;
static ZBool			gInited;
//static ZImage			gGameIdle;
//static ZImage			gGaming;
static ZImage			gGameImages[zNumGameImages];
static ZHelpWindow		gHelpWindow;
static ZFont			gTextBold9;
static ZFont			gTextBold12;
static ZColor			gWhiteColor;
static ZColor			gWhiteSquareColor;
static ZColor			gBlackSquareColor;
static ZOffscreenPort	gOffscreenBackground;
static ZOffscreenPort	gOffscreenGameBoard;
static ZBool			gActivated;
static ZImage			gSequenceImages[zNumRolloverStates];
static IGameShell*      gGameShell;
static IZoneMultiStateFont*	gpButtonFont;
static IGraphicalAccessibility *gReversiIGA;

static HBITMAP          gFocusPattern;
static HBRUSH           gFocusBrush;
static HPEN             gNullPen;


/* Bug Fix 212: flag indicating that game results bitmap should not be drawn */
static int16 gDontDrawResults = FALSE;

#endif


#ifdef ZONECLI_DLL

/* -------- Volatible Globals & Macros -------- */
typedef struct
{
	TCHAR			m_gGameDir[zGameNameLen + 1];
	TCHAR			m_gGameName[zGameNameLen + 1];
	TCHAR			m_gGameDataFile[zGameNameLen + 1];
	TCHAR			m_gGameServerName[zGameNameLen + 1];
	uint32			m_gGameServerPort;
	//ZImage			m_gGameIdle;
	//ZImage			m_gGaming;
	ZImage			m_gGameImages[zNumGameImages];
    ZImage          m_gButtonMask;
	ZFont			m_gTextBold9;
	ZFont			m_gTextBold12;
	ZBool			m_gInited;
	ZColor			m_gWhiteColor;
	ZColor			m_gWhiteSquareColor;
	ZColor			m_gBlackSquareColor;
	ZOffscreenPort	m_gOffscreenBackground;
	ZOffscreenPort	m_gOffscreenGameBoard;
	ZBool			m_gActivated;
	int16			m_gDontDrawResults;
	ZImage			m_gSequenceImages[zNumRolloverStates];
	LPReversiColorFont		m_gReversiFont[zNumFonts];
	IZoneMultiStateFont*	m_gpButtonFont;
	CComPtr<IGraphicalAccessibility> m_gReversiIGA;

    HBITMAP         m_gFocusPattern;
    HBRUSH          m_gFocusBrush;
    HPEN            m_gNullPen;
} GameGlobalsType, *GameGlobals;

#define gGameDir				(pGameGlobals->m_gGameDir)
#define gGameName				(pGameGlobals->m_gGameName)
#define gGameDataFile			(pGameGlobals->m_gGameDataFile)
#define gGameServerName			(pGameGlobals->m_gGameServerName)
#define gGameServerPort			(pGameGlobals->m_gGameServerPort)
//#define gGameIdle				(pGameGlobals->m_gGameIdle)
//#define gGaming					(pGameGlobals->m_gGaming)
#define gGameImages				(pGameGlobals->m_gGameImages)
#define gHelpWindow				(pGameGlobals->m_gHelpWindow)
#define gTextBold9				(pGameGlobals->m_gTextBold9)
#define gTextBold12				(pGameGlobals->m_gTextBold12)
#define gInited					(pGameGlobals->m_gInited)
#define gWhiteColor				(pGameGlobals->m_gWhiteColor)
#define gWhiteSquareColor		(pGameGlobals->m_gWhiteSquareColor)
#define gBlackSquareColor		(pGameGlobals->m_gBlackSquareColor)
#define gOffscreenBackground	(pGameGlobals->m_gOffscreenBackground)
#define gOffscreenGameBoard		(pGameGlobals->m_gOffscreenGameBoard)
#define gActivated				(pGameGlobals->m_gActivated)
#define gDontDrawResults		(pGameGlobals->m_gDontDrawResults)
#define gSequenceImages			(pGameGlobals->m_gSequenceImages)
#define gGameShell              (pGameGlobals->m_gGameShell)

#define gReversiFont			(pGameGlobals->m_gReversiFont)
#define gpButtonFont			(pGameGlobals->m_gpButtonFont)
#define gButtonMask				(pGameGlobals->m_gButtonMask)
#define gReversiIGA				(pGameGlobals->m_gReversiIGA)

#define gFocusPattern           (pGameGlobals->m_gFocusPattern)
#define gFocusBrush             (pGameGlobals->m_gFocusBrush)
#define gNullPen                (pGameGlobals->m_gNullPen)

#endif


/* -------- Internal Routine Prototypes -------- */
static bool HandleTalkMessage(Game game, ZReversiMsgTalk* msg);
static bool HandleMovePieceMessage(Game game, ZReversiMsgMovePiece* msg);
static bool HandleEndGameMessage(Game game, ZReversiMsgEndGame* msg);
static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage);
static void HandleButtonDown(ZWindow window, ZMessage* pMessage);
static void UpdatePlayers(Game game);
static void DrawPlayers(Game game, BOOL bDrawInMemory);
static void UpdateTable(Game game);
static void DrawTable(Game game, BOOL bDrawInMemory);
static void UpdateResultBox(Game game);
static void DrawBackground(Game game, ZRect* clipRect);
static void GameWindowDraw(ZWindow window, ZMessage *message);
static void QuitGamePromptFunc(int16 result, void* userData);
static void HelpButtonFunc(ZHelpButton helpButton, void* userData);
static void TakeBackMoveButtonFunc(ZButton button, void* userData);
static void GoForwardMoveButtonFunc(ZButton button, void* userData);

static ZBool SequenceButtonFunc(ZPictButton button, int16 state, void* userData);
static void ConfirmResignPrompFunc(int16 result, void* userData);
//static void ZPromptM(TCHAR* prompt,ZWindow parentWindow, UINT buttons, TCHAR* msgBoxTitle, ZPromptResponseFunc responseFunc, void* userData);
//static ZBool PromptMMessageFunc(void* pInfo, ZMessage* message);

static void GameExit(Game game);
static ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage);
static ZError LoadGameImages(void);
static void UpdateSquares(Game game, ZReversiSquare* squares);
static void DrawSquares(Game game, ZReversiSquare* squares);
static void DrawPiece(Game game, ZReversiSquare* sq, BOOL bDrawInMemory);
static void DrawResultBox(Game game, BOOL bDrawInMemory);
static void DrawMoveIndicator(Game game, BOOL bDrawInMemory);
static void DrawScores(Game game, BOOL bDrawInMemory);
static void UpdateMoveIndicator(Game game);
static void UpdateScores(Game game);
static ZBool ZReversiSquareFromPoint(Game game, ZPoint* point, ZReversiSquare* sq);
static void EndDragState(Game game);
static void EraseDragPiece(Game game);
static void DrawDragPiece(Game game, BOOL bDrawInMemory);
static void HandleIdleMessage(ZWindow window, ZMessage* pMessage);
static void HandleButtonUp(ZWindow window, ZMessage* pMessage);
static void UpdateDragPiece(Game game);
static void GetPieceRect(Game game, ZRect* rect, int16 col, int16 row);
static void GetPieceBackground(Game game, ZGrafPort window, ZRect* rectDest, int16 col, int16 row);
static void UpdateSquare(Game game, ZReversiSquare* sq);
static void FinishMoveUpdateStateHelper(Game game);
static void HandleGameStateReqMessage(Game game, ZReversiMsgGameStateReq* msg);
static void HandleGameStateRespMessage(Game game, ZReversiMsgGameStateResp* msg);
static void ReversiSetGameState(Game game, int16 state);
static bool HandleNewGameMessage(Game game, ZReversiMsgNewGame* msg);
static bool HandleVoteNewGameMessage(Game game, ZReversiMsgVoteNewGame* msg);
static void HandleMoveTimeout(Game game, ZReversiMsgMoveTimeout* msg);
static void HandleEndLogMessage(Game game, ZReversiMsgEndLog* msg);
static void HandlePlayersMessage(Game game, ZReversiMsgNewGame* msg);
static void ReversiInitNewGame(Game game);
static void ClearDragState(Game game);
static void ReversiEnterMoveState(Game game);

static void LoadRoomImages(void);
static ZBool GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
static void DeleteObjectsFunc(void);
static void SendNewGameMessage(Game game);

static void DisplayChange(Game game);

static void CloseGameFunc(Game game);

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point);
static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point);
static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message);
static void ShowPlayerWindowDraw(Game game);
static void ShowPlayerWindowDelete(Game game);

static void DrawJoinerKibitzers(Game game);
static void DrawOptions(Game game);
static void UpdateOptions(Game game);

static void EraseDragSquareOutline(Game game);
static void DrawDragSquareOutline(Game game);

static void StartDrag(Game game, ZReversiPiece piece, ZPoint point);
static void SaveDragBackground(Game game);

static void AnimateTimerProc(ZTimer timer, void* userData);
static void AnimateBegin(Game game);

static void ZInitSounds();
static void ZResetSounds();
static void ZStopSounds();
static void ZPlaySound( Game game, int idx, ZBool loop, ZBool once_per_game );

static ZBool LoadRolloverButtonImage(ZResource resFile, int16 dwResID, /*int16 dwButtonWidth,*/
							  ZImage rgImages[zNumRolloverStates]);
static void resultBoxTimerFunc(ZTimer timer, void* userData);

static ZBool LoadGameFonts();
static ZBool LoadFontFromDataStore(LPReversiColorFont* ccFont, TCHAR* pszFontName);
static void MAKEAKEY(LPTSTR dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3);
static int ReversiFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... );

static BOOL InitAccessibility(Game game, IGameGame *pIGG);
static void DrawFocusRectangle (Game game);
static void AddResultboxAccessibility();
static void RemoveResultboxAccessibility();

static void SuperRolloverButtonEnable(Game game, ZRolloverButton button);
static void SuperRolloverButtonDisable(Game game, ZRolloverButton button);
static void EnableBoardKbd(bool fEnable);

/**********************************************************************/


class CGameGameReversi : public CGameGameImpl<CGameGameReversi>,public IGraphicallyAccControl
{
public:
	BEGIN_COM_MAP(CGameGameReversi)
		COM_INTERFACE_ENTRY(IGameGame)
		COM_INTERFACE_ENTRY(IGraphicallyAccControl)
	END_COM_MAP()
// IGameGame
public:
    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars);
    STDMETHOD(GameOverReady)();
    STDMETHOD(GamePromptResult)(DWORD nButton, DWORD dwCookie);
    STDMETHOD_(HWND, GetWindowHandle)();

//IGraphicallyAccControl
	STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie);
    STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie);
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);
};

#endif _REVERSICLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) game main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 11, 1996.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/11/96	HI		Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:            
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\reverlib.cpp ===
/*
** Reversilib.c
*/

#include "zone.h"
#include "zonecrt.h"
#include "zonemem.h"
#include "reverlib.h"
#include "revermov.h"

#define ZReversiPlayerWhiteToMove(pReversi) (ZReversiStatePlayerToMove(&pReversi->state) == zReversiPlayerWhite)

typedef struct {
	ZReversiState state; 
	ZReversiState oldState;
	ZReversiSquare squaresChanged[12];
} ZReversiI;

ZBool ZReversiIsLegalMoveInternal(ZReversi reversi, ZReversiMoveTry *pTry);
void ZReversiStateEndian(ZReversiState* state);
void ZReversiIEndian(ZReversiI* pReversi, int16 conversion);
static void ZReversiCalcSquaresChanged(ZReversi reversi, ZReversiState* state0, ZReversiState* state1);

#if 1

ZReversiBoard gBoardStart =
{  
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceBlack,
	zReversiPieceWhite, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceWhite,
	zReversiPieceBlack, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,

	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
	zReversiPieceNone, zReversiPieceNone, zReversiPieceNone, zReversiPieceNone,
};

#else

/* initial board to test draw condition */
ZReversiBoard gBoardStart =
{  
	zReversiPieceBlack, zReversiPieceNone,  zReversiPieceWhite, zReversiPieceBlack,
	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,

	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,
	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,

	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,
	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,

	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,
	zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack, zReversiPieceBlack,

	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,
	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,

	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,
	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,

	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,
	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,

	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,
	zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite, zReversiPieceWhite,
};

#endif // test draw

/*-------------------------------------------------------------------------------*/
ZReversi ZReversiNew()
{
	ZReversiI* pReversi = (ZReversiI*)ZMalloc(sizeof(ZReversiI));

	return (ZReversi)pReversi;
}

void ZReversiDelete(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	ZFree(pReversi);
}

void ZReversiInit(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	/* required, boolean flags must be zero'd */
	z_memset(&pReversi->state,0,sizeof(ZReversiState));
	pReversi->state.player = zReversiPlayerBlack;
	z_memcpy((void*)pReversi->state.board, (void*)gBoardStart, sizeof(ZReversiBoard));
	pReversi->state.whiteScore = 2;
	pReversi->state.blackScore = 2;

	/* copy the new state */
	z_memcpy(&pReversi->oldState,&pReversi->state,sizeof(ZReversiState));
}

ZReversiPiece ZReversiPieceAt(ZReversi reversi, ZReversiSquare* pSquare)
/* returns id of piece at this square, return 0 if no piece */
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	return (pReversi->state.board[pSquare->row][pSquare->col]);
}

void ZReversiPlacePiece(ZReversi reversi, ZReversiSquare* pSquare, BYTE nPiece)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	pReversi->state.board[pSquare->row][pSquare->col] = nPiece;
}

int16 ZReversiPlayerToMove(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	return ZReversiStatePlayerToMove(&pReversi->state);
}


ZBool ZReversiIsLegalMoveInternal(ZReversi reversi, ZReversiMoveTry* pTry)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	/* check to see if it is legal */
	if (!ZReversiPieceCanMoveTo(pTry)) { 
		return FALSE; 
	}

	return TRUE;
}

ZBool ZReversiIsLegalMove(ZReversi reversi, ZReversiMove* pMove)
/* returns true if this is a legal move */
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	ZReversiMoveTry ZRMtry;
	ZBool rval;

	ZRMtry.move = *pMove;
	z_memcpy(&ZRMtry.state,&pReversi->state,sizeof(ZReversiState));
	rval = ZReversiIsLegalMoveInternal(reversi, &ZRMtry);
	return rval;
}

ZReversiSquare* ZReversiGetNextSquaresChanged(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	/* copy the current state */
	z_memcpy(&pReversi->oldState,&pReversi->state,sizeof(ZReversiState));

	ZReversiFlipNext(&pReversi->state);

	/* more to flip... if squaresChanges not empty */
	ZReversiCalcSquaresChanged(reversi,&pReversi->oldState, &pReversi->state);
	return pReversi->squaresChanged;
}

static void ZReversiCalcSquaresChanged(ZReversi reversi, ZReversiState* state0, ZReversiState* state1)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	int16 cnt;
	BYTE i,j;

	/* find the squares that changed so we can return them */
	cnt = 0;
	for (i = 0;i < 8;i ++) {
		for (j = 0; j < 8; j++) {
			if (state0->board[i][j] != state1->board[i][j]) {
				pReversi->squaresChanged[cnt].row = i;
				pReversi->squaresChanged[cnt].col = j;
				cnt++;
			}
		}
	}
	pReversi->squaresChanged[cnt].row = zReversiSquareNone;
	pReversi->squaresChanged[cnt].col = zReversiSquareNone;
}

void ZReversiEndGame(ZReversi reversi,  uint32 flags)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	pReversi->state.flags = flags;

	/* advance to next move, there will be none */
	ZReversiFinishMove(reversi);
}

ZBool ZReversiMakeMove(ZReversi reversi, ZReversiMove* pMove)
/* makes the given move, returns NULL if illegal */ 
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	ZReversiMoveTry ZRMtry;

	ZRMtry.move = *pMove;
	z_memcpy(&ZRMtry.state,&pReversi->state,sizeof(ZReversiState));
	ZRMtry.state.flags = 0;

	if (!ZReversiIsLegalMoveInternal(reversi, &ZRMtry)) {
		return FALSE;
	}

	/* copy the new state */
	z_memcpy(&pReversi->oldState,&pReversi->state,sizeof(ZReversiState));

	/* copy the new state */
	z_memcpy(&pReversi->state,&ZRMtry.state,sizeof(ZReversiState));

	return TRUE;
}

/* finish the MakeMove, allows for board changes */
/* caller should do ZReversiSetPiece to change piece type then call FinishMove */
/* must be called after each ZReversiMakeMove Call */
void ZReversiFinishMove(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	/* calc the next player to play, flags and score */
	ZReversiNextPlayer(&pReversi->state);

	return;
}

ZBool ZReversiGetLastMove(ZReversi reversi, ZReversiMove* move)
/* the argument moveNum is user visible move num, internally */
/* moves are counted twice as fast */
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	*move = pReversi->state.lastMove;
	return TRUE;
}

uint32 ZReversiGetFlags(ZReversi reversi)
/* returns the flags for the move */
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	return pReversi->state.flags;
}

ZBool ZReversiPlayerCanMove(ZReversi reversi, BYTE player)
/* returns the flags for the move */
{
	ZReversiI* pReversi = (ZReversiI*)reversi;

	return ZReversiLegalMoveExists(&pReversi->state,player);
}


ZBool ZReversiIsGameOver(ZReversi reversi, int16* score, int16* whiteScore, int16* blackScore)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	int16 	player = pReversi->state.player;
	ZBool	gameOver = FALSE;

	{
		uint32 flags;

		flags = ZReversiGetFlags(reversi);

		*whiteScore = pReversi->state.whiteScore;
		*blackScore = pReversi->state.blackScore;

		/* did the player resign or lose on time? */
		if ((zReversiFlagResign) & flags) {

			if (player == zReversiPlayerWhite) {
				*score = zReversiScoreWhiteWins;
			} else {
				*score = zReversiScoreBlackWins;
			}
			gameOver = TRUE;
		}

		if (zReversiFlagWhiteWins & flags) {
			*score = zReversiScoreWhiteWins;
			gameOver = TRUE;
		} else if (zReversiFlagBlackWins & flags) {
			gameOver = TRUE;
			*score = zReversiScoreBlackWins;
		} else if (zReversiFlagDraw & flags) {
			gameOver = TRUE;
			*score = zReversiScoreDraw;
		}

		
	}

	return gameOver;
}

void ZReversiStateEndian(ZReversiState* state)
{
	ZEnd16(&state->whiteScore);
	ZEnd16(&state->blackScore);
	ZEnd32(&state->flags);
}


void ZReversiIEndian(ZReversiI* pReversi, int16 conversion)
{
	ZReversiStateEndian(&pReversi->state);
}

int32 ZReversiGetStateSize(ZReversi reversi)
{
	ZReversiI* pReversi = (ZReversiI*)reversi;
	int32 size;

	size = sizeof(ZReversiI);
	return size;
}

void ZReversiGetState(ZReversi reversi, void* buffer)
{
	ZReversiI* pReversi = (ZReversiI*) reversi;
	TCHAR* p0 = (TCHAR*)buffer;
	TCHAR* p = p0;

	/* copy the ReversiI structure */
	z_memcpy((void*)p,(void*)pReversi,sizeof(ZReversiI));
	p += sizeof(ZReversiI);

	/* endianize the whole mess */
	ZReversiIEndian((ZReversiI*)p0, zEndianToStandard);
}

ZReversi ZReversiSetState(void* buffer)
{
	ZReversiI* pReversi = NULL;
	TCHAR* p = (TCHAR*)buffer;

	/* endianize the new reversi state */
	ZReversiIEndian((ZReversiI*) buffer, zEndianFromStandard); /* history assumed to follow ZReversiState */

	/* set the new state */
	pReversi = (ZReversiI*)ZMalloc(sizeof(ZReversiI));
	if (!pReversi){
		return NULL;
	}

	z_memcpy(pReversi,p,sizeof(ZReversiI));
	p += sizeof(ZReversiI);

	return (ZReversi)pReversi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) game main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 11, 1996.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/11/96	HI		Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\revermov.h ===
/*
** reversimov.h
**
** Various reversi movement stuff.
*/

typedef BYTE ZReversiBoard[8][8];

typedef struct {
	ZReversiMove lastMove;
	ZReversiBoard board;
	uint32 flags; /* flags such zReversiFlagCheck, zReversiFlagPromote */
	BYTE player; /* player to move */
	BYTE flipLevel;
	ZBool directionFlippedLastTime[9];
	int16 whiteScore;
	int16 blackScore;
} ZReversiState;

typedef struct {
	ZReversiMove move;
	ZReversiState state;
} ZReversiMoveTry;

#define ZReversiStatePlayerToMove(state) ((state)->player)

ZBool ZReversiPieceCanMoveTo(ZReversiMoveTry* pTry);
ZBool ZReversiFlipNext(ZReversiState* state);
ZBool ZReversiSquareEqual(ZReversiSquare *pSquare0, ZReversiSquare *pSquare1);
void ZReversiNextPlayer(ZReversiState* state);
ZBool ZReversiLegalMoveExists(ZReversiState* state, BYTE player);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\reversi.cpp ===
/*******************************************************************************

	Reversi.c
	
		The client reversi game.
		
		Notes:
		1.	The game window's userData field contains the game object.
			Dereference this value to access needed information.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Kevin Binkley
	Created on Saturday, July 15, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	23		04/12/98	CHB		Added score reporting, fixed drag when regaining focus,
								fixed DrawResultBox after resignation.
	22		06/30/97	leonp	Patch for bug 535 cancel drag has a different effect in 
								reversi than other board games.  Set flag after a mouse activate
								event to preven a piece from being played.
    21		06/19/97	leonp	Fixed bug 535, activate event cause dragging of
								pieces to be canceled
	20		01/15/97	HI		Fixed bug in HandleJoinerKibitzerClick() to
								delete the show player window if one already
								exists before creating another one.
	19		12/18/96	HI		Cleaned up ZoneClientExit().
	18		12/18/96	HI		Cleaned up DeleteObjectsFunc().
	17		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
								Removed MSVCRT dependency.
	16		11/21/96	HI		Use game information from gameInfo in
								ZoneGameDllInit().
	15		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
								Modified code to use ZONECLI_DLL.
	14		11/15/96	HI		Removed authentication stuff from ZClientMain().
	13		10/29/96	CHB		Removed selected queueing of messages.  It now
								queues everything except talk while animating.

	12		10/27/96	CHB		Removed FinishMove messages.  Fixed StateReq
								message processing so it deals with previously
								queued messages.

	11		10/26/96	CHB		Removed gAnimating flag in favor of blocking
								messages based on game state.

	10		10/23/96	HI		Modified ZClientMain() for the new commandline
								format.

    9       10/23/96    HI      Changed serverAddr from int32 to char* in
                                ZClientMain().

	8		10/23/96	CHB		Added basic sounds

	7		10/21/96	CHB		Added gAnimating flag and changed ZCGameProcessMessage
								to queue messages while animating moves.
								(ZoneBugs 339, 446, and 341).

	6		10/16/96	CHB		Changed DrawResultBox to use piece counts instead
								of finalScore.  It now correctly reports tie games.
								(Zone Bug 321)

	5		10/11/96	HI		Added controlHandle parameter to ZClientMain().

    4		10/10/96	CHB		Added gActivated flag so that dragging is turned
								off when the window looses focus.  (Zone Bug 250)

	3		10/09/96	CHB		Prompt users if they really want to exit the
								game.  (Zone Bug 227)

	2		10/08/96	CHB		Added gDontDrawResults flag allowing users to
								remove the who wins bitmap by clicking in 
								the play arena. (Zone Bug 212)

	0		04/15/96	KJB		Created.
	 
*******************************************************************************/

#include <windows.h>
#include <mmsystem.h>

#include "zone.h"
#include "zroom.h"
#include "zonecli.h"
#include "zonecrt.h"
#include "zonehelpids.h"
#include "zoneresource.h"

#include "reverlib.h"
#include "revermov.h"
#include "reversi.h"
#include "reversires.h"
#include "zdialogimpl.h"

#include "ZRollover.h"
#include "ResourceManager.h"
#include "zui.h"

#include "KeyName.h"

#include "client.h"


/* dialog */
class CBadMoveDialog : public CDialog
{
public:
    CBadMoveDialog() : m_hParent(NULL) { }

	HRESULT Init(IZoneShell* pZoneShell, int nResourceId, HWND hParent)
    {
        if(IsDialogDisabled())
            return S_FALSE;

        HRESULT hr = CDialog::Init(pZoneShell, nResourceId);
        if(FAILED(hr))
            return hr;

        m_hParent = hParent;
        return S_OK;
    }

	BEGIN_DIALOG_MESSAGE_MAP(CBadMoveDialog);
		ON_MESSAGE(WM_INITDIALOG, OnInitDialog);
		ON_DLG_MESSAGE(WM_COMMAND, OnCommand);
        ON_DLG_MESSAGE(WM_DESTROY, OnDestroy);
	END_DIALOG_MESSAGE_MAP();

protected:
	BOOL OnInitDialog(HWND hWndFocus)
	{
        if(IsWindow(m_hParent))
        {
	        CenterWindow(m_hParent);
            EnableWindow(m_hParent, FALSE);
        }

		CheckDlgButton(m_hWnd, IDC_COMFORT, BST_CHECKED);
		return TRUE;
	}

	void OnCommand(int id, HWND hwndCtl, UINT codeNotify)
	{
        if(id == IDC_COMFORT)
        {
            const TCHAR *rgszKey[] = { key_Lobby, key_SkipSecondaryQuestion };
            ZShellDataStorePreferences()->SetLong(rgszKey, 2, IsDlgButtonChecked(m_hWnd, IDC_COMFORT) == BST_CHECKED ? 0 : 1);
        }
        else
            Close(1);
	}

    void OnDestroy()
    {
        if(IsWindow(m_hParent))
	        EnableWindow(m_hParent, TRUE);
        m_hParent = NULL;
    }

	bool IsDialogDisabled()
	{
		const TCHAR* arKeys[] = { key_Lobby, key_SkipSecondaryQuestion };
		long fSkip = 0;

		ZShellDataStorePreferences()->GetLong(arKeys, 2, &fSkip);

		return fSkip ? true : false;
	}

    HWND m_hParent;
};

/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

ZError ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals;


	pGameGlobals = new GameGlobalsType;
    // changed to new for CComPtr, but members still count on being zeroed out
    ZeroMemory(pGameGlobals, sizeof(GameGlobalsType));

	if (pGameGlobals == NULL)
		return (zErrOutOfMemory);
	ZSetGameGlobalPointer(pGameGlobals);

	pGameGlobals->m_gDontDrawResults = FALSE;
#endif

	lstrcpyn((TCHAR*)gGameDir, gameInfo->game, zGameNameLen);
	lstrcpyn((TCHAR*)gGameName, gameInfo->gameName, zGameNameLen);
	lstrcpyn((TCHAR*)gGameDataFile, gameInfo->gameDataFile, zGameNameLen);
	lstrcpyn((TCHAR*)gGameServerName, gameInfo->gameServerName, zGameNameLen);
	gGameServerPort = gameInfo->gameServerPort;

	return (zErrNone);
}


void ZoneGameDllDelete(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();


	if (pGameGlobals != NULL)
	{
		ZSetGameGlobalPointer(NULL);
		delete pGameGlobals;
	}
#endif
}


ZError ZoneClientMain(BYTE *commandLineData, IGameShell *piGameShell)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;

	// Get the IGraphicalAccessibility interface
	HRESULT hret = ZShellCreateGraphicalAccessibility(&gReversiIGA);
	if (!SUCCEEDED (hret))
        return zErrLaunchFailure;

//	ZInitSounds();
	LoadRoomImages();

	err = ZClient2PlayerRoom((TCHAR*)gGameServerName, (uint16) gGameServerPort, (TCHAR*)gGameName,
			GetObjectFunc, DeleteObjectsFunc, NULL);
	
	gInited = FALSE;
	gActivated = TRUE;

	return (err);
}

void ZoneClientExit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16 i;

	ZCRoomExit();

	if (gInited)
	{
		if (gOffscreenBackground != NULL)
			ZOffscreenPortDelete(gOffscreenBackground);
		gOffscreenBackground = NULL;
		
		if (gOffscreenGameBoard != NULL)
			ZOffscreenPortDelete(gOffscreenGameBoard);
		gOffscreenGameBoard = NULL;
		
		if (gTextBold9 != NULL)
			ZFontDelete(gTextBold9);
		gTextBold9 = NULL;
		if (gTextBold12 != NULL)
			ZFontDelete(gTextBold12);
		gTextBold12 = NULL;
		
		/* Delete all game images. */
		for (i = 0; i < zNumGameImages; i++)
		{
			if (gGameImages[i] != NULL)
				ZImageDelete(gGameImages[i]);
			gGameImages[i] = NULL;
		}
		for (i = 0; i < zNumRolloverStates; i++)
		{
			if (gSequenceImages[i] != NULL)
				ZImageDelete(gSequenceImages[i]);
			gSequenceImages[i] = NULL;
		}

        gReversiIGA.Release();

        if(gNullPen)
            DeleteObject(gNullPen);
        gNullPen = NULL;

        if(gFocusPattern)
            DeleteObject(gFocusPattern);
        gFocusPattern = NULL;

        if(gFocusBrush)
            DeleteObject(gFocusBrush);
        gFocusBrush = NULL;

        gpButtonFont->Release();

		gInited = FALSE;
	}
}


TCHAR* ZoneClientName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	return ((TCHAR*)gGameName);
}


TCHAR* ZoneClientInternalName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	return ((TCHAR*)gGameDir);
}


ZVersion ZoneClientVersion(void)
{
	return (zGameVersion);
}

void ZoneClientMessageHandler(ZMessage* message)
{
}

ZError		GameInit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError		err = zErrNone;
	HINSTANCE		hinstance;
	ZImage	tempImage;
	gInited = TRUE;
	
	ZSetColor(&gWhiteSquareColor, 200, 200, 80);
	ZSetColor(&gBlackSquareColor, 0, 60, 0);

	ZSetCursor(NULL, zCursorBusy);
	
	err = LoadGameImages();
	if (err != zErrNone)
		goto Exit;
	
	/* Create bold text font. */	
	//gTextBold9 = ZFontNew();
	//ZFontInit(gTextBold9, zFontApplication, zFontStyleBold, 9);
	
	/* Create normal text font. */	
	//gTextBold12 = ZFontNew();
	//ZFontInit(gTextBold12, zFontApplication, zFontStyleBold, 12);

	/* Set the background color */
	ZSetColor(&gWhiteColor, 0xff, 0xff, 0xff);
	
	ZSetCursor(NULL, zCursorArrow);

	/* create a background bitmap */
	gOffscreenBackground = ZOffscreenPortNew();
	if (gOffscreenBackground){
		ZOffscreenPortInit(gOffscreenBackground,&gRects[zRectWindow]);
		ZBeginDrawing(gOffscreenBackground);
		ZImageDraw(gGameImages[zImageBackground], gOffscreenBackground, &gRects[zRectWindow], NULL, zDrawCopy);
		ZEndDrawing(gOffscreenBackground);
	}
	else{
		err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	}

	/* initialised the offscreen  buffer to hold the image of the game board when a game window is being drawn*/
	gOffscreenGameBoard = ZOffscreenPortNew();
	if (gOffscreenGameBoard){
		ZOffscreenPortInit(gOffscreenGameBoard,&gRects[zRectWindow]);
	}
	else{
		err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	}

	// Load strings
	if (!ZShellResourceManager()->LoadString(IDS_BUTTON_RESIGN,(TCHAR*)gButtonResignStr,NUMELEMENTS(gButtonResignStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_YOUR_TURN, (TCHAR*)gYourTurnStr, NUMELEMENTS(gYourTurnStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_OPPONENTS_TURN, (TCHAR*)gOppsTurnStr, NUMELEMENTS(gOppsTurnStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_PLAYER_WINS, (TCHAR*)gPlayerWinsStr, NUMELEMENTS(gPlayerWinsStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_DRAW, (TCHAR*)gDrawStr, NUMELEMENTS(gDrawStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	//if (!ZShellResourceManager()->LoadString(IDS_ILLEGALMOVESYNCHERROR, (TCHAR*)gIllegalMoveSynchErrorStr, NUMELEMENTS(gIllegalMoveSynchErrorStr)))
		//ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_RESIGN_CONFIRM, (TCHAR*)gResignConfirmStr, NUMELEMENTS(gResignConfirmStr)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
	if (!ZShellResourceManager()->LoadString(IDS_RESIGN_CONFIRM_CAPTION, (TCHAR*)gResignConfirmStrCap, NUMELEMENTS(gResignConfirmStrCap)))
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);

	LoadGameFonts();

    // create focus brush
    gFocusBrush = CreatePatternBrush(gFocusPattern);
    if(!gFocusBrush)
    {
        err = zErrOutOfMemory;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		goto Exit;
    }

    gNullPen = CreatePen(PS_NULL, 0, 0);
	
Exit:
	return (err);
}


IGameGame* ZoneClientGameNew(ZUserID userID, int16 tableID, int16 seat, int16 playerType,
					ZRoomKibitzers* kibitzers)
	/*
		Instantiates a new game on the client side of the game at table and from the
		given seat. PlayerType indicates the type of player for the game: originator - one
		of the original players, joiner - one who joins an ongoing game, or kibitzer - one
		who is kibitzing the game. Also, the kibitzers parameters contains all the kibitzers
		at the given table and seat; it includes the given player also if kibitzing.
	*/
{	
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
	ClientDllGlobals	pClientGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	Game g = (Game)ZMalloc(sizeof(GameType));
	int16 i;
	TCHAR title[80];
	ZBool kibitzer = playerType == zGamePlayerKibitzer;
    HRESULT hr;
    IGameGame *pIGG;

	HWND OCXHandle = pClientGlobals->m_OCXHandle;
	if (gInited == FALSE)
	{
		if (GameInit() != zErrNone)
			return (NULL);
	}
	
	if (!g)
		return NULL;

	g->tableID = tableID;
	g->seat = seat;

    g->m_pBadMoveDialog = new CBadMoveDialog;
    if(!g->m_pBadMoveDialog)
        goto ErrorExit;

	g->gameWindow = ZWindowNew();
	if (g->gameWindow == NULL)
		goto ErrorExit;

	if ((ZWindowInit(g->gameWindow, &gRects[zRectWindow], zWindowChild, NULL, zGameName, 
						FALSE, FALSE, FALSE, GameWindowFunc, zWantAllMessages, (void*) g)) != zErrNone)
		goto ErrorExit;


	if((g->sequenceButton = ZRolloverButtonNew()) == NULL)
		goto ErrorExit;

	/*if(ZRolloverButtonInit(g->sequenceButton,
								g->gameWindow,
								&gRects[zRectSequenceButton],
								TRUE,TRUE,
								gSequenceImages[zButtonInactive], // TO TEST
								gSequenceImages[zButtonActive],
								gSequenceImages[zButtonPressed],
								gSequenceImages[zButtonDisabled],NULL ,SequenceButtonFunc,
								(void*) g) != zErrNone)*/
	if(ZRolloverButtonInit2(g->sequenceButton,
								g->gameWindow,
								&gRects[zRectSequenceButton],
								TRUE, FALSE, //TRUE,TRUE,
								gSequenceImages[zButtonInactive], // TO TEST
								gSequenceImages[zButtonActive],
								gSequenceImages[zButtonPressed],
								gSequenceImages[zButtonDisabled],
								NULL , //gButtonMask, 	// mask
								(TCHAR*)gButtonResignStr,	// text
								NULL ,SequenceButtonFunc,
								(void*) g) != zErrNone)
		goto ErrorExit;
	ZRolloverButtonSetMultiStateFont( g->sequenceButton, gpButtonFont );

	g->bMoveNotStarted = FALSE;
	//g->sequenceButton = ZButtonNew();
	//ZButtonInit(g->sequenceButton, g->gameWindow, &gRects[zRectSequenceButton], gButtonResignStr , TRUE, TRUE,
	//		SequenceButtonFunc, (void*) g);

	/* the offscreen port to save the drag piece background */
	{
		ZRect rect;
		rect.left = 0; rect.top = 0;
		rect.right = zReversiPieceImageWidth;
		rect.bottom = zReversiPieceImageHeight;
		g->offscreenSaveDragBackground = ZOffscreenPortNew();
		if (g->offscreenSaveDragBackground)
			ZOffscreenPortInit(g->offscreenSaveDragBackground,&rect);
		else
			goto ErrorExit;
	}

	/* for now, just set these to empty */
	/* we will get all this information in NewGame */

	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		g->players[i].userID = 0;
		g->players[i].name[0] = '\0';
		g->players[i].host[0] = '\0';
		
		g->playersToJoin[i] = 0;
		g->numKibitzers[i] = 0;
		g->kibitzers[i] = ZLListNew(NULL);
		
		g->tableOptions[i] = 0;
	}
		
	if (kibitzers != NULL)
	{
		uint16 i;

		for (i = 0; i < kibitzers->numKibitzers; i++)
		{
			ZLListAdd(g->kibitzers[kibitzers->kibitzers[i].seat], NULL,
					(void*) kibitzers->kibitzers[i].userID,
					(void*) kibitzers->kibitzers[i].userID, zLListAddLast);
			g->numKibitzers[kibitzers->kibitzers[i].seat]++;
		}
	}

	/* initialize beep on move to false */
	g->beepOnTurn = FALSE;

	g->kibitzer = kibitzer;
	g->ignoreMessages = FALSE;

	if (kibitzer == FALSE)
	{
		SendNewGameMessage(g);
		ReversiSetGameState(g,zGameStateNotInited);
	} else {
		/* Request current game state. */
		{
			ZReversiMsgGameStateReq gameStateReq;
			ZPlayerInfoType			playerInfo;

			ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
			gameStateReq.userID = playerInfo.playerID;

			gameStateReq.seat = seat;
			ZReversiMsgGameStateReqEndian(&gameStateReq);
			ZCRoomSendMessage(tableID, zReversiMsgGameStateReq, &gameStateReq, sizeof(ZReversiMsgGameStateReq));
		}
		
		g->ignoreMessages = TRUE;
		ReversiSetGameState(g, zGameStateKibitzerInit);

		/* kibitzer does not beep on move */
		g->beepOnTurn = FALSE;
	}


	/* Note: for now, use seat to indicate player color */

	/* initialize new game state */
	g->reversi = NULL;

	g->showPlayerWindow = NULL;
	g->showPlayerList = NULL;

	g->bStarted=FALSE;
	g->bEndLogReceived=FALSE;
	g->bOpponentTimeout=FALSE;
	g->exitInfo=NULL;
	/* new game vote initialized to FALSE */
	{
		int i;

		for (i = 0;i <2; i++ ) {
			g->newGameVote[i] = FALSE;
		}
	}

	g->animateTimer = ZTimerNew();
	if (!g->animateTimer)
		goto ErrorExit;

	g->resultBoxTimer = ZTimerNew();
	if (!g->resultBoxTimer)
		goto ErrorExit;

    SetRectEmpty(&g->m_FocusRect);
	
	ZWindowShow(g->gameWindow);

    pIGG = CGameGameReversi::BearInstance(g);
    if(!pIGG)
        goto ErrorExit;

	if (InitAccessibility(g, pIGG) == FALSE)
        goto ErrorExit;

	return pIGG;

ErrorExit:
    ZFree(g);
	return NULL;
}


void		ZoneClientGameDelete(ZCGame cgame)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game game = I(cgame);
	int i;
	int16 seatOpponent;

	if (game != NULL)
	{
		if (game->exitInfo)
		{
			ZInfoDelete(game->exitInfo);
			game->exitInfo=NULL;
		};

        // kill this dialog
        if(game->m_pBadMoveDialog)
        {
    	    if(game->m_pBadMoveDialog->IsAlive())
	    	    game->m_pBadMoveDialog->Close(-1);
            delete game->m_pBadMoveDialog;
            game->m_pBadMoveDialog = NULL;
        }

		seatOpponent = !game->seat;
		//Check to see if opponent still in game
		//if they are then it is me who is quitting
		//if not and no end game message assume they aborted
		
		/*
		if (!ZCRoomGetSeatUserId(game->tableID,seatOpponent) && !game->bEndLogReceived 
			&& !game->kibitzer)
		{
            if (game->bStarted &&( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ) )
            {
			    ZAlert( zAbandonRatedStr	,game->gameWindow);
            }
            else
            {
                ZAlert( (TCHAR*)gAbandonStr	,game->gameWindow);
            }

		};*/	
        
        if (game->reversi) ZReversiDelete(game->reversi);

		ShowPlayerWindowDelete(game);

		ZRolloverButtonDelete(game->sequenceButton);
		
		ZWindowDelete(game->gameWindow);

		ZOffscreenPortDelete(game->offscreenSaveDragBackground);

		if (game->animateTimer) ZTimerDelete(game->animateTimer);

		// Barna 091599
		if (game->resultBoxTimer) 
			ZTimerDelete(game->resultBoxTimer);
		game->resultBoxTimer= NULL;

		for (i = 0; i < zNumPlayersPerTable; i++)
		{
			ZLListDelete(game->kibitzers[i]);
		}
		// free accessibility stuff
		gReversiIGA->PopItemlist();
		gReversiIGA->CloseAcc();
		ZFree(game);
	}
}

ZBool		ZoneClientGameProcessMessage(ZCGame gameP, uint32 messageType, void* message,
					int32 messageLen)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game	game = I(gameP);
	ZBool	status = TRUE;
	
	/* Are messages being ignored? */
	if (game->ignoreMessages == FALSE)
	{
		/* can't handle anything but talk messages while animating */
		if (	(game->gameState == zGameStateAnimatePiece) 
			&&	(messageType != zReversiMsgTalk) )
			return FALSE;

		switch (messageType)
		{
			case zReversiMsgMovePiece:
				/* for speed purposes, we will send move piece messages directly*/
				/* when the local player moves.  We will not wait for server */
				/* to send game local players move back */
				/* but since the server does game anyway, we must ignore it */
			{
				if( messageLen < sizeof( ZReversiMsgMovePiece ) )
				{
                    ASSERT(!"zReversiMsgMovePiece sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				ZReversiMsgMovePiece* msg = (ZReversiMsgMovePiece*)message;
				int16 seat = msg->seat;
				ZEnd16(&seat);

				/* don't process message from ourself */
				if (seat == game->seat && !game->kibitzer)
					break;

				/* handle message */
				if(!HandleMovePieceMessage(game, msg))
				{
                    ASSERT(!"zReversiMsgMovePiece sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}
			case zReversiMsgEndGame:
			{
				if( messageLen < sizeof( ZReversiMsgEndGame ) )
				{
                    ASSERT(!"zReversiMsgEndGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				ZReversiMsgEndGame* msg = (ZReversiMsgEndGame*)message;
				int16 seat = msg->seat;
				ZEnd16(&seat);

				/* don't process message from ourself */
				if (seat == game->seat && !game->kibitzer)
					break;

				/* handle message */
				if(!HandleEndGameMessage(game, msg))
				{
                    ASSERT(!"zReversiMsgEndGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}
			case zReversiMsgNewGame:
			{
				if( messageLen < sizeof( ZReversiMsgNewGame ) )
				{
                    ASSERT(!"zReversiMsgNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				if(!HandleNewGameMessage(game, (ZReversiMsgNewGame *) message))
				{
                    ASSERT(!"zReversiMsgNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				gActEvt = 0; //leonp - Big 535 flag for a mouse activation, prevents a piece from
							 //being played on an activate event.
				break;
			}
			case zReversiMsgVoteNewGame:
			{
				if( messageLen < sizeof( ZReversiMsgVoteNewGame ) )
				{
                    ASSERT(!"zReversiMsgVoteNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

				if(!HandleVoteNewGameMessage(game, (ZReversiMsgVoteNewGame *) message))
				{
                    ASSERT(!"zReversiMsgVoteNewGame sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			case zReversiMsgTalk:
			{
				if( messageLen < sizeof( ZReversiMsgTalk ) )
				{
                    ASSERT(!"zReversiMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}

                ZReversiMsgTalk *msg = (ZReversiMsgTalk *) message;
                uint16 talklen = msg->messageLen;
                ZEnd16(&talklen);

				if(talklen < 1 || (uint32) messageLen < talklen + sizeof(ZReversiMsgTalk) || !HandleTalkMessage(game, msg))
				{
                    ASSERT(!"zReversiMsgTalk sync");
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                    return TRUE;
				}
				break;
			}

			//None of these messages should be used.
			case zReversiMsgMoveTimeout:
			case zReversiMsgEndLog:
			case zReversiMsgGameStateReq:
			case zGameMsgTableOptions:
			default:
				ASSERT(false);
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				break;					
		}
	} 
	else 
	{
        if(messageType == zReversiMsgTalk)
		{
			if( messageLen < sizeof( ZReversiMsgTalk ) )
			{
                ASSERT(!"zReversiMsgTalk sync");
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                return TRUE;
			}

            ZReversiMsgTalk *msg = (ZReversiMsgTalk *) message;
            uint16 talklen = msg->messageLen;
            ZEnd16(&talklen);

			if(talklen < 1 || (uint32) messageLen < talklen + sizeof(ZReversiMsgTalk) || !HandleTalkMessage(game, msg))
			{
                ASSERT(!"zReversiMsgTalk sync");
    			ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);	
                return TRUE;
			}
		}
        else
        {
    		//Not used in Millenium code
	    	ASSERT(false);
		    ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
        }
	}

	return status;
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static void ReversiInitNewGame(Game game)
{
	if (game->reversi) {
		/* remove any old reversi state lying around */
		ZReversiDelete(game->reversi);
	}

	/* block messages by default */
	ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );

	/* stop animation timer from previous game */
	if (game->animateTimer)
		ZTimerSetTimeout( game->animateTimer, 0 );

	/* initialize the reversi logic */
	game->reversi = ZReversiNew();
	if (game->reversi == NULL){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return;
	}
	ZReversiInit(game->reversi);
			
	/* initialize game state information */
	ZReversiIsGameOver(game->reversi,&game->finalScore,&game->whiteScore, &game->blackScore);

	/* reset sounds that only play once per game */
	ZResetSounds();

	/* time control stuff */
	{
		int16 i;
		for (i = 0;i < 2;i++) {
			game->newGameVote[i] = FALSE;
		}
	}
}

static void ReversiSetGameState(Game game, int16 state)
{
	static int Unblocking = FALSE;

	ZReversiMsgEndLog logMsg;

	switch (state) {
	case zGameStateNotInited:
        // kill this dialog
    	if(game->m_pBadMoveDialog->IsAlive())
	    	game->m_pBadMoveDialog->Close(-1);

		SuperRolloverButtonDisable(game, game->sequenceButton);
        EnableBoardKbd(false);
		if (ZReversiPlayerIsBlack(game))
			game->bMoveNotStarted = TRUE;
		break;
	case zGameStateDragPiece:
	case zGameStateMove:
		if (!game->kibitzer) 
		{
			/* lets only let them resign on their turn */
			if (!ZReversiPlayerIsMyMove(game)) {
				SuperRolloverButtonDisable(game, game->sequenceButton);
                EnableBoardKbd(false);
			} else {
				if(game->bMoveNotStarted)
					SuperRolloverButtonDisable(game, game->sequenceButton);
				else
					SuperRolloverButtonEnable(game, game->sequenceButton);
                EnableBoardKbd(true);
			}
		}
		break;
	case zGameStateGameOver:
		/* Note: could be called twice at end of game due to time loss */
		/* could be a time loss with a pawn promotion dialog up */

        // kill this dialog
    	if(game->m_pBadMoveDialog->IsAlive())
	    	game->m_pBadMoveDialog->Close(-1);

		/* if user in middle of dragging piece */
		if (game->gameState == zGameStateDragPiece) {
			ClearDragState(game);
		}

        game->bOpponentTimeout=FALSE;
        game->bEndLogReceived=FALSE;
	    game->bStarted=FALSE;
			
		if (ZReversiPlayerIsBlack(game))
			game->bMoveNotStarted = TRUE;

		/* host sends game results */
		if ( !game->kibitzer && game->seat == 0 )
		{
			/* clear message */
			ZeroMemory( &logMsg, sizeof(logMsg) );

			/* record winner */
			if ( game->finalScore == zReversiScoreBlackWins )
			{
				/* black wins */
				if (ZReversiPlayerIsBlack(game))
					logMsg.seatLosing = !game->seat;
				else
					logMsg.seatLosing = game->seat;
			}
			else if ( game->finalScore == zReversiScoreWhiteWins )
			{
				/* white wins */
				if (ZReversiPlayerIsWhite(game))
					logMsg.seatLosing = !game->seat;
				else
					logMsg.seatLosing = game->seat;
			} 
			else
			{
				/* draw */
				logMsg.seatLosing = 2;
			}

			/* record piece counts */
			if ( ZReversiPlayerIsBlack(game) )
			{
				logMsg.pieceCount[ game->seat ] = game->blackScore;
				logMsg.pieceCount[ !game->seat ] = game->whiteScore;
			}
			else
			{
				logMsg.pieceCount[ game->seat ] = game->whiteScore;
				logMsg.pieceCount[ !game->seat ] = game->blackScore;
			}

            /* send message */
			if ( logMsg.seatLosing >= 0 && logMsg.seatLosing <= 2)
			{
				logMsg.reason=zReversiEndLogReasonGameOver; 
				ZReversiMsgEndLogEndian( &logMsg );
				ZCRoomSendMessage( game->tableID, zReversiMsgEndLog, &logMsg, sizeof(logMsg) );
			}
		}
		break;
	case zGameStateKibitzerInit:
		ZRolloverButtonHide(game->sequenceButton, FALSE);
		break;
	case zGameStateAnimatePiece:
		break;
	case zGameStateWaitNew:
        // kill this dialog
    	if(game->m_pBadMoveDialog->IsAlive())
	    	game->m_pBadMoveDialog->Close(-1);

		ZWindowInvalidate( game->gameWindow, NULL );
		break;
	case zGameStateFinishMove:
		break;
	}
	game->gameState = state;

	if (	(state != zGameStateAnimatePiece)
		&&	(state != zGameStateWaitNew))
	{
		/* recursive calls into ZCRoomUnblocking is bad */
		if (!Unblocking)
		{
			Unblocking = TRUE;
			ZCRoomUnblockMessages( game->tableID );
			Unblocking = FALSE;
			ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );
		}
	}
	else
	{
		ZCRoomBlockMessages( game->tableID, zRoomFilterAllMessages, 0 );
	}

}

static void ReversiEnterMoveState(Game game)
{
	/* for the player to move, always place them in the DragState */
	int16 player = ZReversiPlayerToMove(game->reversi);
	if (player == game->seat && !game->kibitzer) {
		ZPoint point;
		ZReversiPiece piece;
		
		piece = player == zReversiPlayerWhite ? zReversiPieceWhite : zReversiPieceBlack;
		ZGetCursorPosition(game->gameWindow,&point);
		ReversiSetGameState(game,zGameStateDragPiece);
		StartDrag(game, piece, point);
	} else {
		/* not this players turn.. .just go to the Move state */
		ReversiSetGameState(game,zGameStateMove);
	}
}

static ZError LoadGameImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;
	uint16				i;
	ZResource			resFile;
	ZInfo				info;
	ZRect				rect;

	//info = ZInfoNew();
	//ZInfoInit(info, NULL, _T("Loading game images ..."), 200, TRUE, zNumGameImages);
	
	resFile = ZResourceNew();
	if ((err = ZResourceInit(resFile, ZGetProgramDataFileName(zGameImageFileName))) == zErrNone)
	{
		//ZInfoShow(info);
		
		for (i = 0; i < zNumGameImages; i++)
		{
			gGameImages[i] = ZResourceGetImage(resFile,  i ? i + zRscOffset : (IDB_BACKGROUND - 100));
			if (gGameImages[i] == NULL)
			{
				err = zErrResourceNotFound;
				ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
				//ZAlert(_T("Out of memory."),NULL);
				break;
			}
			
			//ZInfoIncProgress(info, 1);
		}
		
		// Load button images
		if (!LoadRolloverButtonImage(resFile, 0, gSequenceImages))
			ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);

		ZResourceDelete(resFile);
	}
	else
	{
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("Failed to open image file."), NULL);
	}
	
    gFocusPattern = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCE(IDB_FOCUS_PATTERN));
    if(!gFocusPattern)
	    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, true, true);


	//ZInfoDelete(info);

	return (err);
}

static void QuitGamePromptFunc(int16 result, void* userData)
{
	Game game = (Game) userData;
	ZReversiMsgEndLog log;

    if ( result == zPromptYes )
	{
        if (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
        {

		    if (game->bOpponentTimeout && (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ))
		    {
			    log.reason=zReversiEndLogReasonTimeout;
		    }
		    else if (game->bStarted && (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ))
		    {
			    log.reason=zReversiEndLogReasonForfeit;
		    }
		    else
		    {
			    //game hasn't started
			    log.reason=zReversiEndLogReasonWontPlay;
		    }
		    
            if (log.reason!= game->gameCloseReason)
            {
                //state has changed
                CloseGameFunc(game);
                return;
            }
		    //server determines seat losing
		    log.seatLosing=game->seat;
		    log.seatQuitting=game->seat;
		    
		    ZCRoomSendMessage(game->tableID, zReversiMsgEndLog, &log, sizeof(log));				
		    
		    if (!game->exitInfo)
		    {
			    //game->exitInfo = ZInfoNew();
			    //ZInfoInit(game->exitInfo , game->gameWindow, _T("Exiting game ..."), 300, FALSE, 0);
			    //ZInfoShow(game->exitInfo );

			    EndDragState(game);

			    SuperRolloverButtonDisable(game, game->sequenceButton);
                EnableBoardKbd(false);	    
		    };
        }
        else
        {
			ZShellGameShell()->GameCannotContinue(game);
            //ZCRoomGameTerminated( game->tableID);
        }
	}
	else
	{
		/* Do nothing. */
	}
}


static ZBool  GameWindowFunc(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZBool	msgHandled;
	ZReversiSquare		sq;
	Game	game = (Game) pMessage->userData;
	
	msgHandled = FALSE;
	
	switch (pMessage->messageType) 
	{
		case zMessageWindowMouseClientActivate:  
			gActivated = TRUE;
			msgHandled = TRUE;
            if(game->gameState == zGameStateDragPiece)
			    UpdateDragPiece(game);
			break;
		case zMessageWindowActivate:
			gActivated = TRUE;
			msgHandled = TRUE;
            if(game->gameState == zGameStateDragPiece)
			    UpdateDragPiece(game);
            //Bug fix for #16921, now behaves like checkers
			ZWindowInvalidate( window, NULL );
			break;
		case zMessageWindowDeactivate:
			gActivated = FALSE;
            msgHandled = TRUE;
            if(game->gameState == zGameStateDragPiece)
			    UpdateDragPiece(game);
            //Bug fix for #16921, now behaves like checkers
			ZWindowInvalidate( window, NULL );
			break;

        case zMessageWindowEnable:
            gReversiIGA->GeneralEnable();
            break;

        case zMessageWindowDisable:
            gReversiIGA->GeneralDisable();
            break;

        case zMessageSystemDisplayChange:
            DisplayChange(game);
            break;

		case zMessageWindowDraw:
			GameWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
			HandleButtonDown(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
            CloseGameFunc(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowTalk:
			GameSendTalkMessage(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowIdle:
			HandleIdleMessage(window,pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowChar:
			if (game->gameState == zGameStateGameOver && !gDontDrawResults)
			{
				gDontDrawResults = TRUE;
				ZWindowInvalidate( game->gameWindow, NULL );
			}
			break;
	}
	
	return (msgHandled);
}


// all offscreen ports need to be regenerated
static void DisplayChange(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    // delete our personal offscreen ports
	if(gOffscreenBackground)
		ZOffscreenPortDelete(gOffscreenBackground);
	gOffscreenBackground = NULL;

	if(gOffscreenGameBoard)
		ZOffscreenPortDelete(gOffscreenGameBoard);
	gOffscreenGameBoard = NULL;

    // drag background
	ZOffscreenPortDelete(game->offscreenSaveDragBackground);

    // now remake them all
	gOffscreenBackground = ZOffscreenPortNew();
	if(!gOffscreenBackground)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gOffscreenBackground, &gRects[zRectWindow]);
	ZBeginDrawing(gOffscreenBackground);
	ZImageDraw(gGameImages[zImageBackground], gOffscreenBackground, &gRects[zRectWindow], NULL, zDrawCopy);
	ZEndDrawing(gOffscreenBackground);

	gOffscreenGameBoard = ZOffscreenPortNew();
	if(!gOffscreenGameBoard)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gOffscreenGameBoard, &gRects[zRectWindow]);

	ZRect rect;
	rect.left = 0;
    rect.top = 0;
	rect.right = zReversiPieceImageWidth;
	rect.bottom = zReversiPieceImageHeight;
    game->offscreenSaveDragBackground = ZOffscreenPortNew();
	if(!game->offscreenSaveDragBackground)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(game->offscreenSaveDragBackground, &rect);

    ZWindowInvalidate(game->gameWindow, NULL);
}


static void CloseGameFunc(Game game)
{
    if ( !game->kibitzer )
	{
		TCHAR szBuff[512];

		//if we already clicked close just ignore
		if (!game->exitInfo)
		{
			// select exit dialog based on rated game and state
			/*if ( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
			{
				if (game->bOpponentTimeout)
                {
					wsprintf((TCHAR*)szBuff,zExitTimeoutStr);
                    game->gameCloseReason=zReversiEndLogReasonTimeout;
                }
				else if (game->bStarted)
                {
					wsprintf((TCHAR*)szBuff,zExitForfeitStr);
                    game->gameCloseReason=zReversiEndLogReasonForfeit;
                }
				else
                {
					wsprintf((TCHAR*)szBuff,(TCHAR*)gQuitGamePromptStr);
                    game->gameCloseReason=zReversiEndLogReasonWontPlay;

                }
			}
            else
            {
                wsprintf((TCHAR*)szBuff,(TCHAR*)gQuitGamePromptStr);
                game->gameCloseReason=zReversiEndLogReasonWontPlay;
            }*/
			/* Ask user if desires to leave the current game. */
			ZShellGameShell()->GamePrompt(game, (TCHAR*)szBuff, NULL, AlertButtonYes, AlertButtonNo, NULL, 0, zQuitprompt);
			/*ZPrompt((TCHAR*)szBuff, &gQuitGamePromptRect,	game->gameWindow, TRUE,
									zPromptYes | zPromptNo,	NULL, NULL,	NULL, QuitGamePromptFunc, game );*/
		}
	}
	else
	{
		ZShellGameShell()->GameCannotContinue(game);
		//ZCRoomGameTerminated( game->tableID);
	}
		
}

static void ConfirmResignPrompFunc(int16 result, void* userData)
{
	Game game = (Game) userData;

	if(result == IDNO || result == IDCANCEL)
	{
		if ((game->gameState == zGameStateMove) && ZReversiPlayerIsMyMove(game))
		{
			SuperRolloverButtonEnable(game, game->sequenceButton);
            EnableBoardKbd(true);
		}
		return;
	}
	else
	{
		/* send message announcing resignation */
		ZReversiMsgEndGame		msg;

		msg.seat = game->seat;
		msg.flags = zReversiFlagResign;
		ZReversiMsgEndGameEndian(&msg);
		ZCRoomSendMessage(game->tableID, zReversiMsgEndGame, &msg, sizeof(ZReversiMsgEndGame));
		HandleEndGameMessage(game, (ZReversiMsgEndGame*)&msg);
	}
}

static ZBool	SequenceButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game	game;
	//if ( state != zRolloverButtonDown )
        //return TRUE;
	if(state!=zRolloverButtonClicked)
		return TRUE;

	game = (Game) userData;

	switch (game->gameState) {
	case zGameStateDragPiece:
	case zGameStateMove:
		if (ZReversiPlayerIsMyMove(game) && !(game->kibitzer))
		{
			gReversiIGA->SetFocus(64);
			ZShellGameShell()->GamePrompt(game, (TCHAR*)gResignConfirmStr, (TCHAR*)gResignConfirmStrCap,
							AlertButtonYes, AlertButtonNo, NULL, 0, zResignConfirmPrompt);
			//ZPromptM((TCHAR*)gResignConfirmStr,game->gameWindow, MB_YESNO, (TCHAR*)gResignConfirmStrCap, ConfirmResignPrompFunc, game);		
		}
		break;
	case zGameStateGameOver:
	default:
		ZShellGameShell()->ZoneAlert(_T("Bad state when Option button pressed"));
		break;
	}

	return TRUE;
}

static void SendNewGameMessage(Game game) 
{
	/* if we are a real player */
	ZReversiMsgNewGame newGame;
	newGame.seat = game->seat;
	newGame.protocolSignature = zReversiProtocolSignature;
	newGame.protocolVersion = zReversiProtocolVersion;
	newGame.clientVersion = ZoneClientVersion();
	ZReversiMsgNewGameEndian(&newGame);
	ZCRoomSendMessage(game->tableID, zReversiMsgNewGame, &newGame, sizeof(ZReversiMsgNewGame));
}

static void DrawFocusRectangle (Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	RECT prc;
	if (!IsRectEmpty(&game->m_FocusRect))
	{
		CopyRect(&prc, &game->m_FocusRect);
		HDC	hdc = ZGrafPortGetWinDC( game->gameWindow );
        bool fBoard = (prc.bottom - prc.top == prc.right - prc.left);

        // hack for determining if the rectangle is around the resign button - keep it white in that case
        // based on whether the focus rectangle is square.  could change to use cookies associated with ui items to distinguish type
		ZSetForeColor(game->gameWindow, (ZColor*) ZGetStockObject((game->seat && fBoard) ? zObjectColorBlack : zObjectColorWhite));
		SetROP2(hdc, R2_COPYPEN);
		POINT pts [] = {prc.left, prc.top,
						prc.left, prc.bottom - 1,
						prc.right - 1, prc.bottom - 1,
						prc.right - 1, prc.top,
						prc.left, prc.top};
		Polyline(hdc, pts, 5);

        SetBkMode(hdc, TRANSPARENT);
		SetROP2(hdc, game->seat ? R2_MASKPEN : R2_MERGENOTPEN);
        COLORREF color = SetTextColor(hdc, RGB(0, 0, 0));
        HBRUSH hBrush = SelectObject(hdc, fBoard ? gFocusBrush : GetStockObject(NULL_BRUSH));
        HPEN hPen = SelectObject(hdc, gNullPen);
		Rectangle(hdc, game->m_FocusRect.left + 1, game->m_FocusRect.top + 1, game->m_FocusRect.right, game->m_FocusRect.bottom);  // to make up for the pen - 1 inward
        SelectObject(hdc, hBrush);
        SelectObject(hdc, hPen);
        SetTextColor(hdc, color);
        SetROP2(hdc, R2_COPYPEN);
	}
}

static void GameWindowDraw(ZWindow window, ZMessage *message)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect				rect;
	ZRect				oldClipRect;
	Game				game;
	
	game = (Game) message->userData;
	
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		ZWindowGetRect(window, &rect);
		ZRectOffset(&rect, (int16)-rect.left, (int16)-rect.top);
	}

	ZBeginDrawing(window);
	ZBeginDrawing(gOffscreenGameBoard);
			
	ZGetClipRect(window, &oldClipRect);
	ZSetClipRect(window, &rect);
	
	DrawBackground(NULL, NULL);
	
	/* if we have the reversi state then draw the pieces */
	if (game->reversi != NULL)
	{
		DrawPlayers(game, TRUE);
		DrawTable(game, TRUE);
		DrawOptions(game);
//		DrawDragPiece(game, TRUE);  you can't do this haha as if
		DrawResultBox(game, TRUE);
		DrawMoveIndicator(game, TRUE);
		DrawScores(game, TRUE);
		ZRolloverButtonShow(game->sequenceButton);
	}
	ZCopyImage(gOffscreenGameBoard, window, &rect, &rect, NULL, zDrawCopy);
	ZEndDrawing(gOffscreenGameBoard);
    if(game->gameState == zGameStateDragPiece)
    {
        SaveDragBackground(game);
        UpdateDragPiece(game);
    }
	DrawFocusRectangle(game);
	ZSetClipRect(window, &oldClipRect);
	ZEndDrawing(window);
}

static void DrawResultBox(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage		image = NULL;
	TCHAR		resultStr[zMediumStrLen];

	//if (((game->gameState == zGameStateGameOver) && gDontDrawResults) ||(game->gameState == zGameStateWaitNew)){
	if (game->gameState == zGameStateGameOver && gDontDrawResults){
		if (game->resultBoxTimer) 
			ZTimerDelete(game->resultBoxTimer);
		game->resultBoxTimer= NULL;

        ZShellGameShell()->GameOver( Z(game) );
	}
	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		if ( game->finalScore == zReversiScoreBlackWins )
		{
			ReversiFormatMessage((TCHAR*)resultStr, NUMELEMENTS(resultStr), 
					IDS_PLAYER_WINS, (TCHAR*) game->players[zReversiPlayerBlack].name);
			/* black wins */
			if (ZReversiPlayerIsBlack(game))
				ZPlaySound( game, zSndWin, FALSE, TRUE );
			else
				ZPlaySound( game, zSndLose, FALSE, TRUE );
		}
		else if ( game->finalScore == zReversiScoreWhiteWins )
		{
			ReversiFormatMessage((TCHAR*)resultStr, NUMELEMENTS(resultStr), 
					IDS_PLAYER_WINS, (TCHAR*) game->players[zReversiPlayerWhite].name);
			/* white wins */
			if (ZReversiPlayerIsWhite(game))
				ZPlaySound( game, zSndWin, FALSE, TRUE );
			else
				ZPlaySound( game, zSndLose, FALSE, TRUE );
		} 
		else
		{	
			lstrcpy((TCHAR*)resultStr, (TCHAR*)gDrawStr);
			/* draw */
			ZPlaySound( game, zSndDraw, FALSE, TRUE );
		}

		image = gGameImages[zImageResult];
		if (!gDontDrawResults)
		{
			int16 width, just;
			HDC hdc;
			width = ZTextWidth(game->gameWindow, (TCHAR*)resultStr);
			if (width > ZRectWidth(&gRects[zRectResultBoxName]))
				just = zTextJustifyLeft;
			else
				just = zTextJustifyCenter;

			if (bDrawInMemory){
				ZImageDraw(image, gOffscreenGameBoard, &gRects[zRectResultBox], NULL, zDrawCopy | (ZIsLayoutRTL() ? zDrawMirrorHorizontal : 0));
				hdc = ZGrafPortGetWinDC( gOffscreenGameBoard );
			}else{
				ZImageDraw(image, game->gameWindow, &gRects[zRectResultBox], NULL, zDrawCopy | (ZIsLayoutRTL() ? zDrawMirrorHorizontal : 0));
				hdc = ZGrafPortGetWinDC( game->gameWindow );
			}
			//ZImageDraw(image, game->gameWindow, &gRects[zRectResultBox], NULL, zDrawCopy);
			//HDC hdc = ZGrafPortGetWinDC( game->gameWindow );
			HFONT hOldFont = SelectObject( hdc, gReversiFont[zFontResultBox].m_hFont );
			COLORREF colorOld = SetTextColor( hdc, gReversiFont[zFontResultBox].m_zColor );
			if (bDrawInMemory){
				ZBeginDrawing(gOffscreenGameBoard);
				ZDrawText(gOffscreenGameBoard, &gRects[zRectResultBoxName], just, resultStr);
				ZEndDrawing(gOffscreenGameBoard);
			}else{
				ZBeginDrawing(game->gameWindow);
				ZDrawText(game->gameWindow, &gRects[zRectResultBoxName], just, resultStr);
				ZEndDrawing(game->gameWindow);
			}
			//ZDrawText(game->gameWindow, &gRects[zRectResultBoxName], just, resultStr);

			// set the timer // Barna 091599
			if (game->resultBoxTimer == NULL) 
				game->resultBoxTimer = ZTimerNew();
			if (game->resultBoxTimer)
				ZTimerInit(game->resultBoxTimer, zResultBoxTimeout, resultBoxTimerFunc, game);
		}
	}
}

static void DrawMoveIndicator(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZRect* rectMove1, *rectMove2;
	ZRect* rectName1, *rectName2;
	TCHAR* moveStr;
	HDC hdc;

	if (ZReversiPlayerToMove(game->reversi) == zReversiPlayerBlack) {
		image = gGameImages[zImageBlackMarker];
		//moveStr = gYourTurnStr;
	} else {
		image = gGameImages[zImageWhiteMarker];
		//moveStr = gOppsTurnStr;
	}

	if (bDrawInMemory)
		hdc = ZGrafPortGetWinDC( gOffscreenGameBoard);
	else
		hdc = ZGrafPortGetWinDC( game->gameWindow );

	HFONT hOldFont = SelectObject( hdc, gReversiFont[zFontIndicateTurn].m_hFont );
	COLORREF colorOld = SetTextColor( hdc, gReversiFont[zFontIndicateTurn].m_zColor );

	rectName1 = &gRects[zRectName1];
	rectName2 = &gRects[zRectName2];
	rectMove1 = &gRects[zRectMove1];
	rectMove2 = &gRects[zRectMove2];

	if (ZReversiPlayerIsMyMove(game)) {
		rectName1 = &gRects[zRectName1];
		rectName2 = &gRects[zRectName2];
		rectMove1 = &gRects[zRectMove1];
		rectMove2 = &gRects[zRectMove2];
		moveStr = (TCHAR*)gYourTurnStr;
	} else {
		/* fill top spot with the background */
		rectName2 = &gRects[zRectName1];
		rectName1 = &gRects[zRectName2];
		rectMove2 = &gRects[zRectMove1];
		rectMove1 = &gRects[zRectMove2];
		// Bug 14714 - solved 100199
		moveStr = (TCHAR*)gOppsTurnStr;
	}

	if (bDrawInMemory){
		// Draw Text Indicator
		DrawBackground(NULL,rectName1); 
		DrawBackground(NULL,rectName2); 
		ZDrawText(gOffscreenGameBoard, rectName2, zTextJustifyCenter, moveStr);

		// Draw Piece Indicator
		DrawBackground(NULL,rectMove1); 
		ZImageDraw(image, gOffscreenGameBoard, rectMove2, NULL, zDrawCopy);
	}else{
		// Draw Text Indicator
		DrawBackground(game,rectName1); 
		DrawBackground(game,rectName2); 
		ZDrawText(game->gameWindow, rectName2, zTextJustifyCenter, moveStr);

		// Draw Piece Indicator
		DrawBackground(game,rectMove1); 
		ZImageDraw(image, game->gameWindow, rectMove2, NULL, zDrawCopy);
	}
}


static void DrawBackground(Game game, ZRect* clipRect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (!game){
		ZCopyImage(gOffscreenBackground, gOffscreenGameBoard, clipRect? clipRect: &gRects[zRectWindow], 
			clipRect? clipRect: &gRects[zRectWindow], NULL, zDrawCopy);
		return;
	}
	ZRect			oldClipRect;
	ZRect*			rect;
	ZWindow			window = game->gameWindow;

	rect = &gRects[zRectWindow];
	
	if (clipRect != NULL)
	{
		ZGetClipRect(window, &oldClipRect);
		ZSetClipRect(window, clipRect);
	}

	/* copy the whole background from the offscreen port */
	ZCopyImage(gOffscreenBackground, window, rect, rect, NULL, zDrawCopy);

	if (clipRect != NULL)
	{
		ZSetClipRect(window, &oldClipRect);
	}
}


static void DrawTable(Game game, BOOL bDrawInMemory)
{
	BYTE			i;
	BYTE			j;

	for (i = 0;i < 8; i++) {
		for (j = 0;j < 8; j++) {
			ZReversiSquare sq;
			sq.row = j;
			sq.col = i;
			DrawPiece(game, &sq, bDrawInMemory);
		}
	}
}

static void DrawSquares(Game game, ZReversiSquare* squares)
{
	while (squares && !ZReversiSquareIsNull(squares)) {
		DrawPiece(game, squares, FALSE);
		squares++;
	}
}

static void UpdateSquares(Game game, ZReversiSquare* squares)
{
	ZBeginDrawing(game->gameWindow);
	DrawSquares(game,squares);
	ZEndDrawing(game->gameWindow);
}

static void UpdateTable(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawTable(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void UpdateResultBox(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawResultBox(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void UpdateMoveIndicator(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawMoveIndicator(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void UpdateScores(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawScores(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void GetPieceRect(Game game, ZRect* rect, int16 col, int16 row)
{
	/* reversi player who is white must have the board reversed */
	if (ZReversiPlayerIsBlack(game)) {
		row = 7 - row;
		col = col;
	} else {
		row = row;
		col = 7 - col;
	}

	rect->left = gRects[zRectCells].left + col * zReversiPieceSquareWidth;
	rect->top = gRects[zRectCells].top + row * zReversiPieceSquareHeight;
	rect->right = rect->left + zReversiPieceImageWidth;
	rect->bottom = rect->top + zReversiPieceImageHeight;
}

static void GetPieceBackground(Game game, ZGrafPort window, ZRect* rectDest, int16 col, int16 row)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect rect;

	GetPieceRect(game,&rect,col,row);

	/* provide default destination rect same as source rect */
	if (!rectDest)
		rectDest = &rect;

	/* copy the background */
	ZCopyImage(gOffscreenBackground, window, &rect, rectDest, NULL, zDrawCopy);
}	


static void DrawPiece(Game game, ZReversiSquare* sq, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZReversiPiece		piece;

	piece = ZReversiPieceAt(game->reversi, sq);

	if (piece != zReversiPieceNone) {
		image = gGameImages[ZReversiPieceImageNum(piece)];
	}

	/* copy the background, in case we are removing a piece */
	if (bDrawInMemory)
		GetPieceBackground(game, gOffscreenGameBoard, NULL, sq->col,sq->row);
	else
		GetPieceBackground(game, game->gameWindow, NULL, sq->col,sq->row);

	if (image != NULL) { 
		ZRect			rect;
		GetPieceRect(game,&rect,sq->col,sq->row);
		if (bDrawInMemory)
			ZImageDraw(image, gOffscreenGameBoard, &rect, NULL, zDrawCopy);
		else
			ZImageDraw(image, game->gameWindow, &rect, NULL, zDrawCopy);
	}
}

static ZBool ZReversiSquareFromPoint(Game game, ZPoint* point, ZReversiSquare* sq)
{
	int16 x,y;
	BYTE i,j;

	x = point->x - gRects[zRectCells].left;
	y = point->y - gRects[zRectCells].top;

	i = x/zReversiPieceSquareWidth;
	j = y/zReversiPieceSquareHeight;

	if (i < 0 || i > 7 || j < 0 || j > 7 || x < 0 || y < 0) {
		return FALSE;
	}

	if (ZReversiPlayerIsBlack(game)) {
		/* reverse the row */
		sq->row = (7 - j);
		sq->col = i;
	} else {
		sq->row = j;
		sq->col = (7 - i);
	}

	return TRUE;
}

static void DrawPlayers(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, width, just;

	//ZSetFont(game->gameWindow, gTextBold9);
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		int16 playerNum;
		HDC hdc;
		/* Draw name (black or white) */
		//ZSetForeColor(game->gameWindow, &gPlayerTextColor);
		if (bDrawInMemory)
			hdc = ZGrafPortGetWinDC( gOffscreenGameBoard );
		else
			hdc = ZGrafPortGetWinDC( game->gameWindow );

		HFONT hOldFont = SelectObject( hdc, gReversiFont[zFontPlayerName].m_hFont );
		COLORREF colorOld = SetTextColor( hdc, gReversiFont[zFontPlayerName].m_zColor );
#if 0
		ZDrawText( game->gameWindow, &gRects[gNamePlateRects[i]], zTextJustifyCenter, 
			( ZReversiPlayerIsBlack(game) && i==0 ) || ( ZReversiPlayerIsWhite(game) && i==1) ? (TCHAR*)gWhiteStr : (TCHAR*)gBlackStr );
// next		
		if ( ZReversiPlayerIsBlack(game) ){
			ZDrawText( game->gameWindow, &gRects[gNamePlateRects[i]], zTextJustifyCenter,(TCHAR*)game->players[i].name);
		}
		else if ( ZReversiPlayerIsWhite(game) ){
			ZDrawText( game->gameWindow, &gRects[gNamePlateRects[i]], zTextJustifyCenter, 
			i  ? (TCHAR*)game->players[0].name : (TCHAR*)game->players[1].name );
		}
#endif		

		/* must move player name to reflect the side of the board the player is on */
		
		playerNum = (game->seat + 1 + i) & 1;
		
		//ZSetForeColor(game->gameWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));
		width = ZTextWidth(game->gameWindow, (TCHAR*) game->players[playerNum].name);
		if (width > ZRectWidth(&gRects[gNamePlateRects[i]]))
			just = zTextJustifyLeft;
		else
			just = zTextJustifyCenter;
		if (bDrawInMemory){
			DrawBackground(NULL,&gRects[gNamePlateRects[i]]); 
			ZDrawText(gOffscreenGameBoard, &gRects[gNamePlateRects[i]], just, (TCHAR*) game->players[playerNum].name);
		}else{
			DrawBackground(game,&gRects[gNamePlateRects[i]]); 
			ZDrawText(game->gameWindow, &gRects[gNamePlateRects[i]], just, (TCHAR*) game->players[playerNum].name);
		}

        SetTextColor(hdc, colorOld);
        SelectObject(hdc, hOldFont);
	}
}

static void DrawScores(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, width, just;
	ZImage			image[2];
	int16			score[2];
	ZRect* rect;
    HDC hdc;

	/* for now, keep the counter boxes the same */
	image[0] = gGameImages[zImageCounterWhite];
	image[1] = gGameImages[zImageCounterBlack];

	score[0] = game->whiteScore;
	score[1] = game->blackScore;
	
	if(bDrawInMemory)
		hdc = ZGrafPortGetWinDC(gOffscreenGameBoard);
	else
		hdc = ZGrafPortGetWinDC(game->gameWindow);

	HFONT hOldFont = SelectObject(hdc, gReversiFont[zFontIndicateTurn].m_hFont);
	COLORREF colorOld = SetTextColor(hdc, gReversiFont[zFontIndicateTurn].m_zColor);
	
	for (i = 0; i < zNumPlayersPerTable; i++)
	{
		BYTE tempStr[20];

		/* Draw name plate */
		rect = &gRects[gCounterRects[i]];

		wsprintf((TCHAR*)tempStr,_T("%d"),score[i]);
		width = ZTextWidth(game->gameWindow, (TCHAR*)tempStr);
		if (width > ZRectWidth(&gRects[gCounterTextRects[i]]))
			just = zTextJustifyLeft;
		else
			just = zTextJustifyCenter;

		if (bDrawInMemory){
			ZImageDraw(image[i], gOffscreenGameBoard, rect, NULL, zDrawCopy);
			ZSetForeColor(gOffscreenGameBoard, (ZColor*) ZGetStockObject(zObjectColorBlack));
			ZDrawText(gOffscreenGameBoard, &gRects[gCounterTextRects[i]], just, (TCHAR*) tempStr);
		}else{
			ZImageDraw(image[i], game->gameWindow, rect, NULL, zDrawCopy);
			ZSetForeColor(game->gameWindow, (ZColor*) ZGetStockObject(zObjectColorBlack));
			ZDrawText(game->gameWindow, &gRects[gCounterTextRects[i]], just,(TCHAR*) tempStr);
		}
	}

    SetTextColor(hdc, colorOld);
    SelectObject(hdc, hOldFont);
}


static void UpdatePlayers(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawPlayers(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void DrawOptions(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	/*int16			i;
	uint32			tableOptions;

	tableOptions = 0;
	for (i = 0; i < zNumPlayersPerTable; i++)
		tableOptions |= game->tableOptions[i];
	
	
	if (tableOptions & zRoomTableOptionNoKibitzing)
		ZImageDraw(gGameImages[zImageNoKibitzer], game->gameWindow,
				&gRects[zRectKibitzerOption], NULL, zDrawCopy);
	else
		DrawBackground(game, &gRects[zRectKibitzerOption]);
	*/
}


static void UpdateOptions(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawOptions(game);
	ZEndDrawing(game->gameWindow);
}

static void StartDrag(Game game, ZReversiPiece piece, ZPoint point)
/* initialite the point, piece and the first background rectangle */
{
	ZReversiSquare sq;

	game->dragPiece = piece;
	game->dragPoint = point;
    game->dragOn = false;

	if (ZReversiSquareFromPoint(game, &point, &sq)) {
		SaveDragBackground(game);

		UpdateDragPiece(game);
	}
}

static void UpdateDragPiece(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZPoint point;
    bool fDragOn = (gActivated && IsRectEmpty(&game->m_FocusRect));

	ZGetCursorPosition(game->gameWindow,&point);
	/* do nothing if point has not changed */
	if (point.x == game->dragPoint.x && point.y == game->dragPoint.y && game->dragOn == fDragOn) {
		return;
	}

	ZBeginDrawing(game->gameWindow);
	EraseDragPiece(game);
	game->dragPoint = point;
    game->dragOn = fDragOn;
	DrawDragPiece(game, FALSE);
	ZEndDrawing(game->gameWindow);
}

static void DrawDragSquareOutline(Game game)
{
	ZReversiSquare sq;
	ZRect rect;
	if (game->dragOn && ZReversiSquareFromPoint(game, &game->dragPoint, &sq)) {
		GetPieceRect(game,&rect,sq.col,sq.row);
		ZSetPenWidth(game->gameWindow,zDragSquareOutlineWidth);
		ZSetForeColor(game->gameWindow,(ZColor*) ZGetStockObject(zObjectColorWhite));
		ZRectDraw(game->gameWindow,&rect);
	}
}

static void EraseDragSquareOutline(Game game)
{
	ZReversiSquare sq;

	if (game->dragOn && ZReversiSquareFromPoint(game, &game->dragPoint, &sq)) {

		/* redraw whatever piece might have been there */
		UpdateSquare(game,&sq);
	}
}

static void SaveDragBackground(Game game)
/* calc the save backgroud rect around the drag point */
{
	ZRect rect;
	ZPoint point;
	ZReversiSquare sq;

	if (game->dragOn && ZReversiSquareFromPoint(game, &game->dragPoint, &sq)) {
		point = game->dragPoint;
		rect.left = 0; rect.top = 0;
		rect.right = zReversiPieceImageWidth;
		rect.bottom = zReversiPieceImageHeight;
		game->rectSaveDragBackground = rect;
		ZRectOffset(&game->rectSaveDragBackground, (int16)(point.x-zReversiPieceImageWidth/2),
						(int16)(point.y - zReversiPieceImageHeight/2));

		/* copy the whole background to the offscreen port */
		ZCopyImage(game->gameWindow, game->offscreenSaveDragBackground, 
				&game->rectSaveDragBackground, &rect, NULL, zDrawCopy);
	}
}


static void DrawDragPiece(Game game, BOOL bDrawInMemory)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZReversiSquare sq;

	/* could be called from zMessageDraw, do nothing if no piece dragging */
	if (game->gameState != zGameStateDragPiece && game->gameState != zGameStateAnimatePiece) {
		return;
	}

	if (game->dragOn && ZReversiSquareFromPoint(game, &game->dragPoint, &sq)) {
		SaveDragBackground(game);
 
	 	/* for person dragging, we will out line square moved */
	 	if (game->gameState == zGameStateDragPiece)
			DrawDragSquareOutline(game);

		/* draw the piece on the screen! */
		{
			ZImage image = gGameImages[ZReversiPieceImageNum(game->dragPiece)];

			if (image != NULL) {
				if (bDrawInMemory)
				{
					ZBeginDrawing(gOffscreenGameBoard);
					ZImageDraw(image, gOffscreenGameBoard, &game->rectSaveDragBackground, NULL, zDrawCopy);
					ZEndDrawing(gOffscreenGameBoard);
				}
				else
				{
					ZBeginDrawing(game->gameWindow);
					ZImageDraw(image, game->gameWindow, &game->rectSaveDragBackground, NULL, zDrawCopy);
					ZEndDrawing(game->gameWindow);
				}
			}
		}
	}
}

static void EraseDragPiece(Game game)
{
	ZReversiSquare sq;

	if (game->dragOn && ZReversiSquareFromPoint(game, &game->dragPoint, &sq)) {
		ZRect rect;

	 	/* for person dragging, we will out line square moved */
	 	if (game->gameState == zGameStateDragPiece)
			EraseDragSquareOutline(game);

		rect = game->rectSaveDragBackground;
		ZRectOffset(&rect, (int16)-rect.left, (int16) -rect.top);

		/* copy the whole background from the offscreen port */
		ZCopyImage(game->offscreenSaveDragBackground, game->gameWindow, 
				&rect, &game->rectSaveDragBackground, NULL, zDrawCopy);
	}
}

static void EndDragState(Game game)
{
	if (game->gameState == zGameStateDragPiece) {
		EraseDragPiece(game);
		ReversiSetGameState(game,zGameStateMove);
	}
}

static void ClearDragState(Game game)
{
	if (game->gameState == zGameStateDragPiece) {
		EraseDragPiece(game);
		ReversiSetGameState(game,zGameStateMove);
	}
}

void UpdateSquare(Game game, ZReversiSquare* sq)
{
	ZReversiSquare squares[2];

	/* redraw piece where it was moved from */
	ZReversiSquareSetNull(&squares[1]);
	squares[0].row = sq->row;
	squares[0].col = sq->col;
	UpdateSquares(game,squares);
}

static void HandleButtonDown(ZWindow window, ZMessage* pMessage)
{

#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZReversiSquare		sq;
	Game				game = (Game) pMessage->userData;

    
	if(gActEvt)  //leonp - Big 535 flag for a mouse activation, prevents a piece from
				 //being played on an activate event.
	{
		gActEvt = 0;
		return;  
	}

	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		gDontDrawResults = TRUE;
		ZWindowInvalidate( window, NULL );
	}

	/* check for clicks on the kibitzer icon */
	{
		int16				seat;
		ZPoint				point = pMessage->where;
		if ((seat = FindJoinerKibitzerSeat(game, &point)) != -1)
		{
			HandleJoinerKibitzerClick(game, seat, &point);
		}
	}

	/* kibitzers can't do anyting with the button. */
	if (game->kibitzer) {
		return;
	}

	if (game->gameState == zGameStateDragPiece) {

		EraseDragPiece(game);
		/* make sure piece ends on valid square and not on same square */
		if (ZReversiSquareFromPoint(game, &pMessage->where, &sq)) {
			/* try the move */
			ZBool legal;
			ZReversiMove move;
			ZReversiPiece piece = ZReversiPieceAt(game->reversi, &sq);

			move.square = sq;
			legal = ZReversiIsLegalMove(game->reversi, &move);
			if (legal)
			{
				/* send message to other player (comes to self too) */
				{
					ZReversiMsgMovePiece		msg;

					EndDragState(game);

					msg.move = move;
					msg.seat = game->seat;
					ZReversiMsgMovePieceEndian(&msg);

					ZCRoomSendMessage(game->tableID, zReversiMsgMovePiece, &msg, sizeof(ZReversiMsgMovePiece));
					/* for speed, send our move directly to be processed */
					/* don't wait for it to go to server and back */
					HandleMovePieceMessage(game, &msg);
					// Beta2 Bug #14776 - barna
					// when the piece is placed it should not be in drag state anymore
					//game->gameState = zGameStateFinishMove;
					ReversiSetGameState(game, zGameStateFinishMove);
					// if it is the very first move then enable the rollover buttons
					if (game->bMoveNotStarted == TRUE)
						game->bMoveNotStarted = FALSE;
				}
			}
			else 
			{
				/* illegal move */
				ZPlaySound( game, zSndIllegalMove, FALSE, FALSE );

                if(game->m_pBadMoveDialog->Init(ZShellZoneShell(), IDD_BADMOVE, ZWindowGetHWND(game->gameWindow)) == S_OK)
                    game->m_pBadMoveDialog->ModelessViaRegistration(ZWindowGetHWND(game->gameWindow));
				//UpdateSquare( game, &sq );
			}
		}
	}
}

static void HandleIdleMessage(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game				game;

	game = (Game) pMessage->userData;

	if (game->gameState == zGameStateDragPiece && gActivated && IsRectEmpty(&game->m_FocusRect))
	{
		UpdateDragPiece(game);
        game->fLastPunted = false;
	}
    else
    {
        if(!IsRectEmpty(&game->m_FocusRect))
        {
            ZReversiSquare sq;
            ZPoint point;
	        ZGetCursorPosition(game->gameWindow,&point);
            bool fSq = (ZReversiSquareFromPoint(game, &point, &sq) ? true : false);

            if(game->fLastPunted)
            {
                if(fSq != game->fLastPuntedSq || (fSq && !ZReversiSquareEqual(&sq, &game->sqLastPuntedSq)))
                    gReversiIGA->ForceRectsDisplayed(false);
            }

            game->fLastPunted = true;
            game->fLastPuntedSq = fSq;
            game->sqLastPuntedSq = sq;
        }
        else
            game->fLastPunted = false;
    }
}

static void GameSendTalkMessage(ZWindow window, ZMessage* pMessage)
{
#if 0
	ZReversiMsgTalk*			msgTalk;
	Game					game;
	int16					msgLen;
	ZPlayerInfoType			playerInfo;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{
		msgLen = sizeof(ZReversiMsgTalk) + pMessage->messageLen;
		msgTalk = (ZReversiMsgTalk*) ZCalloc(1, msgLen);
		if (msgTalk != NULL)
		{
			ZCRoomGetPlayerInfo(zTheUser, &playerInfo);
			msgTalk->userID = playerInfo.playerID;
			msgTalk->seat = game->seat;
			msgTalk->messageLen = (uint16)pMessage->messageLen;
			z_memcpy((TCHAR*) msgTalk + sizeof(ZReversiMsgTalk), (TCHAR*) pMessage->messagePtr,
					pMessage->messageLen);
			ZReversiMsgTalkEndian(msgTalk);
			ZCRoomSendMessage(game->tableID, zReversiMsgTalk, (void*) msgTalk, msgLen);
			ZFree((TCHAR*) msgTalk);
		}
		else
		{
			ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
			//ZAlert(_T("Out of memory."),NULL);
		}
	}
#endif
}

static bool HandleMovePieceMessage(Game game, ZReversiMsgMovePiece* msg)
{
	ZReversiMsgMovePieceEndian(msg);

    // the bit about the drag piece is that if you use the keyboard the drag state isn't ended before calling here
    // probably should change that handler to end the drag state when the square is selected
    if((game->gameState != zGameStateMove && (!ZReversiPlayerIsMyMove(game) || game->gameState != zGameStateDragPiece)) ||
        msg->move.square.col < 0 || msg->move.square.col > 7 ||
        msg->move.square.row < 0 || msg->move.square.row > 7 ||
        ZReversiPlayerToMove(game->reversi) != msg->seat)
        return false;

	if (!ZReversiMakeMove(game->reversi, &msg->move))
        return false;
	else
	{
		game->bOpponentTimeout=FALSE;
        game->bEndLogReceived=FALSE;
		game->bStarted=TRUE;
		UpdateSquare( game, &msg->move.square );
		AnimateBegin(game);
	}
    return true;
}
    
static bool HandleEndGameMessage(Game game, ZReversiMsgEndGame* msg)
{
	ZReversiMsgEndGameEndian(msg);

    if(msg->seat != ZReversiPlayerToMove(game->reversi) ||
        game->gameState != (msg->seat == game->seat ? zGameStateDragPiece : zGameStateMove) ||
        msg->flags != zReversiFlagResign)
        return false;

	/* game has now finished */	
	ZReversiEndGame(game->reversi, msg->flags);
	//set so that when quitting correct state can be known
	game->bStarted=FALSE;
    game->bOpponentTimeout=FALSE;
    game->bEndLogReceived=FALSE;

	FinishMoveUpdateStateHelper(game);
    return true;
}

static void HandleEndLogMessage(Game game, ZReversiMsgEndLog* msg)
{
/*
    if (!game->kibitzer)
    {
	    if (msg->reason==zReversiEndLogReasonTimeout)
	    {
		    if (msg->seatLosing==game->seat)
		    {
			    ZAlert(zEndLogTimeoutStr,game->gameWindow);
			    game->bEndLogReceived=TRUE;
		    }
        
	    } 
	    else if (msg->reason==zReversiEndLogReasonForfeit)
	    {
		    if (msg->seatLosing!=game->seat)
		    {
                if (ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable )
                {
			        ZAlert(zEndLogForfeitStr, game->gameWindow);
			        game->bEndLogReceived=TRUE;
                }
                else
                {
                    ZAlert((TCHAR*)gEndLogWontPlayStr, game->gameWindow);
		            game->bEndLogReceived=TRUE;
                }
		    } 
	    }
        else 
        {
            if (msg->seatLosing!=game->seat)
    	    {
	            ZAlert((TCHAR*)gEndLogWontPlayStr, game->gameWindow);
		        game->bEndLogReceived=TRUE;
            }     
	    }


	    if (game->exitInfo)
	    {
		    ZInfoDelete(game->exitInfo);
		    game->exitInfo=NULL;
	    }
    }

*/
	ZShellGameShell()->GameCannotContinue(game);
	//ZCRoomGameTerminated( game->tableID );
}

static void HandleMoveTimeout(Game game, ZReversiMsgMoveTimeout* msg)
{
	/*BYTE buff[512];

    if (!game->kibitzer)
    {
	    if ( msg->seat == game->seat ) 
	    {
	    }
	    else
	    {
		    game->bOpponentTimeout=TRUE;
		    wsprintf((TCHAR*)buff,zTimeoutStr,msg->userName,msg->timeout);
		    ZAlert( (TCHAR*)buff, game->gameWindow);
	    }
    }*/
}



static void FinishMoveUpdateStateHelper(Game game) 
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	/* normal players will be in the move state or the game over state */
	if (ZReversiIsGameOver(game->reversi,&game->finalScore,&game->whiteScore, &game->blackScore)) {
		ReversiSetGameState(game,zGameStateGameOver);
		AddResultboxAccessibility();
	} else {
		ReversiEnterMoveState(game);
	}

	UpdateMoveIndicator(game);
	UpdateScores(game);

	/* see that this gets drawn after the squares changed gets updated */
	if (game->gameState == zGameStateGameOver) {
		UpdateResultBox(game);
		if (gDontDrawResults){
			ZShellGameShell()->GameOver( Z(game) );
		}
		//ZTimerSetTimeout(game->resultBoxTimer, 0);		// Stop the timer for now.
	}
}

static void AnimateTimerProc(ZTimer timer, void* userData)
{
	Game game = (Game)userData;
	ZReversiSquare *squares;

	squares = ZReversiGetNextSquaresChanged(game->reversi);
	if (!ZReversiSquareIsNull(squares))
	{
		ZPlaySound( game, zSndPieceFlip, FALSE, FALSE );
		UpdateSquares(game,squares);
	}
	else
	{
		/* stop timer */
		ZTimerSetTimeout(timer,0);

		/* wrap up current move */
		ZReversiFinishMove(game->reversi);

		/* allow player to enter move now */
		FinishMoveUpdateStateHelper(game);

		/* play turn alert if appropriate */
		if (	(ZReversiPlayerToMove(game->reversi) == game->seat)
			&&	(game->gameState != zGameStateGameOver) )
		{
			ZPlaySound( game, zSndTurnAlert, FALSE, FALSE );
			ZShellGameShell()->MyTurn();
		}
	}
}

static void AnimateBegin(Game game)
{
	ReversiSetGameState( game, zGameStateAnimatePiece );
	ZTimerInit( game->animateTimer, zAnimateInterval, AnimateTimerProc, (void*)game );
}

static void HandleGameStateReqMessage(Game game, ZReversiMsgGameStateReq* msg)
{
	int32 size;
	ZReversiMsgGameStateResp* resp;

	ZReversiMsgGameStateReqEndian(msg);

	/* allocate enough storage for the full resp */
	size = ZReversiGetStateSize(game->reversi);
	size += sizeof(ZReversiMsgGameStateResp);
	resp = (ZReversiMsgGameStateResp*)ZMalloc(size);
	if (!resp){
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return;
	}

	resp->userID = msg->userID;
	resp->seat = msg->seat;

	/* copy the local game state */
	{
		int i;
		resp->gameState = game->gameState;
		resp->finalScore = game->finalScore;
		resp->whiteScore = game->whiteScore;
		resp->blackScore = game->blackScore;
		for (i = 0;i < 2;i++) {
			resp->newGameVote[i] = game->newGameVote[i];
			resp->players[i] = game->players[i];
		}
	}

	/* copy the full reversi state to send to the kibitzer */
	ZReversiGetState(game->reversi,(TCHAR*)resp + sizeof(ZReversiMsgGameStateResp));

	ZReversiMsgGameStateRespEndian(resp);
	ZCRoomSendMessage(game->tableID, zReversiMsgGameStateResp, resp, size);
}

static void HandleGameStateRespMessage(Game game, ZReversiMsgGameStateResp* msg)
{
	ZReversiMsgGameStateRespEndian(msg);

	/* if we get this, we better be in the kibitzer state */
	if (game->gameState != zGameStateKibitzerInit) {
		ZShellGameShell()->ZoneAlert(_T("StateError, kibitzer state expected when game state resp received"));
		//ZAlert(_T("StateError, kibitzer state expected when game state resp received"),NULL);
	}

	/* copy the local game state */
	{
		int i;
		game->gameState = msg->gameState;
		game->finalScore = msg->finalScore;
		game->whiteScore = msg->whiteScore;
		game->blackScore = msg->blackScore;
		for (i = 0;i < 2;i++) {
			game->newGameVote[i] = msg->newGameVote[i];
			game->players[i] = msg->players[i];
		}
	}

	/* create new reversi object with kibitzer state */
	if (game->reversi) {
		ZReversiDelete(game->reversi);
	}
	game->reversi = ZReversiSetState((TCHAR*)msg + sizeof(ZReversiMsgGameStateResp));

	/* cleart the special ignore messages flag for kibitzers */
	game->ignoreMessages = FALSE;

	/* start the clock if needed */
	if (	game->gameState == zGameStateMove
		||	game->gameState == zGameStateDragPiece)
	{
		/* kibitzer can't have these state, must always be in gameStateMove */
		ReversiSetGameState( game, zGameStateMove );
		
	}

	/* redraw the complete window when convenient */
	ZWindowInvalidate(game->gameWindow, NULL);
}

static bool HandleTalkMessage(Game game, ZReversiMsgTalk* msg)
{
	ZPlayerInfoType		playerInfo;
    int i;

	ZReversiMsgTalkEndian(msg);
	
#if 0	
	ZCRoomGetPlayerInfo(msg->userID, &playerInfo);
	ZWindowTalk(game->gameWindow, (_TUCHAR*) playerInfo.userName,
			(_TUCHAR*) msg + sizeof(ZReversiMsgTalk));
#endif
    TCHAR *szText = (TCHAR *) ((BYTE *) msg + sizeof(ZReversiMsgTalk));

    for(i = 0; i < msg->messageLen; i++)
        if(!szText[i])
            break;

    if(i == msg->messageLen || !msg->userID || msg->userID == zTheUser)
        return false;

    ZShellGameShell()->ReceiveChat(Z(game), msg->userID, szText, msg->messageLen / sizeof(TCHAR));
    return true;
}

static bool HandleVoteNewGameMessage(Game game, ZReversiMsgVoteNewGame* msg)
{
	ZReversiMsgVoteNewGameEndian(msg);

    if((msg->seat != 1 && msg->seat != 0) || (game->gameState != zGameStateGameOver &&
        (game->gameState != zGameStateWaitNew || game->seat == msg->seat) && game->gameState != zGameStateNotInited))
        return false;

	ZShellGameShell()->GameOverPlayerReady( Z(game), game->players[msg->seat].userID );
    return true;
}


static bool HandleNewGameMessage(Game game, ZReversiMsgNewGame* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	
	gDontDrawResults = FALSE;

	ZReversiMsgNewGameEndian(msg);

    // not looking at versions, etc. because the old client didn't set them right
    if((msg->seat != 0 && msg->seat != 1) || (game->gameState != zGameStateGameOver &&
        (game->gameState != zGameStateWaitNew || msg->seat == game->seat) && game->gameState != zGameStateNotInited) ||
        game->newGameVote[msg->seat] || msg->playerID == zTheUser || !msg->playerID)
        return false;

	if (msg->seat < zNumPlayersPerTable)
	{
		game->newGameVote[msg->seat] = TRUE;

		// inform the shell and the upsell dialog.
		//ZShellGameShell()->GameOverPlayerReady( Z(game), game->players[msg->seat].userID );
		/* get the player name and hostname... for later */
		{
			ZPlayerInfoType			playerInfo;
			uint16 i = msg->seat;
			ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);
            if(!playerInfo.userName[0])
                return false;

			game->players[i].userID = playerInfo.playerID;
			lstrcpy((TCHAR*) game->players[i].name, (TCHAR*) playerInfo.userName);
			lstrcpy((TCHAR*) game->players[i].host, (TCHAR*) playerInfo.hostName);
			UpdatePlayers(game);
		}
	}

	/* if we are waiting for a client ready message and this is not ours.. */
	if (game->newGameVote[0] && game->newGameVote[1])
	{
		// take down the upsell dialog
		ZShellGameShell()->GameOverGameBegun( Z(game) );
		ReversiInitNewGame(game);
		//Prefix Warning: game could be NULL.  Next message should be a 
		// quit message posted from InitNewGame, so we just have to make sure
		// we don't dereference it here.
		if( game == NULL )
		{
			return true;
		}
		ReversiEnterMoveState(game);

		UpdateMoveIndicator(game);
		UpdateScores(game);

		//InitAccessibility(game, game->m_pIGG);
		RemoveResultboxAccessibility(); 
		/* update the whole board */
		ZWindowInvalidate(game->gameWindow, &gRects[zRectCells]);

        if(ZReversiPlayerIsMyMove(game))
            ZShellGameShell()->MyTurn();
	}
	else if (game->newGameVote[game->seat] && !game->newGameVote[!game->seat])
	{
		ReversiSetGameState( game, zGameStateWaitNew );
	}
	SuperRolloverButtonDisable(game, game->sequenceButton);
    return true;
}

/* for now... kibitzers will receive names in the players message */
/* the structure sent will be the new game msg */
static void HandlePlayersMessage(Game game, ZReversiMsgNewGame* msg)
{
	ZReversiMsgNewGameEndian(msg);

	{
		ZPlayerInfoType			playerInfo;
		uint16 i = msg->seat;
		ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);
		game->players[i].userID = playerInfo.playerID;
		lstrcpy((TCHAR*) game->players[i].name, (TCHAR*) playerInfo.userName);
		lstrcpy((TCHAR*) game->players[i].host, (TCHAR*) playerInfo.hostName);
		UpdatePlayers(game);
	}
}

static void LoadRoomImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
#if 0
	ZError				err = zErrNone;
	ZResource			resFile;
	

	resFile = ZResourceNew();
	if ((err = ZResourceInit(resFile, ZGetProgramDataFileName(zGameImageFileName))) == zErrNone)
	{
		gGameIdle = ZResourceGetImage(resFile, zImageGameIdle + zRscOffset);
		gGaming = ZResourceGetImage(resFile, zImageGaming + zRscOffset);
		
		ZResourceDelete(resFile);
	}
	else
	{
		ZAlert(_T("Failed to open image file."), NULL);
	}
#endif
}


static ZBool GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
#if 0	// Barna 092999
	switch (objectType)
	{
		case zRoomObjectGameMarker:
			if (image != NULL)
			{
				if (modifier == zRoomObjectIdle)
					*image = gGameIdle;
				else if (modifier == zRoomObjectGaming)
					*image = gGaming;
			}
			return (TRUE);
	}
#endif	
	return (FALSE);
}


static void DeleteObjectsFunc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

#if 0
	if (gGameIdle != NULL)
		ZImageDelete(gGameIdle);
	gGameIdle = NULL;
	if (gGaming != NULL)
		ZImageDelete(gGaming);
	gGaming = NULL;
#endif
}

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point)
{
	int16			i, seat = -1;
	
	
	for (i = 0; i < zNumPlayersPerTable && seat == -1; i++)
	{
		ZRect *rect = &gRects[gKibitzerRectIndex[GetLocalSeat(game,i)]];

		if (ZPointInRect(point, rect))
			seat = i;
	}
	
	return (seat);
}


static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point)
{
	int16				playerType = zGamePlayer;
	ZPlayerInfoType		playerInfo;
	int16				i;
	ZLListItem			listItem;
	ZRect				rect;

	if (game->numKibitzers[seat] > 0)
			playerType = zGamePlayerKibitzer;
	
	if (playerType != zGamePlayer)
	{
		if (game->showPlayerWindow != NULL)
			ShowPlayerWindowDelete(game);
		
		/* Create player list. */
		game->showPlayerCount = game->numKibitzers[seat];
		if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), game->numKibitzers[seat])) == NULL)
			goto OutOfMemoryExit;
		for (i = 0; i < game->showPlayerCount; i++)
		{
			if ((listItem = ZLListGetNth(game->kibitzers[seat], i, zLListAnyType)) != NULL)
			{
				ZCRoomGetPlayerInfo((ZUserID) ZLListGetData(listItem, NULL), &playerInfo);
				if ((game->showPlayerList[i] = (TCHAR*) ZCalloc(1, lstrlen(playerInfo.userName) + 1)) == NULL)
					goto OutOfMemoryExit;
				lstrcpy(game->showPlayerList[i], playerInfo.userName);
			}
		}
		
		/* Create the window. */
		if ((game->showPlayerWindow = ZWindowNew()) == NULL)
			goto OutOfMemoryExit;
		ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight * game->showPlayerCount + 4);
		ZRectOffset(&rect, point->x, point->y);
		if (rect.right > gRects[zRectWindow].right)
			ZRectOffset(&rect, (int16)(gRects[zRectWindow].right - rect.right), (int16)0);
		if (rect.left < 0)
			ZRectOffset(&rect, (int16)-rect.left, (int16)0);
		if (rect.bottom > gRects[zRectWindow].bottom)
			ZRectOffset(&rect, (int16)0, (int16)(gRects[zRectWindow].bottom - rect.bottom));
		if (rect.top < 0)
			ZRectOffset(&rect, (int16)-rect.top, (int16)0);
		if (ZWindowInit(game->showPlayerWindow, &rect,
				zWindowPlainType, game->gameWindow, NULL, TRUE, FALSE, FALSE,
				ShowPlayerWindowFunc, zWantAllMessages, game) != zErrNone)
			goto OutOfMemoryExit;
		ZWindowTrackCursor(game->showPlayerWindow, ShowPlayerWindowFunc, game);
	}

	goto Exit;

OutOfMemoryExit:
	ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
	//ZAlert(_T("Out of memory."), game->gameWindow);
	
Exit:
	
	return;
}


static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(window);
			ZRectErase(window, &message->drawRect);
			ZEndDrawing(window);
			ShowPlayerWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonUp:
			ZWindowHide(game->showPlayerWindow);
			ZPostMessage(game->showPlayerWindow, ShowPlayerWindowFunc,zMessageWindowClose,
				NULL, NULL, 0, NULL, 0, game);
			break;
		case zMessageWindowClose:
			ShowPlayerWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void ShowPlayerWindowDraw(Game game)
{
	int16			i;
	ZRect			rect;


	ZBeginDrawing(game->showPlayerWindow);

	//ZSetFont(game->showPlayerWindow, (ZFont) ZGetStockObject(zObjectFontApp9Normal));
	
	ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight);
	ZRectOffset(&rect, 0, 2);
	ZRectInset(&rect, 4, 0);
	for (i = 0; i < game->showPlayerCount; i++)
	{
		ZDrawText(game->showPlayerWindow, &rect, zTextJustifyLeft, game->showPlayerList[i]);
		ZRectOffset(&rect, 0, zShowPlayerLineHeight);
	}
	
	ZEndDrawing(game->showPlayerWindow);
}


static void ShowPlayerWindowDelete(Game game)
{
	int16			i;
	
	
	if (game->showPlayerList != NULL)
	{
		for (i = 0; i < game->showPlayerCount; i++)
			ZFree(game->showPlayerList[i]);
		ZFree(game->showPlayerList);
		game->showPlayerList = NULL;
	}
	
	if (game->showPlayerWindow != NULL)
	{
		ZWindowDelete(game->showPlayerWindow);
		game->showPlayerWindow = NULL;
	}
}

void	ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
}


/*
	Remove the given user as a kibitzer from the game at the given seat.
	
	This is user is not kibitzing the game anymore.
*/
void	ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
}


static void SuperRolloverButtonEnable(Game game, ZRolloverButton button)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(gReversiIGA && button == game->sequenceButton)
        gReversiIGA->SetItemEnabled(true, IDC_RESIGN_BUTTON, false, 0);

    ZRolloverButtonEnable(button);
}

static void SuperRolloverButtonDisable(Game game, ZRolloverButton button)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(gReversiIGA && button == game->sequenceButton)
        gReversiIGA->SetItemEnabled(false, IDC_RESIGN_BUTTON, false, 0);

    ZRolloverButtonDisable(button);
}


/***********************************************************************************************/
/* Sound Routines
/***********************************************************************************************/

static void ZInitSounds()
{
	TCHAR* IniFileName;
	int i;

	IniFileName = _T("zone.ini");
	for( i = 0; i < zSndLastEntry; i++ )
	{
		gSounds[i].played = FALSE;
		GetPrivateProfileString(
				_T("Reversi Sounds"),
				(TCHAR*)(gSounds[i].SoundName),
				_T(""),
				(TCHAR*)(gSounds[i].WavFile),
				sizeof(gSounds[i].WavFile),
				IniFileName );
	}
}


static void ZResetSounds()
{
	int i;
	for( i = 0; i < zSndLastEntry; i++ )
		gSounds[i].played = FALSE;
}


static void ZStopSounds()
{
	PlaySound( NULL, NULL, SND_ASYNC | SND_NODEFAULT | SND_PURGE );
}


static void ZPlaySound( Game game, int idx, ZBool loop, ZBool once_per_game )
{
	DWORD flags;

	/* should we NOT play the sound? */
	if (	(!game->beepOnTurn)
		||	((idx < 0) || (idx >= zSndLastEntry))
		||	(gSounds[idx].WavFile[0] == '\0' && !gSounds[idx].force_default_sound)
		||	(once_per_game && gSounds[idx].played) )
		return;
		
	flags = SND_ASYNC | SND_FILENAME;
	if (!gSounds[idx].force_default_sound)
		flags |= SND_NODEFAULT;
	if ( loop )
		flags |= SND_LOOP;
	if ( gSounds[idx].WavFile[0] == '\0' )
		ZBeep(); /* NT isn't playing the default sound */
	else
		PlaySound( (TCHAR*)(gSounds[idx].WavFile), NULL, flags );
	gSounds[idx].played = TRUE;
}


ZBool LoadRolloverButtonImage(ZResource resFile, int16 dwResID, /*int16 dwButtonWidth,*/
							  ZImage rgImages[zNumRolloverStates])
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int i, j;
	ZOffscreenPort		tmpOSP;
	
	ZRect				tmpRect;
	ZImage				tmpImage = NULL;
	int16				nWidth;
	ZError				err = zErrNone;

	
	tmpImage = ZResourceGetImage(resFile, zImageButton + zRscOffset);
	if(!tmpImage)
		return FALSE;

	nWidth=ZImageGetWidth(tmpImage)/4;//dwButtonWidth;
	tmpRect.left=0;
	tmpRect.top=0;
	tmpRect.right=tmpRect.left+nWidth;
	//int16 nW = ZImageGetWidth(tmpImage);
	tmpRect.bottom=ZImageGetHeight(tmpImage);

	tmpOSP=ZConvertImageToOffscreenPort(tmpImage);
	
	if(!tmpOSP)
	{
		ZImageDelete(tmpImage);
		return FALSE;
	}

	for(i = 0; i < zNumRolloverStates; i++)
	{
		rgImages[i] = ZImageNew();
				
		if(!rgImages[i] || ZImageMake(rgImages[i], tmpOSP, &tmpRect, NULL, NULL) != zErrNone)
        {
            if(!rgImages[i])
			    i--;
            for(; i >= 0; i--)
                ZImageDelete(rgImages[i]);
	        ZOffscreenPortDelete(tmpOSP);
			return FALSE;
		}

		tmpRect.left = tmpRect.right;
		tmpRect.right += nWidth;
	}

	ZOffscreenPortDelete(tmpOSP);

	return TRUE;
}

void resultBoxTimerFunc(ZTimer timer, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	// dismisses the result box 
	Game	game;
	game = (Game) userData;

	if (game->gameState == zGameStateGameOver && !gDontDrawResults)
	{
		//RemoveResultboxAccessibility();
		gDontDrawResults = TRUE;
		ZWindowInvalidate( game->gameWindow, NULL );
	}
}


IResourceManager *ZShellResourceManager()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGameGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetResourceManager();
}



void MAKEAKEY(LPTSTR dest,LPCTSTR key1, LPCTSTR key2, LPCTSTR key3)
{  
	lstrcpy( dest, key1 );
	lstrcat( dest, _T("/") );
	lstrcat( dest, key2);
	lstrcat( dest, _T("/") );
	lstrcat( dest, key3);
}

ZBool LoadFontFromDataStore(LPReversiColorFont* ccFont, TCHAR* pszFontName)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGameGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

 	IDataStore *pIDS = ZShellDataStoreUI(); // gGameShell->GetDataStoreUI();
	const TCHAR* tagFont [] = {zGameName, zKey_FontRscTyp, pszFontName, NULL };
	
    tagFont[3] = zKey_FontId;
	if ( FAILED( pIDS->GetFONT( tagFont, 4, &ccFont->m_zFont ) ) )
    {
        return FALSE;
    }

    tagFont[3] = zKey_ColorId;
	if ( FAILED( pIDS->GetRGB( tagFont, 4, &ccFont->m_zColor ) ) )
    {
        return FALSE;
    }
    // create the HFONT
	/*
	LOGFONT logFont;
	ZeroMemory(&logFont, sizeof(LOGFONT));
	logFont.lfCharSet = DEFAULT_CHARSET;
	logFont.lfHeight = -MulDiv(ccFont->m_zFont.lfHeight, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
	logFont.lfWeight = ccFont->m_zFont.lfWeight;
	logFont.lfItalic = FALSE;
	logFont.lfUnderline = FALSE;
	logFont.lfStrikeOut = FALSE;
	lstrcpy( logFont.lfFaceName, ccFont->m_zFont.lfFaceName );
	*/
    ccFont->m_hFont = ZCreateFontIndirect( &ccFont->m_zFont );
    if ( !ccFont->m_hFont )
    {
        return FALSE;
    }
    return TRUE;
}

ZBool LoadGameFonts()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (LoadFontFromDataStore(&gReversiFont[zFontResultBox], zKey_RESULTBOX) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("Font loading falied"), NULL);
	if (LoadFontFromDataStore(&gReversiFont[zFontIndicateTurn], zKey_INDICATETURN) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("Font loading falied"), NULL);
	if (LoadFontFromDataStore(&gReversiFont[zFontPlayerName], zKey_PLAYERNAME) != TRUE)
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("Font loading falied"), NULL);

    TCHAR tagFont [64];
	MAKEAKEY (tagFont, zGameName, zKey_FontRscTyp, (TCHAR*)zKey_ROLLOVERTEXT);
	if ( FAILED( LoadZoneMultiStateFont( ZShellDataStoreUI(), tagFont, &gpButtonFont ) ) )
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("Font loading falied"), NULL);

	return TRUE;
}



int ReversiFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... )
{
    int nRet = 0;
    va_list list;
    TCHAR szFmt[1024];
	ZError err = zErrNone;
	if (ZShellResourceManager()->LoadString(idMessage, szFmt, sizeof(szFmt)/sizeof(szFmt[0])))
	{
		va_start( list, idMessage );
		nRet = FormatMessage( FORMAT_MESSAGE_FROM_STRING, szFmt, 
							  idMessage, 0, pszBuf, cchBuf, &list );
		va_end( list ); 
	}
	else
		ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
		//ZAlert(_T("String Loading Falied"), NULL);

    return nRet;
}

void ZoneRectToWinRect(RECT* rectWin, ZRect* rectZ)
{
	rectWin->left = rectZ->left;
	rectWin->top = rectZ->top;
	rectWin->right = rectZ->right;
	rectWin->bottom = rectZ->bottom;
}

/******************************Accessibility routines************************************/
static void GetAbsolutePieceRect(Game game, ZRect* rect, int16 col, int16 row)
{
	row = 7 - row;
	rect->left = gRects[zRectCells].left + col * zReversiPieceSquareWidth;
	rect->top = gRects[zRectCells].top + row * zReversiPieceSquareHeight;
	rect->right = rect->left + zReversiPieceImageWidth;
	rect->bottom = rect->top + zReversiPieceImageHeight;
}

void GetPiecePos (Game game, int nIndex, BYTE& row, BYTE&  col)
{
	row = nIndex%8;
	col = nIndex/8;

	if (!ZReversiPlayerIsBlack(game))
	{// reverse the col and row
		row = 7 - row;
		col = 7 - col;
	}
}

BOOL InitAccessibility(Game game, IGameGame *pIGG)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	// initialise the list of accessible objects. // is this the correct way to do it???
	GACCITEM	listReversiAccItems[zReversiAccessibleComponents];	// 8*8 + 1 - verify
	RECT		rcGame;
	ZRect		rcTemp;
	// Get the default values for the items
	int nSize = sizeof (listReversiAccItems)/sizeof(listReversiAccItems[0]);
	for (int i = 0; i < nSize; i++)
		CopyACC(listReversiAccItems[i], ZACCESS_DefaultACCITEM);

	// set the item specific bits
	// game board - 8*8 squares
	int nIndex = 0;
	for (BYTE ii = 0;ii < 8; ii++) {
		for (BYTE jj = 0;jj < 8; jj++) {
			// rc
			GetAbsolutePieceRect(game,&rcTemp,ii,jj);
			ZoneRectToWinRect(&rcGame, &rcTemp);

            // move it in by one pixel
	        rcGame.left++;
            rcGame.top++;
            rcGame.right--;
            rcGame.bottom--;
			CopyRect(&listReversiAccItems[nIndex].rc, &rcGame);

			// arrows
			listReversiAccItems[nIndex].nArrowUp	= (nIndex % 8 != 7) ? nIndex + 1 : ZACCESS_ArrowNone;
			listReversiAccItems[nIndex].nArrowDown = (nIndex % 8) ? nIndex - 1 : ZACCESS_ArrowNone;
			listReversiAccItems[nIndex].nArrowLeft = nIndex > 7 ? nIndex - 8 : ZACCESS_ArrowNone;
			listReversiAccItems[nIndex].nArrowRight= nIndex < 56 ? nIndex + 8 : ZACCESS_ArrowNone;

			nIndex++;
		}
	}
	for (i = 0; i < nSize-1; i++)
	{
		listReversiAccItems[i].wID = ZACCESS_InvalidCommandID;
		listReversiAccItems[i].fTabstop = false;
		listReversiAccItems[i].fGraphical = true;
	}
	listReversiAccItems[0].wID = IDC_GAME_WINDOW;
	listReversiAccItems[0].fTabstop = true;
    listReversiAccItems[0].eAccelBehavior = ZACCESS_FocusGroup;
    listReversiAccItems[0].nGroupFocus = 7;  // start in upper-left

    // resign
    listReversiAccItems[nSize-1].wID = IDC_RESIGN_BUTTON;
    listReversiAccItems[nSize-1].fGraphical = true;
    listReversiAccItems[nSize-1].fEnabled = (ZRolloverButtonIsEnabled(game->sequenceButton) ? true : false);
	ZoneRectToWinRect(&rcGame, &gRects[zRectSequenceButton]);

    // move it out by one pixel
	rcGame.left--;
    rcGame.top--;
    rcGame.right++;
    rcGame.bottom++;

	CopyRect(&listReversiAccItems[nSize-1].rc, &rcGame);

	// Load accelerator table defined in Rsc
	HACCEL hAccel = ZShellResourceManager()->LoadAccelerators (MAKEINTRESOURCE(IDR_REVERSIACCELERATOR));

	// initialise the IGraphicalAccessibility interface
	//IGraphicallyAccControl* pIGAC = dynamic_cast<IGraphicallyAccControl*>(pIGG);

	CComQIPtr<IGraphicallyAccControl> pIGAC = pIGG;
	if(!pIGAC)
        return FALSE;

	gReversiIGA->InitAccG (pIGAC, ZWindowGetHWND(game->gameWindow), 0);

	// push the list of items to be tab ordered
	gReversiIGA->PushItemlistG(listReversiAccItems, nSize, 0, true, hAccel);

	return TRUE;
}
static void AddResultboxAccessibility()
{// have one item which responds to Esc..
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	GACCITEM	resultBoxReversiAccItems;
	CopyACC(resultBoxReversiAccItems, ZACCESS_DefaultACCITEM);
	resultBoxReversiAccItems.wID = IDC_RESULT_WINDOW;
	resultBoxReversiAccItems.fGraphical = true;
	resultBoxReversiAccItems.rgfWantKeys = ZACCESS_WantEsc;
	resultBoxReversiAccItems.oAccel.cmd = IDC_RESULT_WINDOW;
	resultBoxReversiAccItems.oAccel.fVirt = FVIRTKEY;
	resultBoxReversiAccItems.oAccel.key = VK_ESCAPE;
    CopyRect(&resultBoxReversiAccItems.rc, ZIsLayoutRTL() ? &zCloseButtonRectRTL : &zCloseButtonRect);
	gReversiIGA->PushItemlistG(&resultBoxReversiAccItems, 1, 0, true, NULL);

	gReversiIGA->SetFocus(0);
}

static void RemoveResultboxAccessibility()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	if (gReversiIGA->GetStackSize() >1) // the main accelerator should not get popped
	{
		gReversiIGA->PopItemlist();
	}
}


static void EnableBoardKbd(bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;
    for(i = 0; i < 64; i++)
        gReversiIGA->SetItemEnabled(fEnable, i, true, 0);
}

/******************************Accessibility routines************************************/

/************************************************************************************/
/*--------------------------- CGameGameReversi members -----------------------------*/
STDMETHODIMP CGameGameReversi::GamePromptResult(DWORD nButton, DWORD dwCookie)
{
	Game game = I( GetGame() );

	switch (dwCookie)
	{
	case zQuitprompt:
		QuitGamePromptFunc ((int16)nButton, game);
		break;
	case zResignConfirmPrompt:
		ConfirmResignPrompFunc ((int16)nButton, game);
		break;
	default:
		break;
	}
	return S_OK;
}


STDMETHODIMP CGameGameReversi::GameOverReady()
{
    // user selected "Play Again"
	Game game = I( GetGame() );
	ZReversiMsgNewGame msg;
	msg.seat = game->seat;
	msg.protocolSignature = zReversiProtocolSignature;
	msg.protocolVersion = zReversiProtocolVersion;
	msg.clientVersion = ZoneClientVersion();
	ZReversiMsgNewGameEndian(&msg);
	ZCRoomSendMessage(game->tableID, zReversiMsgNewGame, &msg, sizeof(ZReversiMsgNewGame));
    return S_OK;
}

STDMETHODIMP CGameGameReversi::SendChat(TCHAR *szText, DWORD cchChars)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZReversiMsgTalk*		msgTalk;
	Game					game = (Game) GetGame();
	int16					msgLen;
	ZPlayerInfoType			playerInfo;

	msgLen = sizeof(ZReversiMsgTalk) + cchChars * sizeof(TCHAR);
    msgTalk = (ZReversiMsgTalk*) ZCalloc(1, msgLen);
    if (msgTalk != NULL)
    {
        msgTalk->userID = game->players[game->seat].userID;
		msgTalk->seat = game->seat;
        msgTalk->messageLen = (WORD) cchChars * sizeof(TCHAR);
        CopyMemory((BYTE *) msgTalk + sizeof(ZReversiMsgTalk), (void *) szText,
            msgTalk->messageLen);
        ZReversiMsgTalkEndian(msgTalk);
        ZCRoomSendMessage(game->tableID, zReversiMsgTalk, (void*) msgTalk, msgLen);
        ZFree((char*) msgTalk);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
	}
}

STDMETHODIMP_(HWND) CGameGameReversi::GetWindowHandle()
{
	Game game = I( GetGame() );
	return ZWindowGetHWND(game->gameWindow);
}


//IGraphicallyAccControl
void CGameGameReversi::DrawFocus(RECT *prc, long nIndex, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals	pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = I( GetGame() );

    // reversi invalidates the whole window in order to get the right
    // interaction with the "drag" piece that follows the pointer.
    // the main effect of this is that the "Resign" button flickers.
	if (prc)
		CopyRect(&(game->m_FocusRect), prc);
	else
		SetRectEmpty(&(game->m_FocusRect));

	ZWindowInvalidate (game->gameWindow, NULL);
}

void CGameGameReversi::DrawDragOrig(RECT *prc, long nIndex, void *pvCookie)
{
}

DWORD CGameGameReversi::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
	if (nIndex != ZACCESS_InvalidItem)
		SetFocus (GetWindowHandle());

	return 0;
}

DWORD CGameGameReversi::Select(long nIndex, DWORD rgfContext, void *pvCookie)
{
	return Activate(nIndex, rgfContext, pvCookie); // assuming both are doing the same thing- verify
}

DWORD CGameGameReversi::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals		pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game game = I( GetGame() );
	long id = gReversiIGA->GetItemID(nIndex);

	if (id == IDC_RESULT_WINDOW)
	{// result box displayed
		if (game->gameState == zGameStateGameOver && !gDontDrawResults)
		{
			gDontDrawResults = TRUE;
			ZWindowInvalidate( game->gameWindow, &gRects[zRectResultBox] );
		}
		return 0;
	}

	if (!ZReversiPlayerIsMyMove(game) || game->gameState == zGameStateFinishMove) {
		/* if not players move, can't do anything */
		return 0;
	}

	if (id == IDC_RESIGN_BUTTON)
	{// resign btn
		if (ZRolloverButtonIsEnabled( game->sequenceButton ))
			ZShellGameShell()->GamePrompt(game, (TCHAR*)gResignConfirmStr, (TCHAR*)gResignConfirmStrCap,
										AlertButtonYes, AlertButtonNo, NULL, 0, zResignConfirmPrompt);
	}
	else if (id == IDC_RESULT_WINDOW)
	{
		if (game->gameState == zGameStateGameOver && !gDontDrawResults)
		{
			gDontDrawResults = TRUE;
			ZWindowInvalidate( game->gameWindow, &gRects[zRectResultBox] );
		}
	}
	else	// IDC_GAME_WINDOW
	{
		ZReversiSquare sq;
		GetPiecePos (game, nIndex, sq.row, sq.col);
		/* try the move */
		ZReversiMove move;
		move.square = sq;
		ZBool legal = ZReversiIsLegalMove(game->reversi, &move);
		if (legal) 
		{
			/* send message to other player (comes to self too) */
			ZReversiMsgMovePiece	msg;

			msg.move = move;
			msg.seat = game->seat;
			ZReversiMsgMovePieceEndian(&msg);
			ZCRoomSendMessage(game->tableID, zReversiMsgMovePiece, &msg, sizeof(ZReversiMsgMovePiece));
			HandleMovePieceMessage(game, &msg);
			ReversiSetGameState(game, zGameStateFinishMove);
			// if it is the very first move then enable the rollover buttons
			if (game->bMoveNotStarted == TRUE)
				game->bMoveNotStarted = FALSE;
		} else {
			/* illegal move */
			ZPlaySound( game, zSndIllegalMove, FALSE, FALSE );
            if(game->m_pBadMoveDialog->Init(ZShellZoneShell(), IDD_BADMOVE, ZWindowGetHWND(game->gameWindow)) == S_OK)
                game->m_pBadMoveDialog->ModelessViaRegistration(ZWindowGetHWND(game->gameWindow));
		}

		ZWindowInvalidate(game->gameWindow, NULL);
	}
	return 0;
}

DWORD CGameGameReversi::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\bidding.cpp ===
//
// bidding pane/dialog stuff

#include "zone.h"
#include "zroom.h"
#include "spades.h"
#include "zonecli.h"
#include "client.h"
#include "zui.h"
#include "ZoneDebug.h"
#include "ZoneResource.h"
#include "SpadesRes.h"
#include "zrollover.h"
#include <windowsx.h>
#include <commctrl.h>
#include "UAPI.h"

enum
{
	zAccBidNil = 0,
	zAccBidOne,
	zAccBidTwo,
	zAccBidThree,
	zAccBidFour,
	zAccBidFive,
	zAccBidSix,
	zAccBidSeven,
	zAccBidEight,
	zAccBidNine,
	zAccBidTen,
	zAccBidEleven,
	zAccBidTwelve,
	zAccBidThirteen,
	zNumBidStateChooseAcc
};


// 
// When there is no good way to do closures within the language,
// there is always a way to do it OUTSIDE the language.
//
#define DEFINE_DRAW_FUNC(FuncName, rectName)\
static ZBool FuncName(ZRolloverButton rolloverButton, ZGrafPort grafPort, int16 state, ZRect* pdstrect, void* userData){\
GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer(); \
ZRect *psrcrect = NULL; \
switch ( state ) \
{ \
case zRolloverStateIdle:     psrcrect = &gBiddingObjectRects[rectName##Idle];        break; \
case zRolloverStateDisabled: psrcrect = &gBiddingObjectRects[rectName##Disabled];    break; \
case zRolloverStateSelected: psrcrect = &gBiddingObjectRects[rectName##Selected];    break; \
case zRolloverStateHilited:  psrcrect = &gBiddingObjectRects[rectName##Highlighted]; break; \
default: return FALSE; \
} \
ZCopyImage( gBiddingObjectBuffer, grafPort, psrcrect, pdstrect, NULL, zDrawCopy ); \
return TRUE; } \
                                
 


class CBiddingDialogImpl : public CBiddingDialog
{
public:
    CBiddingDialogImpl( Game game )
    {
        m_game = game;
        m_fVisible = false;  
        m_nState = zBiddingStateOpen;
    }
    virtual ~CBiddingDialogImpl()
    {
        Destroy();
    }
    bool _Create();

    virtual bool Show( bool fShow );
    virtual bool Draw();
    virtual bool Destroy();
    virtual bool IsVisible();
	virtual int	 GetState();
    virtual bool Reset();
    virtual bool GetRect( ZRect *prc );


public:
    bool ButtonInit( ZRolloverButton *pButton, Game game, ZRect *bounds,
                     LPCTSTR pszText, ZRolloverButtonFunc func, ZRolloverButtonDrawFunc drawFunc,
                     int nFont = zMultiStateFontBiddingCenter );

    static ZBool ShowCardsButtonFunc(ZRolloverButton button, int16 state, void* userData);
    static ZBool DoubleNilButtonFunc(ZRolloverButton button, int16 state, void* userData);
    static ZBool BidButtonFunc(ZRolloverButton button, int16 state, void* userData);

    // drawing functions
    DEFINE_DRAW_FUNC(LargeButtonLeftDrawFunc,  zRectBiddingObjectLargeButtonLeft)
    DEFINE_DRAW_FUNC(LargeButtonRightDrawFunc, zRectBiddingObjectLargeButtonRight)
    DEFINE_DRAW_FUNC(SmallButtonLeftDrawFunc,  zRectBiddingObjectSmallButtonLeft)
    DEFINE_DRAW_FUNC(SmallButtonCenterDrawFunc,zRectBiddingObjectSmallButtonCenter)
    DEFINE_DRAW_FUNC(SmallButtonRightDrawFunc, zRectBiddingObjectSmallButtonRight)

    void RedrawButtons();

private:
    Game m_game;
    bool m_fVisible;
    int m_nState;

    ZRect m_rcText;
    ZRect m_rcLargeShadow;
    ZRect m_rcSmallShadow;
};

struct LargeBidButtonLayout
{
    int nStringID;
    int nRectID;
    int nMultiStateFontID;
    ZRolloverButtonFunc pfnButton;
    ZRolloverButtonDrawFunc pfnDraw;
};
static const LargeBidButtonLayout g_arLargeBidLayout[2] =
{
    { 
        zStringBiddingShowCards, 
        zRectBiddingLargeButtonLeft, 
        zMultiStateFontBiddingLeft,
        CBiddingDialogImpl::ShowCardsButtonFunc, 
        CBiddingDialogImpl::LargeButtonLeftDrawFunc 
    },
    { 
        zStringBiddingDoubleNil, 
        zRectBiddingLargeButtonRight,
        zMultiStateFontBiddingRight,
        CBiddingDialogImpl::DoubleNilButtonFunc,
        CBiddingDialogImpl::LargeButtonRightDrawFunc 
    }
};
static const LargeBidButtonLayout g_arLargeBidLayoutRTL[2] =
{
    { 
        zStringBiddingDoubleNil,
        zRectBiddingLargeButtonLeft, 
        zMultiStateFontBiddingLeft,
        CBiddingDialogImpl::DoubleNilButtonFunc, 
        CBiddingDialogImpl::LargeButtonLeftDrawFunc
    },
    {
        zStringBiddingShowCards, 
        zRectBiddingLargeButtonRight,
        zMultiStateFontBiddingRight,
        CBiddingDialogImpl::ShowCardsButtonFunc,
        CBiddingDialogImpl::LargeButtonRightDrawFunc 
    }
};

bool CBiddingDialog::ShowCardsButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
	return (CBiddingDialogImpl::ShowCardsButtonFunc(button, state, userData)) ? true : false;
}

bool CBiddingDialog::DoubleNilButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
	return (CBiddingDialogImpl::DoubleNilButtonFunc(button, state, userData)) ? true : false;
}

bool CBiddingDialog::BidButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
	return (CBiddingDialogImpl::BidButtonFunc(button, state, userData)) ? true : false;
}

//static 
CBiddingDialog *CBiddingDialog::Create( Game game )
{
    CBiddingDialogImpl *pImpl = new CBiddingDialogImpl( game );
    if ( !pImpl )
    {
        return NULL;
    }
    if ( !pImpl->_Create() )
    {
        delete pImpl;
        return NULL;
    }
    return pImpl;
}



bool CBiddingDialogImpl::_Create()
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

    int i;
    TCHAR szBid[10];
    ZRect rect;
    ZeroMemory( m_pLargeButtons, sizeof(m_pLargeButtons) );
    ZeroMemory( m_pSmallButtons, sizeof(m_pSmallButtons) );

    int xPaneOffset = gBiddingRects[zRectBiddingPane].left;
    int yPaneOffset = gBiddingRects[zRectBiddingPane].top;
    // initialize all the buttons.

    const LargeBidButtonLayout *arLargeBidLayout;
    arLargeBidLayout = ZIsLayoutRTL() ? g_arLargeBidLayoutRTL : g_arLargeBidLayout;
    ASSERT( NUMELEMENTS(g_arLargeBidLayoutRTL) == NUMELEMENTS(g_arLargeBidLayout) );

    for ( i=0; i < NUMELEMENTS(g_arLargeBidLayout); i++ )
    {
        rect = gBiddingRects[arLargeBidLayout[i].nRectID];
        ZRectOffset( &rect, xPaneOffset, yPaneOffset );

        if ( !ButtonInit( &m_pLargeButtons[i], m_game, 
                          &rect,
                          gStrings[arLargeBidLayout[i].nStringID],
                          arLargeBidLayout[i].pfnButton,
                          arLargeBidLayout[i].pfnDraw,
                          arLargeBidLayout[i].nMultiStateFontID ) )
        {
            goto Fail;
        }
    }


    // index by button. (reversed in RTL)
    TCHAR szBids[14][10];

    if ( ZIsLayoutRTL() )
    {
        for ( i=0; i < 13; i++ )
        {
            _itot( 13-i, szBids[i], 10 );
        }
        lstrcpy( szBids[13], gStrings[zStringBiddingNil] );
    }
    else
    {
        lstrcpy( szBids[0], gStrings[zStringBiddingNil] );
        for ( i=1; i < 14; i++ )
        {
            _itot( i, szBids[i], 10 );
        }
    }


    rect = gBiddingRects[zRectBiddingButton0];
    ZRectOffset( &rect, xPaneOffset, yPaneOffset );
    // create the nil - 13 buttons
    if ( !ButtonInit( &m_pSmallButtons[0], m_game,
                      &rect,
                      szBids[0],
                      BidButtonFunc,
                      SmallButtonLeftDrawFunc,
                      zMultiStateFontBiddingLeft ) )
    {
        goto Fail;
    }


    for ( i=1; i < 13; i++ )
    {
        rect = gBiddingRects[zRectBiddingButton0+i];
        ZRectOffset( &rect, xPaneOffset, yPaneOffset );
        _itot( i, szBid, 10 );

        if ( !ButtonInit( &m_pSmallButtons[i], m_game,
                          &rect,
                          szBids[i],
                          BidButtonFunc,
                          SmallButtonCenterDrawFunc ) )
        {
            goto Fail;
        }
    }
    rect = gBiddingRects[zRectBiddingButton13];
    ZRectOffset( &rect, xPaneOffset, yPaneOffset );

    if ( !ButtonInit( &m_pSmallButtons[13], m_game,
                      &rect,
                      szBids[13],
                      BidButtonFunc,
                      SmallButtonRightDrawFunc,
                      zMultiStateFontBiddingRight ) )
    {
        goto Fail;
    }


    // other rects
    m_rcText = gBiddingRects[zRectBiddingText];
    ZRectOffset( &m_rcText, xPaneOffset, yPaneOffset );

    m_rcLargeShadow = gBiddingRects[zRectBiddingLargeShadow];
    ZRectOffset( &m_rcLargeShadow, xPaneOffset, yPaneOffset );

    m_rcSmallShadow = gBiddingRects[zRectBiddingSmallShadow];
    ZRectOffset( &m_rcSmallShadow, xPaneOffset, yPaneOffset );
    return true;
Fail:
    Destroy();
    return false;
}


bool CBiddingDialogImpl::Destroy()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    for ( i=0; i < NUMELEMENTS(m_pLargeButtons); i++ )
    {
        if(m_pLargeButtons[i])
            ZRolloverButtonDelete(m_pLargeButtons[i]);
        m_pLargeButtons[i] = NULL;
        gGAcc->SetItemEnabled(false, i, true, 0);
    }

    for ( i=0; i < NUMELEMENTS(m_pSmallButtons); i++ )
    {
        if(m_pSmallButtons[i])
            ZRolloverButtonDelete(m_pSmallButtons[i]);
        m_pSmallButtons[i] = NULL;
        gGAcc->SetItemEnabled(false, zAccFirstBid + i, true, 0);
    }

    return true;
}


bool CBiddingDialogImpl::Draw()
{

    if ( !m_fVisible )
    {
        return true;
    }

	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    ZBeginDrawing( m_game->gameDrawPort );

    ZCopyImage( gBiddingObjectBuffer, m_game->gameDrawPort, 
                &gBiddingObjectRects[zRectBiddingObjectBackground], 
                &gBiddingRects[zRectBiddingPane], 
                NULL, zDrawCopy);

	HDC hdc = ZGrafPortGetWinDC( m_game->gameDrawPort );
    gFonts[zFontBiddingPaneText].Select( hdc );

    if ( m_nState == zBiddingStateOpen )
    {
        // lay down the large button shadow
        ZCopyImage( gBiddingObjectBuffer, m_game->gameDrawPort, 
                    &gBiddingObjectRects[zRectBiddingObjectLargeButtonShadow], 
                    &m_rcLargeShadow, 
                    NULL, zDrawCopy);

        ZDrawText( m_game->gameDrawPort, &m_rcText, zTextJustifyCenter|zTextJustifyWrap, gStrings[zStringBiddingOpenText] );
    }
    else
    {
        ASSERT( m_nState == zBiddingStateChoose );
        ZCopyImage( gBiddingObjectBuffer, m_game->gameDrawPort, 
                    &gBiddingObjectRects[zRectBiddingObjectSmallButtonShadow], 
                    &m_rcSmallShadow, 
                    NULL, zDrawCopy);
       ZDrawText( m_game->gameDrawPort, &m_rcText, zTextJustifyCenter, gStrings[zStringBiddingChooseText] );
    }

    gFonts[zFontBiddingPaneText].Deselect( hdc );
    ZEndDrawing( m_game->gameDrawPort );

    return true;
}

bool CBiddingDialogImpl::IsVisible()
{
    return m_fVisible;
}

int CBiddingDialogImpl::GetState()
{
    return m_nState;
}


bool CBiddingDialogImpl::Show( bool fShow )
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

    int i;
    if ( fShow )
    {
        if ( !m_fVisible )
        {
            ZRect rect;
            RECT rc;
            bool fRTL = (ZIsLayoutRTL() ? true : false);

            // deal with the rectangles
            ZRolloverButtonGetRect(m_pLargeButtons[fRTL ? 1 : 0], &rect);
            rc.left = rect.left - 1;
            rc.top = rect.top - 5;
            rc.right = rect.right + 1;
            rc.bottom = rect.bottom + 1;
            gGAcc->SetItemRect(&rc, zAccShowCards, true, 0);

            ZRolloverButtonGetRect(m_pLargeButtons[fRTL ? 0 : 1], &rect);
            rc.left = rect.left - 1;
            rc.top = rect.top - 5;
            rc.right = rect.right + 1;
            rc.bottom = rect.bottom + 1;
            gGAcc->SetItemRect(&rc, zAccDoubleNil, true, 0);

            for(i = 0; i < 14; i++)
            {
                ZRolloverButtonGetRect(m_pSmallButtons[fRTL ? 13 - i : i], &rect);
                rc.left = rect.left - 1;
                rc.top = rect.top - 5;
                rc.right = rect.right + 1;
                rc.bottom = rect.bottom + 1;
                gGAcc->SetItemRect(&rc, zAccFirstBid + i, true, 0);
            }

            if ( m_nState == zBiddingStateChoose )
            {
                for ( i=0; i < NUMELEMENTS(m_pSmallButtons); i++ )
                {
                    ZRolloverButtonShow( m_pSmallButtons[i] );
                    gGAcc->SetItemEnabled(true, zAccFirstBid + i, true, 0);
                }
            }
            else
            {
                ASSERT( m_nState == zBiddingStateOpen );
                for ( i=0; i < NUMELEMENTS(m_pLargeButtons); i++ )
                {
                    ZRolloverButtonShow( m_pLargeButtons[i] );
                    gGAcc->SetItemEnabled(true, i, true, 0);
                }
            }

            gGAcc->SetAcceleratorTable(ghAccelDouble, 0);
            m_fVisible = true;
            return Draw();
        }
    }
    else
    {
        if ( m_fVisible )
        {
			for ( i=0; i < NUMELEMENTS(m_pSmallButtons); i++ )
			{
				ZRolloverButtonHide( m_pSmallButtons[i], TRUE );
                gGAcc->SetItemEnabled(false, zAccFirstBid + i, true, 0);
			}
			for ( i=0; i < NUMELEMENTS(m_pLargeButtons); i++ )
			{
				ZRolloverButtonHide( m_pLargeButtons[i], TRUE );
                gGAcc->SetItemEnabled(false, i, true, 0);
			}

            gGAcc->SetAcceleratorTable(ghAccelDone, 0);
            m_fVisible = false;
    		ZWindowInvalidate( m_game->gameWindow, &gBiddingRects[zRectBiddingPane] );
            return Draw();
        }
    }
    return true;
}


bool CBiddingDialogImpl::Reset()
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i=0;
    // hide the small buttons
    for ( i=0; i < NUMELEMENTS(m_pSmallButtons); i++ )
    {
        ZRolloverButtonHide( m_pSmallButtons[i], TRUE );
        gGAcc->SetItemEnabled(false, zAccFirstBid + i, true, 0);
        //ZRolloverButtonEnable( m_pSmallButtons[i] );
    }
    // show the large buttons
    for ( i=0; i < NUMELEMENTS(m_pLargeButtons); i++ )
    {
        ZRolloverButtonShow( m_pLargeButtons[i] );
        ZRolloverButtonEnable( m_pLargeButtons[i] );
        gGAcc->SetItemEnabled(true, i, true, 0);
    }
    m_nState = zBiddingStateOpen;
    return true;
}


bool CBiddingDialogImpl::GetRect( ZRect *prc )
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    if ( !IsVisible() )
    {
        return false;
    }
    *prc = gBiddingRects[zRectBiddingPane];
    return true;
}


bool CBiddingDialogImpl::ButtonInit( ZRolloverButton *pButton, Game game, ZRect *bounds, 
                                     LPCTSTR pszText, ZRolloverButtonFunc func, ZRolloverButtonDrawFunc drawFunc,
                                     int nFont /*=zMultiStateFontBiddingCenter*/)
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

    ZError err;
    ZRolloverButton rollover;
    rollover = ZRolloverButtonNew();

    if ( !rollover )
    {
        return FALSE;
    }
    err = ZRolloverButtonInit2( rollover, game->gameWindow, bounds, FALSE, FALSE,
                                NULL, NULL, NULL, NULL, NULL,
                                pszText, drawFunc, func, this );

    if ( err != zErrNone )
    {
        ZRolloverButtonDelete( rollover );
        *pButton = NULL;
        return FALSE;
    }

    ZRolloverButtonSetMultiStateFont( rollover, gpButtonFonts[nFont] );

    *pButton = rollover;
    return TRUE;
}



void CBiddingDialogImpl::RedrawButtons()
{               
    int i;
    if ( m_nState == zBiddingStateChoose )
    {
        for ( i=0; i < NUMELEMENTS(m_pSmallButtons); i++ )
        {
            ZRolloverButtonDraw( m_pSmallButtons[i] );
        }
    }
    else
    {
        ASSERT( m_nState == zBiddingStateOpen );
        for ( i=0; i < NUMELEMENTS(m_pLargeButtons); i++ )
        {
            ZRolloverButtonDraw( m_pLargeButtons[i] );
        }
    }
}


//static 
ZBool CBiddingDialogImpl::ShowCardsButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if ( state == zRolloverButtonClicked )
    {
        CBiddingDialogImpl *pThis = (CBiddingDialogImpl*)userData;
        Game game = pThis->m_game;
        int i;

	    ZSpadesMsgShownCards showMsg;
                
        showMsg.seat = game->seat;
	    ZSpadesMsgShownCardsEndian(&showMsg);
	    ZCRoomSendMessage(game->tableID, zSpadesMsgShownCards, (void*) &showMsg, sizeof(showMsg));

	    game->showCards = TRUE;
	    UpdateHand(game);

        for ( i=0; i < NUMELEMENTS(pThis->m_pLargeButtons); i++ )
        {
            ZRolloverButtonHide( pThis->m_pLargeButtons[i], FALSE );
            gGAcc->SetItemEnabled(false, i, true, 0);
        }
        for ( i=0; i < NUMELEMENTS(pThis->m_pSmallButtons); i++ )
        {
            ZRolloverButtonShow( pThis->m_pSmallButtons[i] );
            ZRolloverButtonEnable( pThis->m_pSmallButtons[i] );
            gGAcc->SetItemEnabled(true, zAccFirstBid + i, true, 0);
        }
        pThis->m_nState = zBiddingStateChoose;
        gGAcc->SetFocus(zAccFirstBid, true, 0);
        pThis->Draw();
        pThis->RedrawButtons();
    }

    return TRUE;
}
//static 
ZBool CBiddingDialogImpl::DoubleNilButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
    if ( state == zRolloverButtonClicked )
    {
    	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

        CBiddingDialogImpl *pThis = (CBiddingDialogImpl*)userData;
        Game game = pThis->m_game;
       	ZSpadesMsgBid bid;

		game->toBid = zSpadesBidDoubleNil;

		if (game->playerToPlay == game->seat)
		{
			// Send the bid.
			bid.seat = game->seat;
			bid.bid = (char) game->toBid;
			ZSpadesMsgBidEndian(&bid);
			ZCRoomSendMessage(game->tableID, zSpadesMsgBid, (void*) &bid, sizeof(bid));
		}

		game->showCards = TRUE;
		UnselectAllCards(game);
		ZWindowInvalidate(game->gameWindow, &gRects[zRectHand]);

        pThis->Show( false );
    }
    return TRUE;
}

//static 
ZBool CBiddingDialogImpl::BidButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
    if ( state == zRolloverButtonClicked )
    {
    	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

        CBiddingDialogImpl *pThis = (CBiddingDialogImpl*)userData;
        Game game = pThis->m_game;
       	ZSpadesMsgBid bid;

        game->toBid = -1;
        // figure out which button was clicked
        for ( int i=0; i < NUMELEMENTS(pThis->m_pSmallButtons); i++ )
        {
            if ( button == pThis->m_pSmallButtons[i] )
            {
                game->toBid = ZIsLayoutRTL() ? 13-i : i;
                break;
            }
        }
        if ( game->toBid == -1 )
        {
            // TODO: Do something smart
            ASSERT( !"What did you do?" );
            return TRUE;
        }

	    if (game->playerToPlay == game->seat)
	    {
		    // Send the bid.
		    bid.seat = game->seat;
		    bid.bid = (char) game->toBid;
		    ZSpadesMsgBidEndian(&bid);
		    ZCRoomSendMessage(game->tableID, zSpadesMsgBid, (void*) &bid, sizeof(bid));
	    }
	    UnselectAllCards(game);

        pThis->Show( false );
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\reversi\revermov.cpp ===
/*
** checkersmov.c
**
** Contains movement routines for the checkerslib
*/

#include "zone.h"
#include "zonecrt.h"
#include "reverlib.h"
#include "revermov.h"

#define PieceAt(pState,col,row) ((pState)->board[row][col])
#define PieceAtSquare(pState,sq) ((pState)->board[(sq)->row][(sq)->col])

/* local prototypes */
ZBool ZReversiMoveEqual(ZReversiMove *pMove0, ZReversiMove *pMove1);

ZBool ZReversiSquareEqual(ZReversiSquare* pSquare0, ZReversiSquare* pSquare1)
{
	return (pSquare0->row == pSquare1->row &&
		pSquare0->col == pSquare1->col);
}

ZBool ZReversiMoveEqual(ZReversiMove* pMove0, ZReversiMove* pMove1)
{
	return  (ZReversiSquareEqual(&pMove0->square,&pMove1->square));
}


ZBool ZReversiPieceCanMoveTo(ZReversiMoveTry* pTry)
{
	ZReversiSquare* sq = &pTry->move.square;
	ZReversiState* state = &pTry->state;
	ZReversiState stateCopy;
	ZBool	rval;

	if (PieceAtSquare(state,sq)) {
		/* can't move on top of a square */
		return FALSE;
	}

	/* use a copy of the state so as not to effect later Flip calls */
	stateCopy = *state;
	stateCopy.lastMove = pTry->move;
	stateCopy.flipLevel = 0;

	/* if we can flip any then this was a legal move */
	rval = ZReversiFlipNext(&stateCopy);

	if (rval) {
		ZReversiPiece playersPiece = (ZReversiStatePlayerToMove(state) == zReversiPlayerWhite ?
					zReversiPieceWhite : zReversiPieceBlack);
		/* legal move, change the state */
		state->lastMove = pTry->move;
		state->board[state->lastMove.square.row][state->lastMove.square.col] = playersPiece;
		state->flipLevel = 0;
	}

	return rval;
}

#define INRANGE(x,x0,x1) ((x) <=(x1) && (x) >= (x0))

ZBool FlipHelp(ZReversiState* state, ZReversiSquare start, ZReversiSquare delta, ZReversiPiece playersPiece, ZReversiPiece opponentsPiece)
{
	ZBool flipped = FALSE;
	int16 i;
	int16 flipLevel = state->flipLevel;
	ZReversiSquare sq;
	ZReversiSquare toFlip;


	/* the first flipLevel pieces must be players */
	sq = start;
	for (sq.col += delta.col, sq.row+=delta.row, i = 1; 
			INRANGE(sq.col,0,7) && INRANGE(sq.row,0,7), i < flipLevel; 
			sq.col+=delta.col,sq.row+=delta.row, i++) {
		if (PieceAtSquare(state, &sq) == playersPiece) {
			continue;
		} else {
			/* not players piece, this direction invalid */
			return FALSE;
		}
	}

	/* here is the opponents piece, this will be the one to flip */
	toFlip = sq;
	if (INRANGE(sq.col,0,7) && INRANGE(sq.row,0,7) 
			&& PieceAtSquare(state, &sq) == opponentsPiece ) {
		for (; 
				INRANGE(sq.col,0,7) && INRANGE(sq.row,0,7); 
				sq.col+=delta.col,sq.row+=delta.row) {
			if (PieceAtSquare(state, &sq) == opponentsPiece) {
				continue;
			} else {
				if (PieceAtSquare(state, &sq) == playersPiece) {
					/* flip the first one... */
					state->board[toFlip.row][toFlip.col] = playersPiece;
					flipped = TRUE;
					break;
				} else {
					break;
				}
			}
		}
	}
	return flipped;
}
	

ZBool ZReversiFlipNext(ZReversiState* state)
{
	ZBool flipped = FALSE;
	ZReversiSquare* start = &state->lastMove.square;
	ZReversiPiece playersPiece;
	ZReversiPiece opponentsPiece;
	ZReversiSquare delta;
	int32 i,j;
	int32 direction;

	/* check all directions */
	playersPiece = (ZReversiStatePlayerToMove(state) == zReversiPlayerWhite ?
					zReversiPieceWhite : zReversiPieceBlack);
	opponentsPiece = (playersPiece == zReversiPieceWhite ?
						zReversiPieceBlack : zReversiPieceWhite);

	/* if this is the first time through, check all directions */
	if (state->flipLevel == 0) {
		for (direction = 0;direction < 9; direction++) {
			state->directionFlippedLastTime[direction] = TRUE;
		}
	}

	state->flipLevel ++;

	/* check all diretions, 9 of them! */
	for (i = -1;i <= 1; i++) {
		for (j = -1; j <= 1; j++) {
			direction = (i+1)*3 + j+1;
			delta.row = (BYTE)i;
			delta.col = (BYTE)j;
			if (state->directionFlippedLastTime[direction]) {
				state->directionFlippedLastTime[direction] = FlipHelp(state,*start, delta, playersPiece, opponentsPiece);
				flipped |= state->directionFlippedLastTime[direction];
			}
		}
	}

	return flipped;
}

ZBool ZReversiLegalMoveExists(ZReversiState* state, BYTE player)
{
	int16 i,j;
	ZReversiMoveTry ZRMtry;

	/* try all possible moves for this player */
	for (i = 0;i< 8;i++) {
		ZRMtry.move.square.row = (BYTE)i;
		for (j = 0; j < 8 ; j++) {
			ZRMtry.move.square.col = (BYTE)j;
			z_memcpy(&ZRMtry.state,state,sizeof(ZReversiState));
			ZRMtry.state.player = player;
			if (ZReversiPieceCanMoveTo(&ZRMtry)) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

void ZReversiCalculateScores(ZReversiState* state)
{
	BYTE i,j;
	int16 whiteScore = 0;
	int16 blackScore = 0;
	ZReversiSquare sq;
	ZReversiPiece piece;

	/* try all possible moves for this player */
	for (i = 0;i< 8;i++) {
		sq.row = i;
		for (j = 0; j < 8 ; j++) {
			sq.col = j;
			piece = PieceAtSquare(state,&sq);
			if (piece == zReversiPieceWhite) {
				whiteScore++;
			} else if (piece == zReversiPieceBlack) {
				blackScore++;
			}
		}
	}

	if (!ZReversiLegalMoveExists(state,zReversiPlayerWhite) &&
		!ZReversiLegalMoveExists(state,zReversiPlayerBlack) ) {
		if (whiteScore > blackScore) {
			state->flags |= zReversiFlagWhiteWins;
		} else if (blackScore > whiteScore) {
			state->flags |= zReversiFlagBlackWins;
		} else {
			state->flags |= zReversiFlagDraw;
		}
	}

	state->whiteScore = whiteScore;
	state->blackScore = blackScore;

	return;
}

void ZReversiNextPlayer(ZReversiState* state)
{
	state->player = (state->player+1) & 1;

	if (!ZReversiLegalMoveExists(state,state->player)) {
		/* well, lets see if the other guy has a legal move to play */
		state->player = (state->player+1) & 1;
	}
	
	ZReversiCalculateScores(state);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\client.h ===
/*******************************************************************************

	Client.h
	
		Spades client header file.
		
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on Friday, February 17, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		05/19/98	leonp	Dossier update.
	1		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
	0		02/17/96	HI		Created.
	 
*******************************************************************************/


#ifndef _SPADESCLIENT_
#define _SPADESCLIENT_

#include <tchar.h>
#include "zrollover.h"
#include "GraphicalAcc.h"
#include "SpadesRes.h"

typedef struct _ZClose
{
	//int32 state[4];			//record of events that have occured
	//int32 savedState[4];	//state saved when user hits close
	int32 state;
	
} ZClose;

#define I(object)					((Game) (object))
#define Z(object)					((ZCGame) (object))

#define zGameVersion				0x00010000

#define zGameNameLen				63

#define zHandScoreTimeout			2000						/* 20 seconds */
#define zShowTrickWinnerTimeout		50
#define zTrickWinnerTimeout			5
#define zEndTrickWinnerTimeout		50
#define zGameScoreTimeout			2000
#define zKibitzerTimeout			100
#define zShowBidTimeout				100

#define zNumAnimFrames				8
#define zNumAnimGhostFrames			3

/* The user's local seat location is 0. */
#define LocalSeat(game, n)			(((n) - (game)->seat + zSpadesNumPlayers) % zSpadesNumPlayers)

#ifndef SPADES_SIMPLE_UE
#define zDoneButtonStr				"Done"
#define zOptionsButtonStr			"Options"
#define zBeepOnTurnStr				"Beep on my turn"
#define zAnimateCardsStr			"Animate cards"
#endif // SPADES_SIMPLE_UE

#define zMaxNumBlockedMessages		4

#define DEFINE_SPADES_KEY(name)	\
    extern "C" __declspec(selectany) const TCHAR key_##name[] = _T( #name )


namespace SpadesKeys
{
// used by the CZoneColorFont
DEFINE_SPADES_KEY( Spades );
DEFINE_SPADES_KEY( Fonts );
DEFINE_SPADES_KEY( Font );
DEFINE_SPADES_KEY( Color );
DEFINE_SPADES_KEY( Rects );
DEFINE_SPADES_KEY( Game );
DEFINE_SPADES_KEY( GameRTL );
DEFINE_SPADES_KEY( Objects );
DEFINE_SPADES_KEY( HandScore );
DEFINE_SPADES_KEY( HandScoreRTL );
DEFINE_SPADES_KEY( GameOver );
DEFINE_SPADES_KEY( GameOverRTL );
DEFINE_SPADES_KEY( CardOffset );
DEFINE_SPADES_KEY( CardPopup );
DEFINE_SPADES_KEY( CardOutlinePenWidth );
DEFINE_SPADES_KEY( CardOutlineInset );
DEFINE_SPADES_KEY( CardOutlineRadius );
DEFINE_SPADES_KEY( Bidding );
DEFINE_SPADES_KEY( BiddingRTL );
DEFINE_SPADES_KEY( BiddingObjects );
DEFINE_SPADES_KEY( HistoryDialogs );
DEFINE_SPADES_KEY( HandsColumnWidth );
DEFINE_SPADES_KEY( PlayerColumnWidth );
DEFINE_SPADES_KEY( TotalColumnWidth );
//DEFINE_SPADES_KEY( GamesColumnWidth );
//DEFINE_SPADES_KEY( TeamColumnWidth );
DEFINE_SPADES_KEY( TrickWinnerColor );
DEFINE_SPADES_KEY( CardOutlineColor );
};


/* -------- Accelerators -------- */
enum
{
	zAccShowCards = 0,
	zAccDoubleNil = 1,
    zAccFirstBid = 2,

	zAccScore = 16,
	zAccAutoPlay = 17,
	zAccStop = 18,
    zAccHand = 19,

	zAccPlay = 32,
	zAccLastTrick = 33,
	zAccDone = 34,
	zNumberAccItems
};


enum
{
    zAccRectButton = 0,
    zAccRectCard,
    zAccRectBidding
};


enum 
{
    zBiddingStateOpen,  // 'double nil' and 'show cards'
    zBiddingStateChoose // 0 - 13
};


/* -------- Image Indices -------- */
enum
{
	/* Game Images */
	zImageCardBack,
    zImageGameOverBackground,
    zImageHandOverBackground,
	zNumGameImages

#ifndef SPADES_SIMPLE_UE
    ,
	zHelpTextID,
	zRoomHelpTextID,
#endif // SPADES_SIMPLE_UE
};

extern const int __declspec(selectany) 
IMAGE_IDS[zNumGameImages] = 
{
    IDB_CARDBACK,
    IDB_GAMEOVERBACKGROUND,
    IDB_HANDOVERBACKGROUND
};



#define MAKEZRES( id )  (id-100)

// -------- String indices -----------//
enum
{
    zStringPlay,
    zStringAutoPlay,
    zStringStop,
    zStringScore,
    zStringLastTrick,
    zStringDone,
    zStringTeam1Name,
    zStringTeam2Name,
    zStringDoubleNil,
    zStringCantLeadSpades,
    zStringMustFollowSuit,
    zStringSelectCard,
    zStringHandScoreTitle,
    zStringHandScoreTricks,
    zStringHandScoreNBags,
    zStringHandScoreTract,
    zStringHandScoreBonus,
    zStringHandScoreNil,
    zStringHandScoreBags,
    zStringHandScoreTotal,
    zStringGameOverTitle,
    zStringBiddingShowCards,
    zStringBiddingNil,
    zStringBiddingDoubleNil,
    zStringBiddingOpenText,
    zStringBiddingChooseText,
    zStringYou,
    zNumStrings
};

extern const int __declspec(selectany) 
STRING_IDS[zNumStrings] = 
{
    IDS_PLAY,
    IDS_AUTOPLAY,
    IDS_STOP,
    IDS_SCORE,
    IDS_LASTTRICK,
    IDS_DONE,
    IDS_TEAM1NAME,
    IDS_TEAM2NAME,
    IDS_DOUBLENILBIDSTR,
    IDS_CANTLEADSPADES,
    IDS_MUSTFOLLOWSUIT,
    IDS_SELECTCARD,
    IDS_HANDSCORE_TITLE,
    IDS_HANDSCORE_TRICKS,
    IDS_HANDSCORE_NBAGS,
    IDS_HANDSCORE_TRACT,
    IDS_HANDSCORE_BONUS,
    IDS_HANDSCORE_NIL,
    IDS_HANDSCORE_BAGS,
    IDS_HISTORY_TOTAL,
    IDS_GAMEOVER_TITLE,
    IDS_BIDDING_SHOWCARDS,
    IDS_BIDDING_NIL,
    IDS_BIDDING_DOUBLENIL,
    IDS_BIDDING_OPENTEXT,
    IDS_BIDDING_CHOOSETEXT,
    IDS_SPADES_YOU
};


// -------- Font indices -------------
enum 
{
    zFontHandOverTitle = 0,
    zFontHandOverText,
    zFontHandOverTeamNames,
    zFontGameOverTitle,
    zFontGameOverText,
    zFontScore,
    zFontTeam1,
    zFontTeam2,
    zFontBid,
    zFontBiddingPaneText,
    zNumFonts
};


extern const LPCTSTR __declspec(selectany)
FONT_NAMES[zNumFonts] = 
{
    _T("HandOverTitle"),
    _T("HandOverText"),
    _T("HandOverTeamNames"),
    _T("GameOverTitle"),
    _T("GameOverText"),
    _T("Score"),
    _T("Team1"),
    _T("Team2"),
    _T("Bid"),
    _T("BiddingPaneText"),
};

/* -------- Timer Indicators -------- */
enum
{
	zGameTimerNone = 0,
	zGameTimerShowHandScore,
	zGameTimerShowTrickWinner,
	zGameTimerAnimateTrickWinner,
	zGameTimerEndTrickWinnerAnimation,
	zGameTimerShowGameScore,
	zGameTimerShowBid,
};


/* -------- Game Window Rectangles -------- */
enum
{
	zRectWindow = 0,
	zRectHand,
	zRectTable,
	zRectSouthCard,
	zRectWestCard,
	zRectNorthCard,
	zRectEastCard,
	zRectPlayButton,
	zRectAutoPlayButton,
	zRectLastTrickButton,
	zRectScoreButton,
	zRectSouthName,
	zRectWestName,
	zRectNorthName,
	zRectEastName,
	zRectSouthBid,
	zRectWestBid,
	zRectNorthBid,
	zRectEastBid,
	zRectLeftScorePad,
	zRectLeftBag,
	zRectLeftScore,
    zRectRightScorePad,
	zRectRightBag,
	zRectRightScore,
    zRectSouthLargeBid,
    zRectWestLargeBid,
    zRectNorthLargeBid,
    zRectEastLargeBid,
    // all unused
	zRectSouthJoiner,
	zRectWestJoiner,
	zRectNorthJoiner,
	zRectEastJoiner,
	zRectSouthKibitzer,
	zRectWestKibitzer,
	zRectNorthKibitzer,
	zRectEastKibitzer,
	zRectOptionJoiner,
	zRectOptionKibitzer,
	zNumRects
};
extern const LPCTSTR __declspec(selectany)
GAME_RECT_NAMES[zNumRects] = 
{
    _T("Window"),
    _T("Hand"),
    _T("Table"),
    _T("SouthCard"),
    _T("WestCard"),
    _T("NorthCard"),
    _T("EastCard"),
    _T("PlayButton"),
    _T("AutoPlayButton"),
    _T("LastTrickButton"),
    _T("ScoreButton"),
    _T("SouthName"),
    _T("WestName"),
    _T("NorthName"),
    _T("EastName"),
    _T("SouthBid"),
    _T("WestBid"),
    _T("NorthBid"),
    _T("EastBid"),
    _T("LeftScorePad"),
    _T("LeftBag"),
    _T("LeftScore"),
    _T("RightScorePad"),
    _T("RightBag"),
    _T("RightScore"),
    _T("SouthLargeBid"),
    _T("WestLargeBid"),
    _T("NorthLargeBid"),
    _T("EastLargeBid"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
    _T("Unused"),
};
	
enum
{

	/* -------- Game Object Rectangles -------- */
	zRectObjectTeam1Bid = 0,
    zRectObjectTeam2Bid,
    zRectObjectBidMask,
	zRectObjectBidLarge1,
	zRectObjectBidLargeNil = zRectObjectBidLarge1 + 13,
	zRectObjectBidLargeDoubleNil,
	zRectObjectBidLargeWaiting,
	zRectObjectBidLargeBlank,
	zRectObjectBidLargeMask,
	zRectObjectTeam1ScorePlate,
	zRectObjectTeam2ScorePlate,
	zRectObjectBag0,
	zRectObjectBagMask = zRectObjectBag0 + 10,
    zRectObjectButtonIdle,
    zRectObjectButtonSelected,
    zRectObjectButtonHighlighted,
    zRectObjectButtonDisabled,
    zRectObjectButtonMask,
	zNumObjectRects,
};
extern const LPCTSTR __declspec(selectany)
OBJECT_RECT_NAMES[zNumObjectRects] = 
{
    _T("Team1Bid"),
    _T("Team2Bid"),
    _T("BidMask"),
    _T("BidLarge1"),
    _T("BidLarge2"),
    _T("BidLarge3"),
    _T("BidLarge4"),
    _T("BidLarge5"),
    _T("BidLarge6"),
    _T("BidLarge7"),
    _T("BidLarge8"),
    _T("BidLarge9"),
    _T("BidLarge10"),
    _T("BidLarge11"),
    _T("BidLarge12"),
    _T("BidLarge13"),
    _T("BidLargeNil"),
    _T("BidLargeDoubleNil"),
    _T("BidLargeWaiting"),
    _T("BidLargeBlank"),
    _T("BidLargeMask"),
    _T("Team1ScorePlate"),
    _T("Team2ScorePlate"),
    _T("Bag0"),
    _T("Bag1"),
    _T("Bag2"),
    _T("Bag3"),
    _T("Bag4"),
    _T("Bag5"),
    _T("Bag6"),
    _T("Bag7"),
    _T("Bag8"),
    _T("Bag9"),
    _T("BagMask"),
    _T("ButtonIdle"),
    _T("ButtonSelected"),
    _T("ButtonHighlighted"),
    _T("ButtonDisabled"),
    _T("ButtonMask")
};

enum
{
	/* -------- Hand Score Rectangles -------- */
	zRectHandScorePane = 0,
	zRectHandScoreTitle,
    zRectHandScoreTeamName1,
    zRectHandScoreTeamName2,
    zRectHandScoreTricksTitle,
    zRectHandScoreNBagsTitle,
	zRectHandScoreTractTitle,
	zRectHandScoreBonusTitle,
	zRectHandScoreNilTitle,
	zRectHandScoreBagsTitle,
	zRectHandScoreTotalTitle,
    zRectHandScoreTeamTricks1,
    zRectHandScoreTeamTricks2,
    zRectHandScoreTeamNBags1,
    zRectHandScoreTeamNBags2,
    zRectHandScoreTeamTract1,
    zRectHandScoreTeamTract2,
    zRectHandScoreTeamBonus1,
    zRectHandScoreTeamBonus2,
    zRectHandScoreTeamNil1,
    zRectHandScoreTeamNil2,
    zRectHandScoreTeamBags1,
    zRectHandScoreTeamBags2,
    zRectHandScoreTeamTotal1,
    zRectHandScoreTeamTotal2,
    zRectHandScoreCloseBox,
	zNumHandScoreRects
};

extern const LPCTSTR __declspec(selectany)
HANDSCORE_RECT_NAMES[zNumHandScoreRects] = 
{
    _T("Pane"),
    _T("Title"),
    _T("TeamName1"),
    _T("TeamName2"),
    _T("TricksTitle"),
    _T("NBagsTitle"),
    _T("TractTitle"),
    _T("BonusTitle"),
    _T("NilTitle"),
    _T("BagsTitle"),
    _T("TotalTitle"),
    _T("TeamTricks1"),
    _T("TeamTricks2"),
    _T("TeamNBags1"),
    _T("TeamNBags2"),
    _T("TeamTract1"),
    _T("TeamTract2"),
    _T("TeamBonus1"),
    _T("TeamBonus2"),
    _T("TeamNil1"),
    _T("TeamNil2"),
    _T("TeamBags1"),
    _T("TeamBags2"),
    _T("TeamTotal1"),
    _T("TeamTotal2"),
    _T("CloseBox")
};

	
enum
{
	/* -------- Game Over Score Rectangles -------- */
	zRectGameOverPane = 0,
	zRectGameOverTitle,
	zRectGameOverWinnerTeamName,
	zRectGameOverWinnerName1,
	zRectGameOverWinnerName2,
	zRectGameOverWinnerTeamScore,
	zRectGameOverLoserTeamName,
	zRectGameOverLoserName1,
	zRectGameOverLoserName2,
	zRectGameOverLoserTeamScore,
    zRectGameOverCloseBox,
	zNumGameOverRects
};
extern const LPCTSTR __declspec(selectany)
GAMEOVER_RECT_NAMES[zNumGameOverRects] = 
{
    _T("Pane"),
    _T("Title"),
    _T("WinnerTeamName"),
    _T("WinnerName1"),
    _T("WinnerName2"),
    _T("WinnerTeamScore"),
    _T("LoserTeamName"),
    _T("LoserName1"),
    _T("LoserName2"),
    _T("LoserTeamScore"),
    _T("CloseBox")
};


enum
{
	/* -------- Bidding window rectangles -------- */
	zRectBiddingPane = 0,
    zRectBiddingText,
    zRectBiddingLargeButtonLeft,
    zRectBiddingLargeButtonRight,
    zRectBiddingButton0,
    zRectBiddingButton1,
    zRectBiddingButton2,
    zRectBiddingButton3,
    zRectBiddingButton4,
    zRectBiddingButton5,
    zRectBiddingButton6,
    zRectBiddingButton7,
    zRectBiddingButton8,
    zRectBiddingButton9,
    zRectBiddingButton10,
    zRectBiddingButton11,
    zRectBiddingButton12,
    zRectBiddingButton13,
    zRectBiddingLargeShadow,
    zRectBiddingSmallShadow,
	zNumBiddingRects
};
extern const LPCTSTR __declspec(selectany)
BIDDING_RECT_NAMES[zNumBiddingRects] = 
{
    _T("Pane"),
    _T("Text"),
    _T("LargeButtonLeft"),
    _T("LargeButtonRight"),
    _T("BidButton0"),
    _T("BidButton1"),
    _T("BidButton2"),
    _T("BidButton3"),
    _T("BidButton4"),
    _T("BidButton5"),
    _T("BidButton6"),
    _T("BidButton7"),
    _T("BidButton8"),
    _T("BidButton9"),
    _T("BidButton10"),
    _T("BidButton11"),
    _T("BidButton12"),
    _T("BidButton13"),
    _T("LargeButtonShadow"),
    _T("SmallButtonShadow")
};


enum
{
	/* -------- Bidding object rectangles -------- */
	zRectBiddingObjectBackground  = 0,
    zRectBiddingObjectLargeButtonLeftIdle,
    zRectBiddingObjectLargeButtonLeftHighlighted,
    zRectBiddingObjectLargeButtonLeftSelected,
    zRectBiddingObjectLargeButtonLeftDisabled,
    zRectBiddingObjectLargeButtonRightIdle,
    zRectBiddingObjectLargeButtonRightHighlighted,
    zRectBiddingObjectLargeButtonRightSelected,
    zRectBiddingObjectLargeButtonRightDisabled,
    zRectBiddingObjectSmallButtonLeftIdle,
    zRectBiddingObjectSmallButtonLeftHighlighted,
    zRectBiddingObjectSmallButtonLeftSelected,
    zRectBiddingObjectSmallButtonLeftDisabled,
    zRectBiddingObjectSmallButtonCenterIdle,
    zRectBiddingObjectSmallButtonCenterHighlighted,
    zRectBiddingObjectSmallButtonCenterSelected,
    zRectBiddingObjectSmallButtonCenterDisabled,
    zRectBiddingObjectSmallButtonRightIdle,
    zRectBiddingObjectSmallButtonRightHighlighted,
    zRectBiddingObjectSmallButtonRightSelected,
    zRectBiddingObjectSmallButtonRightDisabled,
    zRectBiddingObjectLargeButtonShadow,
    zRectBiddingObjectSmallButtonShadow,
    zNumBiddingObjectRects
};


extern const LPCTSTR __declspec(selectany)
BIDDINGOBJECT_RECT_NAMES[zNumBiddingObjectRects] = 
{
    _T("Background"),
    _T("LargeButtonLeftIdle"),
    _T("LargeButtonLeftHighlighted"),	
    _T("LargeButtonLeftSelected"),     
    _T("LargeButtonLeftDisabled"),		
    _T("LargeButtonRightIdle"),		
    _T("LargeButtonRightHighlighted"),	
    _T("LargeButtonRightSelected"),	
    _T("LargeButtonRightDisabled"),	
    _T("SmallButtonLeftIdle"),			
    _T("SmallButtonLeftHighlighted"),  
    _T("SmallButtonLeftSelected"),		
    _T("SmallButtonLeftDisabled"),		
    _T("SmallButtonCenterIdle"),		
    _T("SmallButtonCenterHighlighted"),
    _T("SmallButtonCenterSelected"),	
    _T("SmallButtonCenterDisabled"),	
    _T("SmallButtonRightIdle"),		
    _T("SmallButtonRightHighlighted"), 
    _T("SmallButtonRightSelected"),	
    _T("SmallButtonRightDisabled"),
    _T("LargeButtonShadow"),
    _T("SmallButtonShadow")
};


enum
{
	/* -------- multi state fonts -------- */
    zMultiStateFontPlayingField,
    zMultiStateFontBiddingCenter,
    zMultiStateFontBiddingLeft,
    zMultiStateFontBiddingRight,
    zNumMultiStateFonts
};

extern const LPCWSTR __declspec(selectany)
MULTISTATE_FONT_NAMES[zNumMultiStateFonts] = 
{
    L"Spades/Fonts/Buttons/PlayingField",
    L"Spades/Fonts/Buttons/BiddingCenter",
    L"Spades/Fonts/Buttons/BiddingLeft",
    L"Spades/Fonts/Buttons/BiddingRight"
};


/////////////////////////////////////
//
// Game interface
class CGameGameSpades : public CGameGameImpl<CGameGameSpades>, public IGraphicallyAccControl
{
public:
	BEGIN_COM_MAP(CGameGameSpades)
		COM_INTERFACE_ENTRY(IGameGame)
		COM_INTERFACE_ENTRY(IGraphicallyAccControl)
	END_COM_MAP()

// IGameGame interface
public:
    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars);
    STDMETHOD(GameOverReady)();
    STDMETHOD_(HWND, GetWindowHandle)();
    STDMETHOD(ShowScore)();

// IGraphicallyAccControl interface
public:
	STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);
	STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie);
	STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie);
};


/* -------- Player Info -------- */
typedef struct
{
	ZUserID			userID;
	TCHAR           name[zUserNameLen + 1];
	TCHAR           host[zHostNameLen + 1];
} TPlayerInfo, *TPlayerInfoPtr;

// new info window
/*
class CInfoWnd
{
public:
    HWND Create( ZWindow parent );
    BOOL Destroy();
    BOOL Show();
    BOOL Hide();
    BOOL SetText( LPCTSTR pszText );

    HWND m_hWnd;
    HWND m_hWndText;

    static BOOL CALLBACK
    DlgProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
};
*/

class CZoneColorFont
{
public:
    HFONT m_hFont;
    ZONEFONT m_zf;
    COLORREF m_color;

    // only one of these should need to be valid 
    // for any one object, since drawing is done on one thread
    static HGDIOBJ m_hOldFont;
    static COLORREF m_colorOld;

    bool LoadFromDataStore( IDataStore *pIDS, LPCTSTR pszFontName );

    bool Select( HDC hdc );
    bool Deselect( HDC hdc );
};

// Bidding routines
class CBiddingDialog
{
public:
    static CBiddingDialog *Create( struct GameType *game );
    virtual bool Draw() = 0;
    virtual bool Show( bool fShow ) = 0;
    virtual bool Destroy() = 0;
    virtual bool IsVisible() = 0;
	virtual int GetState() = 0;
    // resets to the initial dialog
    virtual bool Reset() = 0;
    // in the game's client coordinates
    virtual bool GetRect( ZRect *prc ) = 0;
	static bool ShowCardsButtonFunc(ZRolloverButton button, int16 state, void* userData);
	static bool DoubleNilButtonFunc(ZRolloverButton button, int16 state, void* userData);
	static bool BidButtonFunc(ZRolloverButton button, int16 state, void* userData);

    ZRolloverButton m_pLargeButtons[2];
    ZRolloverButton m_pSmallButtons[14];
};

class CHistoryDialog
{
public:
    static CHistoryDialog *Create( struct GameType *game );

    // creates the dialog, rather than just the object
    virtual bool CreateHistoryDialog() = 0;
    virtual bool Destroy() = 0;
	virtual bool Close() = 0;
    virtual bool IsWindow() = 0;
	virtual bool IsActive() = 0;
    virtual bool BringWindowToTop() = 0;
    virtual bool Show( bool fShow ) = 0;
    virtual bool UpdateHand() = 0;
    virtual bool UpdateGame() = 0;
    virtual bool UpdateNames() = 0;

    virtual ~CHistoryDialog() { };
};


//
// This keeps track of when we incurred a bag penalty.
// which is needed for the score history dialog.
//
struct ZHandScore2
{
	int16		boardNumber;
	int16		rfu;
	char		bids[zSpadesNumPlayers];
	int16		tricksWon[zSpadesNumPlayers];
	int16		scores[zSpadesNumTeams];
//	int16		bonus[zSpadesNumTeams];

    // new for new Hand Result dialog
    int16       base[zSpadesNumTeams];
    int16       bagbonus[zSpadesNumTeams];
    int16       nil[zSpadesNumTeams];
    int16       bagpenalty[zSpadesNumTeams];
};

struct ZTotalScore2
{
	int16		numScores;
	int16		rfu;
	int16		totalScore[zSpadesNumTeams];
	ZHandScore2	scores[zSpadesMaxNumScores];
};



/* -------- Game Info -------- */
struct GameType
{
	ZUserID			userID;
	int16			tableID;
	int16			seat;
	ZWindow			gameWindow;
    // back buffer--used in GameWindowDraw
    ZOffscreenPort  gameBackBuffer;
    // we will ALWAYS draw to this, which could either
    // be the window or the back buffer.
    ZGrafPort       gameDrawPort;
	ZRolloverButton playButton;
	ZRolloverButton autoPlayButton;
	ZRolloverButton lastTrickButton;
	ZRolloverButton scoreButton;

    RECT            rcFocus;
    DWORD           eFocusType;
    long            iFocus;

    bool            fSetFocusToHandASAP;

#ifndef SPADES_SIMPLE_UE
	ZButton			optionsButton;
#endif
	ZTimer			timer;
	int16			timerType;
	ZBool			showPlayerToPlay;
	ZBool			autoPlay;
	int16			playerType;
	ZBool			ignoreMessages;
	TPlayerInfo		players[zSpadesNumPlayers];
	ZUserID			playersToJoin[zSpadesNumPlayers];
    ZBool   		ignoreSeat[zSpadesNumPlayers];
	TCHAR			teamNames[zSpadesNumTeams][zUserNameLen + 1];
	int16			numKibitzers[zSpadesNumPlayers];
	ZLList			kibitzers[zSpadesNumPlayers];
	uint32			tableOptions[zSpadesNumPlayers];
	ZRect			cardRects[zSpadesNumCardsInHand];
	int16			lastClickedCard;
#ifndef SPADES_SIMPLE_UE
	ZHelpButton		helpButton;
#endif // SPADES_SIMPLE_UE
	ZBool			playButtonWasEnabled;
	ZBool			autoPlayButtonWasEnabled;
	ZBool			lastTrickButtonWasEnabled;
	ZBool			lastTrickShowing;
	int16			oldTimerType;
	int32			oldTimeout;
	ZBool			quitGamePrompted;
	ZBool			dontPromptUser;
	ZBool			beepOnTurn;
	ZBool			animateCards;
	ZBool			showCards;
	ZBool			showHandScore;
	ZBool			showGameOver;
	ZBool			showPassText;
	ZBool			removePlayerPending;
	ZBool			hideCardsFromKibitzer;
	ZBool			kibitzersSilencedWarned;
	ZBool			kibitzersSilenced;
	
	/* Current Game State Info */
	int16			gameState;
	int16			playerToPlay;
	int16			numCardsInHand;
	ZBool			trumpsBroken;
	int16			toBid;
	int16			needToPass;
	int16			leadPlayer;
	int16			numHandsPlayed;
	int16			numGamesPlayed;
	int16			boardNumber;
	char			cardsPlayed[zSpadesNumPlayers];
	char			cardsInHand[zSpadesNumCardsInHand];
	ZBool			cardsSelected[zSpadesNumCardsInHand];
	char            cardsReceived[zSpadesNumCardsInPass];
	char 			bids[zSpadesNumPlayers];
	char			cardsLastTrick[zSpadesNumPlayers];
	int16			tricksWon[zSpadesNumPlayers];
	int16			bags[zSpadesNumTeams];
	char			winners[zSpadesNumPlayers];
	ZTotalScore2	scoreHistory;
	ZWins			wins;
	
	/* Game Options */
	uint32			gameOptions;
	int16			numPointsInGame;
	int16			minPointsInGame;
	
	/* Trick Winner Animation */
	ZRect			ghostFrames[zSpadesNumPlayers - 1][zNumAnimGhostFrames];
	ZRect			winnerRect;
	ZRect			loserRects[zSpadesNumPlayers - 1];
	int16			loserSeats[zSpadesNumPlayers - 1];
	int16			trickWinner;
	int16			trickWinnerFrame;
	ZBool			animatingTrickWinner;
	
	/* Show Player Items */
	ZWindow			showPlayerWindow;
	TCHAR**			showPlayerList;
	int16			showPlayerCount;

    /* dialogs */
    //CInfoWnd        wndInfo;
    CBiddingDialog  *pBiddingDialog;
    CHistoryDialog  *pHistoryDialog;

	/*Dossier information*/
	ZBool			fVotingLock;    //set to true diring voting to prevent playing
	int16 			rgDossierVote[zNumPlayersPerTable]; 
	HWND            voteDialog;
	int16 			voteMap[zNumPlayersPerTable];
	ZClose			closeState;
	int16			fShownCards;

};
typedef GameType *Game;

typedef struct
{
	Game			game;
	int16			requestSeat;
	int16			targetSeat;
} RemovePlayerType, *RemovePlayer;


#ifdef ZONECLI_DLL

/* -------- Volatible Globals & Macros -------- */
typedef struct
{
	TCHAR			m_gGameDir[zGameNameLen + 1];
	TCHAR			m_gGameName[zGameNameLen + 1];
	TCHAR			m_gGameDataFile[zGameNameLen + 1];
	TCHAR			m_gGameServerName[zGameNameLen + 1];
	uint32			m_gGameServerPort;
	ZImage			m_gGameIdle;
	ZImage			m_gGaming;
	ZImage			m_gGameImages[zNumGameImages];
    ZOffscreenPort  m_gBackground;
	ZOffscreenPort	m_gObjectBuffer;
	ZOffscreenPort	m_gHandBuffer;
	ZOffscreenPort	m_gBiddingObjectBuffer;
    ZColor          m_gCardOutlineColor;
    ZColor          m_gTrickWinnerColor;
	ZPoint			m_gTrickWinnerPos[zSpadesNumPlayers][zSpadesNumPlayers][zNumAnimFrames];
	ZRect			m_gTrickWinnerBounds;
    ZImage          m_gBidMadeMask;
	ZImage			m_gLargeBidMask;
	ZImage			m_gBagMask;
    // rollover button images--made from the gObjectBuffer
    ZImage          m_gButtonMask;
	ZRect			m_gRects[zNumRects];
	ZRect			m_gObjectRects[zNumObjectRects];
	ZRect			m_gHandScoreRects[zNumHandScoreRects];
	ZRect			m_gGameOverRects[zNumGameOverRects];
    ZRect           m_gBiddingRects[zNumBiddingRects];
    ZRect           m_gBiddingObjectRects[zNumBiddingObjectRects];
    // localized strings
    TCHAR           m_gStrings[zNumStrings][1024];
    CZoneColorFont  m_gFonts[zNumFonts];
    // the rollover button fonts.
    IZoneMultiStateFont *m_gpButtonFonts[zNumMultiStateFonts];
    // card outline stuff read in from datastore
    LONG            m_glCardOutlinePenWidth;
    LONG            m_glCardOutlineInset;
    LONG            m_glCardOutlineRadius;
	// Accessibility Interface
	CComPtr<IGraphicalAccessibility>    m_gGAcc;

    HBITMAP         m_gFocusPattern;
    HBRUSH          m_gFocusBrush;
    HPEN            m_gFocusPen;

    HACCEL          m_ghAccelDone;
    HACCEL          m_ghAccelDouble;
} GameGlobalsType, *GameGlobals;

#define gGameDir				(pGameGlobals->m_gGameDir)
#define gGameName				(pGameGlobals->m_gGameName)
#define gGameDataFile			(pGameGlobals->m_gGameDataFile)
#define gGameServerName			(pGameGlobals->m_gGameServerName)
#define gGameServerPort			(pGameGlobals->m_gGameServerPort)
#define gGameIdle				(pGameGlobals->m_gGameIdle)
#define gGaming					(pGameGlobals->m_gGaming)
#define gGameImages				(pGameGlobals->m_gGameImages)
#define gBackground			    (pGameGlobals->m_gBackground)
#define gObjectBuffer			(pGameGlobals->m_gObjectBuffer)
#define gHandBuffer				(pGameGlobals->m_gHandBuffer)
#define gBiddingObjectBuffer	(pGameGlobals->m_gBiddingObjectBuffer)
#define gCardOutlineColor		(pGameGlobals->m_gCardOutlineColor)
#define gTrickWinnerColor		(pGameGlobals->m_gTrickWinnerColor)
#define gTrickWinnerPos			(pGameGlobals->m_gTrickWinnerPos)
#define gTrickWinnerBounds		(pGameGlobals->m_gTrickWinnerBounds)
#define gBidMadeMask			(pGameGlobals->m_gBidMadeMask)
#define gLargeBidMask			(pGameGlobals->m_gLargeBidMask)
#define gBagMask				(pGameGlobals->m_gBagMask)
#define gButtonMask		        (pGameGlobals->m_gButtonMask)
#define gRects				    (pGameGlobals->m_gRects)
#define gOptionsRects			(pGameGlobals->m_gOptionsRects)
#define gScoresRects			(pGameGlobals->m_gScoresRects)
#define gObjectRects			(pGameGlobals->m_gObjectRects)
#define gHandScoreRects			(pGameGlobals->m_gHandScoreRects)
#define gGameOverRects			(pGameGlobals->m_gGameOverRects)
#define gBiddingRects			(pGameGlobals->m_gBiddingRects)
#define gBiddingObjectRects		(pGameGlobals->m_gBiddingObjectRects)
#define gStrings			    (pGameGlobals->m_gStrings)
#define gFonts			        (pGameGlobals->m_gFonts)
#define gpButtonFonts			(pGameGlobals->m_gpButtonFonts)
#define glCardOutlinePenWidth	(pGameGlobals->m_glCardOutlinePenWidth)
#define glCardOutlineInset	    (pGameGlobals->m_glCardOutlineInset)
#define glCardOutlineRadius	    (pGameGlobals->m_glCardOutlineRadius)
#define gGAcc					(pGameGlobals->m_gGAcc)
#define gFocusPattern           (pGameGlobals->m_gFocusPattern)
#define gFocusBrush             (pGameGlobals->m_gFocusBrush)
#define gFocusPen               (pGameGlobals->m_gFocusPen)
#define ghAccelDone             (pGameGlobals->m_ghAccelDone)
#define ghAccelDouble           (pGameGlobals->m_ghAccelDouble)

#endif


/* -------- External Routine Prototypes -------- */
ZError UIInit(void);
void UICleanUp(void);
ZError UIGameInit(Game game, int16 tableID, int16 seat, int16 playerType);
void UIGameDelete(Game game);
ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage);
void UpdateTable(Game game);
void UpdatePlayedCard(Game game, int16 seat);
void UpdatePlayer(Game game, int16 seat);
void UpdatePlayers(Game game);
void UpdateJoinerKibitzers(Game game);
void UpdateHand(Game game);
void UpdateOptions(Game game);
void UpdateBid(Game game, int16 seat);
void UpdateBidControls(Game game);
void UpdateHandScore(Game game);
void UpdateGameOver(Game game);
void OutlinePlayerCard(Game game, int16 seat, ZBool winner);
void ClearPlayerCardOutline(Game game, int16 seat);
void InitTrickWinner(Game game, int16 trickWinner);
void OptionsWindowUpdate(Game game, int16 seat);
void ShowHandScore(Game game);
void HideHandScore(Game game);
void ShowGameOver(Game game);
void HideGameOver(Game game);
void ShowPassText(Game game);
void HidePassText(Game game);

void SelectAllCards(Game game);
void UnselectAllCards(Game game);
int16 GetNumCardsSelected(Game game);
void PlayACard(Game game, int16 cardIndex);
void AutoPlayCard(Game game);
void NewGamePromptFunc(int16 result, void* userData);
void QuitGamePromptFunc(int16 result, void* userData);
void GameSendTalkMessage(ZWindow window, ZMessage* pMessage);
int SpadesFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... );
BOOL CenterWindow( HWND hWndToCenter, HWND hWndCenter );
LONG GetDataStoreUILong( const TCHAR *pszLong );

BOOL InitAccessibility(Game game, IGameGame *pIGG);
void EnableAutoplayAcc(Game game, bool fEnable);
void EnableLastTrickAcc(Game game, bool fEnable);

void ScoreButtonWork(Game game);


/* -------- Close Events-------- */
#define zCloseEventCloseRated		0x1
#define zCloseEventCloseUnRated		0x2
#define	zCloseEventCloseForfeit		0x4
#define	zCloseEventCloseAbort		0x8

#define zCloseEventBootStart		0x10
#define zCloseEventBootYes			0x20
#define zCloseEventBootNo			0x40

#define zCloseEventWaitStart		0x100
#define zCloseEventWaitYes			0x200
#define zCloseEventWaitNo			0x400

#define zCloseEventMoveTimeoutMe		0x1000
#define zCloseEventMoveTimeoutOther		0x2000
#define zCloseEventMoveTimeoutPlayed	0x4000

#define zCloseEventBotDetected		0x10000
#define zCloseEventPlayerReplaced	0x20000
#define zCloseEventForfeit			0x40000
#define zCloseEventAbandon			0x80000

#define zCloseEventGameStart		0x100000
#define zCloseEventGameEnd			0x200000
#define zCloseEventRatingStart		0x400000
#define zCloseEventPlayed			0x800000


void  ClosingState			(ZClose * close,int32 closeEvent,int16 seat);
ZBool ClosingRatedGame		(ZClose * close);
ZBool ClosingWillForfeit	(ZClose * close);
ZBool ClosingDisplayChange	(ZClose * pClose,ZRect *rect,ZWindow parentWindow);



#endif _SPADESCLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\history.cpp ===
//
// Score history dialog proc
//
#include "zone.h"
#include "zroom.h"
#include "spades.h"
#include "zonecli.h"
#include "zui.h"
#include "client.h"
#include "ZoneDebug.h"
#include "ZoneResource.h"
#include "SpadesRes.h"
#include <commctrl.h>
#include "UAPI.h"


enum 
{
    zImageListIconSpade,
    zImageListIconBag,
    zImageListIconBlank,
    zNumImageListIcons
};

static const int IMAGELIST_ICONS[zNumImageListIcons] =
{
    IDI_SPADE,
    IDI_BAG,
    IDI_BLANK
};  

#define WM_UPDATESCORES     (WM_USER+4321)
#define WM_UPDATENAMES      (WM_USER+4322)



class CHistoryDialogImpl : public CHistoryDialog
{
public:
    CHistoryDialogImpl( Game game )
    {
		m_bActive = false;
        m_game = game;
        m_hWndGames = m_hWndHands = NULL;
        m_hImageList = NULL;
    }
    ~CHistoryDialogImpl()
    {
        if ( m_hWndHands )
        {
            DestroyWindow( m_hWndHands );
        }
        if ( m_hWndGames )
        {
            DestroyWindow( m_hWndGames );
        }
        if ( m_hImageList )
        {
            ImageList_Destroy( m_hImageList );
        }
    }

    bool _Create();

	bool Close()
	{
        if ( ::IsWindow( m_hWndHands ) )
        {
			::PostMessage(m_hWndHands, WM_CLOSE, 0, 0);
			return true;
        }
		return false;
	}

    virtual bool CreateHistoryDialog()
    {
        m_hWndHands = ZShellResourceManager()->CreateDialogParam( NULL, MAKEINTRESOURCE( IDD_SCORES ),
                                                    ZWindowWinGetWnd( m_game->gameWindow ), 
                                                    HandHistoryDialogProc, (LPARAM)this );
        if ( m_hWndHands )
        {
            ZShellZoneShell()->AddDialog(m_hWndHands, true);
			m_bActive = true;
            return true;
        }
        return false;
    }
    virtual bool Destroy()
    {
        ::DestroyWindow( m_hWndHands );
        return true;
    }
	virtual bool IsActive()
	{
		return m_bActive;
	}
    virtual bool IsWindow()
    {
        return ::IsWindow( m_hWndHands ) == TRUE;
    }
    virtual bool BringWindowToTop()
    {
        ::BringWindowToTop( m_hWndHands );
        return true;
    }
    virtual bool Show( bool fShow )
    {
        ShowWindow( m_hWndHands, fShow ? SW_SHOW : SW_HIDE );
        return true;
    }
    virtual bool UpdateHand()
    {
        ::PostMessage( m_hWndHands, WM_UPDATESCORES, 0, 0 );
        return true;
    }
    virtual bool UpdateGame()
    {
        return false;
    }
    virtual bool UpdateNames()
    {
        ::PostMessage( m_hWndHands, WM_UPDATENAMES, 0, 0 );
        return false;    
    }

    static INT_PTR CALLBACK HandHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK GameHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

    void AddHandData();
    void AddGameData();

    long GetColumnWidth( const TCHAR *pszWidthKey, long lDefault )
    {
        using namespace SpadesKeys;
        const TCHAR *arKeys[3] = { key_Spades, key_HistoryDialogs, pszWidthKey };
        long lWidth;
        RECT rc;
        if ( FAILED( ZShellDataStoreUI()->GetLong( arKeys, 3, &lWidth ) ) )
        {
            return lDefault;
        }
        SetRect( &rc, 0, 0, lWidth, 0 );
        MapDialogRect( m_hWndHands, &rc );
        return rc.right;
    }

private:
    Game m_game;

	bool m_bActive;

    HWND m_hWndHands;
    HWND m_hWndGames;
    HIMAGELIST m_hImageList;
};


//static 
CHistoryDialog *CHistoryDialog::Create( struct GameType *game )
{
    CHistoryDialogImpl *pImpl = new CHistoryDialogImpl( game );
    if ( !pImpl )
    {
        return NULL;
    }
    if ( !pImpl->_Create() )
    {
        delete pImpl;
        return NULL;
    }
    return pImpl;
}


bool CHistoryDialogImpl::_Create()
{
    // create the image list.
    m_hImageList = ImageList_Create( 16, 16, ILC_MASK, zNumImageListIcons, 0 );

    for ( int i=0; i < zNumImageListIcons; i++ )
    {
        HICON hIcon = ZShellResourceManager()->LoadImage(MAKEINTRESOURCE(IMAGELIST_ICONS[i]), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        if ( !hIcon )
        {
            return false;
        }
        ImageList_AddIcon( m_hImageList, hIcon );
    }
    return true;
}


void CHistoryDialogImpl::AddHandData()
{            
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    HWND phWndLists[2];
    phWndLists[0] = GetDlgItem( m_hWndHands, IDC_SCORES_TEAM1HANDS );
    phWndLists[1] = GetDlgItem( m_hWndHands, IDC_SCORES_TEAM2HANDS );

    TCHAR szTricksWon[10];
    TCHAR szBid[10];

        // fill in the hand list.
    for ( int i=0; i < m_game->scoreHistory.numScores; i++ )
    {
        TCHAR szTemp[256];
        _itot( m_game->scoreHistory.scores[i].boardNumber+1, szTemp, 10 );
        
        lvi.mask = LVIF_TEXT|LVIF_IMAGE;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        lvi.pszText = szTemp;
        // make sure the hand winner has the spade. If the scores are the same,
        // than no one gets the spade.
        if ( m_game->scoreHistory.scores[i].scores[0] > m_game->scoreHistory.scores[i].scores[1] )
        {
            lvi.iImage = zImageListIconSpade;
            ListView_InsertItem( phWndLists[0], &lvi );

            lvi.iImage = zImageListIconBlank;
            ListView_InsertItem( phWndLists[1], &lvi );
        }
        else if ( m_game->scoreHistory.scores[i].scores[1] > m_game->scoreHistory.scores[i].scores[0] )
        {
            lvi.iImage = zImageListIconBlank;
            ListView_InsertItem( phWndLists[0], &lvi );

            lvi.iImage = zImageListIconSpade;
            ListView_InsertItem( phWndLists[1], &lvi );
        }
        else // tie
        {
            lvi.iImage = zImageListIconBlank;
            ListView_InsertItem( phWndLists[0], &lvi );
            ListView_InsertItem( phWndLists[1], &lvi );
        }

        lvi.mask &= ~LVIF_IMAGE;
        // team 1
        // player 1
        for ( int j=0; j < zSpadesNumTeams; j++ )
        {
            lvi.iSubItem = 1;
            _itot( m_game->scoreHistory.scores[i].tricksWon[j], szTricksWon, 10 );
            if ( m_game->scoreHistory.scores[i].bids[j] == zSpadesBidDoubleNil )
            {
                lstrcpy( szBid, gStrings[zStringDoubleNil] );
            }
            else
            {
                _itot( m_game->scoreHistory.scores[i].bids[j], szBid, 10 );
            }
            SpadesFormatMessage( szTemp, NUMELEMENTS(szTemp), IDS_TRICKCOUNTER, szTricksWon, szBid );
            ListView_SetItem( phWndLists[j], &lvi );

            // player 3
            lvi.iSubItem = 2;
            _itot( m_game->scoreHistory.scores[i].tricksWon[j+2], szTricksWon, 10 );
            if ( m_game->scoreHistory.scores[i].bids[j+2] == zSpadesBidDoubleNil )
            {
                lstrcpy( szBid, gStrings[zStringDoubleNil] );
            }
            else
            {
                _itot( m_game->scoreHistory.scores[i].bids[j+2], szBid, 10 );
            }
            SpadesFormatMessage( szTemp, NUMELEMENTS(szTemp), IDS_TRICKCOUNTER, szTricksWon, szBid );
            ListView_SetItem( phWndLists[j], &lvi );

            // total
            lvi.iSubItem = 3;
            lvi.mask |= LVIF_IMAGE;
            lvi.iImage = m_game->scoreHistory.scores[i].bagpenalty[j] ? zImageListIconBag : zImageListIconBlank;
            _itot( m_game->scoreHistory.scores[i].scores[j], szTemp, 10 );
            ListView_SetItem( phWndLists[j], &lvi );

            lvi.mask &= ~LVIF_IMAGE;
        }

		// always select the first item in the list
		if(i == 0)
		{
			ListView_SetItemState (phWndLists[0],			// handle to listview
									  0,					// index to listview item
									  LVIS_FOCUSED | LVIS_SELECTED, // item state
									  0x000F);                      // mask
			ListView_SetItemState (phWndLists[1],			// handle to listview
									  0,					// index to listview item
									  LVIS_FOCUSED | LVIS_SELECTED, // item state
									  0x000F);                      // mask
		}
    }
}

// static
INT_PTR CHistoryDialogImpl::HandHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    static CHistoryDialogImpl *pThis;
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    
    BOOL fHandled = TRUE;

    if ( !ConvertMessage( hWnd, message, &wParam, &lParam ) )
    {
        return FALSE;
    }
    int i;
    HWND phWndLists[2];
    LVCOLUMN lvc;
    TCHAR szHands[256];
    TCHAR szTotal[256];
    using namespace SpadesKeys;
    Game game;

    switch ( message )
    {
    case WM_INITDIALOG: 


        pThis = (CHistoryDialogImpl *)lParam;
        game = pThis->m_game;
        pThis->m_hWndHands = hWnd;

        CenterWindow( hWnd, NULL );

        szHands[0] = _T('\0');
        szTotal[0] = _T('\0');
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvc.fmt = LVCFMT_LEFT;

        ZShellResourceManager()->LoadString( IDS_HISTORY_HANDS, szHands, NUMELEMENTS(szHands) );
        ZShellResourceManager()->LoadString( IDS_HISTORY_TOTAL, szTotal, NUMELEMENTS(szTotal) );

        // fill out the hand list views
        phWndLists[0] = GetDlgItem( hWnd, IDC_SCORES_TEAM1HANDS );
        phWndLists[1] = GetDlgItem( hWnd, IDC_SCORES_TEAM2HANDS );

        for ( i=0; i < NUMELEMENTS(phWndLists); i++ )
        {
            ListView_SetExtendedListViewStyle( phWndLists[i], LVS_EX_SUBITEMIMAGES );
            ListView_SetImageList( phWndLists[i], pThis->m_hImageList, LVSIL_SMALL );

            lvc.cx = pThis->GetColumnWidth( key_HandsColumnWidth, 45 );
            lvc.pszText = szHands;
            ListView_InsertColumn( phWndLists[i], 0, &lvc );
        }

        lvc.cx = pThis->GetColumnWidth( key_PlayerColumnWidth, 85 );
        lvc.pszText = (game->seat == 0 ? gStrings[zStringYou] : game->players[0].name);
        ListView_InsertColumn( phWndLists[0], 1, &lvc );

        lvc.pszText = (game->seat == 2 ? gStrings[zStringYou] : game->players[2].name);
        ListView_InsertColumn( phWndLists[0], 2, &lvc );

        lvc.cx = pThis->GetColumnWidth( key_TotalColumnWidth, 65 );
        lvc.pszText = szTotal;
        ListView_InsertColumn( phWndLists[0], 3, &lvc );

        lvc.cx = pThis->GetColumnWidth( key_PlayerColumnWidth, 85 );
        lvc.pszText = (game->seat == 1 ? gStrings[zStringYou] : game->players[1].name);
        ListView_InsertColumn( phWndLists[1], 1, &lvc );

        lvc.pszText = (game->seat == 3 ? gStrings[zStringYou] : game->players[3].name);
        ListView_InsertColumn( phWndLists[1], 2, &lvc );

        lvc.cx = pThis->GetColumnWidth( key_TotalColumnWidth, 65 );
        lvc.pszText = szTotal;
        ListView_InsertColumn( phWndLists[1], 3, &lvc );

        pThis->AddHandData();
        return TRUE;

	case WM_CLOSE:
        // destroy the "child"
        if ( ::IsWindow( pThis->m_hWndGames ) )
        {
            DestroyWindow( pThis->m_hWndGames );
            pThis->m_hWndGames = NULL;
        }
        DestroyWindow( hWnd );
        pThis->m_hWndHands = NULL;
		break;

    case WM_DESTROY:
		pThis->m_bActive = false;
        ZShellZoneShell()->RemoveDialog( hWnd, true );
        break;

    case WM_UPDATESCORES:
        ListView_DeleteAllItems( GetDlgItem( hWnd, IDC_SCORES_TEAM1HANDS ) );
        ListView_DeleteAllItems( GetDlgItem( hWnd, IDC_SCORES_TEAM2HANDS ) );
        pThis->AddHandData();
        break;

    case WM_UPDATENAMES:
        game = pThis->m_game;
        phWndLists[0] = GetDlgItem( hWnd, IDC_SCORES_TEAM1HANDS );
        phWndLists[1] = GetDlgItem( hWnd, IDC_SCORES_TEAM2HANDS );
        lvc.mask = LVCF_TEXT;

        for ( i=0; i < zSpadesNumPlayers; i++ )
        {
            lvc.pszText = (game->seat == i ? gStrings[zStringYou] : game->players[i].name);
            ListView_SetColumn( phWndLists[i%2], (i >> 1)+1, &lvc );
        }
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDCANCEL:
            // destroy the "child"
            if ( ::IsWindow( pThis->m_hWndGames ) )
            {
                DestroyWindow( pThis->m_hWndGames );
                pThis->m_hWndGames = NULL;
            }
            DestroyWindow( hWnd );
            pThis->m_hWndHands = NULL;
            break;

        /*
        case IDC_SCORES_GAMEHISTORY:
            if ( ::IsWindow( pThis->m_hWndGames ) )
            {
                ::BringWindowToTop( pThis->m_hWndGames );
            }
            else
            {
                pThis->m_hWndGames = ZShellResourceManager()->CreateDialogParam( NULL, MAKEINTRESOURCE( IDD_GAMES ),
                                                        pThis->m_hWndHands, GameHistoryDialogProc, (LPARAM)pThis );
            }
            break;
        */
        }

    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}



void CHistoryDialogImpl::AddGameData()
{
    /*
    TCHAR szTemp[256];
    HWND hWndList = GetDlgItem( m_hWndGames, IDC_GAMES_HISTORY );
    LVITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    for ( int i=0; i < m_game->wins.numGames; i++ )
    {
        lvi.iItem = m_game->numGamesPlayed - m_game->wins.numGames + i;
        lvi.iImage = zImageListIconBlank;
        _itot( lvi.iItem+1, szTemp, 10 );
        lvi.pszText = szTemp;
        lvi.iSubItem = 0;
        // insert this.
        lvi.iItem = ListView_InsertItem( hWndList, &lvi );
        ASSERT( lvi.iItem == i );


        if ( m_game->wins.gameScores[i][0] >= m_game->wins.gameScores[i][1] )
        {
            lvi.iSubItem = 1;
            lvi.iImage = zImageListIconSpade;
            _itot( m_game->wins.gameScores[i][0], szTemp, 10 );
            ListView_SetItem(  hWndList, &lvi );

            lvi.iImage = zImageListIconBlank;
            lvi.iSubItem = 2;
            _itot( m_game->wins.gameScores[i][1], szTemp, 10 );
            ListView_SetItem(  hWndList, &lvi );
        }
        else
        {
            lvi.iSubItem = 1;
            lvi.iImage = zImageListIconBlank;
            _itot( m_game->wins.gameScores[i][0], szTemp, 10 );
            ListView_SetItem(  hWndList, &lvi );

            lvi.iImage = zImageListIconSpade;
            lvi.iSubItem = 2;
            _itot( m_game->wins.gameScores[i][1], szTemp, 10 );
            ListView_SetItem(  hWndList, &lvi );
        }
    }
    */
}


//static 
INT_PTR CHistoryDialogImpl::GameHistoryDialogProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    static CHistoryDialogImpl *pThis;
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    
    BOOL fHandled = TRUE;

    if ( !ConvertMessage( hWnd, message, &wParam, &lParam ) )
    {
        return FALSE;
    }
    int i;
    LVCOLUMN lvc;
    HWND hWndList;
    TCHAR szGames[256];
    Game game;
    using namespace SpadesKeys;

    switch ( message )
    {
    case WM_INITDIALOG:  
        pThis = (CHistoryDialogImpl *)lParam;
        game = pThis->m_game;
        pThis->m_hWndGames = hWnd;

        CenterWindow( hWnd, NULL );

        szGames[0] = _T('\0');
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvc.fmt = LVCFMT_LEFT;

        /*
        ZShellResourceManager()->LoadString( IDS_HISTORY_GAMES, szGames, NUMELEMENTS(szGames) );

        hWndList = GetDlgItem( hWnd, IDC_GAMES_HISTORY );
        ListView_SetExtendedListViewStyle( hWndList, LVS_EX_SUBITEMIMAGES );
        ListView_SetImageList( hWndList, pThis->m_hImageList, LVSIL_SMALL );

        lvc.cx = pThis->GetColumnWidth( key_GamesColumnWidth, 65 );
        lvc.pszText = szGames;
        ListView_InsertColumn( hWndList, 0, &lvc );

        lvc.cx = pThis->GetColumnWidth( key_TeamColumnWidth, 100 );
        lvc.pszText = game->teamNames[0];
        ListView_InsertColumn( hWndList, 1, &lvc );

        lvc.pszText = game->teamNames[1];
        ListView_InsertColumn( hWndList, 2, &lvc );

        pThis->AddGameData();
        */
        return TRUE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDCANCEL:
            DestroyWindow( hWnd );
            pThis->m_hWndGames = NULL;
            break;
        }

    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spades.rc
//
#define IDD_DROP                        103
#define IDC_PLAYERA                     1000
#define IDC_PLAYERB                     1001
#define IDC_PLAYERC                     1002
#define IDC_RESPONSE_A                  1003
#define IDC_RESPONSE_B                  1004
#define IDC_RESPONSE_C                  1005
#define IDC_PROMPT                      1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\spades.cpp ===
/*******************************************************************************

	Spades.c
	
		Spades client.
		
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on Friday, February 17, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	15		08/06/97	leonp	Leonp - Fix for bug 1045 disable remove button after a player is removed
	14      06/30/97	leonp	Leonp - fix for bug 3561, check options window pointer before 
								attempting to invalidate it.
	13		06/19/97	leonp	Bugfix #293, behavior change, option button disabled 
								when last trick displayed
	12		06/18/97	leonp	Added ZWindowInvalidate to refresh window after a player
								is removed from the game bug #350
	11		02/04/97	HI		In HandleEndHandMessage(), show the score
								for equal length for players and kibitzers.
	10		12/18/96	HI		Cleaned up ZoneClientExit().
	9		12/18/96	HI		Cleaned up SpadesDeleteObjectsFunc().
    8       12/16/96    HI      Changed ZMemCpy() to memcpy().
	7		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
								Removed MSVCRT dependency.
	6		11/21/96	HI		Use game information from gameInfo in
								ZoneGameDllInit().
	5		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
								Modified code to use ZONECLI_DLL.
	4		10/31/96	HI		Kibitzers/joiners are no longer prompted when
								another players requests to remove a player.
								Set the game over timeout equally for players
								and kibitzers.
    3       10/23/96    HI      Changed ZClientMain() for new commandline
                                format.
	2		10/23/96	HI		Changed ZClientMain() for serverAddr being
								char* instead of int32 now.
	1		10/11/96	HI		Added controlHandle parameter to ZClientMain().
	0		02/17/96	HI		Created.
	 
*******************************************************************************/


#pragma warning (disable:4761)


#include <windows.h>

#include "zone.h"
#include "zroom.h"
#include "spades.h"
#include "zonecli.h"
#include "zonecrt.h"
#include "client.h"
#include "zui.h"
#include "resource.h"
#include "ZoneDebug.h"
#include "zgame.h"
#include "zonestring.h"
#include "zoneresource.h"

/* -------- Valid Card Errors -------- */
enum
{
	zCantLeadSpades = 1,
	zMustFollowSuit
}; 
static int gValidCardErrIndex[] =
{
    0,
    zStringCantLeadSpades,
    zStringMustFollowSuit
};


static ZRect			gPlayerReplacedRect = {0, 0, 280, 100};
static ZRect			gJoiningLockedOutRect = {0, 0, 260, 120};
static ZRect			gRemovePlayerRect = {0, 0, 280, 120};

/* -------- Internal Routine Prototypes -------- */
//dossier work
BOOL __stdcall DossierDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
static void HandleDossierDataMessage(Game game, ZSpadesMsgDossierData* msg);
static void HandleDossierVoteMessage(Game game,ZSpadesMsgDossierVote *msg);

static void HandleStartGameMessage(Game game, ZSpadesMsgStartGame* msg);
static void HandleReplacePlayerMessage(Game game, ZSpadesMsgReplacePlayer* msg);
static void HandleStartBidMessage(Game game, ZSpadesMsgStartBid* msg);
static void HandleStartPassMessage(Game game, ZSpadesMsgStartPass* msg);
static void HandleStartPlayMessage(Game game, ZSpadesMsgStartPlay* msg);
static void HandleEndHandMessage(Game game, ZSpadesMsgEndHand* msg);
static void HandleEndGameMessage(Game game, ZSpadesMsgEndGame* msg);
static void HandleBidMessage(Game game, ZSpadesMsgBid* msg);
static void HandlePlayMessage(Game game, ZSpadesMsgPlay* msg);
static void HandleNewGameMessage(Game game, ZSpadesMsgNewGame* msg);
static void HandleTalkMessage(Game game, ZSpadesMsgTalk* msg, DWORD cbMsg);
static void HandleGameStateResponseMessage(Game game, ZSpadesMsgGameStateResponse* msg);
static void HandleOptionsMessage(Game game, ZSpadesMsgOptions* msg);
static void HandleCheckInMessage(Game game, ZSpadesMsgCheckIn* msg);
static void HandleTeamNameMessage(Game game, ZSpadesMsgTeamName* msg);
static void HandleRemovePlayerRequestMessage(Game game, ZSpadesMsgRemovePlayerRequest* msg);
static void HandleRemovePlayerResponseMessage(Game game, ZSpadesMsgRemovePlayerResponse* msg);
static void HandleRemovePlayerEndGameMessage(Game game, ZSpadesMsgRemovePlayerEndGame* msg);

void GameSendTalkMessage(ZWindow window, ZMessage* pMessage);
static void PlayerPlayedCard(Game game, int16 seat, char card);
static void NewGame(Game game);
static void NewHand(Game game);
void SelectAllCards(Game game);
void UnselectAllCards(Game game);
int16 GetNumCardsSelected(Game game);
static void HandAddCard(Game game, char card);
static void HandRemoveCard(Game game, char card);
static void SortHand(Game game);
static int16 GetCardIndexFromRank(Game game, char card);
void AutoPlayCard(Game game);
static int16 TrickWinner(Game game);

static ZError ValidCardToPlay(Game game, char card);
static int16 GetAutoPlayCard(Game game);
static void CountCardSuits(char* hand, int16 numCardsInHand, int16* counts);
static int16 GetCardHighestPlayedTrump(Game game);
static int16 GetCardHighestPlayed(Game game);
static int16 GetCardHighestPlayedSuit(Game game, int16 suit);
static int16 GetCardHighestUnder(char* hand, int16 numCardsInHand, int16 suit, int16 rank);
static int16 GetCardHighest(char* hand, int16 numCardsInHand, int16 suit);
static int16 GetCardLowestOver(char* hand, int16 numCardsInHand, int16 suit, int16 rank);
static int16 GetCardLowest(char* hand, int16 numCardsInHand, int16 suit);

void QuitGamePromptFunc(int16 result, void* userData);
void RemovePlayerPromptFunc(int16 result, void* userData);

static void LoadRoomImages(void);
static ZBool GetRoomObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
static void DeleteRoomObjectsFunc(void);

//dossier work
static void HandleDossierDataMessage(Game game, ZSpadesMsgDossierData* msg);
static void HandleDossierVoteMessage(Game game,ZSpadesMsgDossierVote *msg);


//
// i19n helper
//
int SpadesFormatMessage( LPTSTR pszBuf, int cchBuf, int idMessage, ... )
{
    int nRet;
    va_list list;
    TCHAR szFmt[1024];
    ZShellResourceManager()->LoadString( idMessage, szFmt, NUMELEMENTS(szFmt) );
    // our arguments really really really better be strings,
    // TODO: Figure out why FORMAT_MESSAGE_FROR_MODULE doesn't work.
    va_start( list, idMessage );
    nRet = FormatMessage( FORMAT_MESSAGE_FROM_STRING, szFmt, 
                          idMessage, 0, pszBuf, cchBuf, &list );
    va_end( list );     
    return nRet;
}




/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

ZError ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals;


	pGameGlobals = new GameGlobalsType;
	if (pGameGlobals == NULL)
		return (zErrOutOfMemory);
    ZeroMemory(pGameGlobals, sizeof(GameGlobalsType));

	ZSetGameGlobalPointer(pGameGlobals);
#endif

	lstrcpyn(gGameDir, gameInfo->game, zGameNameLen);
	lstrcpyn(gGameName, gameInfo->gameName, zGameNameLen);
	lstrcpyn(gGameDataFile, gameInfo->gameDataFile, zGameNameLen);
	lstrcpyn(gGameServerName, gameInfo->gameServerName, zGameNameLen);
	gGameServerPort = gameInfo->gameServerPort;
	return (zErrNone);
}


void ZoneGameDllDelete(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();


	if (pGameGlobals != NULL)
	{
		ZSetGameGlobalPointer(NULL);
		delete pGameGlobals;
	}
#endif
}


ZError ZoneClientMain(uchar *, IGameShell *piGameShell)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZError				err = zErrNone;


	if ((err = UIInit()) != zErrNone)
		return (err);
	
	LoadRoomImages();

	// Get accessibility interface
	if(FAILED(ZShellCreateGraphicalAccessibility(&gGAcc)))
		return zErrLaunchFailure;

	err = ZClient4PlayerRoom(gGameServerName, (uint16) gGameServerPort, gGameName,
			GetRoomObjectFunc, DeleteRoomObjectsFunc, NULL);

	return err;
}


void ZoneClientExit(void)
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

	// release the accessibility interface
	gGAcc.Release();

	ZCRoomExit();
	UICleanUp();
}


void ZoneClientMessageHandler(ZMessage* message)
{
}


TCHAR* ZoneClientName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	return (gGameName);
}


TCHAR* ZoneClientInternalName(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	return (gGameDir);
}


ZVersion ZoneClientVersion(void)
{
	return (zGameVersion);
}


IGameGame* ZoneClientGameNew(ZUserID userID, int16 tableID, int16 seat, int16 playerType,
					ZRoomKibitzers* kibitzers)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game						newGame;
	int32						i;
	ZSpadesMsgClientReady		clientReady;
	ZSpadesMsgGameStateRequest	gameStateReq;
	ZPlayerInfoType				playerInfo;

	newGame = (Game) ZCalloc(1, sizeof(GameType));
	if (newGame != NULL)
	{
		//leonp - dossier service
		for(i=0;i<zNumPlayersPerTable;i++)
		{
			newGame->rgDossierVote[i] = zNotVoted;
			newGame->voteMap[i] = -1;
		}
		newGame->fVotingLock = FALSE;

		newGame->userID = userID;
		newGame->tableID = tableID;
		newGame->seat = seat;
		newGame->gameState = zSpadesGameStateInit;

        SetRectEmpty(&newGame->rcFocus);
        newGame->iFocus = -1;
        newGame->fSetFocusToHandASAP = false;
		
		ZCRoomGetPlayerInfo(userID, &playerInfo);
		
		if ( UIGameInit(newGame, tableID, seat, playerType) != zErrNone )
        {
            return NULL;
        }
		
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
			newGame->players[i].userID = 0;
			newGame->players[i].name[0] = '\0';
			newGame->players[i].host[0] = '\0';
            newGame->ignoreSeat[i]=FALSE;
			
			newGame->playersToJoin[i] = 0;
			newGame->numKibitzers[i] = 0;
			newGame->kibitzers[i] = ZLListNew(NULL);
			newGame->tableOptions[i] = 0;
		}
		
		newGame->numGamesPlayed = 0;
		newGame->wins.numGames = 0;
		for (i = 0; i < zSpadesNumTeams; i++)
			newGame->wins.wins[i] = 0;
		
		lstrcpy(newGame->teamNames[0], gStrings[zStringTeam1Name]);
		lstrcpy(newGame->teamNames[1], gStrings[zStringTeam2Name]);
		
		if (kibitzers != NULL)
		{
			for (i = 0; i < (int16) kibitzers->numKibitzers; i++)
			{
				ZLListAdd(newGame->kibitzers[kibitzers->kibitzers[i].seat], NULL,
						(void*) kibitzers->kibitzers[i].userID,
						(void*) kibitzers->kibitzers[i].userID, zLListAddLast);
				newGame->numKibitzers[kibitzers->kibitzers[i].seat]++;
			}
		}
	
		newGame->showPlayerToPlay = FALSE;
		newGame->autoPlay = FALSE;
		newGame->playerType = playerType;
		newGame->ignoreMessages = FALSE;
		
		newGame->animatingTrickWinner = FALSE;
		
		newGame->playButtonWasEnabled = FALSE;
		newGame->autoPlayButtonWasEnabled = FALSE;
		newGame->lastTrickButtonWasEnabled = FALSE;
		newGame->lastTrickShowing = FALSE;
		
		newGame->quitGamePrompted = FALSE;
		newGame->dontPromptUser = FALSE;
		newGame->beepOnTurn = FALSE;
		newGame->animateCards = TRUE;
		newGame->hideCardsFromKibitzer = FALSE;
		newGame->kibitzersSilencedWarned = FALSE;
		newGame->kibitzersSilenced = FALSE;
		newGame->removePlayerPending = FALSE;

#ifndef SPADES_SIMPLE_UE
		newGame->optionsWindow = NULL;
		newGame->optionsWindowButton = NULL;
		newGame->optionsBeep = NULL;
		newGame->optionsAnimateCards = NULL;
		newGame->optionsTeamNameEdit = NULL;
		for (i= 0; i < zSpadesNumPlayers; i++)
		{
			newGame->optionsKibitzing[i] = NULL;
			newGame->optionsJoining[i] = NULL;
		}
#endif // SPADES_SIMPLE_UE
	
		newGame->showPlayerWindow = NULL;
		newGame->showPlayerList = NULL;
		
		if (playerType == zGamePlayer || playerType == zGamePlayerJoiner)
		{
			clientReady.playerID = userID;
			clientReady.seat = seat;
			clientReady.protocolSignature = zSpadesProtocolSignature;
			clientReady.protocolVersion = zSpadesProtocolVersion;
			clientReady.version = ZoneClientVersion();
			ZSpadesMsgClientReadyEndian(&clientReady);
			ZCRoomSendMessage(tableID, zSpadesMsgClientReady, &clientReady, sizeof(ZSpadesMsgClientReady));
			
			if (playerType == zGamePlayer)
			{
                //newGame->wndInfo.SetText( gStrings[zStringClientReady] );
			}
			else
			{
                //newGame->wndInfo.SetText( gStrings[zStringCheckInInfo] );
				newGame->ignoreMessages = TRUE;
			}
		}
		else if (playerType == zGamePlayerKibitzer)
		{
			/* Request current game state. */
			gameStateReq.playerID = userID;
			gameStateReq.seat = seat;
			ZSpadesMsgGameStateRequestEndian(&gameStateReq);
			ZCRoomSendMessage(tableID, zSpadesMsgGameStateRequest, &gameStateReq, sizeof(gameStateReq));
            //newGame->wndInfo.SetText( gStrings[zStringKibitzerInfo] );
			
			newGame->ignoreMessages = TRUE;
		}

		NewGame(newGame);
		NewHand(newGame);

		ZeroMemory(&newGame->closeState,sizeof(ZClose));
		
		ZWindowShow(newGame->gameWindow);
        //newGame->wndInfo.Show();
	}
	
    IGameGame *pIGG = CGameGameSpades::BearInstance(newGame);
    if(!pIGG)
    {
        ZFree(newGame);
        return NULL;
    }

	InitAccessibility(newGame, pIGG);

	return pIGG;
}


void ZoneClientGameDelete(ZCGame game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game pThis = I(game);
	int16			i;

    gGAcc->CloseAcc();

	if (pThis != NULL)
	{
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
			ZLListDelete(pThis->kibitzers[i]);
		}
		
		UIGameDelete(pThis);
		
		ZFree(game);
	}
}


ZBool ZoneClientGameProcessMessage(ZCGame game, uint32 messageType, void* message, int32 messageLen)
{
	Game pThis = I(game);
	
	
	/* Are messages being ignored? */
	if (pThis->ignoreMessages == FALSE)
	{
		switch (messageType)
		{
			case zSpadesMsgStartGame:
				if( messageLen < sizeof( ZSpadesMsgStartGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleStartGameMessage(pThis, (ZSpadesMsgStartGame*) message);
				}
				break;
			case zSpadesMsgReplacePlayer:
				if( messageLen < sizeof( ZSpadesMsgReplacePlayer ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleReplacePlayerMessage(pThis, (ZSpadesMsgReplacePlayer*) message);
				}
				break;
			case zSpadesMsgStartBid:
				if( messageLen < sizeof( ZSpadesMsgStartBid ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleStartBidMessage(pThis, (ZSpadesMsgStartBid*) message);
				}
				break;
			case zSpadesMsgStartPlay:
				if( messageLen < sizeof( ZSpadesMsgStartPlay ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleStartPlayMessage(pThis, (ZSpadesMsgStartPlay*) message);
				}
				break;
			case zSpadesMsgEndHand:
				if( messageLen < sizeof( ZSpadesMsgEndHand ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleEndHandMessage(pThis, (ZSpadesMsgEndHand*) message);
				}
				break;
			case zSpadesMsgEndGame:
				if( messageLen < sizeof( ZSpadesMsgEndGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleEndGameMessage(pThis, (ZSpadesMsgEndGame*) message);
				}
				break;
			case zSpadesMsgBid:
				if( messageLen < sizeof( ZSpadesMsgBid ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleBidMessage(pThis, (ZSpadesMsgBid*) message);
				}
				break;
			case zSpadesMsgPlay:
				if( messageLen < sizeof( ZSpadesMsgPlay ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandlePlayMessage(pThis, (ZSpadesMsgPlay*) message);
				}
				break;
			case zSpadesMsgNewGame:
				if( messageLen < sizeof( ZSpadesMsgNewGame ) )
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleNewGameMessage(pThis, (ZSpadesMsgNewGame*) message);
				}
				break;
			case zSpadesMsgTalk:
            {
                ZSpadesMsgTalk *msg = (ZSpadesMsgTalk *) message;
				if(messageLen < sizeof(ZSpadesMsgTalk))
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleTalkMessage(pThis, msg, messageLen);
				}
				break;
            }

            // server still sends this.  removed, but need to ignore instead of alert until new
            // server bits are propped
			case zSpadesMsgOptions:
				break;

			case zSpadesMsgPass:
			case zSpadesMsgStartPass:
			case zSpadesMsgCheckIn:
			case zSpadesMsgTeamName:
			case zSpadesMsgRemovePlayerRequest:
			case zSpadesMsgRemovePlayerResponse:
			case zSpadesMsgRemovePlayerEndGame:
			case zSpadesMsgDossierVote:
			case zSpadesMsgDossierData:
			default:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				break;

		}
	}
	else
	{
		/* Messages not to ignore. */
		switch (messageType)
		{
			case zSpadesMsgTalk:
            {
                ZSpadesMsgTalk *msg = (ZSpadesMsgTalk *) message;
				if(messageLen < sizeof(ZSpadesMsgTalk))
				{
					ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
				}
				else
				{
					HandleTalkMessage(pThis, msg, messageLen);
				}
				break;
            }

			default:
			case zSpadesMsgGameStateResponse:
				//These messages shouldn't be comming in for Whistler
				ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );	
				break;
		}
	}
	
	return (TRUE);
}


/*
	Add the given user as a kibitzer to the game at the given seat.
	
	This user is kibitzing the game.
*/
void		ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	Game pThis = I(game);
	
	
	ZLListAdd(pThis->kibitzers[seat], NULL, (void*) userID, (void*) userID, zLListAddLast);
	pThis->numKibitzers[seat]++;
	
	UpdateJoinerKibitzers(pThis);
}


/*
	Remove the given user as a kibitzer from the game at the given seat.
	
	This is user is not kibitzing the game anymore.
*/
void		ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID)
{
	Game pThis = I(game);
	
	
	if (userID == zRoomAllPlayers)
	{
		ZLListRemoveType(pThis->kibitzers[seat], zLListAnyType);
		pThis->numKibitzers[seat] = 0;
	}
	else
	{
		ZLListRemoveType(pThis->kibitzers[seat], (void*) userID);
		pThis->numKibitzers[seat] = (int16) ZLListCount(pThis->kibitzers[seat], zLListAnyType);
	}
	
	UpdateJoinerKibitzers(pThis);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
//dossier work blah
static void HandleDossierDataMessage(Game game, ZSpadesMsgDossierData* msg)
{
#ifndef SPADES_SIMPLE_UE
	int16 					dResult,i,j;
	TCHAR					buff[255];
	TCHAR					buff1[255];
	ZPlayerInfoType 		PlayerInfo;		
	HWND hwnd;

	GameGlobals pGameGlobals = (GameGlobalsType *)ZGetGameGlobalPointer();


	ZSpadesMsgDossierDataEndian(msg);
	switch(msg->message)
	{
		case zDossierMoveTimeout:
			 //don't alert player causing timeout or partner
           	if (game->playerType == zGamePlayer)
            {
			     if ((game->seat == msg->seat) || ((game->seat % 2)  == (msg->seat % 2)))
			     {
				    ClosingState(&game->closeState,zCloseEventMoveTimeoutMe,msg->seat);
			     }
			     else
			     {
				    ClosingState(&game->closeState,zCloseEventMoveTimeoutOther,msg->seat);
				    wsprintf(buff,RATING_TIMEOUT, msg->userName);
				    ZAlert(buff,NULL);
			     }
            }
            break;
		case zDossierBotDetected: 
			 ClosingState(&game->closeState,zCloseEventBotDetected,msg->seat);
             if (game->playerType == zGamePlayer)
			    ZAlert(RATING_ERROR, NULL);
			 break;
		case zDossierAbandonNoStart:
			 //ZCRoomGetPlayerInfo(msg->user, &PlayerInfo);
			 ClosingState(&game->closeState,zCloseEventAbandon,msg->seat);
			 wsprintf(buff,RATING_DISABLED, msg->userName);
             if (game->playerType == zGamePlayer)
             {
			    ZAlert(buff,NULL);
             }
			 break;
		case zDossierAbandonStart:

		     //kibitzers don't get this message
		     //todo: show some type of status to kibitzer
			 if (game->playerType != zGamePlayer)
			 	return;

		     if(ZRolloverButtonIsEnabled(game->playButton))
			    game->playButtonWasEnabled = TRUE;
			 else
			 	game->playButtonWasEnabled = FALSE;
			 	
			 //turn autoplay off
			 if (game->autoPlay)
			 {		
				/* Turn auto play off. */
				game->autoPlay = FALSE;
				ZRolloverButtonSetText(game->autoPlayButton, zAutoPlayButtonStr);
				ZRolloverButtonEnable(game->playButton);
		 	 } 
		 	 
			 if(ZRolloverButtonIsEnabled(game->autoPlayButton))
			 	game->autoPlayButtonWasEnabled = TRUE;
			 else
			 	game->autoPlayButtonWasEnabled = FALSE;
			 
			 if(ZRolloverButtonIsEnabled(game->lastTrickButton))
			 	game->lastTrickButtonWasEnabled = TRUE;
			 else
			 	game->lastTrickButtonWasEnabled = FALSE;

			 ZRolloverButtonDisable(game->playButton);
  			 ZRolloverButtonDisable(game->autoPlayButton);
  			 ZRolloverButtonDisable(game->lastTrickButton);
			 ZRolloverButtonDisable(game->optionsButton);
			 //vote and send the message to the server.
			 //ZCRoomGetPlayerInfo(msg->user, &PlayerInfo);
			
			 //set up mapping
			 for(i=0,j=0;i<=3;i++)	
			 {
			 	if(msg->user!=game->players[i].userID)
			 		game->voteMap[j++] = i;
			 }
			 
  	 		 game->voteMap[3] = -1;
             // this dialog doesn't exist, so this will fail, but
             // no one cares since we don't have ratings anyway.
			 game->voteDialog = ZShellResourceManager()->CreateDialogParam(NULL,
                                                        MAKEINTRESOURCE(IDD_DROP),
                                                        ZWindowWinGetWnd(game->gameWindow),
                                                        DossierDlgProc, NULL);
			 SetWindowLong(game->voteDialog,DWL_USER,(long)game);

			 //set the window names
			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERA);
			 SetWindowText(hwnd,game->players[game->voteMap[0]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERB);
			 SetWindowText(hwnd,game->players[game->voteMap[1]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PLAYERC);
			 SetWindowText(hwnd,game->players[game->voteMap[2]].name);

			 hwnd = GetDlgItem(game->voteDialog,IDC_PROMPT);
			 GetWindowText( hwnd, buff1, sizeof(buff1) );
			 wsprintf( buff, buff1, msg->userName );
			 SetWindowText(hwnd,buff);
			 
			 ShowWindow(game->voteDialog,SW_SHOW);
			 
			 game->fVotingLock = TRUE;
			 for(i=0;i<zNumPlayersPerTable;i++)
				game->rgDossierVote[i] = zNotVoted;

			 ClosingState(&game->closeState,zCloseEventWaitStart,msg->seat);

			 break;
		case zDossierMultiAbandon:
			 if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

			 ZRolloverButtonEnable(game->optionsButton);
          
	    	 ZAlert(RATING_MULTIPLE,NULL);
			     	 game->fVotingLock = FALSE;

		   	 if(game->voteDialog)
		     {
			 	DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;
			 
			 ClosingState(&game->closeState,zCloseEventWaitNo,msg->seat);

			 break;
		case zDossierRatingsReEnabled:
			 ClosingState(&game->closeState,zCloseEventRatingStart,msg->seat);
             if (game->playerType == zGamePlayer)
             {
    	  	 	 ZAlert(RATING_ENABLED,NULL);
             }
			 break;
		case zDossierRatingsEnabled: // occurs only at the start of game
			 ClosingState(&game->closeState,zCloseEventRatingStart,msg->seat);
	  	 	 break;
		case zDossierSpadesRejoin:  //send when the new player rejoins remove the dialog box

			 if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

			 ZRolloverButtonEnable(game->optionsButton);

		     game->fVotingLock = FALSE;  //release UI lock
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
			 }

			 //destroy the dialog box
			 if(game->voteDialog)
			 {
			 	DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;

             if (msg->seat != game->seat)
			    ClosingState(&game->closeState,zCloseEventWaitYes,msg->seat);

			 break;
		case zDossierVoteCompleteWait://no longer used.
			 game->fVotingLock = FALSE;  //release UI lock
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
			 }

  			 hwnd = GetDlgItem(game->voteDialog,IDNO);
  			 EnableWindow(hwnd,FALSE);
  			 
             break;

		case zDossierVoteCompleteCont:

			 ClosingState(&game->closeState,zCloseEventWaitNo,msg->seat);

			 if(game->playButtonWasEnabled)
				 ZRolloverButtonEnable(game->playButton);
		     			 			 	
			 if(game->autoPlayButtonWasEnabled)
			 	 ZRolloverButtonEnable(game->autoPlayButton);
			 	 
			 if(game->lastTrickButtonWasEnabled)
			 	ZRolloverButtonEnable(game->lastTrickButton);

			 ZRolloverButtonEnable(game->optionsButton);	

			 game->fVotingLock = FALSE;  //release UI lock.
			 for(i=0;i<zNumPlayersPerTable;i++)
			 {
			 	game->rgDossierVote[i] = zNotVoted;
				game->voteMap[i]= -1;
			}
			 			 
			 //destroy the dialog box
			 if(game->voteDialog)
			 {
				DestroyWindow(game->voteDialog);
			 }
			 game->voteDialog = NULL;

             if (game->playerType == zGamePlayer)
             {
                ZAlert(RATING_CONT_UNRATED, game->gameWindow);
             }
			 
		     break;

	} 
#endif // SPADES_SIMPLE_UE
	
}


void HandleDossierVoteMessage(Game game,ZSpadesMsgDossierVote *msg)
{
#ifndef SPADES_SIMPLE_UE
	//dossier system message 
	int16 i;
	HWND hwnd;
	TCHAR buff[255];
	
	ZSpadesMsgDossierVoteEndian(msg);
	
	game->rgDossierVote[msg->seat] = msg->vote;
	if(msg->vote == zVotedYes)
    {
        ZShellResourceManager()->LoadString( IDS_RATING_WAITMSG, buff, NUMELEMENTS(buff) );
    }
	else if(msg->vote == zVotedNo)
    {
        ZShellResourceManager()->LoadString( IDS_RATING_DONTWAITMSG, buff, NUMELEMENTS(buff) );
    }
		
	//voteDialog
	if(game->voteDialog)
	{
		//set the window names
		if(msg->seat == game->voteMap[0])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_A);
			SetWindowText(hwnd,buff);
		}
		else if(msg->seat == game->voteMap[1])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_B);
	  		SetWindowText(hwnd,buff);
	
		}
		else if(msg->seat == game->voteMap[2])
		{
			hwnd = GetDlgItem(game->voteDialog,IDC_RESPONSE_C);
			SetWindowText(hwnd,buff);
		}
			
	}
#endif
}

static void HandleStartGameMessage(Game game, ZSpadesMsgStartGame* msg)
{
	int16				i;
	ZPlayerInfoType		playerInfo;
	
	//leonp - dossier work.
	for(i=0;i<zNumPlayersPerTable;i++)
		game->rgDossierVote[i] = zNotVoted;
	game->fVotingLock = FALSE;
	
    //game->wndInfo.Hide();

	ZSpadesMsgStartGameEndian(msg);

// Message verification
    for(i = 0; i < zSpadesNumPlayers; i++)
        if(!msg->players[i] || msg->players[i] == zTheUser)
            break;

    // due to a bug on the server, this value isn't set in the message
    msg->minPointsInGame = -200;

    if(i != zSpadesNumPlayers || msg->numPointsInGame != 500 ||  msg->minPointsInGame != -200 ||
        msg->gameOptions != 0 || (game->gameState != zSpadesGameStateInit && game->gameState != zSpadesGameStateEndGame))
	{
        ASSERT(!"HandleStartGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->gameOptions = msg->gameOptions;
	game->gameState = zSpadesGameStateStartGame;
	game->numPointsInGame = msg->numPointsInGame;
	game->minPointsInGame = msg->minPointsInGame;

	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		ZCRoomGetPlayerInfo(msg->players[i], &playerInfo);

        if(!playerInfo.userName[0])
        {
            ASSERT(!"HandleStartGameMessage sync");
            ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
            return;
        }

		game->players[i].userID = playerInfo.playerID;
		lstrcpy( game->players[i].name, playerInfo.userName );
		lstrcpy( game->players[i].host, playerInfo.hostName );
	}

	NewGame(game);

#ifndef SPADES_SIMPLE_UE
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonShow(game->optionsButton);
	}
#endif // SPADES_SIMPLE_UE
	
	ZWindowDraw(game->gameWindow, NULL);

    // take down the upsell dialog
    ZShellGameShell()->GameOverGameBegun( Z(game) );
}


static void HandleReplacePlayerMessage(Game game, ZSpadesMsgReplacePlayer* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZPlayerInfoType		playerInfo;
	TCHAR               str[100];

	ZSpadesMsgReplacePlayerEndian(msg);

	ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);

// Message verification
    if(msg->playerID == 0 || msg->playerID == zTheUser || !playerInfo.userName[0] ||
        msg->seat < 0 || msg->seat > 3 || game->gameState == zSpadesGameStateInit)
    {
        ASSERT(!"HandleReplacePlayerMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	ASSERT( game != NULL );
	
	game->players[msg->seat].userID = msg->playerID;
	lstrcpy( game->players[msg->seat].name, playerInfo.userName);
	lstrcpy( game->players[msg->seat].host, playerInfo.hostName);
	
	UpdatePlayer(game, msg->seat);
	UpdateJoinerKibitzers(game);

    if ( game->pHistoryDialog )
    {
        game->pHistoryDialog->UpdateNames();
    }
}


static void HandleStartBidMessage(Game game, ZSpadesMsgStartBid* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int16 i, j;
	
	ZSpadesMsgStartBidEndian(msg);

// Message verification
    for(i = 0; i < zSpadesNumCardsInHand; i++)
    {
        for(j = 0; j < i; j++)
            if(msg->hand[i] == msg->hand[j])
                break;

        if(j < i || msg->hand[i] < 0 || msg->hand[i] >= 52)
            break;
    }

    if(i < zSpadesNumCardsInHand || msg->dealer < 0 || msg->dealer > 3 ||
        (game->gameState != zSpadesGameStateStartGame && game->gameState != zSpadesGameStateEndHand) || msg->boardNumber < 0)
    {
        ASSERT(!"HandleStartBidMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification
	
	NewHand(game);
	
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		game->cardsInHand[i] = msg->hand[i];
	game->boardNumber = msg->boardNumber;
	
	game->gameState = zSpadesGameStateBid;
	game->leadPlayer = game->playerToPlay = msg->dealer;
	game->toBid = zSpadesBidNone;
	
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonSetText(game->playButton, gStrings[zStringPlay]);
		ZRolloverButtonSetText(game->autoPlayButton, gStrings[zStringAutoPlay]);
		ZRolloverButtonSetText(game->lastTrickButton, gStrings[zStringLastTrick]);
		ZRolloverButtonSetText(game->scoreButton, gStrings[zStringScore]);
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDisable(game->autoPlayButton);
		ZRolloverButtonDisable(game->lastTrickButton);
		ZRolloverButtonEnable(game->scoreButton);
		ZRolloverButtonShow(game->playButton);
		ZRolloverButtonShow(game->autoPlayButton);
		ZRolloverButtonShow(game->lastTrickButton);
		ZRolloverButtonShow(game->scoreButton);

        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        EnableAutoplayAcc(game, false);
        EnableLastTrickAcc(game, false);
        gGAcc->SetItemEnabled(true, IDC_SCORE_BUTTON, false, 0);

		game->showCards = FALSE;

        if(game->playerToPlay == game->seat)
            ZShellGameShell()->MyTurn();
	}
	else
	{
		game->showCards = TRUE;
	}
    game->pBiddingDialog->Reset();
    game->pBiddingDialog->Show( true );

	game->showPlayerToPlay = TRUE;
	ZTimerSetTimeout(game->timer, 0);
	game->timerType = zGameTimerNone;
	
	ZWindowDraw(game->gameWindow, NULL);
}


static void HandleStartPassMessage(Game game, ZSpadesMsgStartPass* msg)
{
    /*
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZSpadesMsgStartPassEndian(msg);
	
	game->gameState = zSpadesGameStatePass;
	
	if (game->playerType == zGamePlayer)
	{
		if (msg->seat[game->seat] != 0)
		{
			game->needToPass = 1;
			ZRolloverButtonSetText(game->playButton, gStrings[zStringPass]);
			ZRolloverButtonEnable(game->playButton);
			
			ShowPassText(game);
		}
	}
	
	ZTimerSetTimeout(game->timer, 0);
	game->timerType = zGameTimerNone;
	
	ZWindowDraw(game->gameWindow, NULL);
    */
}


static void HandleStartPlayMessage(Game game, ZSpadesMsgStartPlay* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16			i;
	
	
	ZSpadesMsgStartPlayEndian(msg);

// Message verification
    for(i = 0; i < 4; i++)
        if(game->bids[i] == zSpadesBidNone)
            break;

    if(i < 4 || game->gameState != zSpadesGameStateBid || msg->leader < 0 || msg->leader > 3)
    {
        ASSERT(!"HandleStartPlayMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->gameState = zSpadesGameStatePlay;
	game->leadPlayer = game->playerToPlay = msg->leader;
	
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonSetText(game->playButton, gStrings[zStringPlay]);
		ZRolloverButtonEnable(game->autoPlayButton);
		ZRolloverButtonEnable(game->scoreButton);

        EnableAutoplayAcc(game, true);
        gGAcc->SetItemEnabled(true, IDC_SCORE_BUTTON, false, 0);

        if ( game->playerToPlay == game->seat )
        {
    		ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
        }
        else
        {
    		ZRolloverButtonDisable(game->playButton);
            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        }
	}
	else if(game->playerType == zGamePlayerJoiner)
	{
		game->showCards = TRUE;
	}
	
	if (game->needToPass < 0)
	{
		if (game->playerType != zGamePlayer)
		{
			/* Remove selected pass cards first. */
			for (i = 0; i < zSpadesNumCardsInHand; i++)
				if (game->cardsSelected[i])
				{
					game->cardsInHand[i] = zCardNone;
					game->numCardsInHand--;
				}
		}
		
		/* Add passed cards to hand. */
		for (i = 0; i < zSpadesNumCardsInPass; i++)
			HandAddCard(game, game->cardsReceived[i]);
		
		/* Sort new hand. */
		SortHand(game);
		
		/* Select passed cards. */
		UnselectAllCards(game);
		for (i = 0; i < zSpadesNumCardsInPass; i++)
			game->cardsSelected[GetCardIndexFromRank(game, game->cardsReceived[i])] = TRUE;

		UpdateHand(game);
	}
	
	ZWindowDraw(game->gameWindow, NULL);
	
    game->fSetFocusToHandASAP = true;
	game->showPlayerToPlay = TRUE;
	game->timerType = zGameTimerNone;
	ZTimerSetTimeout(game->timer, 0);
	
	OutlinePlayerCard(game, game->playerToPlay, FALSE);
		
	if (game->autoPlay)
		if (game->playerToPlay == game->seat)
			AutoPlayCard(game);
}


static void HandleEndHandMessage(Game game, ZSpadesMsgEndHand* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16			i;
	ZRect rect;
	
	ZSpadesMsgEndHandEndian(msg);

// Message verification
    for(i = 0; i < 4; i++)
        msg->score.bids[i] = zSpadesBidNone; // unused

    for(i = 0; i < 2; i++)
    {
        msg->score.bonus[i] = 0;  // unused

        if(msg->bags[i] < 0 || msg->bags[i] > 9 || msg->score.base[i] % 10 || msg->score.base[i] < -260 || msg->score.base[i] > 130 ||
            msg->score.bagbonus[i] < 0 || msg->score.bagbonus[i] > 13 ||
            msg->score.nil[i] % 100 || msg->score.nil[i] < -400 || msg->score.nil[i] > 400 ||
            msg->score.bagpenalty[i] % 100 || msg->score.bagpenalty[i] < -200 || msg->score.bagpenalty[i] > 0 ||
            msg->score.base[i] + msg->score.bagbonus[i] + msg->score.nil[i] + msg->score.bagpenalty[i] != msg->score.scores[i])
            break;
    }

    if(i != 2 || game->gameState != zSpadesGameStatePlay || game->boardNumber != msg->score.boardNumber)
    {
        ASSERT(!"HandleEndHandMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification
	
	/* Check if total score table is full. */
	if (game->scoreHistory.numScores == zSpadesMaxNumScores)
	{
		z_memcpy(&game->scoreHistory.scores[0], &game->scoreHistory.scores[1],
				sizeof(game->scoreHistory.scores[0]) * (zSpadesMaxNumScores - 1));
		game->scoreHistory.numScores--;
	}

	game->scoreHistory.scores[game->scoreHistory.numScores].boardNumber = game->boardNumber;
	for (i = 0; i < zSpadesNumPlayers; i++)        
    {
		game->scoreHistory.scores[game->scoreHistory.numScores].bids[i] = game->bids[i];
		game->scoreHistory.scores[game->scoreHistory.numScores].tricksWon[i] = game->tricksWon[i];
    }
	for (i = 0; i < zSpadesNumTeams; i++)
	{
		game->bags[i] = msg->bags[i];
		game->scoreHistory.scores[game->scoreHistory.numScores].scores[i] = msg->score.scores[i];
//		game->scoreHistory.scores[game->scoreHistory.numScores].bonus[i] = msg->score.bonus[i];

        game->scoreHistory.scores[game->scoreHistory.numScores].base[i] = msg->score.base[i];
        game->scoreHistory.scores[game->scoreHistory.numScores].bagbonus[i] = msg->score.bagbonus[i];
        game->scoreHistory.scores[game->scoreHistory.numScores].nil[i] = msg->score.nil[i];
        game->scoreHistory.scores[game->scoreHistory.numScores].bagpenalty[i] = msg->score.bagpenalty[i];

		game->scoreHistory.totalScore[i] += msg->score.scores[i];
	}
	game->scoreHistory.numScores++;
	
	/* Set new game status and display scores. */
	game->gameState = zSpadesGameStateEndHand;
	
	if (game->playerType == zGamePlayer)
	{
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDisable(game->autoPlayButton);
		ZRolloverButtonDisable(game->lastTrickButton);
        ZRolloverButtonDisable(game->scoreButton);

        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        EnableAutoplayAcc(game, false);
        EnableLastTrickAcc(game, false);
        gGAcc->SetItemEnabled(false, IDC_SCORE_BUTTON, false, 0);
    }
	
	game->showPlayerToPlay = FALSE;
	ClearPlayerCardOutline(game, game->playerToPlay);
	
	game->autoPlay = FALSE;
	
	ZTimerSetTimeout(game->timer, zHandScoreTimeout);
	game->timerType = zGameTimerShowHandScore;
	ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zSpadesMsgTalk);

    // set up a different accessibility;
    GACCITEM accClose;

    CopyACC(accClose, ZACCESS_DefaultACCITEM);
    accClose.oAccel.cmd = IDC_CLOSE_BOX;
    accClose.oAccel.key = VK_ESCAPE;
    accClose.oAccel.fVirt = FVIRTKEY;

    accClose.fGraphical = true;
    accClose.pvCookie = (void *) zAccRectButton;

    ZRectToWRect(&accClose.rc, &gHandScoreRects[zRectHandScoreCloseBox]);
    rect = gHandScoreRects[zRectHandScorePane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
    // lift it up 4 pixels for fun
    rect.top -= 4;
    rect.bottom -= 4;
    OffsetRect(&accClose.rc, rect.left, rect.top);

    gGAcc->PushItemlistG(&accClose, 1, 0, true, NULL);

	ZWindowDraw(game->gameWindow, NULL);
	ShowHandScore(game);
    // update the score window
    if ( game->pHistoryDialog )
    {
        game->pHistoryDialog->UpdateHand();
    }
}


static void HandleEndGameMessage(Game game, ZSpadesMsgEndGame* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16			i;
	ZRect rect;
	
	ZSpadesMsgEndGameEndian(msg);

// Message verification
    if((!msg->winners[0]) == (!msg->winners[1]) || game->gameState != zSpadesGameStateEndHand ||
        (game->scoreHistory.totalScore[0] > game->scoreHistory.totalScore[1]) == (!msg->winners[0]))
    {
        ASSERT(!"HandleEndGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->gameState = zSpadesGameStateEndGame;
	
	for (i = 0; i < zSpadesNumPlayers; i++)
		game->winners[i] = msg->winners[i];

	/* Check if wins table is full. */
	if (game->wins.numGames == zSpadesMaxNumScores)
	{
		z_memcpy(&game->wins.gameScores[0], &game->wins.gameScores[1],
				2 * sizeof(int16) * (zSpadesMaxNumScores - 1));
		game->wins.numGames--;
	}
	for (i = 0; i < zSpadesNumTeams; i++)
		game->wins.gameScores[game->wins.numGames][i] = game->scoreHistory.totalScore[i];
	game->wins.numGames++;
	game->numGamesPlayed++;
	
	/* Checker winners. */
	if (game->winners[0] != 0 && game->winners[1] == 0)
		game->wins.wins[0]++;
	else if (game->winners[0] == 0 && game->winners[1] != 0)
		game->wins.wins[1]++;

	ClosingState(&game->closeState,zCloseEventGameEnd,-1);
	
    // set up a different accessibility;
    GACCITEM accClose;

    CopyACC(accClose, ZACCESS_DefaultACCITEM);
    accClose.oAccel.cmd = IDC_CLOSE_BOX;
    accClose.oAccel.key = VK_ESCAPE;
    accClose.oAccel.fVirt = FVIRTKEY;

    accClose.fGraphical = true;
    ZRectToWRect(&accClose.rc, &gGameOverRects[zRectGameOverCloseBox]);
    rect = gGameOverRects[zRectGameOverPane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
    OffsetRect(&accClose.rc, rect.left, rect.top);

    gGAcc->PushItemlistG(&accClose, 1, 0, true, NULL);

	ZTimerSetTimeout(game->timer, zGameScoreTimeout);
	game->timerType = zGameTimerShowGameScore;
	ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zSpadesMsgTalk);
	
	ZWindowDraw(game->gameWindow, NULL);
	ShowGameOver(game);
}


static void HandleBidMessage(Game game, ZSpadesMsgBid* msg)
{
	int16			i;
	ZSpadesMsgBid	bid;
	
	
	ZSpadesMsgBidEndian(msg);

// Message verification
    if(game->gameState != zSpadesGameStateBid || msg->seat < 0 || msg->seat > 3 ||
        msg->nextBidder < 0 || msg->nextBidder > 3 || ((msg->bid < 0 || msg->bid > 13) && msg->bid != zSpadesBidDoubleNil) ||
        game->playerToPlay != msg->seat || msg->nextBidder != (msg->seat + 1) % 4)
    {
        ASSERT(!"HandleBidMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

	game->bids[msg->seat] = msg->bid;
	UpdateBid(game, msg->seat);
	game->playerToPlay = msg->nextBidder;
    UpdateBid( game, game->playerToPlay );

	if(game->playerType == zGamePlayer && game->playerToPlay == game->seat)
    {
        if(game->toBid != zSpadesBidNone)
        {
	        game->bids[game->seat] = (char) game->toBid;
		    bid.seat = game->seat;
		    bid.bid = (char) game->toBid;
		    ZSpadesMsgBidEndian(&bid);
		    ZCRoomSendMessage(game->tableID, zSpadesMsgBid, (void*) &bid, sizeof(bid));
		}

        ZShellGameShell()->MyTurn();
    }
		
	/* Check if everyone has bid. */
	for (i = 0; i < zSpadesNumPlayers; i++)
		if (game->bids[i] == zSpadesBidNone)
			break;
	if (i == zSpadesNumPlayers)
	{
		game->showPlayerToPlay = FALSE;
		game->timerType = zGameTimerShowBid;
		ZTimerSetTimeout(game->timer, zShowBidTimeout);
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zSpadesMsgTalk);
	}
}


static void HandlePlayMessage(Game game, ZSpadesMsgPlay* msg)
{
    int16 i, j;

	ZSpadesMsgPlayEndian(msg);

	// Ignore the user's play message.
	if(msg->seat == game->seat && game->playerType == zGamePlayer)
        return;

// Message verification
    for(i = 0; i < 13; i++)
        if(game->cardsInHand[i] == msg->card)
            break;

    for(j = game->leadPlayer; j != game->playerToPlay; j = (j + 1) % 4)
        if(game->cardsPlayed[j] == msg->card)
            break;

    if(i < 13 || j != game->playerToPlay || msg->seat < 0 || msg->seat > 3 || msg->seat != game->playerToPlay ||
        msg->card < 0 || msg->card > 51 || game->gameState != zSpadesGameStatePlay)
    {
        ASSERT(!"HandlePlayMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

    PlayerPlayedCard(game, msg->seat, msg->card);
}


static void HandleNewGameMessage(Game game, ZSpadesMsgNewGame* msg)
{
	ZSpadesMsgNewGameEndian(msg);

// Message verification
    if(msg->seat < 0 || msg->seat > 3 || game->gameState != zSpadesGameStateEndGame)
    {
        ASSERT(!"HandleNewGameMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

    // inform the shell and the upsell dialog.
    ZShellGameShell()->GameOverPlayerReady( Z(game), game->players[msg->seat].userID );
}


static void HandleTalkMessage(Game game, ZSpadesMsgTalk* msg, DWORD cbMsg)
{
	ZSpadesMsgTalkEndian(msg);

#ifndef SPADES_SIMPLE_UE
	ZPlayerInfoType		playerInfo;
	char*				sender = NULL;
    int16               i;

	if (msg->playerID != 0)
	{
		ZCRoomGetPlayerInfo(msg->playerID, &playerInfo);
		sender = playerInfo.userName;
	}

    for (i=0;i<zSpadesNumPlayers;i++)
    {
        if (msg->playerID==game->players[i].userID)
        {
            if (!game->ignoreSeat[i])
            {
                ZWindowTalk(game->gameWindow, (uchar*) sender,
			        (uchar*) msg + sizeof(ZSpadesMsgTalk));
            }
            return;
        }
    }
    
    if (i>=zSpadesNumPlayers)
    {
        //kibitzer
	    ZWindowTalk(game->gameWindow, (uchar*) sender,
			    (uchar*) msg + sizeof(ZSpadesMsgTalk));
    }
#else // SPADES_SIMPLE_UE
    int32 i;
    TCHAR *szText = (TCHAR *) ((BYTE *) msg + sizeof(ZSpadesMsgTalk));

// Message verification
    if(msg->messageLen < 1 || cbMsg < sizeof(ZSpadesMsgTalk) + msg->messageLen)
    {
        ASSERT(!"HandleTalkMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }

    for(i = 0; i < msg->messageLen; i++)
        if(!szText[i])
            break;
    if(i == msg->messageLen)
    {
        ASSERT(!"HandleTalkMessage sync");
        ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false);
        return;
    }
// end verification

    ZShellGameShell()->ReceiveChat(Z(game), msg->playerID, szText, msg->messageLen / sizeof(TCHAR));
#endif // SPADES_SIMPLE_UE
}


static void HandleGameStateResponseMessage(Game game, ZSpadesMsgGameStateResponse* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16					i;
	ZPlayerInfoType			playerInfo;

    //game->wndInfo.Hide();
	
	ZSpadesMsgGameStateResponseEndian(msg, zEndianFromStandard);
	
	/* Set game to the given state. */
	game->fShownCards = msg->fShownCards[game->seat];
	game->gameOptions = msg->gameOptions;
	game->numPointsInGame = msg->numPointsInGame;
	game->minPointsInGame = msg->minPointsInGame;
	game->playerToPlay = msg->playerToPlay;
	game->numCardsInHand = msg->numCardsInHand;
	game->leadPlayer = msg->leadPlayer;
	game->trumpsBroken = msg->trumpsBroken;
	game->numHandsPlayed = msg->numHandsPlayed;
	game->numGamesPlayed = msg->numGamesPlayed;
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		ZCRoomGetPlayerInfo(msg->players[i], &playerInfo);

		game->players[i].userID = playerInfo.playerID;
		lstrcpy( game->players[i].name, playerInfo.userName);
		lstrcpy( game->players[i].host, playerInfo.hostName);

		game->cardsPlayed[i] = zCardNone;
		game->tricksWon[i] = msg->tricksWon[i];
		game->tableOptions[i] = msg->tableOptions[i];
		game->playersToJoin[i] = msg->playersToJoin[i];
		game->bids[i] = msg->bids[i];
	}
	
	z_memcpy(game->cardsInHand, msg->cardsInHand, zSpadesNumCardsInHand * sizeof(char));
	// TODO: figure out how this should be done.
    game->scoreHistory.numScores = 0;
    //z_memcpy(&game->scoreHistory, &msg->totalScore, sizeof(ZTotalScore));
	z_memcpy(&game->wins, &msg->wins, sizeof(ZWins));
	
	for (i = 0; i < zSpadesNumTeams; i++)
	{
		lstrcpyW2T(game->teamNames[i], msg->teamNames[i]);
		game->bags[i] = msg->bags[i];
	}

	i = game->leadPlayer;
	while (i != game->playerToPlay)
	{
		game->cardsPlayed[i] = msg->cardsPlayed[i];
		i = (i + 1) % zSpadesNumPlayers;
	}

	game->kibitzersSilencedWarned = FALSE;
	game->kibitzersSilenced = FALSE;
	for (i = 0; i < zSpadesNumPlayers; i++)
		if (game->tableOptions[i] & zRoomTableOptionSilentKibitzing)
			game->kibitzersSilenced = TRUE;
	game->hideCardsFromKibitzer =
			(game->tableOptions[game->seat] &zSpadesOptionsHideCards) == 0 ? FALSE : TRUE;
	
	SortHand(game);
	
	if ( ( game->playerType == zGamePlayerKibitzer || !( ZCRoomGetRoomOptions() & zGameOptionsRatingsAvailable ) ) ||
			game->fShownCards )
	{
		game->showCards = TRUE;
	}
	if (msg->rated)
        ClosingState(&game->closeState,zCloseEventRatingStart,game->seat);    
    
	/* Set game state */
	switch (msg->state)
	{
		case zSpadesServerStateNone:
			game->gameState = zSpadesGameStateInit;
            //game->wndInfo.SetText( gStrings[zStringClientReady] ); 
			break;
		case zSpadesServerStateBidding:
            ClosingState(&game->closeState,zCloseEventGameStart,-1);
            ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,-1);

			game->gameState = zSpadesGameStateBid;
			game->showPlayerToPlay = TRUE;
			ZTimerSetTimeout(game->timer, 0);
			game->timerType = zGameTimerNone;
			break;
		case zSpadesServerStatePassing:
            ClosingState(&game->closeState,zCloseEventGameStart,-1);
            ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,-1);
			game->gameState = zSpadesGameStatePass;
			
			game->needToPass = msg->toPass[game->seat];
			
			if (msg->toPass[ZGetPartner(game->seat)] < 0)
			{
				/* Save passed cards for later. */
				for (i = 0; i < zSpadesNumCardsInPass; i++)
					game->cardsReceived[i] = msg->cardsPassed[i];
			}
			break;
		case zSpadesServerStatePlaying:
            ClosingState(&game->closeState,zCloseEventGameStart,-1);
            ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,-1);
			game->gameState = zSpadesGameStatePlay;
			game->showPlayerToPlay = TRUE;
			ZTimerSetTimeout(game->timer, 0);
			game->timerType = zGameTimerNone;
			break;
		case zSpadesServerStateEndHand:
            ClosingState(&game->closeState,zCloseEventGameStart,-1);
            ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,-1);
			game->gameState = zSpadesGameStateEndHand;
			break;
		case zSpadesServerStateEndGame:
            ClosingState(&game->closeState,zCloseEventGameStart,-1);
            ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,-1);
            ClosingState(&game->closeState,zCloseEventGameEnd,-1);
			game->gameState = zSpadesGameStateEndGame;
			break;
	}
	
	game->ignoreMessages = FALSE;
	ZWindowDraw(game->gameWindow, NULL);
}


static void HandleOptionsMessage(Game game, ZSpadesMsgOptions* msg)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16 i;
	
	
	ZSpadesMsgOptionsEndian(msg);
	
	game->tableOptions[msg->seat] = msg->options;
	
	game->kibitzersSilenced = FALSE;
	for (i = 0; i < zSpadesNumPlayers; i++)
		if (game->tableOptions[i] & zRoomTableOptionSilentKibitzing)
			game->kibitzersSilenced = TRUE;
	if (game->kibitzersSilenced == FALSE)
		game->kibitzersSilencedWarned = FALSE;
	
	if (game->tableOptions[game->seat] & zSpadesOptionsHideCards)
	{
		game->hideCardsFromKibitzer = TRUE;
		if (game->playerType == zGamePlayerKibitzer)
			UpdateHand(game);
	}
	else if (game->hideCardsFromKibitzer)
	{
		game->hideCardsFromKibitzer = FALSE;
		if (game->playerType == zGamePlayerKibitzer)
			UpdateHand(game);
	}
	
#ifndef SPADES_SIMPLE_UE
	UpdateOptions(game);
	
	OptionsWindowUpdate(game, msg->seat);
	
	/* Check whether the user is a joiner and joining has been locked out. */
	if (game->playerType == zGamePlayerJoiner &&
			(msg->options & zRoomTableOptionNoJoining))
		ZDisplayText(gStrings[zStringJoiningLockedOut], &gJoiningLockedOutRect, game->gameWindow);
#endif // SPADES_SIMPLE_UE
}


static void HandleCheckInMessage(Game game, ZSpadesMsgCheckIn* msg)
{
	ZSpadesMsgCheckInEndian(msg);
	
	game->playersToJoin[msg->seat] = msg->playerID;
	UpdateJoinerKibitzers(game);
}


static void HandleTeamNameMessage(Game game, ZSpadesMsgTeamName* msg)
{
    /*
	ZSpadesMsgTeamNameEndian(msg);
	
	lstrcpyW2T(game->teamNames[ZGetTeam(msg->seat)], msg->name);
	
	// Update score window if open. 
	if ( ( game->hWndScoreDialog != NULL ) && ( msg->seat != game->seat ) )
        SendMessage( game->hWndScoreDialog, WM_UPDATETEAMNAME, 0, 0 );
    */
}


static void HandleRemovePlayerRequestMessage(Game game, ZSpadesMsgRemovePlayerRequest* msg)
{
#ifndef SPADES_SIMPLE_UE
	RemovePlayer remove;
	TCHAR str[256];
	int i;
	
	ZSpadesMsgRemovePlayerRequestEndian(msg);
	
    if ( !msg->ratedGame )
	{
			
	    if (game->playerType == zGamePlayer)
	    {
		    remove = (RemovePlayer) ZCalloc(sizeof(RemovePlayerType), 1);
		    if (remove != NULL)
		    {
			    remove->game = game;
			    remove->requestSeat = msg->seat;
			    remove->targetSeat = msg->targetSeat;
	        
                SpadesFormatMessage( str, NUMELEMENTS(str), 
                                     IDS_REMOVEPLAYERREQUEST,
							         game->players[remove->requestSeat].name,
							         game->players[remove->targetSeat].name );
			    
			    ClosingState(&game->closeState,zCloseEventBootStart,remove->targetSeat);			
			    ClosingState(&game->closeState,zCloseEventBootYes,remove->requestSeat);

			    ZPrompt(str, &gRemovePlayerRect, game->gameWindow, TRUE, zPromptYes | zPromptNo,
					    NULL, NULL, NULL, RemovePlayerPromptFunc, (void*) remove);
		    }
	    }
    }
#endif
}

static void HandleRemovePlayerEndGameMessage(Game game, ZSpadesMsgRemovePlayerEndGame* msg)
{
#ifndef SPADES_SIMPLE_UE
	TCHAR str[256];

	ClosingState(&game->closeState,zCloseEventForfeit,msg->seatLosing);

	
	if (game->playerType == zGamePlayer)
    {
	    if (msg->reason==zDossierEndGameTimeout) //timeout
	    {
            SpadesFormatMessage( str, NUMELEMENTS(str), 
                                 IDS_REMOVEPLAYERTIMEOUT,
                                 game->players[msg->seatLosing].name,
                                 game->players[msg->seatLosing].name );

		    ZDisplayText(str, &gRemovePlayerRect, game->gameWindow);
	    }
	    else if (msg->reason==zDossierEndGameForfeit)
	    {
            SpadesFormatMessage( str, NUMELEMENTS(str),
                                 IDS_REMOVEPLAYERFORFEIT,
                                 game->players[msg->seatLosing].name,
                                 game->players[msg->seatLosing].name);
		    
		    ZDisplayText(str, &gRemovePlayerRect, game->gameWindow);
	    }
    }

	if (msg->seatLosing % 2) //even loses result is false
	{
		game->scoreHistory.totalScore[0] =500;
		game->scoreHistory.totalScore[1] = 0;
	}
	else
	{
		game->scoreHistory.totalScore[0] =0;
		game->scoreHistory.totalScore[1] = 500;
	}
#endif
}


static void HandleRemovePlayerResponseMessage(Game game, ZSpadesMsgRemovePlayerResponse* msg)
{
#ifndef SPADES_SIMPLE_UE
	TCHAR str[256];
	
	
	ZSpadesMsgRemovePlayerResponseEndian(msg);
	
	if (msg->response == -1)
	{
		ClosingState(&game->closeState,zCloseEventBootNo,msg->seat);

		game->removePlayerPending = FALSE;
	}
	else
	{
		if (msg->response == 0)
		{
			ClosingState(&game->closeState,zCloseEventBootNo,msg->seat);

            SpadesFormatMessage( str, NUMELEMENTS(str), 
                                 IDS_REMOVEPLAYERREJECT,
                                 game->players[msg->seat].name,
                                 game->players[msg->requestSeat].name, 
                                 game->players[msg->targetSeat].name);
		}
		else if (msg->response == 1)
		{
			ClosingState(&game->closeState,zCloseEventBootYes,msg->seat);

            SpadesFormatMessage( str, NUMELEMENTS(str),
                                 IDS_REMOVEPLAYERACCEPT,
                                 game->players[msg->seat].name,
					             game->players[msg->requestSeat].name, 
                                 game->players[msg->targetSeat].name );
		}

		ZDisplayText(str, &gRemovePlayerRect, game->gameWindow);
	}
#endif
}


void GameSendTalkMessage(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
    // handled by the shell
#ifndef SPADES_SIMPLE_UE

	ZSpadesMsgTalk*			msgTalk;
	Game					game;
	int16					msgLen;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{
		/*
			Check if kibitzer has been silenced.
		*/
		if (game->playerType == zGamePlayerKibitzer && game->kibitzersSilenced)
		{
			if (game->kibitzersSilencedWarned == FALSE)
			{
				ZAlert(gStrings[zStringKibitzersSilenced], game->gameWindow);
				game->kibitzersSilencedWarned = TRUE;
			}
			return;
		}
		
		msgLen = sizeof(ZSpadesMsgTalk) + pMessage->messageLen;
		msgTalk = (ZSpadesMsgTalk*) ZCalloc(1, msgLen);
		if (msgTalk != NULL)
		{
			msgTalk->playerID = game->userID;
			msgTalk->messageLen = (int16) pMessage->messageLen;
			z_memcpy((char*) msgTalk + sizeof(ZSpadesMsgTalk), (char*) pMessage->messagePtr,
					pMessage->messageLen);
			ZSpadesMsgTalkEndian(msgTalk);
			ZCRoomSendMessage(game->tableID, zSpadesMsgTalk, (void*) msgTalk, msgLen);
			ZFree((char*) msgTalk);
		}
		else
		{
			ZAlert(GetErrStr(zErrOutOfMemory), game->gameWindow);
		}
	}
#endif // SPADES_SIMPLE_UE
}


// based on above for Millennium
STDMETHODIMP CGameGameSpades::SendChat(TCHAR *szText, DWORD cchChars)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZSpadesMsgTalk*			msgTalk;
	Game					game = (Game) GetGame();
	int16					msgLen;

	msgLen = sizeof(ZSpadesMsgTalk) + cchChars * sizeof(TCHAR);
    msgTalk = (ZSpadesMsgTalk*) ZCalloc(1, msgLen);
    if (msgTalk != NULL)
    {
        msgTalk->playerID = game->userID;
        msgTalk->messageLen = (WORD) cchChars * sizeof(TCHAR);
        CopyMemory((BYTE *) msgTalk + sizeof(ZSpadesMsgTalk), (void *) szText,
            msgTalk->messageLen);
        ZSpadesMsgTalkEndian(msgTalk);
        ZCRoomSendMessage(game->tableID, zSpadesMsgTalk, (void*) msgTalk, msgLen);
        ZFree((char*) msgTalk);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
	}
}

STDMETHODIMP CGameGameSpades::GameOverReady()
{
    // user selected "Play Again"
	Game game = I( GetGame() );
	ZSpadesMsgNewGame msg;
	msg.seat = game->seat;
	ZSpadesMsgNewGameEndian(&msg);
	ZCRoomSendMessage(game->tableID, zSpadesMsgNewGame, &msg, sizeof(ZSpadesMsgNewGame));
    return S_OK;
}


STDMETHODIMP_(HWND) CGameGameSpades::GetWindowHandle()
{
	Game game = I( GetGame() );
	return ZWindowGetHWND(game->gameWindow);
}


STDMETHODIMP CGameGameSpades::ShowScore()
{
    ScoreButtonWork(I(GetGame()));

    return S_OK;
}


static void NewGame(Game game)
{
	int16			i, j;
	
	
	/* Clear score history */
	game->scoreHistory.numScores = 0;
	for (j = 0; j < zSpadesNumTeams; j++)
	{
		game->scoreHistory.totalScore[j] = 0;
		game->bags[j] = 0;
	}
    if ( game->pHistoryDialog )
    {
        game->pHistoryDialog->UpdateHand();        
    }
	
	game->numHandsPlayed = 0;
	game->showGameOver = FALSE;
    //clear the state
    ClosingState(&game->closeState,zCloseEventCloseAbort,game->seat);
    //set new state
	ClosingState(&game->closeState,zCloseEventGameStart,-1);
}


static void NewHand(Game game)
{
	int16			i;
	
	
	/* Initialize new hand. */
	for (i = 0; i < zSpadesNumCardsInHand; i++)
	{
		game->cardsInHand[i] = zCardNone;
		game->cardsSelected[i] = FALSE;
	}
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		game->cardsPlayed[i] = zCardNone;
		game->cardsLastTrick[i] = zCardNone;
		game->tricksWon[i] = 0;
		game->bids[i] = zSpadesBidNone;
	}
	game->toBid = zSpadesBidNone;
	
	for (i = 0; i < zSpadesNumCardsInPass; i++)
		game->cardsReceived[i] = zCardNone;
		
	game->numCardsInHand = zSpadesNumCardsInHand;
	
	game->trumpsBroken = FALSE;
	game->lastClickedCard = zCardNone;
	game->lastTrickShowing = FALSE;
	game->needToPass = 0;
	game->showHandScore = FALSE;
	game->showPassText = FALSE;
}


void SelectAllCards(Game game)
{
	int16			i;
	
	
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		game->cardsSelected[i] = TRUE;
}


void UnselectAllCards(Game game)
{
	int16			i;
	
	
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		game->cardsSelected[i] = 0;
}


int16 GetNumCardsSelected(Game game)
{
	int16			i, count;
	
	
	for (i = 0, count = 0; i < zSpadesNumCardsInHand; i++)
		if (game->cardsInHand[i] != zCardNone)
			if (game->cardsSelected[i])
				count++;
	
	return (count);
}


static void HandAddCard(Game game, char card)
{
	int16		i;
	
	
	/* Find an empty slot in the hand and add the card. */
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (game->cardsInHand[i] == zCardNone)
		{
			game->cardsInHand[i] = card;
			game->numCardsInHand++;
			break;
		}
}


static void HandRemoveCard(Game game, char card)
{
	int16		i;
	
	
	/* Find an empty slot in the hand and add the card. */
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (game->cardsInHand[i] == card)
		{
			game->cardsInHand[i] = zCardNone;
			game->numCardsInHand--;
			break;
		}
}


static void SortHand(Game game)
{
	int16			i;
	char			temp;
	ZBool			swapped;
	
	
	/* Simple bubble-sort. */
	swapped = TRUE;
	while (swapped == TRUE)
	{
		swapped = FALSE;
		for (i = 0; i < zSpadesNumCardsInHand - 1; i++)
			if (game->cardsInHand[i] > game->cardsInHand[i + 1])
			{
				/* Swap cards. */
				temp = game->cardsInHand[i + 1];
				game->cardsInHand[i + 1] = game->cardsInHand[i];
				game->cardsInHand[i] = temp;
				
				swapped = TRUE;
			}
	}
}


static int16 GetCardIndexFromRank(Game game, char card)
{
	int16		i;
	
	
	/* Search for the given card in the hand. */
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (game->cardsInHand[i] == card)
			return (i);
	
	return (zCardNone);
}


void PlayACard(Game game, int16 cardIndex)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZSpadesMsgPlay			playMsg;
	char					card;
	ZError					err;

	//dossier work - if ratings are on and we are waiting for the users to vote
	//don't allow them to play anymore.
	if(game->fVotingLock) 
		return;
	
	card = game->cardsInHand[cardIndex];
	if ((err = ValidCardToPlay(game, card)) == zErrNone)
	{
		game->cardsInHand[cardIndex] = zCardNone;
		game->numCardsInHand--;
		
		playMsg.seat = game->seat;
		playMsg.card = card;
		ZSpadesMsgPlayEndian(&playMsg);
		ZCRoomSendMessage(game->tableID, zSpadesMsgPlay, (void*) &playMsg,
				sizeof(playMsg));

        ZRolloverButtonDisable( game->playButton );
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
		
		UpdateHand(game);

		PlayerPlayedCard(game, game->seat, card);
		
		game->lastClickedCard = zCardNone;
	}
	else
	{
        UpdateHand(game);  // for unselected cards etc. (bug 17267)
		ZAlert(gStrings[gValidCardErrIndex[err]], game->gameWindow);
	}
}


void AutoPlayCard(Game game)
{
	int16					cardIndex;

	
	cardIndex = GetAutoPlayCard(game);
	PlayACard(game, cardIndex);
}


static void PlayerPlayedCard(Game game, int16 seat, char card)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16			i;
	
	
	if (game->playerType != zGamePlayer)
		UnselectAllCards(game);
	
	game->cardsPlayed[seat] = card;
	UpdatePlayedCard(game, seat);

	ClosingState(&game->closeState,zCloseEventMoveTimeoutPlayed,seat);
	
	/* Update kibitzer's hand. */
	if (seat == game->seat && game->playerType != zGamePlayer)
	{
		HandRemoveCard(game, card);
		UpdateHand(game);
	}
	
	if (ZSuit(card) == zSuitSpades)
		game->trumpsBroken = TRUE;
	
	ClearPlayerCardOutline(game, game->playerToPlay);
	
	game->playerToPlay = (game->playerToPlay + 1) % zSpadesNumPlayers;
	
	if (game->playerToPlay == game->leadPlayer)
	{
		game->leadPlayer = TrickWinner(game);
		game->playerToPlay = game->leadPlayer;
		
		game->tricksWon[game->leadPlayer]++;

		if (game->playerType == zGamePlayer)
		{
			game->playButtonWasEnabled = ZRolloverButtonIsEnabled(game->playButton);
			game->lastTrickButtonWasEnabled = ZRolloverButtonIsEnabled(game->lastTrickButton);
			ZRolloverButtonDisable(game->playButton);
			ZRolloverButtonDisable(game->lastTrickButton);

            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
            EnableLastTrickAcc(game, false);
		
			/* Enable the last trick button after the first trick; only if not kibitzing. */
			if (game->lastTrickButtonWasEnabled == FALSE && game->playerType == zGamePlayer)
				game->lastTrickButtonWasEnabled = TRUE;
		}
		
		/* Save the last trick. */
		for (i = 0; i < zSpadesNumPlayers; i++)
			game->cardsLastTrick[i] = game->cardsPlayed[i];
		
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zSpadesMsgTalk);
		InitTrickWinner(game, game->leadPlayer);
		
		/* Show the winner of the trick. */
		OutlinePlayerCard(game, game->leadPlayer, TRUE);
		
		game->timerType = zGameTimerShowTrickWinner;
		ZTimerSetTimeout(game->timer, zShowTrickWinnerTimeout);
	}
	else
	{
		OutlinePlayerCard(game, game->playerToPlay, FALSE);
			
		if (game->numCardsInHand > 0 && game->playerToPlay == game->seat)
		{
			if (game->autoPlay)
			{
				AutoPlayCard(game);
			}
			else
			{
				if (game->playerType == zGamePlayer)
				{
					ZRolloverButtonEnable(game->playButton);
                    gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
					if (game->beepOnTurn)
                    {
						ZBeep();
                        ZShellGameShell()->MyTurn();
                    }
				}
			}
		}
		else
		{
			if (game->playerType == zGamePlayer)
            {
				ZRolloverButtonDisable(game->playButton);
                gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
            }
		}
	}
}


static int16 TrickWinner(Game game)
{
	int16			i, winner;
	int16			suit, rank;
	char			card;
	bool			fWinnerFound = false;
	

	rank = GetCardHighestPlayedTrump(game);
	suit = zSuitSpades;
	if (rank == zCardNone)
	{
		rank = GetCardHighestPlayed(game);
		suit = ZSuit(game->cardsPlayed[game->leadPlayer]);
	}
	card = ZCardMake(suit, rank);
	
	/* Look for the player who played the winning card. */
	for (i = 0; i < zSpadesNumPlayers; i++)
		if (game->cardsPlayed[i] == card)
		{
			fWinnerFound = true;
			winner = i;
			break;
		}
	//Prefix Warning: winner could potentially be unitialized.
	if( fWinnerFound == FALSE )
	{
		//Didn't find the winner, I bet someone is cheating.
		ZShellGameShell()->ZoneAlert(ErrorTextSync, NULL, NULL, true, false );
		winner = 0;
	}
	return (winner);
}


/*******************************************************************************
	GAME LOGIC ROUTINES
*******************************************************************************/
static ZError ValidCardToPlay(Game game, char card)
{
	ZError			valid;
	int16			counts[zDeckNumSuits];
	
	
	valid = zErrNone;
	
	CountCardSuits(game->cardsInHand, zSpadesNumCardsInHand, counts);
	
	/* If leading. */
	if (game->leadPlayer == game->seat)
	{
		/* Can lead anything if trumps are broken. */
		if (game->trumpsBroken == FALSE)
		{
			/* Can't lead spades if trumps not broken. */
			if (ZSuit(card) == zSuitSpades)
			{
				/* But can lead spades if there are no other cards to play. */
				if (counts[zSuitSpades] != game->numCardsInHand)
				{
					valid = zCantLeadSpades;
					goto Exit;
				}
			}
		}
	}
	else
	{
		/* Must follow suit if any. */
		if (counts[ZSuit(game->cardsPlayed[game->leadPlayer])] != 0 &&
				ZSuit(card) != ZSuit(game->cardsPlayed[game->leadPlayer]))
		{
			valid = zMustFollowSuit;
			goto Exit;
		}
	}

Exit:
	
	return (valid);
}


static int16 GetAutoPlayCard(Game game)
{
	int16			counts[zDeckNumSuits];
	int16			card, suitLed, suit;
	int16			i, high, low;
	char*			hand;
	int16			bid;
	
	
	card = zCardNone;
	hand = game->cardsInHand;
	
	CountCardSuits(hand, zSpadesNumCardsInHand, counts);
	
	bid = game->bids[game->seat];
	if (bid == zSpadesBidDoubleNil)
		bid = 0;
	
	/* If following, must follow suit if possible; else pick any if leading. */
	if (game->leadPlayer != game->seat)
	{
		suitLed = ZSuit(game->cardsPlayed[game->leadPlayer]);
		
		/* Must follow suit if any. */
		if (counts[suitLed] != 0)
		{
			if (bid == 0)
			{
				/* If trumped played already, play highest. */
				if (GetCardHighestPlayedTrump(game) != zCardNone)
				{
					card = GetCardHighest(hand, zSpadesNumCardsInHand, suitLed);
				}
				else
				{
					card = GetCardHighestUnder(hand, zSpadesNumCardsInHand, suitLed,
							GetCardHighestPlayed(game));
					if (card == zCardNone)
						card = GetCardHighest(hand, zSpadesNumCardsInHand, suitLed);
				}
			}
			else
			{
				/* If trumped played already, play lowest. */
				if (GetCardHighestPlayedTrump(game) != zCardNone)
				{
					card = GetCardLowest(hand, zSpadesNumCardsInHand, suitLed);
				}
				else
				{
					card = GetCardHighest(hand, zSpadesNumCardsInHand, suitLed);
					if (ZRank(hand[card]) < GetCardHighestPlayed(game))
						card = GetCardLowest(hand, zSpadesNumCardsInHand, suitLed);
				}
			}
			goto Exit;
		}
		
		/* Can't follow. */
		if (bid == 0)
		{
			/*
				If someone played a trump already and trump available in hand,
				play the highest under trump.
			*/
			if ((high = GetCardHighestPlayedTrump(game)) != zCardNone &&
					counts[zSuitSpades] > 0)
			{
				card = GetCardHighestUnder(hand, zSpadesNumCardsInHand, zSuitSpades, high);
				if (card != zCardNone)
					goto Exit;
			}

			/* If only trumps left, play the highest trump. */
			if (counts[zSuitSpades] == game->numCardsInHand)
			{
				card = GetCardHighest(hand, zSpadesNumCardsInHand, zSuitSpades);
			}
			else
			{
				/* Pick highest non-trump card. */
				high = -1;
				card = zCardNone;
				for (i = 0; i < zSpadesNumCardsInHand; i++)
					if (hand[i] != zCardNone && ZRank(hand[i]) > high &&
							ZSuit(hand[i]) != zSuitSpades)
					{
						card = i;
						high = ZRank(hand[i]);
					}
			}
			goto Exit;
		}
		else
		{
			/* Play a trump. */
			if (counts[zSuitSpades] > 0)
			{
				/*
					Play highest trump. If not high enough, don't play trump.
				*/
				card = GetCardHighest(hand, zSpadesNumCardsInHand, zSuitSpades);
				if ((high = GetCardHighestPlayedTrump(game)) != zCardNone)
					if (ZRank(hand[card]) < high)
						goto PickLowestNonTrump;
				goto Exit;
			}
			goto PickLowestAny;
		}
	}
	else
	{
		if (bid == 0)
			goto PickLowestNonTrump;
	}

PickHighest:
	/* Pick highest card in hand. */
	suit = -1;
	if (game->trumpsBroken == FALSE && counts[zSuitSpades] < game->numCardsInHand)
		suit = zSuitSpades;
	high = -1;
	card = zCardNone;
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (hand[i] != zCardNone && ZRank(hand[i]) > high && ZSuit(hand[i]) != suit)
		{
			card = i;
			high = ZRank(hand[i]);
		}
	goto Exit;

PickLowestNonTrump:
	/* Pick lowest card in hand. */
	low = zDeckNumCardsInSuit;
	card = zCardNone;
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (hand[i] != zCardNone && ZRank(hand[i]) < low && ZSuit(hand[i]) != zSuitSpades)
		{
			card = i;
			low = ZRank(hand[i]);
		}
	
	/* If none found, must be all trumps and play lowest. */
	if (card != zCardNone)
		goto Exit;

PickLowestAny:
	/* Pick lowest card in hand. */
	low = zDeckNumCardsInSuit;
	card = zCardNone;
	for (i = 0; i < zSpadesNumCardsInHand; i++)
		if (hand[i] != zCardNone && ZRank(hand[i]) < low)
		{
			card = i;
			low = ZRank(hand[i]);
		}
	goto Exit;
	
Exit:
	
	return (card);
}


static void CountCardSuits(char* hand, int16 numCardsInHand, int16* counts)
{
	int16			i;
	
	
	for (i = 0; i < zDeckNumSuits; i++)
		counts[i] = 0;
	for (i = 0; i < numCardsInHand; i++)
		if (hand[i] != zCardNone)
			counts[ZSuit(hand[i])]++;
}


/*
	Returns card rank of the highest played trump.
*/
static int16 GetCardHighestPlayedTrump(Game game)
{
	return (GetCardHighestPlayedSuit(game, zSuitSpades));
}


/*
	Returns card rank of the highest played card of the lead suit.
*/
static int16 GetCardHighestPlayed(Game game)
{
	return (GetCardHighestPlayedSuit(game, ZSuit(game->cardsPlayed[game->leadPlayer])));
}


/*
	Returns card rank of the highest played card of the suit.
*/
static int16 GetCardHighestPlayedSuit(Game game, int16 suit)
{
	int16			i;
	char			card, high;
	
	
	high = -1;
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		card = game->cardsPlayed[i];
		if (ZSuit(card) == suit && card != zCardNone && card > high)
			high = card;
	}
	
	return (high == -1 ? zCardNone : ZRank(high));
}


/*
	Returns card index into the hand.
*/
static int16 GetCardHighestUnder(char* hand, int16 numCardsInHand, int16 suit, int16 rank)
{
	int16			i, high;
	char			card;
	
	
	high = -1;
	card = zCardNone;
	for (i = 0; i < numCardsInHand; i++)
		if (hand[i] != zCardNone && ZSuit(hand[i]) == suit &&
				ZRank(hand[i]) < rank && ZRank(hand[i]) > high)
		{
			card = (char) i;
			high = ZRank(hand[i]);
		}
	
	return (card);
}


/*
	Returns card index into the hand.
*/
static int16 GetCardHighest(char* hand, int16 numCardsInHand, int16 suit)
{
	int16			i, high;
	char			card;
	
	
	/* Pick highest card of the suit. */
	high = -1;
	card = zCardNone;
	for (i = 0; i < numCardsInHand; i++)
		if (hand[i] != zCardNone && ZSuit(hand[i]) == suit && ZRank(hand[i]) > high)
		{
			card = (char) i;
			high = ZRank(hand[i]);
		}
	
	return (card);
}


/*
	Returns card index into the hand.
*/
static int16 GetCardLowestOver(char* hand, int16 numCardsInHand, int16 suit, int16 rank)
{
	int16			i, low;
	char			card;
	
	
	low = zDeckNumCardsInSuit;
	card = zCardNone;
	for (i = 0; i < numCardsInHand; i++)
		if (hand[i] != zCardNone && ZSuit(hand[i]) == suit &&
				ZRank(hand[i]) > rank && ZRank(hand[i]) < low)
		{
			card = (char) i;
			low = ZRank(hand[i]);
		}
	
	return (card);
}


/*
	Returns card index into the hand.
*/
static int16 GetCardLowest(char* hand, int16 numCardsInHand, int16 suit)
{
	int16			i, low;
	char			card;
	
	
	/* Pick lowest card in hand. */
	low = zDeckNumCardsInSuit;
	card = zCardNone;
	for (i = 0; i < numCardsInHand; i++)
		if (hand[i] != zCardNone && ZSuit(hand[i]) == suit && ZRank(hand[i]) < low)
		{
			card = (char) i;
			low = ZRank(hand[i]);
		}
	
	return (card);
}


/*******************************************************************************
	MISCELLANEOUS ROUTINES
*******************************************************************************/


void RemovePlayerPromptFunc(int16 result, void* userData)
{
	RemovePlayer pThis = (RemovePlayer) userData;
	ZSpadesMsgRemovePlayerResponse	response;
	
	
	response.seat = pThis->game->seat;
	response.requestSeat = pThis->requestSeat;
	response.targetSeat = pThis->targetSeat;
	if (result == zPromptYes)
	{
		response.response = 1;
	}
	else
	{
		response.response = 0;
	}
	ZSpadesMsgRemovePlayerResponseEndian(&response);
	ZCRoomSendMessage(pThis->game->tableID, zSpadesMsgRemovePlayerResponse,
			&response, sizeof(response));
	ZFree(userData);
}


/*******************************************************************************
	ROOM INTERFACE ROUTINES
*******************************************************************************/
static void LoadRoomImages(void)
{
}


static ZBool GetRoomObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	switch (objectType)
	{
		case zRoomObjectGameMarker:
			if (image != NULL)
			{
				if (modifier == zRoomObjectIdle)
					*image = gGameIdle;
				else if (modifier == zRoomObjectGaming)
					*image = gGaming;
			}
			return (TRUE);
	}
	
	return (FALSE);
}


static void DeleteRoomObjectsFunc(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	if (gGameIdle != NULL)
		ZImageDelete(gGameIdle);
	gGameIdle = NULL;
	if (gGaming != NULL)
		ZImageDelete(gGaming);
	gGaming = NULL;
}

INT_PTR CALLBACK DossierDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	ZSpadesMsgDossierVote	voteMsg;
	HWND hwnd;

	Game game = (Game)GetWindowLong(hDlg,DWL_USER);
	if(game)
		voteMsg.seat = game->seat;
	
	switch(iMsg)
    {
        case WM_INITDIALOG:
            return TRUE;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				
                case IDYES:
					ASSERT(game);
					if(game == NULL)
						break;
					voteMsg.vote = zVotedYes;
               		ZSpadesMsgDossierVoteEndian(&voteMsg);
			     	ZCRoomSendMessage(game->tableID, zSpadesMsgDossierVote, (void*) &voteMsg,sizeof(voteMsg));

					hwnd = GetDlgItem(game->voteDialog,IDYES);
					if( hwnd != NULL )
					{
						EnableWindow(hwnd,FALSE);
					}
					hwnd = GetDlgItem(game->voteDialog,IDNO);
					if( hwnd != NULL )
					{
						EnableWindow(hwnd,TRUE);
					}
                    break;
                case IDNO:
	                ASSERT(game);
					if(game == NULL)
						break;
                	voteMsg.vote = zVotedNo;            
					ZSpadesMsgDossierVoteEndian(&voteMsg);
					ZCRoomSendMessage(game->tableID, zSpadesMsgDossierVote, (void*) &voteMsg,sizeof(voteMsg));

					hwnd = GetDlgItem(game->voteDialog,IDNO);
					EnableWindow(hwnd,FALSE);
					hwnd = GetDlgItem(game->voteDialog,IDYES);
					EnableWindow(hwnd,TRUE);

                    break;	
            }
            break;
     }

    // ZSendMessage(pWindow,pWindow->messageFunc,zMessageWindowUser,NULL,NULL,wParam,NULL,0L,pWindow->userData);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\launch\launchmres.h ===
#ifndef __LAUNCHRESM_H
#define __LAUNCHRESM_H

#define IDS_FAILED 		1
#define IDS_CAPTION 	2
#define IDS_GAME 	    3
#define IDS_SERVER     	4
#define IDS_CMD		 	5




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\games\spades\ui.cpp ===
/*******************************************************************************

	UI.c
	
		Spades client user interface.
		
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on Friday, February 17, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	10		06/25/97	leonp	Removed bug fix 367, fixed code on server side instead
	9		06/24/97	leonp	Bug fix for bug#367 added one to the number of cards when centering a 
								kibitzed hand.  The served send one too many cards.  Change in GetHandRect()
	8		06/19/97	leonp	Added ZButtonDisable(game->optionsButton) so the option button is 
								disabled when the last trick button is selected.
	7		01/27/97	HI		Display game scores starting from 1.
	6		01/15/97	HI		Fixed bug in HandleJoinerKibitzerClick() to
								delete the show player window if one already
								exists before creating another one.
	5		01/08/96	HI		Fixed ShowScores() to show only one scores window.
	4		12/18/96	HI		Cleaned up UICleanUp().
	3		12/12/96	HI		Dynamically allocate volatible globals for reentrancy.
								Removed MSVCRT dependency.
	2		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
								Modified code to use ZONECLI_DLL.
	1		10/31/96	HI		Display board numbers starting from 1 instead of 0.
	0		02/17/96	HI		Created.
	 
*******************************************************************************/


#pragma warning (disable:4761)


#include "zone.h"
#include "zroom.h"
#include "spades.h"
#include "zonecli.h"
#include "client.h"
#include "zonehelpids.h"
#include "zui.h"
#include "ZoneDebug.h"
#include "ZoneResource.h"
#include "SpadesRes.h"
#include "zrollover.h"
#include <windowsx.h>
#include <commctrl.h>
#include "UAPI.h"
#include "ZoneUtil.h"

inline DECLARE_MAYBE_FUNCTION_1(BOOL, SetProcessDefaultLayout, DWORD);


#define zCardWidth					zCardsSizeWidth
#define zCardHeight					zCardsSizeHeight

/* Given char, return card image index. */
#define CardImageIndex(card)		(gCardSuitConversion[ZSuit(card)] * 13 + ZRank(card))

#define zMaxNumBlockedMessages		4

#define zShowPlayerWindowWidth		120
#define zShowPlayerLineHeight		12

//#define zPassTextStr				"Please pass 3 cards to your partner."
#ifndef SPADES_SIMPLE_UE
#define zTeamNameStr				"Your team name:"
#define zKibitzingStr				"Kibitz"
#define zJoiningStr					"Join"
#define zRemoveStr					"Remove"
#define zUnIgnodeStr				"UnIgnore"
#define zIgnoreStr					"Ignore"
#define zSilentStr					"Silent"
#define zHideCardsStr				"Hide cards from kibitzer"
#define zRemovePendingStr			"Your last request to remove a player is still pending."
#endif // SPADES_SIMPLE_UE

static char				gCardSuitConversion[4] =	{
														zCardsSuitDiamonds,
														zCardsSuitClubs,
														zCardsSuitHearts,
														zCardsSuitSpades
													};
static int16			gNameRectIndex[] =	{
												zRectSouthName,
												zRectWestName,
												zRectNorthName,
												zRectEastName
											};
static int16			gNameFontIndex[] =	{
												zFontTeam1,
												zFontTeam2
											};

// defines where to draw the bid plate
static int16            gBidPlateRectIndex[] = {
												zRectSouthBid,
												zRectWestBid,
												zRectNorthBid,
												zRectEastBid
                                            };
// defines which bid plate to draw
static int16            gBidPlateIndex[] = {
                                                zRectObjectTeam1Bid,
                                                zRectObjectTeam2Bid
                                            };
static int16			gScorePlateIndex[] = {
												zRectObjectTeam1ScorePlate,
												zRectObjectTeam2ScorePlate
											};
static int16			gLargeBidRectIndex[] =	{
												zRectSouthLargeBid,
												zRectWestLargeBid,
												zRectNorthLargeBid,
												zRectEastLargeBid
											};
static int16			gCardRectIndex[] =	{
												zRectSouthCard,
												zRectWestCard,
												zRectNorthCard,
												zRectEastCard
											};
static int16			gJoinerKibitzerRectIndex[][2] =	{
															{zRectSouthKibitzer, zRectSouthJoiner},
															{zRectWestJoiner, zRectWestKibitzer},
															{zRectNorthJoiner, zRectNorthKibitzer},
															{zRectEastKibitzer, zRectEastJoiner}
														};
static int16			gOptionsRectIndex[] =	{
													zRectOptionKibitzer,
													zRectOptionJoiner
												};
static int16			gSmallBidRectIndex[] =	{
													zRectSouthBid,
													zRectWestBid,
													zRectNorthBid,
													zRectEastBid
												};
#ifndef SPADES_SIMPLE_UE
static int16			gOptionsNameRects[] =	{
													zRectOptionsPlayer1Name,
													zRectOptionsPlayer2Name,
													zRectOptionsPlayer3Name,
													zRectOptionsPlayer4Name
												};
static int16			gOptionsKibitzingRectIndex[] =	{
															zRectOptionsKibitzing1,
															zRectOptionsKibitzing2,
															zRectOptionsKibitzing3,
															zRectOptionsKibitzing4
														};
static int16			gOptionsJoiningRectIndex[] =	{
															zRectOptionsJoining1,
															zRectOptionsJoining2,
															zRectOptionsJoining3,
															zRectOptionsJoining4
														};
static int16			gOptionsSilentRectIndex[] =	{
														zRectOptionsSilent1,
														zRectOptionsSilent2,
														zRectOptionsSilent3,
														zRectOptionsSilent4
													};
static int16			gOptionsRemoveRectIndex[] =	{
														zRectOptionsRemove1,
														zRectOptionsRemove2,
														zRectOptionsRemove3,
														zRectOptionsRemove4
													};
#endif // SPADES_SIMPLE_UE

/* -------- Internal Routine Prototypes -------- */
static ZError LoadGameImages(void);
ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage);
static void DisplayChange(Game game);
static ZBool PlayButtonFunc(ZRolloverButton button, int16 state, void* userData);
static ZBool AutoPlayButtonFunc(ZRolloverButton button, int16 state, void* userData);
static ZBool LastTrickButtonFunc(ZRolloverButton button, int16 state, void* userData);
static ZBool ScoreButtonFunc(ZRolloverButton button, int16 state, void* userData);
static void GameWindowDraw(ZWindow window, ZMessage* pMessage);
// DrawBackground will only listen to the 'window' parameter if 'game' is NULL
static void DrawBackground(Game game, ZWindow window, ZRect* drawRect);
static void DrawTable(Game game);
void UpdateTable(Game game);
static void DrawPlayedCard(Game game, int16 seat);
void UpdatePlayedCard(Game game, int16 seat);
static void DrawPlayers(Game game);
static void DrawHand(Game game);
void UpdateHand(Game game);
static void DrawTricksWon(Game game);
static void UpdateTricksWon(Game game);
static void DrawJoinerKibitzers(Game game);
void UpdateJoinerKibitzers(Game game);
static void DrawOptions(Game game);
#ifndef SPADES_SIMPLE_UE
void UpdateOptions(Game game);
#endif // SPADES_SIMPLE_UE
static void DrawScore(Game game);
static void UpdateScore(Game game);
static void DrawBids(Game game);
static void DrawLargeBid(Game game, int16 seat, char bid);
void UpdateBid(Game game, int16 seat);
static void DrawBidControls(Game game);
void UpdateBidControls(Game game);
static void DrawHandScore(Game game);
void UpdateHandScore(Game game);
static void DrawGameOver(Game game);
void UpdateGameOver(Game game);
static void DrawPassText(Game game);
static void DrawFocusRect(Game game);
static void UpdatePassText(Game game);
static void ClearTable(Game game);
static void GetHandRect(Game game, ZRect *rect);
static void HandleButtonDown(ZWindow window, ZMessage* pMessage);

static void BidControlFunc(ZWindow window, ZRect* buttonRect,
		int16 buttonType, int16 buttonState, void* userData);
static int16 GetCardIndex(Game game, ZPoint *point);
static void GameTimerFunc(ZTimer timer, void* userData);
static void InitTrickWinnerGlobals(void);
void InitTrickWinner(Game game, int16 trickWinner);
static void UpdateTrickWinner(Game game, ZBool terminate);
static void ShowTrickWinner(Game game, int16 trickWinner);
void OutlinePlayerCard(Game game, int16 seat, ZBool winner);
void ClearPlayerCardOutline(Game game, int16 seat);
static void OutlineCard(ZGrafPort grafPort, ZRect* rect, ZColor* color);

static void HelpButtonFunc( ZHelpButton helpButton, void* userData );
void ShowScorePane(Game game);
void ShowWinnerPane(Game game);

#ifndef SPADES_SIMPLE_UE
static void OptionsButtonFunc(ZPictButton pictButton, void* userData);
static void ShowOptions(Game game);
static void OptionsWindowDelete(Game game);
static ZBool OptionsWindowFunc(ZWindow window, ZMessage* message);
void OptionsWindowUpdate(Game game, int16 seat);
static void OptionsWindowButtonFunc(ZButton button, void* userData);
static void OptionsWindowDraw(Game game);
static void OptionsCheckBoxFunc(ZCheckBox checkBox, ZBool checked, void* userData);
#endif // SPADES_SIMPLE_UE

static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point);
static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point);
static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message);
static void ShowPlayerWindowDraw(Game game);
static void ShowPlayerWindowDelete(Game game);

static void ZRectSubtract(ZRect* src, ZRect* sub);
                 
static ZBool RolloverButtonDrawFunc(ZRolloverButton rolloverButton, ZGrafPort grafPort, int16 state,
                             ZRect* rect, void* userData);

         
// CInfoWnd
/*
HWND CInfoWnd::Create( ZWindow parent )
{
    m_hWnd = ZShellResourceManager()->CreateDialogParam( NULL, MAKEINTRESOURCE( IDD_INFO ), 
                                                         ZWindowWinGetWnd( parent ), 
                                                         DlgProc, NULL );
    m_hWndText = GetDlgItem( m_hWnd, IDC_INFO_TEXT );
    return m_hWnd;
}
BOOL CInfoWnd::Destroy()
{
    return DestroyWindow( m_hWnd );
}
BOOL CInfoWnd::Show()
{
    return ShowWindow( m_hWnd, SW_SHOW );
}
BOOL CInfoWnd::Hide()
{
    return ShowWindow( m_hWnd, SW_HIDE );
}
BOOL CInfoWnd::SetText( LPCTSTR pszText )
{
    return SetWindowText( m_hWndText, pszText );
}
INT_PTR CInfoWnd::DlgProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch ( message )
    {
    case WM_INITDIALOG:
        CenterWindow( hWnd, NULL );
        return TRUE;
    }
    return FALSE;
}
*/

//static
HGDIOBJ CZoneColorFont::m_hOldFont;
//static 
COLORREF CZoneColorFont::m_colorOld;

bool CZoneColorFont::LoadFromDataStore( IDataStore *pIDS, LPCTSTR pszFontName )
{
    using namespace SpadesKeys;
    const TCHAR* arKeys[] = { key_Spades, key_Fonts, pszFontName, NULL };

    arKeys[3] = key_Font;
    if ( FAILED( pIDS->GetFONT( arKeys, 4, &m_zf ) ) )
    {
        return false;
    }

    arKeys[3] = key_Color;
    if ( FAILED( pIDS->GetRGB( arKeys, 4, &m_color ) ) )
    {
        return false;
    }
    // make this a PALETTERGB
    m_color |= 0x02000000;
    m_hFont = ZCreateFontIndirect( &m_zf );
    if ( !m_hFont )
    {
        return false;
    }
    return true;
}

bool CZoneColorFont::Select( HDC hdc )
{
    m_hOldFont = SelectObject( hdc, m_hFont );
    m_colorOld = SetTextColor( hdc, m_color );
    return true;
}
bool CZoneColorFont::Deselect( HDC hdc )
{
    SelectObject( hdc, m_hOldFont );
    m_hOldFont = NULL;
    SetTextColor( hdc, m_colorOld );
    return true;
}


static void ModifyWindowStyle( HWND hWnd, DWORD dwStyleAdd, DWORD dwStyleRemove )
{
    DWORD dwStyle;
    dwStyle = GetWindowStyle( hWnd );
    dwStyle |= dwStyleAdd;
    dwStyle &= ~dwStyleRemove;
    SetWindowLong( hWnd, GWL_STYLE, dwStyle );
}

BOOL CenterWindow( HWND hWndToCenter, HWND hWndCenter )
{
	DWORD dwStyle;
	RECT rcDlg;
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
    int DlgWidth, DlgHeight, xLeft, yTop;

    dwStyle = GetWindowLong( hWndToCenter, GWL_STYLE );
	ASSERT(IsWindow(hWndToCenter));

	// determine owner window to center against
	if(hWndCenter == NULL)
	{
		if(dwStyle & WS_CHILD)
			hWndCenter = GetParent(hWndToCenter);
		else
			hWndCenter = GetWindow(hWndToCenter, GW_OWNER);
	}

	// get coordinates of the window relative to its parent
	GetWindowRect(hWndToCenter, &rcDlg);
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle = GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
				hWndCenter = NULL;
		}

		// center within screen coordinates
		SystemParametersInfo(SPI_GETWORKAREA, 0, &rcArea, 0);
		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = GetParent(hWndToCenter);
		ASSERT(IsWindow(hWndParent));

		GetClientRect(hWndParent, &rcArea);
		ASSERT(IsWindow(hWndCenter));
		GetClientRect(hWndCenter, &rcCenter);
		MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	DlgWidth = rcDlg.right - rcDlg.left;
	DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	return SetWindowPos(hWndToCenter, NULL, xLeft, yTop, -1, -1,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

// gets a long from the global spades key
LONG GetDataStoreUILong( const TCHAR *pszLong )
{
    using namespace SpadesKeys;
    const TCHAR *arKeys[] = { key_Spades, pszLong };
    LONG l = 0;
    ZShellDataStoreUI()->GetLong( arKeys, 2, &l );
    return l;
}

static void LoadRects( const TCHAR** arKeys, long lElts, 
                       const LPCTSTR *arRectNames,
                       ZRect *arRects, int nNumRects )
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

    BOOL fLoadFailed = FALSE;

    RECT rc;
    IDataStore *pIDS = ZShellDataStoreUI();

    for ( int  i=0; i < nNumRects; i++ )
    {   
        arKeys[lElts] = arRectNames[i];
        if ( FAILED( pIDS->GetRECT( arKeys, lElts+1, &rc ) ) )
        {
            fLoadFailed = TRUE;
        }
        else
        {
            ZSetRect( &arRects[i], rc.left, rc.top, rc.right, rc.bottom );
        }
    }
    arKeys[lElts] = NULL;

    if ( fLoadFailed )
    {
        // this really isn't a fatal error, but something should be done about it.
        ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound );
    }
}




/*******************************************************************************
	USER INTERFACE ROUTINES
*******************************************************************************/
ZError UIInit(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
    int i;
    BOOL fErrorOccurred = FALSE;

    // TODO: Nothing is really fatal if we don't initialize, but we better say something to the user
    // if something fails to load.

    // first thing's first--ready in all the resource strings
    for ( i=0; i < zNumStrings; i++ )
    {
        if ( FAILED( ZShellResourceManager()->LoadString( STRING_IDS[i], gStrings[i], NUMELEMENTS( gStrings[i] ) ) ) )
        {
            fErrorOccurred = TRUE;
        }
    }

    IDataStore *pIDS = ZShellDataStoreUI();
    ZeroMemory(gFonts, sizeof(gFonts));
    for ( i=0; i < zNumFonts; i++ )
    {
        if ( !gFonts[i].LoadFromDataStore( pIDS, FONT_NAMES[i] ) )
        {
            fErrorOccurred = TRUE;
        }
    }

    ZBool fRTL = ZIsLayoutRTL();
    using namespace SpadesKeys;
    // these are needed to initialize the trick winner animation
    RECT rc;
    const TCHAR *arKeys[] = { key_Spades, key_Rects, NULL, NULL };

    arKeys[2] = fRTL ? key_GameRTL : key_Game;
    LoadRects( arKeys, 3, GAME_RECT_NAMES, gRects, zNumRects );

    arKeys[2] = key_Objects;
    LoadRects( arKeys, 3, OBJECT_RECT_NAMES, gObjectRects, zNumObjectRects );

    arKeys[2] = fRTL ? key_HandScoreRTL : key_HandScore;
    LoadRects( arKeys, 3, HANDSCORE_RECT_NAMES, gHandScoreRects, zNumHandScoreRects );

    arKeys[2] = fRTL ? key_GameOverRTL : key_GameOver;
    LoadRects( arKeys, 3, GAMEOVER_RECT_NAMES, gGameOverRects, zNumGameOverRects );

    arKeys[2] = fRTL ? key_BiddingRTL : key_Bidding;
    LoadRects( arKeys, 3, BIDDING_RECT_NAMES, gBiddingRects, zNumBiddingRects );

    arKeys[2] = key_BiddingObjects;
    LoadRects( arKeys, 3, BIDDINGOBJECT_RECT_NAMES, gBiddingObjectRects, zNumBiddingObjectRects );
    
	InitTrickWinnerGlobals();
	
    // read in our global longs.
    using namespace SpadesKeys;
    glCardOutlinePenWidth = GetDataStoreUILong( key_CardOutlinePenWidth );
    glCardOutlineInset = GetDataStoreUILong( key_CardOutlineInset );
    glCardOutlineRadius = GetDataStoreUILong( key_CardOutlineRadius );

	ZSetCursor(NULL, zCursorArrow);

    if ( fErrorOccurred )
    {
        ZShellGameShell()->ZoneAlert( ErrorTextResourceNotFound );
        return zErrResourceNotFound;
    }

    // create drag brush
    gFocusPattern = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCE(IDB_FOCUS_PATTERN));
    if(!gFocusPattern)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);
        return zErrResourceNotFound;
    }

    gFocusBrush = CreatePatternBrush(gFocusPattern);
    if(!gFocusBrush)
    {
        DeleteObject(gFocusPattern);
        gFocusPattern = NULL;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return zErrOutOfMemory;
    }

    gFocusPen = CreatePen(PS_SOLID, 1, RGB(255, 255, 0));
    if(!gFocusPen)
    {
        DeleteObject(gFocusPattern);
        gFocusPattern = NULL;
        DeleteObject(gFocusBrush);
        gFocusBrush = NULL;
		ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory);
		return zErrOutOfMemory;
    }

	// Load accelerator table defined in Rsc
	HACCEL ghAccelDone = ZShellResourceManager()->LoadAccelerators(MAKEINTRESOURCE(IDR_SPADES_ACCELERATOR_DONE));
    HACCEL ghAccelDouble = ZShellResourceManager()->LoadAccelerators(MAKEINTRESOURCE(IDR_SPADES_ACCELERATOR_DOUBLE));

	return zErrNone;
}


void UICleanUp(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    if(gFocusPattern)
        DeleteObject(gFocusPattern);
    if(gFocusBrush)
        DeleteObject(gFocusBrush);
    if(gFocusPen)
        DeleteObject(gFocusPen);

    for(i = 0; i < zNumFonts; i++)
    {
        if(gFonts[i].m_hFont)
            DeleteObject(gFonts[i].m_hFont);
        gFonts[i].m_hFont = NULL;
    }

    return;
}


// helper function
BOOL UIButtonInit( ZRolloverButton *pButton, Game game, ZRect *bounds, 
                   LPCTSTR pszText, ZRolloverButtonFunc func )
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    ZError err;
    ZRolloverButton rollover;
    rollover = ZRolloverButtonNew();

    if ( !rollover )
    {
        return FALSE;
    }
    err = ZRolloverButtonInit2( rollover, game->gameWindow, bounds, FALSE, FALSE,
                                NULL, NULL, NULL, NULL, gButtonMask,
                                pszText, RolloverButtonDrawFunc, func, (void *)game );

    if ( err != zErrNone )
    {
        ZRolloverButtonDelete( rollover );
        *pButton = NULL;
        return FALSE;
    }

    ZRolloverButtonSetMultiStateFont( rollover, gpButtonFonts[zMultiStateFontPlayingField] );

    *pButton = rollover;
    return TRUE;
}


ZError UIGameInit(Game game, int16 tableID, int16 seat, int16 playerType)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	TCHAR                       title[100];
	ZError						err = zErrNone;
	ZPlayerInfoType				playerInfo;

#ifdef SPADES_SIMPLE_UE
    BOOL fTalkSection = FALSE;
#else
    BOOL fTalkSection = TRUE;
#endif // SPADES_SIMPLE_UE
	
    int i;
    for ( i=0; i < zNumMultiStateFonts; i++ )
    {
        // TODO: This is one thing we shouldnt' be failing on.
        if ( FAILED( LoadZoneMultiStateFont( ZShellDataStoreUI(), MULTISTATE_FONT_NAMES[i], &gpButtonFonts[i] ) ) )
        {
            err = zErrOutOfMemory;
            goto Exit;
        }
    }

	err = LoadGameImages();
	if (err != zErrNone)
		goto Exit;
	
	/* Make image masks extracted from an offscreen port. */
    gBidMadeMask = ZImageNew();
	ZImageMake(gBidMadeMask, NULL, NULL, gObjectBuffer, &gObjectRects[zRectObjectBidMask]); 

	gLargeBidMask = ZImageNew();
	ZImageMake(gLargeBidMask, NULL, NULL, gObjectBuffer, &gObjectRects[zRectObjectBidLargeMask]); 

    gBagMask = ZImageNew();
	ZImageMake(gBagMask, NULL, NULL, gObjectBuffer, &gObjectRects[zRectObjectBagMask]); 
	
    gButtonMask = ZImageNew();
	ZImageMake(gButtonMask, NULL, NULL, gObjectBuffer, &gObjectRects[zRectObjectButtonMask]); 

	gHandBuffer = ZOffscreenPortNew();
	ZOffscreenPortInit(gHandBuffer, &gRects[zRectHand]);
	
	err = ZCardsInit(zCardsNormal);
	if (err != zErrNone)
		goto Exit;
	
	if (game != NULL)
	{
		ZCRoomGetPlayerInfo(game->userID, &playerInfo);
		
		if ((game->gameWindow = ZWindowNew()) == NULL)
			goto ErrorExit;
		wsprintf(title, _T("%s:Table %d"), ZoneClientName(), zWindowChild);
		if (ZWindowInit(game->gameWindow, &gRects[zRectWindow], zWindowChild,
				NULL, title, FALSE, fTalkSection, FALSE, GameWindowFunc, zWantAllMessages,
				(void*) game) != zErrNone)
			goto ErrorExit;
		
        // initialize our back buffer:
        if (( game->gameBackBuffer = ZOffscreenPortNew() ) == NULL )
            goto ErrorExit;
        if ( ZOffscreenPortInit( game->gameBackBuffer, &gRects[zRectWindow] ) != zErrNone )
            goto ErrorExit;

        // by default we draw to the window, not the back buffer
        game->gameDrawPort = game->gameWindow;

        if ( !UIButtonInit( &game->playButton, game, &gRects[zRectPlayButton], 
                            gStrings[zStringPlay], PlayButtonFunc ) )
            goto ErrorExit;

        if ( !UIButtonInit( &game->autoPlayButton, game, &gRects[zRectAutoPlayButton], 
                            gStrings[zStringAutoPlay], AutoPlayButtonFunc ) )
            goto ErrorExit;

        if ( !UIButtonInit( &game->lastTrickButton, game, &gRects[zRectLastTrickButton], 
                            gStrings[zStringLastTrick], LastTrickButtonFunc ) )
            goto ErrorExit;

        if ( !UIButtonInit( &game->scoreButton, game, &gRects[zRectScoreButton], 
                            gStrings[zStringScore], ScoreButtonFunc ) )
            goto ErrorExit;

#ifndef SPADES_SIMPLE_UE
        if ((game->optionsButton = ZButtonNew()) == NULL)
			goto ErrorExit;
		if (ZButtonInit(game->optionsButton, game->gameWindow, &gRects[zRectOptionsButton], zOptionsButtonStr,
				playerInfo.groupID == 1, TRUE, OptionsButtonFunc, (void*) game) != zErrNone)
			goto ErrorExit;

        if ((game->helpButton = ZHelpButtonNew()) == NULL)
			goto ErrorExit;
		if (ZHelpButtonInit(game->helpButton, game->gameWindow, &gRects[zRectHelp],
				NULL, HelpButtonFunc, NULL) != zErrNone)
			goto ErrorExit;
#endif // SPADES_SIMPLE_UE
		
        /*
		if ( !game->wndInfo.Create( game->gameWindow ) )
			goto ErrorExit;
        */
		
		/* Create the timer. */
		if ((game->timer = ZTimerNew()) == NULL)
			goto ErrorExit;
		if (ZTimerInit(game->timer, 0, GameTimerFunc, (void*) game) != zErrNone)
			goto ErrorExit;
		game->timerType = zGameTimerNone;

        game->pBiddingDialog = CBiddingDialog::Create( game );
        if ( !game->pBiddingDialog )
        {
            goto ErrorExit;
        }
        game->pHistoryDialog = CHistoryDialog::Create( game );
        if ( !game->pHistoryDialog )
        {
            goto ErrorExit;
        }
	}
		
	goto Exit;

ErrorExit:
		err = zErrOutOfMemory;
	
Exit:
	
	return (err);
}


void UIGameDelete(Game game)
{           
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();

	if (game != NULL)
	{
        if ( game->pBiddingDialog )
        {
            //game->pBiddingDialog->Destroy();
            delete game->pBiddingDialog;
            game->pBiddingDialog = NULL;
        }
        if ( game->pHistoryDialog )
        {
			game->pHistoryDialog->Close();
            //game->pBiddingDialog->Destroy();
            delete game->pHistoryDialog;
            game->pHistoryDialog = NULL;
        }

        if (gHandBuffer != NULL)
        {
	        ZOffscreenPortDelete(gHandBuffer);
	        gHandBuffer = NULL;
        }
        if (gBiddingObjectBuffer != NULL)
        {
	        ZOffscreenPortDelete(gBiddingObjectBuffer);
	        gBiddingObjectBuffer = NULL;
        }
        if (gObjectBuffer != NULL)
        {
	        ZOffscreenPortDelete(gObjectBuffer);
	        gObjectBuffer = NULL;
        }
        if (gBackground != NULL)
        {
	        ZOffscreenPortDelete(gBackground);
	        gBackground = NULL;
        }
        if (gBidMadeMask != NULL)
        {
	        ZImageDelete(gBidMadeMask);
	        gBidMadeMask = NULL;
        }
        if (gLargeBidMask != NULL)
        {
	        ZImageDelete(gLargeBidMask);
	        gLargeBidMask = NULL;
        }
        if (gBagMask != NULL)
        {
	        ZImageDelete(gBagMask);
	        gBagMask = NULL;
        }

        if (gButtonMask != NULL)
        {
	        ZImageDelete(gButtonMask);
	        gButtonMask = NULL;
        }

        /* Delete all game images. */
        for ( int i = 0; i < zNumGameImages; i++)
        {
	        if (gGameImages[i] != NULL)
            {
		        ZImageDelete(gGameImages[i]);
		        gGameImages[i] = NULL;
            }
        }


        for ( i = 0; i < zNumMultiStateFonts; i++)
        {
            if ( gpButtonFonts[i] )
            {
                gpButtonFonts[i]->Release();
                gpButtonFonts[i] = NULL;
            }
        }

        /* Delete cards. */
        ZCardsDelete(zCardsNormal);

		ShowPlayerWindowDelete(game);
		
        //game->wndInfo.Destroy();
		ZTimerDelete(game->timer);
		ZRolloverButtonDelete(game->scoreButton);
		ZRolloverButtonDelete(game->playButton);
		ZRolloverButtonDelete(game->autoPlayButton);
		ZRolloverButtonDelete(game->lastTrickButton);
#ifndef SPADES_SIMPLE_UE
		OptionsWindowDelete(game);
		ZButtonDelete(game->optionsButton);
		ZHelpButtonDelete(game->helpButton);
#endif // SPADES_SIMPLE_UE
		ZOffscreenPortDelete(game->gameBackBuffer);
		ZWindowDelete(game->gameWindow);
        game->gameDrawPort = NULL;
	}
}


static ZError LoadGameImages(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
    LPCTSTR pszErrorText = NULL;

	uint16				i;
    ZError err = zErrNone;
    COLORREF clrTrans = PALETTERGB( 255, 0, 255 );
		
    using namespace SpadesKeys;

	/* Load the objects image, create offscreen port, and delete the image. */

	for (i = 0; i < zNumGameImages; i++)
	{
		gGameImages[i] = ZImageCreateFromResourceManager( IMAGE_IDS[i], clrTrans );
		if (gGameImages[i] == NULL)
		{
            pszErrorText = ErrorTextOutOfMemory;
		}
	}

    // load the background
    if ( !( gBackground = ZOffscreenPortCreateFromResourceManager( IDB_BACKGROUND, clrTrans ) ) )
    {
        pszErrorText = ErrorTextResourceNotFound;

    }
    if ( !( gObjectBuffer = ZOffscreenPortCreateFromResourceManager( IDB_OBJECTS, clrTrans ) ) )
    {
        pszErrorText = ErrorTextResourceNotFound;
    }
    if ( !( gBiddingObjectBuffer = ZOffscreenPortCreateFromResourceManager( IDB_BIDDINGOBJECTS, clrTrans ) ) )
    {
        pszErrorText = ErrorTextResourceNotFound;
    }

    if ( pszErrorText )
    {
        // if anything goes wrong here, since it is mostly images, something will
        // break somewhere down the line. Best cut out now
        ZShellGameShell()->ZoneAlert( pszErrorText, NULL, NULL, true, true );
        // whatever.
        err = zErrOutOfMemory;
    }
	return err;
}


ZBool GameWindowFunc(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	ZBool msgHandled;
	Game pThis = (Game) pMessage->userData;
	msgHandled = FALSE;
	
	switch (pMessage->messageType) 
	{
        case zMessageWindowEnable:
            gGAcc->GeneralEnable();
            break;

        case zMessageWindowDisable:
            gGAcc->GeneralDisable();
            break;

        case zMessageSystemDisplayChange:
            DisplayChange(pThis);
            break;

		case zMessageWindowDraw:
			GameWindowDraw(window, pMessage);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonDoubleClick:
			HandleButtonDown(window, pMessage);
			msgHandled = TRUE;
			break;

		case zMessageWindowClose:
#ifndef SPADES_SIMPLE_UE
			if (pThis->playerType == zGamePlayer && pThis->dontPromptUser == FALSE)
			{
				if (pThis->quitGamePrompted == FALSE)
				{
					//if at this someone else has forfeited game or ratings not enabled
					if (ClosingRatedGame(&pThis->closeState))
					{
						if (ClosingWillForfeit(&pThis->closeState))
						{
							ClosingState(&pThis->closeState,zCloseEventCloseForfeit,pThis->seat);

							ZPrompt(gStrings[zStringQuitGameForfeit], &gQuitGamePromptRect, pThis->gameWindow, TRUE,
								zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, pThis);
						}
                        else if ( (pThis->closeState.state) & zCloseEventWaitStart)
                        {
							ClosingState(&pThis->closeState,zCloseEventCloseRated,pThis->seat);

							ZPrompt(gStrings[zStringQuitGamePrompt], &gQuitGamePromptRect, pThis->gameWindow, TRUE,
								zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, pThis);
						}
						else if ( (pThis->closeState.state) & zCloseEventMoveTimeoutOther)
						{
                            ClosingState(&pThis->closeState,zCloseEventCloseRated,pThis->seat);

							ZPrompt(gStrings[zStringQuitGameTimeout], &gQuitGamePromptRect, pThis->gameWindow, TRUE,
								zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, pThis);
                        }
                        else
                        {
							ClosingState(&pThis->closeState,zCloseEventCloseRated,pThis->seat);

							ZPrompt(gStrings[zStringQuitGamePrompt], &gQuitGamePromptRect, pThis->gameWindow, TRUE,
								zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, pThis);
						}
				
					}
					else
					{
						ClosingState(&pThis->closeState,zCloseEventCloseUnRated,pThis->seat);

						ZPrompt(gStrings[zStringQuitGamePrompt], &gQuitGamePromptRect, pThis->gameWindow, TRUE,
							zPromptYes | zPromptNo, NULL, NULL, NULL, QuitGamePromptFunc, pThis);
					}
					pThis->quitGamePrompted = TRUE;
				}
			}
			else
			{
				ZCRoomGameTerminated(pThis->tableID);
			}
			msgHandled = TRUE;
#endif // SPADES_SIMPLE_UE
			break;
		case zMessageWindowTalk:
			GameSendTalkMessage(window, pMessage);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


// all offscreen ports need to be regenerated
static void DisplayChange(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    int i;

    // delete the cards, they're kept as an offscreen port
	ZCardsDelete(zCardsNormal);

    // delete the images held as offscreen ports
    if(gBiddingObjectBuffer)
	    ZOffscreenPortDelete(gBiddingObjectBuffer);
    gBiddingObjectBuffer = NULL;

    if(gObjectBuffer)
	    ZOffscreenPortDelete(gObjectBuffer);
    gObjectBuffer = NULL;

    if(gBackground)
	    ZOffscreenPortDelete(gBackground);
    gBackground = NULL;

    // delete our personal offscreen ports
	if(game->gameBackBuffer)
		ZOffscreenPortDelete(game->gameBackBuffer);
	game->gameBackBuffer = NULL;

	if(gHandBuffer)
		ZOffscreenPortDelete(gHandBuffer);
	gHandBuffer = NULL;

    // now remake them all
	game->gameBackBuffer = ZOffscreenPortNew();
	if(!game->gameBackBuffer)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(game->gameBackBuffer, &gRects[zRectWindow]);

	gHandBuffer = ZOffscreenPortNew();
	if(!gHandBuffer)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}
	ZOffscreenPortInit(gHandBuffer, &gRects[zRectHand]);

	if(ZCardsInit(zCardsNormal) != zErrNone)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}

    // images held as offscreen ports
    COLORREF clrTrans = PALETTERGB(255, 0, 255);
    gBackground = ZOffscreenPortCreateFromResourceManager(IDB_BACKGROUND, clrTrans);
    gObjectBuffer = ZOffscreenPortCreateFromResourceManager(IDB_OBJECTS, clrTrans);
    gBiddingObjectBuffer = ZOffscreenPortCreateFromResourceManager(IDB_BIDDINGOBJECTS, clrTrans);

    if(!gBackground || !gObjectBuffer || !gBiddingObjectBuffer)
    {
	    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, true, true);
		return;
	}

    ZWindowInvalidate(game->gameWindow, NULL);
}


ZBool RolloverButtonDrawFunc(ZRolloverButton rolloverButton, ZGrafPort grafPort, int16 state,
                                          ZRect* pdstrect, void* userData)
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    Game game = (Game)userData;

    ZRect *psrcrect = NULL;
    switch ( state )
    {
    case zRolloverStateIdle:
        psrcrect = &gObjectRects[zRectObjectButtonIdle];
        break;
    case zRolloverStateDisabled:
        psrcrect = &gObjectRects[zRectObjectButtonDisabled];
        break;
    case zRolloverStateSelected:
        psrcrect = &gObjectRects[zRectObjectButtonSelected];
        break;
    case zRolloverStateHilited:
        psrcrect = &gObjectRects[zRectObjectButtonHighlighted];
        break;
    default:
        return FALSE;
    }
    // TODO: consider caching these rectangles. Is it really worth it?
    if ( game->showHandScore )
    {
        // this is a pretty cheap fix, but it allows us to have a fake Z-order
        // when drawing the rollover buttons.
	    ZRect zrc = gHandScoreRects[zRectHandScorePane];
	    ZCenterRectToRect(&zrc, &gRects[zRectWindow], zCenterBoth);
        // lift it up 4 pixels for fun
        zrc.top -= 4;
        zrc.bottom -= 4;
        ExcludeClipRect( ZGrafPortGetWinDC( grafPort ), zrc.left, zrc.top, zrc.right, zrc.bottom );
    }
    if ( game->showGameOver )
    {
	    ZRect zrc = gGameOverRects[zRectGameOverPane];
	    ZCenterRectToRect(&zrc, &gRects[zRectWindow], zCenterBoth);
        ExcludeClipRect( ZGrafPortGetWinDC( grafPort ), zrc.left, zrc.top, zrc.right, zrc.bottom );
    }

    ZCopyImage( gObjectBuffer, grafPort, psrcrect, pdstrect, gButtonMask, zDrawCopy );
    return TRUE;
}

static ZBool PlayButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	int16					i, j;
	Game					game;
	ZSpadesMsgPass			passMsg;
	TCHAR					tempStr[255];
	int16					cardIndex;

	game = (Game) userData;
	
	if ( state != zRolloverButtonClicked )
        return TRUE;

	if(!ZRolloverButtonIsEnabled(game->playButton))
		return TRUE;

    gGAcc->SetFocus(IDC_PLAY_BUTTON, false, 0);

	if (game->gameState == zSpadesGameStatePass)
	{
        /*
		if (GetNumCardsSelected(game) == zSpadesNumCardsInPass)
		{
			for (i = 0, j = 0; i < zSpadesNumCardsInHand; i++)
				if (game->cardsInHand[i] != zCardNone)
					if (game->cardsSelected[i])
					{
						passMsg.pass[j++] = game->cardsInHand[i];
						game->cardsInHand[i] = zCardNone;
						game->numCardsInHand--;
					}
			passMsg.seat = game->seat;
			ZSpadesMsgPassEndian(&passMsg);
			ZCRoomSendMessage(game->tableID, zSpadesMsgPass, (void*) &passMsg,
					sizeof(passMsg));
			
			// Indicate cards passed. 
			game->needToPass = -1;
			
			UpdateHand(game);
			
			ZRolloverButtonDisable(game->playButton);
		}
		else
		{
			wsprintf(tempStr, _T("Please select %d cards to pass."), zSpadesNumCardsInPass);
			ZAlert(tempStr, game->gameWindow);
		}
        */
	}
	else
	{
		if (game->playerToPlay == game->seat)
		{
			if (GetNumCardsSelected(game) == 1)
			{
				for (i = 0; i < zSpadesNumCardsInHand; i++)
					if (game->cardsInHand[i] != zCardNone)
						if (game->cardsSelected[i])
							cardIndex = i;
				PlayACard(game, cardIndex);
				
				if (game->numCardsInHand == 0)
                {
					ZRolloverButtonDisable(game->playButton);
                    gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
                }
			}
			else
			{
				ZShellGameShell()->ZoneAlert( gStrings[zStringSelectCard] );
			}
		}
		else
		{
            // this really should never happen, since we now disable the send button if it isn't
            // your turn. In which case we should assert to make sure we know this case existed,
            // but not actually DO anything
            ASSERT( !"This button shouldn't have been enabled. What did you do?" );
			//ZShellGameShell()->ZoneAlert( gStrings[zStringNotYourTurn] );
		}
	}    
    return TRUE;
}


static ZBool AutoPlayButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game;

	game = (Game) userData;

    if ( state != zRolloverButtonClicked )
        return TRUE;
	
	if(!ZRolloverButtonIsEnabled(game->autoPlayButton))
		return TRUE;

	
	if (game->autoPlay)
	{
		/* Turn auto play off. */
		game->autoPlay = FALSE;
		ZRolloverButtonSetText(game->autoPlayButton, gStrings[zStringAutoPlay]);
        EnableAutoplayAcc(game, true);
        gGAcc->SetFocus(IDC_AUTOPLAY_BUTTON, false, 0);
		ZRolloverButtonDraw(game->autoPlayButton);
		if ( game->playerToPlay == game->seat )
        {
		    ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
        }
        else
        {
            ZRolloverButtonDisable(game->playButton);
            gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        }
	}
	else
	{
		/* Turn auto play on. */
		game->autoPlay = TRUE;
		ZRolloverButtonSetText(game->autoPlayButton, gStrings[zStringStop]);
        EnableAutoplayAcc(game, true);
        gGAcc->SetFocus(IDC_STOP_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDraw(game->autoPlayButton);
		
		UnselectAllCards(game);
		
		if (game->animatingTrickWinner == FALSE)
		{
			/* Play card if turn to play. */
			if (game->playerToPlay == game->seat)
				AutoPlayCard(game);
		}
		
		UpdateHand(game);
	}
    return TRUE;
}


static ZBool LastTrickButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game			game = I(userData);
	char			tempCard;
	int16			i;
	                                                                 
    if ( state != zRolloverButtonClicked )
        return TRUE;
	
	if(!ZRolloverButtonIsEnabled(game->lastTrickButton))
		return TRUE;

	if (game->lastTrickShowing)
	{
		/* Hide last trick cards. */
		game->lastTrickShowing = FALSE;
		ZRolloverButtonSetText(game->lastTrickButton, gStrings[zStringLastTrick]);
        EnableLastTrickAcc(game, true);
        gGAcc->SetFocus(IDC_LAST_TRICK_BUTTON, false, 0);
		ZRolloverButtonDraw(game->lastTrickButton);
		if (game->playButtonWasEnabled)
        {
			ZRolloverButtonEnable(game->playButton);
            gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
        }
		if (game->autoPlayButtonWasEnabled)
        {
			ZRolloverButtonEnable(game->autoPlayButton);
            EnableAutoplayAcc(game, true);
        }
		
		/* Swap currenly played cards with the last trick. */
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
			tempCard = game->cardsPlayed[i];
			game->cardsPlayed[i] = game->cardsLastTrick[i];
			game->cardsLastTrick[i] = tempCard;
		}
		
		game->timerType = game->oldTimerType;
		ZTimerSetTimeout(game->timer, game->oldTimeout);
		
		ClearPlayerCardOutline(game, game->leadPlayer);
		UpdateTable(game);

		ZCRoomUnblockMessages(game->tableID);
		
		//leonp - Bug fix Bug# 356 Since we are blocking all messages, this will disable the option button
		//(Behavior change)
#ifndef SPADES_SIMPLE_UE
		ZButtonEnable(game->optionsButton);
#endif // SPADES_SIMPLE_UE
	}
	else
	{
		/* Show last trick cards. */
		game->lastTrickShowing = TRUE;
		ZRolloverButtonSetText(game->lastTrickButton, gStrings[zStringDone]);
        EnableLastTrickAcc(game, true);
        gGAcc->SetFocus(IDC_DONE_BUTTON, false, 0);
		ZRolloverButtonDraw(game->lastTrickButton);
		game->playButtonWasEnabled = ZRolloverButtonIsEnabled(game->playButton);
		game->autoPlayButtonWasEnabled = ZRolloverButtonIsEnabled(game->autoPlayButton);
		ZRolloverButtonDisable(game->playButton);
		ZRolloverButtonDisable(game->autoPlayButton);
        gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
        EnableAutoplayAcc(game, false);
		
		/* Swap currenly played cards with the last trick. */
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
			tempCard = game->cardsPlayed[i];
			game->cardsPlayed[i] = game->cardsLastTrick[i];
			game->cardsLastTrick[i] = tempCard;
		}
		
		game->oldTimerType = game->timerType;
		game->timerType = zGameTimerNone;
		game->oldTimeout = ZTimerGetTimeout(game->timer);
		ZTimerSetTimeout(game->timer, 0);
		
		ClearPlayerCardOutline(game, game->playerToPlay);
		UpdateTable(game);
		
		//leonp - Bug fix Bug# 356 Since we are blocking all messages, this will disable the option button
		//(Behavior change)
#ifndef SPADES_SIMPLE_UE
		ZButtonDisable(game->optionsButton);
#endif // SPADES_SIMPLE_UE
		ZCRoomBlockMessages(game->tableID, zRoomFilterThisMessage, zSpadesMsgTalk);
	}
    return TRUE;
}


static void GameWindowDraw(ZWindow window, ZMessage *message)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect				rect;
	ZRect				oldClipRect;
	Game				game;
	
	
	if (ZRectEmpty(&message->drawRect) == FALSE)
	{
		rect = message->drawRect;
	}
	else
	{
		rect = gRects[zRectWindow];
	}
		
	
	game = (Game) message->userData;

    if ( game )
    {
        // initialize our backbuffer
	    ZBeginDrawing(game->gameBackBuffer);
	    ZGetClipRect(game->gameBackBuffer, &oldClipRect);
	    ZSetClipRect(game->gameBackBuffer, &rect);
        // we now draw to the backbuffer
        game->gameDrawPort = game->gameBackBuffer;

	    DrawBackground(game, NULL, NULL);
		DrawTable(game);
		DrawPlayers(game);
		DrawOptions(game);
		DrawJoinerKibitzers(game);
		DrawHand(game);
		DrawScore(game);
		DrawBids(game);
		DrawTricksWon(game);
		DrawBidControls(game);
		DrawPassText(game);
		DrawHandScore(game);
		DrawGameOver(game);
        DrawFocusRect(game);

        ZEndDrawing( game->gameBackBuffer );
        // reset back to window
        game->gameDrawPort = game->gameWindow;
        // now blt everythign onto the window using the same clip rectangle
        // since we already clipped things using the back buffer, there is 
        // no need to here.
	    ZBeginDrawing(window);
	    //ZGetClipRect(window, &oldClipRect);
	    //ZSetClipRect(window, &rect);
        ZCopyImage( game->gameBackBuffer, game->gameWindow, &rect, &rect, NULL, zDrawCopy );
	    //ZSetClipRect(window, &oldClipRect);
	    ZEndDrawing(window);
    }
    else
    {
        DrawBackground( NULL, window, NULL );
    }
}


// DrawBackground no longer cares about its first argument--it will draw
// to the draw port/
static void DrawBackground(Game game, ZWindow window, ZRect* drawRect)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	if (drawRect == NULL)
		drawRect = &gRects[zRectWindow];

    ZCopyImage(gBackground, game ? game->gameDrawPort : window , drawRect, drawRect, NULL, zDrawCopy);
}


static void DrawTable(Game game)
{

	int16			i;
	//dossier
	ZImage			image = NULL;
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	if (game->animatingTrickWinner)
	{
		UpdateTrickWinner(game, FALSE);
	}
	else
	{
		for (i = 0; i < zSpadesNumPlayers; i++)
			DrawPlayedCard(game, i);
	
		if (game->gameState == zSpadesGameStatePlay)
		{
			if (game->showPlayerToPlay)
			{
				/* Show the winner of the last trick (this trick's lead player) if showing last trick. */
				if (game->lastTrickShowing)
					OutlinePlayerCard(game, game->leadPlayer, TRUE);
				else
					OutlinePlayerCard(game, game->playerToPlay, FALSE);
			}
		}
	}

	
}


void UpdateTable(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawTable(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawPlayedCard(Game game, int16 seat)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZImage			image = NULL;
	ZBool			drawBack = TRUE;
	
	
	if (game->cardsPlayed[seat] != zCardNone)
	{
		ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[seat]),
				game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]]);
		drawBack = FALSE;
	}
	
	if (drawBack)
		DrawBackground(game, NULL, &gRects[gCardRectIndex[LocalSeat(game, seat)]]);
}


void UpdatePlayedCard(Game game, int16 seat)
{
	ZBeginDrawing(game->gameWindow);
	DrawPlayedCard(game, seat);
	ZEndDrawing(game->gameWindow);
}


void UpdatePlayer( Game game, int16 seat )
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
    // first erase the name that's there
	ZBeginDrawing(game->gameWindow);
    ZRect *pRect = &gRects[gNameRectIndex[LocalSeat(game, seat)]];

    DrawBackground(game, NULL, pRect);

    CZoneColorFont *pFont;
	HDC hdc = ZGrafPortGetWinDC( game->gameWindow );
    pFont = &gFonts[gNameFontIndex[ZGetTeam(seat)]];

	if (game->players[seat].userID != 0)
	{
        pFont->Select( hdc );
		ZDrawText( game->gameWindow, pRect, zTextJustifyCenter, game->players[seat].name );
        pFont->Deselect( hdc );
	}
	ZEndDrawing(game->gameWindow);
}

static void DrawPlayers(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16 i;
	ZRect *pRect;
    CZoneColorFont *pFont;
	
	HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		pRect = &gRects[gNameRectIndex[LocalSeat(game, i)]]; 
        pFont = &gFonts[gNameFontIndex[ZGetTeam(i)]];

		// Draw the player name
		if (game->players[i].userID != 0)
		{
            pFont->Select( hdc );
			ZDrawText( game->gameDrawPort, pRect, zTextJustifyCenter, game->players[i].name );
            pFont->Deselect( hdc );
		}
	}
}


void UpdatePlayers(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawPlayers(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawHand(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i;
    int16           j;
	ZRect			rect;
	int16			cardIndex;
    bool            fFrontDrawn;

	
	if (game->gameState == zSpadesGameStateBid || game->gameState == zSpadesGameStatePass ||
			game->gameState == zSpadesGameStatePlay)
	{
        int16 lCardPopup = (int16)GetDataStoreUILong( SpadesKeys::key_CardPopup );
        int16 nCardOffset = (int16) GetDataStoreUILong(SpadesKeys::key_CardOffset);

		ZBeginDrawing(gHandBuffer);
		
		DrawBackground(NULL, gHandBuffer, &gRects[zRectHand]);
		
		GetHandRect(game, &rect);
		
		rect.top += lCardPopup;
		rect.right = rect.left + zCardWidth;
		
		for (i = 0; i < zSpadesNumCardsInHand; i++)
		{
			if (game->cardsInHand[i] != zCardNone)
			{
				if (game->cardsSelected[i])
					ZRectOffset(&rect, 0, -lCardPopup);

                fFrontDrawn = false;
				
                // handle accessibility rect
                RECT rc;
                rc.left = rect.left;
                rc.top = rect.top;
                rc.bottom = rect.bottom;
                rc.right = rect.right;
/*                for(j = i + 1; j < zSpadesNumCardsInHand; j++)  // only used if focus drawn in DrawFocusRect
                    if(game->cardsInHand[j] != zCardNone)
                    {
                        rc.right = rc.left + nCardOffset;
                        break;
                    }
*/
				if ((game->playerType != zGamePlayerKibitzer && game->showCards) ||
						(game->showCards && game->playerType == zGamePlayerKibitzer && game->hideCardsFromKibitzer == FALSE))
				{
					cardIndex = CardImageIndex(game->cardsInHand[i]);
					if (cardIndex >= 0 && cardIndex < zDeckNumCards)
                    {
						ZCardsDrawCard(zCardsNormal, cardIndex, gHandBuffer, &rect);
                        if(game->gameState == zSpadesGameStatePlay)
                            fFrontDrawn = true;

                        if(game->iFocus == zAccHand + i)  // copied from DrawFocusRect so that whole card could be covered (even if non-rectangular shape visible)
                        {
		                    HDC	hdc = ZGrafPortGetWinDC(gHandBuffer);
		                    SetROP2(hdc, R2_MASKPEN);
                            SetBkMode(hdc, TRANSPARENT);
                            COLORREF color = SetTextColor(hdc, RGB(255, 255, 0));
                            HBRUSH hBrush = SelectObject(hdc, gFocusBrush);
                            HPEN hPen = SelectObject(hdc, gFocusPen);
		                    Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
                            SelectObject(hdc, hBrush);
                            SelectObject(hdc, hPen);
                            SetTextColor(hdc, color);
		                    SetROP2(hdc, R2_COPYPEN);
                        }
                    }
					else
                    {
						ASSERT(!"DrawHand - invalid card index. Almost crashed ...");
                        ZShellGameShell()->GameCannotContinue(game);
                    }
				}
				else
				{
					ZImageDraw(gGameImages[zImageCardBack], gHandBuffer, &rect, NULL, zDrawCopy);
				}

				/* Save card rect. */
				game->cardRects[i] = rect;

                // for accessibility, need the whole card space for proper invalidation
                if(game->cardsSelected[i])
                    rc.bottom += nCardOffset;
                else
                    rc.top -= nCardOffset;

                gGAcc->SetItemRect(&rc, zAccHand + i, true, 0);
                gGAcc->SetItemEnabled(fFrontDrawn, zAccHand + i, true, 0);
                if(fFrontDrawn && game->fSetFocusToHandASAP && !i)
                {
                    gGAcc->SetFocus(zAccHand, true, 0);
                    game->fSetFocusToHandASAP = false;
                }

				if (game->cardsSelected[i])
					ZRectOffset(&rect, 0, lCardPopup );
					
                ZRectOffset(&rect, nCardOffset, 0);
			}
            else
            {
                gGAcc->SetItemEnabled(false, zAccHand + i, true, 0);
            }
		}
		
		ZCopyImage(gHandBuffer, game->gameDrawPort, &gRects[zRectHand], &gRects[zRectHand], NULL, zDrawCopy);
		
		ZEndDrawing(gHandBuffer);
	}
    else
        for(i = zAccHand; i < zAccHand + 13; i++)
            gGAcc->SetItemEnabled(false, i, true, 0);
}


void UpdateHand(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawHand(game);
//    DrawFocusRect(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawTricksWon(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16 i;
    TCHAR tempBid[10];
	TCHAR tempStr[32];
    TCHAR tempTricksWon[10];
	
    if (game->gameState == zSpadesGameStatePass ||
		game->gameState == zSpadesGameStatePlay)
    {
	    HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
        gFonts[zFontBid].Select( hdc );

	    for ( i = 0; i < zSpadesNumPlayers; i++)
	    {
            ZRect *pdstRect = &gRects[ gBidPlateRectIndex[ LocalSeat(game, i) ] ];

            ZCopyImage( gObjectBuffer, game->gameDrawPort, 
                            &gObjectRects[ gBidPlateIndex[ ZGetTeam(i) ] ],
                            pdstRect, 
                            gBidMadeMask, zDrawCopy);
	    
            if ( game->bids[i] == zSpadesBidDoubleNil )
            {
                lstrcpy( tempBid, gStrings[zStringDoubleNil] );
            }
            else
            {
                _itot( game->bids[i], tempBid, 10 );
            }
            _itot( game->tricksWon[i], tempTricksWon, 10 );
            SpadesFormatMessage( tempStr, NUMELEMENTS(tempStr), IDS_TRICKCOUNTER, tempTricksWon, tempBid );
		    ZDrawText(game->gameDrawPort, pdstRect, zTextJustifyCenter, tempStr );
	    }

        gFonts[zFontBid].Deselect( hdc );
    }
}


static void UpdateTricksWon(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawTricksWon(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawJoinerKibitzers(Game game)
{
#ifndef SPADES_SIMPLE_UE
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, j;
	

	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		j = 0;
		if (game->numKibitzers[i] > 0)
			ZImageDraw(gGameImages[zImageKibitzer], game->gameDrawPort,
					&gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]], NULL, zDrawCopy);
		if (game->playersToJoin[i] != 0)
			ZImageDraw(gGameImages[zImageJoiner], game->gameDrawPort,
					&gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]], NULL, zDrawCopy);
		while (j <= 1)
			DrawBackground(game, NULL, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][j++]]);
	}
	if (game->showHandScore)
		UpdateHandScore(game);
	if (game->showGameOver)
		UpdateGameOver(game);
#endif // SPADES_SIMPLE_UE
}


void UpdateJoinerKibitzers(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawJoinerKibitzers(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawOptions(Game game)
{
#ifndef SPADES_SIMPLE_UE
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, j;
	uint32			tableOptions;
	

	tableOptions = 0;
	for (i = 0; i < zSpadesNumPlayers; i++)
		tableOptions |= game->tableOptions[i];
	
	j = 0;
	if (tableOptions & zRoomTableOptionNoKibitzing)
		ZImageDraw(gGameImages[zImageNoKibitzer], game->gameWindow,
				&gRects[gOptionsRectIndex[j++]], NULL, zDrawCopy);
	if (tableOptions & zRoomTableOptionNoJoining)
		ZImageDraw(gGameImages[zImageNoJoiner], game->gameWindow,
				&gRects[gOptionsRectIndex[j++]], NULL, zDrawCopy);
	while (j <= 1)
		DrawBackground(game, NULL, &gRects[gOptionsRectIndex[j++]]);
#endif // SPADES_SIMPLE_UE
}


#ifndef SPADES_SIMPLE_UE
void UpdateOptions(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawOptions(game);
	ZEndDrawing(game->gameWindow);
}
#endif // SPADES_SIMPLE_UE


static void DrawScore(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	TCHAR str[100];
	

	//ZSetDrawMode(game->gameWindow, zDrawCopy);
	
	/* Draw the score board. */
	ZCopyImage(gObjectBuffer, game->gameDrawPort, 
                &gObjectRects[zRectObjectTeam1ScorePlate],
                &gRects[zRectLeftScorePad], 
                NULL, zDrawCopy);
	
	ZCopyImage(gObjectBuffer, game->gameDrawPort, 
                &gObjectRects[zRectObjectTeam2ScorePlate],
                &gRects[zRectRightScorePad], 
                NULL, zDrawCopy);

	/* Draw the bags. */
	ZCopyImage(gObjectBuffer, game->gameDrawPort, &gObjectRects[zRectObjectBag0 + game->bags[0]],
			&gRects[zRectLeftBag], gBagMask, zDrawCopy);
	ZCopyImage(gObjectBuffer, game->gameDrawPort, &gObjectRects[zRectObjectBag0 + game->bags[1]],
			&gRects[zRectRightBag], gBagMask, zDrawCopy);

	HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
    gFonts[zFontScore].Select( hdc );

	/* Draw the scores. */
	wsprintf(str, _T("%d"), game->scoreHistory.totalScore[0]);
	ZDrawText(game->gameDrawPort, &gRects[zRectLeftScore], zTextJustifyCenter, str);
	wsprintf(str, _T("%d"), game->scoreHistory.totalScore[1]);
	ZDrawText(game->gameDrawPort, &gRects[zRectRightScore], zTextJustifyCenter, str);

    gFonts[zFontScore].Deselect( hdc );
}


static void UpdateScore(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawScore(game);
	ZEndDrawing(game->gameWindow);
}


/*
	Draws both the large and small bids.
*/
static void DrawBids(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i;
	char			bid;
	
	
	ZSetDrawMode(game->gameDrawPort, zDrawCopy);
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		bid = game->bids[i];

        // dont' draw the bid unless the bid has been made, except in the case
        // of the person whose turn it is to bid, in which case draw the ? bid
		if ( ( ( game->gameState == zSpadesGameStateBid ) && ( bid != zSpadesBidNone ) ) || 
             ( i == game->playerToPlay ) )
		{
			DrawLargeBid(game, i, bid);
		}
		else
		{
			DrawBackground(game, NULL, &gRects[gSmallBidRectIndex[LocalSeat(game, i)]]);
		}
	}
}


static void UpdateBids(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawBids(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawLargeBid(Game game, int16 seat, char bid)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect			rect, clipRect, oldClipRect;


	if (game->gameState == zSpadesGameStateBid)
	{
		rect = gObjectRects[zRectObjectBidLargeNil];
		ZCenterRectToRect(&rect, &gRects[gLargeBidRectIndex[LocalSeat(game, seat)]], zCenterBoth);
        //rect = gRects[gLargeBidRectIndex[LocalSeat(game, seat)]];
		clipRect = rect;

        if ( game->pBiddingDialog && game->toBid == zSpadesBidNone && game->playerType == zGamePlayer)
        {
            ZRect zrc;
            game->pBiddingDialog->GetRect( &zrc );
			ZRectSubtract(&clipRect, &zrc );
        }

    	ZGetClipRect(game->gameDrawPort, &oldClipRect);
		ZSetClipRect(game->gameDrawPort, &clipRect);

		if (bid == zSpadesBidNone)
        {
			ZCopyImage(gObjectBuffer, game->gameDrawPort, &gObjectRects[zRectObjectBidLargeWaiting], &rect, gLargeBidMask, zDrawCopy);
        }
		else if (bid == 0)
        {
			ZCopyImage(gObjectBuffer, game->gameDrawPort,&gObjectRects[zRectObjectBidLargeNil], &rect, gLargeBidMask, zDrawCopy);
        }
		else if (bid == zSpadesBidDoubleNil)
        {
			ZCopyImage(gObjectBuffer, game->gameDrawPort,&gObjectRects[zRectObjectBidLargeDoubleNil], &rect, gLargeBidMask, zDrawCopy);
        }
		else
        {
			ZCopyImage(gObjectBuffer, game->gameDrawPort,&gObjectRects[zRectObjectBidLarge1 + (bid - 1)], &rect, gLargeBidMask, zDrawCopy);
        }

		ZSetClipRect(game->gameDrawPort, &oldClipRect);
	}
}


void UpdateBid(Game game, int16 seat)
{
	ZBeginDrawing(game->gameWindow);
	DrawLargeBid(game, seat, game->bids[seat]);
	ZEndDrawing(game->gameWindow);
}


static void DrawBidControls( Game game )
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i;
	
	
	if (game->gameState == zSpadesGameStateBid && game->playerType == zGamePlayer &&
			game->toBid == zSpadesBidNone)
	{
        if ( game->pBiddingDialog )
        {
            game->pBiddingDialog->Draw();
        }
	}
}
     



static void DrawHandScore(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16 i;
    int16 originX, originY;
	TCHAR str[100];
    TCHAR lilstr1[16], lilstr2[16];
    ZRect rect;
	int16 bid[zSpadesNumTeams], made[zSpadesNumTeams], bags[zSpadesNumTeams];
	int16 myTeam, otherTeam;

	if (game->gameState == zSpadesGameStateEndHand && game->showHandScore)
	{
        int nDrawMode = zDrawCopy;
        int nJustify = zTextJustifyRight;
        // our background is easily flipped to accomodate RTL layout
        if ( ZIsLayoutRTL() )
        {
            nDrawMode |= zDrawMirrorHorizontal;
            nJustify = zTextJustifyLeft;
        }

        myTeam = game->seat % 2;
        otherTeam = 1 - myTeam;

        rect = gHandScoreRects[zRectHandScorePane];
		ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
        // lift it up 4 pixels for fun
        rect.top -= 4;
        rect.bottom -= 4;
        ZImageDraw( gGameImages[zImageHandOverBackground], game->gameDrawPort, &rect, NULL, nDrawMode );

		originX = rect.left;
		originY = rect.top;

	    HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
        gFonts[zFontHandOverTitle].Select( hdc );

		rect = gHandScoreRects[zRectHandScoreTitle];
		ZRectOffset( &rect, originX, originY );
		ZDrawText( game->gameDrawPort, &rect, zTextJustifyCenter, gStrings[zStringHandScoreTitle] );

        gFonts[zFontHandOverTitle].Deselect( hdc );
        gFonts[zFontHandOverTeamNames].Select( hdc );

		// Draw team names, totals
		rect = gHandScoreRects[zRectHandScoreTeamName1];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, nJustify, game->teamNames[myTeam] );

		rect = gHandScoreRects[zRectHandScoreTeamName2];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, nJustify, game->teamNames[otherTeam] );

		rect = gHandScoreRects[zRectHandScoreTeamTotal1];
		ZRectOffset(&rect, originX, originY);
        _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].scores[myTeam], str, 10);
		ZDrawText(game->gameDrawPort, &rect, nJustify, str);

		rect = gHandScoreRects[zRectHandScoreTeamTotal2];
		ZRectOffset(&rect, originX, originY);
        _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].scores[otherTeam], str, 10);
		ZDrawText(game->gameDrawPort, &rect, nJustify, str);

        gFonts[zFontHandOverTeamNames].Deselect( hdc );
        gFonts[zFontHandOverText].Select( hdc );

		// Draw static texts.
		//ZSetFont(game->gameDrawPort, (ZFont) ZGetStockObject(zObjectFontSystem12Normal));
		rect = gHandScoreRects[zRectHandScoreTricksTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreTricks] );

		rect = gHandScoreRects[zRectHandScoreNBagsTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreNBags] );

		rect = gHandScoreRects[zRectHandScoreTractTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreTract] );

		rect = gHandScoreRects[zRectHandScoreBonusTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreBonus] );

		rect = gHandScoreRects[zRectHandScoreNilTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreNil] );

		rect = gHandScoreRects[zRectHandScoreBagsTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreBags] );

		rect = gHandScoreRects[zRectHandScoreTotalTitle];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, gStrings[zStringHandScoreTotal] );

        bid[0] = bid[1] = 0;
        made[0] = made[1] = 0;
        bags[0] = bags[1] = 0;

		// Draw bid and scores.
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
            if(game->bids[i] && game->bids[i] != zSpadesBidDoubleNil)
            {
				bid[ZGetTeam(i)] += game->bids[i];
			    made[ZGetTeam(i)] += game->tricksWon[i];
            }
            else
                bags[ZGetTeam(i)] += game->tricksWon[i];
		}

        if(made[0] > bid[0])
            bags[0] += made[0] - bid[0];
        if(made[1] > bid[1])
            bags[1] += made[1] - bid[1];

		// Draw team bids, made, bonus and scores.
        // Team 1
		rect = gHandScoreRects[zRectHandScoreTeamTricks1];
		ZRectOffset(&rect, originX, originY);
        _itot(made[myTeam], lilstr1, 10);
        _itot(bid[myTeam], lilstr2, 10);
        SpadesFormatMessage(str, NUMELEMENTS(str), IDS_TRICKCOUNTER, lilstr1, lilstr2);
		ZDrawText( game->gameDrawPort, &rect, nJustify, str );

		rect = gHandScoreRects[zRectHandScoreTeamTract1];
		ZRectOffset(&rect, originX, originY);
        _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].base[myTeam], str, 10);
		ZDrawText(game->gameDrawPort, &rect, nJustify, str);

        if(bags[myTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamNBags1];
		    ZRectOffset(&rect, originX, originY);
            _itot(bags[myTeam], str, 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagbonus[myTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamBonus1];
		    ZRectOffset(&rect, originX, originY);
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagbonus[myTeam], str + 1, 10);
            str[0] = _T('+');
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[myTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamNil1];
		    ZRectOffset(&rect, originX, originY);
            str[0] = _T('+');
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[myTeam],
                str + (game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[myTeam] > 0 ? 1 : 0), 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagpenalty[myTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamBags1];
		    ZRectOffset(&rect, originX, originY);
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagpenalty[myTeam], str, 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        // Team 2
		rect = gHandScoreRects[zRectHandScoreTeamTricks2];
		ZRectOffset(&rect, originX, originY);
        _itot(made[otherTeam], lilstr1, 10);
        _itot(bid[otherTeam], lilstr2, 10);
        SpadesFormatMessage(str, NUMELEMENTS(str), IDS_TRICKCOUNTER, lilstr1, lilstr2);
		ZDrawText( game->gameDrawPort, &rect, nJustify, str );

		rect = gHandScoreRects[zRectHandScoreTeamTract2];
		ZRectOffset(&rect, originX, originY);
        _itot( game->scoreHistory.scores[game->scoreHistory.numScores - 1].base[otherTeam], str, 10);
		ZDrawText(game->gameDrawPort, &rect, nJustify, str);

        if(bags[otherTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamNBags2];
		    ZRectOffset(&rect, originX, originY);
            _itot(bags[otherTeam], str, 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagbonus[otherTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamBonus2];
		    ZRectOffset(&rect, originX, originY);
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagbonus[otherTeam], str + 1, 10);
            str[0] = _T('+');
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[otherTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamNil2];
		    ZRectOffset(&rect, originX, originY);
            str[0] = _T('+');
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[otherTeam],
                str + (game->scoreHistory.scores[game->scoreHistory.numScores - 1].nil[otherTeam] > 0 ? 1 : 0), 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        if(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagpenalty[otherTeam])
        {
		    rect = gHandScoreRects[zRectHandScoreTeamBags2];
		    ZRectOffset(&rect, originX, originY);
            _itot(game->scoreHistory.scores[game->scoreHistory.numScores - 1].bagpenalty[otherTeam], str, 10);
		    ZDrawText(game->gameDrawPort, &rect, nJustify, str);
        }

        gFonts[zFontHandOverText].Deselect( hdc );
	}
}


void UpdateHandScore(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawHandScore(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawGameOver(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect rect;
	int16 originX, originY;
	TCHAR str[100];
	int16 winner, loser;
    // TODO: right now there is no winner logo--it is a part of the background.
    // in the case of a tie, though, one person will have it next to them.
    // the question is, do we care?  the answer is, no, ties have been made impossible in spades.
	//ZBool		tie = FALSE;
	
	
	if (game->gameState == zSpadesGameStateEndGame && game->showGameOver)
	{
        int nDrawMode = zDrawCopy;	

        // figure out who won and draw them at the top
		if (game->winners[0] && game->winners[1])
		{
			winner = 0;
			loser = 1;
			//tie = TRUE;
		}
		else if (game->winners[0])
		{
			winner = 0;
			loser = 1;
		}
		else if (game->winners[1])
		{
			winner = 1;
			loser = 0;
		}
		else
		{
			winner = 0;
			loser = 1;
			//tie = TRUE;
		}
		
        if ( ZIsLayoutRTL() )
        {
            nDrawMode |= zDrawMirrorHorizontal;
        }

        rect = gGameOverRects[zRectGameOverPane];
		ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
        ZImageDraw( gGameImages[zImageGameOverBackground], game->gameDrawPort, &rect, NULL, nDrawMode );

		originX = rect.left;
		originY = rect.top;

	    HDC hdc = ZGrafPortGetWinDC( game->gameDrawPort );
        gFonts[zFontGameOverTitle].Select( hdc );

		rect = gGameOverRects[zRectGameOverTitle];
		ZRectOffset( &rect, originX, originY );
		ZDrawText( game->gameDrawPort, &rect, zTextJustifyCenter, gStrings[zStringGameOverTitle] );
		
        gFonts[zFontGameOverTitle].Deselect( hdc );
        gFonts[zFontGameOverText].Select( hdc );

        /*
		if (tie == FALSE)
		{
			// Draw the winner image.
			rect = gGameOverRects[zRectGameOverLogo];
			ZRectOffset(&rect, originX, originY);
			ZImageDraw(gGameImages[zImageWinnerLogo], game->gameDrawPort, &rect, NULL, zDrawCopy);
		}
        */
				
		// Draw winners.
		rect = gGameOverRects[zRectGameOverWinnerTeamName];
		ZRectOffset( &rect, originX, originY );
		ZDrawText( game->gameDrawPort, &rect, zTextJustifyLeft, game->teamNames[winner] );

		rect = gGameOverRects[zRectGameOverWinnerName1];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, game->seat == winner ? gStrings[zStringYou] : game->players[winner].name);

		rect = gGameOverRects[zRectGameOverWinnerName2];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, game->seat == ZGetPartner(winner) ? gStrings[zStringYou] : game->players[ZGetPartner(winner)].name);
		
		rect = gGameOverRects[zRectGameOverWinnerTeamScore];
		ZRectOffset(&rect, originX, originY);
        _itot( game->scoreHistory.totalScore[winner], str, 10 );
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyRight, str);

		// Draw losers.
		rect = gGameOverRects[zRectGameOverLoserTeamName];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, game->teamNames[loser]);

		rect = gGameOverRects[zRectGameOverLoserName1];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, game->seat == loser ? gStrings[zStringYou] : game->players[loser].name);

		rect = gGameOverRects[zRectGameOverLoserName2];
		ZRectOffset(&rect, originX, originY);
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyLeft, game->seat == ZGetPartner(loser) ? gStrings[zStringYou] : game->players[ZGetPartner(loser)].name);
		
		rect = gGameOverRects[zRectGameOverLoserTeamScore];
		ZRectOffset(&rect, originX, originY);
        _itot( game->scoreHistory.totalScore[loser], str, 10 );
		ZDrawText(game->gameDrawPort, &rect, zTextJustifyRight, str);

        gFonts[zFontGameOverText].Deselect( hdc );
	}
}


void UpdateGameOver(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawGameOver(game);
	ZEndDrawing(game->gameWindow);
}


static void DrawFocusRect(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(IsRectEmpty(&game->rcFocus))
        return;

    switch(game->eFocusType)
    {
        case zAccRectButton:
        {
		    HDC	hdc = ZGrafPortGetWinDC(game->gameDrawPort);
		    SetROP2(hdc, R2_COPYPEN);
            SetBkMode(hdc, TRANSPARENT);
            HBRUSH hBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
            HPEN hPen = SelectObject(hdc, gFocusPen);
		    Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
            SelectObject(hdc, hPen);
            SelectObject(hdc, hBrush);
            break;
        }

/*      case zAccRectCard:
        {
		    HDC	hdc = ZGrafPortGetWinDC(game->gameDrawPort);
		    SetROP2(hdc, R2_MASKPEN);
            SetBkMode(hdc, TRANSPARENT);
            COLORREF color = SetTextColor(hdc, RGB(255, 255, 0));
            HBRUSH hBrush = SelectObject(hdc, gFocusBrush);
            HPEN hPen = SelectObject(hdc, gFocusPen);
		    Rectangle(hdc, game->rcFocus.left, game->rcFocus.top, game->rcFocus.right, game->rcFocus.bottom);
            SelectObject(hdc, hBrush);
            SelectObject(hdc, hPen);
            SetTextColor(hdc, color);
		    SetROP2(hdc, R2_COPYPEN);
            break;
        }
*/  }
}


static void DrawPassText(Game game)
{
    /*
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect		rect;
	
	
	if (game->gameState == zSpadesGameStatePass && game->showPassText)
	{
		rect = gRects[zRectPassTextPane];

		// Draw Pane
		Draw3DPane(game->gameWindow, &rect, 12);
		
		ZSetFont(game->gameWindow, (ZFont) ZGetStockObject(zObjectFontSystem12Normal));
		ZRectInset(&rect, 16, 16);
		ZDrawText(game->gameWindow, &rect, (uint32) (zTextJustifyCenter + zTextJustifyWrap), zPassTextStr);
	}
    */
}


static void UpdatePassText(Game game)
{
	ZBeginDrawing(game->gameWindow);
	DrawPassText(game);
	ZEndDrawing(game->gameWindow);
}


static void ClearTable(Game game)
{
	int16			i;
	
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		game->cardsPlayed[i] = zCardNone;
		ClearPlayerCardOutline(game, i);
	}
	
	UpdateTable(game);
}


static void GetHandRect(Game game, ZRect *rect)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			width;
    using namespace SpadesKeys;
    
	*rect = gRects[zRectHand];
	if (game->numCardsInHand > 0)
	{
		width = (game->numCardsInHand - 1) * 
                    GetDataStoreUILong( key_CardOffset ) + zCardWidth;
		rect->left = (rect->right + rect->left - width) / 2;
		rect->right = rect->left + width;
	}
}


static void HandleButtonDown(ZWindow window, ZMessage* pMessage)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game				game;
	ZPoint				point;
	ZRect				handRect;
	int16				card;
	int16				seat;
	
	
	game = (Game) pMessage->userData;
	if (game != NULL)
	{
		// make any mouse click on game board act as if the user has hit the done button
		// when the last trick is shown. Users were having a hard time seeing that the last trick button
		// had changed to Done button.
		if(game->lastTrickShowing)
		{
			LastTrickButtonFunc(NULL, zRolloverButtonClicked, game);
			return;
		}

		point = pMessage->where;

		/* Debugging Code Begin */
		/* Check if double click occurred in the rectangle. */
		ZSetRect(&handRect, 0, 0, 8, 8);
		if (pMessage->messageType == zMessageWindowButtonDoubleClick &&
				ZPointInRect(&point, &handRect))
			ZCRoomSendMessage(game->tableID, zSpadesMsgDumpHand, NULL, 0);
		/* Debugging Code End */
		
		/* If trick winner animation is on, terminate it. */
		if (game->animatingTrickWinner)
		{
			UpdateTrickWinner(game, TRUE);
		}

        // TODO: replace the showHandScore and showGameOver with IsWindow( )
    	if (game->gameState == zSpadesGameStateEndHand && game->showHandScore)
		{
			// Simulate timeout.
            gGAcc->SetFocus(zAccShowCards, true, 0);
			GameTimerFunc(game->timer, game);
			return;
		}
		else if (game->gameState == zSpadesGameStateEndGame && game->showGameOver)
		{
			// Simulate timeout.
            gGAcc->SetFocus(zAccShowCards, true, 0);
			GameTimerFunc(game->timer, game);
			return;
		}
		
		if (game->playerType == zGamePlayer)
		{
            if (game->gameState == zSpadesGameStatePass || game->gameState == zSpadesGameStatePlay)
			{
				/* Deselect passed cards, if any. */
				if (game->gameState == zSpadesGameStatePlay &&
						game->numCardsInHand == zSpadesNumCardsInHand &&
						GetNumCardsSelected(game) == zSpadesNumCardsInPass)
				{
					UnselectAllCards(game);
					UpdateHand(game);
				}
				
				GetHandRect(game, &handRect);
				if (ZPointInRect(&point, &handRect))
				{
					/* Play card if double-clicked and not auto-play. */
					if (game->gameState == zSpadesGameStatePlay &&
							pMessage->messageType == zMessageWindowButtonDoubleClick &&
							game->playerToPlay == game->seat &&
							game->autoPlay == FALSE &&
							game->animatingTrickWinner == FALSE &&
							game->lastTrickShowing == FALSE &&
							game->lastClickedCard != zCardNone)
					{
						PlayACard(game, game->lastClickedCard);
					}
					else
					{
						card = GetCardIndex(game, &point);
						if (card != zCardNone)
						{
							if (game->cardsSelected[card])
							{
								game->cardsSelected[card] = FALSE;
							}
							else
							{
								if (game->gameState == zSpadesGameStatePlay)
									UnselectAllCards(game);
								game->cardsSelected[card] = TRUE;
							}
							
							game->lastClickedCard = card;
							gGAcc->SetFocus(zAccHand + card, true, 0);
							UpdateHand(game);
						}
						else
						{
							game->lastClickedCard = zCardNone;
						}
					}
				}
			}
		}
		if ((seat = FindJoinerKibitzerSeat(game, &point)) != -1)
		{
			HandleJoinerKibitzerClick(game, seat, &point);
		}
	}
}



static int16 GetCardIndex(Game game, ZPoint* point)
{
	int16			i;
	int16			selectedCard = zCardNone;
	
	
	for (i = zSpadesNumCardsInHand - 1; i >= 0 ; i--)
	{
		if (game->cardsInHand[i] != zCardNone)
			if (ZPointInRect(point, &game->cardRects[i]))
			{
				selectedCard = i;
				break;
			}
	}
	
	return (selectedCard);
}


static void GameTimerFunc(ZTimer timer, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	Game			game = (Game) userData;
	

	switch (game->timerType)
	{
		case zGameTimerShowHandScore:
            if(gGAcc->GetStackSize() > 1)
                gGAcc->PopItemlist();
            ASSERT(gGAcc->GetStackSize() == 1);

			HideHandScore(game);
			
			/* Stop the timer for now. */
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			
			ZCRoomUnblockMessages(game->tableID);

			break;
		case zGameTimerShowGameScore:
            if(gGAcc->GetStackSize() > 1)
                gGAcc->PopItemlist();
            ASSERT(gGAcc->GetStackSize() == 1);

			HideGameOver(game);
			
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);

			ZCRoomUnblockMessages(game->tableID);
			
			if (game->playerType == zGamePlayer)
			{
                ZShellGameShell()->GameOver( Z(game) );
				// Prompt the user for another game. 
				///ZPrompt(gStrings[zStringNewGamePrompt], &gGameNewGameWindowRect, game->gameWindow, TRUE,
				//		zPromptYes | zPromptNo, NULL, NULL, NULL, NewGamePromptFunc, game);
			}
			break;
		case zGameTimerShowTrickWinner:
			game->timerType = zGameTimerAnimateTrickWinner;
			ZTimerSetTimeout(game->timer, zTrickWinnerTimeout);
			UpdateTrickWinner(game, FALSE);
			break;
		case zGameTimerAnimateTrickWinner:
			UpdateTrickWinner(game, FALSE);
			break;
		case zGameTimerEndTrickWinnerAnimation:
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);

			game->animatingTrickWinner = FALSE;
			
			if (game->playerType == zGamePlayer)
			{
				if (game->playButtonWasEnabled)
                {
					ZRolloverButtonEnable(game->playButton);
                    gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
                }
				if (game->lastTrickButtonWasEnabled)
                {
					ZRolloverButtonEnable(game->lastTrickButton);
                    EnableLastTrickAcc(game, true);
                }
			}

			ClearTable(game);
			UpdateTricksWon(game);

			OutlinePlayerCard(game, game->playerToPlay, FALSE);

			if (game->numCardsInHand > 0 && game->playerToPlay == game->seat)
			{
				if (game->autoPlay)
				{
					AutoPlayCard(game);
				}
				else
				{
					if (game->playerType == zGamePlayer)
					{
						ZRolloverButtonEnable(game->playButton);
                        gGAcc->SetItemEnabled(true, IDC_PLAY_BUTTON, false, 0);
						if (game->beepOnTurn)
                        {
							ZBeep();
                            ZShellGameShell()->MyTurn();
                        }
					}
				}
			}
			else
			{
				if (game->playerType == zGamePlayer)
                {
					ZRolloverButtonDisable(game->playButton);
                    gGAcc->SetItemEnabled(false, IDC_PLAY_BUTTON, false, 0);
                }
			}

			ZCRoomUnblockMessages(game->tableID);
			break;
		case zGameTimerShowBid:
			game->timerType = zGameTimerNone;
			ZTimerSetTimeout(game->timer, 0);
			ZCRoomUnblockMessages(game->tableID);
            if(game->playerToPlay == game->seat && game->playerType == zGamePlayer)
                ZShellGameShell()->MyTurn();
			break;
		default:
			break;
	}
}


static void InitTrickWinnerGlobals(void)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			diffs[zNumAnimFrames] = { 0, 5, 15, 35, 65, 85, 95, 100};
	int16			i, j, k;
	ZPoint			winner, losers[zSpadesNumPlayers];


	for (k = 0; k < zSpadesNumPlayers; k++)
	{
		winner.x = gRects[gCardRectIndex[k]].left;
		winner.y = gRects[gCardRectIndex[k]].top;
		for (i = 0, j = 0; i < zSpadesNumPlayers; i++)
		{
			losers[j].x = gRects[gCardRectIndex[i]].left;
			losers[j].y = gRects[gCardRectIndex[i]].top;
			j++;
		}
		
		/* Calculate rectangle frame positions. */
		for (i = 0; i < zSpadesNumPlayers; i++)
		{
			gTrickWinnerPos[k][i][0] = losers[i];
			gTrickWinnerPos[k][i][zNumAnimFrames - 1] = winner;
			
			for (j = 1; j < zNumAnimFrames - 1; j++)
			{
				gTrickWinnerPos[k][i][j].x = ((winner.x - losers[i].x) * diffs[j]) /
						100 + losers[i].x;
				gTrickWinnerPos[k][i][j].y = ((winner.y - losers[i].y) * diffs[j]) /
						100 + losers[i].y;
			}
		}
	}

    using namespace SpadesKeys;
    const TCHAR* arKeys[] = { key_Spades, key_TrickWinnerColor };
    COLORREF clrTemp;

    if ( FAILED( ZShellDataStoreUI()->GetRGB( arKeys, 2, &clrTemp ) ) )
    {
        gTrickWinnerColor = *(ZColor*)ZGetStockObject( zObjectColorYellow ); 
    }
    else
    {
        ZSetColor( &gTrickWinnerColor, GetRValue( clrTemp ), GetGValue( clrTemp ), GetBValue( clrTemp ) );
    }

    arKeys[1] = key_CardOutlineColor;
    if ( FAILED( ZShellDataStoreUI()->GetRGB( arKeys, 2, &clrTemp ) ) )
    {
        gCardOutlineColor = *(ZColor*)ZGetStockObject( zObjectColorBlue ); 
    }
    else
    {
        ZSetColor( &gCardOutlineColor, GetRValue( clrTemp ), GetGValue( clrTemp ), GetBValue( clrTemp ) );
    }

	gTrickWinnerBounds = gRects[zRectTable];
}


void InitTrickWinner(Game game, int16 trickWinner)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, j;
	
	
	game->trickWinner = trickWinner;
	game->trickWinnerFrame = 0;
	game->animatingTrickWinner = TRUE;
	
	/* Initialize the ghost frames. */
	for (i = 0; i < zNumAnimGhostFrames; i++)
		for (j = 0; j < zSpadesNumPlayers - 1; j++)
			ZSetRect(&game->ghostFrames[j][i], 0, 0, 0, 0);

	game->winnerRect = gRects[gCardRectIndex[LocalSeat(game, trickWinner)]];
	for (i = 0, j = 0; i < zSpadesNumPlayers; i++)
		if (i != game->trickWinner)
		{
			game->loserRects[j] = gRects[gCardRectIndex[LocalSeat(game, i)]];
			game->loserSeats[j++] = i;
		}
}


static void UpdateTrickWinner(Game game, ZBool terminate)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, j, k;
	ZOffscreenPort	animPort;
	

	if (game->animatingTrickWinner)
	{	
		animPort = ZOffscreenPortNew();
		ZOffscreenPortInit(animPort, &gTrickWinnerBounds);
		
		ZBeginDrawing(animPort);
		
		/* Erase the background. */
		DrawBackground(NULL, animPort, &gTrickWinnerBounds);
		
		
		if (ZCRoomGetNumBlockedMessages(game->tableID) < zMaxNumBlockedMessages &&
				terminate == FALSE && game->animateCards == TRUE)
		{
			if ((i = game->trickWinnerFrame) < zNumAnimFrames)
			{
				/* Draw n-1 ghost frames. */
				for (j = 1; j < zNumAnimGhostFrames; j++)
					for (k = 0; k < zSpadesNumPlayers - 1; k++)
						ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[k]]),
								animPort, &game->ghostFrames[k][j]);
				
				/* Draw new frames. */
				for (j = 0; j < zSpadesNumPlayers - 1; j++)
				{
					ZRectOffset(&game->loserRects[j],
							gTrickWinnerPos[LocalSeat(game, game->trickWinner)][LocalSeat(game, game->loserSeats[j])][i].x - game->loserRects[j].left,
							gTrickWinnerPos[LocalSeat(game, game->trickWinner)][LocalSeat(game, game->loserSeats[j])][i].y - game->loserRects[j].top);
					ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[j]]),
							animPort, &game->loserRects[j]);
				}
				
				/* Copy frames. */
				for (j = 0; j < zSpadesNumPlayers - 1; j++)
				{
					for (k = 0; k < zNumAnimGhostFrames - 1; k++)
						game->ghostFrames[j][k] = game->ghostFrames[j][k + 1];
					game->ghostFrames[j][k] = game->loserRects[j];
				}
			}
			else
			{	
				/* Bring in the ghost frames. */
		
				/* Draw n-1 ghost frames. */
				for (j = i; j < zNumAnimGhostFrames; j++)
					for (k = 0; k < zSpadesNumPlayers - 1; k++)
						ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->loserSeats[k]]),
								animPort, &game->ghostFrames[k][j]);
			}
		}
		else
		{
			game->trickWinnerFrame = zNumAnimFrames + zNumAnimGhostFrames;
		}
		
		OutlineCard(animPort, &game->winnerRect, &gTrickWinnerColor);

		ZCardsDrawCard(zCardsNormal, CardImageIndex(game->cardsPlayed[game->trickWinner]),
				animPort, &game->winnerRect);
	
		ZEndDrawing(animPort);
	
		ZCopyImage(animPort, game->gameDrawPort, &gTrickWinnerBounds, &gTrickWinnerBounds,
				NULL, zDrawCopy);
		ZOffscreenPortDelete(animPort);
		
		game->trickWinnerFrame++;
		if (game->trickWinnerFrame >= zNumAnimFrames + zNumAnimGhostFrames)
		{
			game->timerType = zGameTimerEndTrickWinnerAnimation;
			ZTimerSetTimeout(game->timer, zEndTrickWinnerTimeout);
		}
	}
}


void OutlinePlayerCard(Game game, int16 seat, ZBool winner)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZColor*			color;
	
	
	if (winner)
    {
		color = &gTrickWinnerColor;
    }
	else
    {
		color = &gCardOutlineColor;
    }
	
	ZBeginDrawing(game->gameDrawPort);
	
	OutlineCard(game->gameDrawPort, &gRects[gCardRectIndex[LocalSeat(game, seat)]], color);
	
	ZEndDrawing(game->gameDrawPort);
}


void ClearPlayerCardOutline(Game game, int16 seat)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect		rect;
	
	ZBeginDrawing(game->gameDrawPort);
	
	rect = gRects[gCardRectIndex[LocalSeat(game, seat)]];
	ZRectInset(&rect, (int16)glCardOutlineInset, (int16)glCardOutlineInset);
	DrawBackground(game, NULL, &rect);

	DrawPlayedCard(game, seat);
	
	ZEndDrawing(game->gameDrawPort);
}


static void OutlineCard(ZGrafPort grafPort, ZRect* rect, ZColor* color)
{
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
	ZColor		oldColor;
	ZRect		tempRect;
	
	ZGetForeColor(grafPort, &oldColor);
	
	ZSetPenWidth(grafPort, (int16)glCardOutlinePenWidth );
	
	if (color != NULL)
		ZSetForeColor(grafPort, color);
	
	tempRect = *rect;
	ZRectInset(&tempRect, (int16)glCardOutlineInset, (int16)glCardOutlineInset);
	ZRoundRectDraw(grafPort, &tempRect, (int16)glCardOutlineRadius );
	
	ZSetForeColor(grafPort, &oldColor);
}


static void HelpButtonFunc( ZHelpButton helpButton, void* userData )
{
	ZLaunchHelp( zGameHelpID );
}


void ShowHandScore(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect			rect;
	
	
	game->showHandScore = TRUE;
	UpdateHandScore(game);
	rect = gHandScoreRects[zRectHandScorePane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
    // lift it up 4 pixels for fun
    rect.top -= 4;
    rect.bottom -= 4;
	ZWindowValidate(game->gameWindow, &rect);
}


void HideHandScore(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect			rect;
	
	
	game->showHandScore = FALSE;
	ZWindowDraw(game->gameWindow, NULL);
	rect = gHandScoreRects[zRectHandScorePane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
    // lift it up 4 pixels for fun
    rect.top -= 4;
    rect.bottom -= 4;
	ZWindowInvalidate(game->gameWindow, &rect);
}


void ShowGameOver(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect			rect;
	
	
	game->showGameOver = TRUE;
	UpdateGameOver(game);
	rect = gGameOverRects[zRectGameOverPane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
	ZWindowValidate(game->gameWindow, &rect);
}


void HideGameOver(Game game)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	ZRect			rect;
	
	
	game->showGameOver = FALSE;
	rect = gGameOverRects[zRectGameOverPane];
	ZCenterRectToRect(&rect, &gRects[zRectWindow], zCenterBoth);
	ZWindowInvalidate(game->gameWindow, &rect);
}


void ShowPassText(Game game)
{
    /*
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	game->showPassText = TRUE;
	UpdatePassText(game);
	ZWindowValidate(game->gameWindow, &gRects[zRectPassTextPane]);
    */
}


void HidePassText(Game game)
{
    /*
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	
	game->showPassText = FALSE;
	ZWindowInvalidate(game->gameWindow, &gRects[zRectPassTextPane]);
    */
}


/*******************************************************************************
	SCORES WINDOW ROUTINES
*******************************************************************************/
static ZBool ScoreButtonFunc(ZRolloverButton button, int16 state, void* userData)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if ( state == zRolloverButtonClicked )
    {
        Game game = (Game)userData;

		if(!ZRolloverButtonIsEnabled(game->scoreButton))
			return TRUE;

        ScoreButtonWork(game);

        gGAcc->SetFocus(IDC_SCORE_BUTTON, false, 0);
    }
    return TRUE;
}


void ScoreButtonWork(Game game)
{
    if(game->pHistoryDialog->IsActive())
    {
        game->pHistoryDialog->BringWindowToTop();
    }
    else
        if(!game->pHistoryDialog->CreateHistoryDialog())
        {
            ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound);        
        }
}


/*******************************************************************************
	SHOW KIBITZER/JOINER WINDOW ROUTINES
*******************************************************************************/
static int16 FindJoinerKibitzerSeat(Game game, ZPoint* point)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16			i, seat = -1;
	
	
	for (i = 0; i < zSpadesNumPlayers && seat == -1; i++)
	{
		if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][0]]) ||
				ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, i)][1]]))
			seat = i;
	}
	
	return (seat);
}


static void HandleJoinerKibitzerClick(Game game, int16 seat, ZPoint* point)
{
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif
	int16				playerType = zGamePlayer;
	ZPlayerInfoType		playerInfo;
	int16				i;
	ZLListItem			listItem;
	ZRect				rect;


	if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, seat)][0]]))
	{
		if (game->playersToJoin[seat] != 0 && game->numKibitzers[seat] == 0)
			playerType = zGamePlayerJoiner;
		else if (game->numKibitzers[seat] > 0)
			playerType = zGamePlayerKibitzer;
	}
	else if (ZPointInRect(point, &gRects[gJoinerKibitzerRectIndex[LocalSeat(game, seat)][1]]))
	{
		if (game->playersToJoin[seat] != 0 && game->numKibitzers[seat] != 0)
			playerType = zGamePlayerJoiner;
	}
	
	if (playerType != zGamePlayer)
	{
		if (game->showPlayerWindow != NULL)
			ShowPlayerWindowDelete(game);
		
		/* Create player list. */
		if (playerType == zGamePlayerJoiner)
		{
			game->showPlayerCount = 1;
			if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), 1*sizeof(TCHAR))) == NULL)
				goto OutOfMemoryExit;
			ZCRoomGetPlayerInfo(game->playersToJoin[seat], &playerInfo);
			game->showPlayerList[0] = (TCHAR*) ZCalloc(1, lstrlen(playerInfo.userName) + 1*sizeof(TCHAR));
			lstrcpy(game->showPlayerList[0], playerInfo.userName);
		}
		else
		{
			game->showPlayerCount = game->numKibitzers[seat];
			if ((game->showPlayerList = (TCHAR**) ZCalloc(sizeof(TCHAR*), game->numKibitzers[seat])) == NULL)
				goto OutOfMemoryExit;
			for (i = 0; i < game->showPlayerCount; i++)
			{
				if ((listItem = ZLListGetNth(game->kibitzers[seat], i, zLListAnyType)) != NULL)
				{
					ZCRoomGetPlayerInfo((ZUserID) ZLListGetData(listItem, NULL), &playerInfo);
					game->showPlayerList[i] = (TCHAR*) ZCalloc(1, (lstrlen(playerInfo.userName) + 1)*sizeof(TCHAR));
					lstrcpy(game->showPlayerList[i], playerInfo.userName);
				}
			}
		}

		/* Create the window. */
		if ((game->showPlayerWindow = ZWindowNew()) == NULL)
			goto OutOfMemoryExit;
		ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight * game->showPlayerCount + 4);
		ZRectOffset(&rect, point->x, point->y);
		if (rect.right > gRects[zRectWindow].right)
			ZRectOffset(&rect, gRects[zRectWindow].right - rect.right, 0);
		if (rect.left < 0)
			ZRectOffset(&rect, -rect.left, 0);
		if (rect.bottom > gRects[zRectWindow].bottom)
			ZRectOffset(&rect, 0, gRects[zRectWindow].bottom - rect.bottom);
		if (rect.top < 0)
			ZRectOffset(&rect, -rect.top, 0);
		if (ZWindowInit(game->showPlayerWindow, &rect,
				zWindowPlainType, game->gameWindow, NULL, TRUE, FALSE, FALSE,
				ShowPlayerWindowFunc, zWantAllMessages, game) != zErrNone)
			goto OutOfMemoryExit;
		ZWindowTrackCursor(game->showPlayerWindow, ShowPlayerWindowFunc, game);
	}

	goto Exit;

OutOfMemoryExit:
	ZShellGameShell()->GameCannotContinue( game );
	
Exit:
	
	return;
}


static ZBool ShowPlayerWindowFunc(ZWindow window, ZMessage* message)
{
	Game		game = I(message->userData);
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(game->showPlayerWindow);
			ZRectErase(game->showPlayerWindow, &message->drawRect);
			ZEndDrawing(game->showPlayerWindow);
			ShowPlayerWindowDraw(game);
			msgHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
		case zMessageWindowButtonUp:
			ZWindowHide(game->showPlayerWindow);
			ZPostMessage(game->showPlayerWindow, ShowPlayerWindowFunc, zMessageWindowClose,
					NULL, NULL, 0, NULL, 0, game);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			ShowPlayerWindowDelete(game);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void ShowPlayerWindowDraw(Game game)
{
	int16			i;
	ZRect			rect;


	ZBeginDrawing(game->showPlayerWindow);

	ZSetFont(game->showPlayerWindow, (ZFont) ZGetStockObject(zObjectFontApp9Normal));
	
	ZSetRect(&rect, 0, 0, zShowPlayerWindowWidth, zShowPlayerLineHeight);
	ZRectOffset(&rect, 0, 2);
	ZRectInset(&rect, 4, 0);
	for (i = 0; i < game->showPlayerCount; i++)
	{
		ZDrawText(game->showPlayerWindow, &rect, zTextJustifyLeft, game->showPlayerList[i]);
		ZRectOffset(&rect, 0, zShowPlayerLineHeight);
	}
	
	ZEndDrawing(game->showPlayerWindow);
}


static void ShowPlayerWindowDelete(Game game)
{
	int16			i;
	
	
	if (game->showPlayerList != NULL)
	{
		for (i = 0; i < game->showPlayerCount; i++)
			ZFree(game->showPlayerList[i]);
		ZFree(game->showPlayerList);
		game->showPlayerList = NULL;
	}
	
	if (game->showPlayerWindow != NULL)
	{
		ZWindowDelete(game->showPlayerWindow);
		game->showPlayerWindow = NULL;
	}
}


static BOOL ZEqualRect( ZRect *a, ZRect *b )
{
    return ( a->left   == b->left ) &&
           ( a->right  == b->right ) &&
           ( a->top    == b->top ) &&
           ( a->bottom == b->bottom );
}

/*
	Subtracts the intersecting rectangle of src and sub from src.
	
	If the result is not a rectangle, then it creates a rectangle that
	would be created on the opposite diagonal corner.
*/
static void ZRectSubtract(ZRect* src, ZRect* sub)
{
	ZRect		sect;
	
	
	if (ZRectIntersection(src, sub, &sect))
	{
        // if the intersecting rectangle equals the 
        // source rectangle, then the subtraction should
        // yield an empty rectangle.
        if ( ZEqualRect( src, &sect ) )
        {
            ZSetRect( src, 0, 0, 0, 0 );
            return;
        }

		if (sect.left > src->left)
			src->right = sect.left;
		if (sect.right < src->right)
			src->left = sect.right;
		if (sect.top > src->top)
			src->bottom = sect.top;
		if (sect.bottom < src->bottom)
			src->top = sect.bottom;
	}
}



void ClosingState(ZClose * pClose,int32 closeEvent,int16 seat)
{

	int i,j;	
	int32 eventAdd,eventRemove,eventMask,val;


	if (!pClose)
	{
		ASSERT(pClose);
		return;
	}

#ifdef DEBUG
	DebugPrint("BEGIN ClosingState event=0x%x seat=%d\r\n",closeEvent,seat);

	
	val = pClose->state;
	DebugPrint("Before \t ");
	for (j=31;j>=0;j--)
	{
		if (!((j+1) % 4))
		{
			DebugPrint(" ");
		}
		DebugPrint("%d",(val >>j) & 0x1);
	}
	DebugPrint("\r\n");
#endif //DEBUG

	eventAdd = closeEvent;
	eventRemove = 0;
	//manage state changes
	switch (closeEvent)
	{
	case zCloseEventCloseRated:
        break;
	case zCloseEventCloseUnRated:
		break;
	case zCloseEventCloseForfeit:
		break;
	case zCloseEventCloseAbort:
		eventAdd=0;
		eventRemove = zCloseEventCloseRated | zCloseEventCloseForfeit | zCloseEventCloseUnRated;
		break;
	case zCloseEventBootStart:
		eventAdd=0;//ignore these changes cause user sees dialog
		break;
	case zCloseEventBootYes:
		//players voted to boot another player
		//so if this player closing he won't necessarily forfeit game
		eventAdd = zCloseEventForfeit;
		eventRemove = zCloseEventRatingStart;
		break;
	case zCloseEventBootNo:			
		eventAdd=0;;
		break;
	case zCloseEventWaitStart:
		eventAdd=zCloseEventWaitStart;
		break;
	case zCloseEventWaitYes:
		eventAdd=0;
        eventRemove=zCloseEventWaitStart;
		break;
	case zCloseEventWaitNo:	
		//players decided not too wait so player will be kicked
		//so if this player closing he won't necessarily lose
		eventAdd = zCloseEventForfeit;
		eventRemove = zCloseEventRatingStart | zCloseEventWaitStart;
		break;
	case zCloseEventMoveTimeoutMe:
		eventAdd =0;
		break;
	case zCloseEventMoveTimeoutOther:
		//while timeout other can result in forfeit
		//it can also be reversed unlike player boot
		break;
	case zCloseEventMoveTimeoutPlayed:
		//can forfeit up until the first play of a game, multiple hands
		//so keep track of anyone having played 
		eventAdd = zCloseEventPlayed;

		//if someone has played timeouts no longer valid
		eventRemove = zCloseEventMoveTimeoutOther | zCloseEventMoveTimeoutMe ;
		break;
	case zCloseEventBotDetected:
		eventAdd = zCloseEventForfeit;
		eventRemove = zCloseEventRatingStart;
		break;
	case zCloseEventPlayerReplaced:
		eventAdd=0;
		break;
	
	case zCloseEventGameStart:
		eventAdd=0;
		if (pClose->state & zCloseEventRatingStart)
			eventAdd = zCloseEventRatingStart;
		ZeroMemory(&pClose->state,sizeof(DWORD));
		break;
		
	case zCloseEventGameEnd:
		eventAdd = zCloseEventForfeit;
		break;
	case zCloseEventRatingStart:
		break;
	case zCloseEventAbandon:
		eventRemove = zCloseEventRatingStart;
		break;

	};

	pClose->state |= eventAdd;

	eventMask= pClose->state & eventRemove;
	pClose->state ^= eventMask;

#ifdef DEBUG
	val = pClose->state;
	DebugPrint("After \t ");
	for (j=31;j>=0;j--)
	{
		if (!((j+1) % 4))
		{
			DebugPrint(" ");
		}
		DebugPrint("%d",(val >>j) & 0x1);
	}
	DebugPrint("\r\n");

	DebugPrint("END ClosingState rated=%d\r\n\r\n",pClose->state & zCloseEventRatingStart);
#endif //DEBUG
};


ZBool ClosingRatedGame(ZClose * pClose)
{
	if (pClose->state & zCloseEventPlayed)
	{
		if ((pClose->state & zCloseEventRatingStart))
		{
			return TRUE;
		}
	}

	return FALSE;
}

ZBool ClosingWillForfeit(ZClose * pClose)
{
	//if some other player has timed out
	//you won't get forfeit
	if (pClose->state & zCloseEventMoveTimeoutOther)
	{
		return FALSE;
	}

    if (pClose->state & zCloseEventWaitStart)
    {
        return FALSE;
    }

	//if no one else has forfeited then when we
	//close game will be forfeited by me
	if (pClose->state & zCloseEventForfeit)
	{
		return FALSE;
	};


	return TRUE;
	
};

//should add close state message handler
//so code for close state is not interleaved with other code
//ZBool		ProcessCloseStateMessage(ZCGame game, uint32 messageType, void* message,int32 messageLen)
ZBool ClosingDisplayChange(ZClose *pClose,ZRect* rect,ZWindow parentWindow)
{
#ifndef SPADES_SIMPLE_UE
#ifdef ZONECLI_DLL
	GameGlobals pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	TCHAR szBuf[1024];
    int idMessage = -1;
	
	//when player initiated close game was unrated
	//so player wasn't informed of forfeiting game
	if (pClose->state & zCloseEventCloseUnRated)
	{
		//ratings might have started because of new game 
		//so need to inform player if they might forfeit
		if (pClose->state & zCloseEventPlayed)
		{
			if (pClose->state & zCloseEventRatingStart)
			{
				//but another player might have forfeited in the meantime
				if ((pClose->state & zCloseEventForfeit) || (pClose->state & zCloseEventMoveTimeoutOther) || (pClose->state & zCloseEventWaitStart))
				{
				
				}
				else
				{
                    idMessage = IDS_CLOSINGWOULDHAVE;
				};

			}
		}
		
	}


	//check that game state hasn't changed  relative to outstanding close dialog
	if (pClose->state & zCloseEventCloseForfeit)
	{
		//if still rated
		if ((pClose->state & zCloseEventRatingStart))
		{
			if (pClose->state & zCloseEventForfeit) 
			{
                idMessage = IDS_GAMEENDNOPENALTY;
			}
            else if (pClose->state & zCloseEventMoveTimeoutOther) 
            {

            }
            else if (pClose->state & zCloseEventWaitStart)
            {
                idMessage = IDS_GAMEENDPLAYERLEFT;
            }

		}
		else
		{
            idMessage = IDS_GAMENOWUNRATED;
		}
		
	
	}
	
	//player thought they were going to exit without forfeit and possibly a win
	if (pClose->state & zCloseEventCloseRated)
	{
		//if still rated
		if ((pClose->state & zCloseEventRatingStart))
		{
		
			//same or another player might have forfeited or timed out in the meantime
			if ((pClose->state & zCloseEventForfeit) || (pClose->state & zCloseEventMoveTimeoutOther) || (pClose->state & zCloseEventWaitStart))
			{
				
			}
			else
			{
                idMessage = IDS_CLOSINGWOULDHAVE;
			}
		}

	}
	
	if ( idMessage != -1 )
	{
        TCHAR szMessage[1024];
        ZShellResourceManager()->LoadString( idMessage, szMessage, NUMELEMENTS(szMessage) );
		ZDisplayText(szMessage, rect, parentWindow);
		return TRUE;
	}
	else
	{
		return FALSE;
	};
#endif
    return FALSE;
			
};


///////////////////////////////////////////////////
//
// Accessibility interface
//

BOOL InitAccessibility(Game game, IGameGame *pIGG)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	GACCITEM listSpadesAccItems[zNumberAccItems];
    ZRect rect;
    ZRolloverButton but = NULL;
    long nArrows;
    bool fRTL = (ZIsLayoutRTL() ? true : false);
    int dir = (fRTL ? -1 : 1);

	for(int i = 0; i < zNumberAccItems; i++)
	{
		CopyACC(listSpadesAccItems[i], ZACCESS_DefaultACCITEM);
        listSpadesAccItems[i].fGraphical = true;
        listSpadesAccItems[i].fEnabled = false;
        listSpadesAccItems[i].pvCookie = (void *) zAccRectButton;
        nArrows = ZACCESS_InvalidItem;

		switch(i)
		{
            case zAccShowCards:
                listSpadesAccItems[i].wID = IDC_SHOW_CARDS_BUTTON;
                nArrows = zAccDoubleNil;
                break;

            case zAccDoubleNil:
                listSpadesAccItems[i].wID = IDC_DOUBLE_NIL_BUTTON;
                nArrows = zAccShowCards;
                break;

		    case zAccScore:
			    listSpadesAccItems[i].wID = IDC_SCORE_BUTTON;
//                nArrows = zAccAutoPlay;
                but = game->scoreButton;
			    break;

		    case zAccAutoPlay:
			    listSpadesAccItems[i].wID = IDC_AUTOPLAY_BUTTON;
//                nArrows = zAccStop;
                but = game->autoPlayButton;
			    break;

		    case zAccStop:
			    listSpadesAccItems[i].wID = IDC_STOP_BUTTON;
//                nArrows = zAccScore;
                but = game->autoPlayButton;
			    break;

		    case zAccPlay:
			    listSpadesAccItems[i].wID = IDC_PLAY_BUTTON;
//                nArrows = zAccLastTrick;
                but = game->playButton;
			    break;

		    case zAccLastTrick:
			    listSpadesAccItems[i].wID = IDC_LAST_TRICK_BUTTON;
//                nArrows = zAccDone;
                but = game->lastTrickButton;
			    break;

		    case zAccDone:
			    listSpadesAccItems[i].wID = IDC_DONE_BUTTON;
//                nArrows = zAccPlay;
                but = game->lastTrickButton;
			    break;

            case zAccHand:
                listSpadesAccItems[i].wID = IDC_HAND;
                listSpadesAccItems[i].eAccelBehavior = ZACCESS_FocusGroup;
                listSpadesAccItems[i].nArrowDown = i + 1;
                listSpadesAccItems[i].nArrowRight = i + 1;
                listSpadesAccItems[i].nArrowUp = ZACCESS_ArrowNone;
                listSpadesAccItems[i].nArrowLeft = ZACCESS_ArrowNone;
                listSpadesAccItems[i].pvCookie = (void *) zAccRectCard;
                break;

            // cards / buttons besides the first
		    default:
                if(i >= zAccScore)
                {
                    listSpadesAccItems[i].fTabstop = false;
                    listSpadesAccItems[i].nArrowUp = i - 1;
                    listSpadesAccItems[i].nArrowLeft = i - 1;
                    if(i < zAccHand + 12)
                    {
                        listSpadesAccItems[i].nArrowDown = i + 1;
                        listSpadesAccItems[i].nArrowRight = i + 1;
                    }
                    else
                    {
                        listSpadesAccItems[i].nArrowDown = ZACCESS_ArrowNone;
                        listSpadesAccItems[i].nArrowRight = ZACCESS_ArrowNone;
                    }
                    listSpadesAccItems[i].pvCookie = (void *) zAccRectCard;
                }
                else
                {
                    listSpadesAccItems[i].nArrowLeft = i - dir;
                    listSpadesAccItems[i].nArrowUp = i - dir;
                    listSpadesAccItems[i].nArrowRight = i + dir;
                    listSpadesAccItems[i].nArrowDown = i + dir;

                    if(i != zAccFirstBid)
                        listSpadesAccItems[i].fTabstop = false;

                    if(i == zAccFirstBid + (fRTL ? 13 : 0))
                    {
                        listSpadesAccItems[i].nArrowLeft = ZACCESS_ArrowNone;
                        listSpadesAccItems[i].nArrowUp = ZACCESS_ArrowNone;
                    }

                    if(i == zAccFirstBid + (fRTL ? 0 : 13))
                    {
                        listSpadesAccItems[i].nArrowRight = ZACCESS_ArrowNone;
                        listSpadesAccItems[i].nArrowDown = ZACCESS_ArrowNone;
                    }
                }
			    break;
		}

        if(nArrows != ZACCESS_InvalidItem)
        {
            listSpadesAccItems[i].nArrowUp = nArrows;
            listSpadesAccItems[i].nArrowDown = nArrows;
            listSpadesAccItems[i].nArrowLeft = nArrows;
            listSpadesAccItems[i].nArrowRight = nArrows;
        }

        if(but)
        {
            ZRolloverButtonGetRect(but, &rect);
            listSpadesAccItems[i].rc.left = rect.left - 7;
            listSpadesAccItems[i].rc.top = rect.top - 4;
            listSpadesAccItems[i].rc.right = rect.right + 1;
            listSpadesAccItems[i].rc.bottom = rect.bottom + 1;
        }
	}

	CComQIPtr<IGraphicallyAccControl> pIGAC = pIGG;
	if(!pIGAC)
        return FALSE;

	gGAcc->InitAccG(pIGAC, ZWindowGetHWND(game->gameWindow), 0, game);

	// push the list of items to be tab ordered
	gGAcc->PushItemlistG(listSpadesAccItems, zNumberAccItems, zAccHand, true, ghAccelDone);

	return TRUE;
}


// accessibility callback functions
DWORD CGameGameSpades::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
    Game game = (Game) pvCookie;

    if(nIndex != ZACCESS_InvalidItem)
    {
        HWND hWnd = ZWindowGetHWND(((Game) pvCookie)->gameWindow);
        SetFocus(hWnd);

        int16 card = nIndex - zAccHand;
        if(nIndex >= zAccHand && nIndex < zAccHand + 13 && !game->cardsSelected[card] && (rgfContext & ZACCESS_ContextKeyboard))  // need to select the card
        {
            if(game->gameState == zSpadesGameStatePlay)
			    UnselectAllCards(game);
		    game->cardsSelected[card] = TRUE;
	        UpdateHand(game);
        }
    }

	return 0;
}


DWORD CGameGameSpades::Select(long nIndex, DWORD rgfContext, void* pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    Game game = (Game) pvCookie;

    if(nIndex < zAccHand || nIndex >= zAccHand + 13)
        return Activate(nIndex, rgfContext, pvCookie);

    if(game->gameState != zSpadesGameStatePlay)
        return 0;

    int16 card = nIndex - zAccHand;

	if (game->cardsSelected[card])
	{
		game->cardsSelected[card] = FALSE;
	}
	else
	{
		if (game->gameState == zSpadesGameStatePlay)
			UnselectAllCards(game);
		game->cardsSelected[card] = TRUE;
	}

	game->lastClickedCard = zCardNone;

	UpdateHand(game);

	return 0;
}


// Activate gets called when an Alt-<accelerator> has been pressed.
DWORD CGameGameSpades::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

	Game game = (Game) pvCookie;
    long wID = gGAcc->GetItemID(nIndex);

    // cards
    if(nIndex >= zAccHand && nIndex < zAccHand + 13)
    {
		if (game->gameState == zSpadesGameStatePlay &&
			game->playerToPlay == game->seat &&
			game->autoPlay == FALSE &&
			game->animatingTrickWinner == FALSE &&
			game->lastTrickShowing == FALSE)
		{
			UnselectAllCards(game);
			PlayACard(game, nIndex - zAccHand);
		}

        return 0;
    }

    // small bid buttons
    if(nIndex >= zAccFirstBid && nIndex < zAccFirstBid + 14)
    {
        ASSERT(game->pBiddingDialog->IsVisible());
        ASSERT(game->pBiddingDialog->GetState() != zBiddingStateOpen);
        CBiddingDialog::BidButtonFunc(game->pBiddingDialog->m_pSmallButtons[ZIsLayoutRTL() ? 13 - (nIndex - zAccFirstBid) : nIndex - zAccFirstBid],
            zRolloverButtonClicked, game->pBiddingDialog);

        return 0;
    }

    // big buttons with accelerators
    switch(wID)
    {
	    case IDC_SHOW_CARDS_BUTTON:
            ASSERT(game->pBiddingDialog->IsVisible());
            ASSERT(game->pBiddingDialog->GetState() == zBiddingStateOpen);
		    CBiddingDialog::ShowCardsButtonFunc(NULL, zRolloverButtonClicked, game->pBiddingDialog);
		    break;

	    case IDC_DOUBLE_NIL_BUTTON:
            ASSERT(game->pBiddingDialog->IsVisible());
            ASSERT(game->pBiddingDialog->GetState() == zBiddingStateOpen);
		    CBiddingDialog::DoubleNilButtonFunc(NULL, zRolloverButtonClicked, game->pBiddingDialog);
		    break;

        case IDC_SCORE_BUTTON:
	        ScoreButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_AUTOPLAY_BUTTON:
	        ASSERT(!game->autoPlay);
		    AutoPlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_STOP_BUTTON:
	        ASSERT(game->autoPlay);
		    AutoPlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_PLAY_BUTTON:
	        PlayButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_LAST_TRICK_BUTTON:
	        ASSERT(!game->lastTrickShowing);
		    LastTrickButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_DONE_BUTTON:
	        ASSERT(game->lastTrickShowing);
		    LastTrickButtonFunc(NULL, zRolloverButtonClicked, pvCookie);
	        break;

        case IDC_CLOSE_BOX:
		    // Simulate timeout.
    	    if((game->gameState == zSpadesGameStateEndHand && game->showHandScore) ||
                (game->gameState == zSpadesGameStateEndGame && game->showGameOver))
            {
                gGAcc->SetFocus(zAccShowCards, true, 0);
			    GameTimerFunc(game->timer, game);
            }
            break;

        default:
            ASSERT(!"Should never hit this case.  Something is wrong again.");
            break;
    }

	return 0;
}


DWORD CGameGameSpades::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
	return 0;
}


void CGameGameSpades::DrawFocus(RECT *prc, long nIndex, void *pvCookie)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    Game game = (Game) pvCookie;
    ZRect rect;

    if(!IsRectEmpty(&game->rcFocus))
    {
        WRectToZRect(&rect, &game->rcFocus);
        ZWindowInvalidate(game->gameWindow, &rect);
    }

    if(prc)
    {
        CopyRect(&game->rcFocus, prc);
        game->eFocusType = (DWORD) gGAcc->GetItemCookie(nIndex);
        game->iFocus = nIndex;
    }
    else
    {
        SetRectEmpty(&game->rcFocus);
        game->iFocus = -1;
    }

    if(!IsRectEmpty(&game->rcFocus))
    {
        WRectToZRect(&rect, &game->rcFocus);
        ZWindowInvalidate(game->gameWindow, &rect);
    }
}


void CGameGameSpades::DrawDragOrig(RECT *prc, long nIndex, void *pvCookie)
{
}


// acc utils

void EnableAutoplayAcc(Game game, bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(!fEnable)
    {
        gGAcc->SetItemEnabled(false, IDC_AUTOPLAY_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_STOP_BUTTON, false, 0);
    }
    else
    {
        gGAcc->SetItemEnabled(game->autoPlay ? false : true, IDC_AUTOPLAY_BUTTON, false, 0);
        gGAcc->SetItemEnabled(game->autoPlay ? true : false, IDC_STOP_BUTTON, false, 0);
    }
}


void EnableLastTrickAcc(Game game, bool fEnable)
{
#ifdef ZONECLI_DLL
	GameGlobals			pGameGlobals = (GameGlobals)ZGetGameGlobalPointer();
#endif

    if(!fEnable)
    {
        gGAcc->SetItemEnabled(false, IDC_LAST_TRICK_BUTTON, false, 0);
        gGAcc->SetItemEnabled(false, IDC_DONE_BUTTON, false, 0);
    }
    else
    {
        gGAcc->SetItemEnabled(game->lastTrickShowing ? false : true, IDC_LAST_TRICK_BUTTON, false, 0);
        gGAcc->SetItemEnabled(game->lastTrickShowing ? true : false, IDC_DONE_BUTTON, false, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\launch\launchm.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "launchmres.h"
#include "opname.h"
#include "zonedef.h"
#include "zonestring.h"

#include "..\..\zclient\zclient.h"


/*
HRESULT ReadRegistry(LPTSTR szKey,LPTSTR szValueKey, LPTSTR szResult,DWORD cbResult)
{
    HKEY hkey;
    DWORD type=REG_SZ;
    DWORD cb = cbResult;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKey,  
                0,   KEY_READ, &hkey))
    {
        return E_FAIL;
    };

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,szValueKey,0, &type,         (LPBYTE)szResult,        &cb))
    {
        RegCloseKey(hkey);
        return E_FAIL;
    }

    RegCloseKey(hkey);
    return S_OK;
};
*/

class LaunchGame
{
protected:

	void MsgFailed(UINT id)
	{
		TCHAR text[1024];
        text[0] = _T('\0');
		LoadString(NULL, id, text, NUMELEMENTS(text) - 1);

		TCHAR caption[1024];
        caption[0] = _T('\0');
		LoadString(NULL, IDS_CAPTION, caption, NUMELEMENTS(caption) - 1);

        TCHAR name[1024];
        lstrcpy(name, _T("This game"));
        LoadString(NULL, IDS_GAME, name, NUMELEMENTS(name) - 1);

        TCHAR szCaption[1024];
        lstrcpy(szCaption, name);
        ZoneFormatMessage(caption, szCaption, NUMELEMENTS(szCaption), name);

        TCHAR szText[1024];
        lstrcpy(szText, text);
        ZoneFormatMessage(text, szText, NUMELEMENTS(szText), name);

		MessageBox(NULL, szText, szCaption, MB_OK | MB_ICONEXCLAMATION);
	}


/*	virtual HRESULT GetBaseRegistryKey(LPTSTR szKey,DWORD cb)
	{
		TCHAR szRegistry[MAX_PATH];
		if(!LoadString(NULL,IDS_KEY,szRegistry,NUMELEMENTS(szRegistry)-1))
		{
			return E_FAIL;
		}

        if((DWORD)lstrlen(szRegistry) >= cb)
            return E_FAIL;

		lstrcpy(szKey, szRegistry);

		return S_OK;
	};
*/
public:

	// Launches Zone universal client with correct command line for game
	//void __cdecl main ()
	int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd )
	{
	    CLSID clsid;
	    WCHAR *progid = L"Zone.ClientM";
//	    TCHAR szKey[MAX_PATH];
	    TCHAR szValue[1024];
	    TCHAR szCmd[1024];
	    TCHAR szFormat[1024];
        USES_CONVERSION;

		CComBSTR bCommand=op_Launch;
	    CComBSTR bResult;
	    CComBSTR bArg1;
		CComBSTR bArg2="";//"AGEX,6.01.418.1";
	    


	    IUnknown *pUnk=NULL;
		IZoneProxy *pClient=NULL;
		

	    LONG lResult;
	    
		HRESULT hr = CoInitialize(NULL);
		if (FAILED(hr))
		{
            ASSERT(!"CoInitialize Failed");
			MsgFailed(IDS_FAILED);
			goto exit;
		}

//		hr = GetBaseRegistryKey( szKey,NUMELEMENTS(szKey));
//		if (FAILED(hr))
//		{
//			MsgFailed(IDS_FAILED);
//		    	goto exit;
//		}

		//Emulate from Web page
		//RaiseLobby('zaeep_xx_x05','game=<agex>dll=<ZoneCore.dll,ZoneClient.dll>datafile=<SpadesRes.dll,CommonRes.dll>','157.55.20.41:28832','Gladius (Rookie)','AGEX')">
	    if (lstrcmpA(lpCmdLine,"")==0)
	    {
		    if(!LoadString(NULL, IDS_SERVER, szValue, NUMELEMENTS(szValue) - 1))
		    {
                ASSERT(!"LoadString IDS_SERVER Failed");
			    MsgFailed(IDS_FAILED);
	    	    goto exit;
		    }
	    }
	    else
	    {
	        //bArg1= "data=[ID=[zaeep_xx_x05]data=[game=<agex>dll=<ZoneCore.dll,ZoneClient.dll>datafile=<SpadesRes.dll,CommonRes.dll>]server=[157.55.20.41:28832]name=[Gladius (Rookie)]family=[Age of Empires Expansion: Rise of Rome]]";
	        if(lstrlenA(lpCmdLine) >= NUMELEMENTS(szValue))
	        {
                ASSERT(!"Command line too long");
            	MsgFailed(IDS_FAILED);
    	    	goto exit;
	        }
	        CopyA2W(szValue, lpCmdLine);
	    }

	    if (!LoadString(NULL,IDS_CMD,szFormat,NUMELEMENTS(szFormat)-1))
		{
            ASSERT(!"LoadString IDS_CMD Failed");
			MsgFailed(IDS_FAILED);
	    	goto exit;
	    }

        TCHAR szModule[MAX_PATH+1];

        GetModuleFileName(hInstance,szModule,MAX_PATH);
        
        //Format: data=[ID=[zshvl_so_x00]data=[game=<Spades>dll=<ZCorem.dll,cmnClim.dll>datafile=<ShvlRes.dll,CmnResm.dll>]server=[%1:28803]name=[Spades]family=[Spades]icw=[%2 %3]]

	    if (!ZoneFormatMessage(szFormat, szCmd,NUMELEMENTS(szCmd),szValue,szModule,A2T(lpCmdLine)))
	    {
            ASSERT(!"ZoneFormatMessage Failed");
	    	MsgFailed(IDS_FAILED);
	    	goto exit;
	    };

		//checkerszm "data=[ID=[zchkr_so_x00]data=[game=<Checkers>dll=<ZoneCorem.dll,ZoneClientm.dll>datafile=<CheckersRes.dll,CommonResm.dll>]server=[localhost:28805]name=[Lombardo]family=[Checkers]]"
	    bArg1 = szCmd;
	    
	    hr = CLSIDFromProgID(progid,&clsid);
		if (FAILED(hr))
		{
            ASSERT(!"CLSIDFromProgID Failed");
			MsgFailed(IDS_FAILED);
		    	goto exit;
		}

		hr = CoCreateInstance(clsid,NULL,CLSCTX_LOCAL_SERVER,IID_IUnknown,(void**)&pUnk);
		if (FAILED(hr))
		{
            ASSERT(!"CoCreateInstance Failed");
            pUnk = NULL;
			MsgFailed(IDS_FAILED);
		    	goto exit;
		}

		hr = pUnk->QueryInterface( IID_IZoneProxy, (void**) &pClient );
		if (FAILED(hr))
		{
            ASSERT(!"QueryInterface Failed");
            pClient = NULL;
			MsgFailed(IDS_FAILED);
		    	goto exit;
		}

	    hr = pClient->Command( bCommand, bArg1, bArg2, &bResult, &lResult );
		if (FAILED(hr))
		{
            ASSERT(!"Command Failed");
            MsgFailed(IDS_FAILED);
            goto exit;
		}

	exit:        
	    if (pClient)
	        pClient->Release();
	    if (pUnk)
	        pUnk->Release();
		CoUninitialize();
	return 0;
	}

	
};


extern "C" int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd )
{
    LaunchGame lg;

    return lg.WinMain(hInstance,hPrevInstance,lpCmdLine,nShowCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\ocdll\ocmanage.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ocmanage.h

Abstract:

    Public header file for Optional Component Manager.

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// Define type for optional component setup dll interface entry point.
// Note the strings are declared with VOID typing since we don't
// know in advance what the character width is.
//
typedef
DWORD
(*POCSETUPPROC) (
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Define interface function codes.
//
#define OC_PREINITIALIZE                0x00000000
#define OC_INIT_COMPONENT               0x00000001
#define OC_SET_LANGUAGE                 0x00000002
#define OC_QUERY_IMAGE                  0x00000003
#define OC_REQUEST_PAGES                0x00000004
#define OC_QUERY_CHANGE_SEL_STATE       0x00000005
#define OC_CALC_DISK_SPACE              0x00000006
#define OC_QUEUE_FILE_OPS               0x00000007
#define OC_NOTIFICATION_FROM_QUEUE      0x00000008
#define OC_QUERY_STEP_COUNT             0x00000009
#define OC_COMPLETE_INSTALLATION        0x0000000a
#define OC_CLEANUP                      0x0000000b
#define OC_QUERY_STATE                  0x0000000c
#define OC_NEED_MEDIA                   0x0000000d
#define OC_ABOUT_TO_COMMIT_QUEUE        0x0000000e
#define OC_QUERY_SKIP_PAGE              0x0000000f
#define OC_WIZARD_CREATED               0x00000010
#define OC_FILE_BUSY	                0x00000011
#define OC_EXTRA_ROUTINES               0x00000012
#define OC_QUERY_IMAGE_EX               0x00000013

#define OC_QUERY_ERROR                  0x000000FF  // dead

//#define OC_OSSETUP_GET_WIZARD_TITLE     0x00000400
//#define OC_OSSETUP_GET_COMPUTER_NAME    0x00000401
//#define OC_OSSETUP_GET_SERVER_TYPE      0x00000402

#define OC_PRIVATE_BASE                 0x00010000

//
// Define OC Manager directory IDs, available in per-component INFs.
//
#define DIRID_OCM_MASTERINF             987654321       // full path
#define DIRID_OCM_PLATFORM              987654322       // alpha, i386, etc
#define DIRID_OCM_PLATFORM_ALTERNATE    987654323       // alpha, x86, etc
#define DIRID_OCM_COMPONENT             987654324       // component shortname


//
// Define structure used as a table of helper/callback entry points
// into the OC Manager, and the associated function prototypes.
//
typedef
VOID
(CALLBACK *PTICKGAUGE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Text
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Text
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Name,
    IN PVOID  Data,
    IN UINT   Size,
    IN UINT   Type
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR Name,
    OUT    PVOID  Data,         OPTIONAL
    IN OUT PUINT  Size,
    OUT    PUINT  Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR Name,
    OUT    PVOID   Data,         OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type
    );

typedef
UINT
(CALLBACK *PSETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext,
    IN DWORD SetupMode
    );

typedef
UINT
(CALLBACK *PGETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR SubcomponentId,
    IN UINT   StateType
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR SubcomponentId,
    IN UINT    StateType
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR SubcomponentId,
    IN     UINT   Function,
    IN     UINT   Param1,
    IN OUT PVOID  Param2,
    OUT    PUINT  Result
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2,
    OUT    PUINT   Result
    );

typedef
BOOL
(CALLBACK *PCONFIRMCANCEL_ROUTINE) (
    IN HWND ParentWindow
    );

typedef
HWND
(CALLBACK *PQUERYWIZARDDIALOGHANDLE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PSETREBOOT_ROUTINE) (
    IN PVOID OcManagerContext,
    IN BOOL  Reserved
    );

typedef
HINF
(CALLBACK *PGETINFHANDLE_ROUTINE) (
    IN UINT  InfIndex,
    IN PVOID OcManagerContext
    );

#define INFINDEX_UNATTENDED     1

typedef
BOOL
(__cdecl *PREPORTEXTERNALERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR ComponentId,
    IN LPCSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR  MessageId,
    IN DWORD  Flags,
    ...
    );

typedef
BOOL
(__cdecl *PREPORTEXTERNALERROR_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR ComponentId,
    IN LPCWSTR SubcomponentId,  OPTIONAL
    IN DWORD_PTR   MessageId,
    IN DWORD   Flags,
    ...
    );

typedef
VOID 
(WINAPI *OCH_SHOWHIDEWIZARDPAGE)(
    IN PVOID   OcManagerContext,
    IN BOOL bShow
    );

#define ERRFLG_SYSTEM_MESSAGE   0x00000001
#define ERRFLG_IGNORE_INSERTS   0x00000002
#define ERRFLG_PREFORMATTED     0x00000004

typedef struct _OCMANAGER_ROUTINESA {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEA SetProgressText;
    PSETPRIVATEDATA_ROUTINEA SetPrivateData;
    PGETPRIVATEDATA_ROUTINEA GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEA QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEA CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEA ReportExternalError;
    OCH_SHOWHIDEWIZARDPAGE ShowHideWizardPage;
} OCMANAGER_ROUTINESA, *POCMANAGER_ROUTINESA;

typedef struct _OCMANAGER_ROUTINESW {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEW SetProgressText;
    PSETPRIVATEDATA_ROUTINEW SetPrivateData;
    PGETPRIVATEDATA_ROUTINEW GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEW QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEW CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEW ReportExternalError;
    OCH_SHOWHIDEWIZARDPAGE ShowHideWizardPage;
} OCMANAGER_ROUTINESW, *POCMANAGER_ROUTINESW;

#ifdef UNICODE
typedef OCMANAGER_ROUTINESW OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESW POCMANAGER_ROUTINES;
#else
typedef OCMANAGER_ROUTINESA OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESA POCMANAGER_ROUTINES;
#endif

typedef
BOOL
(__cdecl *PLOGERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCSTR Msg,
    ...
    );

typedef
BOOL
(__cdecl *PLOGERROR_ROUTINEW) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCWSTR Msg,
    ...
    );

typedef struct _EXTRA_ROUTINESA {
    DWORD size;
    PLOGERROR_ROUTINEA LogError;
} EXTRA_ROUTINESA, *PEXTRA_ROUTINESA;

typedef struct _EXTRA_ROUTINESW {
    DWORD size;
    PLOGERROR_ROUTINEW LogError;
} EXTRA_ROUTINESW, *PEXTRA_ROUTINESW;

#ifdef UNICODE
typedef EXTRA_ROUTINESW EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESW PEXTRA_ROUTINES;
#else
typedef EXTRA_ROUTINESA EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESA PEXTRA_ROUTINES;
#endif


// for error handler

typedef enum {
    OcErrLevInfo    = 0x00000000,
    OcErrLevWarning = 0x01000000,
    OcErrLevError   = 0x02000000,
    OcErrLevFatal   = 0x03000000,
    OcErrLevMax     = 0x04000000,
    OcErrBatch      = 0x10000000,
    OcErrMask		= 0xFF000000
} OcErrorLevel;

//
// Flags.
//
#define OCFLAG_UNICODE  0x00000001
#define OCFLAG_ANSI     0x00000002

//
// master component flags
//
#define OCFLAG_NOWIZPAGES   0x00000001
#define OCFLAG_NOQUERYSKIP  0x00000002
#define OCFLAG_NOEXTRAFLAGS 0x00000004

//
// Selection state types (for QuerySelectionState and OC_QUERY_STATE).
//
#define OCSELSTATETYPE_ORIGINAL     0
#define OCSELSTATETYPE_CURRENT      1
#define OCSELSTATETYPE_FINAL        2

//
// Setup data structure. Passed within a SETUP_INIT_COMPONENT structure
// as OC_INIT_COMPONENT time.
//
typedef struct _SETUP_DATAA {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    CHAR SourcePath[MAX_PATH];
    CHAR UnattendFile[MAX_PATH];
} SETUP_DATAA, *PSETUP_DATAA;

typedef struct _SETUP_DATAW {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    WCHAR SourcePath[MAX_PATH];
    WCHAR UnattendFile[MAX_PATH];
} SETUP_DATAW, *PSETUP_DATAW;

#ifdef UNICODE
typedef SETUP_DATAW SETUP_DATA;
typedef PSETUP_DATAW PSETUP_DATA;
#else
typedef SETUP_DATAA SETUP_DATA;
typedef PSETUP_DATAA PSETUP_DATA;
#endif


//
// Values for SetupMode
//
#define SETUPMODE_UNKNOWN       (-1)
#define SETUPMODE_MINIMAL       0
#define SETUPMODE_TYPICAL       1
#define SETUPMODE_LAPTOP        2
#define SETUPMODE_CUSTOM        3

#define SETUPMODE_PRIVATE(x)    ((x) & SETUPMODE_PRIVATE_MASK)

//
// Predefined upgrade modes
//
#define SETUPMODE_UPGRADEONLY   0x20000100
#define SETUPMODE_ADDEXTRACOMPS 0x20000200

//
// Predefined mainteance modes
//
#define SETUPMODE_ADDREMOVE     0x10000100
#define SETUPMODE_REINSTALL     0x10000200
#define SETUPMODE_REMOVEALL     0x10000400

//
// Predefined fresh modes
//
#define SETUPMODE_FRESH         0x00000000
#define SETUPMODE_MAINTENANCE   0x10000000
#define SETUPMODE_UPGRADE       0x20000000

#define SETUPMODE_STANDARD_MASK 0x000000ff
#define SETUPMODE_PRIVATE_MASK  0xffffff00
//
// Flag for NeedMedia Callback, Ored in to
// Return code to allow NeedMedia to return
// FILEOP_ Return Codes
//
#define NEEDMEDIA_USEFILEOP     0x80000000


//
// Values for ProductType. Notice careful definitions
// such that low bit on means some kind of DC.
//
#define PRODUCT_WORKSTATION         0
#define PRODUCT_SERVER_PRIMARY      1
#define PRODUCT_SERVER_STANDALONE   2
#define PRODUCT_SERVER_SECONDARY    3

//
// Bit flags for OperationFlags. Note that this is a 64-bit field.
//
#define SETUPOP_WIN31UPGRADE        0x0000000000000001
#define SETUPOP_WIN95UPGRADE        0x0000000000000002
#define SETUPOP_NTUPGRADE           0x0000000000000004
#define SETUPOP_BATCH               0x0000000000000008
#define SETUPOP_STANDALONE          0x0000000000000010
#define SETUPOP_ALPHA_FILES_AVAIL   0x0000000100000000
#define SETUPOP_MIPS_FILES_AVAIL    0x0000000200000000
#define SETUPOP_PPC_FILES_AVAIL     0x0000000400000000
#define SETUPOP_X86_FILES_AVAIL     0x0000000800000000
#define SETUPOP_IA64_FILES_AVAIL    0x0000001000000000


//
// Component initialization structure, passed at OC_INIT_COMPONENT time.
//
typedef struct _SETUP_INIT_COMPONENTA {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAA SetupData;
    OCMANAGER_ROUTINESA HelperRoutines;
} SETUP_INIT_COMPONENTA, *PSETUP_INIT_COMPONENTA;

typedef struct _SETUP_INIT_COMPONENTW {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAW SetupData;
    OCMANAGER_ROUTINESW HelperRoutines;
} SETUP_INIT_COMPONENTW, *PSETUP_INIT_COMPONENTW;

#ifdef UNICODE
typedef SETUP_INIT_COMPONENTW SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTW PSETUP_INIT_COMPONENT;
#else
typedef SETUP_INIT_COMPONENTA SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTA PSETUP_INIT_COMPONENT;
#endif

//
// Current OC Manager version, major and minor.
//
#define OCVER_MAJOR     5
#define OCVER_MINOR     0

#define OCMANAGER_VERSION   ((DWORD)MAKELONG(OCVER_MINOR,OCVER_MAJOR))

//
// Wizard page request structure, used with OC_REQUEST_PAGES.
//
typedef struct _SETUP_REQUEST_PAGES {
    UINT MaxPages;
    HPROPSHEETPAGE Pages[ANYSIZE_ARRAY];
} SETUP_REQUEST_PAGES, *PSETUP_REQUEST_PAGES;


//
// Flags used in Param2 of OC_QUERY_CHANGE_SEL_STATE notification
//
#define OCQ_ACTUAL_SELECTION    0x00000001


//
// Enumerated types.
//

typedef enum {
    SubCompInfoSmallIcon,   // the small icon associated with the subcomponent
    SubCompInfoWatermark    // the watermark image at the top of the wizard
} SubComponentInfo;

typedef struct _OC_QUERY_IMAGE_INFO {
	DWORD   SizeOfStruct;
	SubComponentInfo ComponentInfo;
    UINT    DesiredWidth;      
    UINT    DesiredHeight;
} OC_QUERY_IMAGE_INFO, *POC_QUERY_IMAGE_INFO;


typedef enum {
    WizPagesWelcome,        // welcome page
    WizPagesMode,           // setup mode page
    WizPagesEarly,          // pages that come after the mode page and before prenet pages
    WizPagesPrenet,         // pages that come before network setup
    WizPagesPostnet,        // pages that come after network setup
    WizPagesLate,           // pages that come after postnet pages and before the final page
    WizPagesFinal,          // final page
    WizPagesTypeMax
} WizardPagesType;

typedef enum {
    SubcompUseOcManagerDefault,
    SubcompOn,
    SubcompOff
} SubComponentState;

typedef enum {
    OcPageComponentHierarchy,
    OcPageMax
} OcManagerPage;


// use the assert from SetupAPI
#define sapiAssert MYASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\ocdll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZoneClient.rc
//

#define IDB_SMALL_ICON 1000


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        236
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\ocdll\zoneoc.cpp ===
// zoneoc.cpp: Zone's Optional Component Manager DLL (Windows NT install)


#include <windows.h>
#include <setupapi.h>

#include "resource.h"

#define DWORD_PTR DWORD
#include "ocmanage.h"


#define COMPONENT_NAME TEXT("ZoneGames")
#define INSTALL_SECTION TEXT("ZoneInstall")
#define UNINSTALL_SECTION TEXT("ZoneUninstall")

#define REGISTRY_PATH TEXT("SOFTWARE\\Microsoft")
#define REGISTRY_KEY TEXT("zone.com")
#define REGISTRY_SUBKEY TEXT("Free Games 1.0")
#define REGISTRY_COMMONKEY TEXT("Common")

#define DIRECTORY_COMMON TEXT("Common")
#define ZCLIENTM TEXT("\\zclientm")

#define STEP_COUNT 1

#ifdef _UNICODE
#define CHAR_WIDTH OCFLAG_UNICODE
#else
#define CHAR_WIDTH OCFLAG_ANSI
#endif


static HINSTANCE g_hInstance;

static bool g_fInited = false;
static OCMANAGER_ROUTINES g_oHelperRoutines;
static HINF g_hOCInf = NULL;
static HINF g_hMyInf = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
    }

    return TRUE;    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Utility Functions

BOOL RunZclientm(LPCTSTR szParameters)
{
    TCHAR *szPath;
    DWORD cchSize;
    DWORD cchCommand = lstrlen(ZCLIENTM);

    if(!SetupGetTargetPath(g_hMyInf, NULL, NULL, NULL, 0, &cchSize))
        return FALSE;

    szPath = (TCHAR *) HeapAlloc(GetProcessHeap(), 0, (cchSize + cchCommand) * sizeof(TCHAR));
    if(!szPath)
        return ERROR_OUTOFMEMORY;

    if(!SetupGetTargetPath(g_hMyInf, NULL, NULL, szPath, cchSize, NULL))
    {
        HeapFree(GetProcessHeap(), 0, szPath);
        return FALSE;
    }

    lstrcat(szPath, ZCLIENTM);

    SHELLEXECUTEINFO oSE;
    oSE.cbSize = sizeof(oSE);
    oSE.fMask = SEE_MASK_FLAG_NO_UI;
    oSE.hwnd = NULL;
    oSE.lpVerb = TEXT("open");
    oSE.lpFile = szPath;
    oSE.lpParameters = szParameters;
    oSE.lpDirectory = NULL;
    oSE.nShow = SW_SHOWDEFAULT;
    if(!ShellExecuteEx(&oSE))
    {
        HeapFree(GetProcessHeap(), 0, szPath);
        return FALSE;
    }

    HeapFree(GetProcessHeap(), 0, szPath);
    return TRUE;
}


void RegDelete(HKEY hKey, LPCTSTR szSubKey)
{
    HKEY hSubKey = NULL;
    int i = 0;
    TCHAR szSubSubKey[MAX_PATH];
    DWORD cb;

    if(RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS && hSubKey)
    {
        while(RegEnumKeyEx(hSubKey, i++, szSubSubKey, (cb = MAX_PATH, &cb), NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            RegDelete(hSubKey, szSubSubKey);

        RegCloseKey(hSubKey);
    }

    RegDeleteKey(hKey, szSubKey);
}


void RegPrune(HKEY hRoot)
{
    HKEY hKey = NULL;
    HKEY hBase = NULL;
    int i = 0;
    TCHAR szSubKey[MAX_PATH];
    DWORD cb;
    bool fErase = true;

    if(RegOpenKeyEx(hRoot, REGISTRY_PATH, 0, KEY_ALL_ACCESS, &hBase) == ERROR_SUCCESS && hBase)
    {
        if(RegOpenKeyEx(hBase, REGISTRY_KEY, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS && hKey)
        {
            HKEY hCmnKey = NULL;

            RegDelete(hKey, REGISTRY_SUBKEY);

            while(RegEnumKeyEx(hKey, i++, szSubKey, (cb = MAX_PATH, &cb), NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                if(lstrcmpi(szSubKey, REGISTRY_COMMONKEY))
                {
                    fErase = false;
                    break;
                }

            RegCloseKey(hKey);
        }

        if(fErase)
            RegDelete(hBase, REGISTRY_KEY);

        RegCloseKey(hBase);
    }            
}


void DeleteDirectoryRecur(LPCTSTR szDir)
{
    WIN32_FIND_DATA oFD;
    TCHAR szFilter[MAX_PATH];
    TCHAR szDelete[MAX_PATH];

    if(lstrlen(szDir) > MAX_PATH - 3)
        return;

    lstrcpy(szFilter, szDir);
    lstrcat(szFilter, TEXT("\\*"));

    HANDLE hFind = FindFirstFile(szFilter, &oFD);
    while(hFind != INVALID_HANDLE_VALUE)
    {
        if(lstrlen(szDir) + lstrlen(oFD.cFileName) + 2 <= MAX_PATH && lstrcmpi(oFD.cFileName, TEXT(".")) && lstrcmpi(oFD.cFileName, TEXT("..")))
        {
            lstrcpy(szDelete, szDir);
            lstrcat(szDelete, TEXT("\\"));
            lstrcat(szDelete, oFD.cFileName);
        
            if(oFD.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                DeleteDirectoryRecur(szDelete);
            else
                DeleteFile(szDelete);
        }

        if(!FindNextFile(hFind, &oFD))
            break;
    }

    if(hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);

    RemoveDirectory(szDir);
}


/////////////////////////////////////////////////////////////////////////////
// Helper Functions

DWORD InitComponent(SETUP_INIT_COMPONENT *pInit)
{
    if(g_fInited)
        return ERROR_CANCELLED;

    if(pInit->OCManagerVersion < OCMANAGER_VERSION)
        return ERROR_CALL_NOT_IMPLEMENTED;
    pInit->ComponentVersion = OCMANAGER_VERSION;

    if(!(pInit->SetupData.OperationFlags & SETUPOP_X86_FILES_AVAIL))
        return ERROR_CANCELLED;

    g_oHelperRoutines = pInit->HelperRoutines;
    g_hOCInf = pInit->OCInfHandle;
    g_hMyInf = pInit->ComponentInfHandle;

    g_fInited = true;
    return NO_ERROR;
}


DWORD QueryImage(UINT eType)
{
    if(!g_fInited)
        return (DWORD) NULL;

    if(eType == SubCompInfoSmallIcon)
        return (DWORD) LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SMALL_ICON));

    return (DWORD) NULL;
}


DWORD CalcDiskSpace(UINT fAdd, HDSKSPC hDiskSpace)
{
    if(!g_fInited)
        return ERROR_NOT_READY;

    if(!g_hMyInf)
        return NO_ERROR;

    if(fAdd)
    {
        if(!SetupAddInstallSectionToDiskSpaceList(hDiskSpace, g_hMyInf, NULL, INSTALL_SECTION, NULL, 0))
            return GetLastError();
    }
    else
        if(!SetupRemoveInstallSectionFromDiskSpaceList(hDiskSpace, g_hMyInf, NULL, INSTALL_SECTION, NULL, 0))
            return GetLastError();

    return NO_ERROR;
}


DWORD QueueFileOps(HSPFILEQ hFileQueue)
{
    if(!g_fInited)
        return ERROR_NOT_READY;

    if(!g_hMyInf)
        return NO_ERROR;

    if(g_oHelperRoutines.QuerySelectionState(g_oHelperRoutines.OcManagerContext, COMPONENT_NAME, OCSELSTATETYPE_CURRENT))
    {
        if(!SetupInstallFilesFromInfSection(g_hMyInf, NULL, hFileQueue, INSTALL_SECTION, NULL, 0))
            return GetLastError();
    }
    else
    {
        if(!SetupInstallFilesFromInfSection(g_hMyInf, NULL, hFileQueue, UNINSTALL_SECTION, NULL, 0))
            return GetLastError();
    }

    return NO_ERROR;
}


DWORD AboutToCommitQueue()
{
    HKEY hKey = NULL;
    int i = 0;
    DWORD cb;
    TCHAR szSubKey[_MAX_PATH];

    if(!g_fInited)
        return ERROR_NOT_READY;

    // no pre-rocessing required for install
    if(!g_oHelperRoutines.QuerySelectionState(g_oHelperRoutines.OcManagerContext, COMPONENT_NAME, OCSELSTATETYPE_CURRENT))
    {
        // more options added to SPINST_ALL in w2k, so use the v5 value, hardcoded for now
        if(!SetupInstallFromInfSection(NULL, g_hMyInf, UNINSTALL_SECTION, /* SPINST_ALL */ 0x000001ff & ~SPINST_FILES, NULL, NULL, 0, NULL, NULL, NULL, NULL))
            return GetLastError();

        if(!RunZclientm(TEXT("/unregserver")))
            return GetLastError();

        // clean up registry
        RegPrune(HKEY_LOCAL_MACHINE);
        RegPrune(HKEY_CURRENT_USER);
        while(RegEnumKeyEx(HKEY_USERS, i++, szSubKey, (cb = _MAX_PATH, &cb), NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            if(RegOpenKeyEx(HKEY_USERS, szSubKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS && hKey)
            {
                RegPrune(hKey);
                RegCloseKey(hKey);
            }
        }
    }

    g_oHelperRoutines.TickGauge(g_oHelperRoutines.OcManagerContext);
    return NO_ERROR;
}


DWORD CompleteInstallation()
{
    if(!g_fInited)
        return ERROR_NOT_READY;

    if(g_oHelperRoutines.QuerySelectionState(g_oHelperRoutines.OcManagerContext, COMPONENT_NAME, OCSELSTATETYPE_CURRENT))
    {
        // more options added to SPINST_ALL in w2k, so use the v5 value, hardcoded for now
        if(!SetupInstallFromInfSection(NULL, g_hMyInf, INSTALL_SECTION, /* SPINST_ALL */ 0x000001ff & ~SPINST_FILES, NULL, NULL, 0, NULL, NULL, NULL, NULL))
            return GetLastError();

        if(!RunZclientm(TEXT("/regserver")))
            return GetLastError();
    }
    else
    {
        TCHAR *szPath;
        DWORD cchSize;
        int i;
        WIN32_FIND_DATA oFD;
        bool fDelete = true;

        if(!SetupGetTargetPath(g_hMyInf, NULL, NULL, NULL, 0, &cchSize))
            return FALSE;

        szPath = (TCHAR *) HeapAlloc(GetProcessHeap(), 0, cchSize * sizeof(TCHAR));
        if(!szPath)
            return ERROR_OUTOFMEMORY;

        if(!SetupGetTargetPath(g_hMyInf, NULL, NULL, szPath, cchSize, NULL))
        {
            HeapFree(GetProcessHeap(), 0, szPath);
            return FALSE;
        }

        DeleteDirectoryRecur(szPath);

        for(i = lstrlen(szPath) - 1; i >= 0 && szPath[i] != TEXT('\\'); i--);
        if(i >= 0 && i + 2 <= lstrlen(szPath))
        {
            szPath[i + 1] = TEXT('*');
            szPath[i + 2] = TEXT('\0');

            HANDLE hFind = FindFirstFile(szPath, &oFD);
            while(hFind != INVALID_HANDLE_VALUE)
            {
                if(lstrcmpi(oFD.cFileName, DIRECTORY_COMMON) && lstrcmpi(oFD.cFileName, TEXT(".")) && lstrcmpi(oFD.cFileName, TEXT("..")))
                {
                    fDelete = false;
                    break;
                }

                if(!FindNextFile(hFind, &oFD))
                    break;
            }

            if(hFind != INVALID_HANDLE_VALUE)
                FindClose(hFind);

            if(fDelete)
            {
                szPath[i] = TEXT('\0');
                DeleteDirectoryRecur(szPath);
            }
        }

        HeapFree(GetProcessHeap(), 0, szPath);
    }

    g_oHelperRoutines.TickGauge(g_oHelperRoutines.OcManagerContext);
    return NO_ERROR;
}


DWORD Cleanup()
{
    if(g_fInited)
        g_fInited = false;

    return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
// OC Manager Entry Point

extern "C" DWORD __declspec(dllexport) ZoneSetupProc(LPCVOID ComponentId, LPCVOID SubcomponentId, UINT Function, UINT Param1, PVOID Param2)
{
    LPCTSTR szComponentId = (LPCTSTR) ComponentId;
    LPCTSTR szSubcomponentId = (LPCTSTR) SubcomponentId;

    if(Function == OC_PREINITIALIZE)
        return CHAR_WIDTH & Param1;

    if(lstrcmpi(szComponentId, COMPONENT_NAME))
        return 0;

    switch(Function)
    {
        case OC_INIT_COMPONENT:
            return InitComponent((SETUP_INIT_COMPONENT *) Param2);

        case OC_SET_LANGUAGE:
            return 0;

        case OC_QUERY_IMAGE:
            return QueryImage(Param1);

        case OC_REQUEST_PAGES:
            return 0;

        case OC_QUERY_SKIP_PAGE:
            return 0;

        case OC_QUERY_CHANGE_SEL_STATE:
            return TRUE;

        case OC_CALC_DISK_SPACE:
            return CalcDiskSpace(Param1, (HDSKSPC) Param2);

        case OC_QUEUE_FILE_OPS:
            if(!szSubcomponentId)
                return NO_ERROR;

            return QueueFileOps((HSPFILEQ) Param2);

        case OC_QUERY_STEP_COUNT:
            if(!szSubcomponentId)
                return 0;

            return 2;

        case OC_ABOUT_TO_COMMIT_QUEUE:
            if(!szSubcomponentId)
                return NO_ERROR;

            return AboutToCommitQueue();

        case OC_COMPLETE_INSTALLATION:
            if(!szSubcomponentId)
                return NO_ERROR;

            return CompleteInstallation();

        case OC_CLEANUP:
            return Cleanup();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by zClient.rc
//
#define IDS_REGISTRATION_FAILED         1
#define IDS_REGISTRATION_TITLE          2
#define IDR_ZClient                     100
#define IDR_CLIENTCORE                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\clientcore.h ===
// ClientCore.h : Declaration of the CClientCore

#ifndef __CLIENTCORE_H_
#define __CLIENTCORE_H_

#include "Resource.h"
#include "ZoneResource.h"
#include "zClient.h"
#include "OpName.h"
#include "EventQueue.h"
#include "ZoneShell.h"
#include "ZoneProxy.h"
#include "DataStore.h"
#include "LobbyDataStore.h"
#include "ZoneString.h"


///////////////////////////////////////////////////////////////////////////////
// Forward references
///////////////////////////////////////////////////////////////////////////////

class CClientCore;

///////////////////////////////////////////////////////////////////////////////
// Application global variables
///////////////////////////////////////////////////////////////////////////////

extern CClientCore*			gpCore;
extern IEventQueue*			gpEventQueue;
extern IZoneShell*			gpZoneShell;
extern IZoneFrameWindow*	gpWindow;
extern TCHAR				gszLanguage[16];
extern TCHAR				gszInternalName[128];
extern TCHAR				gszFamilyName[128];
extern TCHAR				gszGameName[128];
extern TCHAR				gszServerName[128];
extern DWORD				gdwServerPort;
extern DWORD				gdwServerAnonymous;

extern HINSTANCE			ghResourceDlls[32];
extern int					gnResourceDlls;
extern HANDLE				ghEventQueue;
extern int					gnChatChannel;


///////////////////////////////////////////////////////////////////////////////
// CClientCore
///////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CClientCore : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CClientCore, &CLSID_ZClient>,
	public IZoneProxy
{
public:
	// constructor and destructor
	CClientCore();
	void FinalRelease();


DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTCORE)
DECLARE_NOT_AGGREGATABLE(CClientCore)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClientCore)
	COM_INTERFACE_ENTRY(IZoneProxy)
END_COM_MAP()

// IZoneProxy
public:
	STDMETHOD(Command)( BSTR bstrCmd, BSTR bstrArg1, BSTR bstrArg2, BSTR* pbstrOut, long* plCode );
	STDMETHOD(Close)();
	STDMETHOD(KeepAlive)();

public:
	// command implementations
	HRESULT DoLaunch( TCHAR* szArg1, TCHAR* szArg2 );

	// manage multiple instances
	HRESULT CreateLobbyMutex();
	void ReleaseLobbyMutex();


private:
	TCHAR					m_szWindowTitle[256];
	HANDLE					m_hMutex;
};


#endif //__CLIENTCORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED_)
#define AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
#include <ZoneATL.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CZoneComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};


extern CExeModule _Module;

#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\clientcore.cpp ===
// ClientCore.cpp : Implementation of CClientCore
#include "stdafx.h"
#include "ClientCore.h"
#include "ZoneEvent.h"
#include "KeyName.h"
#include "ZoneUtil.h"
#include "zeeverm.h"
//#include "zProxy.h"

inline DECLARE_MAYBE_FUNCTION(HRESULT, GetVersionPack, (char *a, ZeeVerPack *b), (a, b), zeeverm, E_NOTIMPL);

///////////////////////////////////////////////////////////////////////////////
// CClientCore IZoneProxy
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CClientCore::Command( BSTR bstrCmd, BSTR bstrArg1, BSTR bstrArg2, BSTR* pbstrOut, long* plCode )
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	TCHAR* szOp   = W2T( bstrCmd );
	TCHAR* szArg1 = W2T( bstrArg1 );
	TCHAR* szArg2 = W2T( bstrArg2 );
	
	if ( lstrcmpi( op_Launch, szOp ) == 0 )
	{
		hr = DoLaunch( szArg1, szArg2 );
		if ( FAILED(hr) )
		{
			// release self-reference since we didn't launch
			Release();
			*plCode = ZoneProxyFail;
		}
        else
            if(hr != S_OK)  // didn't run, but no error
                Release();
	}
	else if ( lstrcmpi( op_Status, szOp ) == 0 )
	{
		*plCode = ZoneProxyOk;
	}
	else
	{
		*plCode = ZoneProxyUnknownOp;
	}
	return hr;
}


STDMETHODIMP CClientCore::Close()
{
	return S_OK;
}


STDMETHODIMP CClientCore::KeepAlive()
{
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// CClientCore Implementation
///////////////////////////////////////////////////////////////////////////////

CClientCore::CClientCore() :
	m_hMutex( NULL )
{
	gpCore = this;
	m_szWindowTitle[0] = _T('\0');
}


void CClientCore::FinalRelease()
{
	// zero out global reference
	gpCore = NULL;

	// release proxy object
	Close();
}


HRESULT CClientCore::CreateLobbyMutex()
{
//	TCHAR szMutexName[128];

	//
	// gnChatChannel values:
	//	-1 = not dynamic chat
	//	 0 = dynamic chat host
	//	 n = dynamic chat joiner
	//

	// multiple dynamic chat hosts are allowed
	if ( gnChatChannel == 0 )
		return S_OK;

	// create lobby mutex
//	wsprintf( szMutexName, _T("%s:%s:%d"), gszServerName, gszInternalName, gnChatChannel  );
	m_hMutex = CreateMutex( NULL, FALSE, gszInternalName );
	if ( m_hMutex == NULL )
		return E_FAIL;

	// is user already in the room?
	if ( m_hMutex && GetLastError() == ERROR_ALREADY_EXISTS )
	{
		// close the mutex.
		CloseHandle( m_hMutex );
		m_hMutex = NULL;

		// find the window and bring it to the top.


		HWND hWnd = ::FindWindow( NULL, m_szWindowTitle );
		if ( hWnd )
		{
			::ShowWindow(hWnd, SW_SHOWNORMAL);
			::BringWindowToTop( hWnd );
			::SetForegroundWindow( hWnd );
		}

		return S_FALSE;
	}

	return S_OK;
}


void CClientCore::ReleaseLobbyMutex()
{
	if ( m_hMutex )
	{
		CloseHandle( m_hMutex );
		m_hMutex = NULL;
	}
}


HRESULT CClientCore::DoLaunch( TCHAR* szArg1, TCHAR* szArg2 )
{
    USES_CONVERSION;

	HINSTANCE	hInst = NULL;
	HRESULT		hr;
	long		lStore = 0;
	TCHAR		szGameDir[128];
	TCHAR		szStore[16];
	TCHAR		szChatChannel[16];
	TCHAR		szDllList[256];
	TCHAR		szBootList[256];
	TCHAR		szICW[MAX_PATH + 1];
	TCHAR*		arResouceDlls[32];
    TCHAR       szSetupToken[128];
	DWORD		nResouceDlls = NUMELEMENTS(arResouceDlls) - 1;
	TCHAR*		arBootDlls[32];
	DWORD		nBootDlls = NUMELEMENTS(arBootDlls);

	// self-reference to prevent early exit
	AddRef();

	// clear local strings
	ZeroMemory( szGameDir, sizeof(szGameDir) );
	ZeroMemory( szStore, sizeof(szStore) );
	ZeroMemory( szChatChannel, sizeof(szChatChannel) );
	ZeroMemory( szDllList, sizeof(szDllList) );
	ZeroMemory( szBootList, sizeof(szBootList) );
	ZeroMemory( arResouceDlls, sizeof(arResouceDlls) );
	ZeroMemory( arBootDlls, sizeof(arBootDlls) );

	// parse launch args
	if ( TokenGetKeyValue( _T("store"), szArg1, szStore, NUMELEMENTS(szStore) ) )
	{
		lStore = zatol(szStore);
	}
	if ( TokenGetKeyValue( _T("channel"), szArg1, szChatChannel, NUMELEMENTS(szChatChannel) ) )
	{
		gnChatChannel = zatol(szChatChannel);
	}
	if ( !TokenGetServer( szArg1, gszServerName, NUMELEMENTS(gszServerName), &gdwServerPort ) )
	{
		ASSERT( !"Missing server name (server)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("lang"), szArg1, gszLanguage, NUMELEMENTS(gszLanguage) ) )
		lstrcpy( gszLanguage, _T("eng") );
	if ( !TokenGetKeyValue( _T("id"), szArg1, gszInternalName, NUMELEMENTS(gszInternalName) ) )
	{
		ASSERT( !"Missing internal name (id)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("name"), szArg1, gszGameName, NUMELEMENTS(gszGameName) ) )
	{
		ASSERT( !"Missing game name (name)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("family"), szArg1, gszFamilyName, NUMELEMENTS(gszFamilyName) ) )
	{
		ASSERT( !"Missing family name (family)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("dll"), szArg1, szBootList, NUMELEMENTS(szBootList) ) )
	{
		ASSERT( !"Missing bootstrap dll (dll)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("datafile"), szArg1, szDllList, NUMELEMENTS(szDllList) ) )
	{
		ASSERT( !"Missing dll list (datafiles)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("game"), szArg1, szGameDir, NUMELEMENTS(szGameDir) ) )
	{
		ASSERT( !"Missing game directory (game)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("icw"), szArg1, szICW, NUMELEMENTS(szICW) ) )
	{
		ASSERT( !"Missing command line (icw)" );
		return E_FAIL;
	}
    if ( !TokenGetKeyValue( _T("setup"), szArg1, szSetupToken, NUMELEMENTS(szSetupToken) ) )
    {
        ASSERT( !"Missing setup token (setup)" );
        return E_FAIL;
    }


	// parse boot dlls
	StringToArray( szBootList, arBootDlls, &nBootDlls );

	// parse datafile dlls
	if ( StringToArray( szDllList, arResouceDlls, &nResouceDlls ) )
	{
		// first look for dll in game directory
		for ( DWORD i = 0; i < nResouceDlls; i++ )
		{
			TCHAR szDll[MAX_PATH];

			if ( !arResouceDlls[i] )
				continue;
			wsprintf( szDll, _T("%s\\%s"), szGameDir, arResouceDlls[i] );
			hInst = LoadLibrary( szDll );
			if ( hInst )
			{
				ghResourceDlls[gnResourceDlls++] = hInst;
				arResouceDlls[i] = NULL;
			}
		}

		// second look for dll in zone directory
		for ( i = 0; i < nResouceDlls; i++ )
		{
			if ( !arResouceDlls[i] )
				continue;
			hInst = LoadLibrary( arResouceDlls[i] );
			if ( hInst )
				ghResourceDlls[gnResourceDlls++] = hInst;
		}

		
		//t-gdosan Make sure all resource Dlls were loaded correctly
		for ( i = 0; i < nResouceDlls; i++ )
		{
			if ( !ghResourceDlls[i] )
			{				
				ASSERT(!"Error loading resource dlls");
				return E_FAIL;
			}
		}

		// always add module, i.e. NULL, as last resort
		ghResourceDlls[gnResourceDlls++] = NULL;
	}

	// create zone shell
	hr = E_FAIL;
	for ( DWORD i = 0; i < nBootDlls; i++ )
	{
		hr = _Module.Create( arBootDlls[i], CLSID_ZoneShell, IID_IZoneShell, (void**) &gpZoneShell );
		if ( SUCCEEDED(hr) )
			break;
	}
	if ( FAILED(hr) )
    {
        ASSERT(!"Could not load code dlls.");
		return hr;
    }

	// initialize zone shell
	hr = gpZoneShell->Init( arBootDlls, nBootDlls, ghResourceDlls, gnResourceDlls );
	if ( FAILED(hr) )
	{
		ASSERT( !"ZoneShell initialization failed" );
		gpZoneShell->Close();
		gpZoneShell->Release();
		gpZoneShell = NULL;
		return E_FAIL;
	}

	// initialize sub-components
	CComPtr<IDataStoreManager>		pIDataStoreManager;
	CComPtr<ILobbyDataStore>		pILobbyDataStore;
	CComPtr<IResourceManager>		pIResourceManager;
	CComQIPtr<ILobbyDataStoreAdmin>	pILobbyDataStoreAdmin;

	gpZoneShell->QueryService( SRVID_LobbyWindow, IID_IZoneFrameWindow, (void**) &gpWindow );
	gpZoneShell->QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &gpEventQueue );
	gpZoneShell->QueryService( SRVID_DataStoreManager, IID_IDataStoreManager, (void**) &pIDataStoreManager );
	gpZoneShell->QueryService( SRVID_LobbyDataStore, IID_ILobbyDataStore, (void**) &pILobbyDataStore );
	gpZoneShell->QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &pIResourceManager );

	pILobbyDataStoreAdmin = pILobbyDataStore;
	_Module.SetResourceManager( pIResourceManager );

	// event queue signal
	gpEventQueue->SetNotificationHandle( ghEventQueue );
	// gpEventQueue->SetWindowMessage( GetCurrentThreadId(), WM_USER + 10666, 0, 0 );

	if (	!gpEventQueue
		||	!pIDataStoreManager
		||	!pILobbyDataStore
		||	!pIResourceManager
		||	!pILobbyDataStoreAdmin
		||	FAILED(pILobbyDataStoreAdmin->Init(pIDataStoreManager)) )
	{
        ASSERT(!"Could not load core objects.");
		gpZoneShell->Close();
		gpZoneShell->Release();
		gpZoneShell = NULL;
		return E_FAIL;
	}

	// Get window title to pass to CreateLobbyMutex call
	// CreateLobbyMutex needs this to be able to bring window to front if an instance is already running
	TCHAR szTitle[ZONE_MAXSTRING];
	TCHAR szFormat[ZONE_MAXSTRING];
	TCHAR szName[ZONE_MAXSTRING];

	if(!pIResourceManager->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
		lstrcpy(szName, TEXT("Zone"));
	if(!pIResourceManager->LoadString(IDS_WINDOW_TITLE, szFormat, NUMELEMENTS(szFormat)))
		lstrcpy(szFormat, TEXT("%1"));
	if(!ZoneFormatMessage(szFormat, szTitle, NUMELEMENTS(szTitle), szName))
		lstrcpy(szTitle, szName);
	lstrcpy(m_szWindowTitle,szTitle);
 
	// prevent multiple copies of the lobby from running, except when debugging
#ifndef _DEBUG
    hr = CreateLobbyMutex();
	if(hr != S_OK)   // could have succeeded with S_FALSE, but we still don't continue
    {
        ASSERT(SUCCEEDED(hr));
		gpZoneShell->Close();
		gpZoneShell->Release();
		gpZoneShell = NULL;
		return hr;
    }
#endif 

	// add startup parameters to lobby data store
	CComPtr<IDataStore> pIDS;
	pILobbyDataStore->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	pIDS->SetString( key_StartData, szArg1 );
	pIDS->SetString( key_Language, gszLanguage );
	pIDS->SetString( key_FriendlyName, szGameDir );
	pIDS->SetString( key_FamilyName, gszFamilyName );
	pIDS->SetString( key_InternalName, gszInternalName );
	pIDS->SetString( key_Server, gszServerName );
	pIDS->SetString( key_icw, szICW);

	pIDS->SetLong( key_Port, (long) gdwServerPort );
	pIDS->SetLong( key_Store, lStore );
	if ( szChatChannel[0] )
		pIDS->SetLong( key_ChatChannel, gnChatChannel );

    char *szST = T2A(szSetupToken);
    ZeeVerPack oPack;
    hr = CALL_MAYBE(GetVersionPack)(szST, &oPack);
    if(SUCCEEDED(hr))
    {
        const TCHAR *arKeys[] = { key_Version, key_VersionNum };
        pIDS->SetLong(arKeys, 2, oPack.dwVersion);

        arKeys[1] = key_VersionStr;
        pIDS->SetString(arKeys, 2, A2T(oPack.szVersionStr));

        arKeys[1] = key_BetaStr;
        pIDS->SetString(arKeys, 2, A2T(oPack.szVersionName));

        arKeys[1] = key_SetupToken;
        pIDS->SetString(arKeys, 2, A2T(oPack.szSetupToken));
    }

	pIDS.Release();

	// load palette
	gpZoneShell->SetPalette( gpZoneShell->CreateZonePalette() );

	// create window if one exists
	if ( gpWindow )
		HWND hwnd = gpWindow->ZCreateEx( NULL, NULL, m_szWindowTitle );

	// start tasks going, login, splash window
	gpEventQueue->PostEvent( PRIORITY_LOW, EVENT_LOBBY_BOOTSTRAP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\backgammon\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\checkers\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\platform\zclient\zclient.cpp ===
#include "stdafx.h"
#include <commctrl.h>
#include "resource.h"
#include "ClientCore.h"

#include <initguid.h>
#include "zClient.h"
#include "zClient_i.c"
//#include "zProxy.h"
//#include "zProxy_i.c"


///////////////////////////////////////////////////////////////////////////////
// Global variable initialization
///////////////////////////////////////////////////////////////////////////////

CClientCore*		gpCore = NULL;			// primary object
IEventQueue*		gpEventQueue = NULL;	// pointer to main event queue	
IZoneShell*			gpZoneShell = NULL;		// pointer to zone shell
IZoneFrameWindow*	gpWindow = NULL;		// pointer to main window
TCHAR				gszLanguage[16];		// language extension
TCHAR				gszInternalName[128];	// internal name
TCHAR				gszFamilyName[128];		// family name
TCHAR				gszGameName[128];		// game name
TCHAR				gszServerName[128];		// server's ip address
DWORD				gdwServerPort = 0;		// server's port
DWORD				gdwServerAnonymous = 0;	// server's authentication

HINSTANCE			ghResourceDlls[32];		// resource dll array
int					gnResourceDlls = 0;		// resource dll array count
HANDLE				ghEventQueue = NULL;	// event queue notification event
int					gnChatChannel = -1;		// dynamic chat channel


///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

static const DWORD	dwTimeOut = 0;			// time for EXE to be idle before shutting down
static const DWORD	dwPause = 1000;			// time to wait for threads to finish up


///////////////////////////////////////////////////////////////////////////////
// Process Monitor
///////////////////////////////////////////////////////////////////////////////

static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*) pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);

        // timed out, if no activity let's really bail
        if (!bActivity && m_nLockCnt == 0)
        {
			break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if(h)
        CloseHandle(h);
    return (h != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Object map
///////////////////////////////////////////////////////////////////////////////

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ZClient, CClientCore)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////
// Helper Functions
///////////////////////////////////////////////////////////////////////////////

static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// WinMain
/////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmd, int nShowCmd )
{
	int nRet = 0;
    BOOL bRun = TRUE;
    LPTSTR lpCmdLine;

	 // this line necessary for _ATL_MIN_CRT
    lpCmdLine = GetCommandLine();

	// initialize OLE
    HRESULT hRes = CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hRes));

	// initialize ATL
    _Module.Init(ObjectMap, hInstance );
	_Module.dwThreadID = GetCurrentThreadId();

    // parse command line
	TCHAR szTokens[] = _T("-/");
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_ZClient, FALSE);
            nRet = _Module.UnregisterServer( TRUE );
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_ZClient, TRUE);
            nRet = _Module.RegisterServer( TRUE );
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
		// initialize common controls
		INITCOMMONCONTROLSEX iccx;
		iccx.dwSize = sizeof(iccx);
		iccx.dwICC = ICC_TAB_CLASSES | ICC_HOTKEY_CLASS | ICC_USEREX_CLASSES | ICC_LISTVIEW_CLASSES;
		::InitCommonControlsEx(&iccx);

		// initialize globals
		ZeroMemory( gszLanguage, sizeof(gszLanguage) );
		ZeroMemory( gszInternalName, sizeof(gszInternalName) );
		ZeroMemory( gszFamilyName, sizeof(gszFamilyName) );
		ZeroMemory( gszGameName, sizeof(gszGameName) );
		ZeroMemory( gszServerName, sizeof(gszServerName) );
		ZeroMemory( ghResourceDlls, sizeof(ghResourceDlls) );

		// register object
		_Module.StartMonitor();
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE );
        _ASSERTE(SUCCEEDED(hRes));

		// create event queue notification event
		ghEventQueue = CreateEvent( NULL, FALSE, FALSE, NULL );
		ASSERT( ghEventQueue );


		// pump messages
		for ( bool bContinue = true; bContinue; )
		{
			for ( bool bFoundItem = true; bFoundItem; )
			{
				bFoundItem = false;

				// process window message
				MSG msg;
				while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
				{
					if ( msg.message == WM_QUIT )
					{
						bContinue = false;
						break;
					}
					else
					{
						bFoundItem = true;
                        if(gpZoneShell)
                            gpZoneShell->HandleWindowMessage(&msg);
                        else
                        {
						    if(!gpWindow || !gpWindow->ZPreTranslateMessage(&msg))
						    {
							    ::TranslateMessage( &msg );
							    ::DispatchMessage( &msg );
                            }
						}
					}
				}

				// process an event queue
				if ( gpEventQueue )
				{
					if ( gpEventQueue->ProcessEvents( true ) != ZERR_EMPTY )
						bFoundItem = true;
				}
			}

			if ( bContinue )
				MsgWaitForMultipleObjects( 1, &ghEventQueue, FALSE, INFINITE, QS_ALLINPUT );
		}

		// unregister object
        _Module.RevokeClassObjects();
        Sleep(dwPause);
    }
	else
	{
		if ( nRet )
		{
			TCHAR szTitle[256];
			TCHAR szError[256];
			LoadString( NULL, IDS_REGISTRATION_FAILED, szTitle, sizeof(szTitle) );
			wsprintf( szError, szTitle, nRet );
			LoadString( NULL, IDS_REGISTRATION_TITLE, szTitle, sizeof(szTitle) );
			MessageBox( NULL, szError, szTitle, MB_OK | MB_ICONEXCLAMATION );
		}
	}

	// close window
	if ( gpWindow )
	{
		gpWindow->ZDestroyWindow();
		gpWindow->Release();
		gpWindow = NULL;
	}
	
	if ( gpCore )
	{
		// release mutex
		gpCore->ReleaseLobbyMutex();
	}

	// close event queue
	if ( gpEventQueue )
	{
		gpEventQueue->SetNotificationHandle( NULL );
		gpEventQueue->Release();
		gpEventQueue = NULL;
	}

	// close event queue handler
	if ( ghEventQueue )
	{
		CloseHandle( ghEventQueue );
		ghEventQueue = NULL;
	}
	
	// close zone shell
	if ( gpZoneShell )
	{
		gpZoneShell->Close();
		if ( gpZoneShell->GetPalette() )
		{
			DeleteObject( gpZoneShell->GetPalette() );
			gpZoneShell->SetPalette( NULL );
		}
		gpZoneShell->Release();
	}

	// free resource libraries
	for ( int i = 0; i < gnResourceDlls; i++ )
	{
		if ( ghResourceDlls[i] )
		{
			FreeLibrary( ghResourceDlls[i] );
			ghResourceDlls[i] = NULL;
		}
	}
	gnResourceDlls = 0;

	// release self-reference
	if ( gpCore )
	{
		gpCore->Release();
		gpCore = NULL;
	}

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\checkers\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\common\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\backgammon\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\common\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\hearts\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\hearts\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\reversi\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\reversires.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\millennium\RESOURCES\Reversi\generic\ReversiRes.rc
//
#define IDB_REV_BLACK                   13101
#define IDB_REV_WHITE                   13102
#define IDB_REV_BLACKNAME               13103
#define IDB_REV_WHITENAME               13104
#define IDB_REV_BLACKMARK               13105
#define IDB_REV_WHITEMARK               13106
#define IDB_REV_BLACKCNT                13107
#define IDB_REV_WHITECNT                13108
#define IDB_RESULTS                     13109
#define IDB_BUTTON                      13112
#define IDD_BADMOVE                     13113
#define IDC_COMFORT                     13114
#define IDR_REVERSIACCELERATOR          13120
#define IDC_RESIGN_BUTTON               13150
#define IDC_GAME_WINDOW                 13152
#define IDC_RESULT_WINDOW               13153
#define IDS_BUTTON_RESIGN               13201
#define IDS_YOUR_TURN                   13204
#define IDS_OPPONENTS_TURN              13205
#define IDS_BLACKS_TURN                 13206
#define IDS_PLAYER_WINS                 13207
#define IDS_DRAW                        13209
#define IDS_RESIGN_CONFIRM              13214
#define IDS_RESIGN_CONFIRM_CAPTION      13215

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        13250
#define _APS_NEXT_COMMAND_VALUE         13500
#define _APS_NEXT_CONTROL_VALUE         13700
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\heartsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by E:\ZM\RESOURCES\Hearts\generic\heartsres.rc
//
#define IDB_PASS_LEFT                   11000
#define IDB_PASS_RIGHT                  11001
#define IDB_PASS_ACROSS                 11002
#define IDB_CARD_BACK                   11003
#define IDB_HAND_SCORE_BACK             11004
#define IDB_GAME_SCORE_BACK             11005
#define IDB_SMALL_HEART                 11006
#define IDB_PASS_LEFT_SMALL             11007
#define IDB_PASS_RIGHT_SMALL            11008
#define IDB_PASS_ACROSS_SMALL           11009
#define IDB_PASS_HOLD_SMALL             11010
#define IDB_BUTTON_HIGHLIGHTED          11029
#define IDB_BUTTON_DISABLED             11030
#define IDB_BUTTON_IDLE                 11031
#define IDB_BUTTON_SELECTED             11032
#define IDS_SCORE_HISTORY               11100
#define IDS_LAST_TRICK                  11101
#define IDS_PLAY                        11102
#define IDS_AUTO_PLAY                   11103
#define IDS_PASS                        11104
#define IDS_CLOSE                       11105
#define IDS_DONE                        11106
#define IDS_STOP                        11107
#define IDS_SCORE                       11108
#define IDS_PASS_LEFT                   11109
#define IDS_PASS_RIGHT                  11110
#define IDS_PASS_ACROSS                 11111
#define IDS_POINTS                      11112
#define IDS_SCORES                      11113
#define IDS_GAME_OVER                   11114
#define IDS_POINTS_X                    11115
#define IDS_HEARTS_YOU                  11116
#define IDS_PASS_SELECT                 11117
#define IDS_PASS_WAITING                11118
#define IDS_PASS_WAITING2               11119
#define IDS_ERR_LEAD_2C                 11200
#define IDS_ERR_CANT_LEAD_HEARTS        11201
#define IDS_ERR_MUST_FOLLOW_SUIT        11202
#define IDS_ERR_NO_PTS_FIRST_TRICK      11203
#define IDS_ERR_PLEASE_SELECT_3         11204
#define IDS_ERR_PLEASE_SELECT_1         11205
#define IDS_PLAYERSHOTTHEMOON           11206
#define IDD_SCORES                      11400
#define IDC_SCORES_HISTORY              11401
#define IDI_BLANK                       11402
#define IDI_HEART                       11403
#define IDS_HISTORY_HANDS               11410
#define IDR_HEARTS_ACCELERATOR			11500
#define IDC_LAST_TRICK_BUTTON			11501
#define IDC_SCORE_BUTTON				11502
#define IDC_PLAY_BUTTON					11503
#define IDC_AUTOPLAY_BUTTON				11504
#define IDC_STOP_BUTTON					11505
#define IDC_DONE_BUTTON					11506
#define IDC_HAND                        11507
#define IDC_CLOSE_BOX                   11508
#define IDB_MOONFRAME_1                 11995
#define IDB_MOONFRAME_2                 11996
#define IDB_MOONFRAME_3                 11997
#define IDB_MOONFRAME_4                 11998
#define IDB_MOONFRAME_5                 11999

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        11200
#define _APS_NEXT_COMMAND_VALUE         11500
#define _APS_NEXT_CONTROL_VALUE         11800
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\commonres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\Millennium\RESOURCES\Common\generic\Common.rc
//
#define ID_UNUSED_BY_RES                1000
#define IDI_ICON                        1009
#define IDR_OBJECT_CONFIG               1010
#define IDR_UI_CONFIG                   1011
#define IDR_ZONE_PALETTE                1012
#define IDB_GAME_SPLASH                 1020
#define IDB_CARDS                       1022
#define IDB_CARD_MASK                   1023
#define IDB_BACKGROUND                  1025
#define IDB_SPLASH_ANIM                 1026
#define IDB_FOCUS_PATTERN               1027
#define IDR_WINDOWFRAME                 1030
#define IDR_CHAT_MENU                   1032
#define IDR_EDIT_MENU                   1033
#define IDD_PLUG_SPLASH                 1110
#define IDD_PLUG_IE                     1120
#define IDD_PLAY_COMFORT                1130
#define IDD_PLAY_CONNECTING             1140
#define IDD_PLAY_GAMEOVER               1150
#define IDD_PLAY_LEFT                   1160
#define IDD_PLAY_ERROR                  1170
#define IDD_ALERTBOX                    1177
#define IDC_ALERTBOX_TEXT               1178
#define IDD_PLAY_ABOUT                  1180
#define IDR_CHAT_ACCEL                  1181
#define IDD_PLAY_CREDITS                1190
#define IDS_GAME_NAME                   1200
#define IDS_PLAYER_1                    1201
#define IDS_PLAYER_2                    1202
#define IDS_PLAYER_3                    1203
#define IDS_PLAYER_4                    1204
#define IDS_COMPUTER_1                  1205
#define IDS_COMPUTER_2                  1206
#define IDS_COMPUTER_3                  1207
#define IDS_COMPUTER_4                  1208
#define IDS_MENU_FINDNEW                1209
#define IDS_CHAT_TYPEHERE               1210
#define IDS_SPLASH_LOOKING              1211
#define IDS_STARTMENU_NAME              1212
#define IDS_STARTMENU_TIP               1213
#define IDS_NETWORK_BUTTON              1217
#define IDS_NETWORK                     1218
#define IDS_NETWORK_DISCONNECT          1219
#define IDS_SPLASH_COPYRIGHT            1220
#define IDS_CHAT_CHAT                   1221
#define IDS_CHAT_ON                     1222
#define IDS_CHAT_OFF                    1223
#define IDS_CHAT_CHATISOFF              1224
#define IDS_CHAT_INACTIVE               1225
#define IDS_CHAT_PLAYER_ON              1226
#define IDS_CHAT_PLAYER_OFF             1227
#define IDS_CHAT_PLAYER_BOT             1228
#define IDS_CHAT_SEPERATOR              1229
#define IDS_CHAT_SEND                   1231
#define IDS_UPSELL_DECIDING             1232
#define IDS_UPSELL_READY                1233
#define IDS_UPSELL_YOU_DECIDING         1234
#define IDS_UPSELL_YOU_READY            1235
#define IDS_ABOUT_TM                    1236
#define IDS_ABOUT_VERSION               1237
#define IDS_ABOUT_VERSION_HYP           1238
#define IDS_MENU_GAMEONTHEWEB           1239
#define IDS_MENU_ABOUTGAME              1240
#define IDS_SPLASH_CONNECTING           1241
#define IDS_SPLASH_OPENING              1242
#define IDS_MENU_GAMEHELP               1243
#define IDS_LEVEL_BEGINNER              1244
#define IDS_LEVEL_INTERMEDIATE          1245
#define IDS_LEVEL_EXPERT                1246
#define IDS_UPSELL_ASKTEXT4             1247
#define IDS_UPSELL_WAITTEXT4            1248
#define IDS_UPSELL_BUTTON4              1249
#define IDS_ZONE_UNAVAILABLE            1250
#define IDS_ZONE_UNAVAILABLE2           1251
#define IDS_WINDOW_TITLE                1252
#define IDS_SYSCHAT_CHATON              1253
#define IDS_SYSCHAT_CHATOFF             1254
#define IDS_SYSCHAT_BOT                 1255
#define IDS_SYSCHAT_NOTON4              1256
#define IDS_SYSCHAT_NOTON2              1257
#define IDS_SYSCHAT_INTRO               1258
#define IDS_SYSCHAT_INTROYOU            1259
#define IDS_SYSCHAT_ON                  1260
#define IDS_SYSCHAT_OFF                 1261
#define IDS_ABOUT_WARNING               1262
#define IDS_L_GERMAN                    1264
#define IDS_L_SPANISH                   1265
#define IDS_L_FRENCH                    1266
#define IDS_L_ITALIAN                   1267
#define IDS_L_SWEDISH                   1268
#define IDS_L_DUTCH                     1269
#define IDS_L_PORTUGUESE                1270
#define IDS_L_JAPANESE                  1271
#define IDS_L_DANISH                    1272
#define IDS_L_NORWEGIAN                 1273
#define IDS_L_FINNISH                   1274
#define IDS_L_KOREAN                    1275
#define IDS_L_CHINESE                   1276
#define IDS_L_CZECH                     1277
#define IDS_L_POLISH                    1278
#define IDS_L_HUNGARIAN                 1279
#define IDS_L_RUSSIAN                   1280
#define IDS_L_GREEK                     1281
#define IDS_L_TURKISH                   1282
#define IDS_L_SLOVAK                    1283
#define IDS_L_SLOVENIAN                 1284
#define IDS_L_ARABIC                    1285
#define IDS_L_HEBREW                    1286
#define IDS_L_THAI                      1287
#define IDS_L_ENGLISH                   1288
#define IDS_L_UNKNOWN                   1289
#define IDS_LEFT_SERVER_FAIL            1296
#define IDS_LEFT_MULTI_OPPS             1297
#define IDS_LEFT_SERVICE_STOP           1298
#define IDS_LEFT_UNAVAILABLE            1299
#define IDS_BUTTON_OK                   1300
#define IDS_BUTTON_CANCEL               1301
#define IDS_BUTTON_YES                  1302
#define IDS_BUTTON_NEWOPP               1303
#define IDS_BUTTON_NO                   1304
#define IDS_BUTTON_QUIT                 1305
#define IDS_BUTTON_RETRY                1306
#define IDS_BUTTON_IGNORE               1307
#define IDS_BUTTON_HELP                 1308
#define IDS_LEFT_UNAVAILABLE2           1309
#define IDS_ERROR_UNKNOWN               1312
#define IDS_ERROR_MEMORY                1313
#define IDS_ERROR_RESOURCE              1314
#define IDS_ERROR_SYNC                  1315
#define IDS_SHUTDOWN_A                  1317
#define IDS_SHUTDOWN_B                  1318
#define IDS_SHUTDOWN_C                  1319
#define IDS_PROMPT_EXIT                 1320
#define IDS_PROMPT_NEWOPP2              1321
#define IDS_PROMPT_NEWOPP4              1322
#define IDS_PROMPT_NEWOPP_TITLE2        1323
#define IDS_PROMPT_NEWOPP_TITLE4        1324
#define IDS_ALERT_TITLE_FMT             1325
#define IDS_INTERR_CANNOT_START         1326
#define IDS_VERFAIL_GENERIC             1328
#define IDS_VERFAIL_URL                 1329
#define IDS_VERFAIL_WINUPD              1330
#define IDS_VERFAIL_PACKAGED            1331
#define IDS_VERFAIL_BUTTON              1332
#define IDS_MINUTES                     1334
#define IDS_HOURS                       1335
#define IDS_SKILLLEVEL_WARNING          1336
#define IDS_SKILLLEVEL_WARN_TTL         1337
#define IDS_QUASICHAT_PROMPT            1400
#define IDS_QUASICHAT_1                 1401
#define IDS_QUASICHAT_2                 1402
#define IDS_QUASICHAT_3                 1403
#define IDS_QUASICHAT_4                 1404
#define IDS_QUASICHAT_5                 1405
#define IDS_QUASICHAT_6                 1406
#define IDS_QUASICHAT_7                 1407
#define IDS_QUASICHAT_8                 1408
#define IDS_QUASICHAT_9                 1409
#define IDS_QUASICHAT_10                1410
#define IDS_QUASICHAT_11                1411
#define IDS_QUASICHAT_12                1412
#define IDS_QUASICHAT_13                1413
#define IDS_QUASICHAT_14                1414
#define IDS_QUASICHAT_15                1415
#define IDS_QUASICHAT_16                1416
#define IDS_QUASICHAT_17                1417
#define IDS_QUASICHAT_18                1418
#define IDS_QUASICHAT_19                1419
#define IDS_QUASICHAT_20                1420
#define IDS_QUASICHAT_21                1421
#define IDS_QUASICHAT_22                1422
#define IDS_QUASICHAT_23                1423
#define IDS_QUASICHAT_24                1424
#define IDS_QUASICHAT_LAST              1425
#define IDS_CHECKERS_1                  1440
#define IDS_CHECKERS_2                  1441
#define IDS_CHECKERS_3                  1442
#define IDS_CHECKERS_4                  1443
#define IDS_SPADES_1                    1450
#define IDS_SPADES_2                    1451
#define IDS_SPADES_3                    1452
#define IDS_SPADES_4                    1453
#define IDS_SPADES_5                    1454
#define IDS_HEARTS_1                    1460
#define IDS_HEARTS_2                    1461
#define IDS_HEARTS_3                    1462
#define IDS_REVERSI_1                   1470
#define IDS_REVERSI_2                   1471
#define IDS_REVERSI_3                   1472
#define IDS_REVERSI_4                   1473
#define IDS_BACKGAMMON_1                1480
#define IDS_BACKGAMMON_2                1481
#define IDS_BACKGAMMON_3                1482
#define ID_GAME_SKILLLEVEL              1500
#define ID_GAME_TURNCHATON              1501
#define ID_GAME_EXIT_APP                1502
#define ID_GAME_FINDNEWOPPONENT         1503
#define ID_HELP_GAMEONTHEWEB            1504
#define ID_HELP_ABOUTGAME               1505
#define ID_HELP_HELPTOPICS              1506
#define ID_GAME_SKILLLEVEL_BEGINNER     1507
#define ID_GAME_SKILLLEVEL_INTERMEDIATE 1508
#define ID_GAME_SKILLLEVEL_EXPERT       1509
#define ID_GAME_SOUND                   1510
#define ID_GAME_SCORE                   1511
#define ID_HOTKEY_SHOWFOCUS             1550
#define IDM_CHAT_CLEAR                  1570
#define IDM_CHAT_CHOOSE_FONT            1571
#define IDM_UNDO                        1572
#define IDM_CUT                         1573
#define IDM_COPY                        1574
#define IDM_PASTE                       1575
#define IDM_DELETE                      1576
#define IDM_SELECTALL                   1577
#define ID_CHAT_SEND                    1599
#define ID_CHAT_HISTORY_ACC             1600
#define ID_CHAT_SEND_ACC                1601
#define ID_CHAT_ON_ACC                  1602
#define ID_CHAT_OFF_ACC                 1603
#define ID_CHAT_CHAT_ACC                1604
#define IDC_SHOW_AGAIN                  1750
#define IDC_SPLASH_TEXT                 1751
#define IDC_SPLASH_TEXT2                1752
#define IDC_SPLASH_TEXT3                1753
#define IDC_KEEP_COMFORTING             1754
#define IDC_SPLASH_IMAGE                1755
#define IDC_SPLASH_ANIM                 1756
#define IDC_PLAYER1_TEXT                1800
#define IDC_PLAYER2_TEXT                1801
#define IDC_PLAYER3_TEXT                1802
#define IDC_PLAYER4_TEXT                1803
#define IDC_BULLET1                     1805
#define IDC_BULLET2                     1806
#define IDC_BULLET3                     1807
#define IDC_BULLET4                     1808
#define IDC_PLUG_IE_DEFAULT             1809
#define IDC_PLUG_IE_DOWNLOAD            1810
#define IDR_HTML_UPSELL                 1811
#define IDC_CRED_TITLE                  1812
#define IDC_CRED_T1                     1813
#define IDC_CRED_P1                     1814
#define IDC_CRED_T2                     1815
#define IDC_CRED_P2                     1816
#define IDC_CRED_T3                     1817
#define IDC_CRED_P3                     1818
#define IDC_CRED_T4                     1819
#define IDC_CRED_P4                     1820
#define IDC_CRED_ICON                   1821
#define IDC_CRED_ICON_FRAME             1822
#define IDC_ALERTBOX_ICON               1823

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1182
#define _APS_NEXT_COMMAND_VALUE         1602
#define _APS_NEXT_CONTROL_VALUE         1824
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\spadesres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by E:\ZM\RESOURCES\spades\generic\SpadesRes.rc
//
#define IDB_OBJECTS                     10100
#define IDB_CARDBACK                    10101
#define IDB_GAMEOVERBACKGROUND          10108
#define IDB_HANDOVERBACKGROUND          10109
#define IDB_BIDDINGOBJECTS              10127
#define IDS_DOUBLENILBIDSTR             10203
#define IDS_PLAY                        10205
#define IDS_AUTOPLAY                    10207
#define IDS_STOP                        10208
#define IDS_SCORE                       10209
#define IDS_LASTTRICK                   10210
#define IDS_TEAM1NAME                   10211
#define IDS_TEAM2NAME                   10212
#define IDS_CANTLEADSPADES              10213
#define IDS_MUSTFOLLOWSUIT              10214
#define IDS_TRICKCOUNTER                10216
#define IDS_DONE                        10217
#define IDS_SELECTCARD                  10223
#define IDS_HANDSCORE_TITLE             10253
#define IDS_HANDSCORE_TRICKS            10254
#define IDS_HANDSCORE_NBAGS             10255
#define IDS_HANDSCORE_TRACT             10256
#define IDS_HANDSCORE_BONUS             10257
#define IDS_HANDSCORE_NIL               10258
#define IDS_HANDSCORE_BAGS              10259
#define IDS_GAMEOVER_TITLE              10260
#define IDS_BIDDING_SHOWCARDS           10261
#define IDS_BIDDING_DOUBLENIL           10262
#define IDS_BIDDING_OPENTEXT            10263
#define IDS_BIDDING_CHOOSETEXT          10264
#define IDS_BIDDING_NIL                 10265
#define IDS_HISTORY_HANDS               10266
#define IDS_HISTORY_TOTAL               10267
#define IDS_SPADES_YOU                  10268
#define IDI_BAG                         10600
#define IDI_BLANK                       10601
#define IDI_SPADE                       10602
#define IDD_SCORES                      10603
#define IDC_SCORES_TEAM1HANDS           10607
#define IDC_SCORES_TEAM2HANDS           10608
#define IDR_SPADES_ACCELERATOR_DONE     10699
#define IDR_SPADES_ACCELERATOR_DOUBLE   10700
#define IDC_LAST_TRICK_BUTTON			10701
#define IDC_SCORE_BUTTON				10702
#define IDC_PLAY_BUTTON					10703
#define IDC_AUTOPLAY_BUTTON				10704
#define IDC_STOP_BUTTON					10705
#define IDC_DONE_BUTTON					10706
#define IDC_SHOW_CARDS_BUTTON			10708
#define IDC_DOUBLE_NIL_BUTTON			10709
#define IDC_HAND                        10710
#define IDC_CLOSE_BOX                   10711


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10129
#define _APS_NEXT_COMMAND_VALUE         10261
#define _APS_NEXT_CONTROL_VALUE         10531
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\backgammonres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\millennium\RESOURCES\Backgammon\generic\BackgammonRes.rc
//
#define IDRESET                         14001
#define IDS_INIT_ROLL_TIE               14003
#define IDS_INIT_ROLL_WIN               14004
#define IDS_INIT_ROLL_LOSS              14005
#define IDS_VERSION                     14006
#define IDS_NOTATION_WHITE              14007
#define IDS_NOTATION_BROWN              14008
#define IDS_MISS                        14009
#define IDS_WON                         14010
#define IDS_LOST                        14011
#define IDS_OFFER_DOUBLE                14012
#define IDS_ACCEPTED_DOUBLE             14013
#define IDS_WON_RESIGN                  14014
#define IDS_MATCH_POINTS                14015
#define IDS_MATCH_RESET                 14016
#define IDS_RESIGN_WAIT                 14017
#define IDS_RESIGN_REFUSED              14018
#define IDS_MISS_KIBITZER               14019
#define IDS_PIPS                        14020
#define IDS_SCORE                       14021
#define IDS_BUTTON_DOUBLE               14022
#define IDS_BUTTON_RESIGN               14023
#define IDS_BUTTON_ROLL                 14024
#define IDS_GAME_WON                    14025
#define IDS_GAME_LOST                   14026
#define IDS_MATCH_WON                   14027
#define IDS_MATCH_LOST                  14028
#define IDS_MATCH                       14029
#define IDS_RESIGN_POINT                14030
#define IDS_RESIGN_POINTS               14031
#define IDS_DOUBLE_POINT                14032
#define IDS_DOUBLE_POINTS               14033
#define IDR_MENU                        14101
#define IDR_MENU_DEBUG                  14108
#define IDB_PIECES                      14113
#define IDB_MEDIUM_DICE                 14118
#define IDB_SMALL_DICE                  14119
#define IDR_BOARD_RECTS                 14120
#define IDD_ROLL_DICE                   14123
#define IDC_HAND                        14124
#define IDB_BIG_DICE                    14126
#define IDB_HIGHLIGHT                   14127
#define IDB_RESIGN_BUTTON               14129
#define IDB_DOUBLE_BUTTON               14130
#define IDB_BUTTON                      14130
#define IDB_BROWN_FRONT                 14138
#define IDB_WHITE_FRONT                 14139
#define IDB_CUBE                        14141
#define IDD_OFFER_DOUBLE                14142
#define IDD_ACCEPT_DOUBLE               14143
#define IDB_WHITE_SIDE                  14144
#define IDB_BROWN_SIDE                  14145
#define IDB_TEXT                        14148
#define IDR_SOUND_DICE                  14162
#define IDR_SOUND_PLACE                 14163
#define IDR_SOUND_LOSE                  14164
#define IDR_SOUND_WIN                   14167
#define IDR_SOUND_BUTTON_DOWN           14168
#define IDR_SOUND_ALERT                 14169
#define IDR_SOUND_MATCH_WIN             14171
#define IDR_SOUND_MATCH_LOSE            14172
#define IDR_SOUND_HIT                   14173
#define IDB_STATUS_BACKGROUND           14176
#define IDB_KIBITZER                    14180
#define IDR_SOUND_ROLL                  14185
#define IDB_NOTATION                    14186
#define IDB_STATUS_MATCHLOST            14187
#define IDB_STATUS_MATCHWON             14188
#define IDB_STATUS_MATCHOVER            14190
#define IDB_STATUS_GAMEWON              14191
#define IDB_STATUS_GAMELOST             14193
#define IDB_STATUS_GAME                 14193
#define IDB_STATUS_GAMEOVER             14194
#define IDD_RESIGN                      14195
#define IDD_RESIGN_ACCEPT               14196
#define IDR_SOUND_BUTTON_HIGHLIGHT      14198
#define IDB_BUTTON_ROLL                 14210
#define IDB_BACKROUND                   14211
#define IDB_STATUS_BACKROUND            14220
#define IDB_DIAMOND                     14228
#define IDB_HIGHLIGHT_PLAYER            14240
#define IDR_PREROLL_ACCELERATORS        14241
#define IDR_MOVE_ACCELERATORS           14242
#define IDC_BROWN                       14505
#define IDC_POINTS                      14508
#define IDC_DICE_ONE                    14508
#define IDC_POINTS_UPDOWN               14509
#define IDC_DICE_TWO                    14519
#define IDCANCELMATCH                   14519
#define IDC_AUTO                        14520
#define IDC_ACCEPT_MESSAGE              14522
#define IDC_NOTATION                    14525
#define IDC_NOTATION_PANE               14526
#define IDC_PIP                         14527
#define IDC_MOVES                       14528
#define IDC_PLAYER_NAME                 14528
#define IDC_ANIMATE                     14529
#define IDC_PLAYER_ALLOW                14529
#define IDC_OPPONENT_NAME               14530
#define IDC_ALERT                       14530
#define IDC_PLAYER_SILENCE              14531
#define IDC_SOUNDS                      14531
#define IDC_OPPONENT_ALLOW              14532
#define IDC_DESCRIPTION                 14532
#define IDC_OPPONENT_SILENCE            14533
#define IDC_COPYRIGHT                   14533
#define IDC_VERSION                     14534
#define IDC_RESTORE_MSG                 14535
#define IDC_MESSAGE_TXT                 14537
#define IDC_DUMMY_BUTTON                14538
#define IDC_POINTS_TAG                  14539
#define IDC_CUBE                        14540
#define IDC_GAMMON                      14541
#define IDC_BACKGAMMON                  14542
#define IDC_RESIGN_TEXT                 14545
#define IDC_DOUBLE_BUTTON               14546
#define IDC_RESIGN_BUTTON               14547
#define IDC_ROLL_BUTTON                 14548
#define IDC_NOTATION_LV                 14549
#define IDC_ESC                         14550
#define IDC_GAME_WINDOW                 14551
#define ID_GAME_EXIT                    14804
#define ID_DEBUG_ROLLDICE               14806

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        14243
#define _APS_NEXT_COMMAND_VALUE         14813
#define _APS_NEXT_CONTROL_VALUE         14546
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\reversi\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\include\checkersres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by E:\ZM\RESOURCES\spades\generic\game.rc
//
/* string ids*/
//#define IDS_UI_BUTTON_RED				12000
//#define IDS_UI_BUTTON_WHITE			12001
#define IDS_UI_MSG_OPPONENT_TURN		12002
//#define IDS_DLG_CAPTION				12003
#define IDS_UI_MSG_DRAW_PEND		    12004
#define IDS_DLG_DRAW_OFFER				12005
#define IDS_DLG_DRAW_REJECT				12006
//#define IDS_DLG_DRAW_ACCEPT			12007
//#define IDS_DLG_YES					12008
//#define IDS_DLG_NO					12009
//#define IDS_DLG_OK					12010
#define IDS_DRAW_PANE_TEXT				12011
#define IDS_GAME_OVER_TEXT				12012
#define IDS_MUST_JUMP_TEXT				12013
#define IDS_DLGDRAW_OFFER_TITLE			12014
#define IDS_DLGDRAW_ACCEPT_TITLE		12015
#define IDS_BTN_RESIGN					12016
#define IDS_BTN_DRAW					12017
#define IDS_UI_MSG_YOUR_TURN			12018

#define IDS_RESIGN_CONFIRM				12224
#define IDS_RESIGN_CONFIRM_CAPTION		12225

/* bitmap ids*/
#define IDB_BKGND						12100
#define IDB_RED							12101
#define IDB_REDQN						12102
#define IDB_WHITE						12103
#define IDB_WHITEQN						12104
#define IDB_REDNAME						12105
#define IDB_WHITENAME					12106
#define IDB_REDMARK						12107
#define IDB_WHITEMARK					12108
#define IDB_DRAWBTN						12109

#define IDB_DRAG_PATTERN                12117
#define IDB_RESIGN_BUTTON				12118 	
#define IDB_DRAW_BUTTON					12119 	
 		
// cmd Id reqd for Accelerator enabled objects
#define IDR_CHECKERSACCELERATOR			12120
#define IDC_RESIGN_BUTTON				12150
#define IDC_DRAW_BUTTON					12151
#define IDC_GAME_WINDOW					12152
#define IDC_RESULT_WINDOW				12153

// Next default values for new objects
// 		
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12200 //101
#define _APS_NEXT_COMMAND_VALUE         12500 //40001
#define _APS_NEXT_CONTROL_VALUE         12900 //1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\spades\generic\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\resources\spades\twentyfour\main.cpp ===
#include <windows.h>


extern "C"
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{

	if (dwReason == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls(hMod);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\accessibilitymanager\caccessibilitymanager.h ===
//
// CAccessibilityManager.h
//
// Internal header for input manager
//

#ifndef _CACCESSIBILITYMANAGER_H_
#define _CACCESSIBILITYMANAGER_H_

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ClientImpl.h"
#include "AccessibilityManager.h"
#include "ZoneShellEx.h"
#include "inputmanager.h"
#include "containers.h"


typedef void* ZHACCESS;

////////////////////////////////////////////////////////////////////////////////
// IAccessibilityManager
//
// Used by the accessibility sub-components to communicate to the Manager.
///////////////////////////////////////////////////////////////////////////////

// {B12D3E61-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IAccessibilityManager, 
0xb12d3e61, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E61-9681-11d3-884D-00C04F8EF45B}"))
IAccessibilityManager : public IUnknown
{
    STDMETHOD_(ZHACCESS, Register)(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie = NULL) = 0;
    STDMETHOD_(void, Unregister)(ZHACCESS zh) = 0;

    // copies from IAccessibility with extra ZHACCESS thing
    STDMETHOD(PushItemlist)(ZHACCESS zh, ACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL) = 0;
    STDMETHOD(PopItemlist)(ZHACCESS zh) = 0;
    STDMETHOD(SetAcceleratorTable)(ZHACCESS zh, HACCEL hAccel = NULL, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(GeneralDisable)(ZHACCESS zh) = 0;
    STDMETHOD(GeneralEnable)(ZHACCESS zh) = 0;
    STDMETHOD_(bool, IsGenerallyEnabled)(ZHACCESS zh) = 0;

    STDMETHOD_(long, GetStackSize)(ZHACCESS zh) = 0;

    STDMETHOD(AlterItem)(ZHACCESS zh, DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetFocus)(ZHACCESS zh, long nItem = ZACCESS_InvalidItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(CancelDrag)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(long, GetFocus)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetDragOrig)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(GetItemlist)(ZHACCESS zh, ACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(HACCEL, GetAcceleratorTable)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(long, GetItemCount)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(GetItem)(ZHACCESS zh, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemIndex)(ZHACCESS zh, WORD wID, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(bool, IsItem)(ZHACCESS zh, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(GetGlobalFocus)(DWORD *pdwFocusID) = 0;
    STDMETHOD(SetGlobalFocus)(DWORD dwFocusID) = 0;
};


class ATL_NO_VTABLE CAccessibility :
    public CAccessibilityImpl<CAccessibility>,
    public CComTearOffObjectBase<CAccessibilityManager>
{
public:
    CAccessibility() : m_zh(NULL) { }
    ~CAccessibility() { CloseAcc(); }

	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CAccessibility)
		COM_INTERFACE_ENTRY(IAccessibility)
	END_COM_MAP()

// IAccessibility
    STDMETHOD(InitAcc)(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie = NULL);
    STDMETHOD_(void, CloseAcc)();

    STDMETHOD(PushItemlist)(ACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL);
    STDMETHOD(PopItemlist)();
    STDMETHOD(SetAcceleratorTable)(HACCEL hAccel = NULL, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GeneralDisable)();
    STDMETHOD(GeneralEnable)();
    STDMETHOD_(bool, IsGenerallyEnabled)();

    STDMETHOD_(long, GetStackSize)();

    STDMETHOD(AlterItem)(DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(SetFocus)(long nItem = ZACCESS_InvalidItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(CancelDrag)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetFocus)(long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetDragOrig)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetItemlist)(ACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(HACCEL, GetAcceleratorTable)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetItemCount)(long nLayer = ZACCESS_TopLayer);
    STDMETHOD(GetItem)(ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetItemIndex)(WORD wID, long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(bool, IsItem)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetGlobalFocus)(DWORD *pdwFocusID);
    STDMETHOD(SetGlobalFocus)(DWORD dwFocusID);


protected:
    ZHACCESS m_zh;
};


class ATL_NO_VTABLE CAccessibilityManager :
	public IAcceleratorTranslator,
    public IAccessibilityManager,
    public IInputVKeyHandler,
    public IAccessibleControl,
	public IZoneShellClientImpl<CAccessibilityManager>,
	public IEventClientImpl<CAccessibilityManager>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAccessibilityManager, &CLSID_AccessibilityManager>
{
public:
    CAccessibilityManager() : m_pControls(NULL) { }
    ~CAccessibilityManager() { ASSERT(!m_pControls); }

	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CAccessibilityManager)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IAcceleratorTranslator)
        COM_INTERFACE_ENTRY(ICommandHandler)
        COM_INTERFACE_ENTRY(IAccessibilityManager)
        COM_INTERFACE_ENTRY(IInputVKeyHandler)
        COM_INTERFACE_ENTRY(IAccessibleControl)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IAccessibility, CAccessibility)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
        EVENT_HANDLER(EVENT_LOBBY_BOOTSTRAP, OnBootstrap)
        EVENT_HANDLER(EVENT_ACCESSIBILITY_UPDATE, OnUpdate)
        EVENT_HANDLER_WITH_DATA(EVENT_UI_FRAME_ACTIVATE, OnFrameActivate)
	END_EVENT_MAP()

// event handlers
    void OnBootstrap(DWORD eventId, DWORD groupId, DWORD userId);
    void OnUpdate(DWORD eventId, DWORD groupId, DWORD userId);
    void OnFrameActivate(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2);

// IZoneShellClient
public:
    STDMETHOD(Init)(IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey);
	STDMETHOD(Close)();

// IAcceleratorTranslator
public:
	STDMETHOD_(bool,TranslateAccelerator)(MSG *pMsg);
    STDMETHOD(Command)(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled);

// IInputVKeyHandler
public:
    STDMETHOD_(bool, HandleVKey)(UINT uMsg, DWORD vkCode, DWORD scanCode, DWORD flags, DWORD *pcRepeat, DWORD time);

// IAccessibilityManager
public:
    STDMETHOD_(ZHACCESS, Register)(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie = NULL);
    STDMETHOD_(void, Unregister)(ZHACCESS zh);

    STDMETHOD(PushItemlist)(ZHACCESS zh, ACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL);
    STDMETHOD(PopItemlist)(ZHACCESS zh);
    STDMETHOD(SetAcceleratorTable)(ZHACCESS zh, HACCEL hAccel = NULL, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GeneralDisable)(ZHACCESS zh);
    STDMETHOD(GeneralEnable)(ZHACCESS zh);
    STDMETHOD_(bool, IsGenerallyEnabled)(ZHACCESS zh);

    STDMETHOD_(long, GetStackSize)(ZHACCESS zh);

    STDMETHOD(AlterItem)(ZHACCESS zh, DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(SetFocus)(ZHACCESS zh, long nItem = ZACCESS_InvalidItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(CancelDrag)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetFocus)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetDragOrig)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetItemlist)(ZHACCESS zh, ACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(HACCEL, GetAcceleratorTable)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetItemCount)(ZHACCESS zh, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(GetItem)(ZHACCESS zh, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetItemIndex)(ZHACCESS zh, WORD wID, long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(bool, IsItem)(ZHACCESS zh, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetGlobalFocus)(DWORD *pdwFocusID);
    STDMETHOD(SetGlobalFocus)(DWORD dwFocusID);

// IAccessibleControl (null default implementation)
public:
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie) { return 0; }
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie) { return 0; }
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie) { return 0; }
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie) { return 0; }

protected:

// local structures
    struct AM_ITEM : public CUniqueness<AM_ITEM>
    {
        ACCITEM o;
        bool fArrowLoop;
    };

    struct AM_LAYER : public CUniqueness<AM_LAYER>
    {
        AM_LAYER() : hAccel(NULL), fIMadeAccel(false), rgItems(NULL), cItems(0), pPrev(NULL) { }
        ~AM_LAYER()
        {
            if(rgItems)
                delete[] rgItems;
            if(hAccel && fIMadeAccel)
                DestroyAcceleratorTable(hAccel);
        }

        HACCEL hAccel;
        bool fIMadeAccel;

        AM_ITEM *rgItems;
        long cItems;

        long nFocusSaved;
        bool fAliveSaved;
        long nDragSaved;

        AM_LAYER *pPrev;
    };

    struct AM_CONTROL : public CUniqueness<AM_CONTROL>
    {
        AM_CONTROL() : pStack(NULL), cLayers(0) { }
        ~AM_CONTROL()
        {
            AM_LAYER *pCur, *p;
            for(pCur = pStack; pCur; )
            {
                p = pCur;
                pCur = pCur->pPrev;
                delete p;
            }
        }

        CComPtr<IAccessibleControl> pIAC;
        UINT nOrdinal;
        void *pvCookie;

        AM_LAYER *pStack;
        long cLayers;

        bool fEnabled;

        AM_CONTROL *pNext;
        AM_CONTROL *pPrev;
    };

    struct AM_FOCUS
    {
        AM_FOCUS() : pControl(NULL) { }

        AM_CONTROL *pControl;
        long nIndex;
        DWORD qItem;

        bool fAlive;
    };

    struct AM_DRAG
    {
        AM_DRAG() : pControl(NULL) { }

        AM_CONTROL *pControl;
        long nIndex;
        DWORD qItem;
    };

// local utilities
    void CanonicalizeItem(AM_LAYER *pLayer, long i);
    AM_LAYER* FindLayer(AM_CONTROL *pControl, long nLayer);
    long FindIndex(AM_LAYER *pLayer, long nItem, bool fByPosition);

    bool IsValid(AM_CONTROL *pControl, long nIndex);
    bool IsFocusValid();
    bool IsDragValid();
    bool IsThereItems();
    bool IsItemFocusable(AM_CONTROL *pControl, long nIndex);
    bool IsWindowActive();
    bool IsValidDragDest(AM_CONTROL *pControl, long nIndex);

    void CommandReceived_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext);
    void ActSelItem_C(AM_CONTROL *pControl, long nIndex, bool fActivate, DWORD rgfContext);
    bool FocusItem_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext);
    void BeginDrag_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext);
    void DoTab_C(bool fShift);
    void DoArrow_C(long ACCITEM::*pmArrow);

    void ScheduleUpdate();
    bool DoUpdate_C();

// local state
    AM_CONTROL *m_pControls;
    AM_FOCUS m_oFocus;  // where is the focus?
    AM_DRAG m_oDrag;

    bool m_fUpdateNeeded;
    bool m_fUpdateFocus;
    DWORD m_rgfUpdateContext;
    AM_FOCUS m_oFocusDirty;
    AM_DRAG m_oDragDirty;
};


#endif // _CACCESSIBILITYMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\accessibilitymanager\caccessibilitymanager.cpp ===
#include <ZoneResource.h>
#include <BasicATL.h>
#include <ATLFrame.h>
#include "CAccessibilityManager.h"
#include "ZoneShell.h"


#define ZH ((AM_CONTROL *) zh)

///////////////////////////////////////////////////////////////////////////////
// Interface methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAccessibilityManager::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CAccessibilityManager>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

    // register with the shell as the accelerator translator
    ZoneShell()->SetAcceleratorTranslator(this);

	return S_OK;
}


void CAccessibilityManager::OnBootstrap(DWORD eventId, DWORD groupId, DWORD userId)
{
    CComPtr<IInputManager> pIIM;

    HRESULT hr = ZoneShell()->QueryService(SRVID_InputManager, IID_IInputManager, (void**) &pIIM);
    if(FAILED(hr))
        return;

    pIIM->RegisterVKeyHandler(this, 0);
}


void CAccessibilityManager::OnUpdate(DWORD eventId, DWORD groupId, DWORD userId)
{
    DoUpdate_C();
}


void CAccessibilityManager::OnFrameActivate(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
{
    if(!IsThereItems())
        return;

    ASSERT(IsFocusValid());
    ASSERT(IsDragValid());
    bool fActive = false;

    // WM_ACTIVATEAPP else WM_ACTIVATE
    if(dwData1)
    {
        if(dwData2)
            fActive = true;
    }
    else
    {
        if(LOWORD(dwData2) == WA_ACTIVE || LOWORD(dwData2) == WA_CLICKACTIVE)
            fActive = true;
    }

    if(fActive)
    {
        if(m_oFocus.fAlive || !IsItemFocusable(m_oFocus.pControl, m_oFocus.nIndex))
            return;

        m_fUpdateFocus = true;
        m_rgfUpdateContext = 0;

        if(!m_fUpdateNeeded)
        {
            m_fUpdateNeeded = true;

            m_oFocusDirty = m_oFocus;
            m_oDragDirty = m_oDrag;
        }

        m_oFocus.fAlive = true;
    }
    else
    {
        if(!m_oFocus.fAlive)
            return;

        m_fUpdateFocus = true;
        m_rgfUpdateContext = 0;

        if(!m_fUpdateNeeded)
        {
            m_fUpdateNeeded = true;

            m_oFocusDirty = m_oFocus;
            m_oDragDirty = m_oDrag;
        }

        m_oFocus.fAlive = false;
        m_oDrag.pControl = NULL;
    }

    DoUpdate_C();
}


STDMETHODIMP CAccessibilityManager::Close()
{
    CComPtr<IInputManager> pIIM;

    // tell the Input Manager that I'm going away
    HRESULT hr = ZoneShell()->QueryService(SRVID_InputManager, IID_IInputManager, (void**) &pIIM);
    if(SUCCEEDED(hr))
        pIIM->ReleaseReferences((IInputVKeyHandler *) this);

    // tell the shell that I'm going away
    ZoneShell()->ReleaseReferences((IAcceleratorTranslator *) this);

	return IZoneShellClientImpl<CAccessibilityManager>::Close();
}


STDMETHODIMP_(bool) CAccessibilityManager::HandleVKey(UINT uMsg, DWORD vkCode, DWORD scanCode, DWORD flags, DWORD *pcRepeat, DWORD time)
{
    if(uMsg != WM_KEYDOWN)
        return false;

    // if our app doesn't even have an active window just punt
    HWND hWndActive = ::GetActiveWindow();
    if(!hWndActive)
        return false;

    // app-wide accessibility (F6) - this is the only thing that is not AccessibleControl-based
    // after I set this up I realized that Windows handles Alt-F6 to do exatly the same thing.  o well.
    if(vkCode == VK_F6)
    {
        HWND hWndTop = ZoneShell()->FindTopWindow(hWndActive);
        if(!hWndTop)
            return false;

        HWND hWndNext;
        for(; *pcRepeat; (*pcRepeat)--)
        {
            // find the next window.  if there isn't another one, eat all the F6s
            hWndNext = ZoneShell()->GetNextOwnedWindow(hWndTop, hWndActive);
            if(hWndNext == hWndActive)
                return true;

            // if hWndActive was bad, switch it to hWndTop just to get into the loop
            if(!hWndNext)
                hWndActive = hWndNext = hWndTop;

            // if this one was bad, keep looking to find one
            while(!::IsWindow(hWndNext) || !::IsWindowVisible(hWndNext) || !::IsWindowEnabled(hWndNext))
            {
                hWndNext = ZoneShell()->GetNextOwnedWindow(hWndTop, hWndNext);

                // we looped, or something else bad happened so just die and eat all the F6s
                if(!hWndNext || hWndNext == hWndActive)
                    return true;
            }

            hWndActive = hWndNext;
        }

        BringWindowToTop(hWndActive);
        return true;
    }

    // besides F6, only trap input to the main window
    if(hWndActive != ZoneShell()->GetFrameWindow())
        return false;

    // send an event on control-tab
    if(vkCode == VK_TAB && (GetKeyState(VK_CONTROL) & 0x8000))
    {
        bool fShifted = ((GetKeyState(VK_SHIFT) & 0x8000) ? true : false);

        for(; *pcRepeat; (*pcRepeat)--)
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ACCESSIBILITY_CTLTAB, ZONE_NOGROUP, ZONE_NOUSER, (long) fShifted, 0);

        return true;
    }

    // this may be a weird time...
    DoUpdate_C();

    for(; *pcRepeat; (*pcRepeat)--)
    {
        if(!IsThereItems())
            return false;

        ASSERT(IsFocusValid());

        // find out if there's a key acceptance mask
        DWORD rgfWantKeys = 0;
        if(m_oFocus.fAlive)
            rgfWantKeys = m_oFocus.pControl->pStack->rgItems[m_oFocus.nIndex].o.rgfWantKeys;

        switch(vkCode)
        {
            // select
            case VK_SPACE:
                if(rgfWantKeys & ZACCESS_WantSpace)
                    return false;

                if(m_oFocus.fAlive)
                    ActSelItem_C(m_oFocus.pControl, m_oFocus.nIndex, false, ZACCESS_ContextKeyboard);

                continue;

            // activate
            case VK_RETURN:
                if(rgfWantKeys & ZACCESS_WantEnter)
                    return false;

                if(m_oFocus.fAlive)
                    ActSelItem_C(m_oFocus.pControl, m_oFocus.nIndex, true, ZACCESS_ContextKeyboard);

                continue;

            // drag cancel
            case VK_ESCAPE:
            {
                if(rgfWantKeys & ZACCESS_WantEsc)
                    return false;

                if(!m_oDrag.pControl)
                    return false;

                ASSERT(!m_fUpdateNeeded);
                ASSERT(IsDragValid());

                AM_CONTROL *pLastControl = m_oDrag.pControl;
                m_oDrag.pControl = NULL;
                pLastControl->pIAC->Drag(ZACCESS_InvalidItem, m_oDrag.nIndex, ZACCESS_ContextKeyboard, pLastControl->pvCookie);

                DoUpdate_C();

                continue;
            }

            case VK_TAB:
            {
                bool fShifted = ((GetKeyState(VK_SHIFT) & 0x8000) ? true : false);
                if(rgfWantKeys & (fShifted ? ZACCESS_WantShiftTab : ZACCESS_WantPlainTab))
                    return false;

                DoTab_C(fShifted);
                continue;
            }

            case VK_UP:
                if(rgfWantKeys & ZACCESS_WantArrowUp)
                    return false;

                DoArrow_C(&ACCITEM::nArrowUp);
                continue;

            case VK_DOWN:
                if(rgfWantKeys & ZACCESS_WantArrowDown)
                    return false;

                DoArrow_C(&ACCITEM::nArrowDown);
                continue;

            case VK_LEFT:
                if(rgfWantKeys & ZACCESS_WantArrowLeft)
                    return false;

                DoArrow_C(&ACCITEM::nArrowLeft);
                continue;

            case VK_RIGHT:
                if(rgfWantKeys & ZACCESS_WantArrowRight)
                    return false;

                DoArrow_C(&ACCITEM::nArrowRight);
                continue;
        }

        return false;
    }

    // we must have eaten them all
    return true;
}


STDMETHODIMP_(bool) CAccessibilityManager::TranslateAccelerator(MSG *pMsg)
{
    HWND hWnd = ZoneShell()->GetFrameWindow();

    // uh oh, nowhere to send commands or no commands or not the active window
    if(!hWnd || !IsThereItems() || hWnd != ::GetActiveWindow())
        return false;

    // loop through accelerator tables and see what's there
    AM_CONTROL *pCur = m_pControls;
    while(true)
    {
        if(pCur->pStack && pCur->pStack->hAccel && pCur->fEnabled)
			if(::TranslateAccelerator(hWnd, pCur->pStack->hAccel, pMsg))
				return true;

        pCur = pCur->pNext;
        if(pCur == m_pControls)
            break;
    }

    return false;
}


STDMETHODIMP CAccessibilityManager::Command(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled)
{
    long i;

    DoUpdate_C();

    if(wID == ZACCESS_InvalidCommandID)
        return S_OK;

    // check if this command should activate anything
    AM_CONTROL *pCur = m_pControls;
    while(true)
    {
        if(pCur->pStack && pCur->fEnabled)
            for(i = 0; i < pCur->pStack->cItems; i++)
                if(pCur->pStack->rgItems[i].o.wID == wID)
                {
                    CommandReceived_C(pCur, i, (wNotify == 1) ? ZACCESS_ContextKeyboard : 0);
                    return S_OK;
                }

        pCur = pCur->pNext;
        if(pCur == m_pControls)
            break;
    }

    return S_OK;
}


STDMETHODIMP_(ZHACCESS) CAccessibilityManager::Register(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie)
{
    if(!m_fRunning)
        return NULL;

    AM_CONTROL *pControl = new AM_CONTROL;
    if(!pControl)
        return NULL;

    // you can not give an acessible control if you don't want any callbaks.
    if(pAC)
    {
        pControl->pIAC = pAC;
        pControl->pvCookie = pvCookie;
    }
    else
    {
        // if not supplied, use our internal (NULL) implementation
        pControl->pIAC = this;
        pControl->pvCookie = (void *) pControl;
    }

    pControl->nOrdinal = nOrdinal;

    // need to treat the first one special to set up the loop
    if(!m_pControls)
    {
        m_pControls = pControl;
        pControl->pNext = pControl;
        pControl->pPrev = pControl;
    }
    else
    {
        AM_CONTROL *pCur;
        for(pCur = m_pControls->pPrev; nOrdinal < pCur->nOrdinal; pCur = pCur->pPrev)
            if(pCur == m_pControls)
            {
                m_pControls = pControl;
                pCur = pCur->pPrev;
                break;
            }
        pControl->pNext = pCur->pNext;
        pControl->pPrev = pCur;
        pControl->pNext->pPrev = pControl;
        pControl->pPrev->pNext = pControl;
    }

    pControl->fEnabled = true;
    return pControl;
}


STDMETHODIMP_(void) CAccessibilityManager::Unregister(ZHACCESS zh)
{
    // remove from circle
    AM_CONTROL *pOldNext = ZH->pNext;

    if(m_pControls == ZH)
        m_pControls = ZH->pNext;
    ZH->pNext->pPrev = ZH->pPrev;
    ZH->pPrev->pNext = ZH->pNext;
    if(m_pControls == ZH)
        m_pControls = NULL;

    delete ZH;

    if(IsThereItems())
    {
        if(m_oFocus.pControl == ZH)
        {
            ASSERT(!IsFocusValid());
            ASSERT(pOldNext && pOldNext != ZH);

            AM_CONTROL *pControl = pOldNext;
            while(true)
            {
                if(pControl->pStack && pControl->pStack->cItems)
                {
                    ScheduleUpdate();

                    m_oFocus.pControl = pControl;
                    m_oFocus.nIndex = pControl->pStack->rgItems[0].o.nGroupFocus;
                    m_oFocus.qItem = pControl->pStack->rgItems[m_oFocus.nIndex].GetQ();
                    m_oFocus.fAlive = false;
                    ASSERT(IsFocusValid());

                    break;
                }

                pControl = pControl->pNext;
                ASSERT(pControl != pOldNext);
            }
        }

        if(m_oDrag.pControl == ZH)
        {
            ASSERT(!IsDragValid());
            ScheduleUpdate();

            m_oDrag.pControl = NULL;
        }
    }
    else
    {
        m_oFocus.pControl = NULL;
        m_oDrag.pControl = NULL;
    }
}


STDMETHODIMP CAccessibilityManager::PushItemlist(ZHACCESS zh, ACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel)
{
    if(!m_fRunning)
        return E_FAIL;

    AM_LAYER *pLayer = new AM_LAYER;
    if(!pLayer)
        return E_OUTOFMEMORY;

    pLayer->cItems = cItems;
    if(!cItems)
        pLayer->rgItems = NULL;
    else
    {
        pLayer->rgItems = new AM_ITEM[cItems];
        if(!pLayer->rgItems)
        {
            delete pLayer;
            return E_OUTOFMEMORY;
        }
    }

    long i;
    // first pass - copy
    for(i = 0; i < cItems; i++)
        pLayer->rgItems[i].o = pItems[i];

    // second pass - validate and adjust
    for(i = 0; i < cItems; i++)
    {
        ACCITEM *p = &pLayer->rgItems[i].o;

        // reconcile the two command IDs
        if(p->wID == ZACCESS_AccelCommandID)
            p->wID = (short) p->oAccel.cmd;  // force sign extension

        if(p->wID == ZACCESS_AccelCommandID)
        {
            p->oAccel.cmd = ZACCESS_InvalidCommandID;
            p->wID = ZACCESS_InvalidCommandID;
        }

        if(p->wID != ZACCESS_InvalidCommandID)
            p->wID &= 0xffffL;

        if(p->oAccel.cmd == (WORD) ZACCESS_AccelCommandID)
            p->oAccel.cmd = (WORD) p->wID;

        if(p->oAccel.cmd != p->wID || !p->oAccel.key)
            p->oAccel.cmd = ZACCESS_InvalidCommandID;

        // the first item is forced to be a tabstop
        if(!i)
            p->fTabstop = true;

        // resolve some generic things that also must be resolved each time the item is altered
        // like arrow behavior
        CanonicalizeItem(pLayer, i);
    }

    // third pass - make accelerator table
    pLayer->fIMadeAccel = false;
    if(!hAccel)
    {
        ACCEL *rgAccel = new ACCEL[cItems];
        if(!rgAccel)
        {
            delete pLayer;
            return E_OUTOFMEMORY;
        }

        long j = 0;
        for(i = 0; i < cItems; i++)
        {
            ACCITEM *p = &pLayer->rgItems[i].o;

            if(p->oAccel.cmd != (WORD) ZACCESS_InvalidCommandID)
            {
                ASSERT(p->wID == p->oAccel.cmd);  // should have been taken care of above
                rgAccel[j++] = p->oAccel;
            }
        }

        if(j)
        {
            hAccel = CreateAcceleratorTable(rgAccel, j);
            if(!hAccel)
            {
                delete[] rgAccel;
                delete pLayer;
                return E_FAIL;
            }
            pLayer->fIMadeAccel = true;
        }

        delete[] rgAccel;
    }
    pLayer->hAccel = hAccel;

    if(ZH->pStack && ZH->pStack->cItems)
    {
        ASSERT(IsFocusValid());

        if(m_oFocus.pControl == ZH)
        {
            ZH->pStack->nFocusSaved = m_oFocus.nIndex;
            ZH->pStack->fAliveSaved = m_oFocus.fAlive;
        }
        else
            ZH->pStack->nFocusSaved = ZACCESS_InvalidItem;

        ASSERT(IsDragValid());

        if(m_oDrag.pControl == ZH)
            ZH->pStack->nDragSaved = m_oDrag.nIndex;
        else
            ZH->pStack->nDragSaved = ZACCESS_InvalidItem;
    }

    pLayer->pPrev = ZH->pStack;
    ZH->pStack = pLayer;
    ZH->cLayers++;

    long nIndexFirstFocus = FindIndex(pLayer, nFirstFocus, fByPosition);

    if(IsThereItems() && !IsFocusValid())
    {
        ASSERT(m_oFocus.pControl == ZH || !m_oFocus.pControl);

        AM_CONTROL *pControl = ZH;
        while(true)
        {
            if(pControl->pStack && pControl->pStack->cItems)
            {
                ScheduleUpdate();

                m_oFocus.pControl = pControl;
                m_oFocus.nIndex = (nIndexFirstFocus != ZACCESS_InvalidItem ? nIndexFirstFocus : 0);
                m_oFocus.qItem = pControl->pStack->rgItems[m_oFocus.nIndex].GetQ();
                m_oFocus.fAlive = (nIndexFirstFocus != ZACCESS_InvalidItem);
                if(m_oFocus.fAlive && (!IsItemFocusable(m_oFocus.pControl, m_oFocus.nIndex) || !IsWindowActive()))
                    m_oFocus.fAlive = false;

                break;
            }

            pControl = pControl->pNext;
            ASSERT(pControl != ZH);
        }
    }

    if(!IsDragValid())
    {
        ASSERT(m_oDrag.pControl == ZH);
        m_oDrag.pControl = NULL;
    }

    return S_OK;
}


STDMETHODIMP CAccessibilityManager::PopItemlist(ZHACCESS zh)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!ZH->cLayers)
    {
        ASSERT(!ZH->pStack);
        return S_FALSE;
    }

    AM_LAYER *p = ZH->pStack;
    ZH->pStack = ZH->pStack->pPrev;
    delete p;
    ZH->cLayers--;

    if(IsThereItems())
    {
        if(m_oFocus.pControl == ZH)
        {
            ASSERT(!IsFocusValid());

            if(ZH->pStack && ZH->pStack->cItems && ZH->pStack->nFocusSaved != ZACCESS_InvalidItem)
            {
                // don't want a callback for this one
                if(m_fUpdateNeeded)
                    m_fUpdateFocus = false;

                m_oFocus.nIndex = ZH->pStack->nFocusSaved;
                m_oFocus.qItem = ZH->pStack->rgItems[m_oFocus.nIndex].GetQ();
                m_oFocus.fAlive = ZH->pStack->fAliveSaved;
            }
            else
            {
                AM_CONTROL *pControl = ZH;

                while(true)
                {
                    if(pControl->pStack && pControl->pStack->cItems)
                    {
                        ScheduleUpdate();

                        m_oFocus.pControl = pControl;
                        m_oFocus.nIndex = pControl->pStack->rgItems[0].o.nGroupFocus;
                        m_oFocus.qItem = pControl->pStack->rgItems[m_oFocus.nIndex].GetQ();
                        m_oFocus.fAlive = false;
                        ASSERT(IsFocusValid());

                        break;
                    }

                    pControl = pControl->pNext;
                    ASSERT(pControl != ZH);
                }
            }
        }

        if(m_oDrag.pControl == ZH || !m_oDrag.pControl)
        {
            ASSERT(!IsDragValid() || !m_oDrag.pControl);

            if(ZH->pStack && ZH->pStack->cItems && ZH->pStack->nDragSaved != ZACCESS_InvalidItem)
            {
                m_oDrag.pControl = ZH;
                m_oDrag.nIndex = ZH->pStack->nDragSaved;
                m_oDrag.qItem = ZH->pStack->rgItems[m_oDrag.nIndex].GetQ();

                if(!IsValidDragDest(m_oFocus.pControl, m_oFocus.nIndex))
                {
                    ScheduleUpdate();

                    m_oDrag.pControl = NULL;
                }
            }
            else
                if(m_oDrag.pControl)
                {
                    ScheduleUpdate();

                    m_oDrag.pControl = NULL;
                }
        }
    }
    else
    {
        m_oFocus.pControl = NULL;
        m_oDrag.pControl = NULL;
    }

    return S_OK;
}


STDMETHODIMP CAccessibilityManager::SetAcceleratorTable(ZHACCESS zh, HACCEL hAccel, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    if(pLayer->hAccel && pLayer->fIMadeAccel)
        DestroyAcceleratorTable(hAccel);

    pLayer->hAccel = hAccel;
    pLayer->fIMadeAccel = false;
    return S_OK;
}


STDMETHODIMP CAccessibilityManager::GeneralDisable(ZHACCESS zh)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!ZH->fEnabled)
        return S_FALSE;

    if(IsThereItems())
    {
        ASSERT(IsFocusValid());
        if(m_oFocus.fAlive && m_oFocus.pControl == ZH)
        {
            ScheduleUpdate();
            m_oFocus.fAlive = false;
        }

        ASSERT(IsDragValid());
        if(m_oDrag.pControl == ZH)
        {
            ScheduleUpdate();
            m_oDrag.pControl = NULL;
        }
    }

    ZH->fEnabled = false;
    return S_OK;
}


STDMETHODIMP CAccessibilityManager::GeneralEnable(ZHACCESS zh)
{
    if(!m_fRunning)
        return E_FAIL;

    if(ZH->fEnabled)
        return S_FALSE;

    ZH->fEnabled = true;
    if(IsThereItems())
    {
        ASSERT(IsFocusValid());
        if(m_oFocus.pControl == ZH && IsItemFocusable(ZH, m_oFocus.nIndex) && IsWindowActive())
        {
            ScheduleUpdate();
            m_oFocus.fAlive = true;
        }
    }

    return S_OK;
}


STDMETHODIMP_(bool) CAccessibilityManager::IsGenerallyEnabled(ZHACCESS zh)
{
    return ZH->fEnabled;
}


STDMETHODIMP_(long) CAccessibilityManager::GetStackSize(ZHACCESS zh)
{
    return ZH->cLayers;
}


STDMETHODIMP CAccessibilityManager::AlterItem(ZHACCESS zh, DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!pItem)
        return E_INVALIDARG;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    long nIndex = FindIndex(pLayer, nItem, fByPosition);
    if(nIndex == ZACCESS_InvalidItem)
        return E_INVALIDARG;

    ACCITEM *p = &pLayer->rgItems[nIndex].o;

    if((rgfWhat & ZACCESS_fEnabled) && p->fEnabled != pItem->fEnabled)
    {
        p->fEnabled = pItem->fEnabled;

        if(!p->fEnabled)
        {
            if(pLayer != ZH->pStack)
            {
                if(pLayer->nFocusSaved == nIndex)
                    pLayer->fAliveSaved = false;

                if(pLayer->nDragSaved == nIndex)
                    pLayer->nDragSaved = ZACCESS_InvalidItem;
            }
            else
            {
                if(IsThereItems())
                {
                    ASSERT(IsFocusValid());
                    if(m_oFocus.pControl == ZH && m_oFocus.nIndex == nIndex && m_oFocus.fAlive)
                    {
                        ScheduleUpdate();

                        m_oFocus.fAlive = false;
                    }

                    ASSERT(IsDragValid());
                    if(m_oDrag.pControl == ZH && m_oDrag.nIndex == nIndex)
                    {
                        ScheduleUpdate();

                        m_oDrag.pControl = NULL;
                    }
                }
            }
        }
        else
        {
            if(pLayer != ZH->pStack)
            {
                if(pLayer->nFocusSaved == nIndex && p->fVisible)
                    pLayer->fAliveSaved = true;
            }
            else
            {
                ASSERT(IsFocusValid());
                if(m_oFocus.pControl == ZH && nIndex == m_oFocus.nIndex &&
                    p->fVisible && ZH->fEnabled && IsWindowActive())
                {
                    ScheduleUpdate();

                    m_oFocus.fAlive = true;
                }
            }    
        }
    }

    if((rgfWhat & ZACCESS_fVisible) && p->fVisible != pItem->fVisible)
    {
        p->fVisible = pItem->fVisible;

        if(!p->fVisible)
        {
            if(pLayer != ZH->pStack)
            {
                if(pLayer->nFocusSaved == nIndex)
                    pLayer->fAliveSaved = false;
            }
            else
            {
                if(IsThereItems())
                {
                    ASSERT(IsFocusValid());
                    if(m_oFocus.pControl == ZH && m_oFocus.nIndex == nIndex && m_oFocus.fAlive)
                    {
                        ScheduleUpdate();

                        m_oFocus.fAlive = false;
                    }
                }
            }
        }
        else
        {
            if(pLayer != ZH->pStack)
            {
                if(pLayer->nFocusSaved == nIndex && p->fEnabled)
                    pLayer->fAliveSaved = true;
            }
            else
            {
                ASSERT(IsFocusValid());
                if(m_oFocus.pControl == ZH && nIndex == m_oFocus.nIndex &&
                    p->fEnabled && ZH->fEnabled && IsWindowActive())
                {
                    ScheduleUpdate();

                    m_oFocus.fAlive = true;
                }
            }    
        }
    }

    if((rgfWhat & ZACCESS_eAccelBehavior) && p->eAccelBehavior != pItem->eAccelBehavior)
        p->eAccelBehavior = pItem->eAccelBehavior;

    if((rgfWhat & ZACCESS_nArrowUp) && p->nArrowUp != pItem->nArrowUp)
        p->nArrowUp = pItem->nArrowUp;

    if((rgfWhat & ZACCESS_nArrowDown) && p->nArrowDown != pItem->nArrowDown)
        p->nArrowDown = pItem->nArrowDown;

    if((rgfWhat & ZACCESS_nArrowLeft) && p->nArrowLeft != pItem->nArrowLeft)
        p->nArrowLeft = pItem->nArrowLeft;

    if((rgfWhat & ZACCESS_nArrowRight) && p->nArrowRight != pItem->nArrowRight)
        p->nArrowRight = pItem->nArrowRight;

    if((rgfWhat & ZACCESS_rgfWantKeys) && p->rgfWantKeys != pItem->rgfWantKeys)
        p->rgfWantKeys = pItem->rgfWantKeys;

    if((rgfWhat & ZACCESS_nGroupFocus) && p->nGroupFocus != pItem->nGroupFocus)
        p->nGroupFocus = pItem->nGroupFocus;

    if((rgfWhat & ZACCESS_pvCookie) && p->pvCookie != pItem->pvCookie)
        p->pvCookie = pItem->pvCookie;

    CanonicalizeItem(pLayer, nIndex);

    return S_OK;
}


STDMETHODIMP CAccessibilityManager::SetFocus(ZHACCESS zh, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    long i;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    long nIndex = FindIndex(pLayer, nItem, fByPosition);
    if(nIndex == ZACCESS_InvalidItem)
        return E_INVALIDARG;

    if(pLayer != ZH->pStack)
    {
        pLayer->nFocusSaved = nIndex;
        for(i = nIndex; !pLayer->rgItems[i].o.fTabstop; i--)
            ASSERT(i > 0);
        pLayer->rgItems[i].o.nGroupFocus = nIndex;
        return S_OK;
    }

    if(!ZH->fEnabled || !pLayer->rgItems[nIndex].o.fVisible || !pLayer->rgItems[nIndex].o.fEnabled)
        return S_FALSE;

    ASSERT(IsFocusValid());
    ASSERT(IsDragValid());
    ASSERT(IsItemFocusable(ZH, nIndex));

    if(ZH == m_oFocus.pControl && nIndex == m_oFocus.nIndex && m_oFocus.fAlive)
        return S_FALSE;

    // hmmmm... need to update internal structures, but postpone callbacks to avoid reentrancy
    ScheduleUpdate();

    m_oFocus.pControl = ZH;
    m_oFocus.nIndex = nIndex;
    m_oFocus.qItem = pLayer->rgItems[nIndex].GetQ();
    m_oFocus.fAlive = IsWindowActive();

    if(!IsValidDragDest(ZH, nIndex))
        m_oDrag.pControl = NULL;

    return S_OK;
}


STDMETHODIMP CAccessibilityManager::CancelDrag(ZHACCESS zh, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    long i;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    if(pLayer != ZH->pStack)
    {
        pLayer->nDragSaved = ZACCESS_InvalidItem;
        return S_OK;
    }

    ASSERT(IsDragValid());

    if(ZH != m_oDrag.pControl || !m_oDrag.pControl)
        return S_FALSE;

    // hmmmm... need to update internal structures, but postpone callbacks to avoid reentrancy
    ScheduleUpdate();

    m_oDrag.pControl = NULL;

    return S_OK;
}


STDMETHODIMP_(long) CAccessibilityManager::GetFocus(ZHACCESS zh, long nLayer)
{
    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return ZACCESS_InvalidItem;

    ASSERT(IsFocusValid());
    if(pLayer != ZH->pStack)
        return pLayer->fAliveSaved ? pLayer->nFocusSaved : ZACCESS_InvalidItem;

    if(ZH != m_oFocus.pControl || !m_oFocus.pControl || !m_oFocus.fAlive)
        return ZACCESS_InvalidItem;

    return m_oFocus.nIndex;
}


STDMETHODIMP_(long) CAccessibilityManager::GetDragOrig(ZHACCESS zh, long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return ZACCESS_InvalidItem;

    ASSERT(IsDragValid());
    if(pLayer != ZH->pStack)
        return pLayer->nDragSaved;

    if(ZH != m_oDrag.pControl || !m_oDrag.pControl)
        return ZACCESS_InvalidItem;

    return m_oDrag.nIndex;
}


STDMETHODIMP CAccessibilityManager::GetItemlist(ZHACCESS zh, ACCITEM *pItems, long cItems, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    if(!cItems)
        return S_OK;

    if(!pItems)
        return E_INVALIDARG;

    if(pLayer->cItems < cItems)
        cItems = pLayer->cItems;

    long i;
    for(i = 0; i < cItems; i++)
        pItems[i] = pLayer->rgItems[i].o;

    return S_OK;
}


STDMETHODIMP_(HACCEL) CAccessibilityManager::GetAcceleratorTable(ZHACCESS zh, long nLayer)
{
    if(!m_fRunning)
        return NULL;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return NULL;

    return pLayer->hAccel;
}


STDMETHODIMP_(long) CAccessibilityManager::GetItemCount(ZHACCESS zh, long nLayer)
{
    if(!m_fRunning)
        return -1;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return -1;

    return pLayer->cItems;
}


STDMETHODIMP CAccessibilityManager::GetItem(ZHACCESS zh, ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!pItem)
        return E_INVALIDARG;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    long i = FindIndex(pLayer, nItem, fByPosition);
    if(i == ZACCESS_InvalidItem)
        return E_INVALIDARG;

    *pItem = pLayer->rgItems[i].o;
    return S_OK;
}


STDMETHODIMP_(long) CAccessibilityManager::GetItemIndex(ZHACCESS zh, WORD wID, long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return ZACCESS_InvalidItem;

    return FindIndex(pLayer, wID, false);
}


STDMETHODIMP_(bool) CAccessibilityManager::IsItem(ZHACCESS zh, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return false;

    AM_LAYER *pLayer = FindLayer(ZH, nLayer);
    if(!pLayer)
        return false;

    long i = FindIndex(pLayer, nItem, fByPosition);
    if(i == ZACCESS_InvalidItem)
        return false;

    return true;
}


STDMETHODIMP CAccessibilityManager::GetGlobalFocus(DWORD *pdwFocusID)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!pdwFocusID)
        return E_INVALIDARG;

    if(!IsThereItems())
        return E_FAIL;

    ASSERT(IsFocusValid());
    *pdwFocusID = m_oFocus.qItem;
    return m_oFocus.fAlive ? S_OK : S_FALSE;
}


STDMETHODIMP CAccessibilityManager::SetGlobalFocus(DWORD dwFocusID)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!IsThereItems())
        return E_FAIL;

    ASSERT(m_pControls);
    ASSERT(IsFocusValid());

    if(m_oFocus.qItem == dwFocusID)
        return S_OK;

    long i;
    AM_CONTROL *pControl = m_pControls;
    while(true)
    {
        if(pControl->pStack)
        {
            for(i = 0;  i < pControl->pStack->cItems; i++)
                if(pControl->pStack->rgItems[i].IsQ(dwFocusID))
                    break;

            if(i < pControl->pStack->cItems)
                break;
        }

        pControl = pControl->pNext;
        if(pControl == m_pControls)
            return E_FAIL;
    }

    ScheduleUpdate();

    m_oFocus.pControl = pControl;
    m_oFocus.nIndex = i;
    m_oFocus.qItem = dwFocusID;
    m_oFocus.fAlive = (IsItemFocusable(pControl, i) && IsWindowActive());

    if(!IsValidDragDest(pControl, i))
        m_oDrag.pControl = NULL;

    return S_OK;
}


//////////////////////////////////////////////////////////////////
// UTILITIES
//////////////////////////////////////////////////////////////////

void CAccessibilityManager::CanonicalizeItem(AM_LAYER *pLayer, long i)
{
    ACCITEM *p = &pLayer->rgItems[i].o;
    long j;

    // set up default arrow behavior
    long nForwards = ZACCESS_ArrowNone;
    long nBackwards = ZACCESS_ArrowNone;
    if(!p->fTabstop || (i != pLayer->cItems - 1 && !pLayer->rgItems[i + 1].o.fTabstop))
    {
        if(i != pLayer->cItems - 1 && !pLayer->rgItems[i + 1].o.fTabstop)
            nForwards = i + 1;
        else
        {
            for(j = i - 1; j >= 0; j--)
                if(pLayer->rgItems[j].o.fTabstop)
                    break;
                nForwards = j;
        }

        if(!p->fTabstop)
            nBackwards = i - 1;
        else
        {
            for(j = i + 1; j < pLayer->cItems; j++)
                if(pLayer->rgItems[j].o.fTabstop)
                    break;
                nBackwards = j - 1;
        }
    }
    if(p->nArrowUp == ZACCESS_ArrowDefault)
        p->nArrowUp = nBackwards;
    if(p->nArrowDown == ZACCESS_ArrowDefault)
        p->nArrowDown = nForwards;
    if(p->nArrowLeft == ZACCESS_ArrowDefault)
        p->nArrowLeft = nBackwards;
    if(p->nArrowRight == ZACCESS_ArrowDefault)
        p->nArrowRight = nForwards;

    // make sure nGroupFocus is legal, and if not, set it to the first item
    if(p->fTabstop)
    {
        long j;
        for(j = i + 1; j < pLayer->cItems && !pLayer->rgItems[j].o.fTabstop; j++)
            if(j == p->nGroupFocus)
                break;
        if(j >= pLayer->cItems || pLayer->rgItems[j].o.fTabstop)
            p->nGroupFocus = i;
    }
    else
        p->nGroupFocus = ZACCESS_InvalidItem;
}


CAccessibilityManager::AM_LAYER* CAccessibilityManager::FindLayer(AM_CONTROL *pControl, long nLayer)
{
    if(nLayer == ZACCESS_TopLayer)
        return pControl->pStack;

    if(nLayer < 0 || nLayer >= pControl->cLayers)
        return NULL;

    long i;
    AM_LAYER *p = pControl->pStack;
    for(i = pControl->cLayers - 1; i != nLayer; i--)
        p = p->pPrev;
    return p;
}


long CAccessibilityManager::FindIndex(AM_LAYER *pLayer, long nItem, bool fByPosition)
{
    if(!fByPosition && nItem != ZACCESS_InvalidCommandID)
    {
        long i;
        nItem &= 0xffffL;
        for(i = 0; i < pLayer->cItems; i++)
            if(nItem == pLayer->rgItems[i].o.wID)
                break;
        if(i < pLayer->cItems)
            nItem = i;
        else
            nItem = ZACCESS_InvalidItem;
    }

    if(nItem < 0 || nItem >= pLayer->cItems)
        return ZACCESS_InvalidItem;

    return nItem;
}


bool CAccessibilityManager::IsValid(AM_CONTROL *pControl, long nIndex)
{
    if(!m_pControls)
        return false;

    AM_CONTROL *pCur = m_pControls;
    while(true)
    {
        if(pCur == pControl)
        {
            if(!pCur->pStack)
                return false;

            if(nIndex < 0 || nIndex >= pCur->pStack->cItems)
                return false;

            return true;
        }

        pCur = pCur->pNext;
        if(pCur == m_pControls)
            break;
    }

    return false;
}


bool CAccessibilityManager::IsFocusValid()
{
    if(!m_oFocus.pControl)
        return false;

    if(!IsValid(m_oFocus.pControl, m_oFocus.nIndex))
        return false;

    return m_oFocus.pControl->pStack->rgItems[m_oFocus.nIndex].IsQ(m_oFocus.qItem);
}


bool CAccessibilityManager::IsDragValid()
{
    if(!m_oDrag.pControl)
        return true;

    if(!IsValid(m_oDrag.pControl, m_oDrag.nIndex))
        return false;

    return m_oDrag.pControl->pStack->rgItems[m_oDrag.nIndex].IsQ(m_oDrag.qItem);
}


bool CAccessibilityManager::IsThereItems()
{
    if(!m_pControls)
        return false;

    AM_CONTROL *pControl = m_pControls;
    while(true)
    {
        if(pControl->pStack && pControl->pStack->cItems)
            return true;

        pControl = pControl->pNext;
        if(pControl == m_pControls)
            return false;
    }
}


bool CAccessibilityManager::IsItemFocusable(AM_CONTROL *pControl, long nIndex)
{
    ASSERT(IsValid(pControl, nIndex));

    return pControl->fEnabled && pControl->pStack->rgItems[nIndex].o.fVisible &&
        pControl->pStack->rgItems[nIndex].o.fEnabled;
}


bool CAccessibilityManager::IsWindowActive()
{
    HWND hWnd = ZoneShell()->GetFrameWindow();

    return hWnd && hWnd == ::GetActiveWindow();
}


bool CAccessibilityManager::IsValidDragDest(AM_CONTROL *pControl, long nIndex)
{
    ASSERT(IsDragValid());
    ASSERT(IsValid(pControl, nIndex));

    long i;

    if(m_oDrag.pControl != pControl)
        return false;

    for(i = nIndex; !pControl->pStack->rgItems[i].o.fTabstop; i--)
        ASSERT(i > 0);
    while(true)
    {
        if(i == m_oDrag.nIndex)
            return true;

        i++;
        if(pControl->pStack->cItems == i || pControl->pStack->rgItems[i].o.fTabstop)
            break;
    }

    return false;
}


void CAccessibilityManager::CommandReceived_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext)
{
    ASSERT(pControl->fEnabled);

    ACCITEM *pItem = &pControl->pStack->rgItems[nIndex].o;

    switch(pItem->eAccelBehavior)
    {
        case ZACCESS_Ignore:
            break;

        case ZACCESS_Select:
            if(pItem->fEnabled)
                ActSelItem_C(pControl, nIndex, false, rgfContext | ZACCESS_ContextCommand);
            break;

        case ZACCESS_Activate:
            if(pItem->fEnabled)
                ActSelItem_C(pControl, nIndex, true, rgfContext | ZACCESS_ContextCommand);
            break;

        case ZACCESS_Focus:
            if(IsItemFocusable(pControl, nIndex))
                FocusItem_C(pControl, nIndex, rgfContext | ZACCESS_ContextCommand);
            break;

        case ZACCESS_FocusGroup:
        case ZACCESS_FocusGroupHere:
        {
            long i = nIndex;
            if(pItem->eAccelBehavior == ZACCESS_FocusGroup && pItem->fTabstop)
                i = nIndex = pItem->nGroupFocus;

            while(true)
            {
                if(IsItemFocusable(pControl, i))
                {
                    FocusItem_C(pControl, i, rgfContext | ZACCESS_ContextCommand);
                    break;
                }

                i++;
                if(i == pControl->pStack->cItems || pControl->pStack->rgItems[i].o.fTabstop)
                    for(i--; !pControl->pStack->rgItems[i].o.fTabstop; i--)
                        ASSERT(i > 0);

                if(i == nIndex)
                    break;
            }
            break;
        }

        case ZACCESS_FocusPositional:
            ASSERT(!"ZACCESS_FocusPositional not implemented.");
            break;
    }
}


void CAccessibilityManager::ActSelItem_C(AM_CONTROL *pControl, long nIndex, bool fActivate, DWORD rgfContext)
{
    ASSERT(IsValid(pControl, nIndex));
    ASSERT(pControl->pStack->rgItems[nIndex].o.fEnabled);
    ASSERT(pControl->fEnabled);

    // save some things for later validation
    DWORD qItem = pControl->pStack->rgItems[nIndex].GetQ();
    DWORD ret;

    // first give the new item the focus
    // if the focus is rejected, do not continue
    bool fWasVisible = pControl->pStack->rgItems[nIndex].o.fVisible;
    if(fWasVisible && !FocusItem_C(pControl, nIndex, rgfContext))
        return;

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////

    // since it returned true, we know it was valid and accepted
    ASSERT(!m_fUpdateNeeded);
    ASSERT(IsValid(pControl, nIndex));
    ASSERT(pControl->pStack->rgItems[nIndex].IsQ(qItem));
    ASSERT(pControl->pStack->rgItems[nIndex].o.fEnabled);
    ASSERT(pControl->fEnabled);

    long nPrevDrag = ZACCESS_InvalidItem;

    // if this completes a drag, call drag instead of activate or select
    ASSERT(IsDragValid());
    if(IsValidDragDest(pControl, nIndex))
    {
        ASSERT(m_oDrag.pControl == pControl);
        nPrevDrag = m_oDrag.nIndex;
        m_oDrag.pControl = NULL;
        ret = pControl->pIAC->Drag(nIndex, nPrevDrag, rgfContext, pControl->pvCookie);
    }
    else
        if(fActivate)
            ret = pControl->pIAC->Activate(nIndex, rgfContext, pControl->pvCookie);
        else
            ret = pControl->pIAC->Select(nIndex, rgfContext, pControl->pvCookie);

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////
    // hold off on the update

    // if a drag was rejected, put back the old drag info
    // it should not have been able to change since calling Drag()
    if((ret & ZACCESS_Reject) && nPrevDrag != ZACCESS_InvalidItem &&
        IsValid(pControl, nPrevDrag) && pControl->pStack->rgItems[nPrevDrag].IsQ(m_oDrag.qItem))
    {
        ASSERT(!m_oDrag.pControl);
        ASSERT(m_oDrag.nIndex == nPrevDrag);
        m_oDrag.pControl = pControl;
        ASSERT(IsDragValid());
    }

    // only let them start a drag if the item was visible to begin with.  otherwise focus will
    // not have been set there, which is necessary for a drag
    if((ret & ZACCESS_BeginDrag) && fWasVisible)
    {
        // revalidate
        if(IsValid(pControl, nIndex) && pControl->pStack->rgItems[nIndex].IsQ(qItem) && pControl->fEnabled &&
            pControl->pStack->rgItems[nIndex].o.fEnabled && pControl->pStack->rgItems[nIndex].o.fVisible &&
            IsWindowActive())
            BeginDrag_C(pControl, nIndex, rgfContext);
    }

    DoUpdate_C();
}


bool CAccessibilityManager::FocusItem_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext)
{
    ASSERT(IsFocusValid());
    ASSERT(IsDragValid());
    ASSERT(IsValid(pControl, nIndex));
    ASSERT(IsItemFocusable(pControl, nIndex));

    bool fWasWindowActive = IsWindowActive();

    // set this up along the lines of SetFocus, then just call DoUpdate
    if(pControl == m_oFocus.pControl && nIndex == m_oFocus.nIndex && (m_oFocus.fAlive || !fWasWindowActive))
        return true;

    // hmmmm... need to update internal structures, but postpone callbacks to avoid reentrancy
    ASSERT(!m_fUpdateNeeded);
    m_fUpdateNeeded = true;
    m_fUpdateFocus = true;
    m_rgfUpdateContext = rgfContext;

    m_oFocusDirty = m_oFocus;
    m_oDragDirty = m_oDrag;

    m_oFocus.pControl = pControl;
    m_oFocus.nIndex = nIndex;
    m_oFocus.qItem = pControl->pStack->rgItems[nIndex].GetQ();
    m_oFocus.fAlive = fWasWindowActive;

    if(!IsValidDragDest(pControl, nIndex))
        m_oDrag.pControl = NULL;

    DoUpdate_C();

    // k if everything was taken care of, and this is still the focus, return true
    if(pControl == m_oFocus.pControl && nIndex == m_oFocus.nIndex && (m_oFocus.fAlive || !fWasWindowActive))
        return true;

    return false;
}


void CAccessibilityManager::BeginDrag_C(AM_CONTROL *pControl, long nIndex, DWORD rgfContext)
{
    ASSERT(IsValid(pControl, nIndex));
    ASSERT(IsDragValid());
    ASSERT(IsItemFocusable(pControl, nIndex));

    DWORD qItem = pControl->pStack->rgItems[nIndex].GetQ();

    // is a drag already in progress?
    if(m_oDrag.pControl)
    {
        if(m_oDrag.pControl == pControl && m_oDrag.nIndex == nIndex)
        {
            ASSERT(qItem == m_oDrag.qItem);
            return;
        }

        // shouldn't be able to be a drag in progress already while there is a dirty drag
        ASSERT(!m_fUpdateNeeded);

        // need to cancel existing drag
        AM_CONTROL *pLastControl = m_oDrag.pControl;
        m_oDrag.pControl = NULL;
        pLastControl->pIAC->Drag(ZACCESS_InvalidItem, m_oDrag.nIndex, rgfContext, pLastControl->pvCookie);
    }

    // if there wasn't a drag in progress, it's still possible that there was a dirty unended drag
    // because BeginDrag can be called while m_fUpdateNeeded.  however, DoUpdate will handle it

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////
    DoUpdate_C();

    if(!IsWindowActive())
        return;

    if(!IsThereItems())
        return;

    // if a new drag got started...  pout
    if(m_oDrag.pControl)
        return;

    if(!IsValid(pControl, nIndex) || !pControl->pStack->rgItems[nIndex].IsQ(qItem))
        return;

    m_oDrag.pControl = pControl;
    m_oDrag.nIndex = nIndex;
    m_oDrag.qItem = qItem;
    return;
}


void CAccessibilityManager::DoTab_C(bool fShift)
{
    ASSERT(IsFocusValid());

    // if the focus is dead, first try to revive it
    if(!m_oFocus.fAlive && IsItemFocusable(m_oFocus.pControl, m_oFocus.nIndex))
    {
        FocusItem_C(m_oFocus.pControl, m_oFocus.nIndex, ZACCESS_ContextKeyboard);
        return;
    }

    // find this item's anchor item
    long nAnchor;
    for(nAnchor = m_oFocus.nIndex; !m_oFocus.pControl->pStack->rgItems[nAnchor].o.fTabstop; nAnchor--);

    long nItem = nAnchor;
    AM_CONTROL *pControl = m_oFocus.pControl;

    long i;

    while(true)
    {
        // find the next tabstop
        if(!fShift)
        {
            while(true)
            {
                nItem++;
                if(nItem == pControl->pStack->cItems)
                {
                    for(pControl = pControl->pNext; !pControl->pStack; pControl = pControl->pNext);
                    nItem = 0;
                }

                // ignore non-tabstops
                if(pControl->pStack->rgItems[nItem].o.fTabstop)
                    break;
            }
        }
        else
        {
            while(true)
            {
                if(!nItem)
                {
                    for(pControl = pControl->pPrev; !pControl->pStack; pControl = pControl->pPrev);
                    nItem = pControl->pStack->cItems;
                }
                nItem--;

                // ignore non-tabstops
                if(pControl->pStack->rgItems[nItem].o.fTabstop)
                    break;
            }
        }

        // no valid items - just do nothing
        if(nItem == nAnchor && pControl == m_oFocus.pControl)
            return;

        // find a valid item in this group
        i = pControl->pStack->rgItems[nItem].o.nGroupFocus;
        while(true)
        {
            // found it
            if(IsItemFocusable(pControl, i))
            {
                FocusItem_C(pControl, i, ZACCESS_ContextKeyboard | (fShift ? ZACCESS_ContextTabBackward : ZACCESS_ContextTabForward));
                return;
            }

            i++;
            if(i >= pControl->pStack->cItems || pControl->pStack->rgItems[i].o.fTabstop)
                for(i--; !pControl->pStack->rgItems[i].o.fTabstop; i--)
                    ASSERT(i > 0);

            if(i == pControl->pStack->rgItems[nItem].o.nGroupFocus)
                break;
        }

        // aw, it didn't work - keep looking
    }
}


void CAccessibilityManager::DoArrow_C(long ACCITEM::*pmArrow)
{
    ASSERT(IsFocusValid());

    if(!m_oFocus.pControl->fEnabled)
        return;

    // if the focus is dead, first try to revive it
    if(!m_oFocus.fAlive && IsItemFocusable(m_oFocus.pControl, m_oFocus.nIndex))
    {
        FocusItem_C(m_oFocus.pControl, m_oFocus.nIndex, ZACCESS_ContextKeyboard);
        return;
    }

    // clear all loop detection bits
    long i;
    for(i = 0; i < m_oFocus.pControl->pStack->cItems; i++)
        m_oFocus.pControl->pStack->rgItems[i].fArrowLoop = false;

    i = m_oFocus.nIndex;
    while(true)
    {
        if(m_oFocus.pControl->pStack->rgItems[i].o.*pmArrow == ZACCESS_ArrowNone)
            return;

        m_oFocus.pControl->pStack->rgItems[i].fArrowLoop = true;
        i = m_oFocus.pControl->pStack->rgItems[i].o.*pmArrow;
        ASSERT(i >= 0 && i < m_oFocus.pControl->pStack->cItems);

        if(m_oFocus.pControl->pStack->rgItems[i].fArrowLoop)
            return;

        // found it
        if(IsItemFocusable(m_oFocus.pControl, i))
        {
            FocusItem_C(m_oFocus.pControl, i, ZACCESS_ContextKeyboard);
            return;
        }
    }
}


void CAccessibilityManager::ScheduleUpdate()
{
    m_fUpdateFocus = true;
    m_rgfUpdateContext = 0;

    if(m_fUpdateNeeded)
        return;

    m_fUpdateNeeded = true;

    m_oFocusDirty = m_oFocus;
    m_oDragDirty = m_oDrag;

    if(m_fRunning)
        EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_ACCESSIBILITY_UPDATE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}


bool CAccessibilityManager::DoUpdate_C()
{
    if(!m_fUpdateNeeded)
        return false;

    AM_FOCUS oFD;

    while(m_fUpdateNeeded)
    {
        // save the really dirty focus in case fixing the drag corrupts it
        oFD = m_oFocusDirty;

        while(m_fUpdateNeeded)
        {
            m_fUpdateNeeded = false;

            // see if a drag was cancelled
            if(m_oDragDirty.pControl && m_oDragDirty.qItem != m_oDrag.qItem && IsValid(m_oDragDirty.pControl, m_oDragDirty.nIndex) &&
                m_oDragDirty.pControl->pStack->rgItems[m_oDragDirty.nIndex].IsQ(m_oDragDirty.qItem))
                m_oDragDirty.pControl->pIAC->Drag(ZACCESS_InvalidItem, m_oDragDirty.nIndex, m_rgfUpdateContext, m_oDragDirty.pControl->pvCookie);
        }

        // see if the focus is currently in this control
        if((!m_oFocus.fAlive || m_oFocus.pControl != oFD.pControl) && IsValid(oFD.pControl, oFD.nIndex) && oFD.fAlive &&
            oFD.pControl->pStack->rgItems[oFD.nIndex].IsQ(oFD.qItem))
            oFD.pControl->pIAC->Focus(ZACCESS_InvalidItem, oFD.nIndex, m_rgfUpdateContext, oFD.pControl->pvCookie);
    }

    // status: we have now killed all pending cancelled drags
    // and told all foreign controls that their focus is gone
    // including reentrant

    // see if we're really done
    if(!m_fUpdateFocus)
        return true;

    // also could be done in these cases.
    // here, we have to throw the windows focus somewhere.  otherwise you can get into
    // situations where you don't get any KEYDOWN messages because no window has the
    // focus.  this is very very annoying windows behavior - i hate this hack
    if(!IsThereItems() || !m_oFocus.fAlive)
    {
        HWND hWnd = ZoneShell()->GetFrameWindow();
        if(hWnd && hWnd == ::GetActiveWindow())
            ::SetFocus(hWnd);
        return true;
    }

    ASSERT(IsFocusValid());
    ASSERT(IsItemFocusable(m_oFocus.pControl, m_oFocus.nIndex));

    // save this stuff in case it is lost after the focus call
    AM_CONTROL *pControl = m_oFocus.pControl;
    long nIndex = m_oFocus.nIndex;
    DWORD qItem = m_oFocus.qItem;
    long nPrevItem = ZACCESS_InvalidItem;
    DWORD rgfContext = m_rgfUpdateContext;

    if(pControl == oFD.pControl && IsValid(oFD.pControl, oFD.nIndex) &&
        oFD.pControl->pStack->rgItems[oFD.nIndex].IsQ(oFD.qItem))
        nPrevItem = oFD.nIndex;

    DWORD ret = pControl->pIAC->Focus(nIndex, oFD.fAlive ? nPrevItem : ZACCESS_InvalidItem, rgfContext, pControl->pvCookie);

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////
    // hold off on the update in this case
    if(!IsThereItems())
        return true;

    ASSERT(IsFocusValid());

    // if focus rejected, then just kill it here
    if((ret & ZACCESS_Reject) && m_oFocus.qItem == qItem)
    {
        m_oFocus.fAlive = false;
    }

    // if focus still ok, move the last focus pointer
    if(IsValid(pControl, nIndex) && pControl->pStack->rgItems[nIndex].IsQ(qItem) &&
        m_oFocus.qItem == qItem && m_oFocus.fAlive && !(ret & ZACCESS_NoGroupFocus))
    {
        // set the last focus of this group to this item
        long i;
        for(i = nIndex; !pControl->pStack->rgItems[i].o.fTabstop; i--)
            ASSERT(i > 0);
        pControl->pStack->rgItems[i].o.nGroupFocus = nIndex;
	}

    if(ret & ZACCESS_BeginDrag)
    {
        // revalidate
        if(IsValid(pControl, nIndex) && pControl->pStack->rgItems[nIndex].IsQ(qItem) && pControl->fEnabled &&
            pControl->pStack->rgItems[nIndex].o.fEnabled && pControl->pStack->rgItems[nIndex].o.fVisible)
            BeginDrag_C(pControl, nIndex, rgfContext);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////
    DoUpdate_C();

    return true;
}


//////////////////////////////////////////////////////////////////
// CAccessibility
//
// This basically just stubs right back to the owner.
//////////////////////////////////////////////////////////////////

STDMETHODIMP CAccessibility::InitAcc(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie)
{
    if(m_zh)
        return E_FAIL;

    m_zh = m_pOwner->Register(pAC, nOrdinal, pvCookie);
    if(!m_zh)
        return E_FAIL;

    return S_OK;
}


STDMETHODIMP_(void) CAccessibility::CloseAcc()
{
    if(m_zh)
    {
        m_pOwner->Unregister(m_zh);
        m_zh = NULL;
    }
}


STDMETHODIMP CAccessibility::PushItemlist(ACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->PushItemlist(m_zh, pItems, cItems, nFirstFocus, fByPosition, hAccel);
}


STDMETHODIMP CAccessibility::PopItemlist()
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->PopItemlist(m_zh);
}


STDMETHODIMP CAccessibility::SetAcceleratorTable(HACCEL hAccel, long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->SetAcceleratorTable(m_zh, hAccel, nLayer);
}


STDMETHODIMP CAccessibility::GeneralDisable()
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->GeneralDisable(m_zh);
}


STDMETHODIMP CAccessibility::GeneralEnable()
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->GeneralEnable(m_zh);
}


STDMETHODIMP_(bool) CAccessibility::IsGenerallyEnabled()
{
    if(!m_zh)
        return false;

    return m_pOwner->IsGenerallyEnabled(m_zh);
}


STDMETHODIMP_(long) CAccessibility::GetStackSize()
{
    if(!m_zh)
        return 0;

    return m_pOwner->GetStackSize(m_zh);
}


STDMETHODIMP CAccessibility::AlterItem(DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->AlterItem(m_zh, rgfWhat, pItem, nItem, fByPosition, nLayer);
}


STDMETHODIMP CAccessibility::SetFocus(long nItem, bool fByPosition, long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->SetFocus(m_zh, nItem, fByPosition, nLayer);
}


STDMETHODIMP CAccessibility::CancelDrag(long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->CancelDrag(m_zh, nLayer);
}


STDMETHODIMP_(long) CAccessibility::GetFocus(long nLayer)
{
    if(!m_zh)
        return ZACCESS_InvalidItem;

    return m_pOwner->GetFocus(m_zh, nLayer);
}


STDMETHODIMP_(long) CAccessibility::GetDragOrig(long nLayer)
{
    if(!m_zh)
        return ZACCESS_InvalidItem;

    return m_pOwner->GetDragOrig(m_zh, nLayer);
}


STDMETHODIMP CAccessibility::GetItemlist(ACCITEM *pItems, long cItems, long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->GetItemlist(m_zh, pItems, cItems, nLayer);
}


STDMETHODIMP_(HACCEL) CAccessibility::GetAcceleratorTable(long nLayer)
{
    if(!m_zh)
        return NULL;

    return m_pOwner->GetAcceleratorTable(m_zh, nLayer);
}


STDMETHODIMP_(long) CAccessibility::GetItemCount(long nLayer)
{
    if(!m_zh)
        return 0;

    return m_pOwner->GetItemCount(m_zh, nLayer);
}


STDMETHODIMP CAccessibility::GetItem(ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_zh)
        return E_FAIL;

    return m_pOwner->GetItem(m_zh, pItem, nItem, fByPosition, nLayer);
}


STDMETHODIMP_(long) CAccessibility::GetItemIndex(WORD wID, long nLayer)
{
    if(!m_zh)
        return ZACCESS_InvalidItem;

    return m_pOwner->GetItemIndex(m_zh, wID, nLayer);
}


STDMETHODIMP_(bool) CAccessibility::IsItem(long nItem, bool fByPosition, long nLayer)
{
    if(!m_zh)
        return false;

    return m_pOwner->IsItem(m_zh, nItem, fByPosition, nLayer);
}


STDMETHODIMP CAccessibility::GetGlobalFocus(DWORD *pdwFocusID)
{
    return m_pOwner->GetGlobalFocus(pdwFocusID);
}


STDMETHODIMP CAccessibility::SetGlobalFocus(DWORD dwFocusID)
{
    return m_pOwner->SetGlobalFocus(dwFocusID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\chat\chatctl.cpp ===
// ChatCtl.cpp : Implementation of CChatCtl

#include <BasicAtl.h>
#include "zoneresource.h"      
#include <AtlCtl.h>
#include <AtlCtrls.h>
#include <RollOver.h>
#include <ClientImpl.h>
#include <ClientIdl.h>
#include <ZoneString.h>
#include <KeyName.h>
#include "UserPrefix.h"
#include "ChatCtl.h"
#include "ZoneUtil.h"
#include "ZoneResource.h"

// Chat Flood defs
#define kMinTimeBetweenChats		500
#define kMaxNumChatQueue			10


const char SYSOP_TOKEN = '+';

// Font handling

void ChooseFontFromCharFormat(CHOOSEFONT* pcf, LOGFONT* plf, CHARFORMAT* pchf, HWND hWnd);
void CharFormatFromChooseFont(CHOOSEFONT* pcf, CHARFORMAT* pchf);
void TextFontFromCharFormat(ITextFont* pfnt, CHARFORMAT* pcf);

#define COLOR_CHAT_TEXT		PALETTERGB(0, 0, 0)
#define COLOR_CHAT_BKGND	PALETTERGB(255,255,255)
#define COLOR_USERS_TEXT	PALETTERGB(0,0,0)
#define COLOR_USERS_BKGND	PALETTERGB(255,255,255)
#define COLOR_USERS_GROUP	PALETTERGB(192,192,192)
#define COLOR_MAIN_BKGND	PALETTERGB(255,255,255)
#define COLOR_MAIN_FOREGRND PALETTERGB(0,0,0)
#define CHAT_FONT_HEIGHT_TWIPS  180
#define TWIPS_PER_INCH		1440

/////////////////////////////////////////////////////////////////////////////
// CChatCtl

CChatCtl::CChatCtl() :
	m_ChatDisplay(TEXT("RichEdit20A"), this, 1),
	m_ChatEdit(TEXT("RichEdit20A"), this, 2),
	m_RadioButtonOn(TEXT("BUTTON"),this,3),
	m_RadioButtonOff(TEXT("BUTTON"),this,4),
	m_PlayerList(TEXT("LISTBOX"),this,5),
#ifdef COPPA
	m_QuasiChat(this,6),
    m_fComboEndOk(false),
    m_fComboDown(false),
#endif
    m_fFocusKept(false),
    m_nChatMinHeight(60)
{
	m_bWindowOnly = TRUE;

	// these are defaults  - real values are loaded from resource
	m_EditHeight = 30;  
	m_EditMargin = 1;
    m_QuasiItemsDisp = 20;
    m_nPanelWidth = 165;

	m_bFirstChatLine = TRUE;
	m_pTDocHistory = NULL;
	m_ptrgInsert   = NULL;
	m_ptrgWhole      = NULL;
	m_strNewLine = SysAllocString(L"\n");

	m_bPreferencesLoaded = false;

	m_Batch = false;

	// default font info
	memset(&m_cfCurFont, 0, sizeof(m_cfCurFont));
	m_cfCurFont.cbSize = sizeof(m_cfCurFont);
    m_cfCurFont.dwMask = CFM_COLOR | CFM_FACE | CFM_SIZE | CFM_BOLD | CFM_STRIKEOUT | CFM_UNDERLINE | CFM_ITALIC;
	m_cfCurFont.yHeight = CHAT_FONT_HEIGHT_TWIPS;
	m_cfCurFont.crTextColor = COLOR_CHAT_TEXT;
    m_cfCurFont.bPitchAndFamily = DEFAULT_PITCH;
    lstrcpy(m_cfCurFont.szFaceName, TEXT("Tahoma"));

	m_pfntText = 0;
	m_pfntName = 0;

    m_tszChatWord[0] = '\0';
    m_tszOnWord[0] = '\0';
    m_tszOffWord[0] = '\0';
    m_tszPlayerOffWord[0] = '\0';
    m_tszPlayerOnWord[0] = '\0';
    m_tszPlayerBotWord[0] = '\0';
    m_tszChatSeperator[0] = '\0';

    m_hPanelPen = NULL;
	m_RadioButtonHeight = 0;

	m_OrgSystemMessageColor = m_SystemMessageColor = RGB(0,0,0);

	m_bGameTerminated = false;

	m_hRichEdit = NULL;

	m_bChatOnAtStartUp = true;
	m_bDisplayedTypeHereMessage = false;

	m_rcPanel.SetRectEmpty();

	m_ChatMessageNdxBegin = 0;
	m_ChatMessageNdxEnd = 0;
}

CChatCtl::~CChatCtl()
{
	SysFreeString(m_strNewLine);
	
    if(m_hPanelPen)
        DeleteObject(m_hPanelPen);

	if(m_hRichEdit)
		FreeLibrary(m_hRichEdit);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	WritePreferences		Write User Preferences to DataStore
//
//	Parameters
//		None
//
//	Return Values
//		void
//
//////////////////////////////////////////////////////////////////////////////////////////////
void CChatCtl::WritePreferences()
{
	// save settings to user preferences
	const TCHAR* arKeys[3] = { key_Zone, key_ChatCtl, key_ChatFont };

	IDataStore* pIPrefs = DataStorePreferences();
	if ( !pIPrefs )
		return;
}

void CChatCtl::LoadPreferences()
{
	IDataStore* pIDS = DataStorePreferences();
	if ( !pIDS )
		return;

	CComPtr<IZoneFrameWindow> pWindow;
	ZoneShell()->QueryService( SRVID_LobbyWindow, IID_IZoneFrameWindow, (void**) &pWindow );
	if(!pWindow)
		return;

	long enable = 0;

	// get lobby's data store
	pIDS = 0;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( SUCCEEDED(hr) )
	{
		// get user's default chat status (on or off)
		pIDS->GetLong( key_LocalChatStatus, &enable );
        pIDS->Release();

		m_bChatOnAtStartUp = enable ? true:false;
	}

	m_bPreferencesLoaded = true;
}


STDMETHODIMP CChatCtl::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	IZoneShellClientImpl<CChatCtl>::Init( pIZoneShell, dwGroupId, szKey );
	DWORD cb;
    ZONEFONT oFont;
	
    LoadPreferences();

    // load some UI stuff
	const TCHAR* arKeys[3] = { key_WindowManager, key_ChatMinHeight };

    // this should be handled through getminmaxinfo or something
    DataStoreUI()->GetLong(arKeys, 2, &m_nChatMinHeight);

    arKeys[0] = key_ChatCtl;
    arKeys[1] = key_EditHeight;
	DataStoreUI()->GetLong( arKeys, 2, &m_EditHeight );

	arKeys[1] = key_EditMargin;
	DataStoreUI()->GetLong( arKeys, 2, &m_EditMargin );

    arKeys[1] = key_QuasiItemsDisp;
	DataStoreUI()->GetLong( arKeys, 2, &m_QuasiItemsDisp );

	arKeys[1] = key_ChatPanel;
	arKeys[2] = key_PanelWidth;
	DataStoreUI()->GetLong( arKeys, 3, &m_nPanelWidth );

	arKeys[2] = key_RadioButtonHeight;
	DataStoreUI()->GetLong( arKeys, 3, &m_RadioButtonHeight );

	arKeys[2] = key_ChatWordRect;
	DataStoreUI()->GetRECT( arKeys, 3, &m_rcChatWord );

	arKeys[2] = key_PlayerOffset;
	DataStoreUI()->GetPOINT( arKeys, 3, &m_ptPlayer );

	arKeys[2] = key_ChatWordOffset;
	DataStoreUI()->GetPOINT( arKeys, 3, &m_ptChatWord );

    arKeys[2] = key_OnOffOffset;
	DataStoreUI()->GetPOINT( arKeys, 3, &m_ptOnOff );


	// Load fonts
	CDC dc;
	dc.CreateCompatibleDC();	// by default this does CreateCompatibleDC(NULL)

	ZONEFONT zfChatPreferred;	// impossible to match
	ZONEFONT zfChatBackup(8);	// will provide a reasonable 8 point default
	arKeys[2] = key_ChatFont;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatPreferred );
	arKeys[2] = key_ChatFontBackup;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatBackup );
	m_font.SelectFont(zfChatPreferred, zfChatBackup, dc);

	arKeys[2] = key_ChatWordFont;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatPreferred );
	arKeys[2] = key_ChatWordFontBackup;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatBackup );
	m_fontPanelChat.SelectFont(zfChatPreferred, zfChatBackup, dc);

	arKeys[2] = key_QuasiFont;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatPreferred );
	arKeys[2] = key_QuasiFontBackup;
	DataStoreUI()->GetFONT( arKeys, 3, &zfChatBackup );
	m_fontQuasi.SelectFont(zfChatPreferred, zfChatBackup, dc);

	ZONEFONT zfPlayerPreferred;	// impossible to match
	ZONEFONT zfPlayerBackup(8);	// will provide a reasonable 8 point default
	arKeys[2] = key_PlayerFont;
	DataStoreUI()->GetFONT( arKeys, 3, &zfPlayerPreferred );
	arKeys[2] = key_PlayerFontBackup;
	DataStoreUI()->GetFONT( arKeys, 3, &zfPlayerBackup );
	m_fontPanelPlayer.SelectFont(zfPlayerPreferred, zfPlayerBackup, dc);
	
	// Load strings to use
	arKeys[2] = key_ChatWordText;
    cb = sizeof(m_tszChatWord);
	DataStoreUI()->GetString( arKeys, 3, m_tszChatWord, &cb );

	arKeys[2] = key_OnText;
    cb = sizeof(m_tszOnWord);
	DataStoreUI()->GetString( arKeys, 3, m_tszOnWord, &cb );

	arKeys[2] = key_OffText;
    cb = sizeof(m_tszOffWord);
	DataStoreUI()->GetString( arKeys, 3, m_tszOffWord, &cb );

	arKeys[2] = key_SystemMessageColor;
	DataStoreUI()->GetRGB( arKeys, 3, &m_SystemMessageColor );
	m_OrgSystemMessageColor = m_SystemMessageColor;
	// If this color matches with window bkgnd then it should be changed to a readable one.
	VerifySystemMsgColor(m_SystemMessageColor);

	ResourceManager()->LoadString(IDS_CHAT_PLAYER_ON,	(TCHAR*)m_tszPlayerOnWord,	NUMELEMENTS(m_tszPlayerOnWord));
	ResourceManager()->LoadString(IDS_CHAT_PLAYER_OFF,(TCHAR*)m_tszPlayerOffWord,	NUMELEMENTS(m_tszPlayerOffWord));
	ResourceManager()->LoadString(IDS_CHAT_PLAYER_BOT,(TCHAR*)m_tszPlayerBotWord,	NUMELEMENTS(m_tszPlayerBotWord));
	ResourceManager()->LoadString(IDS_CHAT_SEPERATOR,	(TCHAR*)m_tszChatSeperator,	NUMELEMENTS(m_tszChatSeperator));
	ResourceManager()->LoadString(IDS_CHAT_SEND,	(TCHAR*)m_tszChatSend,			NUMELEMENTS(m_tszChatSend));

#ifdef COPPA
	// Load ndxs for loading quasichat strings
    arKeys[0] = key_ChatCtl;
    arKeys[1] = key_QuasiChat;
	arKeys[2] = key_ChatMessageNdxBegin;
	DataStoreUI()->GetLong( arKeys, 3, &m_ChatMessageNdxBegin );
	arKeys[2] = key_ChatMessageNdxEnd;
	DataStoreUI()->GetLong( arKeys, 3, &m_ChatMessageNdxEnd );
#endif

	// Create pen
    m_hPanelPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW));

    // sign up for accessibility
    HRESULT hr = ZoneShell()->QueryService(SRVID_AccessibilityManager, IID_IAccessibility, (void**) &m_pIAcc);
    if(FAILED(hr))
        return hr;
    m_pIAcc->InitAcc(this, 1);

    CComPtr<IInputManager> pIIM;

	// sign up to get WM_CHAR
    hr = ZoneShell()->QueryService(SRVID_InputManager, IID_IInputManager, (void**) &pIIM);
    if(FAILED(hr))
        return hr;

    pIIM->RegisterCharHandler(this, 0);

    // handle accessibility
    HACCEL hAccel = ResourceManager()->LoadAccelerators(MAKEINTRESOURCE(IDR_CHAT_ACCEL));

    ACCITEM rgItems[5];
    long i;
    for(i = 0; i < NUMELEMENTS(rgItems); i++)
        CopyACC(rgItems[i], ZACCESS_DefaultACCITEM);

    rgItems[0].wID = ID_CHAT_HISTORY_ACC;
    rgItems[0].rgfWantKeys = ZACCESS_WantAllArrows;
    rgItems[0].eAccelBehavior = ZACCESS_Focus;

    rgItems[1].wID = ID_CHAT_SEND_ACC;
    rgItems[1].rgfWantKeys = ZACCESS_WantSpace | ZACCESS_WantAllArrows;

    rgItems[2].wID = ID_CHAT_ON_ACC;
    if(!m_bChatOnAtStartUp)
        rgItems[2].nGroupFocus = 3;

    rgItems[3].wID = ID_CHAT_OFF_ACC;
    rgItems[3].fTabstop = false;

    rgItems[4].wID = ID_CHAT_CHAT_ACC;
    rgItems[4].fVisible = false;
    m_pIAcc->PushItemlist(rgItems, NUMELEMENTS(rgItems), m_bChatOnAtStartUp ? ID_CHAT_SEND_ACC : ID_CHAT_OFF_ACC, false, hAccel);

	return S_OK;
}


STDMETHODIMP CChatCtl::Close()
{
    CComPtr<IInputManager> pIIM;

    // tell the Input Manager that I'm going away
    HRESULT hr = ZoneShell()->QueryService(SRVID_InputManager, IID_IInputManager, (void**) &pIIM);
    if(SUCCEEDED(hr))
        pIIM->ReleaseReferences((IInputCharHandler *) this);

	WritePreferences();

    m_pIAcc.Release();

	return IZoneShellClientImpl<CChatCtl>::Close();
}


LRESULT CChatCtl::OnMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	MEASUREITEMSTRUCT* i = (MEASUREITEMSTRUCT*)lParam;

	HDC dc = CreateCompatibleDC(NULL);
	HFONT oldFont = SelectObject(dc,(HFONT)m_fontPanelPlayer);
	TEXTMETRIC tm;
	GetTextMetrics(dc,&tm);
	
	i->itemHeight = tm.tmHeight;
	i->itemWidth = m_nPanelWidth - (m_rcChatWord.right - m_rcChatWord.left+1) - 2;
	
	SelectObject(dc,oldFont);
	DeleteDC(dc);
	return TRUE;
}

LRESULT CChatCtl::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	int idCtl = (UINT) wParam; 
	if(idCtl!=5)
		return 0;

	DRAWITEMSTRUCT* drawItem = (LPDRAWITEMSTRUCT) lParam;
	RECT r = drawItem->rcItem;
	// subtract some room so there's a margin
	r.left+=4;
	r.right-=1;

	if(drawItem->itemAction==ODA_DRAWENTIRE )
	{
		// Get datastore for user
		CComPtr<IDataStore> pIDS;
		HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, drawItem->itemData, &pIDS );
		if ( FAILED(hr) )
			return 0;

		// Get username
		TCHAR szUserName[ ZONE_MaxUserNameLen ];
		DWORD dwLen = sizeof(szUserName);
		hr = pIDS->GetString( key_Name, szUserName, &dwLen ); 
		if ( FAILED(hr) )
			return 0;

		TCHAR buf[ZONE_MAXSTRING];

		// Get chat status
		long chatStatus = 0;
		hr = pIDS->GetLong( key_ChatStatus, &chatStatus );

        // Get bot status
        long eSkill = KeySkillLevelBeginner;
        hr = pIDS->GetLong( key_PlayerSkill, &eSkill );
		
		if(SUCCEEDED(hr))
            ZoneFormatMessage(eSkill != KeySkillLevelBot ? chatStatus ? m_tszPlayerOnWord : m_tszPlayerOffWord : m_tszPlayerBotWord, buf, NUMELEMENTS(buf), szUserName);

		// Get appropriate reading direction
		long textStyle = DT_RTLREADING;  
		
		long s = m_PlayerList.GetWindowLong(GWL_EXSTYLE);

		if(s & WS_EX_RTLREADING)
			textStyle |= DT_RIGHT;
		else 
			textStyle |= DT_LEFT;

		COLORREF oldColor = SetTextColor(drawItem->hDC, GetSysColor(COLOR_BTNTEXT));
		SetBkMode(drawItem->hDC, TRANSPARENT);
		// draw player name and chat status
		DrawText(drawItem->hDC, buf, -1, &r, textStyle);
		SetTextColor(drawItem->hDC, oldColor);
	}
	return 0;
}

LRESULT CChatCtl::OnCompareItem(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	COMPAREITEMSTRUCT* i = (COMPAREITEMSTRUCT*) lParam;

	if(i->itemData1 == i->itemData2)
		return 0;

	// get player ndxs
	CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, i->itemData1, &pIDS );
	if ( FAILED(hr) )
		return 0;
	long ndx1 = 0;
	hr = pIDS->GetLong( key_PlayerNumber, &ndx1 ); 
	if ( FAILED(hr) )
		return 0;

	pIDS.Release();

	hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, i->itemData2, &pIDS );
	if ( FAILED(hr) )
		return 0;
	long ndx2 = 0;
	hr = pIDS->GetLong( key_PlayerNumber, &ndx2 ); 
	if ( FAILED(hr) )
		return 0;

	if(ndx1 < ndx2)
		return -1;
	else if(ndx1 > ndx2)
		return 1;

	return 0;
}

void CChatCtl::OnUserUpdate(DWORD eventId,DWORD groupId,DWORD userId)
{
	int found = m_PlayerList.FindString(-1,(TCHAR*)userId);

	if(found!=LB_ERR)
	{
		RECT r;
		int result = m_PlayerList.GetItemRect(found, &r);
		if(result!=LB_ERR)
			m_PlayerList.InvalidateRect(&r,TRUE);
	}
}
void CChatCtl::OnLobbyClear(DWORD eventId,DWORD groupId,DWORD userId)
{
	// Empty player listbox 
	m_PlayerList.ResetContent();
}

void CChatCtl::OnUserAdd(DWORD eventId,DWORD groupId,DWORD userId)
{
	// PlayerList is an ownerdraw listbox, so takes a data instead of a string
	m_PlayerList.AddString((TCHAR*)userId);
}

void CChatCtl::OnUserRemove(DWORD eventId,DWORD groupId,DWORD userId)
{
	if(GetGroupId()!=groupId)
		return;

	ASSERT(m_PlayerList.IsWindow());
	
	int found = m_PlayerList.FindString(-1,(TCHAR*)userId);
	
	if(found!=LB_ERR)
	{
		m_PlayerList.DeleteString(found);
	}
}

void CChatCtl::OnGameLaunching(DWORD eventId,DWORD groupId,DWORD userId)
{
	m_bGameTerminated = false;
	m_ChatDisplay.EnableWindow(TRUE);

	// make sure we set chat to proper state everytime we launch, this may have been affected by radio button usage while
	// in game terminate state
	long enable = FALSE;
	const TCHAR* arKeys[2];
	CComPtr<IDataStore> pIDS;

	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( SUCCEEDED(hr) )
	{
		// get user's default chat status (on or off)
		pIDS->GetLong( key_LocalChatStatus, &enable );
	}

	// don't change the chat enable state, but make sure the chat windows match the current state
	EnableChat(enable, false);

	// Beta2 Bug #15365 - After clearing the text should always begin from the first line.
	m_bFirstChatLine = TRUE;
}

void CChatCtl::OnGameTerminated(DWORD eventId,DWORD groupId,DWORD userId)
{
	m_bGameTerminated = true;

	// clear chat history
	m_pTDocHistory->New();

	// disable chat history window
	m_ChatDisplay.EnableWindow(FALSE);

    // fix up scroll bar for next time
	SCROLLINFO si;
	memset(&si, 0, sizeof(si));
	si.cbSize = sizeof(si);
	si.fMask = SIF_ALL;
	::SetScrollInfo(m_ChatDisplay.m_hWnd, SB_VERT, &si, true);

	// make sure we disable chat when we terminate, but don't change that chat on/off state, since if we 
	// restart a game we want to maintain the same state
	EnableChat(false, false);
}

void CChatCtl::CalcDisplayRects()
{
	GetClientRect(&m_EditRect);

	m_DisplayRect = m_EditRect;
    m_rcPanel = m_EditRect;

    m_DisplayRect.right -= m_nPanelWidth;

	m_DisplayRect.bottom -= m_EditHeight + m_EditMargin;
	m_EditRect.top = m_DisplayRect.bottom + m_EditMargin;

#ifndef COPPA
	int sendButtonWidth = 20;
	if(m_SendButton.m_hWnd)
		sendButtonWidth = m_SendButton.GetWidth();
	m_EditRect.right -= sendButtonWidth + m_nPanelWidth;
#else
	if(m_QuasiChat.IsWindow())
		m_EditRect.bottom += m_QuasiChat.GetItemHeight(0) * m_QuasiItemsDisp;

	m_EditRect.right -= m_nPanelWidth;
#endif

    m_rcPanel.left = m_DisplayRect.right;
	m_rcPanel.top = m_DisplayRect.top;
}

void CChatCtl::EnableChat(BOOL enable, BOOL fNotify)
{
	// Check current state in datastore and if already matches don't do anything
	if(fNotify) // only do this check if we're really trying to change the state, otherwise someone is calling this function just to update the ui
	{
		CComPtr<IDataStore> pIDS;
		HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
		if ( SUCCEEDED(hr) )
		{
			long chatState = 0;

			hr = pIDS->GetLong( key_LocalChatStatus, &chatState);
			if(SUCCEEDED(hr))
				if (chatState == (enable?1:0))
					return;
		}
	}


	if(!(m_bGameTerminated && enable))
	{
#ifndef COPPA
		m_ChatEdit.EnableWindow(enable);
		m_SendButton.EnableWindow(enable);

//		if(enable)
//			m_ChatEdit.SetFocus();

		//m_SendButton.SetEnabled(enable == TRUE);
	
		// IME enabling/disabling
		//HIMC imeContext = ImmGetContext(m_hWnd);
		//ImmSetOpenStatus(imeContext,TRUE);

		//HWND imeWnd = ImmGetDefaultIMEWnd(m_ChatEdit);
		
		//ASSERT(imeWnd!=0);
		
		//if(imeWnd)
		//{
		//	::SendMessage(imeWnd, WM_IME_CONTROL, enable ? IMC_OPENSTATUSWINDOW : IMC_CLOSESTATUSWINDOW,0);
		//}


		BSTR defaultText = NULL;

		// Get default text for chat entry
		TCHAR szDefaultText[256];
		szDefaultText[0] = NULL;

		DWORD dwLen = sizeof(szDefaultText);

		long idToLoad = IDS_CHAT_CHATISOFF;

		if(enable && !m_bGameTerminated)
		{
			if (!m_bChatOnAtStartUp  && !m_bDisplayedTypeHereMessage)	// Beta2 Bug 15180 - it should only appear the first time they turn chat on 
			{																	// in any session, and not at all if they have chat on at startup.
				idToLoad = IDS_CHAT_TYPEHERE;
				m_bDisplayedTypeHereMessage = true;
			}
			else
				idToLoad = 0;
		}
		else if (m_bGameTerminated)
			idToLoad = IDS_CHAT_INACTIVE;

		if(idToLoad)
			ResourceManager()->LoadString(idToLoad,	szDefaultText,	NUMELEMENTS(szDefaultText));

		// Beta2  Bug #15183 - The chat edit window font should not change after edit operations like Paste.
		m_ChatEdit.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_font,0);
		// set range to include any existing text
		m_EntryRange->SetStart(0);
		m_EntryRange->MoveEnd(tomStory,1,NULL); // move endpoint to end
		m_EntryRange->MoveEnd(tomCharacter,-1,NULL); // don't include \n which is always at the end of the range

		// and set to default text
		defaultText = T2BSTR(szDefaultText);
		m_EntryRange->SetText(defaultText);
		SysFreeString(defaultText);	

		m_bHasTypedInEntry = FALSE;

		// Select text
		if(enable && !m_bGameTerminated)
			m_EntryRange->Select();

		// repaint gray/white area background for sendbutton
		RECT buttonRect;
		buttonRect.top = m_EditRect.top;
		buttonRect.bottom = m_EditRect.bottom;
		buttonRect.left = m_EditRect.right;
		buttonRect.right = m_DisplayRect.right;
		InvalidateRect(&buttonRect);
#else
		m_QuasiChat.EnableWindow(enable);
#endif
	}

    if(fNotify)
    {
	    // Save state in datastore and tell everyone
	    CComPtr<IDataStore> pIDS;
	    HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	    if ( FAILED(hr) )
		    return;

	    pIDS->SetLong( key_LocalChatStatus, enable ? 1 : 0 );
	    EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_CHAT_SWITCH, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    }

}

LRESULT CChatCtl::OnLanguageChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 0;
}

LRESULT CChatCtl::OnCreate(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
    SetClassLong(m_hWnd, GCL_HBRBACKGROUND, (LONG) GetStockObject(NULL_BRUSH));
    CalcDisplayRects();

	// Load Richedit dll
	m_hRichEdit = LoadLibrary(TEXT("RichEd20.dll"));
	if (m_hRichEdit == NULL)
		return FALSE;

	// Create chat edit controls
	
	// Chat History

	HWND hWnd = m_ChatDisplay.Create(m_hWnd, m_DisplayRect, NULL,
		WS_CHILD | WS_TABSTOP | WS_VSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL |  WS_VISIBLE, 0 , 1 );

	// Set font
	m_ChatDisplay.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_font,0);
	m_ChatDisplay.EnableWindow(FALSE);

	// Enable proper reading order
	// ID_EDITCONTROL is the control ID in the
	// resource file.
	/*
	HANDLE hWndEdit 
		= GetDlgItem(hDlg, ID_EDITCONTROL);
	LONG lAlign = GetWindowLong(hWndEdit, GWL_EXSTYLE) ;
	//...
	// To toggle alignment
	lAlign ^= WS_EX_RIGHT ;
	// To toggle reading order
	lAlign ^= WS_EX_RTLREADING ;
	After setting the lAlign value, enable the new display by setting the extended style of the edit control window as follows:

	// (This assumes your edit control is in a
	// dialog box. If not, you can 
	// get the edit control handle
	// from another source)
	SetWindowLong(hWndEdit, GWL_EXSTYLE, lAlign);
	InvalidateRect(hWndEdit, NULL, FALSE);
	*/


	// Get TOM interface for chat history
	IUnknown* pUnk = NULL;
	if (!m_ChatDisplay.SendMessage(EM_GETOLEINTERFACE, 0, (LPARAM)&pUnk) || pUnk == NULL)
		return FALSE;
	HRESULT hr = pUnk->QueryInterface(IID_ITextDocument, (LPVOID*)&m_pTDocHistory);
	pUnk->Release();
	if (m_pTDocHistory != NULL)
	{
		m_pTDocHistory->Range(0, 0, &m_ptrgInsert);
		m_pTDocHistory->Range(0, 0, &m_ptrgWhole);

		if (m_ptrgInsert != NULL)
		{
			ITextFont* pfnt;
			m_ptrgInsert->GetFont(&pfnt);
			pfnt->GetDuplicate(&m_pfntText);
			pfnt->GetDuplicate(&m_pfntName);
			pfnt->Release();
			m_pfntName->SetBold(tomTrue);
			m_pfntText->SetBold(tomFalse);
		}
	}

#ifndef COPPA
	// Chat Entry

	m_ChatEdit.Create(m_hWnd, m_EditRect, NULL, 
		WS_CHILD | WS_TABSTOP | ES_SAVESEL | ES_LEFT | ES_AUTOHSCROLL| ES_WANTRETURN | WS_VISIBLE , 0 ,2);
	//m_ChatEdit.Create(m_hWnd, m_EditRect, NULL, 
	//	WS_CHILD | WS_TABSTOP | ES_SAVESEL | ES_LEFT | ES_MULTILINE | ES_WANTRETURN | ES_AUTOVSCROLL|WS_VISIBLE , WS_EX_RTLREADING | WS_EX_RIGHT,2);
	
	m_ChatEdit.SendMessage(EM_EXLIMITTEXT, 0, ZONE_MaxChatLen - 1);
	m_ChatEdit.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_font,0);


	// Get TOM interface for chat entry
	if (!m_ChatEdit.SendMessage(EM_GETOLEINTERFACE, 0, (LPARAM)&pUnk) || pUnk == NULL)
		return FALSE;
	
	// Get ITextDocument
	hr = pUnk->QueryInterface(IID_ITextDocument, (LPVOID*)&m_EntryDoc);
	pUnk->Release();

	// Get a ITextRange for the document
	hr = m_EntryDoc->Range(0, 0, &m_EntryRange);

	// Send Button
	CComPtr<IResourceManager> pRM;
	ZoneShell()->QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &pRM );
	
	// get font for send button
	const TCHAR* arKeys[2] = { key_ChatCtl, key_ChatSendFont };
	ZONEFONT zfChatSend(8);	
	DataStoreUI()->GetFONT( arKeys, 2, &zfChatSend );
	CZoneFont font;
	font.CreateFont(zfChatSend);

	m_SendButton.Init(m_hWnd,ZoneShell()->GetPalette(),ID_CHAT_SEND,0,0,IDB_CHAT_SEND,pRM,0,m_tszChatSend,font,RGB(0,0,0));
#else
	// Create combo box for quasi chat
	m_QuasiChat.Create(m_hWnd, m_EditRect, NULL,
				WS_CHILD | WS_TABSTOP | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL, 0 , 6);
	m_QuasiChat.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_fontQuasi,0);
	LoadChatStrings();
	m_QuasiChat.SetCurSel(0);

#endif

	// Player list
	RECT r;
	GetClientRect(&r);
	m_PlayerList.Create(m_hWnd, r, NULL, WS_CHILD |  WS_VISIBLE | LBS_OWNERDRAWFIXED | LBS_SORT, 0 ,5);
	m_PlayerList.SendMessage(WM_SETFONT, (WPARAM) (HFONT)m_fontPanelPlayer,0);

	// Radio buttons
    m_RadioButtonOn.Create(m_hWnd, r, m_tszOnWord, WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 0, 3);	
    m_RadioButtonOff.Create(m_hWnd, r, m_tszOffWord, WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 0, 4);	
	m_RadioButtonOn.SendMessage(WM_SETFONT, (WPARAM) (HFONT) m_fontPanelChat,0);
	m_RadioButtonOff.SendMessage(WM_SETFONT, (WPARAM) (HFONT) m_fontPanelChat,0);

    // position
	CRect rcChatWord = m_rcChatWord;
    rcChatWord.OffsetRect(m_rcPanel.left, m_rcPanel.top);

	CRect rcRadioOn;
	rcRadioOn.left = m_rcPanel.left + m_rcChatWord.left + m_ptOnOff.x;
	rcRadioOn.right = rcRadioOn.left + rcChatWord.Width() - m_ptOnOff.x;
	rcRadioOn.top = m_rcPanel.top + rcChatWord.Height() + m_ptOnOff.y;
	rcRadioOn.bottom = rcRadioOn.top + m_RadioButtonHeight;
	CRect rcRadioOff = rcRadioOn;
	rcRadioOff.top = rcRadioOn.bottom;
	rcRadioOff.bottom = rcRadioOff.top + m_RadioButtonHeight;

	m_RadioButtonOn.SetWindowPos(NULL,rcRadioOn.left,rcRadioOn.top,rcRadioOn.Width(),rcRadioOn.Height(),SWP_NOZORDER|SWP_NOREDRAW );
	m_RadioButtonOff.SetWindowPos(NULL,rcRadioOff.left,rcRadioOff.top,rcRadioOff.Width(),rcRadioOff.Height(),SWP_NOZORDER|SWP_NOREDRAW );

	// Position player list
	CRect rcPlayerList = m_rcPanel;
	rcPlayerList.left = rcChatWord.right + m_ptPlayer.x;
	rcPlayerList.right--;
	rcPlayerList.top += m_ptPlayer.y;
	rcPlayerList.bottom = m_nChatMinHeight - 1;
	m_PlayerList.SetWindowPos(NULL,rcPlayerList.left,rcPlayerList.top, rcPlayerList.Width(), rcPlayerList.Height(), SWP_NOZORDER|SWP_NOREDRAW );

    // initial radio button state
	if(m_bChatOnAtStartUp)
    {
		CheckRadioButton(3,4,3);
        EnableChat(true, false);
    }
	else
    {
		CheckRadioButton(3,4,4);
        EnableChat(false, false);
    }


	// Set palettes to use
#ifndef COPPA
	m_ChatEdit.SendMessage(EM_SETPALETTE, (WPARAM) ZoneShell()->GetPalette(), 0);
#else
	m_QuasiChat.SendMessage(EM_SETPALETTE, (WPARAM) ZoneShell()->GetPalette(), 0);
#endif
	m_ChatDisplay.SendMessage(EM_SETPALETTE, (WPARAM) ZoneShell()->GetPalette(), 0);

	// Load context menu
	m_ContextMenuParent = ResourceManager()->LoadMenu(MAKEINTRESOURCE(IDR_CHAT_MENU));
	m_ContextMenu = GetSubMenu(m_ContextMenuParent,0);

#ifndef COPPA
	m_EditContextMenuParent = ResourceManager()->LoadMenu(MAKEINTRESOURCE(IDR_EDIT_MENU));
	m_EditContextMenu = GetSubMenu(m_EditContextMenuParent,0);
#endif

    return 0;
}

// Loads quasichat strings from resource file and inserts them into combobox
void CChatCtl::LoadChatStrings()
{
	TCHAR buf[ZONE_MAXSTRING];

	long idToLoad = IDS_QUASICHAT_PROMPT;

	// Load common messages first
	while(idToLoad < IDS_QUASICHAT_LAST)
	{
		buf[0] = 0;
		HRESULT hr = ResourceManager()->LoadString(idToLoad, (TCHAR*)buf, NUMELEMENTS(buf));
		if(SUCCEEDED(hr))
		{
			m_QuasiChat.AddString(buf);
		}
		else
			break;

		idToLoad++;
	}
	
	// Then load game specific messages
	idToLoad = m_ChatMessageNdxBegin;
	while( idToLoad <= m_ChatMessageNdxEnd )
	{
		buf[0] = 0;
		HRESULT hr = ResourceManager()->LoadString(idToLoad, (TCHAR*)buf, NUMELEMENTS(buf));
		if(SUCCEEDED(hr))
		{
			m_QuasiChat.AddString(buf);
		}
		else
			break;

		idToLoad++;
	}
}

LRESULT CChatCtl::OnDestroy(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
    if(m_pIAcc)
        m_pIAcc->PopItemlist();

    return 0;
}


void CChatCtl::OnZoneSuspend(DWORD eventId,DWORD groupId,DWORD userId)
{
	if ( GetGroupId() == ZONE_NOGROUP)
		return;

	m_pTDocHistory->New();
}

void CChatCtl::OnChatSystemEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen)
{
	// skip chat from other groups
	if ( groupId != GetGroupId() )
		return;
	
	HandleChatMessage(NULL, (TCHAR*) pData, dataLen, false, m_SystemMessageColor);
}


void CChatCtl::OnChatEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen)
{
	// skip chat from other groups
	if ( groupId != GetGroupId() )
		return;

	// get user's data store
	CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, userId, &pIDS );
	if ( FAILED(hr) )
		return;

//	long ignore = 0;
//	hr = pIDS->GetLong( key_User_IsIgnored, &ignore );
//	if(ignore)
//		return;

//	long classId;
//	pIDS->GetLong( key_ClassId, &classId );

	// get user's name
	TCHAR szUserName[ ZONE_MaxUserNameLen ];
	DWORD dwLen = sizeof(szUserName);
	hr = pIDS->GetString( key_Name, szUserName, &dwLen ); 
	if ( FAILED(hr) )
		return;

	HandleChatMessage(szUserName, (TCHAR *) pData, dataLen, false, GetSysColor(COLOR_WINDOWTEXT));
}

void CChatCtl::HandleChatMessage(TCHAR *pszName, TCHAR *pszMessage, DWORD cbDataLen, bool displayAllBold, COLORREF color)
{
	if (pszMessage == NULL || m_hWnd == NULL || m_bGameTerminated)
		return;

	// Check to see if we're currently at bottom of chat history
	SCROLLINFO si;
	memset(&si, 0, sizeof(si));
	si.cbSize = sizeof(si);
	si.fMask = SIF_ALL;
	::GetScrollInfo(m_ChatDisplay.m_hWnd, SB_VERT, &si);
	// Is the scroll thumb currently at the bottom?
	BOOL bAtEnd = (si.nPage == 0) || (si.nMax - (int) si.nPage <= si.nMin) || // no scrollbar yet
        (si.nPos + (int) si.nPage) >= si.nMax;  // scrollbar at bottom
	
	
	TCHAR nameBuf[ZONE_MAXSTRING];

	// if this is normal message format name into buffer
	if (pszName != NULL)
	{
		// format name if any into buffer plus seperator char
        ZoneFormatMessage(m_tszChatSeperator, nameBuf, NUMELEMENTS(nameBuf), pszName);
	}
	

	if (!m_bFirstChatLine)
	{
		m_ptrgInsert->SetText(m_strNewLine);
		m_ptrgInsert->Collapse(tomEnd);
	}
	m_bFirstChatLine = FALSE;

	

	if(pszName)
	{
		BSTR nameStr = T2BSTR(nameBuf);

		m_pfntName->SetForeColor(color);
		m_ptrgInsert->SetFont(m_pfntName);		// Set font to the name format
		m_ptrgInsert->SetText(nameStr);
		m_ptrgInsert->Collapse(tomEnd);

		SysFreeString(nameStr);
	}

	BSTR messageStr = NULL;
	
#ifdef COPPA
	// check to see if this is a quasichat message and if so, load and display it
	int ndx = 0;

    DWORD cbExtra = cbDataLen - (lstrlen(pszMessage) + 1) * sizeof(*pszMessage);
    if(cbExtra >= sizeof(WORD))
        ndx = *(WORD *) ((BYTE *) pszMessage + cbDataLen - cbExtra);

    if(!ndx)
        ndx = GetQuasiChatMessageIndex(pszMessage);

	if(ndx)
	{
		TCHAR buf[ZONE_MAXSTRING];
		buf[0] = 0;
		// not the fastest thing in the world, but this should be ok
		if(ResourceManager()->LoadString(IDS_QUASICHAT_PROMPT + ndx, buf, NUMELEMENTS(buf)) > 0)
			messageStr = T2BSTR(buf);
	}

	if(!messageStr)
	{
		messageStr = T2BSTR(pszMessage);
	}
#else
	messageStr = T2BSTR(pszMessage);
#endif

	m_pfntText->SetForeColor(color);
	if(!displayAllBold)
		m_ptrgInsert->SetFont(m_pfntText);		// Set font to the text format
	m_ptrgInsert->SetText(messageStr);
	m_ptrgInsert->Collapse(tomEnd);

	SysFreeString(messageStr);

	// if we were at bottom of chat history, make sure we're still at the bottom
	if (bAtEnd)
	{
		ScrollToEnd();
	}
	
}

int CChatCtl::GetQuasiChatMessageIndex(TCHAR* str)
{
	if(*str == _T('/'))
	{
		return zatol(++str);
	}
	return 0;
}

LRESULT CChatCtl::OnButtonDownChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if (!m_bHasTypedInEntry)
	{
		m_EntryRange->Delete(tomCharacter,0,0);
		m_bHasTypedInEntry = TRUE;
	}
	
	bHandled = FALSE;
	return 0;
}

LRESULT CChatCtl::OnKeyDownChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(wParam == VK_RETURN)
	{
        if(m_fFocusKept)
        {
            if(m_pIAcc)
                m_pIAcc->SetGlobalFocus(m_dwFocusID);

            m_fFocusKept = false;
        }

		SendChat();
		return 0;
	}

	bHandled = FALSE;
	return 0;
}

LRESULT CChatCtl::OnCharChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(!m_bHasTypedInEntry)
	{
		m_EntryRange->Delete(tomCharacter,0,0);
		m_bHasTypedInEntry = TRUE;
	}

	bHandled = FALSE;
	return 0;
}

LRESULT CChatCtl::OnCharComboBox(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	if((wParam == VK_DOWN || wParam == VK_UP) && (GetKeyState(VK_CONTROL) & 0x8000))  // ctrl - up or ctr - down
	{
		m_QuasiChat.ShowDropDown();
		return 0;
	}
	bHandled = FALSE;
	return 0;
}

LRESULT CChatCtl::OnDestroyEntry(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_ChatEdit.DefWindowProc(nMsg, wParam, lParam);
	m_ChatEdit.UnsubclassWindow();
	return 0;
}

LRESULT CChatCtl::OnDestroyHistory(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_ChatDisplay.DefWindowProc(nMsg, wParam, lParam);
	m_ChatDisplay.UnsubclassWindow();
	return 0;
}

LRESULT CChatCtl::IgnoreKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	switch (wParam)
	{
	case VK_DOWN:
	case VK_UP:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_END:
	case VK_HOME:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_TAB:
		bHandled = FALSE;
		break;
	case 'C':
		if (GetKeyState(VK_CONTROL) & 0x8000)		// If this is CTRL-C or allow copy command...
			bHandled = FALSE;
		break;
	case VK_INSERT:
		if (GetKeyState(VK_CONTROL) & 0x8000 &&
			(GetKeyState(VK_SHIFT)  & 0x8000) == 0)		// If this is CTRL-Insert, allow copy command...
			bHandled = FALSE;
		break;
	}
	return 0;
}

LRESULT CChatCtl::Ignore(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 0;		//Ignore them.
}

void CChatCtl::SendChat()
{

#ifndef COPPA
	if (!m_bHasTypedInEntry)
		return;
#endif

	// Scroll history to end
	ScrollToEnd();

#ifndef COPPA
	// Get the message to send
	m_EntryRange->SetStart(0);
	m_EntryRange->MoveEnd(tomStory,1,NULL); // move endpoint to end
	m_EntryRange->MoveEnd(tomCharacter,-1,NULL); // don't include \n which is always at the end of the range
	BSTR str = NULL;
	HRESULT hr = m_EntryRange->GetText(&str);
	m_EntryRange->Delete(tomCharacter,0,NULL);
	m_ChatEdit.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_font,0);  // gets rid of any char formatting that might have been pasted in

	if( SysStringLen(str) > 0 )
	{
#ifdef _DEBUG
        long id = 0;
        if(lstrlen(str) > 7 && str[7] == _T(' '))
        {
            str[7] = _T('\0');
            if(!lstrcmpi(str, _T("/dialog")))
                id = zatol(&str[8]);
            str[7] = _T(' ');
        }
        if(id)
        {
            ZoneShell()->AlertMessage(NULL, MAKEINTRESOURCE(id), _T("Debug Dialog"), AlertButtonOK);
            if(str)
                SysFreeString(str);
            return;
        }

        TCHAR szUrl[ZONE_MAXSTRING] = _T("");
        if(lstrlen(str) > 6 && str[6] == _T(' '))
        {
            str[6] = _T('\0');
            if(!lstrcmpi(str, _T("/adurl")))
                lstrcpy(szUrl, str + 7);
            str[6] = _T(' ');
        }
        if(szUrl[0])
        {
            const TCHAR *arKeys[] = { key_WindowManager, key_Upsell, key_AdURL };
            DataStoreUI()->SetString(arKeys, 3, szUrl);
            if(str)
                SysFreeString(str);
            return;
        }
#endif _DEBUG


		EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_SEND, GetGroupId(), GetUserId(), str, (lstrlen(str)+1)*sizeof(TCHAR));
	}
	
	if(str)
		SysFreeString(str);
#else
	TCHAR buf[ZONE_MAXSTRING];

	LRESULT sel = m_QuasiChat.GetCurSel();
	
	if(sel && sel != CB_ERR)
	{
		// convert selection to chat message index
		if(sel >= IDS_QUASICHAT_LAST - IDS_QUASICHAT_PROMPT)
			sel += m_ChatMessageNdxBegin - IDS_QUASICHAT_LAST;

        TCHAR sz[ZONE_MAXSTRING] = _T("");
		ResourceManager()->LoadString(IDS_QUASICHAT_PROMPT + sel, sz, NUMELEMENTS(sz));

        // add the index as a character after the terminating NULL.  once all clients understand this protocol, the
        // "/#" method can be phased out.  This allows better extensibility later (new messages can be added that
        // simply come out untranslated when received by an older client)
		wsprintf(buf, _T("/%d %s\0"), sel, sz);
        buf[lstrlen(buf) + 1] = (TCHAR) sel;

		//m_QuasiChat.GetLBText(sel,buf);
		EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_SEND, GetGroupId(), GetUserId(), buf, (lstrlen(buf) + 2) * sizeof(TCHAR));
		m_QuasiChat.SetCurSel(0);
	}

#endif COPPA

}

void CChatCtl::ScrollToEnd()
{
	// scroll the thumb down to the bottom - which brings the 
	// bottom text into view

	SCROLLINFO si;
	memset(&si, 0, sizeof(si));
	si.cbSize = sizeof(si);
	si.fMask = SIF_ALL;
	::GetScrollInfo(m_ChatDisplay.m_hWnd, SB_VERT, &si);

	// if we don't have a visible scrollbar, bail.  be sure we're at the top
	if ( (si.nPage == 0) || (si.nMax - (int) si.nPage <= si.nMin) )
    {
        m_ptrgWhole->MoveStart(tomStory, -1, NULL);
        m_ptrgWhole->MoveEnd(tomStory, 1, NULL);
	    m_ptrgWhole->ScrollIntoView(tomStart);
		return;
    }

    si.nPos = si.nMax - (si.nPage - 1);
	m_ChatDisplay.SendMessage(WM_VSCROLL, MAKEWPARAM(SB_THUMBPOSITION, si.nPos) , NULL);
}

LRESULT CChatCtl::OnContext(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int  cMenuItems = m_ContextMenu.GetMenuItemCount(); 
    UINT id; 
    UINT fuFlags; 

	// is there any text selected?

	CHARRANGE rgc;
	::SendMessage(m_ChatDisplay, EM_EXGETSEL, 0, (LPARAM)	&rgc);
	bool sel = rgc.cpMax != rgc.cpMin;
 
    for (int nPos = 0; nPos < cMenuItems; nPos++) 
    { 
        id = m_ContextMenu.GetMenuItemID(nPos); 
 
        switch (id) 
        { 
		case IDM_UNDO:
        case IDM_CUT: 
        case IDM_DELETE: 
        case IDM_PASTE: 
            fuFlags = MF_BYCOMMAND | MF_GRAYED; 
            m_ContextMenu.EnableMenuItem( id, fuFlags); 
            break; 
        case IDM_COPY: 
			fuFlags = sel ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED; 
            m_ContextMenu.EnableMenuItem( id, fuFlags); 

			break;  
        } 
    } 

	int xPos = LOWORD(lParam); 
	int yPos = HIWORD(lParam); 
	
	int ret = m_ContextMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_NONOTIFY|TPM_RETURNCMD,xPos,yPos,m_hWnd);
	if(ret)
		PostMessage(WM_COMMAND,MAKEWPARAM(ret,0),(LPARAM)(HWND)m_ChatDisplay);
	
	int err = GetLastError();

	return 0;
}

LRESULT CChatCtl::OnEditContext(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int  cMenuItems = m_EditContextMenu.GetMenuItemCount(); 
    UINT id; 
    UINT fuFlags; 
	
	// is there any text selected?
	CHARRANGE rgc;
	::SendMessage(m_ChatEdit, EM_EXGETSEL, 0, (LPARAM)	&rgc);
	bool sel = rgc.cpMax != rgc.cpMin;

    for (int nPos = 0; nPos < cMenuItems; nPos++) 
    { 
        id = m_EditContextMenu.GetMenuItemID(nPos); 
 
        switch (id) 
        { 
		case IDM_UNDO:
            fuFlags = MF_BYCOMMAND | MF_GRAYED; 
            m_EditContextMenu.EnableMenuItem( id, fuFlags); 
			break;
        case IDM_CUT: 
        case IDM_DELETE: 
        case IDM_COPY: 
			fuFlags = sel ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED; 
            m_EditContextMenu.EnableMenuItem( id, fuFlags); 
            break; 
        case IDM_PASTE: 
                m_EditContextMenu.EnableMenuItem(id, 
					IsClipboardFormatAvailable(CF_TEXT) ?  MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED ); 
 
        } 
    } 

	int xPos = LOWORD(lParam); 
	int yPos = HIWORD(lParam); 
	
	int ret = m_EditContextMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN |TPM_NONOTIFY|TPM_RETURNCMD ,xPos,yPos,m_hWnd);
	
	if(ret)
		PostMessage(WM_COMMAND,MAKEWPARAM(ret,0),(LPARAM)(HWND)m_ChatEdit);

	int err = GetLastError();
	
	return 0;
}

LRESULT CChatCtl::OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CalcDisplayRects();

	m_ChatDisplay.SetWindowPos(0, m_DisplayRect.left, m_DisplayRect.top, m_DisplayRect.Width(), m_DisplayRect.Height(), SWP_NOZORDER );

#ifndef COPPA
	// center button 
	int sendHeight = m_SendButton.GetHeight();
	int editHeight = m_EditRect.bottom - m_EditRect.top;
	int diff = editHeight - sendHeight;
	int y=m_EditRect.top + 1;
	if(diff>0)
		y+=diff/2;

	m_ChatEdit.SetWindowPos(0, m_EditRect.left, m_EditRect.top, m_EditRect.Width(), m_EditRect.Height(), SWP_NOZORDER);
	m_SendButton.SetWindowPos(NULL,m_EditRect.right,y,0,0,SWP_NOSIZE|SWP_NOZORDER );
#else
	m_QuasiChat.SetWindowPos(0, m_EditRect.left, m_EditRect.top, m_EditRect.Width(), m_EditRect.Height(), SWP_NOZORDER);
#endif
	
	/*
	CRect rcChatWord = m_rcChatWord;
    rcChatWord.OffsetRect(m_rcPanel.left, m_rcPanel.top);

	MINMAXINFO minmaxinfo;
	m_RadioButtonOn.SendMessage(WM_GETMINMAXINFO,0,(LPARAM)&minmaxinfo);

	rcRadioOn.left = m_rcPanel.left+1;
	rcRadioOn.right = rcRadioOn.left + rcChatWord.Width();
	rcRadioOn.top = m_rcPanel.top+rcChatWord.Height()+1;
	rcRadioOn.bottom = rcRadioOn.top+minmaxinfo.ptMinTrackSize.y;
	CRect rcRadioOff = rcRadioOn;
	rcRadioOff.top = rcRadioOn.bottom;
	rcRadioOff.bottom = rcRadioOff.top+minmaxinfo.ptMinTrackSize.y;

	CRect rcRadioOn;
	rcRadioOn.left = m_rcPanel.left + m_rcChatWord.left + m_ptOnOff.x;
	rcRadioOn.right = rcRadioOn.left + rcChatWord.Width() - m_ptOnOff.x;
	rcRadioOn.top = m_rcPanel.top + rcChatWord.Height() + m_ptOnOff.y;
	rcRadioOn.bottom = rcRadioOn.top + m_RadioButtonHeight;
	CRect rcRadioOff = rcRadioOn;
	rcRadioOff.top = rcRadioOn.bottom;
	rcRadioOff.bottom = rcRadioOff.top + m_RadioButtonHeight;

	m_RadioButtonOn.SetWindowPos(NULL,rcRadioOn.left,rcRadioOn.top,rcRadioOn.Width(),rcRadioOn.Height(),SWP_NOZORDER|SWP_NOREDRAW );
	m_RadioButtonOff.SetWindowPos(NULL,rcRadioOff.left,rcRadioOff.top,rcRadioOff.Width(),rcRadioOff.Height(),SWP_NOZORDER|SWP_NOREDRAW );

	// Position player list
	CRect rcPlayerList = m_rcPanel;
	rcPlayerList.left = rcChatWord.right + 1;
	rcPlayerList.right--;
	rcPlayerList.top++;
	rcPlayerList.bottom--;
	m_PlayerList.SetWindowPos(NULL,rcPlayerList.left,rcPlayerList.top, rcPlayerList.Width(), rcPlayerList.Height(), SWP_NOZORDER|SWP_NOREDRAW );

	InvalidateRect(m_rcChatWord);

	if (IsWindowVisible()) // Only when window is up and visible.
		CalcOriginalPanelRect();
	*/

	return 0;
}

LRESULT CChatCtl::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
#ifndef COPPA
	// Set focus to the edit window.
    if(m_ChatEdit.IsWindowEnabled())
	    m_ChatEdit.SetFocus();
#else
	if(m_QuasiChat.IsWindowEnabled())
		m_QuasiChat.SetFocus();
#endif
    else
        if(m_RadioButtonOn.SendMessage(BM_GETCHECK, 0, 0) == BST_CHECKED)
            m_RadioButtonOn.SetFocus();
        else
            m_RadioButtonOff.SetFocus();
	return 0;
}

LRESULT CChatCtl::OnErase(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = true;
    return 1;
}


BOOL CChatCtl::SuperScreenToClient(LPRECT lpRect)
{
    BOOL ret;
    ret = ScreenToClient(lpRect);
    if(ret && lpRect->left > lpRect->right)
    {
        lpRect->left ^= lpRect->right;
        lpRect->right ^= lpRect->left;
        lpRect->left ^= lpRect->right;
    }
    return ret;
}


LRESULT CChatCtl::OnPrintClient(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC hdc = (HDC) wParam;

    bHandled = FALSE;

    if((lParam & PRF_CHECKVISIBLE) && !IsWindowVisible())
        return 0;

    // as far as i can tell, this is a performance hack they're forcing us to do
    // to support themes, where we have to paint the various backgrounds.
    if(lParam & (PRF_CLIENT | PRF_ERASEBKGND | PRF_CHILDREN))
    {
        COLORREF colOld = GetTextColor(hdc);
        COLORREF colOldBk = GetBkColor(hdc);

        HBRUSH hBrush = (HBRUSH) SendMessage(WM_CTLCOLORBTN, wParam, 0);

        RECT rc;
        m_RadioButtonOn.GetWindowRect(&rc);
        SuperScreenToClient(&rc);
        FillRect(hdc, &rc, hBrush);

        m_RadioButtonOff.GetWindowRect(&rc);
        SuperScreenToClient(&rc);
        FillRect(hdc, &rc, hBrush);

        SetTextColor(hdc, colOld);
        SetBkColor(hdc, colOldBk);
    }

    return 0;
}


HRESULT CChatCtl::OnDraw(ATL_DRAWINFO &di)
{
	// Erase all areas but where send and chat display controls are
	CRect& rcBounds = *(CRect*)di.prcBounds;
	CDrawDC dc = di.hdcDraw;

	RECT rc;
	GetClientRect(&rc);

    CRect rcChatWord;

    HPALETTE oldPal = dc.SelectPalette(ZoneShell()->GetPalette(), TRUE);
	dc.RealizePalette();

	dc.ExcludeClipRect(&m_EditRect);
	dc.ExcludeClipRect(&m_DisplayRect);

	// Fill the margin between Display and Edit areas with Black. 
	RECT rcMargin, rct;
	rcMargin.top = m_DisplayRect.bottom;
	rcMargin.left = rc.left;
	rcMargin.right = m_rcPanel.left;
	rcMargin.bottom = m_EditRect.top;

	dc.FillRect(&rcMargin, GetSysColorBrush(COLOR_3DFACE));

    // do this piecemeal to avoid flicker, and exclude as much as possible
    RECT rcTemp;

    m_RadioButtonOn.GetWindowRect(&rcTemp);
    ScreenToClient(&rcTemp);
    if(rcTemp.right < rcTemp.left)  // RTL
    {
        rcTemp.right ^= rcTemp.left;
        rcTemp.left ^= rcTemp.right;
        rcTemp.right ^= rcTemp.left;
    }
    dc.ExcludeClipRect(&rcTemp);

    m_RadioButtonOff.GetWindowRect(&rcTemp);
    ScreenToClient(&rcTemp);
    if(rcTemp.right < rcTemp.left)  // RTL
    {
        rcTemp.right ^= rcTemp.left;
        rcTemp.left ^= rcTemp.right;
        rcTemp.right ^= rcTemp.left;
    }
    dc.ExcludeClipRect(&rcTemp);

    m_PlayerList.GetWindowRect(&rcTemp);
    ScreenToClient(&rcTemp);
    if(rcTemp.right < rcTemp.left)  // RTL
    {
        rcTemp.right ^= rcTemp.left;
        rcTemp.left ^= rcTemp.right;
        rcTemp.right ^= rcTemp.left;
    }
    dc.ExcludeClipRect(&rcTemp);

    CRect rcSide(0, 0, m_rcChatWord.left - 1, m_rcPanel.bottom - m_rcPanel.top);
    rcSide.OffsetRect(m_rcPanel.left, m_rcPanel.top);
    dc.FillRect(&rcSide, GetSysColorBrush(COLOR_3DFACE));

    CRect rcChat(m_rcChatWord);
    rcChat.OffsetRect(m_rcPanel.left, m_rcPanel.top);
    dc.FillRect(&rcChat, GetSysColorBrush(COLOR_3DFACE));

    CRect rcRadio(m_rcChatWord.left, m_rcChatWord.bottom + 1, m_rcChatWord.right, m_rcPanel.bottom - m_rcPanel.top - 1);
    rcRadio.OffsetRect(m_rcPanel.left, m_rcPanel.top);
    dc.FillRect(&rcRadio, GetSysColorBrush(COLOR_3DFACE));

    CRect rcPlayer(m_rcChatWord.right + 1, 0, m_rcPanel.right - m_rcPanel.left, m_rcPanel.bottom - m_rcPanel.top - 1);
    rcPlayer.OffsetRect(m_rcPanel.left, m_rcPanel.top);
    dc.FillRect(&rcPlayer, GetSysColorBrush(COLOR_3DFACE));

#ifndef COPPA
	CRect buttonRect(m_EditRect.right, m_EditRect.top, m_DisplayRect.right, m_EditRect.bottom);
    dc.FillRect(&buttonRect, GetSysColorBrush(m_SendButton.IsWindowEnabled() ? COLOR_WINDOW : COLOR_3DFACE));
#endif


	// Draw panel boxes
    if(m_hPanelPen)
    {
        HPEN hOldPen = dc.SelectPen(m_hPanelPen);

        POINT rgPts[8];

        rgPts[0].x = m_rcPanel.right - 1;
        rgPts[0].y = m_rcPanel.top + m_rcChatWord.top;

        rgPts[1].x = rgPts[0].x;
        rgPts[1].y = m_rcPanel.bottom - 1;

        rgPts[2].x = m_rcPanel.left + m_rcChatWord.left - 1;
        rgPts[2].y = rgPts[1].y;

        rgPts[3].x = rgPts[2].x;
        rgPts[3].y = rgPts[0].y;

        rgPts[4].x = rgPts[3].x;
        rgPts[4].y = m_rcPanel.top + m_rcChatWord.bottom;

        rgPts[5].x = m_rcPanel.left + m_rcChatWord.right;
        rgPts[5].y = rgPts[4].y;

        rgPts[6].x = rgPts[5].x;
        rgPts[6].y = rgPts[0].y;

        rgPts[7].x = rgPts[6].x;
        rgPts[7].y = rgPts[1].y;

        dc.Polyline(rgPts, 8);

        if(hOldPen) 
            dc.SelectPen(hOldPen);
        else
            dc.SelectPen(GetStockObject(BLACK_PEN));
    }

	// Draw chat word
    HFONT hOldFont = dc.SelectFont(m_fontPanelChat);
    COLORREF oldColor = dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
    dc.SetBkMode(TRANSPARENT);

    rcChatWord = m_rcChatWord;
    rcChatWord.OffsetRect(m_rcPanel.left, m_rcPanel.top);
    rcChatWord.left += m_ptChatWord.x;
    rcChatWord.top += m_ptChatWord.y;
    dc.DrawText(m_tszChatWord, -1, &rcChatWord, DT_TOP | DT_LEFT);

    GdiFlush();

	dc.SetTextColor(oldColor);
	dc.SelectPalette(oldPal, TRUE);
	dc.SelectFont( hOldFont );

	return TRUE;
}

LRESULT CChatCtl::OnCtlColorListBox(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HDC dc = (HDC)wParam;

	SetBkColor(dc,GetSysColor(COLOR_3DFACE));

	return (BOOL)GetSysColorBrush(COLOR_3DFACE);
}

LRESULT CChatCtl::OnCtlColorComboBox(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HDC dc = (HDC)wParam;

    SetTextColor(dc, GetSysColor(COLOR_WINDOWTEXT));
	SetBkColor(dc,GetSysColor(COLOR_WINDOW));

	return (BOOL)GetSysColorBrush(COLOR_WINDOW);
}

LRESULT CChatCtl::OnCtlColorStatic(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HDC dc = (HDC)wParam;

    SetTextColor(dc, GetSysColor(COLOR_BTNTEXT));
	SetBkColor(dc,GetSysColor(COLOR_3DFACE));

	return (BOOL)GetSysColorBrush(COLOR_3DFACE);
}

LRESULT CChatCtl::OnCtlColorButton(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HDC dc = (HDC)wParam;

    SetTextColor(dc, GetSysColor(COLOR_BTNTEXT));
	SetBkColor(dc,GetSysColor(COLOR_3DFACE));

	return (BOOL)GetSysColorBrush(COLOR_3DFACE);
}

/*
LRESULT CChatCtl::OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CPaintDC dc(m_hWnd);
    HPALETTE oldPal;
    CRect rcChatWord;

    oldPal = dc.SelectPalette(ZoneShell()->GetPalette(), TRUE);
	dc.RealizePalette();
	dc.SelectPalette(oldPal, TRUE);

	return 0;
}
*/

LRESULT CChatCtl::OnClear(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_pTDocHistory->New();
	m_bFirstChatLine = TRUE;	// Beta2 Bug #15365 - On Clear the Firstline flag should be set
	return 0;
}

LRESULT CChatCtl::OnSelectAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	if(hWndCtl)
	{
		// Force entire contents to be selected
		CHARRANGE rgc;
		rgc.cpMin = 0;
		rgc.cpMax = -1;
		::SendMessage(hWndCtl, EM_EXSETSEL, 0, (LPARAM)	&rgc);
	}

	return 0;
}

LRESULT CChatCtl::OnQuasiChat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled) 
{
    if(wNotifyCode == CBN_SELENDOK)
    {
        if(m_fComboDown)
            m_fComboEndOk = true;
        return 0;
    }

    if(wNotifyCode == CBN_SELENDCANCEL)
    {
        if(m_fComboDown)
            m_fComboEndOk = false;
        return 0;
    }

    if(wNotifyCode == CBN_DROPDOWN)
    {
        m_fComboDown = true;
        m_pIAcc->SetItemWantKeys(ZACCESS_WantSpace | ZACCESS_WantEnter | ZACCESS_WantAllArrows, ID_CHAT_SEND_ACC, false);
        return 0;
    }

    ASSERT(wNotifyCode == CBN_CLOSEUP);
    m_fComboDown = false;
    m_pIAcc->SetItemWantKeys(ZACCESS_WantSpace | ZACCESS_WantAllArrows, ID_CHAT_SEND_ACC, false);

    if(m_fComboEndOk)
    {
        if(m_fFocusKept)
        {
            if(m_pIAcc)
                m_pIAcc->SetGlobalFocus(m_dwFocusID);

            m_fFocusKept = false;
        }

	    SendChat();
    }

    m_fComboEndOk = false;

	return 0;
}

LRESULT CChatCtl::OnClipboardCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	int msg = 0;

	switch(wID)
	{
	case IDM_CUT:
		msg = WM_CUT;
		break;
	case IDM_COPY:
		msg = WM_COPY;
		break;
	case IDM_PASTE:
		msg = WM_PASTE;
		break;
	case IDM_DELETE:
		msg = WM_CLEAR;
		break;
	}

	if(msg)
		::PostMessage(hWndCtl, msg, 0 , 0);

	return 0;

}


void CChatCtl::OnReloadPreferences(DWORD eventId,DWORD groupId,DWORD userId)
{
	LoadPreferences();
}


LRESULT CChatCtl::OnChatSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	SendChat();

    SetFocus();

	return 0; 
}

LRESULT CChatCtl::OnChooseFont(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	CHOOSEFONT cf;
	LOGFONT	lf;

	ChooseFontFromCharFormat(&cf, &lf, &m_cfCurFont, m_hWnd);

	if (ChooseFont(&cf))
	{
		CharFormatFromChooseFont(&cf, &m_cfCurFont);
		WritePreferences();
		EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_CHAT_FONT, 0, 0, NULL, 0);

		m_ChatEdit.SendMessage(EM_SETCHARFORMAT, 0, (LPARAM)&m_cfCurFont);
		TextFontFromCharFormat(m_pfntText, &m_cfCurFont);
		TextFontFromCharFormat(m_pfntName, &m_cfCurFont);
		m_pfntName->SetBold(tomTrue);
	}

	return 0;
}
LRESULT CChatCtl::OnSysColorChange(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	m_ChatDisplay.SendMessage(WM_SETFONT,(WPARAM)(HFONT)m_font,0);
	
	// If this color matches with window bkgnd then it should be changed to a readable one.
	VerifySystemMsgColor(m_SystemMessageColor);

	return TRUE;
}


LRESULT CChatCtl::OnSetFocusDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pIAcc->SetFocus(ID_CHAT_HISTORY_ACC, false);
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnKillFocusEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_fFocusKept = false;
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnSetFocusEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pIAcc->SetFocus(ID_CHAT_SEND_ACC, false);
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnSetFocusOn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pIAcc->SetFocus(ID_CHAT_ON_ACC, false);
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnSetFocusOff(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pIAcc->SetFocus(ID_CHAT_OFF_ACC, false);
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnEnableDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pIAcc->SetItemEnabled(wParam ? true : false, ID_CHAT_HISTORY_ACC, false);
    bHandled = false;
    return 0;
}


LRESULT CChatCtl::OnEnableEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(!wParam)
        m_fFocusKept = false;

    m_pIAcc->SetItemEnabled(wParam ? true : false, ID_CHAT_SEND_ACC, false);
    m_pIAcc->SetItemEnabled(wParam ? true : false, ID_CHAT_CHAT_ACC, false);
    bHandled = false;
    return 0;
}

#ifdef COPPA
LRESULT CChatCtl::OnEnableCombo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(!wParam)
        m_fFocusKept = false;

    m_pIAcc->SetItemEnabled(wParam ? true : false, ID_CHAT_SEND_ACC, false);
    m_pIAcc->SetItemEnabled(wParam ? true : false, ID_CHAT_CHAT_ACC, false);
    bHandled = false;
    return 0;
}
#endif


// IAccessibleControl
STDMETHODIMP_(DWORD) CChatCtl::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
    switch(m_pIAcc->GetItemID(nIndex))
    {
        case ID_CHAT_HISTORY_ACC:
            m_ChatDisplay.SetFocus();
            break;

        case ID_CHAT_SEND_ACC:
#ifndef COPPA
            m_ChatEdit.SetFocus();
#else
			m_QuasiChat.SetFocus();
#endif
            break;

        case ID_CHAT_ON_ACC:
            m_RadioButtonOn.SendMessage(BM_CLICK);
            break;

        case ID_CHAT_OFF_ACC:
            m_RadioButtonOff.SendMessage(BM_CLICK);
            break;

        case ID_CHAT_CHAT_ACC:
            break;
    }

    return 0;
}


STDMETHODIMP_(DWORD) CChatCtl::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
    switch(m_pIAcc->GetItemID(nIndex))
    {
        case ID_CHAT_HISTORY_ACC:
            break;

        case ID_CHAT_SEND_ACC:
#ifndef COPPA
            m_SendButton.ButtonPressed();
#else
            if(m_fFocusKept)
            {
                if(m_pIAcc)
                    m_pIAcc->SetGlobalFocus(m_dwFocusID);

                m_fFocusKept = false;
            }

            SendChat();
#endif
            break;

        case ID_CHAT_ON_ACC:
            // do nothing because radio buttons do not distinguish between focus and selection
            break;

        case ID_CHAT_OFF_ACC:
            // do nothing because radio buttons do not distinguish between focus and selection
            break;

        case ID_CHAT_CHAT_ACC:
#ifndef COPPA
            m_ChatEdit.SetFocus();
#else	
			m_QuasiChat.SetFocus();
#endif
            break;
    }

    return 0;
}


STDMETHODIMP_(bool) CChatCtl::HandleChar(HWND *phWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD time)
{
// IME - real chat only
#ifndef COPPA
	// if getting a startcomposition and not the chat window then someone's typing on something like the radio button
	// so we need to set the ime context to the chat window
	if(uMsg == WM_IME_STARTCOMPOSITION && (*phWnd != m_ChatEdit.m_hWnd))
	{
		::SendMessage(*phWnd, WM_IME_SETCONTEXT,FALSE,ISC_SHOWUIALL);
		if(m_ChatEdit.IsWindow())
		{
			::SendMessage(m_ChatEdit.m_hWnd, WM_IME_SETCONTEXT,TRUE,ISC_SHOWUIALL);
		}
	}

	// if someone's trying to type on something other than the chat window and chat is disabled
	// we need to clear the composition string otherwise when we enable chat there'll be some 
	// bogus chars 
	if(*phWnd != m_ChatEdit.m_hWnd && m_ChatEdit.IsWindow() && !m_ChatEdit.IsWindowEnabled())
	{
		if(uMsg == WM_IME_SETCONTEXT || uMsg == WM_IME_STARTCOMPOSITION || uMsg==WM_IME_COMPOSITION || uMsg == WM_IME_NOTIFY ||
			uMsg == WM_IME_SELECT)
		{
			HIMC himc = ImmGetContext(*phWnd);
			if(himc)
			{
				ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
				ImmReleaseContext(*phWnd,himc);
			}

			return true;
		}
	}
#endif

    if(!(uMsg == WM_CHAR || uMsg == WM_DEADCHAR || uMsg == WM_IME_SETCONTEXT || uMsg == WM_IME_STARTCOMPOSITION || uMsg==WM_IME_COMPOSITION || 
		uMsg == WM_IME_NOTIFY || uMsg == WM_IME_SELECT ) || wParam == _T(' ') || !m_pIAcc)
        return false;

    // only process if the main window is active
    HWND hWnd = ZoneShell()->GetFrameWindow();
    if(!hWnd || hWnd != GetActiveWindow())
        return false;

#ifndef COPPA  // regular chat
    if(*phWnd != m_ChatEdit.m_hWnd && m_ChatEdit.IsWindow())
    {
		if(m_ChatEdit.IsWindowEnabled())
		{
			HRESULT hr = m_pIAcc->GetGlobalFocus(&m_dwFocusID);
			if(SUCCEEDED(hr))
				m_fFocusKept = true;
			m_ChatEdit.SetFocus();
	        *phWnd = m_ChatEdit.m_hWnd;
		}
    }
#else   // combo box
    if(*phWnd != m_QuasiChat.m_hWnd && m_QuasiChat.IsWindow())
    {
		if(m_QuasiChat.IsWindowEnabled())
		{
			HRESULT hr = m_pIAcc->GetGlobalFocus(&m_dwFocusID);
			if(SUCCEEDED(hr))
				m_fFocusKept = true;
			m_QuasiChat.SetFocus();
	        *phWnd = m_QuasiChat.m_hWnd;
		}
    }
#endif

    return false;
}


void CChatCtl::VerifySystemMsgColor(COLORREF& color)
{	// If the system msg color is white or it is not the same as the window color then 
	// keep the color read from the data store. Otherwise chose a more readable color.
	if ((GetSysColor(COLOR_WINDOW) == RGB(255, 255, 255)) || (color != GetSysColor(COLOR_WINDOW)))
		color = m_OrgSystemMessageColor;
	else
		color = GetSysColor(COLOR_BTNTEXT);
}

/*
void CChatCtl::CalcOriginalPanelRect()
{
	//GetClientRect(&m_rcPanelOld);
	m_rcPanelOld = m_rcPanel;
	//m_rcPanelOld.left = m_rcPanelOld.right - m_nPanelWidth;

	CRect rcChatWord = m_rcChatWord;
    rcChatWord.OffsetRect(m_rcPanel.left, m_rcPanel.top);
	CRect rcRadioOn;
	rcRadioOn.top = m_rcPanel.top + rcChatWord.Height() + m_ptOnOff.y;
	rcRadioOn.bottom = rcRadioOn.top + m_RadioButtonHeight;

	CRect rcRadioOff = rcRadioOn;
	rcRadioOff.top = rcRadioOn.bottom;
	rcRadioOff.bottom = rcRadioOff.top + m_RadioButtonHeight;

	m_rcPanelOld.bottom = rcRadioOff.bottom;
	//m_rcPanelOld.UnionRect (m_rcPanelOld, m_rcChatWord);
}
*/

#define TWIPS_PER_INCH        1440

//
// Font conversion routines.  These convert CHARFORMATs into CHOOSEFONT/LOGFONT structures
// and back
//
// pcf, plf        Sturctures to be filled
// pchf            Structure containing source information
// hWnd            Intended owner of dialog in ChooseFont call
void ChooseFontFromCharFormat(CHOOSEFONT* pcf, LOGFONT* plf, CHARFORMAT* pchf, HWND hWnd)
{
    memset(pcf, 0, sizeof(CHOOSEFONT));
    memset(plf, 0, sizeof(LOGFONT));

    HDC hdc = ::GetDC(NULL);
    plf->lfHeight = -MulDiv(pchf->yHeight, GetDeviceCaps(hdc, LOGPIXELSY), TWIPS_PER_INCH);
    ::ReleaseDC(NULL, hdc);

    plf->lfWeight = (pchf->dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL; 
    plf->lfItalic = (pchf->dwEffects & CFE_ITALIC) != 0;
    plf->lfUnderline = (pchf->dwEffects & CFE_UNDERLINE) != 0;
    plf->lfStrikeOut = (pchf->dwEffects & CFE_STRIKEOUT) != 0;
    plf->lfCharSet = pchf->bCharSet;
    plf->lfPitchAndFamily = pchf->bPitchAndFamily;
    lstrcpy(plf->lfFaceName, pchf->szFaceName);

    pcf->lStructSize = sizeof(CHOOSEFONT); 
    pcf->hwndOwner   = hWnd;
    pcf->lpLogFont   = plf; 
    pcf->iPointSize  = pchf->yHeight / 2;        // yHeight is in TWIPS, iPointSize in 1/10th points
    pcf->Flags       = CF_INITTOLOGFONTSTRUCT | CF_EFFECTS | CF_SCRIPTSONLY | CF_SCREENFONTS; 
    pcf->rgbColors   = pchf->crTextColor;
}

void CharFormatFromChooseFont(CHOOSEFONT* pcf, CHARFORMAT* pchf)
{
    LOGFONT* plf = pcf->lpLogFont;

    pchf->cbSize  = sizeof(CHARFORMAT);
    pchf->yHeight = pcf->iPointSize * 2;
    pchf->crTextColor = pcf->rgbColors;
    pchf->dwEffects  = (pcf->nFontType & BOLD_FONTTYPE) ? CFE_BOLD : 0;
    pchf->dwEffects |= (pcf->nFontType & ITALIC_FONTTYPE) ? CFE_ITALIC : 0;
    pchf->dwEffects |= (plf->lfUnderline) ? CFE_UNDERLINE : 0;
    pchf->dwEffects |= (plf->lfStrikeOut) ? CFE_STRIKEOUT : 0;
    pchf->bCharSet = plf->lfCharSet;
    pchf->bPitchAndFamily = plf->lfPitchAndFamily;
    lstrcpy(pchf->szFaceName, plf->lfFaceName);
}

void TextFontFromCharFormat(ITextFont* pfnt, CHARFORMAT* pcf)
{

	if (pcf->dwMask & CFM_BOLD)
		pfnt->SetBold((pcf->dwEffects & CFE_BOLD) ? tomTrue : tomFalse);

	if (pcf->dwMask & CFM_ITALIC)
		pfnt->SetItalic((pcf->dwEffects & CFE_ITALIC) ? tomTrue : tomFalse);

	if (pcf->dwMask & CFM_STRIKEOUT)
		pfnt->SetStrikeThrough((pcf->dwEffects & CFE_STRIKEOUT) ? tomTrue : tomFalse);

	if (pcf->dwMask & CFM_UNDERLINE)
		pfnt->SetUnderline((pcf->dwEffects & CFE_UNDERLINE) ? tomSingle : tomNone);
 
	if (pcf->dwMask & CFM_SIZE)
		pfnt->SetSize(((float)pcf->yHeight) / 20.0f);	// Convert from TWIPs to points

	if (pcf->dwMask & CFM_COLOR)
		pfnt->SetForeColor(pcf->dwEffects & CFE_AUTOCOLOR ? tomAutoColor : pcf->crTextColor);

	if (pcf->dwMask & CFM_FACE)
	{
		BSTR strName = T2BSTR(pcf->szFaceName);
		pfnt->SetName(strName);
		SysFreeString(strName);
	}
}

//BUBUG - this is old Johnse code...I think to get around a problem that you get a crt av when 
//	superclassing richedit for use with CContainedWindow
//

////////////////////////////////////////////////////////////////////////////
// Special override for containing a RichEdit control
////////////////////////////////////////////////////////////////////////////
HWND CREWindow::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName, DWORD dwStyle,
					   DWORD dwExStyle, UINT nID)
{
	CContainedWindow* pBase = this;

	ASSERT(m_hWnd == NULL);

	ATOM atom = RegisterWndSuperclass();
	if (atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, pBase);

	if (nID == 0 && (dwStyle & WS_CHILD))
		nID = (UINT) pBase;

	HWND hWnd = ::CreateWindowEx(dwExStyle, m_lpszClassName, szWindowName,
						dwStyle,
						rcPos.left, rcPos.top,
						rcPos.right - rcPos.left,
						rcPos.bottom - rcPos.top,
						hWndParent, (HMENU)nID,
						_Module.GetModuleInstance(), (void*) pBase);
	SubclassWindow(hWnd);

	ASSERT(m_hWnd == hWnd);
	return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\chat\chatctl.h ===
// ChatCtl.h : Declaration of the CChatCtl

#ifndef __CHATCTL_H_
#define __CHATCTL_H_

//#include "dibpal.h"
#include <ZoneDef.h>
#include <queue.h>

#include "zgdi.h"
#include "rollover.h"
#include "zoneevent.h"
#include "accessibilitymanager.h"
#include "inputmanager.h"

#include "tom.h"			// Text Object Model

#define COPPA

class CREWindow : public CContainedWindow
{
public:
	CREWindow(LPTSTR pszClassName, CMessageMap* pObject, DWORD dwMsgMapID) :
		CContainedWindow(pszClassName, pObject, dwMsgMapID)
		{}

	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0, UINT nID = 0);
};

/////////////////////////////////////////////////////////////////////////////
// CChatCtl
class ATL_NO_VTABLE CChatCtl :
    public IAccessibleControl,
    public IInputCharHandler,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComControl<CChatCtl>,
	public IPersistStreamInitImpl<CChatCtl>,
	public IOleControlImpl<CChatCtl>,
	public IOleObjectImpl<CChatCtl>,
	public IOleInPlaceActiveObjectImpl<CChatCtl>,
	public IViewObjectExImpl<CChatCtl>,
	public IOleInPlaceObjectWindowlessImpl<CChatCtl>,
	public CComCoClass<CChatCtl, &CLSID_ChatCtl>,
	public IZoneShellClientImpl<CChatCtl>,
	public IEventClientImpl<CChatCtl>
{
protected:
	CREWindow						m_ChatDisplay;	
	CREWindow						m_ChatEdit;
	CRolloverButton					m_SendButton;						
	CContainedWindowT<CButton>		m_RadioButtonOn;
	CContainedWindowT<CButton>		m_RadioButtonOff;
	CContainedWindowT<CListBox>		m_PlayerList;
	CContainedWindowT<CComboBox>	m_QuasiChat;	// remember if you change this to comboboxex that by default comboboxex is ownerdraw	
	
	CMenu	m_ContextMenuParent;
	CMenu	m_ContextMenu;
	CMenu	m_EditContextMenuParent;
	CMenu	m_EditContextMenu;

	CRect	m_DisplayRect;
	CRect	m_EditRect;
    CRect	m_rcPanel;		//current size of the panel.
    CPoint  m_ptPlayer;
    CRect	m_rcChatWord;
    CPoint	m_ptChatWord;
    CPoint	m_ptOnOff;
	
	long	m_EditHeight;
	long	m_EditMargin;
    long    m_QuasiItemsDisp;
    long	m_nPanelWidth;
	long	m_RadioButtonHeight;
    long    m_nChatMinHeight;

	HMODULE m_hRichEdit;
	bool	m_Batch;		// whether a batch update is in progress or not - use to defer ui updates and control ui flicker

	// Text object model stuff

	// Tom interfaces for chat history
	ITextDocument*		m_pTDocHistory;			// Main document interface for History control
	ITextRange*			m_ptrgInsert;			// Insertion point
	ITextRange*			m_ptrgWhole;	    	// should be whole doc - right now end is not extended as text is added
	ITextFont*			m_pfntName;				// Font to use for Name
	ITextFont*			m_pfntText;				// Font to use for text
	// TOM interfaces for chat entry
	ITextDocument*		m_EntryDoc;			// Main document interface for chat entry
	ITextRange*			m_EntryRange;		// chat entry range

	BSTR				m_strNewLine;
	BOOL				m_bHasTypedInEntry;		// FALSE for special case of Type Here to chat...
	COLORREF			m_crTextColor;			// Color of text
	CHARFORMAT			m_cfCurFont;			// Character format for RichEdit controls
	BOOL				m_bTextBold;			// Flags whether chat text is bold.
	BOOL				m_bFirstChatLine;		// Flag to see whether a \n is needed before next chat
    HPEN                m_hPanelPen;
	COLORREF			m_SystemMessageColor;	// Color to display system messages in
	COLORREF			m_OrgSystemMessageColor;	// Color to display system messages in
	bool				m_bGameTerminated;		// current game status

	// Strings loaded from resource
    TCHAR m_tszChatWord[ZONE_MAXSTRING];		// the word "Chat" displayed above radio buttons
    TCHAR m_tszOnWord[ZONE_MAXSTRING];			// Radio button on
    TCHAR m_tszOffWord[ZONE_MAXSTRING];			// Radio button off
    TCHAR m_tszPlayerOffWord[ZONE_MAXSTRING];	// (on) - appendended to player name if their chat is on
    TCHAR m_tszPlayerOnWord[ZONE_MAXSTRING];	// (off)
    TCHAR m_tszPlayerBotWord[ZONE_MAXSTRING];	// if player is a bot
    TCHAR m_tszChatSeperator[ZONE_MAXSTRING];	// seperator between player name and their chat in the chat display window
    TCHAR m_tszChatSend[ZONE_MAXSTRING];		// string for chat send button

	CZoneFont m_font;							// font used for the richedit controls
    CZoneFont m_fontPanelChat;					// font used for displaying word "Chat" in chat panel	
    CZoneFont m_fontPanelPlayer;				// font used to display players in player list
    CZoneFont m_fontQuasi;					    // font used for combo box

	bool	m_bPreferencesLoaded;
	// Beta2 Bug 15180
	bool	m_bChatOnAtStartUp;						// Flag to check whether chat was set to be on at startup
	bool	m_bDisplayedTypeHereMessage;			// Whether user has been shown the type here message or not

	// quasichat
	long m_ChatMessageNdxBegin;					// ndx to start at when loading game specific messages from resource file
	long m_ChatMessageNdxEnd;					// end ndx
	void LoadChatStrings();						// Load quasichat strings from resource and insert into combobox
	int GetQuasiChatMessageIndex(TCHAR* str);	// parses chat string for /# and returns the # converted to int

public:
	CChatCtl();
	~CChatCtl();
	
	void WritePreferences();
	void HandleChatMessage(TCHAR *pszName, TCHAR *pszMessage, DWORD cbDataLen, bool displayAllBold = false, COLORREF color = RGB(0, 0, 0));
	void CalcDisplayRects();  // Based on clientRC, calculate rects of chat windows
	void SendChat();
	void LoadPreferences();

	void ScrollToEnd();
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	void EnableChat(BOOL enable, BOOL fNotify = true);	// enable/disable chat, option param whether to send event notification
	void VerifySystemMsgColor(COLORREF& color);

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_WND_CLASS(_T("ChatControl"))

BEGIN_PROP_MAP(CChatCtl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_COM_MAP(CChatCtl)
	COM_INTERFACE_ENTRY(IEventClient)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IZoneShellClient)
END_COM_MAP()

BEGIN_MSG_MAP(CChatCtl)
	MESSAGE_HANDLER(WM_ENTERIDLE, OnIdle)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnErase)
    MESSAGE_HANDLER(WM_PRINTCLIENT, OnPrintClient)
	MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_CTLCOLORLISTBOX, OnCtlColorListBox)
	MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColorStatic)
//	MESSAGE_HANDLER(WM_CTLCOLORLISTBOX, OnCtlColorComboBox)
	MESSAGE_HANDLER(WM_CTLCOLORBTN, OnCtlColorButton)
	MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
	MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
	MESSAGE_HANDLER(WM_COMPAREITEM, OnCompareItem)
	MESSAGE_HANDLER(WM_INPUTLANGCHANGEREQUEST , OnLanguageChange)
//	MESSAGE_HANDLER(WM_EXITSIZEMOVE, OnExitSizeMove)
	//MESSAGE_HANDLER(WM_ENTERSIZEMOVE, OnEnterSizeMove)
	COMMAND_ID_HANDLER(IDM_CHAT_CLEAR, OnClear)
	COMMAND_ID_HANDLER(IDM_SELECTALL, OnSelectAll)
	COMMAND_ID_HANDLER(IDM_COPY, OnClipboardCommand)
	COMMAND_ID_HANDLER(IDM_CUT, OnClipboardCommand)
	COMMAND_ID_HANDLER(IDM_PASTE, OnClipboardCommand)
	COMMAND_ID_HANDLER(IDM_PASTE, OnClipboardCommand)
	COMMAND_ID_HANDLER(IDM_DELETE, OnClipboardCommand)
	COMMAND_ID_HANDLER(IDM_CHAT_CHOOSE_FONT, OnChooseFont)
	COMMAND_ID_HANDLER(ID_CHAT_SEND, OnChatSend)
	COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
    COMMAND_CODE_HANDLER(CBN_DROPDOWN, OnQuasiChat)
	COMMAND_CODE_HANDLER(CBN_CLOSEUP, OnQuasiChat)
	COMMAND_CODE_HANDLER(CBN_SELENDOK, OnQuasiChat)
	COMMAND_CODE_HANDLER(CBN_SELENDCANCEL, OnQuasiChat)
ALT_MSG_MAP(1)		// message map for Chat Display Window
	MESSAGE_HANDLER(WM_CONTEXTMENU,OnContext)
	MESSAGE_HANDLER(WM_CHAR, Ignore)
	MESSAGE_HANDLER(WM_IME_CHAR, Ignore)
	MESSAGE_HANDLER(WM_IME_COMPOSITION, Ignore)
	MESSAGE_HANDLER(WM_CUT, Ignore)
	MESSAGE_HANDLER(WM_PASTE, Ignore)
	MESSAGE_HANDLER(WM_KEYDOWN, IgnoreKeyDown)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocusDisplay)
    MESSAGE_HANDLER(WM_ENABLE, OnEnableDisplay)
	COMMAND_ID_HANDLER(IDM_SELECTALL, OnSelectAll)
ALT_MSG_MAP(2)		// Message map for Chat Edit Window
	MESSAGE_HANDLER(WM_CONTEXTMENU,OnEditContext)
	MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDownChatEntry)
    MESSAGE_HANDLER(WM_CHAR, OnCharChatEntry)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDownChatEntry)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocusEdit)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocusEdit)
    MESSAGE_HANDLER(WM_ENABLE, OnEnableEdit)
ALT_MSG_MAP(3)		// Message map for RadioButtonOn
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocusOn)
ALT_MSG_MAP(4)		// Message map for RadioButtonOff
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocusOff)
ALT_MSG_MAP(5)		// Message map for PlayerList
    MESSAGE_HANDLER(WM_LBUTTONDOWN, Ignore)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, Ignore)
	//CHAIN_MSG_MAP(CComControl<CChatCtl>)
	//DEFAULT_REFLECTION_HANDLER()
#ifdef COPPA
ALT_MSG_MAP(6)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocusEdit)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocusEdit)
	MESSAGE_HANDLER(WM_CTLCOLORLISTBOX, OnCtlColorComboBox)
    MESSAGE_HANDLER(WM_CHAR, OnCharComboBox)
    MESSAGE_HANDLER(WM_ENABLE, OnEnableCombo)
#endif
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// IViewObjectEx
	//DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

BEGIN_EVENT_MAP()
	EVENT_HANDLER_WITH_BUFFER(EVENT_CHAT_RECV_USERID, OnChatEvent)
	EVENT_HANDLER_WITH_BUFFER(EVENT_CHAT_RECV_SYSTEM, OnChatSystemEvent)
	EVENT_HANDLER(EVENT_LOBBY_BATCH_BEGIN, OnBatchBegin)
	EVENT_HANDLER(EVENT_LOBBY_BATCH_END, OnBatchEnd)
	EVENT_HANDLER( EVENT_LOBBY_SUSPEND, OnZoneSuspend)
	EVENT_HANDLER( EVENT_CHAT_ENTER_EXIT, OnReloadPreferences)
	EVENT_HANDLER( EVENT_CHAT_FILTER, OnReloadPreferences)
	EVENT_HANDLER( EVENT_CHAT_FONT, OnReloadPreferences)
	EVENT_HANDLER( EVENT_LOBBY_SUSPEND, OnZoneSuspend)
	EVENT_HANDLER( EVENT_GAME_LAUNCHING, OnGameLaunching)
	EVENT_HANDLER( EVENT_GAME_TERMINATED, OnGameTerminated)
	EVENT_HANDLER( EVENT_LOBBY_USER_UPDATE, OnUserUpdate)
	EVENT_HANDLER( EVENT_LOBBY_CLEAR_ALL, OnLobbyClear)
	EVENT_HANDLER( EVENT_LOBBY_USER_NEW, OnUserAdd)
	EVENT_HANDLER( EVENT_LOBBY_USER_DEL, OnUserRemove)
END_EVENT_MAP()
// IChatCtl
public:
	static DWORD GetWndStyle(DWORD dwStyle){ return WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS;}

    HRESULT OnDraw(ATL_DRAWINFO &di);

	LRESULT OnIdle(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
        HWND hWnd = ZoneShell()->GetFrameWindow();
		::PostMessage(hWnd, WM_ENTERIDLE, 0, 0);
		return 0;

	}

	LRESULT OnSize(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetFocus(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnContext(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnEditContext(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
//	LRESULT OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnErase(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCtlColorListBox(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCtlColorStatic(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnSysColorChange(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCtlColorComboBox(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCtlColorButton(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);

	// IZoneShellClientImpl
	STDMETHOD(Close)();

	LRESULT OnPrintClient(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    BOOL SuperScreenToClient(LPRECT lpRect);

	// Message Handlers for Chat display window
	LRESULT OnClear(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnChatSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT IgnoreKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroyHistory(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChooseFont(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSelectAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClipboardCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled) 
	{
		// Handle messages from radiobuttons
		if(wID==3) 
			EnableChat(TRUE); 
		else if (wID==4)
			EnableChat(FALSE);
		return 0; 
	}
	LRESULT OnQuasiChat(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled); 

	// Message Handlers for Chat Edit window
	LRESULT OnButtonDownChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnKeyDownChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCharChatEntry(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCharComboBox(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroyEntry(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT Ignore(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	// Message Handlers for playerlist
	LRESULT OnDrawItem(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnMeasureItem(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCompareItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // accessibility-related
    LRESULT OnSetFocusDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKillFocusEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocusEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocusOn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocusOff(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnEnableDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEnableEdit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#ifdef COPPA
    LRESULT OnEnableCombo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
#endif

	// Language
	LRESULT OnLanguageChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
/*
	LRESULT OnEnterSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RECT buttonRect;
		GetClientRect(&buttonRect);
		m_SendButton.SetWindowPos(NULL,buttonRect.right,buttonRect.bottom+1,0,0,SWP_NOSIZE|SWP_NOZORDER );
		bHandled = true;
		return 0; 
	}

	LRESULT OnExitSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RECT buttonRect;
		buttonRect.top = m_EditRect.top;
		buttonRect.bottom = m_EditRect.bottom;
		buttonRect.left = m_EditRect.right;
		buttonRect.right = m_DisplayRect.right;
		InvalidateRect(&m_rcPanel);
		InvalidateRect(&buttonRect);

//		int sendHeight = m_SendButton.GetHeight();
//		int editHeight = m_EditRect.bottom - m_EditRect.top;
//		int diff = editHeight - sendHeight;
//		int y=m_EditRect.top + 1;
//		if(diff>0)
//			y+=diff/2;
//		m_SendButton.SetWindowPos(NULL,m_EditRect.right,y,0,0,SWP_NOSIZE|SWP_NOZORDER );
//		InvalidateRect(&buttonRect);

		bHandled = true;
		return 0; 
	}
*/

	// Zone Event Handlers
	void OnGameLaunching(DWORD eventId,DWORD groupId,DWORD userId);
	void OnGameTerminated(DWORD eventId,DWORD groupId,DWORD userId);
	void OnReloadPreferences(DWORD eventId,DWORD groupId,DWORD userId);
	void OnZoneSuspend(DWORD eventId,DWORD groupId,DWORD userId);
	void OnChatEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen);
	void OnChatSystemEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen);
	void OnBatchBegin(DWORD eventId,DWORD groupId,DWORD userId){ m_Batch = true; }
	void OnBatchEnd(DWORD eventId,DWORD groupId,DWORD userId){ m_Batch = false; }
	void OnUserUpdate(DWORD eventId,DWORD groupId,DWORD userId);
	void OnLobbyClear(DWORD eventId,DWORD groupId,DWORD userId);
	void OnUserAdd(DWORD eventId,DWORD groupId,DWORD userId);
	void OnUserRemove(DWORD eventId,DWORD groupId,DWORD userId);


// IInputCharHandler
public:
    STDMETHOD_(bool, HandleChar)(HWND *phWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD time);

protected:
    DWORD m_dwFocusID;
    bool m_fFocusKept;

#ifdef COPPA
    bool m_fComboEndOk;
    bool m_fComboDown;
#endif

// IAccessibleControl
public:
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie) { return Activate(nIndex, rgfContext, pvCookie); }
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie) { return 0; }

protected:
    CComPtr<IAccessibility> m_pIAcc;
};

#endif //__CHATCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\chat\tom.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: tom */

#ifndef _tom_H_
#define _tom_H_

DEFINE_GUID(LIBID_tom,0x8CC497C9L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

interface ITextSelection;

interface ITextRange;

interface ITextFont;

interface ITextPara;

interface ITextStoryRanges;

typedef enum {
    tomFalse = 0,
    tomTrue = -1,
    tomUndefined = -9999999,
    tomToggle = -9999998,
    tomAutoColor = -9999997,
    tomDefault = -9999996,
    tomBackward = -1073741823,
    tomForward = 1073741823,
    tomMove = 0,
    tomExtend = 1,
    tomNoSelection = 0,
    tomSelectionIP = 1,
    tomSelectionNormal = 2,
    tomSelectionFrame = 3,
    tomSelectionColumn = 4,
    tomSelectionRow = 5,
    tomSelectionBlock = 6,
    tomSelectionInlineShape = 7,
    tomSelectionShape = 8,
    tomSelStartActive = 1,
    tomSelAtEOL = 2,
    tomSelOvertype = 4,
    tomSelActive = 8,
    tomSelReplace = 16,
    tomEnd = 0,
    tomStart = 32,
    tomCollapseEnd = 0,
    tomCollapseStart = 1,
    tomNone = 0,
    tomSingle = 1,
    tomWords = 2,
    tomDouble = 3,
    tomDotted = 4,
    tomLineSpaceSingle = 0,
    tomLineSpace1pt5 = 1,
    tomLineSpaceDouble = 2,
    tomLineSpaceAtLeast = 3,
    tomLineSpaceExactly = 4,
    tomLineSpaceMultiple = 5,
    tomAlignLeft = 0,
    tomAlignCenter = 1,
    tomAlignRight = 2,
    tomAlignJustify = 3,
    tomAlignDecimal = 3,
    tomAlignBar = 4,
    tomSpaces = 0,
    tomDots = 1,
    tomDashes = 2,
    tomLines = 3,
    tomTabBack = -3,
    tomTabNext = -2,
    tomTabHere = -1,
    tomListNone = 0,
    tomListBullet = 1,
    tomListNumberAsArabic = 2,
    tomListNumberAsLCLetter = 3,
    tomListNumberAsUCLetter = 4,
    tomListNumberAsLCRoman = 5,
    tomListNumberAsUCRoman = 6,
    tomListNumberAsSequence = 7,
    tomListParentheses = 65536,
    tomListPeriod = 131072,
    tomListPlain = 196608,
    tomCharacter = 1,
    tomWord = 2,
    tomSentence = 3,
    tomParagraph = 4,
    tomLine = 5,
    tomStory = 6,
    tomScreen = 7,
    tomSection = 8,
    tomColumn = 9,
    tomRow = 10,
    tomWindow = 11,
    tomCell = 12,
    tomCharFormat = 13,
    tomParaFormat = 14,
    tomTable = 15,
    tomObject = 16,
    tomMatchWord = 2,
    tomMatchCase = 4,
    tomMatchPattern = 8,
    tomUnknownStory = 0,
    tomMainTextStory = 1,
    tomFootnotesStory = 2,
    tomEndnotesStory = 3,
    tomCommentsStory = 4,
    tomTextFrameStory = 5,
    tomEvenPagesHeaderStory = 6,
    tomPrimaryHeaderStory = 7,
    tomEvenPagesFooterStory = 8,
    tomPrimaryFooterStory = 9,
    tomFirstPageHeaderStory = 10,
    tomFirstPageFooterStory = 11,
    tomNoAnimation = 0,
    tomLasVegasLights = 1,
    tomBlinkingBackground = 2,
    tomSparkleText = 3,
    tomMarchingBlackAnts = 4,
    tomMarchingRedAnts = 5,
    tomShimmer = 6,
    tomWipeDown = 7,
    tomWipeRight = 8,
    tomAnimationMax = 8,
    tomLowerCase = 0,
    tomUpperCase = 1,
    tomTitleCase = 2,
    tomSentenceCase = 4,
    tomToggleCase = 5,
    tomReadOnly = 256,
    tomShareDenyRead = 512,
    tomShareDenyWrite = 1024,
    tomPasteFile = 4096,
    tomCreateNew = 16,
    tomCreateAlways = 32,
    tomOpenExisting = 48,
    tomOpenAlways = 64,
    tomTruncateExisting = 80,
    tomRTF = 1,
    tomText = 2,
    tomHTML = 3,
    tomWordDocument = 4
} tomConstants;

DEFINE_GUID(IID_ITextDocument,0x8CC497C0L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextDocument */
#undef INTERFACE
#define INTERFACE ITextDocument

DECLARE_INTERFACE_(ITextDocument, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextDocument methods */
    STDMETHOD(GetName)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(GetSelection)(THIS_ ITextSelection FAR* FAR* ppSel) PURE;
    STDMETHOD(GetStoryCount)(THIS_ long FAR* pCount) PURE;
    STDMETHOD(GetStoryRanges)(THIS_ ITextStoryRanges FAR* FAR* ppStories) PURE;
    STDMETHOD(GetSaved)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetSaved)(THIS_ long Value) PURE;
    STDMETHOD(GetDefaultTabStop)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetDefaultTabStop)(THIS_ float Value) PURE;
    STDMETHOD(New)(THIS) PURE;
    STDMETHOD(Open)(THIS_ VARIANT FAR* pVar, long Flags, long CodePage) PURE;
    STDMETHOD(Save)(THIS_ VARIANT FAR* pVar, long Flags, long CodePage) PURE;
    STDMETHOD(Freeze)(THIS_ long FAR* pCount) PURE;
    STDMETHOD(Unfreeze)(THIS_ long FAR* pCount) PURE;
    STDMETHOD(BeginEditCollection)(THIS) PURE;
    STDMETHOD(EndEditCollection)(THIS) PURE;
    STDMETHOD(Undo)(THIS_ long Count, long FAR* prop) PURE;
    STDMETHOD(Redo)(THIS_ long Count, long FAR* prop) PURE;
    STDMETHOD(Range)(THIS_ long cp1, long cp2, ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(RangeFromPoint)(THIS_ long x, long y, ITextRange FAR* FAR* ppRange) PURE;
};

DEFINE_GUID(IID_ITextRange,0x8CC497C2L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextRange */
#undef INTERFACE
#define INTERFACE ITextRange

DECLARE_INTERFACE_(ITextRange, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextRange methods */
    STDMETHOD(GetText)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(SetText)(THIS_ BSTR bstr) PURE;
    STDMETHOD(GetChar)(THIS_ long FAR* pch) PURE;
    STDMETHOD(SetChar)(THIS_ long ch) PURE;
    STDMETHOD(GetDuplicate)(THIS_ ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(GetFormattedText)(THIS_ ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(SetFormattedText)(THIS_ ITextRange FAR* pRange) PURE;
    STDMETHOD(GetStart)(THIS_ long FAR* pcpFirst) PURE;
    STDMETHOD(SetStart)(THIS_ long cpFirst) PURE;
    STDMETHOD(GetEnd)(THIS_ long FAR* pcpLim) PURE;
    STDMETHOD(SetEnd)(THIS_ long cpLim) PURE;
    STDMETHOD(GetFont)(THIS_ ITextFont FAR* FAR* pFont) PURE;
    STDMETHOD(SetFont)(THIS_ ITextFont FAR* pFont) PURE;
    STDMETHOD(GetPara)(THIS_ ITextPara FAR* FAR* pPara) PURE;
    STDMETHOD(SetPara)(THIS_ ITextPara FAR* pPara) PURE;
    STDMETHOD(GetStoryLength)(THIS_ long FAR* pcch) PURE;
    STDMETHOD(GetStoryType)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(Collapse)(THIS_ long bStart) PURE;
    STDMETHOD(Expand)(THIS_ long Unit, long FAR* pDelta) PURE;
    STDMETHOD(GetIndex)(THIS_ long Unit, long FAR* pIndex) PURE;
    STDMETHOD(SetIndex)(THIS_ long Unit, long Index, long Extend) PURE;
    STDMETHOD(SetRange)(THIS_ long cpActive, long cpOther) PURE;
    STDMETHOD(InRange)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(InStory)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(IsEqual)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(Select)(THIS) PURE;
    STDMETHOD(StartOf)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(EndOf)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(Move)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStart)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEnd)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStartWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEndWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStartUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEndUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(FindText)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(FindTextStart)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(FindTextEnd)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(Delete)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(Cut)(THIS_ VARIANT FAR* pVar) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT FAR* pVar) PURE;
    STDMETHOD(Paste)(THIS_ VARIANT FAR* pVar, long Format) PURE;
    STDMETHOD(CanPaste)(THIS_ VARIANT FAR* pVar, long Format, long FAR* pb) PURE;
    STDMETHOD(CanEdit)(THIS_ long FAR* pbCanEdit) PURE;
    STDMETHOD(ChangeCase)(THIS_ long Type) PURE;
    STDMETHOD(GetPoint)(THIS_ long Type, long FAR* px, long FAR* py) PURE;
    STDMETHOD(SetPoint)(THIS_ long x, long y, long Type, long Extend) PURE;
    STDMETHOD(ScrollIntoView)(THIS_ long Value) PURE;
    STDMETHOD(GetEmbeddedObject)(THIS_ IUnknown * FAR* ppv) PURE;
};

DEFINE_GUID(IID_ITextSelection,0x8CC497C1L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextSelection */
#undef INTERFACE
#define INTERFACE ITextSelection

DECLARE_INTERFACE_(ITextSelection, ITextRange)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* ITextRange methods */
    STDMETHOD(GetText)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(SetText)(THIS_ BSTR bstr) PURE;
    STDMETHOD(GetChar)(THIS_ long FAR* pch) PURE;
    STDMETHOD(SetChar)(THIS_ long ch) PURE;
    STDMETHOD(GetDuplicate)(THIS_ ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(GetFormattedText)(THIS_ ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(SetFormattedText)(THIS_ ITextRange FAR* pRange) PURE;
    STDMETHOD(GetStart)(THIS_ long FAR* pcpFirst) PURE;
    STDMETHOD(SetStart)(THIS_ long cpFirst) PURE;
    STDMETHOD(GetEnd)(THIS_ long FAR* pcpLim) PURE;
    STDMETHOD(SetEnd)(THIS_ long cpLim) PURE;
    STDMETHOD(GetFont)(THIS_ ITextFont FAR* FAR* pFont) PURE;
    STDMETHOD(SetFont)(THIS_ ITextFont FAR* pFont) PURE;
    STDMETHOD(GetPara)(THIS_ ITextPara FAR* FAR* pPara) PURE;
    STDMETHOD(SetPara)(THIS_ ITextPara FAR* pPara) PURE;
    STDMETHOD(GetStoryLength)(THIS_ long FAR* pcch) PURE;
    STDMETHOD(GetStoryType)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(Collapse)(THIS_ long bStart) PURE;
    STDMETHOD(Expand)(THIS_ long Unit, long FAR* pDelta) PURE;
    STDMETHOD(GetIndex)(THIS_ long Unit, long FAR* pIndex) PURE;
    STDMETHOD(SetIndex)(THIS_ long Unit, long Index, long Extend) PURE;
    STDMETHOD(SetRange)(THIS_ long cpActive, long cpOther) PURE;
    STDMETHOD(InRange)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(InStory)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(IsEqual)(THIS_ ITextRange FAR* pRange, long FAR* pb) PURE;
    STDMETHOD(Select)(THIS) PURE;
    STDMETHOD(StartOf)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(EndOf)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(Move)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStart)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEnd)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStartWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEndWhile)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveStartUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(MoveEndUntil)(THIS_ VARIANT FAR* Cset, long Count, long FAR* pDelta) PURE;
    STDMETHOD(FindText)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(FindTextStart)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(FindTextEnd)(THIS_ BSTR bstr, long cch, long Flags, long FAR* pLength) PURE;
    STDMETHOD(Delete)(THIS_ long Unit, long Count, long FAR* pDelta) PURE;
    STDMETHOD(Cut)(THIS_ VARIANT FAR* pVar) PURE;
    STDMETHOD(Copy)(THIS_ VARIANT FAR* pVar) PURE;
    STDMETHOD(Paste)(THIS_ VARIANT FAR* pVar, long Format) PURE;
    STDMETHOD(CanPaste)(THIS_ VARIANT FAR* pVar, long Format, long FAR* pb) PURE;
    STDMETHOD(CanEdit)(THIS_ long FAR* pbCanEdit) PURE;
    STDMETHOD(ChangeCase)(THIS_ long Type) PURE;
    STDMETHOD(GetPoint)(THIS_ long Type, long FAR* px, long FAR* py) PURE;
    STDMETHOD(SetPoint)(THIS_ long x, long y, long Type, long Extend) PURE;
    STDMETHOD(ScrollIntoView)(THIS_ long Value) PURE;
    STDMETHOD(GetEmbeddedObject)(THIS_ IUnknown * FAR* ppv) PURE;
#endif

    /* ITextSelection methods */
    STDMETHOD(GetFlags)(THIS_ long FAR* pFlags) PURE;
    STDMETHOD(SetFlags)(THIS_ long Flags) PURE;
    STDMETHOD(GetType)(THIS_ long FAR* pType) PURE;
    STDMETHOD(MoveLeft)(THIS_ long Unit, long Count, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(MoveRight)(THIS_ long Unit, long Count, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(MoveUp)(THIS_ long Unit, long Count, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(MoveDown)(THIS_ long Unit, long Count, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(HomeKey)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(EndKey)(THIS_ long Unit, long Extend, long FAR* pDelta) PURE;
    STDMETHOD(TypeText)(THIS_ BSTR bstr) PURE;
};

DEFINE_GUID(IID_ITextFont,0x8CC497C3L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextFont */
#undef INTERFACE
#define INTERFACE ITextFont

DECLARE_INTERFACE_(ITextFont, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextFont methods */
    STDMETHOD(GetDuplicate)(THIS_ ITextFont FAR* FAR* ppFont) PURE;
    STDMETHOD(SetDuplicate)(THIS_ ITextFont FAR* pFont) PURE;
    STDMETHOD(CanChange)(THIS_ long FAR* pB) PURE;
    STDMETHOD(IsEqual)(THIS_ ITextFont FAR* pFont, long FAR* pB) PURE;
    STDMETHOD(Reset)(THIS_ long Value) PURE;
    STDMETHOD(GetStyle)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetStyle)(THIS_ long Value) PURE;
    STDMETHOD(GetAllCaps)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetAllCaps)(THIS_ long Value) PURE;
    STDMETHOD(GetAnimation)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetAnimation)(THIS_ long Value) PURE;
    STDMETHOD(GetBackColor)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetBackColor)(THIS_ long Value) PURE;
    STDMETHOD(GetBold)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetBold)(THIS_ long Value) PURE;
    STDMETHOD(GetEmboss)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetEmboss)(THIS_ long Value) PURE;
    STDMETHOD(GetForeColor)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetForeColor)(THIS_ long Value) PURE;
    STDMETHOD(GetHidden)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetHidden)(THIS_ long Value) PURE;
    STDMETHOD(GetEngrave)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetEngrave)(THIS_ long Value) PURE;
    STDMETHOD(GetItalic)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetItalic)(THIS_ long Value) PURE;
    STDMETHOD(GetKerning)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetKerning)(THIS_ float Value) PURE;
    STDMETHOD(GetLanguageID)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetLanguageID)(THIS_ long Value) PURE;
    STDMETHOD(GetName)(THIS_ BSTR FAR* pbstr) PURE;
    STDMETHOD(SetName)(THIS_ BSTR bstr) PURE;
    STDMETHOD(GetOutline)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetOutline)(THIS_ long Value) PURE;
    STDMETHOD(GetPosition)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetPosition)(THIS_ float Value) PURE;
    STDMETHOD(GetProtected)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetProtected)(THIS_ long Value) PURE;
    STDMETHOD(GetShadow)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetShadow)(THIS_ long Value) PURE;
    STDMETHOD(GetSize)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetSize)(THIS_ float Value) PURE;
    STDMETHOD(GetSmallCaps)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetSmallCaps)(THIS_ long Value) PURE;
    STDMETHOD(GetSpacing)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetSpacing)(THIS_ float Value) PURE;
    STDMETHOD(GetStrikeThrough)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetStrikeThrough)(THIS_ long Value) PURE;
    STDMETHOD(GetSubscript)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetSubscript)(THIS_ long Value) PURE;
    STDMETHOD(GetSuperscript)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetSuperscript)(THIS_ long Value) PURE;
    STDMETHOD(GetUnderline)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetUnderline)(THIS_ long Value) PURE;
    STDMETHOD(GetWeight)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetWeight)(THIS_ long Value) PURE;
};

DEFINE_GUID(IID_ITextPara,0x8CC497C4L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextPara */
#undef INTERFACE
#define INTERFACE ITextPara

DECLARE_INTERFACE_(ITextPara, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextPara methods */
    STDMETHOD(GetDuplicate)(THIS_ ITextPara FAR* FAR* ppPara) PURE;
    STDMETHOD(SetDuplicate)(THIS_ ITextPara FAR* pPara) PURE;
    STDMETHOD(CanChange)(THIS_ long FAR* pB) PURE;
    STDMETHOD(IsEqual)(THIS_ ITextPara FAR* pPara, long FAR* pB) PURE;
    STDMETHOD(Reset)(THIS_ long Value) PURE;
    STDMETHOD(GetStyle)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetStyle)(THIS_ long Value) PURE;
    STDMETHOD(GetAlignment)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetAlignment)(THIS_ long Value) PURE;
    STDMETHOD(GetHyphenation)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetHyphenation)(THIS_ long Value) PURE;
    STDMETHOD(GetFirstLineIndent)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(GetKeepTogether)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetKeepTogether)(THIS_ long Value) PURE;
    STDMETHOD(GetKeepWithNext)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetKeepWithNext)(THIS_ long Value) PURE;
    STDMETHOD(GetLeftIndent)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(GetLineSpacing)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(GetLineSpacingRule)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(GetListAlignment)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetListAlignment)(THIS_ long Value) PURE;
    STDMETHOD(GetListLevelIndex)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetListLevelIndex)(THIS_ long Value) PURE;
    STDMETHOD(GetListStart)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetListStart)(THIS_ long Value) PURE;
    STDMETHOD(GetListTab)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetListTab)(THIS_ float Value) PURE;
    STDMETHOD(GetListType)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetListType)(THIS_ long Value) PURE;
    STDMETHOD(GetNoLineNumber)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetNoLineNumber)(THIS_ long Value) PURE;
    STDMETHOD(GetPageBreakBefore)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetPageBreakBefore)(THIS_ long Value) PURE;
    STDMETHOD(GetRightIndent)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetRightIndent)(THIS_ float Value) PURE;
    STDMETHOD(SetIndents)(THIS_ float StartIndent, float LeftIndent, float RightIndent) PURE;
    STDMETHOD(SetLineSpacing)(THIS_ long LineSpacingRule, float LineSpacing) PURE;
    STDMETHOD(GetSpaceAfter)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetSpaceAfter)(THIS_ float Value) PURE;
    STDMETHOD(GetSpaceBefore)(THIS_ float FAR* pValue) PURE;
    STDMETHOD(SetSpaceBefore)(THIS_ float Value) PURE;
    STDMETHOD(GetWidowControl)(THIS_ long FAR* pValue) PURE;
    STDMETHOD(SetWidowControl)(THIS_ long Value) PURE;
    STDMETHOD(GetTabCount)(THIS_ long FAR* pCount) PURE;
    STDMETHOD(AddTab)(THIS_ float tbPos, long tbAlign, long tbLeader) PURE;
    STDMETHOD(ClearAllTabs)(THIS) PURE;
    STDMETHOD(DeleteTab)(THIS_ float tbPos) PURE;
    STDMETHOD(GetTab)(THIS_ long iTab, float FAR* ptbPos, long FAR* ptbAlign, long FAR* ptbLeader) PURE;
};

DEFINE_GUID(IID_ITextStoryRanges,0x8CC497C5L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);

/* Definition of interface: ITextStoryRanges */
#undef INTERFACE
#define INTERFACE ITextStoryRanges

DECLARE_INTERFACE_(ITextStoryRanges, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextStoryRanges methods */
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppunkEnum) PURE;
    STDMETHOD(Item)(THIS_ long Index, ITextRange FAR* FAR* ppRange) PURE;
    STDMETHOD(GetCount)(THIS_ long FAR* pCount) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\datastore\cdatastore.cpp ===
#include "BasicATL.h"
#include "ZoneError.h"
#include "ZoneDef.h"
#include "ZoneLocks.h"
#include "ZoneMem.h"
#include "ZoneString.h"
#include "Hash.h"

#include "CDataStore.h"

static void DeleteVariantData(LPVARIANT pVariant);


///////////////////////////////////////////////////////////////////////////////
// CDataStoreManager
///////////////////////////////////////////////////////////////////////////////

CDataStoreManager::CDataStoreManager()
{
	m_pStringTable = NULL;
    m_piResourceManager = NULL;
}


CDataStoreManager::~CDataStoreManager()
{
	if ( m_pStringTable )
	{
		delete m_pStringTable;
		m_pStringTable = NULL;
	}

    if(m_piResourceManager)
        m_piResourceManager->Release();
}


STDMETHODIMP CDataStoreManager::Create(IDataStore **ppZds)
{
	CDataStore *pZds;

	// allocate new data store interface
	pZds = new (m_ZdsPool) CDataStore();
	if ( !pZds )
		return E_OUTOFMEMORY;
	pZds->AddRef();

	HRESULT hr = pZds->Init(this, m_pStringTable, &m_variantAlloc, &m_keyAlloc);
	if ( FAILED(hr) )
	{
		// if we cannot init the data store then its because we
		// cannot allocate the critical section that protects the
		// setting of keys so we cannot create the datastore.
		delete pZds;
		*ppZds = NULL;
		return hr;
	}

	*ppZds = (IDataStore *) pZds;
	return S_OK;
}


STDMETHODIMP CDataStoreManager::Init(int iInitialTableSize, int iNextStrAlloc, int iMaxStrAllocSize, WORD NumBuckets, WORD NumLocks, IResourceManager *piResourceManager)
{
	m_pStringTable = new CStringTable();
	if ( !m_pStringTable )
		return E_OUTOFMEMORY;

	HRESULT hr = m_pStringTable->Init(iInitialTableSize, iNextStrAlloc, iMaxStrAllocSize, NumBuckets, NumLocks);
	if ( FAILED(hr) )
	{
		delete m_pStringTable;
		m_pStringTable = NULL;
		return hr;
	}

    if(m_piResourceManager)
        m_piResourceManager->Release();

    m_piResourceManager = piResourceManager;
    if(m_piResourceManager)
        m_piResourceManager->AddRef();

	return S_OK;
}


STDMETHODIMP CDataStoreManager::SetResourceManager(IResourceManager *piResourceManager)
{
    if(m_piResourceManager)
        m_piResourceManager->Release();

    m_piResourceManager = piResourceManager;
    if(m_piResourceManager)
        m_piResourceManager->AddRef();

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// CDataStore
///////////////////////////////////////////////////////////////////////////////


ZONECALL CDataStore::CDataStore(void)
{
	m_pStringTable = NULL;
	m_pVariantAlloc = NULL;
	m_pKeyAlloc = NULL;
    m_piManager = NULL;
	m_cRef = 0;
	m_Root.idKeyName = -1;
	m_Root.dwSize = 0;
	m_Root.pvtData = NULL;
	m_Root.pNext = NULL;
	m_Root.pChild = NULL;
	InitializeCriticalSection( &m_csKey );
}


ZONECALL CDataStore::~CDataStore()
{
	EnterCriticalSection( &m_csKey );

	// delete all keys
	while ( m_Root.pChild )
		DeleteKey( m_Root.pChild, &m_Root );

	DeleteCriticalSection( &m_csKey );
}


STDMETHODIMP CDataStore::QueryInterface(REFIID iid, void **ppvObject)
{
	if ( IsEqualGUID(iid,IID_IDataStore) )
	{
		*ppvObject = (IDataStore*) this;
		AddRef();
		return S_OK;
	}
	else if ( IsEqualGUID(iid,IID_IUnknown) )
	{
		*ppvObject = (IUnknown*) this;
		AddRef();
		return S_OK;
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
}


STDMETHODIMP_(ULONG) CDataStore::AddRef( void )
{
	return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDataStore::Release( void)
{
	if ( InterlockedDecrement(&m_cRef) == 0 )
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


STDMETHODIMP CDataStore::Init(IDataStoreManager *piManager, CStringTable *pStringTable, CPool<VARIANT> *pVariantAlloc, CPool<KEY> *pKeyAlloc)
{
	m_pStringTable	= pStringTable;
	m_pVariantAlloc	= pVariantAlloc;
	m_pKeyAlloc		= pKeyAlloc;
    m_piManager     = piManager;
	return S_OK;
}


STDMETHODIMP CDataStore::SetKey(CONST TCHAR *szKey, LPVARIANT pVariant, DWORD dwSize)
{
	CAutoLockCS lock( &m_csKey );

	// verify arguments
	if ( !szKey || !szKey[0] || !pVariant )
		return E_INVALIDARG;

	// create key
	PKEY pKey = AddKey(szKey);
	if ( !pKey )
		return E_FAIL;

	// set key data
	return StoreKeyData(pKey, pVariant, dwSize);
}


STDMETHODIMP CDataStore::SetKey( CONST TCHAR** arKeys, long nElts, LPVARIANT pVariant, DWORD dwSize)
{
	CAutoLockCS lock( &m_csKey );

	// verify arguments
	if ( !nElts || !arKeys || !pVariant )
		return E_INVALIDARG;

	// create key
	PKEY pKey = AddKey(arKeys,nElts);
	if ( !pKey )
		return E_FAIL;

	// set key data
	return StoreKeyData(pKey, pVariant, dwSize);
}


STDMETHODIMP CDataStore::SetString( CONST TCHAR* szKey, CONST TCHAR* szValue )
{
	// verify arguments
	if ( !szKey || !szValue )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = (void*) szValue;
	return SetKey( szKey, &v, (lstrlen(szValue) + 1 )*sizeof(TCHAR));
}


STDMETHODIMP CDataStore::SetString( CONST TCHAR** arKeys, long nElts, CONST TCHAR* szValue )
{
	// verify arguments
	if ( !nElts || !arKeys || !szValue )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = (void*) szValue;
	return SetKey( arKeys, nElts, &v, (lstrlen(szValue) + 1 )*sizeof(TCHAR));
}


STDMETHODIMP CDataStore::SetBlob( CONST TCHAR* szKey, CONST void* pBlob, DWORD dwLen )
{
	// verify arguments
	if ( !szKey || !pBlob || !dwLen )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = (void*) pBlob;
	return SetKey( szKey, &v, dwLen );
}


STDMETHODIMP CDataStore::SetBlob( CONST TCHAR** arKeys, long nElts, CONST void* pBlob, DWORD dwLen )
{
	// verify arguments
	if ( !nElts || !arKeys || !pBlob || !dwLen )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = (void*) pBlob;
	return SetKey( arKeys, nElts, &v, dwLen );
}


STDMETHODIMP CDataStore::SetLong( CONST TCHAR* szKey, long lValue )
{
	// verify arguments
	if ( !szKey )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_LONG;
	v.lVal = lValue;
	return SetKey( szKey, &v, sizeof(long) );
}


STDMETHODIMP CDataStore::SetLong( CONST TCHAR**	arKeys, long nElts, long lValue )
{
	// verify arguments
	if ( !nElts || !arKeys )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_LONG;
	v.lVal = lValue;
	return SetKey( arKeys, nElts, &v, sizeof(long) );
}


STDMETHODIMP CDataStore::SetRGB( CONST TCHAR* szKey, COLORREF colorRGB )
{
	// verify arguments
	if ( !szKey )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_RGB;
	v.lVal = (long) colorRGB;
	return SetKey( szKey, &v, sizeof(long) );
}


STDMETHODIMP CDataStore::SetRGB( CONST TCHAR**	arKeys, long nElts, COLORREF colorRGB )
{
	// verify arguments
	if ( !nElts || !arKeys )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_RGB;
	v.lVal = (long) colorRGB;
	return SetKey( arKeys, nElts, &v, sizeof(long) );
}


STDMETHODIMP CDataStore::SetPOINT( CONST TCHAR*	szKey, const POINT&	refPoint )
{
	// verify arguments
	if ( !szKey )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_PT;
	v.byref = (void*) &refPoint;
	return SetKey( szKey, &v, sizeof(POINT) );
}


STDMETHODIMP CDataStore::SetPOINT( CONST TCHAR** arKeys, long nElts, const POINT& refPoint )
{
	// verify arguments
	if ( !nElts || !arKeys )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_PT;
	v.byref = (void*) &refPoint;
	return SetKey( arKeys, nElts, &v, sizeof(POINT) );
}


STDMETHODIMP CDataStore::SetRECT( CONST TCHAR*	szKey, const RECT& refRect )
{
	// verify arguments
	if ( !szKey )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_RECT;
	v.byref = (void*) &refRect;
	return SetKey( szKey, &v, sizeof(RECT) );
}


STDMETHODIMP CDataStore::SetRECT( CONST TCHAR**	arKeys, long nElts, const RECT& refRect )
{
	// verify arguments
	if ( !nElts || !arKeys )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_RECT;
	v.byref = (void*) &refRect;
	return SetKey( arKeys, nElts, &v, sizeof(RECT) );
}


STDMETHODIMP CDataStore::SetFONT( CONST TCHAR*	szKey, const ZONEFONT& refFont )
{
	// verify arguments
	if ( !szKey )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_FONT;
	v.byref = (void*) &refFont;
	return SetKey( szKey, &v, sizeof(ZONEFONT) );
}


STDMETHODIMP CDataStore::SetFONT( CONST TCHAR**	arKeys, long nElts, const ZONEFONT& refFont )
{
	// verify arguments
	if ( !nElts || !arKeys )
		return E_INVALIDARG;

	// construct variant
	VARIANT v;
	v.vt = ZVT_FONT;
	v.byref = (void*) &refFont;
	return SetKey( arKeys, nElts, &v, sizeof(ZONEFONT) );
}


STDMETHODIMP CDataStore::GetKey( CONST TCHAR *szKey, LPVARIANT pVariant, PDWORD pdwSize )
{
	CAutoLockCS lock( &m_csKey );

	// verify arguments
	if ( !szKey || !szKey[0] || (!pVariant && !pdwSize) )
		return E_INVALIDARG;

	// lookup key
	PKEY pKey = FindKeyAndParent( szKey, NULL );
	if ( !pKey )
		return ZERR_NOTFOUND;

	// only care about size
	if ( !pVariant )
	{
		if ( pKey->pvtData->vt & ZVT_BYREF )
			*pdwSize = pKey->dwSize;
		else
			*pdwSize = 0;
		return ZERR_BUFFERTOOSMALL;
	}

	// Copy variant
	if ( pKey->pvtData->vt & ZVT_BYREF )
	{
		if ( pdwSize && *pdwSize < pKey->dwSize )
		{
			*pdwSize = pKey->dwSize;
			return ZERR_BUFFERTOOSMALL;
		}

		pVariant->vt = pKey->pvtData->vt;
		*pdwSize = pKey->dwSize;
		CopyMemory(pVariant->byref, pKey->pvtData->byref, pKey->dwSize);
	}
	else
	{
		CopyMemory(pVariant, pKey->pvtData, sizeof(VARIANT));
	}

	return S_OK;
}


STDMETHODIMP CDataStore::GetKey( CONST TCHAR** arKeys, long nElts, LPVARIANT pVariant, PDWORD pdwSize )
{
	CAutoLockCS lock( &m_csKey );

	// verify arguments
	if ( !nElts || !arKeys || !pVariant )
		return E_INVALIDARG;

	// lookup key
	PKEY pKey = FindKeyAndParent(arKeys,nElts);
	if ( !pKey )
		return ZERR_NOTFOUND;

	// Copy variant
	if ( pKey->pvtData->vt & ZVT_BYREF )
	{
		if ( pdwSize && *pdwSize < pKey->dwSize )
		{
			*pdwSize = pKey->dwSize;
			return ZERR_BUFFERTOOSMALL;
		}

		pVariant->vt = pKey->pvtData->vt;
		*pdwSize = pKey->dwSize;
		CopyMemory(pVariant->byref, pKey->pvtData->byref, pKey->dwSize);
	}
	else
		CopyMemory(pVariant, pKey->pvtData, sizeof(VARIANT));

	return S_OK;
}


STDMETHODIMP CDataStore::GetString( CONST TCHAR* szKey, TCHAR* szValue, PDWORD pdwSize )
{
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = (PVOID) szValue;

	HRESULT hr = GetKey( szKey, &v, pdwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LPTSTR )
		{
			szValue[ (*pdwSize)/sizeof(TCHAR) - 1 ] = _T('\0');
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetString( CONST TCHAR** arKeys, long nElts, TCHAR* szValue, PDWORD pdwSize )
{
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = (PVOID) szValue;

	HRESULT hr = GetKey( arKeys, nElts, &v, pdwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LPTSTR )
		{
			szValue[ *pdwSize - 1 ] = _T('\0');
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}

STDMETHODIMP CDataStore::GetBlob( CONST TCHAR* szKey, void* pBlob, PDWORD pdwSize )
{
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = pBlob;

	HRESULT hr = GetKey( szKey, &v, pdwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_BLOB )
		{
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}

STDMETHODIMP CDataStore::GetBlob( CONST TCHAR** arKeys, long nElts, void* pBlob, PDWORD pdwSize )
{
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = pBlob;

	HRESULT hr = GetKey( arKeys, nElts, &v, pdwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_BLOB )
		{
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}

STDMETHODIMP CDataStore::GetLong( CONST TCHAR* szKey, long* plValue )
{
	VARIANT v;
	v.vt = ZVT_LONG;
	v.byref = NULL;

	HRESULT hr = GetKey( szKey, &v, NULL );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LONG )
		{
			*plValue = v.lVal;
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetLong( CONST TCHAR** arKeys, long nElts, long* plValue )
{
	VARIANT v;
	v.vt = ZVT_LONG;
	v.byref = NULL;

	HRESULT hr = GetKey( arKeys, nElts, &v, NULL );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LONG )
		{
			*plValue = v.lVal;
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetRGB( CONST TCHAR* szKey, COLORREF* pcolorRGB )
{
	VARIANT v;
	v.vt = ZVT_RGB;
	v.byref = NULL;

	HRESULT hr = GetKey( szKey, &v, NULL );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_RGB )
		{
			*pcolorRGB = (COLORREF) v.lVal;
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetRGB( CONST TCHAR** arKeys, long nElts, COLORREF* pcolorRGB )
{
	VARIANT v;
	v.vt = ZVT_RGB;
	v.byref = NULL;

	HRESULT hr = GetKey( arKeys, nElts, &v, NULL );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_RGB )
		{
			*pcolorRGB = (COLORREF) v.lVal;
			return S_OK;
		}
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetPOINT( CONST TCHAR*	szKey, POINT* pPoint )
{
	DWORD dwSize = sizeof(POINT);
	VARIANT v;
	v.vt = ZVT_PT;
	v.byref = (PVOID) pPoint;

	HRESULT hr = GetKey( szKey, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_PT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetPOINT( CONST TCHAR** arKeys, long nElts, POINT* pPoint )
{
	DWORD dwSize = sizeof(POINT);
	VARIANT v;
	v.vt = ZVT_PT;
	v.byref = (PVOID) pPoint;

	HRESULT hr = GetKey( arKeys, nElts, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_PT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetRECT( CONST TCHAR* szKey, RECT* pRect )
{
	DWORD dwSize = sizeof(RECT);
	VARIANT v;
	v.vt = ZVT_RECT;
	v.byref = (PVOID) pRect;

	HRESULT hr = GetKey( szKey, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_RECT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetRECT( CONST TCHAR** arKeys, long nElts, RECT* pRect )
{
	DWORD dwSize = sizeof(RECT);
	VARIANT v;
	v.vt = ZVT_RECT;
	v.byref = (PVOID) pRect;

	HRESULT hr = GetKey( arKeys, nElts, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_RECT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetFONT( CONST TCHAR* szKey, ZONEFONT* pFont )
{
	DWORD dwSize = sizeof(ZONEFONT);
	VARIANT v;
	v.vt = ZVT_FONT;
	v.byref = (PVOID) pFont;

	HRESULT hr = GetKey( szKey, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_FONT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::GetFONT( CONST TCHAR** arKeys, long nElts, ZONEFONT* pFont )
{
	DWORD dwSize = sizeof(ZONEFONT);
	VARIANT v;
	v.vt = ZVT_FONT;
	v.byref = (PVOID) pFont;

	HRESULT hr = GetKey( arKeys, nElts, &v, &dwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_FONT )
			return S_OK;
		else
			return ZERR_WRONGTYPE;
	}
	return hr;
}


STDMETHODIMP CDataStore::DeleteKey(CONST TCHAR *szBaseKey)
{
	CAutoLockCS lock( &m_csKey );

	int		i;
	DWORD	id;
	PKEY	pKey;
	PKEY	pKeyPrev;
	TCHAR	*ptr;


	if ( !szBaseKey || !szBaseKey[0] )
	{
		// delete all keys
		while ( m_Root.pChild )
			DeleteKey( m_Root.pChild, &m_Root );
	}
	else
	{
		// delete specified key and its children
		PKEY pParent = NULL;
		PKEY pKey = FindKeyAndParent( szBaseKey, &pParent );
		if ( !pKey )
			return ZERR_NOTFOUND;
		DeleteKey( pKey, pParent );
	}

	return S_OK;
}


void ZONECALL CDataStore::DeleteKey( PKEY pKey, PKEY pParent )
{
	// remove pKey from tree
	if ( pParent->pChild == pKey )
	{
		pParent->pChild = pKey->pNext;
	}
	else
	{
		// find previous pointer
		for ( PKEY p = pParent->pChild; p && p->pNext != pKey; p = p->pNext )
			;
		if ( !p )
			return;

		// unlink node
		p->pNext = pKey->pNext;
	}
	pKey->pNext = NULL;

	// delete pKey's children
	while ( pKey->pChild )
		DeleteKey( pKey->pChild, pKey );
	DeleteVariantData( pKey->pvtData );
	if ( pKey != &m_Root )
		delete pKey;
}


STDMETHODIMP CDataStore::EnumKeys( CONST TCHAR* szKey, PFKEYENUM pfCallback, LPVOID pContext )
{
	return EnumKeysLimitedDepth( szKey, 0xffffffff, pfCallback, pContext );
}


STDMETHODIMP CDataStore::EnumKeysLimitedDepth( CONST TCHAR* szKey, DWORD dwMaxDepth, PFKEYENUM pfCallback, LPVOID pContext )
{
	CAutoLockCS lock( &m_csKey );

	bool bEmpty = true;
	HRESULT hr = S_OK;
	
	// verify arguments
	if ( !pfCallback || (dwMaxDepth == 0) )
		return E_INVALIDARG;

	if ( !szKey || !szKey[0] )
	{
		// enumerate all root keys
		for ( PKEY pKey = m_Root.pChild; pKey; pKey = pKey->pNext )
		{
			bEmpty = false;
			hr = InternalEnumKey( pKey, _T(""), _T(""), pfCallback, pContext, true, dwMaxDepth );
			if ( hr != S_OK )
				return hr;
		}
	}
	else
	{
		// find base key
		PKEY pKey = FindKeyAndParent( szKey );
		if ( !pKey )
			return ZERR_NOTFOUND;

		// enumerate sub keys
		bEmpty = false;
		hr = InternalEnumKey( pKey, szKey, _T(""), pfCallback, pContext, false, dwMaxDepth );
		if ( hr != S_OK )
			return hr;
	}

	// did we do anything?
	if ( bEmpty )
		return ZERR_EMPTY;
	else
		return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// CDataStore private methods
///////////////////////////////////////////////////////////////////////////////

HRESULT ZONECALL CDataStore::InternalEnumKey(
			PKEY			pKey,
			CONST TCHAR*	szRoot,
			CONST TCHAR*	szRelative,
			PFKEYENUM		pfCallback,
			LPVOID			pContext,
			bool			bEnumSelf,
			DWORD			dwDepth )
{
	HRESULT hr = S_OK;

	// verify arguments
	if ( !pKey || !pKey->idKeyName )
		return E_INVALIDARG;

	// compose key names
	TCHAR szName[ 64 ];
	TCHAR szRelativeName[ 256 ];
	DWORD dwName = NUMELEMENTS(szName);
	szName[0] = _T('\0');
	szRelativeName[0] = _T('\0');
	m_pStringTable->Get( pKey->idKeyName, szName, &dwName );
	if ( bEnumSelf )
	{
		if ( szRelative && szRelative[0] )
			wsprintf( szRelativeName, TEXT("%s/%s"), szRelative, szName ); 
		else
			lstrcpy( szRelativeName, szName );
	}

	
	// call application
	if ( bEnumSelf )
	{
		if ( szRoot && szRoot[0] )
		{
			TCHAR szFullPath[ 512 ];
			wsprintf( szFullPath, TEXT("%s/%s"), szRoot, szRelativeName );
			hr = pfCallback( szFullPath, szRelativeName, pKey->pvtData, pKey->dwSize, pContext );
		}
		else
		{
			hr = pfCallback( szRelativeName, szRelativeName, pKey->pvtData, pKey->dwSize, pContext );
		}
		if ( hr != S_OK )
			return hr;
		dwDepth--;
	}

	// reached maximum depth?
	if ( dwDepth == 0 )
		return S_OK;

	// enumerate children
	for ( PKEY p = pKey->pChild; p; p = p->pNext )
	{
		hr = InternalEnumKey( p, szRoot, szRelativeName, pfCallback, pContext, true, dwDepth );
		if ( hr != S_OK )
			break;
	}

	return hr;
}

void ZONECALL CDataStore::DirToArray( CONST TCHAR *szKey, TCHAR* szBuf, TCHAR** arKeys, int* pnElts )
{
	int i = 0;
	int end = *pnElts - 1;
	TCHAR* key = szBuf;
	TCHAR* dst = szBuf;

	while ( *szKey && (i < end) )
	{
		if ( *szKey != _T('\\') && *szKey != _T('/') )
		{
			// copy char
			*dst++ = *szKey++;
		}
		else
		{
			// add directory
			*dst++ = _T('\0'), szKey++;
			if ( *key )
				arKeys[i++] = key;
			key = dst;
		}
	}
	*dst = _T('\0');
	if ( *key )
		arKeys[i++] = key;
	*pnElts = i;
}


PKEY ZONECALL CDataStore::FindKeyAndParent( CONST TCHAR *szKey, PKEY* ppParent )
{
	// inefficient, should use FindKey(CONST TCHAR** arKeys, int elmts)
	TCHAR	szBuf[4096];
	TCHAR*	arKeys[DataStore_MaxDirectoryDepth];
	int		nElts = DataStore_MaxDirectoryDepth;

	DirToArray( szKey, szBuf, arKeys, &nElts );
	return FindKeyAndParent( (CONST TCHAR**) arKeys, nElts, ppParent );
}


PKEY ZONECALL CDataStore::AddKey( CONST TCHAR *szKey )
{
	// inefficient, should use FindKey(CONST TCHAR** arKeys, int elmts)
	TCHAR	szBuf[4096];
	TCHAR*	arKeys[DataStore_MaxDirectoryDepth];
	int		nElts = DataStore_MaxDirectoryDepth;

	DirToArray( szKey, szBuf, arKeys, &nElts );
	return AddKey( (CONST TCHAR**) arKeys, nElts );
}


PKEY ZONECALL CDataStore::FindKeyAndParent( CONST TCHAR** arKeys, int nElts, PKEY* ppParent )
{
	PKEY pParent = NULL;
	PKEY pKey = &m_Root;

	// sanity check input
	if ( nElts <= 0 )
		return NULL;

	for ( int i = 0; i < nElts; i++ )
	{
		// convert directory to string id
		DWORD id = m_pStringTable->Find( arKeys[i] );
		if ( id == -1 )
			return NULL;

		// remember parent
		pParent = pKey;

		// find directory node
		for ( pKey = pKey->pChild; pKey; pKey = pKey->pNext )
		{
			if ( pKey->idKeyName == id )
				break;
		}
		if ( !pKey )
			return NULL;
	}

	// found key?
	if ( ppParent )
		*ppParent = pParent;
	return pKey;
}


PKEY ZONECALL CDataStore::AddKey( CONST TCHAR** arKeys, int nElts )
{
	PKEY pParent = NULL;
	PKEY pKey = &m_Root;

	// sanity check input
	if ( nElts <= 0 )
		return NULL;

	for ( int i = 0; i < nElts; i++ )
	{
		// convert directory to string id
		DWORD id = m_pStringTable->Add( arKeys[i] );
		if ( id == -1 )
			return NULL;

		// remember parent
		pParent = pKey;

		// find directory node
		for ( pKey = pKey->pChild; pKey; pKey = pKey->pNext )
		{
			if ( pKey->idKeyName == id )
				break;
		}

		// add key since if we didn't find one
		if ( !pKey )
		{
			pKey = new (*m_pKeyAlloc) KEY;
			if ( !pKey )
				return NULL;
			pKey->idKeyName = id;
			pKey->dwSize = 0;
			pKey->pvtData = NULL;
			pKey->pChild = NULL;
			pKey->pNext = pParent->pChild;
			pParent->pChild = pKey;
		}
	}

	// return last key found or added
	return pKey;
}


//
// Note:	The storeKeyData is protected from multiple access at the SetKey level.
//
HRESULT ZONECALL CDataStore::StoreKeyData(PKEY pKey, LPVARIANT pVariant, DWORD dwSize)
{
	// If the variant type contains ZVT_BYREF then we need to know the
	// size of the data object. There are currently two cases supported
	// ZVT_BLOB and VT_STRING. In the case of a BLOB the wReserved1 and
	// wReserved2 fields contain the size of the binary object.
	// In the case of a string the length is calculated. The differentation
	// is by the wReserved3 field.

	//Remove old data if present.
	DeleteVariantData(pKey->pvtData);

	//Allocate new variant
	pKey->pvtData = new (*m_pVariantAlloc) VARIANT;
	if ( !pKey->pvtData )
		return E_OUTOFMEMORY;

	// Copy variant info & data
	switch ( pVariant->vt )
	{
	case ZVT_LONG:
	case ZVT_RGB:
		pKey->pvtData->vt = pVariant->vt;
		pKey->pvtData->lVal = pVariant->lVal;
		pKey->dwSize = 0;
		break;

	case ZVT_LPTSTR:
		pKey->pvtData->vt = ZVT_LPTSTR;
		pKey->dwSize = (lstrlen( (TCHAR*) pVariant->byref ) + 1)*sizeof(TCHAR);
		pKey->pvtData->byref = (PVOID) ZMalloc( pKey->dwSize );
		if ( !pKey->pvtData->byref )
			return E_OUTOFMEMORY;
		CopyMemory( pKey->pvtData->byref, pVariant->byref, pKey->dwSize );
		break;

	case ZVT_BLOB:
	case ZVT_PT:
	case ZVT_RECT:
	case ZVT_FONT:
		pKey->pvtData->vt = pVariant->vt;
		pKey->dwSize = dwSize;
		pKey->pvtData->byref = (PVOID) ZMalloc( pKey->dwSize );
		if ( !pKey->pvtData->byref )
			return E_OUTOFMEMORY;
		CopyMemory(pKey->pvtData->byref, pVariant->byref, dwSize );
		break;

	default:
		CopyMemory( &(pKey->pvtData), pVariant, sizeof(VARIANT) );
		pKey->dwSize = dwSize;
		if ( pVariant->vt & ZVT_BYREF )
		{
			pKey->pvtData->byref = (PVOID) ZMalloc( pKey->dwSize );
			if ( !pKey->pvtData->byref )
				return E_OUTOFMEMORY;
			CopyMemory(pKey->pvtData->byref, pVariant->byref, dwSize );
		}
		break;
	}

	return S_OK;
}


static void DeleteVariantData(LPVARIANT pVariant)
{
	if ( !pVariant )
		return;

	if ( pVariant->vt & ZVT_BYREF )
		ZFree(pVariant->byref);

	delete pVariant;
}


///////////////////////////////////////////////////////////////////////////////
// CDataStore utility functions
//////////////////////////////////////////////////////////////////////////////

HRESULT ZONECALL CDataStore::VariantToString( const LPVARIANT pVariant, TCHAR* buff )
{
	// skip empty keys
	if ( !pVariant )
	{
		buff[0] = _T('\0');
		return S_OK;
	}

	// construct text
	switch( pVariant->vt )
	{
	case ZVT_LONG:
		{
			wsprintf( buff, TEXT("LONG, %d"), pVariant->lVal );
			break;
		}

	case ZVT_LPTSTR:
		{
			wsprintf( buff, TEXT("SZ, \"%s\""), (TCHAR*) pVariant->byref );
			break;
		}

	case ZVT_RGB:
		{
			BYTE red = GetRValue( pVariant->lVal );
			BYTE green = GetGValue( pVariant->lVal );
			BYTE blue = GetBValue( pVariant->lVal );
			wsprintf( buff, TEXT("RGB, { %d, %d, %d }"), red, green, blue );
			break;
		}

	case ZVT_PT:
		{
			POINT* p = (POINT*) pVariant->byref;
			wsprintf( buff, TEXT("PT, { %d, %d }"), p->x, p->y );
			break;
		}

	case ZVT_RECT:
		{
			RECT* r = (RECT*) pVariant->byref;
			wsprintf( buff, TEXT("RECT, { %d, %d, %d, %d }"), r->left, r->top, r->right, r->bottom );
			break;
		}

	case ZVT_FONT:
		{
			ZONEFONT* p = (ZONEFONT*) pVariant->byref;
			wsprintf( buff, TEXT("FONT, { \"%s\", %d, %d }"), p->lfFaceName, p->lfHeight, p->lfWeight );
			break;
		}

	default:
		{
			wsprintf( buff, TEXT("Unknown type" ));
			return ZERR_UNSUPPORTED_KEY_TYPE;
		}
	}

	return S_OK;
}


HRESULT ZONECALL CDataStore::StringToVariant( TCHAR* szInput, LPVARIANT pVariant, BYTE* pBuffer, DWORD* pdwSize, IDataStoreManager *piManager )
{
	//
	// Convert TYPE, VALUE to variant
	//

	HRESULT hr = E_FAIL;
	TCHAR *p, *type, *value;
    TCHAR szRegBuf[1024];

	// find type
	type = strltrim( szInput );
	p = FindChar( type, _T(',') );
	if ( !p )
		return E_FAIL;
	*p++ = _T('\0');
	strrtrim( type );

	// find value
	value = strtrim( p );

    // see if we should load indirectly
    TCHAR *pSubtype;
    pSubtype = FindChar( type, _T(' ') );
    if( pSubtype )
    {
        *pSubtype++ = _T('\0');
        pSubtype = strltrim( pSubtype );

        if(!lstrcmpi( pSubtype, TEXT("indir") ) || !lstrcmpi( pSubtype, TEXT("i") ))
        {
            UINT uID;
            int res;
            IResourceManager *pResMgr = piManager->GetResourceManager();

            uID = zatol(value);
            if(!uID)
                return E_FAIL;

            if(pResMgr)
                res = pResMgr->LoadString(uID, szRegBuf, NUMELEMENTS(szRegBuf));
            else
                res = LoadString(_Module.GetResourceInstance(), uID, szRegBuf, NUMELEMENTS(szRegBuf));

            if(!res)
                return E_FAIL;

            value = strtrim(szRegBuf);
        }
    }

	// convert value to variant
	if ( lstrcmpi( type, TEXT("long") ) == 0 )
	{
		// create variant
		*pdwSize = 0;
		pVariant->vt = ZVT_LONG;
		pVariant->lVal = zatol(value);
		hr = S_OK;
	}
	else if ( lstrcmpi( type, TEXT("sz") ) == 0 )
	{
		// strip one set of quotes if present
		if ( *value == _T('\"') )
		{
			p = FindLastChar ( value, _T('\"') );
			if ( !p )
				return E_FAIL;
			value++;
			*p = _T('\0');
		}

		// create variant
		*pdwSize = (lstrlen(value)+1)*sizeof(TCHAR);
		pVariant->vt = ZVT_LPTSTR;
		pVariant->byref = value;
		hr = S_OK;
	}
	else if ( lstrcmpi( type, TEXT("rgb") ) == 0 )
	{
		BYTE red, green, blue;

		// extract RGB from { red , green , blue }
		if ( *value++ != _T('{') )
			return E_FAIL;
		p = FindChar( value, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		red = (BYTE) zatol( strtrim( value ) );
		p = FindChar( value = p, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		green = (BYTE) zatol( strtrim( value ) );
		p = FindChar( value = p, _T('}') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		blue = (BYTE) zatol( strtrim( value ) );

		// create variant
		*pdwSize = 0;
		pVariant->vt = ZVT_RGB;
		pVariant->lVal = RGB(red,green,blue);
		hr = S_OK;
	}
	else if ( lstrcmpi( type, TEXT("pt") ) == 0 )
	{
		POINT* pt = (POINT*) pBuffer;

		// extract x,y from { x, y }
		if ( *value++ != _T('{') )
			return E_FAIL;
		p = FindChar( value, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		pt->x = zatol( strtrim( value ) );
		p = FindChar( value = p, _T('}') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		pt->y = zatol( strtrim( value ) );

		// create variant
		*pdwSize = sizeof(POINT);
		pVariant->vt = ZVT_PT;
		pVariant->byref = (void*) pt;
		hr = S_OK;
	}
	else if ( lstrcmpi( type, TEXT("rect") ) == 0 )
	{
		RECT* rc = (RECT*) pBuffer;

		// extract l,t,r,b from { l, t, r, b }
		if ( *value++ != _T('{') )
			return E_FAIL;
		p = FindChar( value, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		rc->left = zatol( strtrim( value ) );

		p = FindChar( value = p, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		rc->top = zatol( strtrim( value ) );

		p = FindChar( value = p, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		rc->right = zatol( strtrim( value ) );

		p = FindChar( value = p, _T('}') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		rc->bottom = zatol( strtrim( value ) );

		// create variant
		*pdwSize = sizeof(RECT);
		pVariant->vt = ZVT_RECT;
		pVariant->byref = (void*) rc;
		hr = S_OK;
	}
	else if ( lstrcmpi( type, TEXT("font") ) == 0 )
	{
		ZONEFONT* pFont = (ZONEFONT*) pBuffer;

		// extract facename, height, weight from { "n", h, w }
		if ( *value++ != _T('{') )
			return E_FAIL;

        value = strltrim(value);

		// here we go, wheeeeee. Find the name, allow quotes or not quotes
		p = FindChar ( value, _T(',') );

		// strip one set of quotes if present
		if ( value[0] == _T('\"') )
		{
			if ( !p || p[-1] != _T('\"') )
				return E_FAIL;
			value++;
			p[-1] = _T('\0');
		} 
		p++[0] = _T('\0');

		if ( lstrlen(value) >= NUMELEMENTS(pFont->lfFaceName) )
			return E_FAIL;
		lstrcpy(pFont->lfFaceName, value);
		
		// now find the height
		p = FindChar( value = p, _T(',') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		pFont->lfHeight = zatol( strtrim( value ) );

		// and finish up with the weight
		p = FindChar( value = p, _T('}') );
		if ( !p )
			return E_FAIL;
		*p++ = _T('\0');
		pFont->lfWeight = zatol( strtrim( value ) );

		// create variant
		*pdwSize = sizeof(ZONEFONT);
		pVariant->vt = ZVT_FONT;
		pVariant->byref = (void*) pFont;
		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}


struct BUFFERSIZECONTEXT
{
	DWORD dwSizeNeeded;		// total size of memory block and data
	DWORD dwTotalKeys;		// total keys to copy from data store	
	DWORD dwDataOffset;		// offset to string data within the returned memory block.
};


struct BUFFERCOPYCONTEXT
{
	DWORD		dwTotalKeys;
	BYTE*		pData;
	PKEYINFO	pKeyInfo;
};


HRESULT ZONECALL CDataStore::CalcSizeCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	BUFFERSIZECONTEXT* p = (BUFFERSIZECONTEXT*) pContext;
	
	// skip empty keys
	if ( !pVariant )
		return S_OK;

	// add key and data to buffer size
	p->dwTotalKeys++;
	p->dwDataOffset += sizeof(KEYINFO);
	p->dwSizeNeeded += ((lstrlen(szKey) + 1)*sizeof(TCHAR) + sizeof(VARIANT) + sizeof(KEYINFO));
	if ( pVariant->vt & ZVT_BYREF )
			p->dwSizeNeeded += dwSize;

	return S_OK;
}


HRESULT ZONECALL CDataStore::CopyCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	BUFFERCOPYCONTEXT* p = (BUFFERCOPYCONTEXT*) pContext;

	// skip empty keys
	if ( !pVariant )
		return S_OK;

	// copy key name to data
	p->pKeyInfo[p->dwTotalKeys].szKey = (TCHAR*) p->pData;
	lstrcpy( (TCHAR*) p->pData, szKey );
	p->pData += (lstrlen(szKey) + 1)*sizeof(TCHAR);

	// copy variant header
	p->pKeyInfo[p->dwTotalKeys].lpVt = (LPVARIANT) p->pData;
	CopyMemory( (PVOID) p->pData, pVariant, sizeof(VARIANT) );
	p->pData += sizeof(VARIANT);

	// copy variant data
	p->pKeyInfo[p->dwTotalKeys].dwSize = dwSize;
	if ( pVariant->vt & ZVT_BYREF )
	{
		p->pKeyInfo[p->dwTotalKeys].lpVt->byref = (PVOID) p->pData;
		CopyMemory( (PVOID) p->pData, pVariant->byref, dwSize );
		p->pData += dwSize;
	}
	
	// inc key count
	p->dwTotalKeys++;
	return S_OK;
}


HRESULT ZONECALL CDataStore::LoadFromBuffer(CONST TCHAR* szBaseKey, PKEYINFO pKeyInfo, DWORD dwTotalKeys)
{
	int		i;
	int		iMaxLen = 0;
	int		iLen;
	DWORD	dwBaseKeySlash;
	HRESULT	hr;
	TCHAR	szSmall[256];
	TCHAR	*pszKeyBuffer;
	BOOL	bSlashNeeded;

	// walk key array to find maximum key length
	for(i=0; i<(int)dwTotalKeys; i++)
	{
		iLen = (lstrlen(pKeyInfo[i].szKey) + 1)*sizeof(TCHAR);
		if ( iLen > iMaxLen )
			iMaxLen = iLen;
	}
	iMaxLen = iMaxLen + (lstrlen(szBaseKey) + 2)*sizeof(TCHAR);

	// allocate buffer big enough for max key name
	if ( iMaxLen < sizeof(szSmall) )
		pszKeyBuffer = szSmall;
	else
	{
		pszKeyBuffer = (TCHAR *)ZMalloc(iMaxLen);
		if ( !pszKeyBuffer )
			return E_OUTOFMEMORY;
	}

	// create base key string, adding slash if necessary
	lstrcpy( pszKeyBuffer, szBaseKey );
	dwBaseKeySlash = (DWORD) lstrlen(pszKeyBuffer);
	bSlashNeeded = (BOOL)(szBaseKey[dwBaseKeySlash-1] != _T('/'));
	if ( bSlashNeeded )
	{
		pszKeyBuffer[dwBaseKeySlash] = _T('/');
		dwBaseKeySlash++;
	}

	// walk key array and add to data store
	for(i=0; i<(int)dwTotalKeys; i++)
	{
		lstrcpy(&pszKeyBuffer[dwBaseKeySlash], pKeyInfo[i].szKey);
		hr = SetKey(pszKeyBuffer, pKeyInfo[i].lpVt, pKeyInfo[i].dwSize);
		if ( FAILED(hr) )
			return hr;
	}

	// free key name buffer if we created one
	if ( pszKeyBuffer != szSmall )
		ZFree(pszKeyBuffer);

	return S_OK;
}


HRESULT ZONECALL CDataStore::SaveToBuffer(CONST TCHAR *szBaseKey, PKEYINFO pKeyInfo, PDWORD pdwBufferSize, PDWORD pdwTotalKeys)
{
	HRESULT		hr;
	PBYTE		pData;

	// First pass calculates buffer size required to return to information
	// to the caller.  We need to calc how many keys to read and also how
	// big the returned pKeyInfo array needs to be.
	BUFFERSIZECONTEXT bz;
	bz.dwSizeNeeded = 0;
	bz.dwTotalKeys = 0;
	bz.dwDataOffset = 0;
	hr = EnumKeys( szBaseKey, CalcSizeCallback, &bz );
	if ( FAILED(hr) )
		goto error_SaveToBuffer;

	// Tell caller number of keys
	if ( pdwTotalKeys )
		*pdwTotalKeys = bz.dwTotalKeys;

	// Big enough buffer?
	if ( !pdwBufferSize  || (*pdwBufferSize < bz.dwSizeNeeded) )
	{
		*pdwBufferSize = bz.dwSizeNeeded;
		hr = ZERR_BUFFERTOOSMALL;
		goto error_SaveToBuffer;
	}

	// clear buffer
	ZeroMemory((PVOID)pKeyInfo, bz.dwSizeNeeded);
	pData = ((PBYTE)pKeyInfo) + bz.dwDataOffset;

	// Second pass copies keys into buffer
	BUFFERCOPYCONTEXT bc;
	bc.dwTotalKeys = 0;
	bc.pData = (BYTE*) pData;
	bc.pKeyInfo = pKeyInfo;
	hr = EnumKeys( szBaseKey, CopyCallback, &bc );
	if ( FAILED(hr) )
		goto error_SaveToBuffer;

	hr = S_OK;

error_SaveToBuffer:

	return hr;
}


HRESULT ZONECALL CDataStore::LoadFromRegistry(CONST TCHAR* szBaseKey, HKEY hKey)
{
	HRESULT		hr;
	long		ret;
	TCHAR		szKey[512];
	TCHAR		szName[128];
	DWORD		cchName = NUMELEMENTS(szName);
	BYTE		pData[512];
	DWORD		cbData = sizeof(pData);
	BYTE		pVariantBuffer[512];
	DWORD		cbVariantBuffer = sizeof(pVariantBuffer);
	DWORD		dwType;
	VARIANT		v;
	DWORD		dwSize;
	FILETIME	ftLastWrite;

	// insert key's values into the data store
	for ( int i = 0; ; i++ )
	{
		// get registry value
		szName[0] = _T('\0');
		cchName = NUMELEMENTS(szName);
		cbData  = sizeof(pData);
		ret = RegEnumValue( hKey, i, szName, &cchName, NULL, &dwType, pData, &cbData );
		if ( ret != ERROR_SUCCESS )
			break;

		// create data store path
		if ( szBaseKey && szBaseKey[0] )
			wsprintf( szKey, TEXT("%s/%s"), szBaseKey, szName );
		else
			lstrcpy( szKey, szName );

		// create variant
		switch ( dwType )
		{
		case REG_SZ:
			{
				// assume string is in DataStore format
				hr = StringToVariant( (TCHAR*) pData, &v, pVariantBuffer, &cbVariantBuffer, m_piManager );
				if ( FAILED(hr) )
					goto error;
				dwSize = cbVariantBuffer;
				break;
			}
		case REG_BINARY:
			{
				// binary data in any form.
				v.vt = ZVT_BLOB;
				v.byref = (PVOID) pData;
				dwSize = cbData;
				break;
			}
		case REG_DWORD:
			{
				// Long
				v.vt = ZVT_LONG;
				v.lVal = *((long *)pData);
				break;
			}
		default:
			{
				continue;
			}
		}

		hr = SetKey( szKey, &v, dwSize );
		if ( FAILED(hr) )
			goto error;
	}

	// load sub-keys
	for ( i = 0; ; i++ )
	{
		HKEY hNewKey = NULL;

		szName[0] = _T('\0');
		cchName = NUMELEMENTS(szName);
		ret = RegEnumKeyEx( hKey, i, szName, &cchName, NULL, NULL, NULL, &ftLastWrite );
		if ( ret != ERROR_SUCCESS )
			break;

		ret = RegOpenKeyEx( hKey, szName, 0, KEY_READ, &hNewKey );
		if ( ret == ERROR_SUCCESS )
		{
			// create data store path
			if ( szBaseKey && szBaseKey[0] )
				wsprintf( szKey, TEXT("%s/%s"), szBaseKey, szName );
			else
				lstrcpy( szKey, szName );

			// recursive through sub-key
			hr = LoadFromRegistry( szKey, hNewKey );
			if ( FAILED(hr) )
			{
				RegCloseKey( hNewKey );
				goto error;
			}
		}

		if ( hNewKey )
			RegCloseKey( hNewKey );
  	}

	hr = S_OK;
error:
	return hr;
}


STDMETHODIMP CDataStore::LoadFromTextBuffer( CONST TCHAR* szBaseKey, CONST TCHAR* pBuffer, DWORD dwBufferSz )
{
	HRESULT hr;
	TCHAR szLine[1024];
	TCHAR szFullKey[512];
	TCHAR szPrefix[128];
	TCHAR szRoot[128];
	TCHAR *p;

	// verify arguments
	if ( !pBuffer || (dwBufferSz <= 0) )
		return E_INVALIDARG;

	// clear strings, overkill but handy
	ZeroMemory( szFullKey, sizeof(szFullKey) );
	ZeroMemory( szRoot, sizeof(szRoot) );
	ZeroMemory( szPrefix, sizeof(szPrefix) );

	// copy base key into prefix, append trailing '/' if necessary
	if ( szBaseKey && szBaseKey[0] )
	{
		for ( p = szPrefix; *szBaseKey; )
			*p++ = *szBaseKey++;
		if ( *(szBaseKey - 1) != _T('/') )
			*p++ = _T('/');
		*p = _T('\0');
	}
	else
		szPrefix[0] = _T('\0');
	
	// parse buffer
	CONST TCHAR* pEnd = (TCHAR*)(((BYTE*) pBuffer) + dwBufferSz);
	while ( pBuffer < pEnd )
	{
		// read a line into work buffer
		for ( p = szLine; (*pBuffer != _T('\n')) && (*pBuffer != _T('\0')) && (pBuffer < pEnd); )
			*p++ = *pBuffer++;
		if ( pBuffer < pEnd )
		{
			*p++ = *pBuffer++;
			*p = _T('\0');
		}
		else
			*p = _T('\0');
		p = strltrim( szLine );


		if ( *p == _T('\0') )
		{
			// EMPTY
			continue;
		}
		else if (	((*p == _T('\\')) && (*(p + 1) == _T('\\')) )
				 || ((*p == _T('/')) && (*(p + 1) == _T('/') )) 
				 || (*p == _T(';')))
		{
			// COMMMENT
			continue;
		}
		else if ( *p == _T('[') )
		{
			// [ ROOT ]
			TCHAR* end;

			// find root
			p = strltrim( ++p );
			end = FindChar( p, _T(']') );
			if ( !end )
				return E_FAIL;
			*end = _T('\0');
			end = strrtrim( p );

			// copy root, append trailing '/' if necessary
			if ( *p )
			{
				if ( *end != _T('/') )
				{
					*++end = _T('/');
					*++end = _T('\0');
				}
				lstrcpy( szRoot, p );
			}
			else
				szRoot[0] = _T('\0');
		}
		else
		{
			// KEY = TYPE, VALUE
			VARIANT	v;
			TCHAR*	key;
			BYTE	pBuffer[1024];
			DWORD	dwSize = sizeof(pBuffer);

			// find key
			key = strltrim( p );
			p = FindChar( key, _T('=') );
			if ( !p )
				return E_FAIL;
			*p++ = _T('\0');
			strrtrim(key);

			// find type
			hr = StringToVariant( p, &v, pBuffer, &dwSize, m_piManager );
			if ( FAILED(hr) )
				return hr;

			// concat key names
			wsprintf( szFullKey, TEXT("%s%s%s"), szPrefix, szRoot, key );

			// create key
			hr = SetKey( szFullKey, &v, dwSize );
			if ( FAILED(hr) )
				return hr;
		}
	}

	return S_OK;
}


struct TEXTBUFFERCONTEXT
{
	bool	m_bCopy;
	DWORD	m_dwBufferSize;
	DWORD	m_dwMaxBufferSize;
	LPVOID	m_pBuffer;
};


HRESULT ZONECALL CDataStore::BufferCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	TCHAR buff[2048];
	DWORD len;
	TEXTBUFFERCONTEXT* pCT = (TEXTBUFFERCONTEXT*) pContext;

	// skip empty keys
	if ( !pVariant )
		return S_OK;

	// construct text
	switch( pVariant->vt )
	{
	case ZVT_LONG:
		{
			wsprintf( buff, TEXT("%s = LONG, %d\r\n"), szKey, pVariant->lVal );
			break;
		}

	case ZVT_LPTSTR:
		{
			wsprintf( buff, TEXT("%s = SZ, \"%s\"\r\n"), szKey, (TCHAR*) pVariant->byref );
			break;
		}

	case ZVT_RGB:
		{
			BYTE red = GetRValue( pVariant->lVal );
			BYTE green = GetGValue( pVariant->lVal );
			BYTE blue = GetBValue( pVariant->lVal );
			wsprintf( buff, TEXT("%s = RGB, { %d, %d, %d }\r\n"), szKey, red, green, blue );
			break;
		}

	case ZVT_PT:
		{
			POINT* p = (POINT*) pVariant->byref;
			wsprintf( buff, TEXT("%s = PT, { %d, %d }\r\n"), szKey, p->x, p->y );
			break;
		}

	case ZVT_RECT:
		{
			RECT* r = (RECT*) pVariant->byref;
			wsprintf( buff, TEXT("%s = RECT, { %d, %d, %d, %d }\r\n"), szKey, r->left, r->top, r->right, r->bottom );
			break;
		}
	
	case ZVT_FONT:
		{
			ZONEFONT* p = (ZONEFONT*) pVariant->byref;
			wsprintf( buff, TEXT("%s = FONT, { \"%s\", %d, %d }\r\n"), szKey, p->lfFaceName, p->lfHeight, p->lfWeight );
			break;
		}

	default:
		return ZERR_UNSUPPORTED_KEY_TYPE;
	}

	// copy buffer
	len = lstrlen(buff)*sizeof(TCHAR);
	if ( pCT->m_bCopy  )
	{
		if ( (pCT->m_dwBufferSize + len) <= pCT->m_dwMaxBufferSize )
			CopyMemory( pCT->m_pBuffer, buff, len );
		pCT->m_pBuffer = ((BYTE*) pCT->m_pBuffer ) + len;
	}
	
	// adjust buffer size
	pCT->m_dwBufferSize += len;

	return S_OK;
}


STDMETHODIMP CDataStore::SaveToTextBuffer( CONST TCHAR* szBaseKey, LPVOID pBuffer, PDWORD pdwBufferSz )
{
	// verify arguments
	if ( !pdwBufferSz )
		return E_INVALIDARG;

	// copy buffer
	TEXTBUFFERCONTEXT p;
	p.m_dwBufferSize = 0;
	p.m_dwMaxBufferSize = *pdwBufferSz;
	p.m_pBuffer = pBuffer;
	if ( pBuffer )
		p.m_bCopy = true;
	else
		p.m_bCopy = false;

	// eunmerate keys and write to file
	HRESULT hr = EnumKeys( szBaseKey, BufferCallback, &p );
	if ( FAILED(hr) )
		return hr;

	// set buffer size
	if ( !pBuffer || (*pdwBufferSz < p.m_dwBufferSize) )
		hr = ZERR_BUFFERTOOSMALL;
	*pdwBufferSz = p.m_dwBufferSize;

	return hr;
}


STDMETHODIMP CDataStore::LoadFromFile(CONST TCHAR *szBaseKey, CONST TCHAR *szFileName)
{
	HRESULT hr;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hMap = NULL;
	VOID* pBuffer = NULL;
	DWORD dwSize;
	USES_CONVERSION;

	// verify arguments
	if ( !szFileName || !szFileName[0] )
		return E_INVALIDARG;

	// Open file
	hFile = CreateFile( szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0 );
	if ( hFile == INVALID_HANDLE_VALUE )
		return ZERR_NOTFOUND;
	
	// Query size
	dwSize = GetFileSize( hFile, NULL );

	// Open map
	hMap = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, NULL );
	if ( hMap == NULL )
	{
		hr = ZERR_NOTFOUND;
		goto exit;
	}

	// create view
	//assumption is file is ANSI not UNICODE
	pBuffer = MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );
	if ( !pBuffer )
	{
		hr = E_FAIL;
		goto exit;
	}

	// Use LoadFromTextBuffer to parse file
	hr = LoadFromTextBuffer( szBaseKey, (TCHAR*) A2T((char*)pBuffer), dwSize );
	if ( FAILED(hr) )
		goto exit;

	hr = S_OK;
exit:
	if ( pBuffer )
		UnmapViewOfFile( pBuffer );
	if ( hMap )
		CloseHandle( hMap );
	if ( hFile != INVALID_HANDLE_VALUE )
		CloseHandle( hFile );

	return hr;
}


HRESULT ZONECALL CDataStore::FileCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	TCHAR buff[1024];
	TCHAR value[512];
	DWORD dwBytesWritten;
	HANDLE hFile = (HANDLE) pContext;
	
	ASSERT( sizeof(buff) >= dwSize );

	// skip empty keys
	if ( !pVariant )
		return S_OK;

	// construct variant text
	HRESULT hr = VariantToString( pVariant, value );
	if ( FAILED(hr) )
		return hr;

	// contruct rest of line
	wsprintf( buff, TEXT("%s = %s\r\n"), szKey, value );

	// write line to file
	if ( !WriteFile( hFile, buff, lstrlen(buff)*sizeof(TCHAR), &dwBytesWritten, NULL ) )
		return ZERR_WRITE_FILE;

	return S_OK;
}


STDMETHODIMP CDataStore::SaveToFile(CONST TCHAR *szBaseKey, CONST TCHAR *szFileName)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HRESULT hr;

	// create file
	hFile = CreateFile( szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( hFile == INVALID_HANDLE_VALUE )
	{
		hr = ZERR_CANNOT_CREATE_FILE;
		goto SaveToFile_error;
	}

	// eunmerate keys and write to file
	hr = EnumKeys( szBaseKey, FileCallback, hFile );

	// clean up
SaveToFile_error:
	if ( hFile != INVALID_HANDLE_VALUE )
		CloseHandle( hFile );
	return hr;
}


HRESULT ZONECALL CDataStore::RegistryCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	HKEY hKey = (HKEY) pContext;
	HKEY hNewKey = NULL;
	DWORD dwDisposition = 0;
	long ret;

	CONST TCHAR* p;
	HRESULT hr = S_OK;
	TCHAR* q;
	TCHAR* szRegKey;
	TCHAR* szRegValue;
	TCHAR  szRegPath[1024];

	// convert DataStore path to registry path by replacing
	// forward slashes with backward slashes.
	for ( p = szRelKey, q = szRegPath; *p; p++, q++ )
	{
		*q = ( *p == _T('/')) ? _T('\\') : *p;
	}
	*q = _T('\0');


	if ( pVariant )
	{
		// create registry value
		TCHAR buff[2048];
		ASSERT( sizeof(buff) >= dwSize );

		// construct text

		if(pVariant->vt != ZVT_BLOB)
		{
			hr = VariantToString( pVariant, buff );
			if ( FAILED(hr) )
				return hr;
		}

		// Seperate registry key and value names
		q = FindLastChar( szRegPath, _T('\\') );
		if ( !q )
		{
			// only value
			szRegKey = NULL;
			szRegValue = szRegPath;
		}
		else
		{
			// both key and value
			*q = _T('\0');
			szRegKey = szRegPath;
			szRegValue = q + 1;
		}

		// create registry key if necessary
		if ( szRegKey )
		{
			ret = RegCreateKeyEx( hKey, szRegPath, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hNewKey, &dwDisposition );
			if ( ret != ERROR_SUCCESS )
				return S_OK;
			hKey = hNewKey;
		}

		// write registry value

		if(pVariant->vt != ZVT_BLOB)
			ret = RegSetValueEx( hKey, szRegValue, 0, REG_SZ, (BYTE*) buff, (lstrlen(buff)+ 1 )*sizeof(TCHAR) );
		else
			ret = RegSetValueEx( hKey, szRegValue, 0, REG_BINARY, (BYTE*) pVariant->byref, dwSize );

		// clese registry key if we create one
		if ( hNewKey )
			RegCloseKey( hNewKey );
	}

	return S_OK;
}


STDMETHODIMP CDataStore::SaveToRegistry(CONST TCHAR *szBaseKey, HKEY hKey)
{
	if ( hKey == NULL )
		return E_INVALIDARG;
	return EnumKeys( szBaseKey, RegistryCallback, hKey );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\clientguids\main.cpp ===
#include <windows.h>
#include <tchar.h>
#include <initguid.h>

// event mappings
#define __INIT_EVENTS
#include "ZoneEvent.h"

// key names
#define __INIT_KEYNAMES
#include "KeyName.h"

// IZoneProxy commands
#define __INIT_OPNAMES
#include "OpName.h"

// DirectX guids
#include "dplay.h"
#include "dplobby.h"
#include "ZoneLobby.h"

// Z5 to Z6 Network guids
#include <ZNet.h>

// zone guids
#include "BasicATL.h"
#include "ZoneDef.h"
#include "LobbyDataStore.h"
#include "EventQueue.h"
#include "ZoneShell.h"
#include "ZoneShellEx.h"
#include "LobbyCore.h"
#include "ChatCore.h"
#include "Launcher.h"
#include "Timer.h"
#include "InputManager.h"
#include "AccessibilityManager.h"
#include "GraphicalAcc.h"
#include "MillCommand.h"
#include "MillNetworkCore.h"
#include "MillEngine.h"
#include "MillCore.h"
#include "MultiStateFont.h"
#include "Conduit.h"
#include "ResourceManager.h"
#include "DataStore.h"

// test guids
//#include "..\test\stressengine\stressengine.h"

// text object model for chat
#include "..\chat\tom.h"

// IDL generated
#include "ClientIDL.h"
#include "ClientIDL_i.c"
#include "ZoneProxy.h"
#include "ZoneProxy_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\datastore\cstrtab.cpp ===
#include "BasicATL.h"
#include <ZoneDef.h>
#include <ZoneMem.h>
#include <ZoneError.h>
#include <hash.h>

#include "CdataStore.h"


ZONECALL CStringTable::CStringTable(void)
{
	m_pHash			= NULL;
}

void  ZONECALL CStringTable::StringDelete( StringKey * pkey, void* )
{
    if (pkey)
        delete pkey;
}


ZONECALL CStringTable::~CStringTable(void)
{
	// Lock the table then delete it same as the CDMTHash table.
	m_lock.Lock();

	// delete hash table 
	if ( m_pHash )
	{
		m_pHash->RemoveAll(StringDelete);
		delete m_pHash;
		m_pHash = NULL;
	}
}


HRESULT ZONECALL CStringTable::Init(int iInitialTableSize, int iNextAlloc, int iMaxAllocSize, WORD NumBuckets, WORD NumLocks)
{

	m_pHash = new CMTHash<StringKey,TCHAR*>( CStringTable::HashString, CStringTable::HashCompare, NULL, NumBuckets, NumLocks);
	if ( !m_pHash )
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


DWORD ZONECALL CStringTable::HashString( TCHAR* pKey )
{
	return ::HashString( pKey);
}


bool ZONECALL CStringTable::HashCompare( StringKey* pValue,TCHAR *pKey )
{
    return (lstrcmpi(pKey,pValue->m_szString)==0);
}


//
// Add a string into the table or return the id of the string is it is
// already in the table.
//
DWORD ZONECALL CStringTable::Add( CONST TCHAR* szStr )
{
	CAutoLock lock( &m_lock );

	// Is string already in table?
	int id = Find(szStr);
	if ( id != -1 )
		return id;

	// Add string to table
	id = AddStringToTable(szStr);
	if ( id == -1 )
		return -1;
	
	return id;
}


//
// Get a string's text from it's id
//
HRESULT ZONECALL CStringTable::Get( DWORD id, TCHAR* szBuffer, PDWORD pdwSize )
{
	// validate arguments
    TCHAR *psz = (TCHAR*) id;
    
	CAutoLock lock( &m_lock );

	StringKey * pkey = m_pHash->Get(psz);

	if (!pkey)
	{
	    return E_FAIL;
	}

	// if a size was passed in then make sure that the callers
	// buffer is large enought to contain the return string.
	if ( !szBuffer || (*pdwSize < pkey->m_dwLenStr) )
	{
		*pdwSize = pkey->m_dwLenStr;
		return ZERR_BUFFERTOOSMALL;
	}

	*pdwSize = pkey->m_dwLenStr;
	lstrcpy(szBuffer, pkey->m_szString);
	
	return S_OK;
}

//
// Find's a string in the table and return's its id if it exists.
//
DWORD ZONECALL CStringTable::Find( CONST TCHAR* szStr)
{
	CAutoLock lock( &m_lock );

	StringKey *pkey;
	
	pkey = m_pHash->Get( (TCHAR*)szStr );
	if ( pkey)
		return (DWORD) pkey->m_szString;

	return -1;
}


//
// Write access is serialized at the Add and Get functions though the locking mechanism.
//
int ZONECALL CStringTable::AddStringToTable(CONST TCHAR *szStr)
{
	StringKey*pkey;
    DWORD dwStrLen;
    
	pkey = new StringKey;
	if (!pkey)
	{
	    return -1;
	}
	dwStrLen= lstrlen(szStr);
	pkey->m_szString = new TCHAR[dwStrLen+1];

	if (!pkey->m_szString )
	{
	    delete pkey;
	    return -1;
	}

    lstrcpy(pkey->m_szString ,szStr);
	pkey->m_dwLenStr=dwStrLen + 1;//not necessary but efficient for string compares later
	if (!m_pHash->Add((TCHAR*)szStr,pkey))
	{
	    delete pkey;
	    return -1;
	};
	return (DWORD)pkey->m_szString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\datastore\cdatastore.h ===
#include <datastore.h>
#include <ZoneLocks.h>
#include <Hash.h>


class CStringTable
{
public:
	ZONECALL CStringTable();
	ZONECALL ~CStringTable(void);

	HRESULT	ZONECALL Init(int iInitialTableSize = 256, int iNextAlloc = 32, int iMaxAllocSize = 512, WORD NumBuckets = 16, WORD NumLocks = 4);
	HRESULT	ZONECALL Get( DWORD id, TCHAR *szBuffer, PDWORD pdwSize = NULL );
	DWORD	ZONECALL Add( CONST TCHAR *szStr );
	DWORD	ZONECALL Find( CONST TCHAR *szStr);

private:

	int ZONECALL AddStringToTable( CONST TCHAR *szStr );

	struct StringKey
	{
		DWORD m_dwLenStr;
		TCHAR* m_szString;

		StringKey()
		{
			m_dwLenStr=0;
			m_szString=NULL;
		}

		~StringKey()
		{
			if (m_szString)
			{
				delete [] m_szString;
			}

			m_dwLenStr=0;
            m_szString=NULL;
		}
	};

	static void StringDelete( StringKey * pkey, void* );

	static DWORD ZONECALL HashString( TCHAR* pKey );
	static bool ZONECALL HashCompare( StringKey* value, TCHAR* pKey );

	CMTHash<StringKey, TCHAR*>*	m_pHash;			// Hash class for quick lookups of string data.
	CCriticalSection			m_lock;				// protect from multiple threads
};



///////////////////////////////////////////////////////////////////////////////
// CDataStoreManager
///////////////////////////////////////////////////////////////////////////////

#ifndef PVARTYPE
	typedef VARTYPE *PVARTYPE;
#endif


struct KEY
{
	DWORD		idKeyName;	// id of this key in global CStringTable.
	DWORD		dwSize;		// length of data if variant is a VT_BYREF type.
	LPVARIANT	pvtData;	// data for this key
	KEY*		pNext;		// peer nodes
	KEY*		pChild;		// child nodes
};

typedef KEY* PKEY;


class ATL_NO_VTABLE CDataStoreManager :
	public IDataStoreManager,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDataStoreManager,&CLSID_DataStoreManager>
{
public:
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CDataStoreManager)
		COM_INTERFACE_ENTRY(IDataStoreManager)
	END_COM_MAP()

public:
	CDataStoreManager();
	~CDataStoreManager();

public:
	STDMETHOD(Create)( IDataStore **pZds );

	STDMETHOD(Init)(
		int		iInitialTableSize = 256,
		int		iNextStrAlloc = 32,
		int		iMaxStrAllocSize = 512,
		WORD	NumBuckets = 16,
		WORD	NumLocks = 4,
        IResourceManager *piResourceManager = NULL );

    STDMETHOD(SetResourceManager)(IResourceManager *piResourceManager);

	STDMETHOD_(IResourceManager*, GetResourceManager)() { return m_piResourceManager; }

private:
	CStringTable*		m_pStringTable;		// control handle key string table class
	CPool<KEY>			m_keyAlloc;			// Key node allocator
	CPool<VARIANT>		m_variantAlloc;		// Variant Allocator
	CPool<CDataStore>	m_ZdsPool;			// fixed size memory allocator for an individual

    IResourceManager *m_piResourceManager;
};


///////////////////////////////////////////////////////////////////////////////
// CDataStore
///////////////////////////////////////////////////////////////////////////////

class CDataStore : public IDataStore
{
// CDataStore
public:
	ZONECALL CDataStore();
	ZONECALL ~CDataStore();

// IDataStore
public:

	STDMETHOD(SetKey)(
		CONST TCHAR *szKey,
		LPVARIANT pVariant,
		DWORD dwSize);

	STDMETHOD(SetKey)(
		CONST TCHAR**	arKeys,
		long			nElts,
		LPVARIANT		pVariant,
		DWORD			dwSize);

	STDMETHOD(SetString)(
		CONST TCHAR*	szKey,
		CONST TCHAR*	szValue );

	STDMETHOD(SetString)(
		CONST TCHAR**	arKeys,
		long			nElts,
		CONST TCHAR*	szValue );

	STDMETHOD(SetLong)(
		CONST TCHAR*	szKey,
		long			lValue );

	STDMETHOD(SetLong)(
		CONST TCHAR**	arKeys,
		long			nElts,
		long			lValue );

	STDMETHOD(SetRGB)(
		CONST TCHAR*	szKey,
		COLORREF 		colorRGB );

	STDMETHOD(SetRGB)(
		CONST TCHAR**	arKeys,
		long			nElts,
		COLORREF 		colorRGB );

	STDMETHOD(SetPOINT)(
		CONST TCHAR*	szKey,
		const POINT&	refPoint );

	STDMETHOD(SetPOINT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const POINT&	refPoint );

	STDMETHOD(SetRECT)(
		CONST TCHAR*	szKey,
		const RECT&		refRect );

	STDMETHOD(SetRECT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const RECT&		refRect );
	
	STDMETHOD(SetFONT)(
		CONST TCHAR*	szKey,
		const ZONEFONT&	refRect );

	STDMETHOD(SetFONT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const ZONEFONT&	refRect );
	
	STDMETHOD(SetBlob)(
		CONST TCHAR*	szKey,
		CONST void*		pBlob,
		DWORD			dwLen );

	STDMETHOD(SetBlob)(
		CONST TCHAR**	arKeys,
		long			nElts,
		CONST void*		pBlob,
		DWORD			dwLen );

	STDMETHOD(GetKey)(
		CONST TCHAR *szKey,
		LPVARIANT pVariant,
		PDWORD pdwSize );

	STDMETHOD(GetKey)(
		CONST TCHAR**	arKeys,
		long			nElts,
		LPVARIANT		pVariant,
		PDWORD			pdwSize );

	STDMETHOD(GetString)(
		CONST TCHAR*	szKey,
		TCHAR*			szValue,
		PDWORD			pdwSize );

	STDMETHOD(GetString)(
		CONST TCHAR**	arKeys,
		long			nElts,
		TCHAR*			szValue,
		PDWORD			pdwSize );

	STDMETHOD(GetLong)(
		CONST TCHAR*	szKey,
		long*			plValue );

	STDMETHOD(GetLong)(
		CONST TCHAR**	arKeys,
		long			nElts,
		long*			plValue );

	STDMETHOD(GetRGB)(
		CONST TCHAR*	szKey,
		COLORREF* 		pcolorRGB );

	STDMETHOD(GetRGB)(
		CONST TCHAR**	arKeys,
		long			nElts,
		COLORREF* 		pcolorRGB );

	STDMETHOD(GetPOINT)(
		CONST TCHAR*	szKey,
		POINT*			pPoint );

	STDMETHOD(GetPOINT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		POINT*			pPoint );

	STDMETHOD(GetRECT)(
		CONST TCHAR*	szKey,
		RECT*			pRect );

	STDMETHOD(GetRECT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		RECT*			pRect );
	
	STDMETHOD(GetFONT)(
		CONST TCHAR*	szKey,
		ZONEFONT*		pRect );

	STDMETHOD(GetFONT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		ZONEFONT*		pRect );
	
	STDMETHOD(GetBlob)(
		CONST TCHAR*	szKey,
		void*			pBlob,
		PDWORD			pdwSize );

	STDMETHOD(GetBlob)(
		CONST TCHAR**	arKeys,
		long			nElts,
		void*			pBlob,
		PDWORD			pdwSize );

	STDMETHOD(DeleteKey)(
		CONST TCHAR *szBaseKey);

	STDMETHOD(EnumKeys)(
		CONST TCHAR* szKey,
		PFKEYENUM pfCallback,
		LPVOID pContext );

	STDMETHOD(EnumKeysLimitedDepth)(
		CONST TCHAR*	szKey,
		DWORD			dwMaxDepth,
		PFKEYENUM		pfCallback,
		LPVOID			pContext );

	STDMETHOD(LoadFromBuffer)(
		CONST TCHAR* szBaseKey,
		PKEYINFO pKeyInfo,
		DWORD dwTotalKeys);

	STDMETHOD(SaveToBuffer)(
		CONST TCHAR *szBaseKey,
		PKEYINFO pKeyInfo,
		PDWORD pdwBufferSize,
		PDWORD pdwTotalKeys);

	STDMETHOD(LoadFromRegistry)(
		CONST TCHAR* szBaseKey,
		HKEY hKey);

	STDMETHOD(SaveToRegistry)(
		CONST TCHAR *szBaseKey,
		HKEY hKey);

	STDMETHOD(LoadFromTextBuffer)(
		CONST TCHAR* szBaseKey,
		CONST TCHAR* pBuffer,
		DWORD dwBufferSz );

	STDMETHOD(SaveToTextBuffer)(
		CONST TCHAR* szBaseKey,
		LPVOID pBuffer,
		PDWORD pdwBufferSz );

	STDMETHOD(LoadFromFile)(
		CONST TCHAR *szBaseKey,
		CONST TCHAR *szFileName);

	STDMETHOD(SaveToFile)(
		CONST TCHAR *szBaseKey,
		CONST TCHAR *szFileName);

// IUnknown
public:
	STDMETHOD(QueryInterface)( REFIID iid, void **ppvObject );
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

// internal functions and data
public:
	HRESULT ZONECALL Init( IDataStoreManager *piManager, CStringTable *pStringTable, CPool<VARIANT> *pVariantAlloc, CPool<KEY> *pKeyAlloc);
	static HRESULT ZONECALL StringToVariant( TCHAR* szInput, LPVARIANT pVariant, BYTE* pBuffer, DWORD* pdwSize, IDataStoreManager *piManager = NULL );
	static HRESULT ZONECALL VariantToString( const LPVARIANT pVariant, TCHAR* buff );

private:
	PKEY ZONECALL FindKeyAndParent(CONST TCHAR* szKey, PKEY* ppParent = NULL );
	PKEY ZONECALL FindKeyAndParent(CONST TCHAR** arKeys, int nElts, PKEY* ppParent = NULL );
	PKEY ZONECALL AddKey(CONST TCHAR* szKey);
	PKEY ZONECALL AddKey(CONST TCHAR** arKeys, int nElts);
	void ZONECALL DeleteKey( PKEY pKey, PKEY pParent );
	void ZONECALL DirToArray( CONST TCHAR *szKey, TCHAR* szBuf, TCHAR** arKeys, int* pnElts );

	HRESULT ZONECALL StoreKeyData(PKEY pKey, LPVARIANT pVariant, DWORD dwSize);

	HRESULT ZONECALL InternalEnumKey(
		PKEY			pKey,
		CONST TCHAR*	szRoot,
		CONST TCHAR*	szRelative,
		PFKEYENUM		pfCallback,
		LPVOID			pContext,
		bool			bEnumSelf,
		DWORD			dwDepth );

	static HRESULT ZONECALL CalcSizeCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );
	static HRESULT ZONECALL CopyCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );
	static HRESULT ZONECALL FileCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );
	static HRESULT ZONECALL BufferCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );
	static HRESULT ZONECALL RegistryCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );

	KEY					m_Root;				// root node
	CStringTable*		m_pStringTable;		// Pointer to COM objects String table
	CPool<VARIANT>*		m_pVariantAlloc;	// Pointer to COM objects Variant Allocator
	CPool<KEY>*			m_pKeyAlloc;		// Key node allocator
	CRITICAL_SECTION	m_csKey;			// Critical section for pretecting write operations to the key tree.
	LONG				m_cRef;				// Reference count for this data store

    IDataStoreManager*  m_piManager;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\eventqueue\ceventqueue.h ===
#include "EventQueue.h"

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ZoneLocks.h"
#include "Queue.h"
#include "Hash.h"


#define EVENTQUEUE_CACHE	5


class ATL_NO_VTABLE CEventQueue :
	public IEventQueue,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEventQueue, &CLSID_EventQueue>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CEventQueue)
		COM_INTERFACE_ENTRY(IEventQueue)
	END_COM_MAP()


// CEventQueue
public:
	ZONECALL CEventQueue();
	ZONECALL ~CEventQueue();


// IEventQueue
public:
	STDMETHOD(RegisterClient)(
		IEventClient*	pIEventClient,
		void*			pCookie );

	STDMETHOD(UnregisterClient)(
		IEventClient*	pIEventClient,
		void*			pCookie );

	STDMETHOD(RegisterOwner)(
		DWORD			dwEventId,
		IEventClient*	pIEventClient,
		void*			pCookie );

	STDMETHOD(UnregisterOwner)(
		DWORD			dwEventId,
		IEventClient*	pIEventClient,
		void*			pCookie );

	STDMETHOD(PostEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2 );

	STDMETHOD(PostEventWithBuffer)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		void*	pData,
		DWORD	dwDataLen );

	STDMETHOD(PostEventWithIUnknown)(
		DWORD		dwPriority,
		DWORD		dwEventId,
		DWORD		dwGroupId,
		DWORD		dwUserId,
		IUnknown*	pIUnknown,
		DWORD		dwData2 );

	STDMETHOD(SetNotificationHandle)( HANDLE hEvent );

	STDMETHOD(SetWindowMessage)( DWORD dwThreadId, DWORD Msg, WPARAM wParam, WPARAM lParam );

	STDMETHOD(DisableWindowMessage)();

	STDMETHOD(ProcessEvents)( bool bSingleEvent );

	STDMETHOD_(long,EventCount)();

	STDMETHOD(ClearQueue)();

	STDMETHOD(EnableQueue)( bool bEnable );

// internal functions and data
protected:

	class Handler
	{
	public:
		ZONECALL Handler( IEventClient* pIEventClient, void* pCookie );
		ZONECALL ~Handler();

		IEventClient*	m_pIEventClient;
		void*			m_pCookie;

		// hash helper functions
		static DWORD ZONECALL Hash( Handler* pKey );
		static bool  ZONECALL Cmp( Handler* pHandler, Handler* pKey);
		static void  ZONECALL Del( Handler* pHandler, void* );

	private:
		Handler() {}
	};

	class Owner
	{
	public:
		ZONECALL Owner(DWORD dwEventId, IEventClient* pIEventClient, void* pCookie );
		ZONECALL ~Owner();

		DWORD			m_dwEventId;
		IEventClient*	m_pIEventClient;
		void*			m_pCookie;

		// hash helper functions
		static DWORD ZONECALL Hash( DWORD dwEventId );
		static bool  ZONECALL Cmp( Owner* pOwner, DWORD dwEventId );
		static void  ZONECALL Del( Owner* pOwnerf, void* );

	private:
		Owner();
	};

	class Event
	{
		enum EventType
		{
			EventUnknown,
			EventDWORD,
			EventBuffer,
			EventIUnknown
		};

	public:
		ZONECALL Event();
		ZONECALL ~Event();

		HRESULT ZONECALL Init( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2 );
		HRESULT ZONECALL InitBuffer( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, void* pData, DWORD dwDataLen, CDataPool& pool );
		HRESULT ZONECALL InitIUnknown( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, IUnknown* pIUnk, DWORD dwData2 );
		void    ZONECALL Free( CDataPool& pool );

		DWORD		m_dwPriority;
		DWORD		m_dwEventId;
		DWORD		m_dwGroupId;
		DWORD		m_dwUserId;
		DWORD		m_dwData1;
		DWORD		m_dwData2;
		EventType	m_enumType;
	};

	class EventWrapper
	{
	public:
		Event* m_pEvent;
		Owner* m_pOwner;
	};

	static bool ZONECALL CallHandler( Handler* pHandler, MTListNodeHandle hNode, void* Cookie );

	HRESULT ZONECALL AddEvent( Event* pEvent );

	CRITICAL_SECTION		m_lockEvents;
	CRITICAL_SECTION		m_lockHandlers;
	CHash<Handler,Handler*>	m_hashHandlers;
	CHash<Owner,DWORD>		m_hashOwners;
	CPool<Event>			m_poolEvents;
	CDataPool				m_poolData;
	CList<Event>			m_listEvents[EVENTQUEUE_CACHE];
	HANDLE					m_hNotification;
	DWORD					m_dwRecursion;

	// post message parameters
	bool	m_bEnabled;
	bool	m_bPostMessage;
	long	m_lCount;
	DWORD	m_dwThreadId;
	DWORD	m_dwMsg;
	WPARAM	m_wParam;
	LPARAM	m_lParam;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\accessibilitymanager.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		AccessibilityManager.h
 *
 * Contents:	Accessibility manager interfaces
 *
 *****************************************************************************/

#ifndef _ACCESSIBILITYMANAGER_H_
#define _ACCESSIBILITYMANAGER_H_

#include "ZoneShell.h"


///////////////////////////////////////////////////////////////////////////////
// AccessibilityManager Object
///////////////////////////////////////////////////////////////////////////////

// {B12D3E5F-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(CLSID_AccessibilityManager, 
0xb12d3e5f, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

class __declspec(uuid("{B12D3E5F-9681-11d3-884D-00C04F8EF45B}")) CAccessibilityManager;


///////////////////////////////////////////////////////////////////////////////
// Accessibility Constants
///////////////////////////////////////////////////////////////////////////////

enum
{
    ZACCESS_Ignore = 0,
    ZACCESS_Select,
    ZACCESS_Activate,
    ZACCESS_Focus,
    ZACCESS_FocusGroup,
    ZACCESS_FocusGroupHere,
    ZACCESS_FocusPositional
};

#define ZACCESS_ArrowNone    (-1)
#define ZACCESS_ArrowDefault (-2)

#define ZACCESS_InvalidCommandID (-1)
#define ZACCESS_AccelCommandID   (-2)

#define ZACCESS_InvalidItem ZACCESS_InvalidCommandID

#define ZACCESS_TopLayer (-1)

// flags for rgfWhat in AlterItem
#define ZACCESS_fEnabled        0x0002
#define ZACCESS_fVisible        0x0004
#define ZACCESS_eAccelBehavior  0x0008
#define ZACCESS_nArrowUp        0x0010
#define ZACCESS_nArrowDown      0x0020
#define ZACCESS_nArrowLeft      0x0040
#define ZACCESS_nArrowRight     0x0080
#define ZACCESS_rgfWantKeys     0x0100
#define ZACCESS_nGroupFocus     0x0200
#define ZACCESS_pvCookie        0x0800

#define ZACCESS_AllFields       0xffff
#define ZACCESS_AllArrows       0x00f0

// flags for rgfWantKeys
#define ZACCESS_WantSpace       0x0001
#define ZACCESS_WantEnter       0x0002
#define ZACCESS_WantEsc         0x0004
#define ZACCESS_WantArrowUp     0x0010
#define ZACCESS_WantArrowDown   0x0020
#define ZACCESS_WantArrowLeft   0x0040
#define ZACCESS_WantArrowRight  0x0080

#define ZACCESS_WantPlainTab    0x0100
#define ZACCESS_WantShiftTab    0x0200
#define ZACCESS_WantTab         0x0300

#define ZACCESS_WantVArrows     0x0030
#define ZACCESS_WantHArrows     0x00c0
#define ZACCESS_WantAllArrows   0x00f0

#define ZACCESS_WantAllKeys     0xffff

// flags for callback responses
#define ZACCESS_Reject          0x01
#define ZACCESS_BeginDrag       0x02
#define ZACCESS_NoGroupFocus    0x04

// flags for rgfContext
#define ZACCESS_ContextKeyboard 0x01
#define ZACCESS_ContextCommand  0x02

#define ZACCESS_ContextTabForward  0x10
#define ZACCESS_ContextTabBackward 0x20


///////////////////////////////////////////////////////////////////////////////
// ACCITEM structure
///////////////////////////////////////////////////////////////////////////////

// shouldn't really be instantiated
struct __accbase
{
    // Application-global command ID.
    // Cannot even conflict with Menu Items!!  (Unless that's the desired effect.)
    // Set to ZACCESS_InvalidCommandID if you don't care.  Such items cannot have
    // accelerators.
    //
    // Set to ZACCESS_AccelCommandID to use the ID from the oAccel accelerator structure.  (This works
    // even if a seperate HACCEL accelerator table is supplied.)
    //
    // If any two items share a valid wID (even within a group), the results are undefined.
    //
    // Only the lower 16 bits are used (except for ZACCESS_...)
    long wID;

    // Used to mark the first item in a group.  All items following this one
    // are counted in the group until the next Tabstop item.
    // More like the Group style in dialogs than the Tabstop style
    bool fTabstop;

    // Items that are not enabled cannot be selected by any means.
    // The only exception is if the item has a FocusGroup, FocusGroupHere, or FocusPositional accelerator behavior, in which
    // case the accelerator still works.
    bool fEnabled;

    // Items that are not visible cannot get the focus but can be selected via acceleration.
    bool fVisible;

    // Sets what happens when the accelerator for the item is pressed:
    // ZACCESS_Ignore - the accessibility manager should not handle the command
    // ZACCESS_Select - the item is selected if enabled
    // ZACCESS_Activate - the item is activated if enabled
    // ZACCESS_Focus - the item gets the focus if enabled and visible
    // ZACCESS_FocusGroup - if set on a group's fTabstop, focus goes to the group just like it was tabbed to.  otherwise this acts like FocusGroupHere
    // ZACCESS_FocusGroupHere - sets the focus to the first available item in the group starting with this item.  can be set on any item in a group.
    // ZACCESS_FocusPositional - the next item at all (even in a different component) which is visible and enabled gets the focus
    DWORD eAccelBehavior;

    // These are used to override standard arrow behavior within a group.
    // They should be set to the index of the item that the
    // corresponding arrow should move to.  If that item is not visible
    // or not enabled, the graph is walked until a valid item is found,
    // or a dead-end or loop is encountered, in which cases the focus is
    // not moved.
    //
    // Basically, these are not really related to groups at all, besides their defaults.
    // Items in singleton groups default to ZACCESS_ArrowNone.  Items in larger groups
    // default to standard group wrapping behavior as in dialogs.  But you can specify any behavior
    // you want, including inter-group movement etc.
    //
    // Set to ZACCESS_ArrowDefault for the default behavior
    // Set to ZACCESS_ArrowNone if that item cannot be arrowed off of in that direction
    long nArrowUp;
    long nArrowDown;
    long nArrowLeft;
    long nArrowRight;

    // When this control has focus, the keys specified in this bit field lose their special
    // accessibility meaning.  For example, most keystrokes are meaningful to an edit control
    // and shouldn't be trapped by accessibility.
    DWORD rgfWantKeys;

    // for fTabstop items only, specifies the item in the group that should be the one to get the
    // focus when the focus returns to the group.  must be an index into the group, or ZACCESS_InvalidItem if
    // you don't care.
    //
    // totally ignored for non fTabstop items so if you use SetItemGroupFocus(), set it on the fTabstop
    // item, not the one you want to have the focus
    long nGroupFocus;

    // Accelerator information for the item.  Ignored if an accelerator table is
    // provided along with the itemlist in PushItemlist.  The 'cmd' value must equal
    // the wID value for the accelerator to be valid.  If it is different (or ZACCESS_InvalidCommandID)
    // the accelerator is ignored.  If it is ZACCESS_AccelCommandID it is assumed to match.
    // If wID is ZACCESS_AccelCommandID, the cmd from this structure is taken as the wID as well.
    // If both are ZACCESS_AccelCommandID, they are both treated as invalid and the accelerator is ignored.
    ACCEL oAccel;

    // Application-defined cookie for the Item.
    void *pvCookie;
};


struct ACCITEM : public __accbase
{
};


// default __accbase structure - may be useful during initialization
// use CopyACC(rgMyItemlist[i], ZACCESS_DefaultACCITEM) for each item, then set up only the fields you want
extern const __declspec(selectany) __accbase ZACCESS_DefaultACCITEM =
{
    ZACCESS_AccelCommandID,
    true,
    true,
    true,
    ZACCESS_Activate,
    ZACCESS_ArrowDefault,
    ZACCESS_ArrowDefault,
    ZACCESS_ArrowDefault,
    ZACCESS_ArrowDefault,
    0,
    ZACCESS_InvalidItem,
    { FALT | FVIRTKEY, 0, ZACCESS_InvalidCommandID },
    NULL
};


// nice hackey thing to let you copy the base parts of derived structures
#define CopyACC(x, y) (*(__accbase *) &(x) = *(__accbase *) &(y))


///////////////////////////////////////////////////////////////////////////////
// IAccessibleControl
///////////////////////////////////////////////////////////////////////////////

// {B12D3E62-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IAccessibleControl, 
0xb12d3e62, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E62-9681-11d3-884D-00C04F8EF45B}"))
IAccessibleControl : public IUnknown
{
    // these routines return a combination of flags indicating the response
    // ZACCESS_Reject = the action should be aborted
    // ZACCESS_BeginDrag = the nIndex item should become the orig for a new drag operation
    // ZACCESS_NoGroupFocus = for Focus(), do not set the item as the new default focus for the group

    // rgfContext contains flags relating to the origin of the event and can be zero or more of:
    // ZACCESS_ContextKeyboard = came from a key like space or enter, including Accelerators
    // ZACCESS_ContextCommand = came from a WM_COMMAND, including Accelerators
    // so yes, both are set if someone presses the accelerator.  none are set if the call is the
    // result of for example SetFocus()

    // nIndex or nIndexPrev can be ZACCESS_InvalidItem if there is no new / prev focus item
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie) = 0;

    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie) = 0;

    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie) = 0;

    // nIndex can be ZACCESS_InvalidItem if a drag operation is aborted
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IAccessibility
///////////////////////////////////////////////////////////////////////////////

// {09BAD4A1-980C-11d3-87ED-00AA00446FD9}
DEFINE_GUID(IID_IAccessibility, 
0x9bad4a1, 0x980c, 0x11d3, 0x87, 0xed, 0x0, 0xaa, 0x0, 0x44, 0x6f, 0xd9);

interface __declspec(uuid("{09BAD4A1-980C-11d3-87ED-00AA00446FD9}"))
IAccessibility : public IUnknown
{
    // the ordinal is the application-wide ordering.  it can be parameterized in object.txt or something.
    // if two controls use the same ordinal, the ordering for those is undefined
    STDMETHOD(InitAcc)(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie = NULL) = 0;
    STDMETHOD_(void, CloseAcc)() = 0;

    // PushItemlist()
    //
    // This takes an array of items and makes it the active Itemlist.  If an
    // HACCEL accelerator table is provided, then it is used verbatim, and all
    // of the accelerators listed in the Itemlist are ignored.  Otherwise, an
    // accelerator table is constructed from the Itemlist.
    STDMETHOD(PushItemlist)(ACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL) = 0;
    STDMETHOD(PopItemlist)() = 0;
    STDMETHOD(SetAcceleratorTable)(HACCEL hAccel = NULL, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(GeneralDisable)() = 0;
    STDMETHOD(GeneralEnable)() = 0;
    STDMETHOD_(bool, IsGenerallyEnabled)() = 0;

    STDMETHOD_(long, GetStackSize)() = 0;

    STDMETHOD(AlterItem)(DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetFocus)(long nItem = ZACCESS_InvalidItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(CancelDrag)(long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(long, GetFocus)(long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetDragOrig)(long nLayer = ZACCESS_TopLayer) = 0;  // can be used to determine if a drag is in progress - returns ZACCEL_InvalidItem

    STDMETHOD(GetItemlist)(ACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(HACCEL, GetAcceleratorTable)(long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(long, GetItemCount)(long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItem)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(GetItem)(ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemIndex)(WORD wID, long nLayer = ZACCESS_TopLayer) = 0;

    // these allow a control to get a cookie describing the app-wide focus, which the focus can later be set back to, even in another control
    STDMETHOD(GetGlobalFocus)(DWORD *pdwFocusID) = 0;
    STDMETHOD(SetGlobalFocus)(DWORD dwFocusID) = 0;


    // Lite Util Functions
    // Implemented in CAccessibilityImpl since they can be derived from the actual interfaces above.
    STDMETHOD_(bool, IsItemFocused)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItemDragOrig)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(long, GetItemID)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItemTabstop)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItemEnabled)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItemVisible)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(DWORD, GetItemAccelBehavior)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemArrowUp)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemArrowDown)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemArrowLeft)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemArrowRight)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(DWORD, GetItemWantKeys)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetItemGroupFocus)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(void *, GetItemCookie)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(SetItemEnabled)(bool fEnabled, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemVisible)(bool fVisible, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemAccelBehavior)(DWORD eAccelBehavior, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemArrows)(long nArrowUp, long nArrowDown, long nArrowLeft, long nArrowRight, DWORD rgfWhat, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemWantKeys)(DWORD rgfWantKeys, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemGroupFocus)(long nGroupFocus, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemCookie)(void *pvCookie, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// CAccessibilityImpl
///////////////////////////////////////////////////////////////////////////////

// Templates for the simple accessor functions

#define DECLARE_ACC_IS_FUNC(name, test)                                                             \
    STDMETHOD_(bool, name)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)     \
    {                                                                                               \
        if(!fByPosition && nItem != ZACCESS_InvalidCommandID)                                       \
        {                                                                                           \
            nItem = GetItemIndex((WORD) (nItem & 0xffffL), nLayer);                                 \
            if(nItem == ZACCESS_InvalidItem)                                                        \
                return false;                                                                       \
        }                                                                                           \
                                                                                                    \
        return test(nLayer) == nItem;                                                               \
    }


#define DECLARE_ACC_ACCESS_FUNC(type, name, field, error)                                           \
    STDMETHOD_(type, name)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)     \
    {                                                                                               \
        ACCITEM o;                                                                                  \
        HRESULT hr = GetItem(&o, nItem, fByPosition, nLayer);                                       \
        if(FAILED(hr))                                                                              \
            return error;                                                                           \
                                                                                                    \
        return o.field;                                                                             \
    }

#define DECLARE_ACC_SET_FUNC(name, type, field)                                                     \
    STDMETHOD(name)(type v, long nItem,  bool fByPosition = true, long nLayer = ZACCESS_TopLayer)   \
    {                                                                                               \
        ACCITEM o;                                                                                  \
        o.field = v;                                                                                \
        return AlterItem( ZACCESS_##field , &o, nItem, fByPosition, nLayer);                        \
    }

template <class T>
class ATL_NO_VTABLE CAccessibilityImpl : public IAccessibility
{
    DECLARE_ACC_IS_FUNC(IsItemFocused, GetFocus)
    DECLARE_ACC_IS_FUNC(IsItemDragOrig, GetDragOrig)

    DECLARE_ACC_ACCESS_FUNC(long, GetItemID, wID, ZACCESS_InvalidCommandID)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemTabstop, fTabstop, false)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemEnabled, fEnabled, false)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemVisible, fVisible, false)
    DECLARE_ACC_ACCESS_FUNC(DWORD, GetItemAccelBehavior, eAccelBehavior, 0xffffffff)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowUp, nArrowUp, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowDown, nArrowDown, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowLeft, nArrowLeft, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowRight, nArrowRight, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(DWORD, GetItemWantKeys, rgfWantKeys, 0xffffffff)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemGroupFocus, nGroupFocus, ZACCESS_InvalidItem)
    DECLARE_ACC_ACCESS_FUNC(void *, GetItemCookie, pvCookie, NULL)

    DECLARE_ACC_SET_FUNC(SetItemEnabled, bool, fEnabled)
    DECLARE_ACC_SET_FUNC(SetItemVisible, bool, fVisible)
    DECLARE_ACC_SET_FUNC(SetItemAccelBehavior, DWORD, eAccelBehavior)
    DECLARE_ACC_SET_FUNC(SetItemWantKeys, DWORD, rgfWantKeys)
    DECLARE_ACC_SET_FUNC(SetItemGroupFocus, long, nGroupFocus)
    DECLARE_ACC_SET_FUNC(SetItemCookie, void*, pvCookie)

    STDMETHOD(SetItemArrows)(long nArrowUp, long nArrowDown, long nArrowLeft, long nArrowRight, DWORD rgfWhat, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        ACCITEM o;
        o.nArrowUp = nArrowUp;
        o.nArrowDown = nArrowDown;
        o.nArrowLeft = nArrowLeft;
        o.nArrowRight = nArrowRight;
        return AlterItem(rgfWhat & ZACCESS_AllArrows, &o, nItem, fByPosition, nLayer);
    }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\graphicalacc\cgraphicalacc.h ===
//
// CGraphicalAcc.h
//
// Internal header for graphical accessibility
//

#ifndef _CGRAPHICALACC_H_
#define _CGRAPHICALACC_H_

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ClientImpl.h"
#include "GraphicalAcc.h"
#include "containers.h"

class ATL_NO_VTABLE CGraphicalAccessibility :
    public CGraphicalAccessibilityImpl<CGraphicalAccessibility>,
    public IAccessibleControl,
	public IZoneShellClientImpl<CGraphicalAccessibility>,
	public IEventClientImpl<CGraphicalAccessibility>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGraphicalAccessibility, &CLSID_GraphicalAccessibility>,
    public CUniqueness<CGraphicalAccessibility>
{
public:
    CGraphicalAccessibility() : m_pStack(NULL), m_cLayers(0), m_fUpdateScheduled(false), m_fFocusActive(false), m_hWnd(NULL) { }
    ~CGraphicalAccessibility()
    {
        SetupCaret(NULL);
        DestroyStack();
    }

	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CGraphicalAccessibility)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneShellClient)
        COM_INTERFACE_ENTRY(IGraphicalAccessibility)
        COM_INTERFACE_ENTRY(IAccessibleControl)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
        EVENT_HANDLER(EVENT_GRAPHICALACC_UPDATE, OnUpdate);
        EVENT_HANDLER(EVENT_INPUT_MOUSE_ALERT, OnMouseEvent);
        EVENT_HANDLER(EVENT_UI_SHOWFOCUS, OnShowFocus);
	END_EVENT_MAP()

	void OnUpdate(DWORD eventId, DWORD groupId, DWORD userId);
	void OnMouseEvent(DWORD eventId, DWORD groupId, DWORD userId);
	void OnShowFocus(DWORD eventId, DWORD groupId, DWORD userId);

// IZoneShellClient
public:
    STDMETHOD(Init)(IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey);
	STDMETHOD(Close)();

// IAccessibility
public:
    STDMETHOD(InitAcc)(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie = NULL);
    STDMETHOD_(void, CloseAcc)();

    STDMETHOD(PushItemlist)(ACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL);
    STDMETHOD(PopItemlist)();
    STDMETHOD(SetAcceleratorTable)(HACCEL hAccel = NULL, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GeneralDisable)();
    STDMETHOD(GeneralEnable)();
    STDMETHOD_(bool, IsGenerallyEnabled)();

    STDMETHOD_(long, GetStackSize)();

    STDMETHOD(AlterItem)(DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(SetFocus)(long nItem = ZACCESS_InvalidItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(CancelDrag)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetFocus)(long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetDragOrig)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetItemlist)(ACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(HACCEL, GetAcceleratorTable)(long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(long, GetItemCount)(long nLayer = ZACCESS_TopLayer);
    STDMETHOD(GetItem)(ACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetItemIndex)(WORD wID, long nLayer = ZACCESS_TopLayer);

    STDMETHOD_(bool, IsItem)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);

    STDMETHOD(GetGlobalFocus)(DWORD *pdwFocusID);
    STDMETHOD(SetGlobalFocus)(DWORD dwFocusID);


// IGraphicalAccessibility
public:
    // pseudo-overloaded functions with GACCITEM, etc.
    STDMETHOD(InitAccG)(IGraphicallyAccControl *pGAC, HWND hWnd, UINT nOrdinal, void *pvCookie = NULL);

    STDMETHOD(PushItemlistG)(GACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL);
    STDMETHOD(AlterItemG)(DWORD rgfWhat, GACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(GetItemlistG)(GACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer);
    STDMETHOD(GetItemG)(GACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer);

    // additional functions
    STDMETHOD(ForceRectsDisplayed)(bool fDisplay = TRUE);
    STDMETHOD_(long, GetVisibleFocus)(long nLayer = ZACCESS_TopLayer);
    STDMETHOD_(long, GetVisibleDragOrig)(long nLayer = ZACCESS_TopLayer);

// IAccessibleControl
public:
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie);
    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie);

protected:

// local structures - mirror those of AccessibilityManager
    struct GA_ITEM : public CUniqueness<GA_ITEM>
    {
        bool fGraphical;
        RECT rc;
    };

    struct GA_LAYER
    {
        GA_LAYER() : rgItems(NULL), cItems(0), pPrev(NULL) { }
        ~GA_LAYER()
        {
            if(rgItems)
                delete[] rgItems;
            rgItems = NULL;
        }

        GA_ITEM *rgItems;
        long cItems;

        GA_LAYER *pPrev;
    };

    struct GA_RECT
    {
        GA_RECT() : fShowing(false) { }

        RECT rc;
        bool fShowing;
        long nIndex;
        DWORD qItem;
    };

    struct GA_CARET
    {
        GA_CARET() : fCreated(false), fActive(false), pfnPrevFunc(NULL), hWnd(NULL) { }
        ~GA_CARET()
        {
            ASSERT(!pfnPrevFunc);  // make sure everyone shut down
        }

        bool fActive;
        bool fCreated;
        RECT rc;
        HWND hWnd;
        WNDPROC pfnPrevFunc;
    };

// local state
    // the accessibility unit we're wrapping
    CComPtr<IAccessibility> m_pIA;

    bool m_fGraphical;   // set when we're running in opaque mode
    CComPtr<IGraphicallyAccControl> m_pIGAC;
    void *m_pvCookie;
    HWND m_hWnd;

    bool m_fUpdateScheduled;
    bool m_fFocusActive;

    GA_RECT m_rcFocus;
    GA_RECT m_rcDragOrig;

    // like AM_CONTROL
    GA_LAYER *m_pStack;
    long m_cLayers;

// local utilities
    HRESULT PushItemlistHelper(GA_ITEM *pGItems, ACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel);
    void DestroyStack();
    GA_LAYER* FindLayer(long nLayer);
    void SetupCaret(LPRECT prc);
    void ScheduleUpdate();
    void DoUpdate();
    bool IsValid(long nIndex);

// global caret state
    static GA_CARET sm_oCaret;

// global utility
    static LRESULT CALLBACK CaretWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};


#endif // _CGRAPHICALACC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\graphicalacc\cgraphicalacc.cpp ===
#include <ZoneResource.h>
#include <BasicATL.h>
#include <ATLFrame.h>
#include "CGraphicalAcc.h"
#include "ZoneShell.h"


CGraphicalAccessibility::GA_CARET CGraphicalAccessibility::sm_oCaret;


///////////////////////////////////////////////////////////////////////////////
// IZoneShell
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGraphicalAccessibility::Init(IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey)
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CGraphicalAccessibility>::Init(pIZoneShell, dwGroupId, szKey);
	if(FAILED(hr))
		return hr;

    // get an accessibility object and wrap it
	hr = ZoneShell()->QueryService(SRVID_AccessibilityManager, IID_IAccessibility, (void**) &m_pIA);
	if(FAILED(hr))
		return hr;

	return S_OK;
}


STDMETHODIMP CGraphicalAccessibility::Close()
{
    CloseAcc();  // guarantee this is done, after this func it can't be called again
    m_pIA.Release();
    SetupCaret(NULL);
	return IZoneShellClientImpl<CGraphicalAccessibility>::Close();
}


///////////////////////////////////////////////////////////////////////////////
// IGraphicalAccessibility
///////////////////////////////////////////////////////////////////////////////

// NON-graphical version
STDMETHODIMP CGraphicalAccessibility::InitAcc(IAccessibleControl *pAC, UINT nOrdinal, void *pvCookie)
{
    if(!m_fRunning)
        return E_FAIL;

    // sending the actual IAccessibleControl makes us see-through
    HRESULT hr = m_pIA->InitAcc(pAC, nOrdinal, pvCookie);
    if(FAILED(hr))
        return hr;

    DestroyStack();
    return S_OK;
}

// GRAPHICAL version
STDMETHODIMP CGraphicalAccessibility::InitAccG(IGraphicallyAccControl *pGAC, HWND hWnd, UINT nOrdinal, void *pvCookie)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!pGAC)
        return E_INVALIDARG;

    // send us as the accessible control, then we're opaque
    HRESULT hr = m_pIA->InitAcc(this, nOrdinal, pvCookie);
    if(FAILED(hr))
        return hr;

    m_fGraphical = true;
    m_fFocusActive = false;
    m_pIGAC = pGAC;
    m_pvCookie = pvCookie;
    ASSERT(!m_hWnd);
    m_hWnd = hWnd;
    DestroyStack();
    return S_OK;
}


STDMETHODIMP_(void) CGraphicalAccessibility::CloseAcc()
{
    if(!m_fRunning)
        return;

    if(m_fGraphical)
    {
        m_pIGAC.Release();
        m_fGraphical = false;
    }

    m_pIA->CloseAcc();
    SetupCaret(NULL);
    DestroyStack();
    RefreshQ();
    m_fUpdateScheduled = false;
    m_fFocusActive = false;
    m_hWnd = NULL;
    m_rcFocus.fShowing = false;
    m_rcDragOrig.fShowing = false;
}


// NON-graphical version
STDMETHODIMP CGraphicalAccessibility::PushItemlist(ACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return m_pIA->PushItemlist(pItems, cItems, nFirstFocus, fByPosition, hAccel);

    // make up a default GA_ITEM list
    GA_ITEM *rgGItems;
    if(!cItems)
        rgGItems = NULL;
    else
    {
        rgGItems = new GA_ITEM[cItems];
        if(!rgGItems)
            return E_OUTOFMEMORY;

        long i;
        for(i = 0; i < cItems; i++)
        {
            rgGItems[i].fGraphical = false;
            rgGItems[i].rc = CRect(0, 0, 0, 0);
        }
    }

    HRESULT hr = PushItemlistHelper(rgGItems, pItems, cItems, nFirstFocus, fByPosition, hAccel);
    if(FAILED(hr))
        delete[] rgGItems;
    else
        ScheduleUpdate();

    return hr;
}

// GRAPHICAL version
STDMETHODIMP CGraphicalAccessibility::PushItemlistG(GACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return E_FAIL;

    // seperate out the graphical bits & make also a regular array
    GA_ITEM *rgGItems;
    ACCITEM *rgItems;
    if(!cItems)
    {
        rgGItems = NULL;
        rgItems = NULL;
    }
    else
    {
        rgGItems = new GA_ITEM[cItems];
        if(!rgGItems)
            return E_OUTOFMEMORY;

        rgItems = new ACCITEM[cItems];
        if(!rgItems)
        {
            delete[] rgGItems;
            return E_OUTOFMEMORY;
        }

        long i;
        for(i = 0; i < cItems; i++)
        {
            rgGItems[i].fGraphical = pItems[i].fGraphical;
            rgGItems[i].rc = pItems[i].rc;
            CopyACC(rgItems[i], pItems[i]);
        }
    }

    HRESULT hr = PushItemlistHelper(rgGItems, rgItems, cItems, nFirstFocus, fByPosition, hAccel);
    delete[] rgItems;
    if(FAILED(hr))
        delete[] rgGItems;
    else
        ScheduleUpdate();

    return hr;
}


STDMETHODIMP CGraphicalAccessibility::PopItemlist()
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return m_pIA->PopItemlist();

    if(!m_cLayers)
    {
        ASSERT(!m_pStack);
        return m_pIA->PopItemlist();
    }

    GA_LAYER *p = m_pStack;
    m_pStack = m_pStack->pPrev;
    delete p;
    m_cLayers--;

    HRESULT hr = m_pIA->PopItemlist();
    if(SUCCEEDED(hr))
        ScheduleUpdate();

    return hr;
}


STDMETHODIMP CGraphicalAccessibility::SetAcceleratorTable(HACCEL hAccel, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->SetAcceleratorTable(hAccel, nLayer);
}


STDMETHODIMP CGraphicalAccessibility::GeneralDisable()
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->GeneralDisable();
}


STDMETHODIMP CGraphicalAccessibility::GeneralEnable()
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->GeneralEnable();
}


STDMETHODIMP_(bool) CGraphicalAccessibility::IsGenerallyEnabled()
{
    if(!m_fRunning)
        return false;

    return m_pIA->IsGenerallyEnabled();
}


STDMETHODIMP_(long) CGraphicalAccessibility::GetStackSize()
{
    if(!m_fRunning)
        return -1;

    return m_pIA->GetStackSize();
}


// NON-graphical version
STDMETHODIMP CGraphicalAccessibility::AlterItem(DWORD rgfWhat, ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->AlterItem(rgfWhat, pItem, nItem, fByPosition, nLayer);
}

// GRAPHICAL version
STDMETHODIMP CGraphicalAccessibility::AlterItemG(DWORD rgfWhat, GACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return E_FAIL;

    if(!pItem)
        return E_INVALIDARG;

    GA_LAYER *pLayer = FindLayer(nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    ACCITEM oItem;
    CopyACC(oItem, *pItem);

    HRESULT hr = m_pIA->AlterItem(rgfWhat, &oItem, nItem, fByPosition, nLayer);
    if(FAILED(hr))
        return hr;

    if(!fByPosition && nItem != ZACCESS_InvalidCommandID)
        nItem = m_pIA->GetItemIndex((WORD) (nItem & 0xffffL), nLayer);

    ASSERT(nItem >= 0 && nItem < pLayer->cItems);

    if((rgfWhat & ZACCESS_fGraphical) && pLayer->rgItems[nItem].fGraphical != pItem->fGraphical)
    {
        pLayer->rgItems[nItem].fGraphical = pItem->fGraphical;

        if(pLayer == m_pStack && (nItem == m_pIA->GetFocus(nLayer) || nItem == m_pIA->GetDragOrig(nLayer)))
            ScheduleUpdate();
    }

    if((rgfWhat & ZACCESS_rc) && CRect(pLayer->rgItems[nItem].rc) != CRect(pItem->rc))
    {
        pLayer->rgItems[nItem].rc = pItem->rc;

        if(pLayer == m_pStack && pLayer->rgItems[nItem].fGraphical &&
            (nItem == m_pIA->GetFocus(nLayer) || nItem == m_pIA->GetDragOrig(nLayer)))
            ScheduleUpdate();
    }

    return hr;
}


STDMETHODIMP CGraphicalAccessibility::SetFocus(long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->SetFocus(nItem, fByPosition, nLayer);
}


STDMETHODIMP CGraphicalAccessibility::CancelDrag(long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->CancelDrag(nLayer);
}


STDMETHODIMP_(long) CGraphicalAccessibility::GetFocus(long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    return m_pIA->GetFocus(nLayer);
}


STDMETHODIMP_(long) CGraphicalAccessibility::GetDragOrig(long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    return m_pIA->GetDragOrig(nLayer);
}


// NON-graphical version
STDMETHODIMP CGraphicalAccessibility::GetItemlist(ACCITEM *pItems, long cItems, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->GetItemlist(pItems, cItems, nLayer);
}

// GRAPHICAL version
STDMETHODIMP CGraphicalAccessibility::GetItemlistG(GACCITEM *pItems, long cItems, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return E_FAIL;

    // need to get the items and combine
    if(!cItems)
        return m_pIA->GetItemlist(NULL, 0, nLayer);

    GA_LAYER *pLayer = FindLayer(nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    if(!pItems)
        return E_INVALIDARG;

    ACCITEM *pRegItems = new ACCITEM[cItems];
    if(!pRegItems)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pIA->GetItemlist(pRegItems, cItems, nLayer);
    if(FAILED(hr))
    {
        delete[] pRegItems;
        return hr;
    }

    if(cItems < pLayer->cItems)
        cItems = pLayer->cItems;

    long i;
    for(i = 0; i < cItems; i++)
    {
        CopyACC(pItems[i], pRegItems[i]);
        pItems[i].fGraphical = pLayer->rgItems[i].fGraphical;
        pItems[i].rc = pLayer->rgItems[i].rc;
    }

    delete[] pRegItems;
    return S_OK;
}


STDMETHODIMP_(HACCEL) CGraphicalAccessibility::GetAcceleratorTable(long nLayer)
{
    if(!m_fRunning)
        return NULL;

    return m_pIA->GetAcceleratorTable(nLayer);
}


STDMETHODIMP_(long) CGraphicalAccessibility::GetItemCount(long nLayer)
{
    if(!m_fRunning)
        return -1;

    return m_pIA->GetItemCount(nLayer);
}


// NON-graphical version
STDMETHODIMP CGraphicalAccessibility::GetItem(ACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->GetItem(pItem, nItem, fByPosition, nLayer);
}

// GRAPHICAL version
STDMETHODIMP CGraphicalAccessibility::GetItemG(GACCITEM *pItem, long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fGraphical)
        return E_FAIL;

    GA_LAYER *pLayer = FindLayer(nLayer);
    if(!pLayer)
        return E_INVALIDARG;

    ACCITEM oItem;
    HRESULT hr = m_pIA->GetItem(&oItem, nItem, fByPosition, nLayer);
    if(FAILED(hr))
        return hr;

    if(!fByPosition && nItem != ZACCESS_InvalidCommandID)
        nItem = m_pIA->GetItemIndex((WORD) (nItem & 0xffffL), nLayer);

    ASSERT(nItem >= 0 && nItem < pLayer->cItems);
    CopyACC(*pItem, oItem);
    pItem->fGraphical = pLayer->rgItems[nItem].fGraphical;
    pItem->rc = pLayer->rgItems[nItem].rc;
    return hr;
}


STDMETHODIMP_(long) CGraphicalAccessibility::GetItemIndex(WORD wID, long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    return m_pIA->GetItemIndex(wID, nLayer);
}


STDMETHODIMP_(bool) CGraphicalAccessibility::IsItem(long nItem, bool fByPosition, long nLayer)
{
    if(!m_fRunning)
        return false;

    return m_pIA->IsItem(nItem, fByPosition, nLayer);
}


STDMETHODIMP CGraphicalAccessibility::GetGlobalFocus(DWORD *pdwFocusID)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->GetGlobalFocus(pdwFocusID);
}


STDMETHODIMP CGraphicalAccessibility::SetGlobalFocus(DWORD dwFocusID)
{
    if(!m_fRunning)
        return E_FAIL;

    return m_pIA->SetGlobalFocus(dwFocusID);
}


// GRAPHICAL only
STDMETHODIMP CGraphicalAccessibility::ForceRectsDisplayed(bool fDisplay)
{
    if(!m_fRunning)
        return E_FAIL;

    if(fDisplay == m_fFocusActive)
        return S_FALSE;

    m_fFocusActive = fDisplay;
    ScheduleUpdate();
    return S_OK;
}


// GRAPHICAL only
STDMETHODIMP_(long) CGraphicalAccessibility::GetVisibleFocus(long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    if(!m_fGraphical || !m_fFocusActive)
        return ZACCESS_InvalidItem;

    return m_pIA->GetFocus(nLayer);
}


// GRAPHICAL only
STDMETHODIMP_(long) CGraphicalAccessibility::GetVisibleDragOrig(long nLayer)
{
    if(!m_fRunning)
        return ZACCESS_InvalidItem;

    if(!m_fGraphical || !m_fFocusActive)
        return ZACCESS_InvalidItem;

    return m_pIA->GetDragOrig(nLayer);
}


///////////////////////////////////////////////////////////////////////////////
// IAccessibleControl
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(DWORD) CGraphicalAccessibility::Focus(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
{
    if(!m_fGraphical)
    {
        ASSERT(!"Internal GraphicalAccessibility Error - Focus");
        return 0;
    }

    DWORD ret = m_pIGAC->Focus(nIndex, nIndexPrev, rgfContext, pvCookie);

    bool fOldActive = m_fFocusActive;
    if(rgfContext & ZACCESS_ContextKeyboard)
        m_fFocusActive = true;

    if(!fOldActive && !m_fFocusActive)
        return ret;

    if(fOldActive != m_fFocusActive || !(ret & ZACCESS_Reject) ||
        nIndexPrev != ZACCESS_InvalidItem || ((ret & ZACCESS_BeginDrag) && nIndex != ZACCESS_InvalidItem))
        ScheduleUpdate();

    return ret;
}


STDMETHODIMP_(DWORD) CGraphicalAccessibility::Select(long nIndex, DWORD rgfContext, void *pvCookie)
{
    if(!m_fGraphical)
    {
        ASSERT(!"Internal GraphicalAccessibility Error - Select");
        return 0;
    }

    DWORD ret = m_pIGAC->Select(nIndex, rgfContext, pvCookie);

    bool fOldActive = m_fFocusActive;
    if(rgfContext & ZACCESS_ContextKeyboard)
        m_fFocusActive = true;

    if(!fOldActive && !m_fFocusActive)
        return ret;

    if(fOldActive != m_fFocusActive || ((ret & ZACCESS_BeginDrag) && nIndex != ZACCESS_InvalidItem))
        ScheduleUpdate();

    return ret;
}


STDMETHODIMP_(DWORD) CGraphicalAccessibility::Activate(long nIndex, DWORD rgfContext, void *pvCookie)
{
    if(!m_fGraphical)
    {
        ASSERT(!"Internal GraphicalAccessibility Error - Activate");
        return 0;
    }

    DWORD ret = m_pIGAC->Activate(nIndex, rgfContext, pvCookie);

    bool fOldActive = m_fFocusActive;
    if(rgfContext & ZACCESS_ContextKeyboard)
        m_fFocusActive = true;

    if(!fOldActive && !m_fFocusActive)
        return ret;

    if(fOldActive != m_fFocusActive || ((ret & ZACCESS_BeginDrag) && nIndex != ZACCESS_InvalidItem))
        ScheduleUpdate();

    return ret;
}


STDMETHODIMP_(DWORD) CGraphicalAccessibility::Drag(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
{
    if(!m_fGraphical)
    {
        ASSERT(!"Internal GraphicalAccessibility Error - Drag");
        return 0;
    }

    DWORD ret = m_pIGAC->Drag(nIndex, nIndexOrig, rgfContext, pvCookie);

    bool fOldActive = m_fFocusActive;
    if(rgfContext & ZACCESS_ContextKeyboard)
        m_fFocusActive = true;

    if(!fOldActive && !m_fFocusActive)
        return ret;

    ScheduleUpdate();

    return ret;
}


///////////////////////////////////////////////////////////////////////////////
// Event Handlers
///////////////////////////////////////////////////////////////////////////////

void CGraphicalAccessibility::OnUpdate(DWORD eventId, DWORD groupId, DWORD userId)
{
    if(!IsQ(userId))
        return;

    ASSERT(m_fUpdateScheduled);
    m_fUpdateScheduled = false;

    DoUpdate();
}


void CGraphicalAccessibility::OnMouseEvent(DWORD eventId, DWORD groupId, DWORD userId)
{
    CancelDrag();

    if(m_fFocusActive)
    {
        m_fFocusActive = false;

        if(!m_fUpdateScheduled)
            DoUpdate();
    }
}


void CGraphicalAccessibility::OnShowFocus(DWORD eventId, DWORD groupId, DWORD userId)
{
    if(!m_fFocusActive)
    {
        m_fFocusActive = true;

        if(!m_fUpdateScheduled)
            DoUpdate();
    }
}


///////////////////////////////////////////////////////////////////////////////
// UTILITIES
///////////////////////////////////////////////////////////////////////////////

HRESULT CGraphicalAccessibility::PushItemlistHelper(GA_ITEM *pGItems, ACCITEM *pItems, long cItems, long nFirstFocus, bool fByPosition, HACCEL hAccel)
{
    GA_LAYER *pLayer = new GA_LAYER;
    if(!pLayer)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pIA->PushItemlist(pItems, cItems, nFirstFocus, fByPosition, hAccel);
    if(FAILED(hr))
        return hr;

    pLayer->cItems = cItems;
    pLayer->rgItems = pGItems;
    pLayer->pPrev = m_pStack;
    m_pStack = pLayer;
    m_cLayers++;
    return hr;
}


void CGraphicalAccessibility::DestroyStack()
{
    GA_LAYER *pCur, *p;
    for(pCur = m_pStack; pCur; )
    {
        p = pCur;
        pCur = pCur->pPrev;
        delete p;
        m_cLayers--;
    }
    m_pStack = NULL;
    ASSERT(!m_cLayers);
}


CGraphicalAccessibility::GA_LAYER* CGraphicalAccessibility::FindLayer(long nLayer)
{
    if(nLayer == ZACCESS_TopLayer)
        return m_pStack;

    if(nLayer < 0 || nLayer >= m_cLayers)
        return NULL;

    long i;
    GA_LAYER *p = m_pStack;
    for(i = m_cLayers - 1; i != nLayer; i--)
        p = p->pPrev;
    return p;
}


void CGraphicalAccessibility::SetupCaret(LPRECT prc)
{
    // if just moving around within a window, go easy
    if(sm_oCaret.fActive && prc && m_hWnd == sm_oCaret.hWnd)
    {
        ASSERT(m_hWnd);

        // see if size change needed
        if(CRect(sm_oCaret.rc).Width() != CRect(prc).Width() ||
            CRect(sm_oCaret.rc).Height() != CRect(prc).Height())
        {
            DestroyCaret();
            CreateCaret(m_hWnd, NULL, CRect(prc).Width(), CRect(prc).Height());
        }

        CopyRect(&sm_oCaret.rc, prc);
        if(sm_oCaret.fCreated)
            SetCaretPos(prc->left, prc->top);
        return;
    }

    // if it's not being set to me, and i don't have it anyway, just go
    if(!prc && (!m_hWnd || m_hWnd != sm_oCaret.hWnd))
        return;

    if(sm_oCaret.fCreated)
    {
        DestroyCaret();
        sm_oCaret.fCreated = false;
    }

    if(sm_oCaret.fActive)
    {
        ASSERT(sm_oCaret.hWnd);
        ASSERT(sm_oCaret.pfnPrevFunc);
        SetWindowLong(sm_oCaret.hWnd, GWL_WNDPROC, (LONG) sm_oCaret.pfnPrevFunc);
        sm_oCaret.pfnPrevFunc = NULL;
        sm_oCaret.hWnd = NULL;
        sm_oCaret.fActive = false;
    }

    if(!m_hWnd || !prc)
        return;

    sm_oCaret.pfnPrevFunc = (WNDPROC) SetWindowLong(m_hWnd, GWL_WNDPROC, (LONG) CaretWndProc);
    if(!sm_oCaret.pfnPrevFunc)
        return;

    sm_oCaret.fActive = true;
    CopyRect(&sm_oCaret.rc, prc);
    sm_oCaret.hWnd = m_hWnd;

    if(::GetFocus() == m_hWnd)
    {
        CreateCaret(m_hWnd, NULL, CRect(sm_oCaret.rc).Width(), CRect(sm_oCaret.rc).Height());
        SetCaretPos(sm_oCaret.rc.left, sm_oCaret.rc.top);
        sm_oCaret.fCreated = true;
    }
}


LRESULT CALLBACK CGraphicalAccessibility::CaretWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(sm_oCaret.hWnd == hWnd);
    ASSERT(sm_oCaret.fActive);

    if((uMsg == WM_KILLFOCUS || uMsg == WM_DESTROY) && sm_oCaret.fCreated)
    {
        DestroyCaret();
        sm_oCaret.fCreated = false;
    }

    if(uMsg == WM_SETFOCUS && !sm_oCaret.fCreated)
    {
        CreateCaret(hWnd, NULL, CRect(sm_oCaret.rc).Width(), CRect(sm_oCaret.rc).Height());
        SetCaretPos(sm_oCaret.rc.left, sm_oCaret.rc.top);
        sm_oCaret.fCreated = true;
    }

    return CallWindowProc((FARPROC) sm_oCaret.pfnPrevFunc, hWnd, uMsg, wParam, lParam);
}


void CGraphicalAccessibility::ScheduleUpdate()
{
    if(m_fUpdateScheduled)
        return;

    m_fUpdateScheduled = true;
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_GRAPHICALACC_UPDATE, ZONE_NOGROUP, GetQ(), 0, 0);
}


void CGraphicalAccessibility::DoUpdate()
{
    if(!m_pIA || !m_fGraphical)
        return;

    // find focus or drag item
    long i;
    for(i = 0; i < 2; i++)
    {
        long nFocus;
        CRect rcFocus;
        DWORD qFocus;
        GA_RECT *pRect = (i ? &m_rcFocus : &m_rcDragOrig);

        nFocus = (i ? m_pIA->GetFocus() : m_pIA->GetDragOrig());

        if(nFocus != ZACCESS_InvalidItem)
        {
            ASSERT(IsValid(nFocus));

            if(!m_pStack->rgItems[nFocus].fGraphical)
                nFocus = ZACCESS_InvalidItem;
            else
            {
                rcFocus = m_pStack->rgItems[nFocus].rc;
                qFocus = m_pStack->rgItems[nFocus].GetQ();
            }
        }

        // for the focus, handle the caret
        if(i)
            SetupCaret((nFocus == ZACCESS_InvalidItem) ? NULL : &rcFocus);

        if(!m_fFocusActive)
            nFocus = ZACCESS_InvalidItem;

        if(nFocus == ZACCESS_InvalidItem)
        {
            if(pRect->fShowing)
            {
                pRect->fShowing = false;
                if(i)
                    m_pIGAC->DrawFocus(NULL, ZACCESS_InvalidItem, m_pvCookie);
                else
                    m_pIGAC->DrawDragOrig(NULL, ZACCESS_InvalidItem, m_pvCookie);
            }
        }
        else
        {
            if(!pRect->fShowing || nFocus != pRect->nIndex || pRect->qItem != qFocus ||
                CRect(pRect->rc) != rcFocus)
            {
                pRect->fShowing = true;
                pRect->nIndex = nFocus;
                pRect->qItem = m_pStack->rgItems[nFocus].GetQ();
                pRect->rc = m_pStack->rgItems[nFocus].rc;
                if(i)
                    m_pIGAC->DrawFocus(&rcFocus, nFocus, m_pvCookie);
                else
                    m_pIGAC->DrawDragOrig(&rcFocus, nFocus, m_pvCookie);
            }
        }
    }
}


bool CGraphicalAccessibility::IsValid(long nIndex)
{
    if(!m_pStack)
        return false;

    if(nIndex < 0 || nIndex >= m_pStack->cItems)
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\eventqueue\ceventqueue.cpp ===
#include "BasicATL.h"
#include "CEventQueue.h"


ZONECALL CEventQueue::CEventQueue() :
	m_hashHandlers( Handler::Hash, Handler::Cmp, NULL, 8, 2 ),
	m_hashOwners( Owner::Hash, Owner::Cmp, NULL, 8, 2 ),
	m_poolEvents(),
	m_poolData( 512, 32 ),
	m_hNotification( NULL ),
	m_dwRecursion( 0 ),
	m_bPostMessage( false ),
	m_bEnabled( true ),
	m_dwThreadId( 0 ),
	m_dwMsg( 0 ),
	m_wParam( 0 ),
	m_lParam( 0 ),
	m_lCount( 0 )
{
	InitializeCriticalSection( &m_lockEvents );
	InitializeCriticalSection( &m_lockHandlers );
}


ZONECALL CEventQueue::~CEventQueue()
{
	// lock event queue
	EnterCriticalSection( &m_lockEvents );
	EnterCriticalSection( &m_lockHandlers );

	// release handlers
	m_hashHandlers.RemoveAll( Handler::Del, NULL );
	m_hashOwners.RemoveAll( Owner::Del, NULL );

	// delete events
	for ( int i = 0; i < EVENTQUEUE_CACHE; i++ )
	{
		Event* p = m_listEvents[i].PopHead();
		while ( p )
		{
			p->Free( m_poolData );
			delete p;
			p = m_listEvents[i].PopHead();
		}
	}

	// delete locks
	DeleteCriticalSection( &m_lockEvents );
	DeleteCriticalSection( &m_lockHandlers );
}


STDMETHODIMP_(long) CEventQueue::EventCount()
{
	return m_lCount;
}


STDMETHODIMP CEventQueue::RegisterClient( IEventClient*	pIEventClient, void* pCookie )
{
	// check parameters
	if ( !pIEventClient )
		return E_INVALIDARG;

	// initialize handler entry
	Handler* pHandler = new Handler( pIEventClient, pCookie );
	if ( !pHandler )
		return E_OUTOFMEMORY;

	// add handler, don't allow duplicates
	{
		CAutoLockCS lock( &m_lockHandlers );

		if ( !m_hashHandlers.Get( pHandler ) )
		{
			if ( !m_hashHandlers.Add( pHandler, pHandler ) )
			{
				delete pHandler;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			delete pHandler;
			return ZERR_ALREADYEXISTS;
		}
	}

	return S_OK;
}


STDMETHODIMP CEventQueue::UnregisterClient( IEventClient* pIEventClient, void* pCookie )
{
	// check parameters
	if ( !pIEventClient )
		return E_INVALIDARG;

	// initialize handler entry
	Handler handler( pIEventClient, pCookie );

	// remove handler
	{
		CAutoLockCS lock( &m_lockHandlers );

		Handler* pHandler = m_hashHandlers.Delete( &handler );
		if ( !pHandler )
			return ZERR_NOTFOUND;
		delete pHandler;
	}

	return S_OK;
}


STDMETHODIMP CEventQueue::RegisterOwner(
	DWORD			dwEventId,
	IEventClient*	pIEventClient,
	void*			pCookie )
{
	// check parameters
	if ( !dwEventId || !pIEventClient )
		return E_INVALIDARG;

	// initialize owner entry
	Owner* pOwner = new Owner( dwEventId, pIEventClient, pCookie );
	if ( !pOwner )
		return E_OUTOFMEMORY;

	// add owner but don't allow duplicates
	{
		CAutoLockCS lock( &m_lockHandlers );

		if ( !m_hashOwners.Get( dwEventId ) )
		{
			if ( !m_hashOwners.Add( dwEventId, pOwner ) )
			{
				delete pOwner;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			delete pOwner;
			return ZERR_ALREADYEXISTS;
		}
	}

	return S_OK;
}


STDMETHODIMP  CEventQueue::UnregisterOwner(
	DWORD			dwEventId,
	IEventClient*	pIEventClient,
	void*			pCookie )
{
	// check parameters
	if ( !dwEventId || !pIEventClient )
		return E_INVALIDARG;

	// remove handler
	{
		CAutoLockCS lock( &m_lockHandlers );

		// find owner
		Owner* pOwner = m_hashOwners.Get( dwEventId );
		if (	(!pOwner)
			||	(pOwner->m_pIEventClient != pIEventClient)
			||	(pOwner->m_pCookie != pCookie) )
		{
			return ZERR_NOTOWNER;
		}

		// remove owner
		pOwner = m_hashOwners.Delete( dwEventId );
		if ( pOwner )
			delete pOwner;
	}

	return S_OK;
}


STDMETHODIMP CEventQueue::PostEvent(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2 )
{
	HRESULT hr;

	// check parameters
	if ( !dwEventId )
		return E_INVALIDARG;

	// check queue state
	if ( !m_bEnabled )
		return S_OK;

	// initalize event
	Event* pEvent = new (m_poolEvents) Event;
	if ( !pEvent )
		return E_OUTOFMEMORY;
	hr = pEvent->Init( dwPriority, dwEventId, dwGroupId, dwUserId, dwData1, dwData2 );
	if ( FAILED(hr) )
	{
		delete pEvent;
		return hr;
	}

	// add event to queue
	hr = AddEvent( pEvent );
	if ( FAILED(hr) )
	{
		pEvent->Free( m_poolData );
		delete pEvent;
		return hr;
	}

	// signal notification event
	if ( m_bPostMessage )
	{
		BOOL bRet = PostThreadMessage( m_dwThreadId, m_dwMsg, m_wParam, m_lParam );
		ASSERT( bRet );
	}
	if ( m_hNotification )
		SetEvent( m_hNotification );

	return S_OK;
}



STDMETHODIMP CEventQueue::PostEventWithBuffer(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		void*	pData,
		DWORD	dwDataLen )
{
	HRESULT hr;

	// check parameters
	if ( !dwEventId || (dwDataLen && !pData) )
		return E_INVALIDARG;

	// check queue state
	if ( !m_bEnabled )
		return S_OK;

	// initalize event
	Event* pEvent = new (m_poolEvents) Event;
	if ( !pEvent )
		return E_OUTOFMEMORY;
	hr = pEvent->InitBuffer( dwPriority, dwEventId, dwGroupId, dwUserId, pData, dwDataLen, m_poolData );
	if ( FAILED(hr) )
	{
		delete pEvent;
		return hr;
	}

	// add event to queue
	hr = AddEvent( pEvent );
	if ( FAILED(hr) )
	{
		pEvent->Free( m_poolData );
		delete pEvent;
		return hr;
	}

	// signal notification event
	if ( m_bPostMessage )
	{
		BOOL bRet = PostThreadMessage( m_dwThreadId, m_dwMsg, m_wParam, m_lParam );
		ASSERT( bRet );
	}
	if ( m_hNotification )
		SetEvent( m_hNotification );

	return S_OK;
}


STDMETHODIMP CEventQueue::PostEventWithIUnknown(
		DWORD		dwPriority,
		DWORD		dwEventId,
		DWORD		dwGroupId,
		DWORD		dwUserId,
		IUnknown*	pIUnknown,
		DWORD		dwData2 )
{
	HRESULT hr;

	// check parameters
	if ( !dwEventId )
		return E_INVALIDARG;

	// check queue state
	if ( !m_bEnabled )
		return S_OK;

	// initalize event
	Event* pEvent = new (m_poolEvents) Event;
	if ( !pEvent )
		return E_OUTOFMEMORY;
	hr = pEvent->InitIUnknown( dwPriority, dwEventId, dwGroupId, dwUserId, pIUnknown, dwData2 );
	if ( FAILED(hr) )
	{
		delete pEvent;
		return hr;
	}

	// add event to queue
	hr = AddEvent( pEvent );
	if ( FAILED(hr) )
	{
		pEvent->Free( m_poolData );
		delete pEvent;
		return hr;
	}

	// signal notification event
	if ( m_bPostMessage )
	{
		BOOL bRet = PostThreadMessage( m_dwThreadId, m_dwMsg, m_wParam, m_lParam );
		ASSERT( bRet );
	}
	if ( m_hNotification )
		SetEvent( m_hNotification );

	return S_OK;
}


STDMETHODIMP CEventQueue::SetNotificationHandle( HANDLE hEvent )
{
	InterlockedExchange( (LPLONG) &m_hNotification, (LONG) hEvent );
	return S_OK;
}


STDMETHODIMP CEventQueue::SetWindowMessage( DWORD dwThreadId, DWORD Msg, WPARAM wParam, WPARAM lParam )
{
	m_dwThreadId = dwThreadId;
	m_dwMsg = Msg;
	m_wParam = wParam; 
	m_lParam = lParam;
	m_bPostMessage = true;
	return S_OK;
}

STDMETHODIMP CEventQueue::DisableWindowMessage()
{
	m_bPostMessage = false;
	return S_OK;
}


STDMETHODIMP CEventQueue::EnableQueue( bool bEnable )
{
	m_bEnabled = bEnable;
	return S_OK;
}



STDMETHODIMP CEventQueue::ClearQueue()
{
	Event* pEvent = NULL;

	CAutoLockCS lock( &m_lockEvents );

	// free eventsevents
	for ( int i = 0; i < EVENTQUEUE_CACHE; i++ )
	{
		pEvent = m_listEvents[i].PopHead();
		while ( pEvent )
		{
			pEvent->Free( m_poolData );
			delete pEvent;
			pEvent = m_listEvents[i].PopHead();
		}
	}
	InterlockedExchange( &m_lCount, 0 );
	return S_OK;
}


STDMETHODIMP CEventQueue::ProcessEvents( bool bSingleEvent )
{
	HRESULT hr = S_OK;

	// check recursion
	if (m_dwRecursion)
		return ZERR_ILLEGALRECURSION;
	else
		m_dwRecursion++;

	// process events
	do
	{
		EventWrapper wrapper;
		Event* pEvent = NULL;
		Owner* pOwner = NULL;

		// get highest priority event
		{
			CAutoLockCS lock( &m_lockEvents );
			for ( int i = 0; i < EVENTQUEUE_CACHE; i++ )
			{
				pEvent = m_listEvents[i].PopHead();
				if ( pEvent )
					break;
			}
		}
		if ( !pEvent )
		{
			hr = ZERR_EMPTY;
			break;
		}
		InterlockedDecrement( &m_lCount );

		// call owner and handlers
		{
			CAutoLockCS lock( &m_lockHandlers );
			pOwner = m_hashOwners.Get( pEvent->m_dwEventId );
			wrapper.m_pEvent = pEvent;
			wrapper.m_pOwner = pOwner;
			if ( pOwner )
			{
				HRESULT ret = pOwner->m_pIEventClient->ProcessEvent(
									pEvent->m_dwPriority,
									pEvent->m_dwEventId,
									pEvent->m_dwGroupId,
									pEvent->m_dwUserId,
									pEvent->m_dwData1,
									pEvent->m_dwData2,
									pOwner->m_pCookie );
				if ( ret == S_OK )
					m_hashHandlers.ForEach( CallHandler, &wrapper );
			}
			else
			{
				m_hashHandlers.ForEach( CallHandler, &wrapper );
			}
		}

		// free event
		pEvent->Free( m_poolData );
		delete pEvent;

	} while ( !bSingleEvent );

	m_dwRecursion--;
	return hr;
}


bool ZONECALL CEventQueue::CallHandler( Handler* pHandler, MTListNodeHandle hNode, void* Cookie )
{
	EventWrapper* p = (EventWrapper*) Cookie;

	// don't call owner more than once
	if (	(p->m_pOwner == NULL)
		||	(pHandler->m_pIEventClient != p->m_pOwner->m_pIEventClient)
		||	(pHandler->m_pCookie != p->m_pOwner->m_pCookie) )
	{
		pHandler->m_pIEventClient->ProcessEvent(
						p->m_pEvent->m_dwPriority,
						p->m_pEvent->m_dwEventId,
						p->m_pEvent->m_dwGroupId,
						p->m_pEvent->m_dwUserId,
						p->m_pEvent->m_dwData1,
						p->m_pEvent->m_dwData2,
						pHandler->m_pCookie );
	}

	return true;
}


///////////////////////////////////////////////////////////////////////////////
// Internal functions
///////////////////////////////////////////////////////////////////////////////

HRESULT ZONECALL CEventQueue::AddEvent( Event* pEvent )
{
	CAutoLockCS lock( &m_lockEvents );

	if ( pEvent->m_dwPriority < (EVENTQUEUE_CACHE - 1) )
	{
		// cached priority so just add to end of list
		if ( !m_listEvents[pEvent->m_dwPriority].AddTail( pEvent ) )
			return E_OUTOFMEMORY;
	}
	else
	{
		// sorted insert from end of list
		CList<Event>* pList = &(m_listEvents[EVENTQUEUE_CACHE-1]);
		
		// find first node with higher priority
		ListNodeHandle node = pList->GetTailPosition();
		while ( node )
		{
			Event* p = pList->GetObjectFromHandle( node );
			if ( p->m_dwPriority <= pEvent->m_dwPriority )
				break;
			node = pList->GetPrevPosition( node );
		}

		// insert event
		if ( !node )
			node = pList->AddHead( pEvent );
		else
			node = pList->InsertAfter( pEvent, node );
		if ( !node )
			return E_OUTOFMEMORY;
	}

	InterlockedIncrement( &m_lCount );
	return S_OK;
}


ZONECALL CEventQueue::Handler::Handler( IEventClient* pIEventClient, void* pCookie )
{
	m_pCookie = pCookie;
	m_pIEventClient = pIEventClient;
	if ( m_pIEventClient )
		m_pIEventClient->AddRef();
}


ZONECALL CEventQueue::Handler::~Handler()
{
	if ( m_pIEventClient )
	{
		m_pIEventClient->Release();
		m_pIEventClient = NULL;
	}
	m_pCookie = NULL;
}


DWORD ZONECALL CEventQueue::Handler::Hash( Handler* pKey )
{
	return (DWORD) pKey->m_pIEventClient;
}


bool ZONECALL CEventQueue::Handler::Cmp( Handler* pHandler, Handler* pKey)
{
	return (	(pHandler->m_pIEventClient == pKey->m_pIEventClient)
			&&	(pHandler->m_pCookie == pKey->m_pCookie) );
}


void ZONECALL CEventQueue::Handler::Del( Handler* pHandler, void* )
{
	delete pHandler;
}


ZONECALL CEventQueue::Owner::Owner( DWORD dwEventId, IEventClient* pIEventClient, void* pCookie )
{
	m_dwEventId = dwEventId;
	m_pCookie = pCookie;
	m_pIEventClient = pIEventClient;
	if ( m_pIEventClient )
		m_pIEventClient->AddRef();
}


ZONECALL CEventQueue::Owner::~Owner()
{
	if ( m_pIEventClient )
	{
		m_pIEventClient->Release();
		m_pIEventClient = NULL;
	}
	m_pCookie = NULL;
	m_dwEventId = 0;
}


DWORD ZONECALL CEventQueue::Owner::Hash( DWORD dwEventId )
{
	return dwEventId;
}


bool ZONECALL CEventQueue::Owner::Cmp( Owner* pOwner, DWORD dwEventId )
{
	return ( pOwner->m_dwEventId == dwEventId );
}


void ZONECALL CEventQueue::Owner::Del( Owner* pOwner, void* )
{
	delete pOwner;
}


ZONECALL CEventQueue::Event::Event()
{
	m_dwPriority = 0;
	m_dwEventId = 0;
	m_dwGroupId = 0;
	m_dwUserId = 0;
	m_dwData1 = 0;
	m_dwData2 = 0;
	m_enumType = EventUnknown;
}


ZONECALL CEventQueue::Event::~Event()
{
	ASSERT( m_dwData1 == 0 );
}


HRESULT ZONECALL CEventQueue::Event::Init( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2 )
{
	m_dwPriority = dwPriority;
	m_dwEventId = dwEventId;
	m_dwGroupId = dwGroupId;
	m_dwUserId = dwUserId;
	m_dwData1 = dwData1;
	m_dwData2 = dwData2;
	m_enumType = EventDWORD;
	return S_OK;
}


HRESULT ZONECALL CEventQueue::Event::InitBuffer( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, void* pData, DWORD dwDataLen, CDataPool& pool )
{
	m_dwPriority = dwPriority;
	m_dwEventId = dwEventId;
	m_dwGroupId = dwGroupId;
	m_dwUserId = dwUserId;
	m_dwData1 = 0;
	m_dwData2 = 0;
	m_enumType = EventBuffer;

	// copy data for async queue
	if ( pData && dwDataLen )
	{
		m_dwData2 = dwDataLen;
		m_dwData1 = (DWORD) pool.Alloc( m_dwData2 );
		if ( !m_dwData1 )
			return E_OUTOFMEMORY;
		CopyMemory( (void*) m_dwData1, pData, m_dwData2 );
	}

	return S_OK;
}


HRESULT ZONECALL CEventQueue::Event::InitIUnknown( DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, IUnknown* pIUnk, DWORD dwData2 )
{
	m_dwPriority = dwPriority;
	m_dwEventId = dwEventId;
	m_dwGroupId = dwGroupId;
	m_dwUserId = dwUserId;
	m_dwData1 = (DWORD) pIUnk;
	m_dwData2 = dwData2;
	m_enumType = EventIUnknown;
	if ( pIUnk )
		pIUnk->AddRef();

	return S_OK;
}


void ZONECALL CEventQueue::Event::Free( CDataPool& pool )
{
	switch ( m_enumType )
	{
		case EventUnknown:
		case EventDWORD:
			break;

		case EventBuffer:
			if ( m_dwData1 )
				pool.Free( (char*) m_dwData1, m_dwData2 );
			break;

		case EventIUnknown:
			if ( m_dwData1 )
				((IUnknown*) m_dwData1)->Release();
			break;

		default:
			ASSERT( !"Invalid event type" );
			break;
	}
	m_dwData1 = 0;
	m_dwData2 = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\chat.h ===
#ifndef __CHAT_H__
#define __CHAT_H__

#include <windows.h>
#include "rectfrx.h"

typedef long (*PFHANDLEINPUT)( char*, int, DWORD cookie );


class CChatWnd
{
public:
	CChatWnd();
	~CChatWnd();
	HRESULT Init( HINSTANCE hInstance, HWND hWndParent, CRect* pRect, PFHANDLEINPUT	pfHandleInput, DWORD dwCookie );

	// Add text to display window
	void AddText( char* from, char* text );

	// Resize display and enter window
	void ResizeWindow( CRect* pRect );

	// Set focus to input window
	void SetFocus()	{ ::SetFocus(m_hWndEnter); }

	void Enable(){ m_bEnabled = TRUE; }
	void Disable(){ m_bEnabled = FALSE; }
	
	static LRESULT CALLBACK EnterWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
	static LRESULT CALLBACK DisplayWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

	HWND			m_hWndDisplay;
	HWND			m_hWndEnter;
	HWND			m_hWndParent;
	WNDPROC			m_DefEnterProc;
	WNDPROC			m_DefDisplayProc;
	PFHANDLEINPUT	m_pfHandleInput;
	DWORD			m_dwCookie;
	HFONT			m_hFont;
	int				m_fDone;
	BOOL			m_bEnabled;
	BOOL  			m_bBackspaceWorks;
};

#endif //!__CHAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\datastore\test\test.cpp ===
#define INITGUID
#include <windows.h>
#include <winreg.h>
#include <stdio.h>

#include "ZoneMem.h"
#include "ZoneCOM.h"
#include "DataStore.h"


// TCHAR* szDllPath = _T("..\\..\\..\\..\\bin\\debug\\ZoneClient.dll");
TCHAR* szDllPath = _T("e:\\z6\\ZoneNT\\bin\\debug\\ZoneCore.dll");

TCHAR szArray[10000][100];

void __cdecl TestBasicMethods();
void __cdecl TestSavesLoads();

void __cdecl main()
{
	TestBasicMethods();
	TestSavesLoads();
}


HRESULT ZONECALL PrintCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT	pVariant, DWORD dwSize, LPVOID pContext )
{
	printf("Key %s, ", szKey );

	if ( pVariant )
	{
		switch( pVariant->vt )
		{
		case ZVT_LONG:
			printf("type = long, value = %d", pVariant->lVal );
			break;
		case ZVT_LPTSTR:
			printf("type = string, value = %s", (TCHAR*) pVariant->byref );
			break;
		case ZVT_BLOB:
			printf("type = blob, size = %s", dwSize );
			break;
		case ZVT_RGB:
			{
				BYTE red = GetRValue( pVariant->lVal );
				BYTE green = GetGValue( pVariant->lVal );
				BYTE blue = GetBValue( pVariant->lVal );
				printf( "type = rgb, value = { %d, %d, %d }", red, green, blue );
				break;
			}

		case ZVT_PT:
			{
				POINT* p = (POINT*) pVariant->byref;
				printf( "type = point, { %d, %d }", p->x, p->y );
				break;
			}

		case ZVT_RECT:
			{
				RECT* r = (RECT*) pVariant->byref;
				printf( "type = rect, { %d, %d, %d, %d }", r->left, r->top, r->right, r->bottom );
				break;
			}
		}
	}
	else 
		printf("no data", szKey );

	printf( "\n" );
	return S_OK;
}


void __cdecl TestBasicMethods()
{
	HRESULT		hr;
	VARIANT		v;
	VARTYPE		vtValueType = 0;
	TCHAR		szKeyName[256];
	DWORD		dwKeyNameSize;

	CZoneComManager*	pManager = NULL;
	IDataStoreManager*		pZdsMgr = NULL;
	IDataStore			*pZds1 = NULL;
	IDataStore			*pZds2 = NULL;

	//Create the ZONE COM manager
	pManager = new CZoneComManager;
	hr = pManager->Create(szDllPath, NULL, CLSID_DataStoreManager, IID_IDataStoreManager, (void**) &pZdsMgr );
	if ( FAILED(hr) )
	{
		printf("Error IDataStoreManager manager, hr = %d\n", hr);
		goto done;
	}

	//Initialize the IDataStoreManager object. This needs to be done before the //Create method can be used.
	//See the IDSMGR methods Init() for a description of each //parameter that can be sent to the
	//Init() method.

	hr = pZdsMgr->Init();	//defaults are fine for this application.
	if ( FAILED(hr) )
	{
		printf("Error initializing the IDataStoreManager object, hr = %d\n", hr);
		goto done;
	}
	

	//Create a zone data store
	hr=pZdsMgr->Create(&pZds1);
	if ( FAILED(hr)  )
	{
		printf("Error creating data store 1, hr = %d\n", hr);
		goto done;
	}

	//Create another zone data store
	hr = pZdsMgr->Create(&pZds2);
	if ( FAILED(hr)  )
	{
		printf("Error creating data store 2, hr = %d\n", hr);
		goto done;
	}

	//Add basic keys
	pZds1->SetLong( "A", 1 );
	
	pZds1->SetLong( "B", 2 );

	pZds1->SetLong( "A/B/C", 3 );

	// Verify basic keys
	pZds1->GetKey( "A", &v, NULL );
	ASSERT( (v.vt == ZVT_LONG) && (v.lVal == 1));

	pZds1->GetKey( "B", &v, NULL );
	ASSERT( (v.vt == ZVT_LONG) && (v.lVal == 2));

	pZds1->GetKey( "A/B/C", &v, NULL );
	ASSERT( (v.vt == ZVT_LONG) && (v.lVal == 3));

	pZds1->SetLong( "A/B/C", 4 );
	pZds1->GetKey( "A/B/C", &v, NULL );
	ASSERT( (v.vt == ZVT_LONG) && (v.lVal == 4));


	// Test deletion and memory reuse
	pZds1->DeleteKey( "A" );
	pZds1->SetLong( "A", 1 );


	//Add some long value keys to each data store.
	v.vt = ZVT_LONG;
	v.lVal = 1;

	TCHAR	szTmp[256];
	TCHAR	szKey[256];
	TCHAR	*pStr;
	int i;
	int t;

	strcpy(szArray[0], "foo");

	for(i=1; i<1000; i++)
	{
		for(t=0; t<10; t++)
		{
			if ( t != 0 && rand() % 30 > 15 )
				continue;
			if ( (rand() % 100) > 50 )
			{
				pStr = szArray[0];
			}
			else
			{
				sprintf(szTmp, "%d", (rand() % 100) );
				pStr = szTmp;
			}
			if ( t == 0 )
				sprintf(szKey, "%s", pStr);
			else
			{
				strcat(szKey, "/");
				strcat(szKey, pStr);
			}
		}
		strcpy(szArray[i], szKey);
	}

	for(i=0; i<1000; i++)
	{
		v.lVal = i;
		pZds1->SetKey(szArray[i], &v, NULL);
	}

	pZds1->SetKey("ccc/ddd", &v, NULL);

	v.lVal = 88;
	pZds2->SetKey("ccc/ddd", &v, NULL);

	//retrieve the key that we added from each data store.
	v.lVal = 99;
	pZds1->GetKey("ccc/ddd", &v, NULL);

	printf("Data Store pZds1, ccc/ddd = %d\n", v.lVal);

	v.lVal = 99;
	pZds2->GetKey("ccc/ddd", &v, NULL);

	printf("Data Store pZds2, ccc/ddd = %d\n", v.lVal);

	//Add some keys to data store 1

	pZds1->SetKey("aaa/B", &v, NULL);

	pZds1->SetKey("ddd", &v, NULL);

	//delete our ddd key in data store 1
	pZds1->DeleteKey("ddd");

	pZds1->SetKey("bbb/ccc/ddd", &v, NULL);

	dwKeyNameSize = sizeof(szKeyName);

	//Enumerate our ccc key in data store 1
	printf("Enumerate bbb key in Data Store 1.\n", szKeyName, vtValueType);
	pZds1->EnumKeys( "bbb", PrintCallback, NULL );


	{

		//test get set helper functions

		TCHAR	szString[256];
		BYTE	pData[256];
		long	lValue;
		DWORD	dwSize;

		lValue = 256;
		strcpy(szString, "Hello World");

		for(int i=0; i<sizeof(pData); i++)
			pData[i] = (BYTE)i;

		pZds1->SetLong( "macro/long", lValue );
		pZds1->SetString( "macro/string", szString );
		pZds1->SetBlob( "macro/blob", pData, sizeof(pData) );

		lValue = 0;
		memset(pData, 0, sizeof(pData));
		strcpy(szString, "This is not the time or the place.");

		pZds1->GetLong( "macro/long", &lValue );

		dwSize = sizeof(szString);
		pZds1->GetString( "macro/string", szString, &dwSize );

		dwSize = sizeof(pData);
		pZds1->GetBlob( "macro/blob", pData, &dwSize );

		dwSize = sizeof(pData);
	}



done:

	//clean up any data stores that have been allocated.

	if ( pZds1 )
		pZds1->Release();

	if ( pZds2 )
		pZds2->Release();


	//release the IDataStoreManager interface.

	if ( pZdsMgr )
		pZdsMgr->Release();

	//release the zone com manager.

	if ( pManager )
		delete pManager;

	return;
}

void __cdecl TestSavesLoads()
{
	HRESULT				hr;
	VARIANT				v;
	VARTYPE				vtValueType;
	TCHAR				szKeyName[256];
	DWORD				dwKeyNameSize;
	CZoneComManager*	pManager = NULL;
	IDataStoreManager*	pZdsMgr = NULL;
	IDataStore			*pZds1 = NULL;
	VARIANT				V[5];
	TCHAR				sz[] = { "My Favorite Age Lobby" };
	DWORD				dwBufferSize;
	PKEYINFO			pKeyInfo;
	
	const TCHAR			szFileName[] = { "foo.txt" };
	const TCHAR			szBaseKey[] = { "Window Settings" };

	KEYINFO	keyInfo[] =
	{
		{ &V[0], "Title", lstrlen(sz) + 1 },
		{ &V[1], "X", 0		 },
		{ &V[2], "Y", 0		 },
		{ &V[3], "W", 0		 },
		{ &V[4], "H", 0		 },
	};

	DWORD dwTotalKeys = sizeof(keyInfo)/sizeof(keyInfo[0]);

	//Create the ZONE COM manager
	pManager = new CZoneComManager;
	hr = pManager->Create(szDllPath, NULL, CLSID_DataStoreManager, IID_IDataStoreManager, (void**) &pZdsMgr );
	if ( FAILED(hr) )
	{
		printf("Error IDataStoreManager manager, hr = %d\n", hr);
		goto done;
	}

	//Initialize the IZDSMGR object. This needs to be done before the Create method can be used.
	//See the IDSMGR methods Init() for a description of each parameter that can be sent to the
	//Init() method.

	hr=pZdsMgr->Init();	//defaults are fine for this application.
	if ( FAILED(hr) )
	{
		printf("Error initializing the IZDSMGR object, hr = %d\n", hr);
		goto done;
	}
	

	//Create a zone data store
	hr=pZdsMgr->Create(&pZds1);
	if ( FAILED(hr)  )
	{
		printf("Error creating data store 1, hr = %d\n", hr);
		goto done;
	}

	// Test enumeration
	{
		char buff[2048];
		DWORD size = sizeof(buff);
		PKEYINFO keyInfo = (PKEYINFO) buff;
		DWORD keys = 0;
		DWORD len = 0;
		VARIANT v;

		pZds1->SetLong( "aaa", 1 );
		pZds1->SetLong( "aaa/bbb", 2 );
		pZds1->SetLong( "aaa/bbb/ccc", 3 );
		pZds1->SetLong( "aaa/bbb/ccc/zzz", 4 );
		pZds1->SetLong( "aaa/bbb/ccc/yyy", 5 );
		pZds1->SetLong( "aaa/bbb/ccc/yyy/hhh", 6 );
		pZds1->SetString( "aaa/bbb/ddd", "test ..1 ..2 ..3" );

		printf( "\n\nFull enumeration:\n" );
		hr = pZds1->EnumKeys( NULL, PrintCallback, NULL );

		printf( "\n\nPartial enumeration (aaa/bbb):\n" );
		hr = pZds1->EnumKeys( "aaa/bbb", PrintCallback, NULL );

		printf( "\n\nFull enumeration, depth = 1:\n" );
		hr = pZds1->EnumKeysLimitedDepth( NULL, 1, PrintCallback, NULL );

		printf( "\n\nPartial enumeration (aaa/bbb), depth = 1:\n" );
		hr = pZds1->EnumKeysLimitedDepth( "aaa/bbb", 1, PrintCallback, NULL );
	}


	// Test save to buffer
	{
		char buff[2048];
		DWORD size = sizeof(buff);
		PKEYINFO keyInfo = (PKEYINFO) buff;
		DWORD keys = 0;
		DWORD len = 0;
		VARIANT v;

		pZds1->SetLong( "aaa", 1 );
		pZds1->SetLong( "aaa/bbb", 2 );
		pZds1->SetLong( "aaa/bbb/ccc", 3 );
		pZds1->SetString( "aaa/bbb/ddd", "test ..1 ..2 ..3" );
		hr = pZds1->EnumKeys( NULL, PrintCallback, NULL );
		hr = pZds1->SaveToBuffer( NULL, keyInfo, &size, &keys );

		printf( "\n\nSave to buffer results:\n" );
		for ( DWORD i = 0; i < keys; i++ )
			printf("Key %s, type = %d, value = %d\n", keyInfo[i].szKey, keyInfo[i].lpVt->vt, keyInfo[i].lpVt->iVal );
	}

	//Test Save to file
	{
		char buff[1024];
		DWORD size = sizeof(buff);

		pZds1->SaveToFile(NULL, "file.txt");
		pZds1->SaveToTextBuffer(NULL, buff, &size );
		pZds1->DeleteKey( "aaa" );
	}

	//Test RGB LoadFromTextBuffer
	{
		char buff[] = "[test]\r\nblack = RGB, { 0, 1, 2}\r\nxy = PT, {10,20}\r\nrc = RECT, {1,2,3,4}\r\n";
		pZds1->LoadFromTextBuffer( "", buff, sizeof(buff) );
		printf( "\n\nLoadFromTextBuffer:\n" );
		pZds1->EnumKeys( NULL, PrintCallback, NULL );
		pZds1->DeleteKey( "test" );
	}

	//Test LoadFromTextBuffer
	{
		char buff[] = "[bbb]\r\nccc = LONG, 1\r\nddd = SZ, \"string 1\"\r\n[]\r\neee=sz,   string 4 ";
		pZds1->LoadFromTextBuffer( "aaa/", buff, sizeof(buff) );
		printf( "\n\nLoadFromTextBuffer:\n" );
		pZds1->EnumKeys( NULL, PrintCallback, NULL );
		pZds1->DeleteKey( "aaa" );
	}

	//Test Load from file
	{
		printf( "\n\nLoadFromFile:\n" );
		pZds1->LoadFromFile("file", "file.txt");
		pZds1->EnumKeys( NULL, PrintCallback, NULL );
	}
	
	//Test SaveToRegistry & LoadFromRegistry
	{
		HKEY hKey;
		DWORD dwDisp;
		long ret;
		char buff[] = "[test]\r\nblack = RGB, { 0, 1, 2}\r\nxy = PT, {10,20}\r\nrc = RECT, {1,2,3,4}\r\n";
		pZds1->LoadFromTextBuffer( "", buff, sizeof(buff) );
		ret = RegCreateKeyEx( HKEY_LOCAL_MACHINE, "Software\\DataStoreTest", 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp );
		if ( ret == ERROR_SUCCESS )
		{
			pZds1->SaveToRegistry( NULL, hKey  );
			RegCloseKey( hKey );
		}

		printf( "\n\nLoadFromRegistry - Before:\n" );
		pZds1->EnumKeys( NULL, PrintCallback, NULL );
		pZds1->DeleteKey( NULL );

		if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\DataStoreTest", 0, KEY_READ, &hKey) == ERROR_SUCCESS )
		{
			printf( "\n\nLoadFromRegistry - After:\n" );
			hr = pZds1->LoadFromRegistry( NULL, hKey );
			hr = pZds1->EnumKeys( NULL, PrintCallback, NULL );
			RegCloseKey(hKey);
		}
	}

	//Test load from buffer
	{
		V[0].vt = ZVT_LPTSTR; 
		V[0].byref = sz; 

		V[1].vt = ZVT_LONG; 
		V[1].lVal = 0;

		V[2].vt = ZVT_LONG; 
		V[2].lVal = 0;

		V[3].vt = ZVT_LONG; 
		V[3].lVal = 640;

		V[4].vt = ZVT_LONG; 
		V[4].lVal = 480;

		if ( pZds1->LoadFromBuffer((TCHAR *)szBaseKey, keyInfo, dwTotalKeys) == S_OK )
		{
			printf( "\n\nLoad from buffer results:\n" );
			pZds1->EnumKeys( NULL, PrintCallback, NULL );
		}
	}

	dwBufferSize = 1024;

	pKeyInfo = (PKEYINFO)ZMalloc(dwBufferSize);

	if ( pKeyInfo )
	{
		hr = pZds1->SaveToBuffer((TCHAR *)szBaseKey, pKeyInfo, &dwBufferSize, &dwTotalKeys);
		ZFree(pKeyInfo);
	}

	hr = pZds1->SaveToFile((TCHAR *)szBaseKey, "save.txt");

	{
		HKEY hKey;

		if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\test", 0, KEY_WRITE, &hKey) == ERROR_SUCCESS )
		{
			hr = pZds1->SaveToRegistry((TCHAR *)szBaseKey, hKey);

			RegCloseKey(hKey);
		}
	}

done:

	//clean up any data stores that have been allocated.

	if (pZds1 )
		pZds1->Release();

	//release the IZDSMGR interface.

	if ( pZdsMgr )
		pZdsMgr->Release();

	//release the zone com manager.

	if ( pManager )
		delete pManager;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\chatcore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ChatCore.h
 *
 * Contents:	Millennium Lobby protocol module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// MillLobbyCore object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{E6C04FD5-5D25-11d3-8846-00C04F8EF45B}")) MillLobbyCore;

// {E6C04FD5-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(CLSID_MillLobbyCore, 
0xe6c04fd5, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\friends.h ===
#ifndef _FRIENDS_H
#define _FRIENDS_H

#ifdef __cplusplus

// predefined groups
#define FRIENDS_GROUP TEXT("Friends")
#define HIDDEN_GROUP_CHARACTER TEXT('#')
#define PRIVACY_ALLOW_GROUP TEXT("#Watchers Allowed")
#define PRIVACY_DENY_GROUP TEXT("#Watchers Not Allowed")

// return FALSE from callback to stop enumeration
typedef BOOL (*FRIENDS_ENUM_CALLBACK)(LPTSTR pGroup, LPTSTR pName, LPVOID pCookie );
typedef BOOL (*FRIENDS_ENUMGROUPS_CALLBACK)(LPTSTR pGroup, LPVOID pCookie );
typedef void (*FRIENDS_FILECHANGE_CALLBACK)( LPVOID pCookie );

// You MUST call SetUserName before calling any functions or nothing will happen!

class IFriends
{
    public:
        IFriends() {}
        virtual ~IFriends() {}

        virtual BOOL SetUserName(LPTSTR pName) = 0;
        virtual void Close() = 0;

        // note: - adds and removes are commited immediately,
        //         and can not be called during enumerations.
        //       - passing a NULL group name defaults to the FRIENDS_GROUP
        virtual BOOL Add( LPTSTR pGroup, LPTSTR pName ) = 0;
        virtual BOOL AddGroup( LPTSTR pGroup ) = 0;
        virtual BOOL Remove( LPTSTR pGroup, LPTSTR pName ) = 0;
        virtual BOOL RemoveGroup( LPTSTR pGroup ) = 0;

        virtual BOOL Enum( LPTSTR pGroup, FRIENDS_ENUM_CALLBACK pfn, LPVOID pCookie ) = 0;
        virtual BOOL EnumGroups( FRIENDS_ENUMGROUPS_CALLBACK pfn,  LPVOID pCookie ) = 0;

        virtual BOOL NotifyOnChange( FRIENDS_FILECHANGE_CALLBACK pfn, LPVOID pCookie ) = 0;


};

#else

typedef void IFriends;

#endif  // cplusplus

#ifdef __cplusplus
extern "C" {
#endif

IFriends* CreateFriendsFile();
void      FreeFriendsFile(IFriends* p);

#ifdef __cplusplus
}
#endif

#endif // _FRIENDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\frx.h ===
#ifndef __WINFRX_H__
#define __WINFRX_H__

#include "..\WinFrx\wndfrx.h"
#include "..\WinFrx\buttonfrx.h"
#include "rectfrx.h"
#include "..\WinFrx\palfrx.h"
#include "..\WinFrx\dibfrx.h"
#include "..\WinFrx\dirtyfrx.h"
#include "..\WinFrx\spritefrx.h"
#include "..\WinFrx\wndrectfrx.h"

#endif //!__WINFRX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\datastore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		DataStore.h
 *
 * Contents:	DataStore interfaces
 *
 *****************************************************************************/

#ifndef _DATASTORE_H_
#define _DATASTORE_H_

#include "ResourceManager.h"

#pragma comment(lib, "DataStore.lib")

///////////////////////////////////////////////////////////////////////////////
// Data Store Variant types (NOT VARENUM)
///////////////////////////////////////////////////////////////////////////////

enum ZVTENUM
{
	ZVT_BYREF	=	0x4000,

	ZVT_EMPTY	=	0x000,
	ZVT_LONG	=	0x001,
	ZVT_RGB		=	0x002,
	ZVT_LPTSTR	=	0x003 | ZVT_BYREF,
	ZVT_BLOB	=	0x004 | ZVT_BYREF,	
	ZVT_PT		=	0x005 | ZVT_BYREF,
	ZVT_RECT	=	0x006 | ZVT_BYREF,
	ZVT_FONT	=	0x007 | ZVT_BYREF,
};

struct ZONEFONT {

	// default constructor - won't match any physical font
	ZONEFONT() 	{ ZeroMemory( this, sizeof(ZONEFONT) );	}
	// 
	ZONEFONT(LONG h, const TCHAR* pName = NULL, LONG w = 400) :
		lfHeight(h),
		lfWeight(w)
	{ 
		if ( pName )
			lstrcpyn(lfFaceName, pName, LF_FACESIZE);
		else
			ZeroMemory( lfFaceName, LF_FACESIZE );
	}

    LONG      lfHeight;
    LONG      lfWeight;
    TCHAR     lfFaceName[LF_FACESIZE];
};



#define DataStore_MaxDirectoryDepth	64


///////////////////////////////////////////////////////////////////////////////
// IDataStoreManager
///////////////////////////////////////////////////////////////////////////////

interface IDataStore;

// {EDF392E0-ACCA-11d2-A5F5-00C04F68FD5E}
DEFINE_GUID(IID_IDataStoreManager,
    0xedf392e0, 0xacca, 0x11d2, 0xa5, 0xf5, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0x5e);

interface __declspec(uuid("{EDF392E0-ACCA-11d2-A5F5-00C04F68FD5E}"))
IDataStoreManager : public IUnknown
{
	//
	// IDataStoreManager::Create
	//
	// Create a new data store object
	//
	// Parameters:
	//	pZds
	//    returned pointer to IDataStore interface object
	//
	STDMETHOD(Create)(
		IDataStore **pZds ) = 0;


	STDMETHOD(Init)(
		int		iInitialTableSize = 256,
		int		iNextStrAlloc = 32,
		int		iMaxStrAllocSize = 512,
		WORD	NumBuckets = 16,
		WORD	NumLocks = 4,
        IResourceManager *piResourceManager = NULL ) = 0;

    STDMETHOD(SetResourceManager)(IResourceManager *piResourceManager) = 0;

	STDMETHOD_(IResourceManager*, GetResourceManager)() = 0;
};



///////////////////////////////////////////////////////////////////////////////
// DataStore object
///////////////////////////////////////////////////////////////////////////////

// {66B1FD12-BA5D-11d2-8B14-00C04F8EF2FF}
DEFINE_GUID(CLSID_DataStoreManager, 
0x66b1fd12, 0xba5d, 0x11d2, 0x8b, 0x14, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{66B1FD12-BA5D-11d2-8B14-00C04F8EF2FF}")) CDataStore ;



///////////////////////////////////////////////////////////////////////////////
// IDataStore
///////////////////////////////////////////////////////////////////////////////

typedef struct _KEYINFO
{
	LPVARIANT	lpVt;	//pointer to variant data to be written to the key
	TCHAR*		szKey;	//NULL ternimated name of the key the variant data is to be stored.
	DWORD		dwSize;	//data size for variable length data items.
} KEYINFO, *PKEYINFO;


// {2031AB52-B61C-11d2-A5F6-00C04F68FD5E}
DEFINE_GUID(IID_IDataStore,
	0x2031ab52, 0xb61c, 0x11d2, 0xa5, 0xf6, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0x5e);

interface __declspec(uuid("{2031AB52-B61C-11d2-A5F6-00C04F68FD5E}"))
IDataStore : public IUnknown
{
	//
	// IDataStore::PFKEYENUM
	//
	// Application defined callback function for IDataStore::EnumKeys method.
	// Return S_OK to continue enumeration, S_FALSE to stop enumeration.
	//
	// Parameters:
	//	szKey
	//		Pointer to key name of string. Callback must not modify parameter.
	//	szRelativeKey
	//		Pointer to key name relative to specified key. Callback must not
	//		modify parameter.
	//	pVariant
	//		Pointer to key's variant.  Callback must not modify parameter.
	//	dwSize
	//		Size fo variant data.
	//	pContext
	//		Context supplied in ILobbyDataStore::EnumKeys
	//
	typedef HRESULT (ZONECALL *PFKEYENUM)(
		CONST TCHAR*	szFullKey,
		CONST TCHAR*	szRelativeKey,
		CONST LPVARIANT	pVariant,
		DWORD			dwSize,
		LPVOID			pContext );


	//
	// IDataStore::SetKey
	//
	// Adds the specified key to the data store
	//
	// Parameters:
	//	szKey
	//		Key to be added
	//  pVariant
	//		Data value to be associated with the key variant that contains
	//		the data to be associated with the key.
	//  dwSize
	//		Size of the data if variable length
	//
	STDMETHOD(SetKey)(
		CONST TCHAR*	szKey,
		LPVARIANT		pVariant,
		DWORD			dwSize) = 0;


	//
	// IDataStore::SetKey
	//
	// Optimized version of the standard SetKey that takes an array of key
	// names so it doesn't have to parse the directory seperators.
	//
	// Parameters:
	//	arKeys
	//		Array of key names
	//	nElts
	//		Number of array entries
	//  pVariant
	//		Data value to be associated with the key variant that contains
	//		the data to be associated with the key.
	//  dwSize
	//		Size of the data if variable length
	//
	STDMETHOD(SetKey)(
		CONST TCHAR**	arKeys,
		long			nElts,
		LPVARIANT		pVariant,
		DWORD			dwSize) = 0;


	//
	// IDataStore::SetKey variations
	//
	// Convenient forms SetKey for common data types.
	//
	STDMETHOD(SetString)(
		CONST TCHAR*	szKey,
		CONST TCHAR*	szValue ) = 0;

	STDMETHOD(SetString)(
		CONST TCHAR**	arKeys,
		long			nElts,
		CONST TCHAR*	szValue ) = 0;

	STDMETHOD(SetLong)(
		CONST TCHAR*	szKey,
		long			lValue ) = 0;

	STDMETHOD(SetLong)(
		CONST TCHAR**	arKeys,
		long			nElts,
		long			lValue ) = 0;

	STDMETHOD(SetRGB)(
		CONST TCHAR*	szKey,
		COLORREF 		colorRGB ) = 0;

	STDMETHOD(SetRGB)(
		CONST TCHAR**	arKeys,
		long			nElts,
		COLORREF 		colorRGB ) = 0;

	STDMETHOD(SetPOINT)(
		CONST TCHAR*	szKey,
		const POINT&	refPoint ) = 0;

	STDMETHOD(SetPOINT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const POINT&	refPoint ) = 0;

	STDMETHOD(SetRECT)(
		CONST TCHAR*	szKey,
		const RECT&		refRect ) = 0;

	STDMETHOD(SetRECT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const RECT&		refRect ) = 0;

	STDMETHOD(SetFONT)(
		CONST TCHAR*	szKey,
		const ZONEFONT&	refFont ) = 0;

	STDMETHOD(SetFONT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		const ZONEFONT&	refFont ) = 0;

	STDMETHOD(SetBlob)(
		CONST TCHAR*	szKey,
		CONST void*		pBlob,
		DWORD			dwLen ) = 0;

	STDMETHOD(SetBlob)(
		CONST TCHAR**	arKeys,
		long			nElts,
		CONST void*		pBlob,
		DWORD			dwLen ) = 0;


	//
	// IDataStore::GetKey
	//
	// Retrieves the specified key's data from the data store.
	//
	// Parameters:
	//	szKey
	//		Key to be retrieved
	//  pVariant
	//		Variant that receives the retrieved keys data.
	//  pdwSize
	//		Contains the size of the key buffer pointed to in the variants byref member for
	//		string and blob types. On exit this parameter is updated to reflect the size of
	//		the data stored in the byref member of the variant. If this parameter is NULL
	//		then it is assumed that the buffer is large enough to contain the data. If the
	//		data value is fixed length then this parameter is ignored.
	//
	STDMETHOD(GetKey)(
		CONST TCHAR*	szKey,
		LPVARIANT		pVariant,
		PDWORD			pdwSize ) = 0;

	
	//
	// IDataStore::GetKey
	//
	// Optimized version of the standard GetKey that takes an array of key
	// names so it doesn't have to parse the directory seperators.
	//
	// Parameters:
	//	arKeys
	//		Array of key names
	//	nElts
	//		Number of array entries
	//  pVariant
	//		Variant that receives the retrieved keys data.
	//  pdwSize
	//		Contains the size of the key buffer pointed to in the variants byref member for
	//		string and blob types. On exit this parameter is updated to reflect the size of
	//		the data stored in the byref member of the variant. If this parameter is NULL
	//		then it is assumed that the buffer is large enough to contain the data. If the
	//		data value is fixed length then this parameter is ignored.
	//
	STDMETHOD(GetKey)(
		CONST TCHAR**	arKeys,
		long			nElts,
		LPVARIANT		pVariant,
		PDWORD			pdwSize ) = 0;


	//
	// IDataStore::SetKey variations
	//
	// Convenient forms SetKey for common data types.
	//
	STDMETHOD(GetString)(
		CONST TCHAR*	szKey,
		TCHAR*			szValue,
		PDWORD			pdwSize ) = 0;

	STDMETHOD(GetString)(
		CONST TCHAR**	arKeys,
		long			nElts,
		TCHAR*			szValue,
		PDWORD			pdwSize ) = 0;

	STDMETHOD(GetLong)(
		CONST TCHAR*	szKey,
		long*			plValue ) = 0;

	STDMETHOD(GetLong)(
		CONST TCHAR**	arKeys,
		long			nElts,
		long*			plValue ) = 0;

	STDMETHOD(GetRGB)(
		CONST TCHAR*	szKey,
		COLORREF* 		pcolorRGB ) = 0;

	STDMETHOD(GetRGB)(
		CONST TCHAR**	arKeys,
		long			nElts,
		COLORREF* 		pcolorRGB ) = 0;

	STDMETHOD(GetPOINT)(
		CONST TCHAR*	szKey,
		POINT*			pPoint ) = 0;

	STDMETHOD(GetPOINT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		POINT*			pPoint ) = 0;

	STDMETHOD(GetRECT)(
		CONST TCHAR*	szKey,
		RECT*			pRect ) = 0;

	STDMETHOD(GetRECT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		RECT*			pRect ) = 0;

	STDMETHOD(GetFONT)(
		CONST TCHAR*	szKey,
		ZONEFONT*		pFont ) = 0;

	STDMETHOD(GetFONT)(
		CONST TCHAR**	arKeys,
		long			nElts,
		ZONEFONT*		pFont ) = 0;

	STDMETHOD(GetBlob)(
		CONST TCHAR*	szKey,
		void*			pBlob,
		PDWORD			pdwSize ) = 0;

	STDMETHOD(GetBlob)(
		CONST TCHAR**	arKeys,
		long			nElts,
		void*			pBlob,
		PDWORD			pdwSize ) = 0;


	//
	// IDataStore::DeleteKey
	//
	// Removes a key and all of it's siblings from a data store.
	//
	// Parameters:
	//	szKey
	//		Key to be removed.
	//
	STDMETHOD(DeleteKey)( CONST TCHAR *szBaseKey ) = 0;


	//
	// IDataStore::EnumKeys
	//
	// Enumerates keys
	//
	// Parameters:
	//	szKey
	//		Name of the key being queried.
	//	pfCallback
	//		Pointer to callback function that will be called for each
	//		key.
	//	pContext
	//		Context that will be passed to the callback fuction
	//
	STDMETHOD(EnumKeys)(
		CONST TCHAR*	szKey,
		PFKEYENUM		pfCallback,
		LPVOID			pContext ) = 0;

	//
	// IDataStore::EnumKeysLimitedDepth
	//
	// Enumerates keys to specified depth
	//
	// Parameters:
	//	szKey
	//		Name of the key being queried.
	//	dwMaxDepth
	//		Maximum depth to enumeration; 1 = key's immediate children, etc.
	//	pfCallback
	//		Pointer to callback function that will be called for each
	//		key.
	//	pContext
	//		Context that will be passed to the callback fuction
	//
	STDMETHOD(EnumKeysLimitedDepth)(
		CONST TCHAR*	szKey,
		DWORD			dwMaxDepth,
		PFKEYENUM		pfCallback,
		LPVOID			pContext ) = 0;


	//
	// IDataStore::SaveToBuffer
	//
	// Saves key and sub keys into a KEYINFO memory array.
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key to read
	//
	//	PKEYINFO pKeyInfo
	//    Pointer to caller supplied KEYINFO array. There should be 1 KEYINFO structure
	//    for each key that the caller expects to be returned. This paramter can be NULL
	//    in which case no individual key info is returned.
	//
	//	PDWORD pdwBufferSize
	//    Pointer to a DWORD that contains of the size of the caller supplied pKeyInfo 
	//    buffer. On exit this parameter is updated to the required size needed to
	//    contain all of the returned keyinfo data
	//
	//	PDWORD pdwTotalKeys
	//    Pointer to a DWORD that will be updated on exit to the total number of
	//    keys returned in the KEYINFO array.
	//
	STDMETHOD(SaveToBuffer)(
		CONST TCHAR*	szBaseKey,
		PKEYINFO		pKeyInfo,
		PDWORD			pdwBufferSize,
		PDWORD			pdwTotalKeys ) = 0;


	//
	// IDataStore::LoadFromBuffer
	//
	// Creates a set of keys within a data store key or sub key.
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key underwhich to load the memory buffers keys
	//	PKEYINFO pKeyInfo
	//    Array of KEYINFO structures that contain the individual keys to be created.
	//	DWORD dwTotalKeys) = 0;
	//    Total number of keys contained in the KEYINFO structure array.
	//
	STDMETHOD(LoadFromBuffer)(
		CONST TCHAR*	szBaseKey,
		PKEYINFO		pKeyInfo,
		DWORD			dwTotalKeys ) = 0;


	//
	// IDataStore::SaveToRegistry
	//
	// Saves key and sub keys into a registry.
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key in data store to read
	//	hKey
	//    handle to open registry key, the registry key must have WRITE access.
	//
	STDMETHOD(SaveToRegistry)(
		CONST TCHAR*	szBaseKey,
		HKEY			hKey ) = 0;


	//
	// IDataStore::LoadFromRegistry
	//
	// Creates a set of keys within a data store key or sub key.
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key under which to place the keys and values
	//	PKEYINFO pKeyInfo
	//    Array of KEYINFO structures that contain the individual keys to be created.
	//	DWORD dwTotalKeys) = 0;
	//    Total number of keys contained in the KEYINFO structure array.
	//
	STDMETHOD(LoadFromRegistry)(
		CONST TCHAR*	szBaseKey,
		HKEY			hKey ) = 0;


	//
	// IDataStore::LoadFromFile
	//
	// Creates a set of keys within a data store key or sub key (ANSI only).
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key under which to place the keys and values
	//
	//  TCHAR* szFileName
	//    File name which contains the keys and values to be read into the data store base key.
	//
	STDMETHOD(LoadFromFile)(
		CONST TCHAR*	szBaseKey,
		CONST TCHAR*	szFileName ) = 0;


	//
	// IDataStore::SaveToFile
	//
	// Saves key and sub keys into a file.
	//
	// Parameters:
	//	TCHAR* szBaseKey,
	//    Base key to read
	//	szFileName
	//    File name of file where key data is to be stored.
	//
	STDMETHOD(SaveToFile)(
		CONST TCHAR*	szBaseKey,
		CONST TCHAR*	szFileName ) = 0;

	//
	// IDataStore::LoadFromTextBuffer
	//
	// Creates keys from buffer in the same format as the text files (ANSI only).
	//
	// Parameters:
	//	szBaseKey
	//		Base key to store new keys under.
	//	pBuffer
	//		Pointer to buffer formatted the same a text files
	//	dwBufferSz
	//		Size of the buffer in bytes.
	//
	STDMETHOD(LoadFromTextBuffer)(
		CONST TCHAR*	szBaseKey,
		CONST TCHAR*	pBuffer,
		DWORD			dwBufferSz ) = 0;

	//
	// IDataStore::SaveToTextBuffer
	//
	// Saves key and sub keys to buffer in same format as text files.
	//
	// Parameters:
	//	szBaseKey
	//		Base key to read.
	//	pBuffer
	//		Pointer to buffer to receive data
	//	dwBufferSz
	//		Pointer to buffer size.
	//
	STDMETHOD(SaveToTextBuffer)(
		CONST TCHAR*	szBaseKey,
		LPVOID			pBuffer,
		PDWORD			pdwBufferSz ) = 0;
};



///////////////////////////////////////////////////////////////////////////////////////////
//Helper functions
///////////////////////////////////////////////////////////////////////////////////////////

/*
inline void SetLong( VARIANT& v, long lValue )
{
	v.vt = ZVT_LONG;
	v.lVal = lValue;
}
*/
/*
inline HRESULT SetLong( IDataStore* pIDS, const TCHAR* szKey, long lValue )
{
	VARIANT v;
	v.vt = ZVT_LONG;
	v.lVal = lValue;
	return pIDS->SetKey( szKey, &v, sizeof(lValue) );
}
*/
/*
inline void SetString( VARIANT& v, char* szString )
{
	v.vt = ZVT_LPTSTR;
	v.byref = szString;
}
*/
/*
inline HRESULT SetString( IDataStore *pIDS, const TCHAR *szKey, TCHAR *szString )
{
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = szString;
	return pIDS->SetKey( szKey, &v, lstrlen(szString) + 1 );
}
*/
/*
inline void SetBlob( VARIANT& v, PVOID pData )
{
	v.vt = ZVT_BLOB;
	v.byref = pData;
}
*/
/*
inline HRESULT SetBlob( IDataStore* pIDS, const TCHAR *szKey, PVOID pData, DWORD dwSize )
{
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = pData;
	return pIDS->SetKey( szKey, &v, dwSize );
}
*/
/*
inline HRESULT GetLong( IDataStore* pIDS, const TCHAR* szKey, long& lValue )
{
	VARIANT v;
	HRESULT hr = pIDS->GetKey( szKey, &v, NULL );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LONG )
		{
			lValue = v.lVal;
			return S_OK;
		}
		else
			return E_FAIL;
	}
	return hr;
}
*/
/*
inline HRESULT GetString( IDataStore* pIDS, const TCHAR* szKey, TCHAR* szString, DWORD* pdwSize )
{
	VARIANT v;
	v.vt = ZVT_LPTSTR;
	v.byref = (PVOID) szString;
	HRESULT hr = pIDS->GetKey( szKey, &v, pdwSize );
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_LPTSTR )
			return S_OK;
		else
			return E_FAIL;
	}
	return hr;
}
*/
/*
inline HRESULT GetBlob( IDataStore* pIDS, const TCHAR *szKey, PVOID pData, DWORD* pdwSize )
{
	VARIANT v;
	v.vt = ZVT_BLOB;
	v.byref = pData;
	HRESULT hr = pIDS->GetKey( szKey, &v, pdwSize);
	if ( SUCCEEDED(hr) )
	{
		if ( v.vt == ZVT_BLOB )
			return S_OK;
		else
			return E_FAIL;
	}
	return hr;
}
*/

#endif // _DATASTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\conduit.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Conduit.h
 *
 * Contents:	DataStore interfaces
 *
 *****************************************************************************/

#ifndef _CONDUIT_H_
#define _CONDUIT_H_

// {BD0BA6D1-7079-11d3-8847-00C04F8EF45B}
DEFINE_GUID(IID_IConnectee,
0xbd0ba6d1, 0x7079, 0x11d3, 0x88, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{BD0BA6D1-7079-11d3-8847-00C04F8EF45B}"))
IConnectee : public IUnknown
{
    STDMETHOD(Connected)(DWORD dwChannel, DWORD evSend, DWORD evReceive, LPVOID pCookie, DWORD dweReason) = 0;
    STDMETHOD(ConnectFailed)(LPVOID pCookie, DWORD dweReason) = 0;
    STDMETHOD(Disconnected)(DWORD dwChannel, DWORD dweReason) = 0;
};

// {BD0BA6CF-7079-11d3-8847-00C04F8EF45B}
DEFINE_GUID(IID_IConduit,
0xbd0ba6cf, 0x7079, 0x11d3, 0x88, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{BD0BA6CF-7079-11d3-8847-00C04F8EF45B}"))
IConduit : public IUnknown
{
    STDMETHOD(Connect)(IConnectee *pCtee, LPVOID pCookie = NULL) = 0;
    STDMETHOD(Reconnect)(DWORD dwChannel, LPVOID pCookie = NULL) = 0;
    STDMETHOD(Disconnect)(DWORD dwChannel) = 0;
};


// reasons - add new ones as needed
enum
{
    ZConduit_ConnectGeneric
};

enum
{
    ZConduit_FailGeneric
};

enum
{
    ZConduit_DisconnectGeneric,
    ZConduit_DisconnectServiceStop
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\clientimpl.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ClientImpl.h
 *
 * Contents:	Template implementations for common interfaces and classes.
 *
 *****************************************************************************/

#ifndef __CLIENTIMPL_H
#define __CLIENTIMPL_H

#include "ClientIdl.h"
#include "LobbyDataStore.h"
#include "EventQueue.h"
#include "ZoneEvent.h"
#include "Timer.h"
#include "ZoneShell.h"
#include "KeyName.h"
#include "UserPrefix.h"
#include "ZoneString.h"
#include "ZoneProxy.h"


//////////////////////////////////////////////////////////////////////////////
// IShellComponentImpl
//////////////////////////////////////////////////////////////////////////////

template <class T>
class ATL_NO_VTABLE IZoneShellClientImpl : public IZoneShellClient
{

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
	{
		ASSERT(pIZoneShell);
		T* pT = static_cast<T*>(this);

		m_szDataStoreKey = szKey;
		m_pIZoneShell = pIZoneShell;

		pIZoneShell->QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &m_pIEventQueue );
		pIZoneShell->QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &m_pIResourceManager );
		pIZoneShell->QueryService( SRVID_LobbyDataStore, IID_ILobbyDataStore, (void**) &m_pILobbyDataStore );
		pIZoneShell->QueryService( SRVID_TimerManager, IID_ITimerManager, (void**) &m_pITimerManager );
		pIZoneShell->QueryService( SRVID_DataStoreObjects, IID_IDataStore, (void**) &m_pIDSObjects );
		pIZoneShell->QueryService( SRVID_DataStoreUI, IID_IDataStore, (void**) &m_pIDSUI);
		pIZoneShell->QueryService( SRVID_DataStorePreferences, IID_IDataStore, (void**) &m_pIDSPreferences );
		pIZoneShell->QueryService( SRVID_DataStoreManager, IID_IDataStoreManager, (void**) &m_pIDataStoreManager );

		// if we're given an Event Queue, try and connect it up
		CComPtr<IEventClient> pEventClient;
		pT->QueryInterface(__uuidof(IEventClient), (void**)&pEventClient);
		if ( m_pIEventQueue && pEventClient )
		{
			m_pIEventQueue->RegisterClient(pEventClient,NULL);		
		}

		SetGroupId( dwGroupId);

        m_fRunning = true;
		return S_OK;
	}

	STDMETHOD(Close)()
	{
		T* pT = static_cast<T*>(this);

		// unregister event clients
		CComPtr<IEventClient> pEventClient;
		pT->QueryInterface(__uuidof(IEventClient), (void**) &pEventClient);
		if ( m_pIEventQueue && pEventClient )
		{
			m_pIEventQueue->UnregisterClient(pEventClient,NULL);		
		}

		// release ZoneShell objects
		m_pIZoneShell.Release();
		m_pIEventQueue.Release();
		m_pILobbyDataStore.Release();
		m_pIResourceManager.Release();
		m_pITimerManager.Release();
		m_pIDSObjects.Release();
		m_pIDSUI.Release();
		m_pIDSPreferences.Release();
		m_pIDataStoreManager.Release();

        m_fRunning = false;
		return S_OK;
	}

	STDMETHOD(SetGroupId)(DWORD dwGroupId)
	{
		m_dwGroupId = dwGroupId;
		return S_OK;
	}


// IZoneShellClientImpl
public:
	IZoneShellClientImpl()
	{
		m_dwGroupId = ZONE_NOGROUP;
        m_fRunning = false;
	}

	IZoneShell*			ZoneShell()				{ return m_pIZoneShell; }
	IEventQueue*		EventQueue()			{ return m_pIEventQueue; }
	ILobbyDataStore*	LobbyDataStore()		{ return m_pILobbyDataStore; }
	IResourceManager*	ResourceManager()		{ return m_pIResourceManager; }
	ITimerManager*		TimerManager()			{ return m_pITimerManager; }
	IDataStoreManager*	DataStoreManager()		{ return m_pIDataStoreManager; }
	IDataStore*			DataStoreConfig()		{ return m_pIDSObjects; }
	IDataStore*			DataStoreUI()			{ return m_pIDSUI; }
	IDataStore*			DataStorePreferences()	{ return m_pIDSPreferences; }

	const ZoneString&  GetDataStoreKey()		{ return m_szDataStoreKey; }
	DWORD GetGroupId()							{ return m_dwGroupId; }
	DWORD GetUserId()							{ return LobbyDataStore()->GetUserId(NULL); }

	DWORD GetHostId(int nTable)
	{
		CComPtr<IDataStore> pIDS;
		HRESULT hr = LobbyDataStore()->GetDataStore( nTable, ZONE_NOUSER, &pIDS );
		if ( FAILED(hr) )
			return ZONE_INVALIDUSER;
		DWORD dwHostId = 0;
		pIDS->GetLong( key_HostId, (long*) &dwHostId);
		return dwHostId;
	}

	bool IsUserHost(int nTable, DWORD User = ZONE_INVALIDUSER)
	{
		if ( User == ZONE_INVALIDUSER ) 
			User = GetUserId();
		return (GetHostId(nTable) == User);
	}

	bool IsUserHost(IDataStore* pIDS, DWORD User = ZONE_INVALIDUSER)
	{
		if ( User == ZONE_INVALIDUSER ) 
			User = GetUserId();
		DWORD dwHostId = 0;
		pIDS->GetLong( key_HostId, (long*) &dwHostId);
		return (dwHostId == User);
	}

	void ZoneProxyCommand( const TCHAR* szCmd, const TCHAR* szArg1, const TCHAR* szArg2 )
	{
		CComBSTR bstrCmd  = szCmd;
		CComBSTR bstrArg1 = szArg1;
		CComBSTR bstrArg2 = szArg2;
		CComBSTR bstrOut;
		long	 lCode;
		CComPtr<IZoneProxy> p;
		HRESULT hr = CoCreateInstance( CLSID_zProxy, NULL, CLSCTX_LOCAL_SERVER, IID_IZoneProxy, (void**) &p );
		if ( FAILED(hr) )
			return;
		p->Command( bstrCmd, bstrArg1, bstrArg2, &bstrOut, &lCode );
	}

protected:
	ZoneString  m_szDataStoreKey;
	DWORD		m_dwGroupId;
    bool        m_fRunning;

	CComPtr<IZoneShell>			m_pIZoneShell;
	CComPtr<IEventQueue>		m_pIEventQueue;
	CComPtr<ILobbyDataStore>	m_pILobbyDataStore;
	CComPtr<IResourceManager>	m_pIResourceManager;
	CComPtr<ITimerManager>		m_pITimerManager;
	CComPtr<IDataStoreManager>	m_pIDataStoreManager;
	CComPtr<IDataStore>			m_pIDSObjects;
	CComPtr<IDataStore>			m_pIDSUI;
	CComPtr<IDataStore>			m_pIDSPreferences;
};


//////////////////////////////////////////////////////////////////////////////
// IEventClientImpl
//////////////////////////////////////////////////////////////////////////////

template <class T>
class ATL_NO_VTABLE IEventClientImpl : public IEventClient
{
public:

	// IEventClient
	STDMETHOD(ProcessEvent)(DWORD dwPriority, DWORD	dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2, void* pCookie )
	{
		T* pT = static_cast<T*>(this);
		pT->ProcessEvent( dwPriority, dwEventId, dwGroupId, dwUserId, dwData1, dwData2, pCookie);
		return S_OK;
	}
};

#define BEGIN_EVENT_MAP() \
public: \
	virtual void ProcessEvent(DWORD dwPriority, DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2, void* pCookie, DWORD dwMsgMapID = 0) \
	{ \
		dwPriority; \
		dwEventId; \
		dwGroupId; \
		dwUserId; \
		dwData1; \
		dwData2; \
		pCookie; \
		switch(dwMsgMapID) \
		{ \
		case 0:

#define EVENT_HANDLER(event, func) \
	if(dwEventId == event) \
	{ \
		func(dwEventId, dwGroupId, dwUserId); \
		return; \
	}

#define EVENT_HANDLER_WITH_DATA(event, func) \
	if(dwEventId == event) \
	{ \
		func(dwEventId, dwGroupId, dwUserId, dwData1, dwData2); \
		return; \
	}

#define EVENT_HANDLER_WITH_BUFFER(event, func) \
	if(dwEventId == event) \
	{ \
		func(dwEventId, dwGroupId, dwUserId, (void*) dwData1, dwData2); \
		return; \
	}

#define EVENT_HANDLER_WITH_IUNKNOWN(event, func) \
	if(dwEventId == event) \
	{ \
		func(dwEventId, dwGroupId, dwUserId, (IUnknown*) dwData1, dwData2); \
		return; \
	}

#define CHAIN_EVENT_MAP(theChainClass) \
	{ \
		theChainClass::ProcessEvent( dwPriority, dwEventId, dwGroupId, dwUserId, dwData1, dwData2, pCookie, dwMsgMapID); \
		return; \
	}
#define END_EVENT_MAP() \
			break; \
		default: \
			ATLTRACE2(atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
			ATLASSERT(FALSE); \
			break; \
		} \
		return; \
	}


/*////////////////////////////////////////////////////////////////////////////
// IZoneFrameWindowImpl

This is verging on a hack. We'd like to make our main frame windows
replaceable. So we're accessing them as COM objects. But I'm not aware of an
easy way to use ATL to create a top level window in this way. Normally
your main frame is stack variable in the main thread, and ATL ties this in
with translating messages and UI updates. So this interface just gives us
the hooks we need to separate the main thread and message pump from the
main window.

////////////////////////////////////////////////////////////////////////////*/

template <class T>
class ATL_NO_VTABLE IZoneFrameWindowImpl : public IZoneFrameWindow
{

// IZoneFrameWindow
public:
	STDMETHOD_(HWND,ZCreateEx)(HWND hWndParent, LPRECT lpRect, TCHAR* szTitle, DWORD dwStyle, DWORD dwExStyle)
	{
		T* pT = static_cast<T*>(this);
		pT->CreateEx(hWndParent, lpRect, szTitle, dwStyle, dwExStyle );
		return pT->m_hWnd;
	}

	STDMETHOD_(HWND,ZGetHWND)()
	{
		T* pT = static_cast<T*>(this);
        if(pT->IsWindow())
		    return pT->m_hWnd;
        else
            return NULL;
	}

	STDMETHOD_(BOOL,ZShowWindow)(int nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		return pT->ShowWindow(nCmdShow);
	}

	STDMETHOD_(BOOL,ZPreTranslateMessage)(MSG* pMsg)
	{
		T* pT = static_cast<T*>(this);
		if ( pT->IsWindow() )
			return pT->PreTranslateMessage(pMsg);
		else
			return FALSE;
	}
	STDMETHOD_(BOOL,ZOnIdle)(int nIdleCount)
	{
		T* pT = static_cast<T*>(this);
		if ( pT->IsWindow() )
			return pT->OnIdle(nIdleCount);
		else
			return FALSE;
	}
	STDMETHOD_(BOOL,ZDestroyWindow)()
	{
		T* pT = static_cast<T*>(this);
		if ( pT->IsWindow() )
			return pT->DestroyWindow();
		else
			return FALSE;
	}
	STDMETHOD_(BOOL,ZAddMenu)(HWND hWnd)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIAddMenu(hWnd);
	}
	STDMETHOD_(BOOL,ZAddToolBar)(HWND hWnd)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIAddToolBar(hWnd);
	}
	STDMETHOD_(BOOL,ZAddStatusBar)(HWND hWnd)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIAddStatusBar(hWnd);
	}
	STDMETHOD_(BOOL,ZAddWindow)(HWND hWnd)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIAddWindow(hWnd);
	}
	STDMETHOD_(BOOL,ZEnable)(int nID, BOOL bEnable, BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIEnable(nID,bEnable,bForceUpdate);
	}
	STDMETHOD_(BOOL,ZSetCheck)(int nID, int nCheck, BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UISetCheck(nID,nCheck,bForceUpdate);
	}
	STDMETHOD_(BOOL,ZToggleCheck)(int nID, BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIToggleCheck(nID,bForceUpdate);
	}
	STDMETHOD_(BOOL,ZSetRadio)(int nID, BOOL bRadio, BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UISetRadio(nID,bRadio,bForceUpdate);
	}
	STDMETHOD_(BOOL,ZSetText)(int nID, LPCTSTR lpstrText, BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UISetText(nID,lpstrText,bForceUpdate);
	}
	STDMETHOD_(BOOL,ZSetState)(int nID, DWORD dwState)
	{
		T* pT = static_cast<T*>(this);
		return pT->UISetState(nID,dwState);
	}
	STDMETHOD_(DWORD,ZGetState)(int nID)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIGetState(nID);
	}
	STDMETHOD_(BOOL,ZUpdateMenu)(BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIUpdateMenu(bForceUpdate);
	}
	STDMETHOD_(BOOL,ZUpdateToolBar)(BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIUpdateToolBar(bForceUpdate);
	}
	STDMETHOD_(BOOL,ZUpdateStatusBar)(BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIUpdateStatusBar(bForceUpdate);
	}
	STDMETHOD_(BOOL,ZUpdateChildWnd)(BOOL bForceUpdate)
	{
		T* pT = static_cast<T*>(this);
		return pT->UIUpdateChildWnd(bForceUpdate);
	}
};


#endif //__CLIENTIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\eventqueue.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		EventQueue.h
 *
 * Contents:	EventQueue interfaces
 *
 *****************************************************************************/

#ifndef _EVENTQUEUE_H_
#define _EVENTQUEUE_H_


///////////////////////////////////////////////////////////////////////////////
// IEventClient
///////////////////////////////////////////////////////////////////////////////

// {A494872E-B039-11d2-8B0F-00C04F8EF2FF}
DEFINE_GUID(IID_IEventClient,
0xa494872e, 0xb039, 0x11d2, 0x8b, 0xf, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{A494872E-B039-11d2-8B0F-00C04F8EF2FF}"))
IEventClient : public IUnknown
{
	//
	// IEventClient::ProcessEvents
	//
	// Called by IEventQueue::ProcessEvents to handle events.  If the interface
	// owns the event, then returning S_OK sends the event to the other handlers
	// and S_FALSE prevents further processing.
	//
	// Parameters:
	//	dwPriority
	//		Priority level of event, 0 = highest priority
	//	dwEventId
	//		Id of event
	//	dwGroupId
	//		Id of group associated with event
	//	dwUserId
	//		Id of user associated with event
	//	pData
	//		Data associated with event.  If (pData != NULL) and (dwDataLen == 0)
	//		then pData is assumed to be DWORD instead of a pointer to a blob.
	//	dwDataLen
	//		Length of data
	//	pCookie
	//		Application pointer specified at registration
	//
	STDMETHOD(ProcessEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2,
		void*	pCookie ) = 0;	
};


///////////////////////////////////////////////////////////////////////////////
// IEventQueue
///////////////////////////////////////////////////////////////////////////////

// {A494872C-B039-11d2-8B0F-00C04F8EF2FF}
DEFINE_GUID(IID_IEventQueue, 
0xa494872c, 0xb039, 0x11d2, 0x8b, 0xf, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{A494872C-B039-11d2-8B0F-00C04F8EF2FF}"))
IEventQueue : public IUnknown
{

	//
	// IEventQueue::RegisterClient
	//
	// Adds the specified IEventClient interface to the event queue.
	//
	// Parameters:
	//	pIEventClient
	//		Pointer to client interface being registered
	//	pCookie
	//		Application data sent to handler with the event
	//
	STDMETHOD(RegisterClient)(
		IEventClient*	pIEventClient,
		void*			pCookie ) = 0;


	//
	// IEventQeueue::UnregisterClient
	//
	// Removes the specified IEventClient interface from the event queue.
	//
	// Parameters:
	//	pIEventClient
	//		Pointer to client interface being registered
	//	pCookie
	//		Pointer to application data originally specified at registration
	//
	STDMETHOD(UnregisterClient)(
		IEventClient*	pIEventClient,
		void*			pCookie ) = 0;


	//
	// IEventQueue::RegisterOwner
	//
	// Adds the specified IEventClient interface to the event queue
	// as the events owner.  Each event can have one owner that receives
	// the event first and decides if it is sent to the other handlers.
	//
	// If the same IEventClient,Cookie pair is registered as a generic
	// handler then it is only called once as the owner.
	//
	// Parameters:
	//	dwEventId
	//		Id of event
	//	pIEventClient
	//		Pointer to client interface being registered
	//	pCookie
	//		Application data sent to handler with the event
	//
	STDMETHOD(RegisterOwner)(
		DWORD			dwEventId,
		IEventClient*	pIEventClient,
		void*			pCookie ) = 0;


	//
	// IEventQeueue::UnregisterOwner
	//
	// Removes the specified IEventClient interface as the event's owner.
	//
	// Parameters:
	//	dwEventId
	//		Id of event.
	//	pIEventClient
	//		Pointer to client interface being registered
	//	pCookie
	//		Pointer to application data originally specified at registration
	//
	STDMETHOD(UnregisterOwner)(
		DWORD			dwEventId,
		IEventClient*	pIEventClient,
		void*			pCookie ) = 0;


	//
	// IEventQueue::PostEvent
	//
	// Place specified event onto the event queue.
	//
	// Parameters:
	//	dwPriority
	//		Priority level of event, 0 = highest priority
	//	dwEventId
	//		Id of event
	//	dwGroupId
	//		Id of group associated with event
	//	dwUserId
	//		Id of user associated with event
	//	dwData1
	//		Data item 1 associated with event
	//	dwData2
	//		Data item 2 associated with event
	//
	STDMETHOD(PostEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1 = 0,
		DWORD	dwData2 = 0 ) = 0;


	//
	// IEventQueue::PostEventWithBuffer
	//
	// Place specified event onto the event queue, copy associated data buffer onto the queue.
	//
	// Parameters:
	//	dwPriority
	//		Priority level of event, 0 = highest priority
	//	dwEventId
	//		Id of event
	//	dwGroupId
	//		Id of group associated with event
	//	dwUserId
	//		Id of user associated with event
	//	pData
	//		Pointer to data buffer.
	//	dwDataLen
	//		Number of bytes in data buffer.
	//
	STDMETHOD(PostEventWithBuffer)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		void*	pData = NULL,
		DWORD	dwDataLen = 0 ) = 0;

	//
	// IEventQueue::PostEventWithIUnknown
	//
	// Place specified event onto the event queue, copy associated interface onto the queue.
	//
	// Parameters:
	//	dwPriority
	//		Priority level of event, 0 = highest priority
	//	dwEventId
	//		Id of event
	//	dwGroupId
	//		Id of group associated with event
	//	dwUserId
	//		Id of user associated with event
	//	pIUnknown
	//		Pointer to IUnknown interface.
	//	dwData2
	//		Data item2 associated with event
	//
	STDMETHOD(PostEventWithIUnknown)(
		DWORD		dwPriority,
		DWORD		dwEventId,
		DWORD		dwGroupId,
		DWORD		dwUserId,
		IUnknown*	pIUnknown = NULL,
		DWORD		dwData2 = 0 ) = 0;


	//
	// IEventQueue::SetNotificationHandle
	//
	// Allows the application to specify a win32 syncronization event that is
	// signaled when an event is added to the queue.
	//
	// Parameters:
	//	hEvent
	//		Win32 syncronization event to signal
	//
	STDMETHOD(SetNotificationHandle)( HANDLE hEvent ) = 0;


	//
	// IEventQueue::SetWindowMessage
	//
	// Allows the application to specify a window message to post
	// when an event is added to the queue.
	//
	// Parameters:
	//	dwThreadId
	//		Thread to post message
	//	dwMsg
	//		Message id to post
	//	wParam
	//		first message parameter
	//	lParam
	//		second message parameter
	//
	//
	STDMETHOD(SetWindowMessage)( DWORD dwThreadId, DWORD Msg, WPARAM wParam, WPARAM lParam ) = 0;


	//
	// IEventQueue::DisableWindowMessage
	//
	// Turns off window message posting when an event is posted.
	//
	STDMETHOD(DisableWindowMessage)() = 0;


	//
	// IEventQueue::ProcessEvents
	//
	// Process a single event or all events in the queue.
	//
	// Parameters:
	//	bSingleEvent
	//		Boolean indicating if a single event should be processed (true) or
	//		the entire queue (false).
	//
	// Returns:
	//	ZERR_RECURSIVE	- Illegal recursive call detected.
	//	ZERR_EMPTY		- No more events to process.
	//
	STDMETHOD(ProcessEvents)( bool bSingleEvent ) = 0;


	//
	// IEventQueue::EventCount
	//
	// Return number of queued events
	//
	STDMETHOD_(long,EventCount)() = 0;


	//
	// IEventQueue::ClearQueue
	//
	// Removes all events from the queue without processing them
	//
	STDMETHOD(ClearQueue)() = 0;


	//
	// IEventQueue::EnableQueue
	//
	// If queue is disabled, all new posts are ignored.
	//
	// Parameters:
	//	bEnable
	//		Boolean indicating if the queue should be enabled (true) or disabled (false)
	//
	STDMETHOD(EnableQueue)( bool bEnable ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// EventQueue object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{A494872D-B039-11d2-8B0F-00C04F8EF2FF}")) CEventQueue ;

// {A494872D-B039-11d2-8B0F-00C04F8EF2FF}
DEFINE_GUID(CLSID_EventQueue,
0xa494872d, 0xb039, 0x11d2, 0x8b, 0xf, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\gameshell.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		GameShell.h
 *
 * Contents:	Game shell interfaces
 *
 *****************************************************************************/

#ifndef _GAMESHELL_H_
#define _GAMESHELL_H_

#include "ClientIdl.h"
#include "LobbyDataStore.h"
#include "EventQueue.h"
#include "ZoneEvent.h"
#include "Timer.h"
#include "ZoneShell.h"
#include "ResourceManager.h"

///////////////////////////////////////////////////////////////////////////////
// IGameGame
///////////////////////////////////////////////////////////////////////////////
typedef void * ZCGame;

// {BD0BA6CD-7079-11d3-8847-00C04F8EF45B}
DEFINE_GUID( IID_IGameGame,
0xbd0ba6cd, 0x7079, 0x11d3, 0x88, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{BD0BA6CD-7079-11d3-8847-00C04F8EF45B}"))
IGameGame : public IUnknown
{
    STDMETHOD_(ZCGame, GetGame)() = 0;

    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars) = 0;
    STDMETHOD(GameOverReady)() = 0;

    STDMETHOD(GamePromptResult)(DWORD nButton, DWORD dwCookie) = 0;
    STDMETHOD_(HWND, GetWindowHandle)() = 0;

    STDMETHOD(ShowScore)() = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IGameShell
///////////////////////////////////////////////////////////////////////////////

// {E6C04FDB-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID( IID_IGameShell, 
0xe6c04fdb, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{E6C04FDB-5D25-11d3-8846-00C04F8EF45B}"))
IGameShell : public IUnknown
{
    STDMETHOD_(IZoneShell*, GetZoneShell)() = 0;
	STDMETHOD_(IResourceManager*, GetResourceManager)() = 0;
	STDMETHOD_(ILobbyDataStore*, GetLobbyDataStore)() = 0;
	STDMETHOD_(ITimerManager*, GetTimerManager)() = 0;
	STDMETHOD_(IDataStoreManager*, GetDataStoreManager)() = 0;
	STDMETHOD_(IDataStore*, GetDataStoreConfig)() = 0;
	STDMETHOD_(IDataStore*, GetDataStoreUI)() = 0;
	STDMETHOD_(IDataStore*, GetDataStorePreferences)() = 0;

    STDMETHOD(SendGameMessage)(int16 table, uint32 messageType, void* message, int32 messageLen) = 0;
    STDMETHOD(ReceiveChat)(ZCGame pGame, ZUserID userID, TCHAR *szText, DWORD cchChars) = 0;
    STDMETHOD(GetUserName)(ZUserID userID, TCHAR *szName, DWORD cchChars) = 0;

    STDMETHOD(GameOver)(ZCGame pGame) = 0;
    STDMETHOD(GameOverPlayerReady)(ZCGame pGame, ZUserID userID) = 0;
    STDMETHOD(GameOverGameBegun)(ZCGame pGame) = 0;

    STDMETHOD(MyTurn)() = 0;

    STDMETHOD(ZoneAlert)(LPCTSTR szText, LPCTSTR szTitle = NULL, LPCTSTR szButton = NULL, bool fGameFatal = false, bool fZoneFatal = false) = 0;
    STDMETHOD(GamePrompt)(ZCGame pGame, LPCTSTR szText, LPCTSTR szTitle = NULL,
        LPCTSTR szButtonYes = NULL, LPCTSTR szButtonNo = NULL, LPCTSTR szButtonCancel = NULL,
        DWORD nDefault = 0, DWORD dwCookie = 0) = 0;

    STDMETHOD(GameCannotContinue)(ZCGame pGame) = 0;
    STDMETHOD(ZoneExit)() = 0;

    STDMETHOD(ZoneLaunchHelp)(LPCTSTR szTopic = NULL) = 0;

    // should not do anything in Release builds
    STDMETHOD_(void, ZoneDebugChat)(LPTSTR szText) = 0;
};


// useful only in zonecli-based components because of ZShellGameShell()
#ifdef DEBUG
#define DebugChat(t) (ZShellGameShell()->ZoneDebugChat(t))
#else
#define DebugChat(t)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\dplayhelp.h ===
/*******************************************************************************

	DPlayHelp.h
	
	DirectPlay helper functions
		
*******************************************************************************/


#ifndef _DPLAYHELP_
#define _DPLAYEHELP_

#include "ZoneDef.h"
#include <dplay.h>
#include <dplobby.h>
#include <lobbyMsg.h>
#include <datastore.h>
//
// Create DirectPlayLobby object via CoCreateInstance
//
LPDIRECTPLAYLOBBYA ZONECALL DirectPlayLobbyCreate();

//
// Retrieve EXE path from registry
//
void ZONECALL DirectPlayLobbyGetExePath( TCHAR* szAppName, TCHAR* szExePath );

//
// Create DirectPlayLobby address structure
//
HRESULT ZONECALL DirectPlayLobbyCreateAddress(
					LPDIRECTPLAYLOBBYA	lpDPlayLobby,
					LPGUID				lpguidServiceProvider,
					LPGUID				lpguidAddressType,
					LPSTR				lpszAddressText,
					LPVOID*				lplpAddress,
					LPDWORD				lpdwAddressSize );

//
// Launch a DirectPlayLobby application
//
HRESULT ZONECALL DirectPlayLobbyRunApplication(
					LPDIRECTPLAYLOBBYA	lpDPlayLobby,
					LPGUID				lpguidApplication,
					LPGUID				lpguidInstance,
					LPGUID				lpguidServiceProvider,
					LPVOID				lpAddress,
					DWORD				dwAddressSize,
					LPSTR				lpszSessionName,
					DWORD				dwSessionFlags,
					LPSTR				lpszPlayerName,
					DWORD				dwCurrentPlayers,
					DWORD				dwMaxPlayers,
					BOOL				bHostSession,
					DWORD*				pdwAppId,
					ZPresetData*	 	presetData);


//These are here for a lack of a better place
ZLPMsgSettings * GetPresetData(IDataStore* pIDS);
HRESULT GetPresetText(IDataStore* pIDS,char * szDescription);
HRESULT GetPresetText(IDataStore* pIDS,char * szDescription,CONST TCHAR** arKeys, long nElts);
HRESULT SetPresetText(IDataStore* pIDS,char * szDescription);
HRESULT SetPresetText(IDataStore* pIDS,char * szDescription,CONST TCHAR** arKeys, long nElts);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\icwcfg.h ===
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996 - 97

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
        and if it has been run before.  It optionally will start
        either the full or manual path of ICW if it is insalled
        but has not been run before.

  History:  10/22/96    Created
        10/24/96    Added defines and typedefs
        2/25/97     Added CreateDirectoryService -- jmazner
        4/24/97     Removed InetCreate*, these are now owned
                    by the Account Manager -- jmazner

  Support:  This header file (and INETCFG.DLL) is supported by the
            Internet Connection Wizard team (alias icwcore).  Please
            do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICW_REGKEYCOMPLETED TEXT("Completed")
#define ICW_REGKEYERROR     TEXT("ICWError")

// Maximum field lengths
#define ICW_MAX_ACCTNAME    256
#define ICW_MAX_PASSWORD    256 // PWLEN
#define ICW_MAX_LOGONNAME   256 // UNLEN
#define ICW_MAX_SERVERNAME  64
#define ICW_MAX_RASNAME     256 // RAS_MaxEntryName
#define ICW_MAX_EMAILNAME   64
#define ICW_MAX_EMAILADDR   128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS     0x0001

#define ICW_LAUNCHFULL      0x0100
#define ICW_LAUNCHMANUAL    0x0200
#define ICW_USE_SHELLNEXT   0x0400
#define ICW_FULL_SMARTSTART 0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT     0x0001
#define ICW_MANUALPRESENT   0x0002
#define ICW_ALREADYRUN      0x0004

#define ICW_LAUNCHEDFULL    0x0100
#define ICW_LAUNCHEDMANUAL  0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS     0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD   (WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD   (WINAPI *PFNSETSHELLNEXT) (CHAR *);

//
// external function declarations
//
DWORD   WINAPI CheckConnectionWizard(DWORD, LPDWORD);
DWORD   WINAPI SetShellNextA(CHAR *);
DWORD   WINAPI SetShellNextW(WCHAR *);

#ifdef UNICODE
#define SetShellNext  SetShellNextW
#else
#define SetShellNext  SetShellNextA
#endif


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\graphicalacc.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		GraphicalAcc.h
 *
 * Contents:	Graphical Accessibility interfaces
 *
 *****************************************************************************/

#ifndef _GRAPHICALACC_H_
#define _GRAPHICALACC_H_

#include "ZoneShell.h"
#include "AccessibilityManager.h"


///////////////////////////////////////////////////////////////////////////////
// GraphicalAccessibility Object
///////////////////////////////////////////////////////////////////////////////

// {B12D3E63-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(CLSID_GraphicalAccessibility, 
0xb12d3e63, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

class __declspec(uuid("{B12D3E63-9681-11d3-884D-00C04F8EF45B}")) CGraphicalAccesibility;


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

#define ZACCESS_fGraphical      0x1000
#define ZACCESS_rc              0x2000


///////////////////////////////////////////////////////////////////////////////
// GACCITEM structure
///////////////////////////////////////////////////////////////////////////////

struct GACCITEM : public __accbase
{
    // Sets whether rects need to be drawn for this item when it is focused / drag originated
    bool fGraphical;

    // The rect for the item
    RECT rc;
};


///////////////////////////////////////////////////////////////////////////////
// IGraphicallyAccControl
///////////////////////////////////////////////////////////////////////////////

// {09BAD4A3-980C-11d3-87ED-00AA00446FD9}
DEFINE_GUID(IID_IGraphicallyAccControl, 
0x9bad4a3, 0x980c, 0x11d3, 0x87, 0xed, 0x0, 0xaa, 0x0, 0x44, 0x6f, 0xd9);

interface __declspec(uuid("{09BAD4A3-980C-11d3-87ED-00AA00446FD9}"))
IGraphicallyAccControl : public IAccessibleControl
{
    // additional functions - there can only be one focus rect and one drag rect at a time
    // so the old one should be automatically undrawn when these are called
    // called with NULL prc to indicate no rect of the type should be visible
    STDMETHOD_(void, DrawFocus)(RECT *prc, long nIndex, void *pvCookie) = 0;
    STDMETHOD_(void, DrawDragOrig)(RECT *prc, long nIndex, void *pvCookie) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IGraphicalAccessibility
///////////////////////////////////////////////////////////////////////////////

// {09BAD4A2-980C-11d3-87ED-00AA00446FD9}
DEFINE_GUID(IID_IGraphicalAccessibility, 
0x9bad4a2, 0x980c, 0x11d3, 0x87, 0xed, 0x0, 0xaa, 0x0, 0x44, 0x6f, 0xd9);

interface __declspec(uuid("{09BAD4A2-980C-11d3-87ED-00AA00446FD9}"))
IGraphicalAccessibility : public IAccessibility
{
    // pseudo-overloaded functions with GACCITEM, etc.
    STDMETHOD(InitAccG)(IGraphicallyAccControl *pGAC, HWND hWnd, UINT nOrdinal, void *pvCookie = NULL) = 0;

    STDMETHOD(PushItemlistG)(GACCITEM *pItems, long cItems, long nFirstFocus = 0, bool fByPosition = true, HACCEL hAccel = NULL) = 0;
    STDMETHOD(AlterItemG)(DWORD rgfWhat, GACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(GetItemlistG)(GACCITEM *pItems, long cItems, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(GetItemG)(GACCITEM *pItem, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    // additional functions
    STDMETHOD(ForceRectsDisplayed)(bool fDisplay = TRUE) = 0;
    STDMETHOD_(long, GetVisibleFocus)(long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(long, GetVisibleDragOrig)(long nLayer = ZACCESS_TopLayer) = 0;

    // additional CGraphicalAccessibilityImpl utility functions
    STDMETHOD_(bool, IsItemVisiblyFocused)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD_(bool, IsItemVisiblyDragOrig)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD_(bool, IsItemGraphical)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(GetItemRect)(RECT *prc, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;

    STDMETHOD(SetItemGraphical)(bool fGraphical, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
    STDMETHOD(SetItemRect)(RECT *prc, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// CGraphicalAccessibilityImpl
///////////////////////////////////////////////////////////////////////////////

template <class T>
class ATL_NO_VTABLE CGraphicalAccessibilityImpl : public IGraphicalAccessibility
{
    // same as CAccessibilityImpl
    DECLARE_ACC_IS_FUNC(IsItemFocused, GetFocus)
    DECLARE_ACC_IS_FUNC(IsItemDragOrig, GetDragOrig)

    DECLARE_ACC_ACCESS_FUNC(long, GetItemID, wID, ZACCESS_InvalidCommandID)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemTabstop, fTabstop, false)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemEnabled, fEnabled, false)
    DECLARE_ACC_ACCESS_FUNC(bool, IsItemVisible, fVisible, false)
    DECLARE_ACC_ACCESS_FUNC(DWORD, GetItemAccelBehavior, eAccelBehavior, 0xffffffff)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowUp, nArrowUp, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowDown, nArrowDown, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowLeft, nArrowLeft, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemArrowRight, nArrowRight, ZACCESS_ArrowDefault)
    DECLARE_ACC_ACCESS_FUNC(DWORD, GetItemWantKeys, rgfWantKeys, 0xffffffff)
    DECLARE_ACC_ACCESS_FUNC(long, GetItemGroupFocus, nGroupFocus, ZACCESS_InvalidItem)
    DECLARE_ACC_ACCESS_FUNC(void *, GetItemCookie, pvCookie, NULL)

    DECLARE_ACC_SET_FUNC(SetItemEnabled, bool, fEnabled)
    DECLARE_ACC_SET_FUNC(SetItemVisible, bool, fVisible)
    DECLARE_ACC_SET_FUNC(SetItemAccelBehavior, DWORD, eAccelBehavior)
    DECLARE_ACC_SET_FUNC(SetItemWantKeys, DWORD, rgfWantKeys)
    DECLARE_ACC_SET_FUNC(SetItemGroupFocus, long, nGroupFocus)
    DECLARE_ACC_SET_FUNC(SetItemCookie, void*, pvCookie)

    STDMETHOD(SetItemArrows)(long nArrowUp, long nArrowDown, long nArrowLeft, long nArrowRight, DWORD rgfWhat, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        ACCITEM o;
        o.nArrowUp = nArrowUp;
        o.nArrowDown = nArrowDown;
        o.nArrowLeft = nArrowLeft;
        o.nArrowRight = nArrowRight;
        return AlterItem(rgfWhat & ZACCESS_AllArrows, &o, nItem, fByPosition, nLayer);
    }


    // specific to CGraphicalAccessibilityImpl
    DECLARE_ACC_IS_FUNC(IsItemVisiblyFocused, GetVisibleFocus)
    DECLARE_ACC_IS_FUNC(IsItemVisiblyDragOrig, GetVisibleDragOrig)

    STDMETHOD_(bool, IsItemGraphical)(long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        GACCITEM o;
        HRESULT hr = GetItemG(&o, nItem, fByPosition, nLayer);
        if(FAILED(hr))
            return false;

        return o.fGraphical;
    }

    STDMETHOD(GetItemRect)(RECT *prc, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        if(!prc)
            return E_INVALIDARG;

        GACCITEM o;
        HRESULT hr = GetItemG(&o, nItem, fByPosition, nLayer);
        if(FAILED(hr))
            return hr;

        *prc = o.rc;
        return S_OK;
    }

    STDMETHOD(SetItemGraphical)(bool fGraphical, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        GACCITEM o;
        o.fGraphical = fGraphical;
        return AlterItemG(ZACCESS_fGraphical, &o, nItem, fByPosition, nLayer);
    }

    STDMETHOD(SetItemRect)(RECT *prc, long nItem, bool fByPosition = true, long nLayer = ZACCESS_TopLayer)
    {
        GACCITEM o;
        o.rc = *prc;
        return AlterItemG(ZACCESS_rc, &o, nItem, fByPosition, nLayer);
    }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\inputmanager.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		InputManager.h
 *
 * Contents:	Input manager interfaces
 *
 *****************************************************************************/

#ifndef _INPUTMANAGER_H_
#define _INPUTMANAGER_H_

#include "ZoneShell.h"


///////////////////////////////////////////////////////////////////////////////
// InputManager Object
///////////////////////////////////////////////////////////////////////////////


// {F3A3837B-9636-11d3-884D-00C04F8EF45B}
DEFINE_GUID(CLSID_InputManager, 
0xf3a3837b, 0x9636, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

class __declspec(uuid("{F3A3837B-9636-11d3-884D-00C04F8EF45B}")) CInputManager;


///////////////////////////////////////////////////////////////////////////////
// IInputVKeyHandler
///////////////////////////////////////////////////////////////////////////////

// {B12D3E66-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IInputVKeyHandler, 
0xb12d3e66, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E66-9681-11d3-884D-00C04F8EF45B}"))
IInputVKeyHandler : public IUnknown
{
    // flags is just 'flags' from the KBDLLHOOKSTRUCT (i.e. bits 24-31 of lParam shifted down)
    STDMETHOD_(bool, HandleVKey)(UINT uMsg, DWORD vkCode, DWORD scanCode, DWORD flags, DWORD *pcRepeat, DWORD time) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IInputCharHandler
///////////////////////////////////////////////////////////////////////////////

// {B12D3E67-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IInputCharHandler, 
0xb12d3e67, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E67-9681-11d3-884D-00C04F8EF45B}"))
IInputCharHandler : public IUnknown
{
    STDMETHOD_(bool, HandleChar)(HWND *phWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD time) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IInputMouseHandler
///////////////////////////////////////////////////////////////////////////////

// {B12D3E68-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IInputMouseHandler, 
0xb12d3e68, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);


// The mouse handler is problematic.  There needs to be more resolution in specifying what you want to hook because
// there are way too many mouse events to a) generalize them into a single callback reasonably and
// b) degrade performance reasonably.
//
// I am going to not implement this for now because it needs more serious thought.
interface __declspec(uuid("{B12D3E68-9681-11d3-884D-00C04F8EF45B}"))
IInputMouseHandler : public IUnknown
{
    // If hWnd is NULL, x and y are in screen coordinates
    // otherwise they are in client coordinates of HWND
    // wParam is set to 0 for events received from a mouse hook,
    // otherwise it is the wParam of the message.
    STDMETHOD_(bool, HandleMouse)(HWND hWnd, UINT uMsg, long x, long y, WPARAM wParam, DWORD time) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IInputManager
///////////////////////////////////////////////////////////////////////////////

// {B12D3E65-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IInputManager, 
0xb12d3e65, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E65-9681-11d3-884D-00C04F8EF45B}"))
IInputManager : public IUnknown
{
    STDMETHOD(RegisterVKeyHandler)(IInputVKeyHandler *pIVKH, long nOrdinal, bool fGlobal = false) = 0;
    STDMETHOD(UnregisterVKeyHandler)(IInputVKeyHandler *pIVKH) = 0;

    STDMETHOD(RegisterCharHandler)(IInputCharHandler *pICH, long nOrdinal, bool fGlobal = false) = 0;
    STDMETHOD(UnregisterCharHandler)(IInputCharHandler *pICH) = 0;

    STDMETHOD(RegisterMouseHandler)(IInputMouseHandler *pIMH, long nOrdinal, bool fGlobal = false) = 0;
    STDMETHOD(UnregisterMouseHandler)(IInputMouseHandler *pIMH) = 0;

    STDMETHOD(ReleaseReferences)(IUnknown *pIUnk) = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\keyname.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		KeyNames.h
 *
 * Contents:	Data Store Key Names
 *
 *****************************************************************************/

#ifndef _KEYNAMES_H_
#define _KEYNAMES_H_

#include "ZoneDef.h"


//
// Macro to declare key names
//
#ifndef __INIT_KEYNAMES
	#define DEFINE_KEY(name)	extern "C" const TCHAR key_##name[]
#else
	#define DEFINE_KEY(name)	extern "C" const TCHAR key_##name[] = _T( #name )
#endif


//
// Key names
//
DEFINE_KEY( Zone );

DEFINE_KEY( Store );
DEFINE_KEY( FamilyName );
DEFINE_KEY( FriendlyName );
DEFINE_KEY( InternalName );
DEFINE_KEY( Server );
DEFINE_KEY( Port );
DEFINE_KEY( Lobby );
DEFINE_KEY( Genre );
DEFINE_KEY( Options );
DEFINE_KEY( Type );
DEFINE_KEY( User );
DEFINE_KEY( Name );
DEFINE_KEY( Id );
DEFINE_KEY( ClassId );
DEFINE_KEY( ClassId_Shadow);
DEFINE_KEY( Group );
DEFINE_KEY( MaxGroups );
DEFINE_KEY( NumUsers );
DEFINE_KEY( MaxUsers );
DEFINE_KEY( MinUsers );
DEFINE_KEY( DataStoreManager );
DEFINE_KEY( ResourceManager );
DEFINE_KEY( LobbyDataStore );
DEFINE_KEY( EventQueue );
DEFINE_KEY( core );
DEFINE_KEY( clsid );
DEFINE_KEY( srvid );
DEFINE_KEY( dll );
DEFINE_KEY( Address );
DEFINE_KEY( Suspended );
DEFINE_KEY( Rating );
DEFINE_KEY( GamesPlayed );
DEFINE_KEY( GamesAbandoned );
DEFINE_KEY( GameStatus );
DEFINE_KEY( Status );
DEFINE_KEY( Status_Shadow );
DEFINE_KEY( GameId );
DEFINE_KEY( HostId );
DEFINE_KEY( Guid );
DEFINE_KEY( Description );
DEFINE_KEY( LatencyIcon );
DEFINE_KEY( Latency );
DEFINE_KEY( Experience );
DEFINE_KEY( Launcher );
DEFINE_KEY( GameName );
DEFINE_KEY( GameDll );
DEFINE_KEY( HelpFile );
DEFINE_KEY( conduit );
DEFINE_KEY( ExeName );
DEFINE_KEY( ExeVersion );
DEFINE_KEY( RegKey );
DEFINE_KEY( RegPath );
DEFINE_KEY( RegVersion );
DEFINE_KEY( LaunchData );
DEFINE_KEY( colors );
DEFINE_KEY( Private );
DEFINE_KEY( BlockJoiners );
DEFINE_KEY( Password );
DEFINE_KEY( StartData );
DEFINE_KEY( ChatChannel );
DEFINE_KEY( LaunchAborted );
DEFINE_KEY( ServerIp );
DEFINE_KEY( SoftURL );
DEFINE_KEY( FrameWindow );

// millennium user info
DEFINE_KEY( ChatStatus );
DEFINE_KEY( PlayerNumber );
DEFINE_KEY( PlayerReady );
DEFINE_KEY( Language );
DEFINE_KEY( PlayerSkill );
// local (ZONE_NOUSER)
DEFINE_KEY( LocalChatStatus );
DEFINE_KEY( LocalLanguage );
DEFINE_KEY( LocalLCID );

DEFINE_KEY( ServiceUnavailable );
DEFINE_KEY( ServiceDowntime );

DEFINE_KEY( ChatAbility );
DEFINE_KEY( StatsAbility );

DEFINE_KEY( Version );
DEFINE_KEY( VersionNum );
DEFINE_KEY( VersionStr );
DEFINE_KEY( SetupToken );
DEFINE_KEY( BetaStr );

DEFINE_KEY( Icons );
DEFINE_KEY( LaunchpadIcon );

DEFINE_KEY( Red );
DEFINE_KEY( Yellow );
DEFINE_KEY( LtGreen );
DEFINE_KEY( Green );

DEFINE_KEY ( WindowManager );
DEFINE_KEY ( WindowRect );
DEFINE_KEY ( Upsell );
DEFINE_KEY ( AdURL );
DEFINE_KEY ( AdValid );
DEFINE_KEY ( IdealFromTop );
DEFINE_KEY ( BottomThresh );
DEFINE_KEY ( NetWaitMsgTime );
DEFINE_KEY ( AnimStartFrame );
DEFINE_KEY ( AnimFrameTime );
DEFINE_KEY ( AnimSize );
DEFINE_KEY ( IEPaneSize );
DEFINE_KEY ( About );
DEFINE_KEY ( WarningFontPref );
DEFINE_KEY ( WarningFont );

DEFINE_KEY ( GameSize );
DEFINE_KEY ( ChatMinHeight );
DEFINE_KEY ( ChatDefaultHeight );

DEFINE_KEY ( BitmapText );
DEFINE_KEY ( Splash );
DEFINE_KEY ( DynText );
DEFINE_KEY ( DynRect );
DEFINE_KEY ( DynColor );
DEFINE_KEY ( DynJustify );
DEFINE_KEY ( DynPrefFont );
DEFINE_KEY ( DynFont );

// Millennium per-game
DEFINE_KEY( SkipOpeningQuestion );
DEFINE_KEY( SkipSecondaryQuestion );
DEFINE_KEY( SkillLevel );
DEFINE_KEY( SeenSkillLevelWarning );
DEFINE_KEY( ChatOnAtStartup );
DEFINE_KEY( PrefSound );
DEFINE_KEY( Numbers );

// defaults
#define DEFAULT_PrefSound 1
#define DEFAULT_ChatOnAtStartup 1

//generic settings
DEFINE_KEY( Menu );
DEFINE_KEY( SoundAvail );
DEFINE_KEY( ScoreAvail );


// For Usability Test
DEFINE_KEY(InfoBehavior);

// BitmapCtl
//   Config DataStore (either Bitmap OR JPEG)
//	   Bitmap, sz	[resource NAME of bitmap to display]
//	   JPEG, sz	[resource NAME of JPEG to display]
DEFINE_KEY ( BitmapCtl );
DEFINE_KEY ( Bitmap );
DEFINE_KEY ( JPEG );

// ChatCtl
DEFINE_KEY ( ChatCtl );

// preferences
DEFINE_KEY ( EnterExitMessages );
DEFINE_KEY ( BadWordFilter );
DEFINE_KEY ( ChatFont );
DEFINE_KEY ( ChatFontBackup );
DEFINE_KEY ( QuasiFont );
DEFINE_KEY ( QuasiFontBackup );
//ui
DEFINE_KEY ( DisabledText );
DEFINE_KEY ( TypeHereText );
DEFINE_KEY ( InactiveText );
DEFINE_KEY ( EditHeight );
DEFINE_KEY ( EditMargin );
DEFINE_KEY ( QuasiItemsDisp );
DEFINE_KEY ( SystemMessageColor);
DEFINE_KEY ( ChatSendFont );

// panel
DEFINE_KEY ( ChatPanel );
DEFINE_KEY ( PanelWidth );
DEFINE_KEY ( ChatWordRect );
DEFINE_KEY ( ChatWordOffset );
DEFINE_KEY ( ChatWordText );
DEFINE_KEY ( ChatWordFont );
DEFINE_KEY ( PlayerOffset );
DEFINE_KEY ( PlayerFont );
DEFINE_KEY ( ChatWordFontBackup );
DEFINE_KEY ( PlayerFontBackup );
DEFINE_KEY ( OnText );
DEFINE_KEY ( OffText );
DEFINE_KEY ( OnOffOffset );
DEFINE_KEY ( RadioButtonHeight );

// Get & set property
DEFINE_KEY( SupportedProperties );
DEFINE_KEY( ResponseId );
DEFINE_KEY( UserId );
DEFINE_KEY( PropertyGuid );
DEFINE_KEY( Data );

DEFINE_KEY( icw );


// Quasichat
DEFINE_KEY( QuasiChat);
DEFINE_KEY( ChatMessageNdxBegin );
DEFINE_KEY( ChatMessageNdxEnd );

///////////////////////////////////////////////////////////////////////////////
//
// Notes:	Not every item may be available nor does this list constitute all
//			possible items.
//
// Lobby (ZONE_NOGROUP,ZONE_NOUSER)
//	FriendlyName, sz
//	InternalName, sz
//	Language, sz
//	Server, sz
//	Port, long
//
//	Lobby
//		Genre, long			[lobby genre]
//		Options, long		[lobby options bit field]
//		Type, long			[lobby type]
//	User
//		Name, sz			[local user's name]
//		Id, long			[local user's id]
//		ClassId, long		[local user's class id]
//	Group
//		MaxGroups, long		[current number of groups]
//		MinUsers, long		[min number of Users per group to launch]
//		MaxUsers, long		[max number of Users per group]
//	Launcher
//		GameName, sz		[game name]
//		ExeName, sz			[game exe]
//		ExeVersion, sz		[required game version]
//		RegKey, sz			[game registry key]
//		RegVersion, sz		[game registry value]
//		RegPath, sz			[game registry path]
//	Latency
//		Experience, long	[game experience]
//	DPlayApps
//		0
//			Name, sz		[application 1's name]
//			Guid, blob		[application 1's guid]
//		N
//							[application N's name]
//							[application N's guid]
//

//
// User (ZONE_NOGROUP, user id)
//	Name, sz				[name]
//	ClassId, long			[user classification: zRootGroupID, zSysOpGroupID, etc.]
//	Address, long			[ip address]
//	Status, long			[user status, see KeyStatus enum]
//	Suspended, long			[time at which user was suspended (in ms)]
//	Rating, long			[rating, <0 is unknown]
//	GamesPlayed, long		[number of games played, <0 is unknown]
//	GamesAbandoned, long	[number of games abandoned, <0 is unknown]
//	Latency, long			[latency to display]
//	LatencyIcon, long		[latency icon to display, 0 = unknown, 1 = red, 2 = yellow, 3 = lt.green, 4 = green]
//

//
// User (Theater Chat)
//	Name, sz				[name]
//	ClassId, long			[user classification: zRootGroupID, zSysOpGroupID, etc.]
//	Status, long			[user status, see KeyStatus enum]
//	Index, long				[user's index in queue?]
//

//
// Group (group id, ZONE_NOUSER)
//	GameId, long			[lobby server's "game id" for group]
//	HostId, long			[group's current host]
//	Status,long				[status via lobby]
//	GameStatus, long		[status via launch pad]
//	Options,long			[options via lobby]
//  NumUsers, long			[current number of Users]
//	LaunchData, blob		[launch data]
//
// Note: game settings
//
//	Name,sz					[name]
//  Description,sz			[group description]
//  MinUsers, long			[min number of Users]
//	MaxUsers,long			[max number of Users]
//	BlockJoiners			[flag indicating quick no quick joiners]
//	Private, long			[flag indicating locked game]
//	Password, sz			[password if game locked (only host)]
//	DPlayName, sz			[generic dplay, game name]
//	DPlayGuid, blob (guid)	[generic dplay, guid]
//

//
// Enumerations for key_Status
//
enum KeyStatus
{
	// room statys
	KeyStatusUnknown	= 0,
	KeyStatusEmpty		= 1,
	KeyStatusWaiting	= 2,
	KeyStatusInProgress	= 3,

	// player status
	KeyStatusLooking	= 4,
//	KeyStatusWaiting	= 2,
	KeyStatusPlaying	= 5,

	// Theater Chat
//  KeyStatusLooking    = 4       re-using this to represent users that are watching
//  KeyStatusWaiting    = 2
	KeyStatusModerator	= 6,
	KeyStatusGuest		= 7,
	KeyStatusAsking		= 8
};


//
// Enumerations for key_PlayerReady
//
enum KeyPlayerReady
{
    KeyPlayerDeciding   = 0,
    KeyPlayerReady      = 1
};


//
// Enumerations for key_SkillLevel
//
enum KeySkillLevel
{
    KeySkillLevelBot          = -1,
    KeySkillLevelBeginner     =  0,
    KeySkillLevelIntermediate =  1,
    KeySkillLevelExpert       =  2
};


//
// Enumerations for key_Options
//
enum KeyType
{
	KeyTypeUnknown				=	0x00000000,

	// lobbies 
	KeyTypeLobby				=	0x00010000,
	KeyTypeLobbyCardboard		=	0x00010001,
	KeyTypeLobbyRetail			=	0x00010002,
	KeyTypeLobbyGenericDPlay	=	0x00010003,
	KeyTypeLobbyPremium			=	0x00010004,

	// chats
	KeyTypeChat					=	0x00020000,
	KeyTypeChatStatic			=	0x00020001,
	KeyTypeChatDynamic			=	0x00020002,
	KeyTypeChatTheater			=	0x00020003,
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\lobbycore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		LobbyCore.h
 *
 * Contents:	Lobby behavior module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// LobbyCore object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{A494872D-B039-11d2-8B0F-00C04F8EF2FF}")) LobbyCore;

// {67EBB784-C25E-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(CLSID_LobbyCore, 
0x67ebb784, 0xc25e, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\launcher.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Launcher.h
 *
 * Contents:	Base launcher object
 *
 *****************************************************************************/

#ifndef __LAUNCHER_H_
#define __LAUNCHER_H_

///////////////////////////////////////////////////////////////////////////////
// Launcher object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("DCCF5D69-CFF0-11d2-8B30-00C04F8EF2FF")) CLauncher;

// DCCF5D69-CFF0-11d2-8B30-00C04F8EF2FF
DEFINE_GUID(CLSID_Launcher,
0xDCCF5D69, 0xCFF0, 0x11d2, 0x8B, 0x30, 0x0, 0xC0, 0x4F, 0x8E, 0xF2, 0xFF);


///////////////////////////////////////////////////////////////////////////////
// DirectPlayLauncher object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{4FD602EF-D13E-11d2-8B33-00C04F8EF2FF}")) CDirectPlayLauncher;

// {4FD602EF-D13E-11d2-8B33-00C04F8EF2FF}
DEFINE_GUID(CLSID_DirectPlayLauncher, 
0x4fd602ef, 0xd13e, 0x11d2, 0x8b, 0x33, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);


///////////////////////////////////////////////////////////////////////////////
// AsheronsCallLauncher Object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{9DF0CE58-40B5-4b13-BD25-C8E88AEFB315}")) CACLauncher;

// {9DF0CE58-40B5-4b13-BD25-C8E88AEFB315}
DEFINE_GUID(CLSID_ACLauncher, 
0x9df0ce58, 0x40b5, 0x4b13, 0xbd, 0x25, 0xc8, 0xe8, 0x8a, 0xef, 0xb3, 0x15);

///////////////////////////////////////////////////////////////////////////////
// FighterAceLauncher object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{19F72924-11F2-11d3-89C1-00C04F8EC0A2}")) CFighterAceLauncher;

// {19F72924-11F2-11d3-89C1-00C04F8EC0A2}
DEFINE_GUID(CLSID_FighterAceLauncher, 
0x19f72924, 0x11f2, 0x11d3, 0x89, 0xc1, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

///////////////////////////////////////////////////////////////////////////////
// SimutronicsLauncher object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{A3CB690E-29C2-11d3-9654-00C04F8EF946}")) CSimuTronLauncher;

// {A3CB690E-29C2-11d3-9654-00C04F8EF946}
DEFINE_GUID(CLSID_SimuTronLauncher, 
0xa3cb690e, 0x29c2, 0x11d3, 0x96, 0x54, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0x46);


///////////////////////////////////////////////////////////////////////////////
// AllegianceLauncher object
///////////////////////////////////////////////////////////////////////////////

// {3D717C57-2AD9-11d3-8B8E-00C04F8EF2FF}
DEFINE_GUID(CLSID_AllegianceLauncher, 
0x3d717c57, 0x2ad9, 0x11d3, 0x8b, 0x8e, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

///////////////////////////////////////////////////////////////////////////////
// MindAerobicsLauncher object
///////////////////////////////////////////////////////////////////////////////

// {EB633B0F-2B4E-11d3-9654-00C04F8EF946}
DEFINE_GUID(CLSID_MALauncher, 
0xeb633b0f, 0x2b4e, 0x11d3, 0x96, 0x54, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0x46);

///////////////////////////////////////////////////////////////////////////////
// TanarusLauncher object
///////////////////////////////////////////////////////////////////////////////

// {903A9D99-2E60-11d3-9655-00C04F8EF946}
DEFINE_GUID(CLSID_TanarusLauncher, 
0x903a9d99, 0x2e60, 0x11d3, 0x96, 0x55, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0x46);

#endif // __LAUNCHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\lcidmap.h ===
#ifndef _LCIDMAP_H_
#define _LCIDMAP_H_


//  Requires  ////////////////////////////////////////////////////////////////
//
//  ZoneDef.h
//  ClientIdl.h
//  ResourceManager.h


///////////////////////////////////////////////////////////////////////////////
// Windows Primary LangIDs to CommonRes string ID mapping - end with LANG_NEUTRAL
///////////////////////////////////////////////////////////////////////////////

#define ZONE_PLANGIDTORESMAP \
{   { LANG_GERMAN,      IDS_L_GERMAN        },  \
    { LANG_SPANISH,     IDS_L_SPANISH       },  \
    { LANG_FRENCH,      IDS_L_FRENCH        },  \
    { LANG_ITALIAN,     IDS_L_ITALIAN       },  \
    { LANG_SWEDISH,     IDS_L_SWEDISH       },  \
    { LANG_DUTCH,       IDS_L_DUTCH         },  \
    { LANG_PORTUGUESE,  IDS_L_PORTUGUESE    },  \
    { LANG_JAPANESE,    IDS_L_JAPANESE      },  \
    { LANG_DANISH,      IDS_L_DANISH        },  \
    { LANG_NORWEGIAN,   IDS_L_NORWEGIAN     },  \
    { LANG_FINNISH,     IDS_L_FINNISH       },  \
    { LANG_KOREAN,      IDS_L_KOREAN        },  \
    { LANG_CHINESE,     IDS_L_CHINESE       },  \
    { LANG_CZECH,       IDS_L_CZECH         },  \
    { LANG_POLISH,      IDS_L_POLISH        },  \
    { LANG_HUNGARIAN,   IDS_L_HUNGARIAN     },  \
    { LANG_RUSSIAN,     IDS_L_RUSSIAN       },  \
    { LANG_GREEK,       IDS_L_GREEK         },  \
    { LANG_TURKISH,     IDS_L_TURKISH       },  \
    { LANG_SLOVAK,      IDS_L_SLOVAK        },  \
    { LANG_SLOVENIAN,   IDS_L_SLOVENIAN     },  \
    { LANG_ARABIC,      IDS_L_ARABIC        },  \
    { LANG_HEBREW,      IDS_L_HEBREW        },  \
    { LANG_THAI,        IDS_L_THAI          },  \
    { LANG_ENGLISH,     IDS_L_ENGLISH       },  \
    { LANG_NEUTRAL,     IDS_L_UNKNOWN       }};

extern const DWORD gc_mapLangToRes[][2];

HRESULT ZONECALL LanguageFromLCID(LCID lcid, TCHAR *sz, DWORD cch, IResourceManager *pIRM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\launcherimpl.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		LauncherImpl.h
 *
 * Contents:	Template implementations for laucher interfaces and classes.
 *
 *****************************************************************************/

#ifndef __LAUNCHERIMPL_H
#define __LAUNCHERIMPL_H


#include <dplay.h>
#include <dplobby.h>
#include "ZoneDef.h"
#include "Hash.h"
#include "Launcher.h"
#include "ClientImpl.h"
#include "LaunchMsg.h"


///////////////////////////////////////////////////////////////////////////////
//
// User helper functions for launchers
//
///////////////////////////////////////////////////////////////////////////////

// Retrieves application's version from registry
extern bool GetExeVersion( TCHAR* szRegKey, TCHAR* szRegVersion, char* szVersion, DWORD dwLen );
extern bool GetExeFullPath( ILobbyDataStore* pLobbyDataStore, TCHAR * pszPathWithExe, DWORD cchSize );


///////////////////////////////////////////////////////////////////////////////
//
//	ILauncher
//		Non-COM base class for launcher objects
//
///////////////////////////////////////////////////////////////////////////////
class ILauncher
{
public:

	STDMETHOD(Init)( ILobbyDataStore* pILDS, IEventQueue* pIEQ, IDataStoreManager* pIDSM ) = 0;
	STDMETHOD(Close)() = 0;
	STDMETHOD_(EventLauncherCodes,IsGameInstalled)() = 0;
	STDMETHOD_(EventLauncherCodes,IsSupportLibraryInstalled)() = 0;
	STDMETHOD_(EventLauncherCodes,LaunchGame)( DWORD dwGroupId, DWORD dwUserId ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
//
// CLauncherImpl	Template implementation of launcher object
//
// Notes:	CLauncherImpl needs to come before ILauncher or one of it's derived
//			classes so COM has an IUknown.
//
// Parameters	
//	T		Derived launcher object
//	CL		Derived launcher class
//	pclsid	Object's clsid
//
///////////////////////////////////////////////////////////////////////////////
template <class T, class CL, const CLSID* pclsid = &CLSID_NULL>
class CLauncherImpl :
	public IZoneShellClientImpl<T>,
	public IEventClientImpl<T>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<T,pclsid>
{

// ATL definitions
public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(T)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
	END_COM_MAP()


// IZoneShellClient overrides
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
	{
		T* pT = static_cast<T*>(this);

		HRESULT hr = IZoneShellClientImpl<T>::Init( pIZoneShell, dwGroupId, szKey );
		if ( FAILED(hr) )
			return hr;
		else
			return pT->CL::Init( LobbyDataStore(), EventQueue(), DataStoreManager() );
	}

	STDMETHOD(Close)()
	{
		T* pT = static_cast<T*>(this);

		pT->CL::Close();
		IZoneShellClientImpl<T>::Close();
		return S_OK;
	}


// Process events
public:
	BEGIN_EVENT_MAP()
		EVENT_HANDLER( EVENT_LAUNCHER_INSTALLED_REQUEST, OnInstalledRequest );
		EVENT_HANDLER( EVENT_LAUNCHER_LAUNCH_REQUEST, OnLaunchRequest );
	END_EVENT_MAP()


	void ZONECALL OnInstalledRequest( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
	{
		T* pT = static_cast<T*>(this);

		// cache installation results
		if ( !m_bCheckedVersion )
		{
			m_codeInstalled = pT->IsGameInstalled();
			if ( m_codeInstalled == EventLauncherOk )
			{
				m_codeInstalled = pT->IsSupportLibraryInstalled();
			}
			m_bCheckedVersion = true;
		}
		EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LAUNCHER_INSTALLED_RESPONSE, dwGroupId, dwUserId, m_codeInstalled, 0 );
	}


	void ZONECALL OnLaunchRequest( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
	{
		T* pT = static_cast<T*>(this);
		EventLauncherCodes codeResponse = EventLauncherFail;
		
		if ( !LobbyDataStore()->IsUserInGroup( dwGroupId, dwUserId ) )
		{
			// don't launch if user isn't in the group
			codeResponse = EventLauncherFail;
		}
		else if ( !m_bCheckedVersion || (m_codeInstalled != EventLauncherOk) )
		{
			// can't launch until successful version check
			codeResponse = m_codeInstalled;
		}
		else
		{
			// launch game
			codeResponse = pT->LaunchGame( dwGroupId, dwUserId );
		}

		EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LAUNCHER_LAUNCH_RESPONSE, dwGroupId, dwUserId, codeResponse, 0 );
	}


// CLauncherImpl internals
public:
	CLauncherImpl() :	m_bCheckedVersion(false), 
						m_codeInstalled(EventLauncherFail){}	
private:
	bool					m_bCheckedVersion;
	EventLauncherCodes		m_codeInstalled;
};


///////////////////////////////////////////////////////////////////////////////
//
// CBaseLauncher
//		Base launcher implementation
//
///////////////////////////////////////////////////////////////////////////////

class CBaseLauncher : public ILauncher
{
public:
	STDMETHOD(Init)( ILobbyDataStore* pILDS, IEventQueue* pIEQ, IDataStoreManager* pIDSM )
	{
		m_pILobbyDataStore = pILDS;
		m_pIEventQueue = pIEQ;
		m_pIDataStoreManager = pIDSM;
		return S_OK;
	}

	STDMETHOD(Close)()
	{
		m_pILobbyDataStore.Release();
		m_pIEventQueue.Release();
		m_pIDataStoreManager.Release();
		return S_OK;
	}

	STDMETHOD_(EventLauncherCodes,IsGameInstalled)()
	{
		return EventLauncherOk;
	}

	STDMETHOD_(EventLauncherCodes,IsSupportLibraryInstalled)()
	{
		return EventLauncherOk;
	}

	STDMETHOD_(EventLauncherCodes,LaunchGame)( DWORD dwGroupId, DWORD dwUserId )
	{
		return EventLauncherFail;
	}

public:
	CComPtr<ILobbyDataStore>	m_pILobbyDataStore;
	CComPtr<IEventQueue>		m_pIEventQueue;
	CComPtr<IDataStoreManager>	m_pIDataStoreManager;
};


///////////////////////////////////////////////////////////////////////////////
//
// CCommandLineLauncher
//		Command line implementation
//
///////////////////////////////////////////////////////////////////////////////
class CCommandLineLauncher : public CBaseLauncher
{
public:
	STDMETHOD_(EventLauncherCodes,IsGameInstalled)();
	STDMETHOD_(EventLauncherCodes,LaunchGame)( DWORD dwGroupId, DWORD dwUserId );

protected:
	// helper functions
	bool ZONECALL GetFullCmdLine( ZLPMsgRetailLaunchData *pLaunchData, TCHAR* fullCmdLine );
	bool ZONECALL GetPathWithExe( TCHAR * pszPathWithExe, DWORD cchPathWithExe );
};


///////////////////////////////////////////////////////////////////////////////
//
// CDirectPlayLauncher
//		DirectPlayLobby implementation
//
///////////////////////////////////////////////////////////////////////////////
class CDirectPlayLauncher : public CBaseLauncher
{
public:
	CDirectPlayLauncher();
	~CDirectPlayLauncher();

// ILaunch overrides
public:
	STDMETHOD_(EventLauncherCodes,IsGameInstalled)();
	STDMETHOD_(EventLauncherCodes,IsSupportLibraryInstalled)();
	STDMETHOD_(EventLauncherCodes,LaunchGame)( DWORD dwGroupId, DWORD dwUserId );

// DirectPlayLobby message handling
public:
	struct GameInfo
	{
		bool					m_bIsHost;
		DWORD					m_dwGroupId;
		DWORD					m_dwUserId;
		DWORD					m_dwMaxUsers;
		DWORD					m_dwMinUsers;
		DWORD					m_dwCurrentUsers;
		DWORD					m_dwSessionFlags;
		TCHAR					m_szPlayerName[ZONE_MaxUserNameLen];
		TCHAR					m_szGroupName[ZONE_MaxGameNameLen];
		TCHAR					m_szExeName[ZONE_MaxGameNameLen];
		TCHAR					m_szHostAddr[24];
		GUID					m_guidApplication;
		GUID					m_guidServiceProvider;
		GUID					m_guidAddressType;
		GUID					m_guidSession;
		void*					m_pLobbyAddress;
		DWORD					m_dwLobbyAddressSize;
		IDirectPlayLobbyA*		m_pIDPLobby;
		DWORD					m_dwDPAppId;

		GameInfo();
		~GameInfo();
		static bool ZONECALL Cmp( GameInfo* p, DWORD dwGroupId )	{ return (p->m_dwGroupId == dwGroupId); }
		static void ZONECALL Del( GameInfo* p, void* );
	};

	// functions derived classes may need to override
	STDMETHOD_(bool,HandleLobbyMessage)( GameInfo* p, BYTE* msg, DWORD msgLen );
	STDMETHOD_(void,HandleSetProperty)( GameInfo* p, DPLMSG_SETPROPERTY* set );
	STDMETHOD_(void,HandleGetProperty)( GameInfo* p, DPLMSG_GETPROPERTY* get );
	STDMETHOD(SetGameInfo)( DWORD dwGroupId, DWORD dwUserId, GameInfo* pGameInfo );


// helper functions
protected:
	struct FindGameContext
	{
		const GUID*		m_pGuid;
		bool			m_bFound;

		FindGameContext( const GUID* pGuid ) : m_pGuid( pGuid ), m_bFound( false ) {}
	};
	
	static BOOL WINAPI EnumGamesCallBack( LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags );
	static bool ZONECALL EnumPollCallback( GameInfo* p, MTListNodeHandle hNode, void* pCookie );
	static DWORD WINAPI LobbyThread( LPVOID lpParameter );

	HANDLE						m_hExitEvent;
	HANDLE						m_hThread;
	CMTHash<GameInfo,DWORD>		m_hashGameInfo;
};

#endif //__LAUNCHERIMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\menumanager.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		MenuManager.h
 *
 * Contents:	Menu manager interfaces
 *
 *****************************************************************************/

#ifndef _MENUMANAGER_H_
#define _MENUMANAGER_H_

#include "ZoneShell.h"

///////////////////////////////////////////////////////////////////////////////
// IMenuManager
///////////////////////////////////////////////////////////////////////////////

// {1C99F390-197F-11d3-8B75-00C04F8EF2FF}
DEFINE_GUID( IID_IMenuManager, 
0x1c99f390, 0x197f, 0x11d3, 0x8b, 0x75, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);


interface __declspec(uuid("{1C99F390-197F-11d3-8B75-00C04F8EF2FF}"))
IMenuManager : public IUnknown
{
	STDMETHOD(SetWindow)( IZoneFrameWindow* pIWindow ) = 0;
	STDMETHOD(ReleaseWindow)() = 0;
	STDMETHOD(ProcessCommand)( UINT nMsg, WPARAM wParam, LPARAM lParam, bool* pbHandled ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// MenuManager Object
///////////////////////////////////////////////////////////////////////////////


// {1C99F392-197F-11d3-8B75-00C04F8EF2FF}
DEFINE_GUID(CLSID_MenuManager, 
0x1c99f392, 0x197f, 0x11d3, 0x8b, 0x75, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{1C99F392-197F-11d3-8B75-00C04F8EF2FF}")) CMenuManager ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\lobbyhelper.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		LobbyHelper.h
 *
 * Contents:	Inlines for common lobby functions
 *
 *****************************************************************************/

#ifndef __LOBBYHELPER_H_
#define __LOBBYHELPER_H_

#include "ZoneShell.h"
#include "LobbyDataStore.h"
#include "KeyName.h"

inline bool LobbyHasRatings(ILobbyDataStore* pILDS)
{
	CComPtr<IDataStore> pIDS;
	HRESULT hr = pILDS->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( FAILED(hr) )
		return false;
	long options = 0;
	CONST TCHAR* keys[] = { key_Lobby, key_Options };
	hr = pIDS->GetLong( keys, 2, &options);
	if(options & zGameOptionsRatingsAvailable)
		return true;
	else
		return false;
}

inline bool LobbyHasLatency(IZoneShell* pIZoneShell)
{
	CComPtr<IUnknown> temp;
	HRESULT hr = pIZoneShell->QueryService(SRVID_Latency, IID_IUnknown, (void**)&temp);
	if(SUCCEEDED(hr))
		return true;
	else
		return false;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\lobbydatastore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		LobbyDataStore.h
 *
 * Contents:	Lobby wrapper around low-level data store
 *
 *****************************************************************************/

#ifndef _LOBBYDATASTORE_H_
#define _LOBBYDATASTORE_H_

#include "ZoneDef.h"
#include "DataStore.h"


///////////////////////////////////////////////////////////////////////////////
// ILobbyDataStore
///////////////////////////////////////////////////////////////////////////////

// {F23B5BBC-B56C-11d2-8B13-00C04F8EF2FF}
DEFINE_GUID( IID_ILobbyDataStore,
0xf23b5bbc, 0xb56c, 0x11d2, 0x8b, 0x13, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{F23B5BBC-B56C-11d2-8B13-00C04F8EF2FF}"))
ILobbyDataStore : public IUnknown
{
	//
	// ILobbyData::PFKEYENUM
	//
	// Application defined callback function for ILobbyDataStore::EnumKeys method.
	// Return S_OK to continue enumeration, S_FALSE to stop enumeration.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group
	//	dwUserId
	//		Id of user
	//	szKey
	//		Pointer to name of string.  Callback must not modify parameter.
	//	pVariant
	//		Pointer to key's variant.  Callback must not modify the parameter.
	//	dwSize
	//		Size fo variant data.
	//	pContext
	//		Context supplied in ILobbyDataStore::EnumKeys
	//
	typedef HRESULT (ZONECALL *PFKEYENUM)(
		DWORD			dwGroupId,
		DWORD			dwUserId,
		CONST TCHAR*	szKey,
		CONST LPVARIANT	pVariant,
		DWORD			dwSize,
		LPVOID			pContext );


	//
	// ILobbyData::PFENTITYENUM
	//
	// Application defined callback function for ILobbyDataStore::EnumGroups
	// and ILobbyDataStore::EnumUsers method.  Return S_OK to continue
	// enumeration, S_FALSE to stop enumeration.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group
	//	dwUserId
	//		Id of user
	//	pContext
	//		Context supplied in ILobbyDataStore::EnumKeys
	//
	typedef HRESULT (ZONECALL *PFENTITYENUM)(
		DWORD	dwGroupId,
		DWORD	dwUserId,
		LPVOID	pContext );


	//
	// ILobbyDataStore::GetUserId
	//
	// Returns id of specified user.  Internal lobby components
	// should not need this method, but it may be useful when processing 
	// data from external sources (e.g. DirectPlayLobby).
	//
	// NOTE:	If szUserName == NULL then the local user's id is returned.
	//
	// Parameters:
	//	szUserName
	//		Name of user to retrieve.  If NULL, the id of the lobby's local
	//		user is returned.
	//
	STDMETHOD_(DWORD,GetUserId)( TCHAR* szUserName ) = 0;


	//
	// ILobbyDataStore::GetDataStore
	//
	// Returns data store associated with specified group,user pair.  Callers
	// should NOT keep a long term reference to the data store.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group.  Set this parameter to ZONE_NOGROUP if the data
	//		store is not group specific.
	//	dwUserId
	//		Id of user.  Set this parameter to ZONE_NOUSER if the data
	//		store is not user specific.
	//	ppIDataStore
	//		Pointer to IDataStore pointer to receive the data store.  The returned
	//		data store's reference count is incremented.
	//
	STDMETHOD(GetDataStore)(
		DWORD			dwGroupId,
		DWORD			dwUserId,
		IDataStore**	ppIDataStore ) = 0;


	//
	// ILobbyDataStore::IsUserInLobby
	//
	// Returns TRUE if user is in lobby, otherwise FALSE.
	//
	// Parameters:
	//	dwUserId
	//		Id of user to check.
	//
	STDMETHOD_(bool,IsUserInLobby)( DWORD dwUserId ) = 0;


	//
	// ILobbyDataStore::IsGroupInLobby
	//
	// Returns TRUE if group is in lobby, otherwise FALSE.
	//
	// Parameters:
	//	dwGroupId
	//		Id of user to check.
	//
	STDMETHOD_(bool,IsGroupInLobby)( DWORD dwGroupId ) = 0;


	//
	// ILobbyDataStore::IsUserInGroup
	//
	// Returns TRUE of user belongs to the group, otherwise FALSE.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group to check.
	//	dwUserId
	//		Id of user to check.
	//
	STDMETHOD_(bool,IsUserInGroup)(
		DWORD	dwGroupId,
		DWORD	dwUserId ) = 0;

	//
	// ILobbyDataStore::GetGroupUserCount
	//
	// Returns number of users in specified group.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group to check.
	//
	STDMETHOD_(long,GetGroupUserCount)( DWORD dwGroupId ) = 0;

	//
	// ILobbyDataStore::GetUserGroupCount
	//
	// Returns number of groups specified user belongs.
	//
	// Parameters:
	//	dwUserId
	//		Id of group to check.
	//
	STDMETHOD_(long,GetUserGroupCount)( DWORD dwUserId ) = 0;


	//
	// ILobbyDataStore::EnumGroups
	//
	// Enumerates groups associated with specified user or the entire lobby
	// if dwUserId equals ZONE_NOUSER.
	//
	// Parameters:
	//	dwUserId
	//		Id of the user whose groups are being enumerated.  Set this
	//		parameter to ZONE_NOUSER if to enumerated all groups in the
	//		lobby.
	//	pfCallback
	//		Pointer to callback function that will be called for group.
	//	pContext
	//		Context that will be passed to the callback fuction
	//
	STDMETHOD(EnumGroups)(
		DWORD			dwUserId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext ) = 0;


	//
	// ILobbyDataStore::EnumUsers
	//
	// Enumerates users associated with specified group or the entire lobby
	// if dwGroupId equals ZONE_NOGROUP.
	//
	// Parameters:
	//	dwGroupId
	//		Id of the groups whose users are being enumerated.  Set this
	//		parameter to ZONE_NOUSER if to enumerated all groups in the
	//		lobby.
	//	pfCallback
	//		Pointer to callback function that will be called for user.
	//	pContext
	//		Context that will be passed to the callback fuction.
	//
	STDMETHOD(EnumUsers)(
		DWORD			dwGroupId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// ILobbyDataStoreAdmin
///////////////////////////////////////////////////////////////////////////////

// {1F0F0601-B7A9-11d2-8B13-00C04F8EF2FF}
DEFINE_GUID(IID_ILobbyDataStoreAdmin, 
0x1f0f0601, 0xb7a9, 0x11d2, 0x8b, 0x13, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{1F0F0601-B7A9-11d2-8B13-00C04F8EF2FF}"))
ILobbyDataStoreAdmin : public IUnknown
{
	//
	// ILobbyDataStoreAdmin::Init
	//
	// Initializes lobby store with and external components
	//
	// Parameters:
	//	pIDataStoreManager
	//		Pointer to data store manager used to create the internal user
	//		and group stores.
	STDMETHOD(Init)( IDataStoreManager* pIDataStoreManager ) = 0;


	//
	// ILobbyDataStoreAdmin::NewUser
	//
	// Allocates necessary structures to hold the users data.
	//
	// Parameters:
	//	dwUserId
	//		Id of new user.
	//	szUserName
	//		Name of user.
	//
	STDMETHOD(NewUser)(
		DWORD	dwUserId,
		TCHAR*	szUserName ) = 0;

	//
	// ILobbyDataStoreAdmin::SetLocalUser( dwUserId )
	//
	// Set lobby's local user id.
	//
	// Parameters:
	//	dwUserId
	//		Id of local user
	//
	STDMETHOD(SetLocalUser)( DWORD dwUserId ) = 0;

	//
	// ILobbyDataStoreAdmin::DeleteUser
	//
	// Delete structures and data associated with the user.
	//
	// Parameters:
	//	dwUserId
	//		Id of user to delete.
	//
	STDMETHOD(DeleteUser)( DWORD dwUserId ) = 0;

	//
	// ILobbyDataStoreAdmin::DeleteAllUsers
	//
	// Deletes all users.
	//
	STDMETHOD(DeleteAllUsers)() = 0;

	//
	// ILobbyDataStoreAdmin::GetUserId
	//
	// Returns id of specified user.  Internal lobby components
	// should not need this method, but it may be useful when processing 
	// data from external sources (e.g. DirectPlayLobby).
	//
	// Parameters:
	//	szUserName
	//		Name of user to retrieve
	//
	STDMETHOD_(DWORD,GetUserId)( TCHAR* szUserName = NULL ) = 0;

	//
	// ILobbyDataStoreAdmin::NewGroup
	//
	// Allocates necessary structures to hold the users data.
	//
	// Parameters:
	//	dwUserId
	//		Id of new group.
	//
	STDMETHOD(NewGroup)( DWORD dwGroupId ) = 0;

	//
	// ILobbyDataStoreAdmin::DeleteGroup
	//
	// Delete structures and data associated with the group.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group to delete.
	//
	STDMETHOD(DeleteGroup)( DWORD dwGroupId ) = 0;

	//
	// ILobbyDataStoreAdmin::DeleteAllGroup
	//
	// Deletes all groups
	//
	STDMETHOD(DeleteAllGroups)() = 0;

	//
	// ILobbyDataStoreAdmin::AddUserToGroup
	//
	// Adds user to specified group.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group.
	//	dwUserId
	//		Id of user.
	//	
	STDMETHOD(AddUserToGroup)(
		DWORD	dwUserId,
		DWORD	dwGroupId ) = 0;


	//
	// ILobbyDataStoreAdmin::RemoveUserFromGroup
	//
	// Removes user from specified group.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group.
	//	dwUserId
	//		Id of user.
	//	
	STDMETHOD(RemoveUserFromGroup)(
		DWORD	dwUserId,
		DWORD	dwGroupId ) = 0;

	//
	// ILobbyDataStoreAdmin::ResetGroup
	//
	// Removes all users and data from the group.  Typically this 
	// is called by the lobby when the last user leaves the group.
	//
	// Parameters:
	//	dwGroupId
	//		Id of group.
	//
	STDMETHOD(ResetGroup)( DWORD dwGroupId ) = 0;

	//
	// ILobbyDataStoreAdmin::ResetAllGroups
	//
	// Removes all users and data from all groups.
	//
	STDMETHOD(ResetAllGroups)() = 0;
};


///////////////////////////////////////////////////////////////////////////////
// LobbyDataStore object
///////////////////////////////////////////////////////////////////////////////

// {F23B5BBE-B56C-11d2-8B13-00C04F8EF2FF}
DEFINE_GUID(CLSID_LobbyDataStore, 
0xf23b5bbe, 0xb56c, 0x11d2, 0x8b, 0x13, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{F23B5BBE-B56C-11d2-8B13-00C04F8EF2FF}")) CLobbyDataStore ;

#endif // _LOBBYDATASTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\lobbymsg.h ===
/*******************************************************************************

	LobbyMsg.h

		Header file for lobby messages.
	
	Copyright (c) Microsoft Corp. 1998. All rights reserved.
	Written by Hoon Im
	Created on 04/06/98
	 
*******************************************************************************/


#ifndef LOBBYMSG_H
#define LOBBYMSG_H


enum
{
    /*
        These msgs start above WM_USER so that internal libs can send windows
        msgs to the shell window (lobby.exe) as each individual msgs.
        The shell window in contrast sends these msgs subclasses under
        WM_USER msg.
    */
    // client to shell
	LM_LAUNCH_HELP = WM_USER + 200,
	LM_ENABLE_AD_CONTROL,
	LM_EXIT,
    LM_PROMPT_ON_EXIT,

    // shell to client
    LM_UNIGNORE_ALL,
    LM_QUICKHOST,
	LM_CUSTOM_ITEM_GO,
	LM_RESET_ZONE_TIPS,

	// client to shell - more (didn't want to renumber others)
	LM_SET_CUSTOM_ITEM,
	LM_SET_TIPS_ITEM,
	LM_SEND_ZONE_MESSAGE,
	LM_VIEW_PROFILE,
};


/*
	These messages allow anywhere downstream to throw requests right into the main message loop
	via PostThreadMessage.  Currently used to tell the message loop about Modeless dialogs to dispatch to.
	Implemented in the lobby.exe message loop in lobby.cpp.
*/
enum
{
	TM_REGISTER_DIALOG = WM_USER + 465,
	TM_UNREGISTER_DIALOG
};

/*
	Callback with a status value.  0 for success.
*/
typedef void (CALLBACK* THREAD_REGISTER_DIALOG_CALLBACK)(HWND hWnd, DWORD dwReason);

/*
	Other status values.
*/
enum
{
	REGISTER_DIALOG_SUCCESS = 0,
	REGISTER_DIALOG_ERR_BUG,
	REGISTER_DIALOG_ERR_MAX_EXCEEDED,
	REGISTER_DIALOG_ERR_BAD_HWND
};


enum
{
	// Ad control states
	zAdDisable = 0,
	zAdNoActivity,
	zAdNoNetwork,
	zAdEnable
};


#endif // LOBBYMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\millcore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ChatCore.h
 *
 * Contents:	Millennium Lobby protocol module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// MillLobbyCore object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{E6C04FD5-5D25-11d3-8846-00C04F8EF45B}")) MillCore;

// {E6C04FD5-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(CLSID_MillCore, 
0xe6c04fd5, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\millcommand.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		MillCommand.h
 *
 * Contents:	Millennium command manager class
 *
 *****************************************************************************/

#ifndef _MILLCOMMAND_H_
#define _MILLCOMMAND_H_

///////////////////////////////////////////////////////////////////////////////
// MillCommand Object
///////////////////////////////////////////////////////////////////////////////

// {B12D3E5B-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(CLSID_MillCommand, 
0xb12d3e5b, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

class __declspec(uuid("{B12D3E5B-9681-11d3-884D-00C04F8EF45B}")) CMillCommand ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\opname.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		KeyCommands.h
 *
 * Contents:	IZoneClient::OnCommand operations
 *
 *****************************************************************************/

#ifndef _OPNAMES_H_
#define _OPNAMES_H_

//
// Macro to declare key names
//
#ifndef __INIT_OPNAMES
	#define DEFINE_OP(name)	extern "C" const TCHAR op_##name[]
#else
	#define DEFINE_OP(name)	extern "C" const TCHAR op_##name[] = _T( #name )
#endif


//
// Component mutex strings
//
#ifndef PROXY_MUTEX_NAME
#define PROXY_MUTEX_NAME	"Z6ProxyClient"
#endif



//
// Start zone component
//
// Parameters
//	arg1, launch parameters
//	arg2, setup parameters
//
DEFINE_OP(Start);


//
// Launch zone component
//
// Parameters
//	???
//
// Returns
//	none
//
DEFINE_OP(Launch);


//
// Navigate broswer to specified URL via heartbeat if one
// is present.  Otherwise launch a new browser instance.
//
// Parameters
//	arg1, URL to display
//	arg2, none
//
// Returns
//	none
//
DEFINE_OP(Url);

//
// Generic browser command that is passed through to web page/
//
// Parameters
//	arg1, op code
//	arg2, op argument
//
DEFINE_OP(BrowserCommand);

//
// Query zone component's version
//
// Parameters:
//	none
//
// Returns:
//	szOut, version string of component
//
DEFINE_OP(Version);


//
// Query zone component's status
//
// Parameters:
//	none
//
// Returns:
//	plCode, result code
//
DEFINE_OP(Status);


//
// Establish a network connection
//
// Parameters:
//	arg1, "server:port"
//	arg2, internal name 
//
// Returns:
//	plCode, result code
//
DEFINE_OP(Connect);


//
// Discontinue network connection
//
// Parameters
//	none
//
// Returns:
//	plCode, result code
//
DEFINE_OP(Disconnect);


//
// Get remote address from proxy connection
//
// Parameters
//	none
//
// Returns
//	szOut, address
DEFINE_OP(GetRemoteAddress);

//
// Close zProxy
//
// Parameters
//	none
//
// Returns
//	none
DEFINE_OP(Shutdown);


///////////////////////////////////////////////////////////////////////////////
// result codes
///////////////////////////////////////////////////////////////////////////////

enum ZoneProxyResultCodes
{
	ZoneProxyOk					=	 0,
	ZoneProxyFail				=	-1,
	ZoneProxyNotInitialized		=	-2,
	ZoneProxyUnknownOp			=	-3,
	ZoneProxyServerUnavailable	=	-4,
};


///////////////////////////////////////////////////////////////////////////////
// op_BrowserCommand op codes
///////////////////////////////////////////////////////////////////////////////

enum BrowserOpCodes
{
	B_Navigate = 1,
	B_Help,
	B_Profile,
	B_Store,
	B_Ad,
	B_SysopChat,
	B_ProfileMenu,
	B_Downlaod
};

#define browser_op_Navigate		TEXT("1")
#define browser_op_Help			TEXT("2")
#define browser_op_Profile		TEXT("3")
#define browser_op_Store		TEXT("4")
#define browser_op_Ad			TEXT("5")
#define browser_op_SysopChat	TEXT("6")
#define browser_op_ProfileMenu	TEXT("7")
#define browser_op_Download		TEXT("8")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\millengine.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		MillEngine.h
 *
 * Contents:	Millennium Engine module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// MillEngine object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{E6C04FD8-5D25-11d3-8846-00C04F8EF45B}")) MillEngine;

// {E6C04FD8-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(CLSID_MillEngine, 
0xe6c04fd8, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);


// {927DB69E-8A83-11d3-884B-00C04F8EF45B}
DEFINE_GUID(IID_IMillUtils, 
0x927db69e, 0x8a83, 0x11d3, 0x88, 0x4b, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{927DB69E-8A83-11d3-884B-00C04F8EF45B}"))
IMillUtils : public IUnknown
{
    STDMETHOD(GetURLQuery)(TCHAR *buf, DWORD cch, long nContext = 0) = 0;
    STDMETHOD(IncrementCounter)(long eCounter) = 0;
    STDMETHOD(ResetCounter)(long eCounter) = 0;
    STDMETHOD_(DWORD, GetCounter)(long eCounter, bool fLifetime = true) = 0;
    STDMETHOD(WriteTime)(long nMinutes, TCHAR *sz, DWORD cch) = 0;

    enum
    {
        M_CounterAdsRequested = 0,
        M_CounterAdsViewed,
        M_CounterEvergreenViewed,

        M_CounterGamesCompleted,
        M_CounterGamesDisconnected,
        M_CounterGamesQuit,
        M_CounterGamesFNO,

        M_CounterLaunches,
        M_CounterMainWindowOpened,
        M_CounterZoneConnectEst,
        M_CounterZoneConnectFail,
        M_CounterZoneConnectLost,

        M_CounterGamesAbandonedRunning,

        M_NumberOfCounters
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\premiumview.h ===
#ifndef PREMIUMVIEW_H
#define PREMIUMVIEW_H

#include <ClientImpl.h>
#include <ClientIdl.h>
#include <ZoneString.h>
#include <KeyName.h>
#include "zoneevent.h"
#include <commctrl.h>
#include "zoneresource.h"
#include <zGDI.h>
#include "rollover.h"
#include "TextWindow.h"

#define PREMIUM_VIEW_BUTTON_ID		1

typedef CWinTraits<WS_CHILD | WS_VISIBLE> CPremiumViewTraits;

// CPremiumViewBase class
//
// Do not use this base class directly
// Use CPremiumViewImpl if you're trying to create a custom PremiumView control

class CPremiumViewBase: public CWindowImpl<CPremiumViewBase, CWindow, CPremiumViewTraits>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public IZoneShellClientImpl<CPremiumViewBase>,
	public IEventClientImpl<CPremiumViewBase>
{
protected:
	CRolloverButton		m_PlayNowButton;
	CMarqueeTextWindow*	m_pMarqueeTextWnd;
	CDib				m_DibBackground;
	CPoint				m_ButtonLocation;
	bool				m_OkToLaunch;
	DWORD				m_UserId;

public:
	CPremiumViewBase();
	virtual ~CPremiumViewBase();

DECLARE_NOT_AGGREGATABLE(CPremiumViewBase)

DECLARE_WND_CLASS( "PremiumView" )


BEGIN_COM_MAP(CPremiumViewBase)
	COM_INTERFACE_ENTRY(IEventClient)
	COM_INTERFACE_ENTRY(IZoneShellClient)
END_COM_MAP()

// Zone Event Handler Map
BEGIN_EVENT_MAP()
	EVENT_HANDLER_WITH_DATA( EVENT_LAUNCHER_INSTALLED_RESPONSE, OnLauncherInstalled)
	EVENT_HANDLER(EVENT_LOBBY_GROUP_ADD_USER, OnUserAdd)
	EVENT_HANDLER_WITH_BUFFER(EVENT_LAUNCHPAD_GAME_STATUS, OnGameStatusEvent)
	EVENT_HANDLER_WITH_BUFFER(EVENT_LAUNCHPAD_ZSETUP, OnGameZSetupEvent)
END_EVENT_MAP()

BEGIN_MSG_MAP(thisClass)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	COMMAND_ID_HANDLER(PREMIUM_VIEW_BUTTON_ID, OnPlayNow)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	// Message Handlers
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){return 0;}
	// Command Handlers
	LRESULT OnPlayNow(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	// Zone Event Handlers
	void OnUserAdd( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnLauncherInstalled( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2);

	virtual void OnGameStatusEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen){}
	virtual void OnGameZSetupEvent(DWORD eventId,DWORD groupId,DWORD userId,void* pData, DWORD dataLen){}

};


/////////////////////////////////////////////////////////////////////////////
// CPremiumViewImpl
//
// Use this class to create custom PremiumView controls like the one for Fighter Ace
// You needs to specify a new class id for the control, and replace the tableview classid in object.txt 
// with this class id. Note that you must chain the message map, and com map for this control to work properly
// See CPremiumViewCtl for an example on how to do this
//

template <class T,const CLSID* pclsid = &CLSID_NULL>
class ATL_NO_VTABLE CPremiumViewImpl : 
	public CComControl<T,CPremiumViewBase>,
	public IOleControlImpl<T>,
	public IOleObjectImpl<T>,
	public IOleInPlaceActiveObjectImpl<T>,
	public IViewObjectExImpl<T>,
	public IOleInPlaceObjectWindowlessImpl<T>,
	public CComCoClass<T,pclsid>,
	public IPersistStreamInitImpl<T>
{
protected:

public:
	CPremiumViewImpl(){ 	m_bWindowOnly = TRUE; }
	~CPremiumViewImpl(){};

DECLARE_NO_REGISTRY()

DECLARE_NOT_AGGREGATABLE(T)

DECLARE_PROTECT_FINAL_CONSTRUCT()

typedef CPremiumViewImpl< T, pclsid >	thisClass;

BEGIN_COM_MAP(thisClass)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY_CHAIN(CPremiumViewBase)
END_COM_MAP()

BEGIN_PROP_MAP(thisClass)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(thisClass)
	CHAIN_MSG_MAP(CPremiumViewBase)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\multistatefont.h ===
///////////////////////////////////////////////////////////////////////////
// This is a generic method for loading and accessing fonts which have
// specified formatting material which they work with. 
// They are created using LoadZoneButtonFont and reference counted
// by the normal COM methods.
//

#ifndef __MULTISTATEFONT_H
#define __MULTISTATEFONT_H

#include "BasicATL.h"
#include "DataStore.h"

#define ZF_JUSTIFY_LEFT     (-1)
#define ZF_JUSTIFY_CENTER   (0)
#define ZF_JUSTIFY_RIGHT    (1)
#define ZF_JUSTIFY_TOP      ZF_JUSTIFY_LEFT
#define ZF_JUSTIFY_BOTTOM   ZF_JUSTIFY_RIGHT

// {39897895-718A-11d3-AE77-0000F803F3DE}
DEFINE_GUID(IID_IZoneMultiStateFont, 
0x39897895, 0x718a, 0x11d3, 0xae, 0x77, 0x0, 0x0, 0xf8, 0x3, 0xf3, 0xde);


struct __declspec(uuid("39897895-718A-11d3-AE77-0000F803F3DE"))
IZoneMultiStateFont : public IUnknown
{
    //STDMETHOD(Init)( IDataStore *pIDS, const WCHAR* pszKey ) = 0;

    STDMETHOD(GetHFont)( DWORD dwState, HFONT *phFont ) = 0;

    STDMETHOD(FindState)( LPCWSTR pszName, LPDWORD pdwState ) = 0;
    STDMETHOD(GetStateName)( DWORD dwState, LPWSTR pszName, DWORD cchName ) = 0;

    STDMETHOD(GetNumStates)( LPDWORD pdwNumStates ) = 0;

    STDMETHOD(GetPreferredFont)( DWORD dwState, ZONEFONT *pzf ) = 0;
    STDMETHOD(SetPreferredFont)( DWORD dwState, ZONEFONT *pzf ) = 0;

    STDMETHOD(GetZoneFont)( DWORD dwState, ZONEFONT *pzf ) = 0;
    STDMETHOD(SetZoneFont)( DWORD dwState, ZONEFONT *pzf ) = 0;

    STDMETHOD(GetColor)( DWORD dwState, COLORREF *pcolor ) = 0;
    STDMETHOD(SetColor)( DWORD dwState, COLORREF color ) = 0;

    STDMETHOD(GetRect)( DWORD dwState, LPRECT pRect ) = 0;
    STDMETHOD(SetRect)( DWORD dwState, LPRECT pRect ) = 0;

    // If you don't want to retrieve one (or set one)
    // set it to NULL and it will be ignored.
    STDMETHOD(GetJustify)( DWORD dwState, int *pnHJustify, int *pnVJustify ) = 0;
    STDMETHOD(SetJustify)( DWORD dwState, int *pnHJustify, int *pnVJustify ) = 0;
};

// link with zoneui.lib
extern "C" HRESULT LoadZoneMultiStateFont( IDataStore *pIDS, const WCHAR* pszKey, 
                                          IZoneMultiStateFont **ppFont );

#endif // __MULTISTATEFONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\millnetworkcore.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		MillNetworkCore.h
 *
 * Contents:	Millennium "Proxy" protocol module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// MillNetworkCore object
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("{E6C04FD6-5D25-11d3-8846-00C04F8EF45B}")) MillNetworkCore;

// {E6C04FD6-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(CLSID_MillNetworkCore, 
0xe6c04fd6, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\resourcemanager.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ResourceManager.h
 *
 * Contents:	Resource manager interface
 *
 *****************************************************************************/

#ifndef _RESOURCEMANAGER_H_
#define _RESOURCEMANAGER_H_


///////////////////////////////////////////////////////////////////////////////
// IResourceManager
///////////////////////////////////////////////////////////////////////////////

// {3C663534-9F6C-11D2-89AA-00C04F8EC0A2}
DEFINE_GUID(IID_IResourceManager,
	0x3C663534, 0x9F6C, 0x11D2, 0x89, 0xAA, 0x00, 0xC0, 0x4F, 0x8E, 0xC0, 0xA2);

interface __declspec(uuid("{3C663534-9F6C-11D2-89AA-00C04F8EC0A2}"))
IResourceManager : public IUnknown
{
	STDMETHOD_(HINSTANCE,GetResourceInstance)(LPCTSTR lpszName, LPCTSTR lpszType) = 0;

	STDMETHOD_(HANDLE,LoadImage)(LPCTSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad) = 0;

	STDMETHOD_(HBITMAP,LoadBitmap)(LPCTSTR lpBitmapName) = 0;

	STDMETHOD_(HMENU,LoadMenu)(LPCTSTR lpMenuName) = 0;

	STDMETHOD_(HACCEL,LoadAccelerators)(LPCTSTR lpTableName) = 0;

	STDMETHOD_(HCURSOR,LoadCursor)(LPCTSTR lpCursorName) = 0;

	STDMETHOD_(HICON,LoadIcon)(LPCTSTR lpIconName) = 0;

	STDMETHOD_(int,LoadString)(UINT uID, LPTSTR lpBuffer, int nBufferMax) = 0;

	STDMETHOD(AddInstance)(HINSTANCE hInstance) = 0;

	STDMETHOD_(HWND,CreateDialogParam)(
		HINSTANCE hInstance,     
		LPCTSTR lpTemplateName,  		
		HWND hWndParent,         		
		DLGPROC lpDialogFunc,    		
		LPARAM dwInitParam)=0;       

};


///////////////////////////////////////////////////////////////////////////////
// ResourceManager
///////////////////////////////////////////////////////////////////////////////

// {3C663535-9F6C-11D2-89AA-00C04F8EC0A2}
DEFINE_GUID(CLSID_ResourceManager,
	0x3C663535, 0x9F6C, 0x11D2, 0x89, 0xAA, 0x00, 0xC0, 0x4F, 0x8E, 0xC0, 0xA2);

class __declspec(uuid("{3C663535-9F6C-11D2-89AA-00C04F8EC0A2}")) ResourceManager;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\rollover.h ===
#ifndef ROLLOVER_H
#define ROLLOVER_H

#include "atlctrls.h"
#include "zgdi.h"
enum ButtonStates{
	DISABLED=0,
	RESTING,
	ROLLOVER,
	PRESSED,
};

class CRolloverButtonWindowless{
protected:
	CImageList mImageList;
	int mWidth;
	int mHeight;
	RECT mRect;
	bool mCaptured;
	int mState;
	bool mPressed;
	int mFocused;
	int mSpaceBar;
	int mFocusWidth;
	UINT mOldDefId;
	HPALETTE  m_hPal;
	void DrawResting(HDC dc,int x, int y);
	void DrawRollover(HDC dc,int x, int y);
	void DrawPressed(HDC dc,int x, int y);
	void DrawDisabled(HDC dc,int x,int y);
	virtual void SetEnabled(bool enable);
	HDC mHDC;
	HWND mParent;
	DWORD mID;

	static HHOOK				m_hMouseHook;
public:	
	CRolloverButtonWindowless();
	virtual ~CRolloverButtonWindowless();
	bool Init(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,HDC dc,int focusWidth=1, TCHAR* psz=NULL, HFONT hFont=0, COLORREF color=RGB(0,0,0));
	/*
    virtual LRESULT OnKeyDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnSysKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	*/
    virtual LRESULT OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual void CaptureOn();
	virtual void CaptureOff();
	virtual bool HasCapture(){ return mCaptured;}
	virtual void ForceRepaint(bool mCallHasRepainted=TRUE); 
	virtual void HasRepainted();
	virtual void Draw(bool mCallHasRepainted=TRUE);
	virtual void ButtonPressed();
	virtual bool PtInRect(POINT pt); // make sure these coords have been translated to the coords of your offscreen bitmap 
									 // if you're doing windowless

	virtual bool SetPos(CPoint newPos){ OffsetRect( &mRect, newPos.x - mRect.left, newPos.y - mRect.top); return TRUE;};
	virtual HWND GetOwner(){ return mParent;}
	virtual DWORD GetID(){ return mID; }

	static LRESULT	CALLBACK	MouseHook(int nCode, WPARAM wParam, LPARAM lParam );
	static CRolloverButtonWindowless * m_hHookObj;
};

class CRolloverButton:public CRolloverButtonWindowless,public CWindowImpl<CRolloverButton>{
private:
public:
	CRolloverButton();
	bool Init(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,int focusWidth=1, TCHAR* psz=NULL, HFONT hFont=0, COLORREF color=RGB(0,0,0));
	void SetEnabled(bool enable);

    DECLARE_WND_CLASS(TEXT("ZRolloverButton"));
	// Message Map
	BEGIN_MSG_MAP(CRolloverButton)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_ERASEBKGND,OnErase)
	MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
	MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
	MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
	MESSAGE_HANDLER(WM_ENABLE, OnEnable)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDown)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
	MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
    END_MSG_MAP()
	~CRolloverButton();
	// Message Handlers
    LRESULT OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnErase(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnKeyDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnSysKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnEnable(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnKillFocus(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnCaptureChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	// Overides

	// Methods
	// Create a rollover button, on failure returns 0
	static CRolloverButton* CreateButton(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,int focusWidth=1);
	void Draw(bool mCallHasRepainted=TRUE);
	void Enable(bool enable){ EnableWindow(enable);}
	TCHAR GetMnemonic();
	int GetWidth(){ return mWidth+2;} // bitmap + border for highlight
	int GetHeight(){ return mHeight+2;} // bitmap + border for highlight
	// Overloaded from CRolloverButtonWindowless
	void CaptureOn();
	void CaptureOff();
	void ButtonPressed();
	
	HWND GetOwner(){ return m_hWnd;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\rectfrx.h ===
#ifndef __FRX_RECT_H__
#define __FRX_RECT_H__

#include <windows.h>
#include <tchar.h>

namespace FRX
{

//
// CRect differs from Window's RECT in that the right and bottom edges
// are included in calculations.  For example, CRect(0,0,0,0) is considered
// a single pixel and as such the width and height are both 1.
//

class CRect : public RECT
{
public:
	// constructors
	CRect() {}
	CRect( const RECT& srcRect );
	CRect( long l, long t, long r, long b );
	
	void SetRect( long l, long t, long r, long b );

	// accessors
	long GetWidth() const		{ return right - left + 1; }
	long GetHeight() const		{ return bottom - top + 1; }

	// tests
	BOOL IsEmpty() const		{ return ((right < left) || (bottom < top)); }
	BOOL Intersects( const RECT& rc ) const;
	BOOL Intersects( const RECT* rc ) const;
	BOOL PtInRect( long x, long y ) const;	
	BOOL PtInRect( const POINT& pt ) const;


	// operators
	void OffsetRect( long dx, long dy );
	void OffsetRect( const POINT& pt );
	void operator=( const CRect& rc );

	// centers rectangle wrt rcParent
	void UnionRect( const CRect& rc );
	void CenterRect( const CRect& rcParent );
};


class CRectList
{
public:
	// Constructor
	CRectList();

	// Initialization
	HRESULT Init( IResourceManager* pResourceManager, int nResourceId );
	HRESULT Init( HINSTANCE hInstance, int nResourceId );
	HRESULT Init( CRect* pRectArray, int nRects );
	
	// Retreive a rectangle
	const CRect& operator []( int idx );

protected:
	CRect	m_NullRect;
	CRect*	m_Array;
	int		m_NumRects;
};


///////////////////////////////////////////////////////////////////////////////
// CRect Inlines
///////////////////////////////////////////////////////////////////////////////

inline CRect::CRect( long l, long t, long r, long b )
{
	left = l;
	top = t;
	right = r;
	bottom = b;
}


inline CRect::CRect( const RECT& srcRect )
{
	left = srcRect.left;
	top = srcRect.top;
	right = srcRect.right;
	bottom = srcRect.bottom;
}


inline void CRect::SetRect( long l, long t, long r, long b )
{
	left = l;
	top = t;
	right = r;
	bottom = b;
}


inline BOOL CRect::PtInRect( long x, long y ) const
{
	return ((left <= x) && (right >= x) && (top <= y) && (bottom >= y));
}


inline BOOL CRect::PtInRect( const POINT& pt ) const
{
	return PtInRect( pt.x, pt.y );
}


inline BOOL CRect::Intersects( const RECT& rc ) const
{
	return !((right < rc.left) || (bottom < rc.top) || (left > rc.right) || (top > rc.bottom));
}

inline BOOL CRect::Intersects( const RECT* rc ) const
{
	return !((right < rc->left) || (bottom < rc->top) || (left > rc->right) || (top > rc->bottom));
}


inline void CRect::OffsetRect( long dx, long dy ) 
{
	left += dx;
	right += dx;
	top += dy;
	bottom += dy;
}


inline void CRect::OffsetRect( const POINT& pt )
{
	OffsetRect( pt.x, pt.y );
}


inline void CRect::operator=( const CRect& rc )
{
	left = rc.left;
	right = rc.right;
	top = rc.top;
	bottom = rc.bottom;
}


inline void CRect::CenterRect( const CRect& rcParent )
{
	long w = right - left;
	long h = bottom - top;

	left = rcParent.left + ((rcParent.right - rcParent.left) - w) / 2;
	top = rcParent.top + ((rcParent.bottom - rcParent.top) - h) / 2;
	right = left + w;
	bottom = top + h;
}


inline void CRect::UnionRect( const CRect& rc )
{
	if ( rc.left < left )
		left = rc.left;
	if ( rc.top < top )
		top = rc.top;
	if ( rc.right > right )
		right = rc.right;
	if ( rc.bottom > bottom )
		bottom = rc.bottom;
}


///////////////////////////////////////////////////////////////////////////////
// CRectList Inlines
///////////////////////////////////////////////////////////////////////////////

inline CRectList::CRectList()
	: m_NullRect( 0, 0, 0, 0 )
{
	m_NumRects = 0;
	m_Array = NULL;
}

inline HRESULT CRectList::Init( IResourceManager* pResourceManager, int nResourceId )
{
	HANDLE hInstance;		

	// get resource handle
	hInstance = pResourceManager->GetResourceInstance( MAKEINTRESOURCE( nResourceId ), _T("RECTS") );
	if ( !hInstance )
		return E_FAIL;

	return Init( hInstance, nResourceId );

}

inline HRESULT CRectList::Init( HINSTANCE hInstance, int nResourceId )
{
	HRSRC handle;
	int* ptr;

	// get resource handle
	handle = FindResource( hInstance, MAKEINTRESOURCE( nResourceId ), _T("RECTS") );
	if ( !handle )
		return E_FAIL;

	// get pointer to resource
	ptr = (int*) LockResource( LoadResource( hInstance, handle ) );
	if ( !ptr )
		return E_FAIL;

	// init number of rectangles
	m_NumRects = *ptr;
	if (m_NumRects <= 0)
		return E_FAIL;

	// init array pointer
	m_Array = (CRect*)( ptr + 1 );

	return NOERROR;
}


inline HRESULT CRectList::Init( CRect* pRectArray, int nRects )
{
	// parameter paranoia
	if ( !pRectArray || (nRects <= 0) )
		return E_INVALIDARG;

	m_NumRects = nRects;
	m_Array = pRectArray;
	return NOERROR;
}


inline const CRect& CRectList::operator[]( int idx )
{
#if _DEBUG
	if ((idx < 0) || (idx >= m_NumRects))
		return m_NullRect;
	else
#endif
		return m_Array[idx];
}

}

using namespace FRX;

#endif //!__FRX_RECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\textwindow.h ===
#ifndef TEXTWINDOW_H
#define TEXTWINDOW_H

#include <atlwin.h>
#include <atlctrls.h>
#include "ZoneString.h"

#define SCROLL_TICK (5000)
#define SCROLL_EVENT_ID (100)

#define CTEXTWINDOW_STYLE_EX WS_EX_TRANSPARENT
#define CTEXTWINDOW_STYLE WS_VISIBLE | WS_CHILD | WS_TABSTOP | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL

class CTextWindow : public CWindowImpl<CTextWindow,CRichEditCtrl>
{
	HINSTANCE hInstRich;

public:
	CTextWindow(){LoadRichEditLib();}
	~CTextWindow(){}

	BEGIN_MSG_MAP(CTextWindow)
		MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	END_MSG_MAP()

	virtual DWORD GetTextWndStyle(){return (CTEXTWINDOW_STYLE|WS_VSCROLL);} 
		
	HWND Create(HWND hWndParent, RECT& rcPos);

virtual bool InsertTextFile(TCHAR * pszTextFile);
		bool SetFontColor(COLORREF rgbColor);

protected:

	void	LoadRichEditLib(){hInstRich = ::LoadLibrary(_T("RICHED20.DLL"));}
	LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){return 0;}
	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){::SetFocus((HWND) wParam); return 0;}
};

class CMarqueeTextWindow : public CTextWindow
{
	public:
		CMarqueeTextWindow(){}
		~CMarqueeTextWindow(){KillTimer(SCROLL_EVENT_ID);}

		BEGIN_MSG_MAP(CMarqueeTextWindow)
			MESSAGE_HANDLER(WM_TIMER, OnTimer)
		END_MSG_MAP()

		virtual DWORD GetTextWndStyle(){return (CTEXTWINDOW_STYLE);} 
		
		LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
		{
			TCHAR pszString[ZONE_MAXSTRING];
			int nIdx = GetFirstVisibleLine();
			
			int nBegin = LineIndex(nIdx);
			int nEnd= LineIndex(nIdx+1);
			int nLineLength =  LineLength(nIdx); 
			
			int nChar = GetLine( nIdx, pszString, ZONE_MAXSTRING);
			pszString[nChar] = _T('\0');
			
			SetSel(nBegin, nEnd);
			Clear();

			AppendText(pszString);
			
			return 1;
		}

		virtual bool InsertTextFile(TCHAR * pszTextFile)
		{
			CTextWindow::InsertTextFile(pszTextFile);
			SetTimer(SCROLL_EVENT_ID, SCROLL_TICK);
			return true;
		}
};

#endif //TEXTWINDOW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\serviceid.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ServiceId.h
 *
 * Contents:	Zone service ids
 *
 *****************************************************************************/

#ifndef _SERVICEID_H_
#define _SERVICEID_H_


// {EFB5B567-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_EventQueue, 
0xefb5b567, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {D60D46D8-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyDataStore, 
0xd60d46d8, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {D60D46DA-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_DataStoreManager, 
0xd60d46da, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EFB5B568-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_DataStoreObjects, 
0xefb5b568, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EFB5B569-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_DataStoreUI, 
0xefb5b569, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {C4C9D895-E80B-11d2-8B5B-00C04F8EF2FF}
DEFINE_GUID(SRVID_DataStorePreferences, 
0xc4c9d895, 0xe80b, 0x11d2, 0x8b, 0x5b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EFB5B56A-C22A-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_ResourceManager, 
0xefb5b56a, 0xc22a, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {E6C04FD9-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(SRVID_MillEngine, 
0xe6c04fd9, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

// {67EBB783-C25E-11d2-8B1C-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyCore, 
0x67ebb783, 0xc25e, 0x11d2, 0x8b, 0x1c, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {E6C04FD7-5D25-11d3-8846-00C04F8EF45B}
DEFINE_GUID(SRVID_NetworkCore, 
0xe6c04fd7, 0x5d25, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

// {B5A84EA5-D541-11d2-8B3B-00C04F8EF2FF}
DEFINE_GUID(SRVID_TimerManager, 
0xb5a84ea5, 0xd541, 0x11d2, 0x8b, 0x3b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {9C770675-CFF0-11d2-8B30-00C04F8EF2FF}
DEFINE_GUID(SRVID_Launcher, 
0x9c770675, 0xcff0, 0x11d2, 0x8b, 0x30, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {B72DFFC2-E1C0-11d2-8B53-00C04F8EF2FF}
DEFINE_GUID(SRVID_Latency, 
0xb72dffc2, 0xe1c0, 0x11d2, 0x8b, 0x53, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EC5B9F85-1871-11d3-8B75-00C04F8EF2FF}
DEFINE_GUID(SRVID_CommandManager, 
0xec5b9f85, 0x1871, 0x11d3, 0x8b, 0x75, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {F3A3837D-9636-11d3-884D-00C04F8EF45B}
DEFINE_GUID(SRVID_InputManager, 
0xf3a3837d, 0x9636, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

// {B12D3E60-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(SRVID_AccessibilityManager, 
0xb12d3e60, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);



// LOBBY Services

// {229A68F1-F98F-11d2-89BA-00C04F8EC0A2}
DEFINE_GUID(SRVID_LobbyWindow, 
0x229a68f1, 0xf98f, 0x11d2, 0x89, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

// {9A1FF2D9-C6C6-11d2-8B23-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyWindowManager, 
0x9a1ff2d9, 0xc6c6, 0x11d2, 0x8b, 0x23, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {25FF89A5-C79D-11d2-8B23-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyAdCtl, 
0x25ff89a5, 0xc79d, 0x11d2, 0x8b, 0x23, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {12E6224F-FD06-11d2-89BB-00C04F8EC0A2}
DEFINE_GUID(SRVID_LobbyLogoCtl, 
0x12e6224f, 0xfd06, 0x11d2, 0x89, 0xbb, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

// {25FF89A6-C79D-11d2-8B23-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyTableViewCtl, 
0x25ff89a6, 0xc79d, 0x11d2, 0x8b, 0x23, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EF63EEF8-28EF-11d3-89D5-00C04F8EC0A2}
DEFINE_GUID(SRVID_LobbyTableInfoCtl, 
0xef63eef8, 0x28ef, 0x11d3, 0x89, 0xd5, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

// {25FF89A7-C79D-11d2-8B23-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyUserListCtl, 
0x25ff89a7, 0xc79d, 0x11d2, 0x8b, 0x23, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {25FF89A8-C79D-11d2-8B23-00C04F8EF2FF}
DEFINE_GUID(SRVID_LobbyChatCtl, 
0x25ff89a8, 0xc79d, 0x11d2, 0x8b, 0x23, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);


// {AD0E6017-3C85-11d3-8B95-00C04F8EF2FF}
DEFINE_GUID(SRVID_NetworkManager, 
0xad0e6017, 0x3c85, 0x11d3, 0x8b, 0x95, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);


// {0E8C286C-5C59-11d3-8846-00C04F8EF45B}
DEFINE_GUID(SRVID_LobbyGameCtl, 
0xe8c286c, 0x5c59, 0x11d3, 0x88, 0x46, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

// {BD0BA6D2-7079-11d3-8847-00C04F8EF45B}
DEFINE_GUID(SRVID_PhysicalNetwork, 
0xbd0ba6d2, 0x7079, 0x11d3, 0x88, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);


// LAUNCHPAD Services

// {536AB365-1A63-11d3-8B75-00C04F8EF2FF}
DEFINE_GUID(SRVID_LaunchPad, 
0x536ab365, 0x1a63, 0x11d3, 0x8b, 0x75, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {EBB64B00-1A61-11d3-8B75-00C04F8EF2FF}
DEFINE_GUID(SRVID_LaunchPadUserListCtl, 
0xebb64b00, 0x1a61, 0x11d3, 0x8b, 0x75, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

// {5731EDBA-1DD9-11d3-89CA-00C04F8EC0A2}
DEFINE_GUID(SRVID_LaunchPadChatCtl, 
0x5731edba, 0x1dd9, 0x11d3, 0x89, 0xca, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

// {5731EDB9-1DD9-11d3-89CA-00C04F8EC0A2}
DEFINE_GUID(SRVID_LaunchPadAdCtl, 
0x5731edb9, 0x1dd9, 0x11d3, 0x89, 0xca, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

//!! Hack to prevent platform\include
DEFINE_GUID(CLSID_zProxy,
0xFD3C6486, 0xF387, 0x11D2, 0x8B, 0x66, 0x0, 0xC0, 0x4F, 0x8E, 0xF2, 0xFF);

// {1C3BFC65-D49A-4f92-95F7-968D78F70FFC}
DEFINE_GUID(SRVID_MillCore, 
0x1c3bfc65, 0xd49a, 0x4f92, 0x95, 0xf7, 0x96, 0x8d, 0x78, 0xf7, 0xf, 0xfc);

// {B65F73B6-7694-4ba1-84EF-9A1868420E20}
DEFINE_GUID(SRVID_MillNetworkCore, 
0xb65f73b6, 0x7694, 0x4ba1, 0x84, 0xef, 0x9a, 0x18, 0x68, 0x42, 0xe, 0x20);


// GAME Services

// {B12D3E64-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(SRVID_GraphicalAccessibility, 
0xb12d3e64, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\splitter.h ===
#pragma once

class CSplitter
{
	// base class for splitter bars. 
public:
	enum ORIENTATION {
		VERTICAL = 0,
		HORIZONTAL = 1,
	};

protected:

	int m_SplitterWidth;			// the width of the UI splitter 	
	ORIENTATION m_Orientation;		// the orientation of the splitter

	// X coordinates refer to TopLeft pane
	// Y coordinates refer to BottomRight pane
	CSize m_Size;			// current size of panes
	CRect m_MinMax;			// min/max sizes for panes

	CPoint m_ptDown;		// mouse down location
	CSize m_SizeInitial;	// initial size during resize, remembered in case the resize is aborted

public:
	CSplitter(const CRect& MinMax, ORIENTATION Orientation) :
		m_MinMax(MinMax),
		m_Size(0,0),
		m_Orientation(Orientation),
		m_SplitterWidth(8) {}

	int SizeTop() { return m_Size.cx; }
	int SizeLeft() { return m_Size.cx; }
	int SizeBottom() { return m_Size.cy; }
	int SizeRight() { return m_Size.cy; }

	int GetSplitterWidth() { return m_SplitterWidth; }
	void SetSplitterWidth(int SplitterWidth) { m_SplitterWidth = SplitterWidth; }

	const CRect& GetMinMax() { return m_MinMax; }
	void SetMinMax(const CRect& MinMax) { m_MinMax = MinMax; }

	virtual void Start(const CPoint& ptDown) 
	{ 
		m_ptDown = ptDown; 
		m_SizeInitial = m_Size;
	}
	virtual void Move(const CPoint& ptMouse) 
	{
		int movement( (m_Orientation == VERTICAL) ? ptMouse.x-m_ptDown.x : ptMouse.y-m_ptDown.y);

		m_Size = m_SizeInitial + CSize(movement, -movement);

		// crop to ensure we don't exceed any min/max bounds for either pane
		MinMaxAdjust();
	}

	virtual void End() {}
	virtual void Abort() { m_Size = m_SizeInitial; }

	virtual void Resize(int Size)
	{
		// derrived classes should implement a resize strategy

		// this class just tries to ensure we don't exceed our stated min/max values

		// crop to ensure we don't exceed any min/max bounds for either pane
		MinMaxAdjust();
	}
protected:
	void MinMaxAdjust(void)
	{
		// crop to ensure we don't exceed any min/max bounds for either pane

		

		// if the top/left pane is too small, or the right/bottom pane is too big,
		// we'll need to move the splitter towards the bottom/right.

		// adjust if we're below the top/left minimum
		int AdjustRight = 0;
		AdjustRight = max( AdjustRight, m_MinMax.left-m_Size.cx);
		if ( m_MinMax.right )
			AdjustRight = max( AdjustRight, m_Size.cy-m_MinMax.bottom);

		int AdjustLeft = 0;
		AdjustLeft = max( AdjustLeft, m_MinMax.top-m_Size.cy);
		if ( m_MinMax.bottom )
			AdjustLeft = max( AdjustLeft, m_Size.cx-m_MinMax.right);

		AdjustRight -= AdjustLeft;

		m_Size += CSize( AdjustRight, -AdjustRight);

#if 0
		if ( m_Size.cx < m_MinMax.left )
		{
			m_Size += CSize( m_MinMax.left-m_Size.cx, m_Size.cx-m_MinMax.left);
		}

		if ( m_Size.cy > m_MinMax.bottom && m_MinMax.right )
		{

			m_Size += CSize( m_Size.cy-m_MinMax.bottom, m_MinMax.bottom-m_Size.cy);
		}


		if ( m_Size.cy < m_MinMax.top )
		{
			m_Size += CSize( m_Size.cy-m_MinMax.top, m_MinMax.top-m_Size.cy);
		}

		if ( m_Size.cx > m_MinMax.right && m_MinMax. )
		{
			m_Size += CSize( m_MinMax.right-m_Size.cx, m_Size.cx-m_MinMax.right);
		}
#endif
	}

};

class CSplitterFixed : public CSplitter
{
	// a splitter that maintains a fixed size to one side
public:
	enum FIXED_SIDE {
		LEFT = 0,
		RIGHT = 1,
	};

protected:

	FIXED_SIDE m_FixedSide;		// the side which should remain a fixed size
	long m_SizeIdeal;			// the ideal size to allocated to m_FixedSide

public:

	CSplitterFixed(const CRect& MinMax, ORIENTATION Orientation, 
		           int SizeIdeal, FIXED_SIDE FixedSide) :
		CSplitter( MinMax, Orientation),
		m_SizeIdeal(SizeIdeal),
		m_FixedSide(FixedSide) {}

	long GetSizeIdeal(void) { return m_SizeIdeal; }
	void SetSizeIdeal(long SizeIdeal) { m_SizeIdeal = SizeIdeal; }

	void End() 
	{
		// establish the  new ideal size following a splitter move
		m_SizeIdeal = (m_FixedSide == LEFT) ? m_Size.cx : m_Size.cy;
	}

	void Resize(int Size)
	{
		// The goal of the resize is to keep one pane a user settable "ideal size," adding all
		// additional space to the other pane.

		// leave room for the actual splitter
		Size -= m_SplitterWidth;
		
		// try and get ideal size for pane.
		m_Size = (m_FixedSide == LEFT) ? CSize(m_SizeIdeal, Size-m_SizeIdeal) :
										 CSize(Size-m_SizeIdeal, m_SizeIdeal);

		CSplitter::Resize(Size);
	}
};

class CSplitterProportional : public CSplitter
{
protected:

	double m_ProportionIdeal;		// the ideal proportion to allocate to the left pane

public:

	// a splitter that maintains proportional spacing between sides
	CSplitterProportional(const CRect& MinMax, ORIENTATION Orientation, const double& Proportion ) :
		CSplitter( MinMax, Orientation),
		m_ProportionIdeal(Proportion) {}

	double GetProportionIdeal(void) { return m_ProportionIdeal; }
	void SetProportionIdeal(double ProportionIdeal) { m_ProportionIdeal = ProportionIdeal; }

	void End() 
	{
		// establish the  new ideal proportion following a splitter move

		// if End() is called, the user has verified this is the ideal size they want.
		m_ProportionIdeal = (double)m_Size.cx / (double)(m_Size.cx+m_Size.cy);
	}

	void Resize(int Size) 
	{
		// The goal of the resize is to keep the ideal proportion of the panes visible

		// leave some space for the actuall splitter
		Size -= m_SplitterWidth;
		
		int SizeTop((int)(Size * m_ProportionIdeal));

		m_Size = CSize(SizeTop, Size-SizeTop);

		CSplitter::Resize(Size);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\timer.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Timer.h
 *
 * Contents:	Simple timer
 *
 * Notes:	(1)	The thread creating the TimerManager object must have an
 *				active message pump so SetTimer works.
 *			(2) Only one TimerManager my be created per application due to
 *				the global variable used to look up the callback context.
 *
 *****************************************************************************/

#ifndef __TIMER_H_
#define __TIMER_H_

//////////////////////////////////////////////////////////////////////////////
// ITimerManager
///////////////////////////////////////////////////////////////////////////////

// {0D4AF0DB-D529-11d2-8B3B-00C04F8EF2FF}
DEFINE_GUID(IID_ITimerManager, 
0xd4af0db, 0xd529, 0x11d2, 0x8b, 0x3b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{0D4AF0DB-D529-11d2-8B3B-00C04F8EF2FF}"))
ITimerManager : public IUnknown
{
	//
	// ITimerManager::PFTIMERCALLBACK
	//
	// Application defined callback for ITimerManager::CreateTimer method.
	//
	// Parameters:
	//	pITimer
	//		Pointer to timer interface responsible for the callback.
	//	pContext
	//		Context supplied in ITimer::SetCallback.
	//
	typedef HRESULT (ZONECALL *PFTIMERCALLBACK)(
		ITimerManager*	pITimerManager,
		DWORD			dwTimerId,
		DWORD			dwTime,
		LPVOID			pContext );

	//
	// ITimerManager::CreateTimer
	//
	// Creates a timer.
	//
	// Parameters:
	//	dwMilliseconds
	//		Amount of time in milliseconds between callbacks.
	//	pfCallback
	//		Application defined callback function.
	//	pContext
	//		Application defined context to included in the callback
	//	pdwTimerId
	//		Pointer to dword to receive timer id.
	//
	STDMETHOD(CreateTimer)(
		DWORD			dwMilliseconds,
		PFTIMERCALLBACK	pfCallback,
		LPVOID			pContext,
		DWORD*			pdwTimerId ) = 0;

	//
	// ITimerManager::DeleteTimer
	//
	// Deletes a timer.
	//
	// Parameters:
	//	dwTimerId
	//		Timer id provided by the CreateTimer method.
	//
	STDMETHOD(DeleteTimer)( DWORD dwTimerId ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// TimerManager object
///////////////////////////////////////////////////////////////////////////////

// {0D4AF0DD-D529-11d2-8B3B-00C04F8EF2FF}
DEFINE_GUID(CLSID_TimerManager, 
0xd4af0dd, 0xd529, 0x11d2, 0x8b, 0x3b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{0D4AF0DD-D529-11d2-8B3B-00C04F8EF2FF}")) CTimerManager;


#endif // __TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zcards.h ===
/*******************************************************************************

	ZCards.h
	
		Zone(tm) card data file constants.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Friday, August 4, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	1		11/11/96	HI		Moved definition of zNumSmallCardTypes from
								zcards.c.
	0		08/05/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZCARDS_
#define _ZCARDS_

#ifdef __cplusplus
extern "C" {
#endif



#define zCardsNumCardsInDeck			52
#define zCardsNumSuits					4
#define zCardsNumCardsInSuit			13

#define zCardsSizeWidth					54
#define zCardsSizeHeight				72

#define zCardsSmallSizeWidth			27
#define zCardsSmallSizeHeight			36

#define ZCardsMakeIndex(suit, rank)		((suit) * zCardsNumCardsInSuit + (rank))
#define ZCardsSuit(cardIndex)			((cardIndex) / zCardsNumCardsInSuit)
#define ZCardsRank(cardIndex)			((cardIndex) % zCardsNumCardsInSuit)

#define zNumSmallCardTypes				4
	

enum
{
	/* -------- Card Types -------- */
	zCardsNormal = 0,
	zCardsSmallUp,
	zCardsSmallDown,
	zCardsSmallLeft,
	zCardsSmallRight,
	
	/* -------- Card Suits -------- */
	zCardsSuitSpades = 0,
	zCardsSuitHearts,
	zCardsSuitDiamonds,
	zCardsSuitClubs,

	/* -------- Card Ranks -------- */
	zCardsRank2 = 0,
	zCardsRankJack = 9,
	zCardsRankQueen,
	zCardsRankKing,
	zCardsRankAce
};


/* -------- Exported Routines -------- */
ZError ZCardsInit(int16 cardType);
void ZCardsDelete(int16 cardType);
void ZCardsDrawCard(int16 cardType, int16 cardIndex, ZGrafPort grafPort, ZRect* rect);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#include <BasicATL.h>


#if 0
//!! do we want any of this?
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zclicon.h ===
/*******************************************************************************

	Zclicon.h
	
		Zone(tm) Client Connection API.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, April 29, 1995 06:26:45 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
	1		1/13/97		JWS		Removed from zone.h
	0		04/29/95	HI		Created.
	 
*******************************************************************************/

// @doc ZCLICON

#ifndef _ZCLICON_
#define _ZCLICON_



#ifdef __cplusplus
extern "C" {
#endif

//#define ENABLE_TRACE
void XPrintf(char *format, ...);

#ifdef ENABLE_TRACE
#define ZTRACE	XPrintf
#else
#define ZTRACE	1 ? (void)0 : XPrintf
#endif



/*******************************************************************************
		Client Connection Services
*******************************************************************************/

#define ZIsSystemMessage(type)		(((uint32) (type)) & 0x80000000 ? TRUE : FALSE)

/* -------- Message Types -------- */
enum
{
    /* Program Specific Message Types (0 - 0x7FFFFFFF) */
    zConnectionProgramMessageBaseID = 0,

    /* System Reserved Message Types (0x80000000 - 0xFFFFFFFF) */
    zConnectionSystemAlertExMessage = 0xFFFFFFFE,
    zConnectionSystemAlertMessage = 0xFFFFFFFF
	
};

/* -------- Connection Events -------- */
enum
{
	/*
		These events are passed to the client connection message procedure
		whenever an event takes place.
	*/
	
	zConnectionOpened = 1,
	zConnectionOpenFailed,
	zConnectionAccessDenied,
	zConnectionLoginCancel,
	zConnectionMessageAvail,
		/* Available message in the queue to be retrieved. */
	zConnectionClosed
		/* Connection closed by host -- connection lost. */
};

/* -------- Connection Retrieval Flags -------- */
enum
{
	zConnectionMessageGetAny		= 0x0000,
		/* Get next and remove from queue. */
	zConnectionMessageNoRemove		= 0x0001,
		/* Do not remove from queue. */
	zConnectionMessageSearch		= 0x0002
		/* Get next of the given type. */
};


BOOL ZNetworkOnlyLibInit(HINSTANCE hInstance);		// Added by JohnSe 12/16/97
void ZNetworkOnlyLibExit();							// Added by JohnSe 12/16/97

typedef void* ZCConnection;

typedef void (*ZCConnectionMessageFunc)(ZCConnection connection, int32 event, void* userData);


/* -------- Routines -------- */
ZCConnection ZCConnectionNew(void);
	/*
		Allocates a new client connection object.
		
		Returns NULL if it is out of memory.
	*/
	
ZError ZCConnectionInit(ZCConnection connection, char* hostName,
		uint32 hostAddr, uint32 hostPortNumber, char* userName, char * Password, 
		ZCConnectionMessageFunc messageFunc, void* userData);
	/*
		Initializes the connection object by connection to the host. It uses
		hostName only if hostAddr is 0. Initiates an open to the host; when the
		connection is established, the message func is called with zConnectionOpened
		message. Once the connection has been established, network access is
		available.
	*/
	
void ZCConnectionDelete(ZCConnection connection);
	/*
		Deletes the connection object. The connection to the host is
		automatically closed.
	*/
	
char* ZCConnectionRetrieve(ZCConnection connection, int32* type,
		int32* len, int32 flags);
	/*
		Retrieves a message in the queue of the given connection. It returns
		a pointer to the data and the type and length of the data.
		
		The returned pointer to the data must be disposed of by the caller
		when it is through with the data.
		
		If requesting for a particular type of message, then store the
		desired type in the type field and set flags to zConnectionMessageSearch.
		
		It returns NULL if no message is available on the connection.
	*/

// @func int | ZCConnectionSend| Sends the message stored in buffer to the connection.

ZError ZCConnectionSend(
	ZCConnection connection, //@parm Connection for message to be sent on
							 //created by <f ZCConnectionNew> and <f ZCConnectionInit>
	int32 type, //@parm Application defined message type
	char* buffer, //@parm message data to be sent
	int32 len); //@parm length of message

// @rdesc Returns 0 or <m zErrNetworkWrite>
//
// @comm This function creates the Connection Layer packet with
// headers <t ZConnInternalHeaderType> and <t ZConnMessageHeaderType>

ZError ZCConnectionUserName(ZCConnection connection, char * userName);
	/*
		Gets the user name associated with a connection
	*/


#ifdef __cplusplus
}
#endif

#endif //_ZCLICON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zdialogimpl.h ===
#ifndef _ZDIALOGIMPL_H
#define _ZDIALOGIMPL_H

#include <atlbase.h>
#include <atlwin.h>

template <class T, class TBase = CWindow>
class ATL_NO_VTABLE ZDialogImpl : public CDialogImpl< T, TBase >
{
	public:

		
	ATLINLINE ATLAPI_(HWND) ZAtlAxCreateDialog(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
	{
		AtlAxWinInit();
		HRSRC hDlg = ::FindResource(hInstance, lpTemplateName, (LPTSTR)RT_DIALOG);
		HRSRC hDlgInit = ::FindResource(hInstance, lpTemplateName, (LPTSTR)_ATL_RT_DLGINIT);
		HGLOBAL hData = NULL;
		BYTE* pInitData = NULL;
		HWND hWnd = NULL;

		if (hDlgInit)
		{
			hData = ::LoadResource(hInstance, hDlgInit);
			pInitData = (BYTE*) ::LockResource(hData);
		}
		if (hDlg)
		{
			HGLOBAL hResource = LoadResource(hInstance, hDlg);
			DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
			LPCDLGTEMPLATE lpDialogTemplate;
			lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
// ATL BUGBUG. Changed hInstance to _Module.GetModuleInstance(). Also, provide on one version
//             of this function instead of A and W versions.			
			hWnd = ::CreateDialogIndirectParam(_Module.GetModuleInstance(), lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
			if (lpDialogTemplate != pDlg)
				GlobalFree(GlobalHandle(lpDialogTemplate));
			UnlockResource(hResource); 
			FreeResource(hResource);
		}
		if (pInitData && hDlgInit)
		{
			UnlockResource(hData);
			FreeResource(hData);
		}
		return hWnd;
	}

	int DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		HINSTANCE hInstance = _Module.GetResourceInstance( MAKEINTRESOURCE(T::IDD),RT_DIALOG);
        if(!hInstance)
            hInstance = _Module.GetResourceInstance();
		return AtlAxDialogBox(hInstance, MAKEINTRESOURCE(T::IDD),
				hWndParent, T::StartDialogProc, dwInitParam);
	}

	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		HWND hWnd;

		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG

		HINSTANCE hInstance = _Module.GetResourceInstance( MAKEINTRESOURCE(T::IDD),RT_DIALOG);
        if(!hInstance)
            hInstance = _Module.GetResourceInstance();

		hWnd = ZAtlAxCreateDialog( hInstance, MAKEINTRESOURCE(T::IDD), hWndParent, T::StartDialogProc, dwInitParam);

		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
};


#endif //_ZDIALOGIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zonecli.h ===
/*******************************************************************************

	ZoneCli.h
	
		Zone(tm) Client DLL header file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on Thursday, November 7, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	4		05/15/97	HI		Removed zLobbyRoomName.
	3		02/26/97	HI		Set file and path name lengths to _MAX_PATH.
	2		02/11/97	RJK		Added zLobbyRoomName define
	1		12/27/96	HI		Removed m_gNameRects.
	0		11/07/96	HI		Created.
	 
*******************************************************************************/


#ifndef _ZONECLI_
#define _ZONECLI_

#include <basicatl.h>

#ifndef _ZSYSTEM_
#include "zone.h"
#endif

#ifndef _RETAIL_
#include "zroom.h"
#endif

#ifndef _ZONEMEM_H_
#include "zonemem.h"
#endif


#include <windows.h>
#include <tchar.h>
#include "uapi.h"


#include "GameShell.h"
#include "GraphicalAcc.h"

#ifdef __cplusplus

template <class T>
class ATL_NO_VTABLE CGameGameImpl :
    public IGameGame,
    public CComObjectRootEx<CComSingleThreadModel>
{
    friend class CGameGameImpl<T>;

public:
    // Should Override
    STDMETHOD(SendChat)(TCHAR *szText, DWORD cchChars) { return S_OK; }
    STDMETHOD(GameOverReady)() { return S_OK; }
    STDMETHOD(GamePromptResult)(DWORD nButton, DWORD dwCookie) { return S_OK; };

    //
    CGameGameImpl<T>() : m_game(this) { }
    STDMETHOD(AttachGame)(ZCGame game) { m_game = game; return S_OK; }
    STDMETHOD_(ZCGame, GetGame)() { return m_game; }

    STDMETHOD_(HWND, GetWindowHandle)() { return NULL; }

    STDMETHOD(ShowScore)() { return S_OK; }

    // utility to assist creating in a one-off context
    // i.e. when you just want to make a IGameGame to return from ZoneClientGameNew()
    // don't use if you have implemented CGameGameImpl as your main Game class
    static T* BearInstance(ZCGame game)
    {
        CComObject<T> *p = NULL;
        HRESULT hr = CComObject<T>::CreateInstance(&p);

	    if(FAILED(hr))
            return NULL;

        hr = p->AttachGame(game);
	    if(FAILED(hr))
        {
            p->Release();
            return NULL;
        }

        return p;
    }

BEGIN_COM_MAP(T)
	COM_INTERFACE_ENTRY(IGameGame)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

private:
    ZCGame m_game;
};

extern "C" {
#else
typedef void* IGameGame;
#endif // _cplusplus


typedef struct
{
    TCHAR*           gameID;
	TCHAR*			game;
	TCHAR*			gameName;
	TCHAR*			gameDll;
	TCHAR*			gameDataFile;
	TCHAR*			gameCommandLine;
	TCHAR*			gameServerName;
	unsigned int	gameServerPort;
	uint32			screenWidth;
	uint32			screenHeight;
	int16			chatOnly;  /* mdm 8.18.97 */
} GameInfoType, *GameInfo;

// Zone Game Client Shell Routines

typedef int		(CALLBACK * ZUserMainInitCallback)(HINSTANCE hInstance,HWND OCXWindow, IGameShell *piGameShell, GameInfo gameInfo); 
typedef int		(CALLBACK * ZUserMainRunCallback)(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result);
typedef int		(CALLBACK * ZUserMainStopCallback)(void);
typedef BOOL	(CALLBACK * ZUserMainDisabledCallback)(void);

int EXPORTME UserMainInit(HINSTANCE hInstance,HWND OCXWindow, IGameShell *piGameShell, GameInfo gameInfo);
int EXPORTME UserMainRun(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result);
int EXPORTME UserMainStop();
BOOL EXPORTME UserMainDisabled();

/* -------- Zone Game Client Exported Routines -------- */
ZError				ZoneGameDllInit(HINSTANCE hLib, GameInfo gameInfo);
void				ZoneGameDllDelete(void);

ZError				ZoneClientMain(_TUCHAR* commandLine, IGameShell *piGameShell);
void				ZoneClientExit(void);
void				ZoneClientMessageHandler(ZMessage* message);
TCHAR*				ZoneClientName(void);
TCHAR*				ZoneClientInternalName(void);
ZVersion			ZoneClientVersion(void);

IGameGame*			ZoneClientGameNew(ZUserID userID, int16 tableID, int16 seat, int16 playerType, ZRoomKibitzers* kibitzers);
void				ZoneClientGameDelete(ZCGame game);
ZBool				ZoneClientGameProcessMessage(ZCGame game, uint32 messageType, void* message, int32 messageLen);
void				ZoneClientGameAddKibitzer(ZCGame game, int16 seat, ZUserID userID);
void				ZoneClientGameRemoveKibitzer(ZCGame game, int16 seat, ZUserID userID);


void* ZGetStockObject(int32 objectID);

#ifdef __cplusplus
}

// functions for getting shell objects
IGameShell          *ZShellGameShell();

IZoneShell          *ZShellZoneShell();
IResourceManager    *ZShellResourceManager();
ILobbyDataStore     *ZShellLobbyDataStore();
ITimerManager       *ZShellTimerManager();
IDataStoreManager   *ZShellDataStoreManager();
IDataStore          *ZShellDataStoreConfig();
IDataStore          *ZShellDataStoreUI();
IDataStore          *ZShellDataStorePreferences();
HRESULT ZShellCreateGraphicalAccessibility(IGraphicalAccessibility **ppIGA);

#endif


#ifdef ZONECLI_DLL

#ifndef _ZCARDS_
#include "zcards.h"
#endif

#ifndef _RETAIL_
#ifndef _ZCLIROOM_
#include "zcliroom.h"
#endif
#endif


enum
{
	zFuncZClientMain = 0,
	zFuncZClientExit,
	zFuncZClientMessageHandler,
	zFuncZClientName,
	zFuncZClientInternalName,
	zFuncZClientVersion,
	zFuncZCGameNew,
	zFuncZCGameDelete,
	zFuncZCGameProcessMessage,
	zFuncZCGameAddKibitzer,
	zFuncZCGameRemoveKibitzer
};


typedef ZError				(*ZGameDllInitFunc)(HINSTANCE hLib, GameInfo gameInfo);
typedef void				(*ZGameDllDeleteFunc)(void);

typedef ZError				(*ZClientMainFunc)(TCHAR* commandLine, IGameShell *piGameShell);
typedef void				(*ZClientExitFunc)(void);
typedef void				(*ZClientMessageHandlerFunc)(ZMessage* message);
typedef TCHAR*				(*ZClientNameFunc)(void);
typedef TCHAR*				(*ZClientInternalNameFunc)(void);
typedef ZVersion			(*ZClientVersionFunc)(void);

typedef IGameGame*			(*ZCGameNewFunc)(ZUserID userID, int16 tableID, int16 seat, int16 playerType,
									ZRoomKibitzers* kibitzers);
typedef void				(*ZCGameDeleteFunc)(ZCGame game);
typedef ZBool				(*ZCGameProcessMessageFunc)(ZCGame game, uint32 messageType, void* message,
									int32 messageLen);
typedef void				(*ZCGameAddKibitzerFunc)(ZCGame game, int16 seat, ZUserID userID);
typedef void				(*ZCGameRemoveKibitzerFunc)(ZCGame game, int16 seat, ZUserID userID);


#ifndef _RETAIL_

#ifdef __cplusplus
class IFriends;
#else
typedef void* IFriends;
#endif

/* Little Zone Tip supporting class */
struct CDialogTip;   // would call it a class, but there's too many silly .c files everywhere - they freak out


/* Client DLL Globals */
typedef struct
{
	// Virtual screen -- actually the lobby control size.
	uint32				m_screenWidth;
	uint32				m_screenHeight;

	TCHAR               localPath[_MAX_PATH];
	TCHAR				tempStr[_MAX_PATH];
	TCHAR				gameDllName[_MAX_PATH];
	HINSTANCE			gameDll;
	TCHAR				gameID[zGameIDLen + 1];
	ZGameDllInitFunc	pZGameDllInitFunc;
	ZGameDllDeleteFunc	pZGameDllDeleteFunc;

	/* -------- Predefined Font Objects -------- */
	ZFont				m_gFontSystem12Normal;
	ZFont				m_gFontApp9Normal;
	ZFont				m_gFontApp9Bold;
	ZFont				m_gFontApp12Normal;
	ZFont				m_gFontApp12Bold;

	/* ZCommLib.c Globals */
	ZLList				m_gExitFuncList;
	ZLList				m_gPeriodicFuncList;
	ZTimer				m_gPeriodicTimer;

	/* ZTimer.cpp Globals */
	HWND				m_g_hWndTimer;
	ZLList				m_g_TimerList;
	uint32				m_s_nTickCount; // the last tick count in 100/sec

	/* ZMessage.c Globals */
	ZBool				m_gMessageInited;
	ZLList				m_gMessageList;

	/* ZCards.c Globals */
	ZOffscreenPort		m_gCardsImage;
	ZMask				m_gCardMask;
	ZOffscreenPort		m_gSmallCards[zNumSmallCardTypes];
	ZMask				m_gSmallCardMasks[zNumSmallCardTypes];

	/* ZWindow.cpp Globals */
	void*				m_gModalWindow;
	HWND				m_gModalParentWnd;
	HWND				m_gHWNDMainWindow;
	HWND				m_OCXHandle;
	void*				m_gWindowList; // Keep track of all windows created..
	HFONT				m_chatFont;

	/* ZNetwork.c Globals */
	ZLList				m_gSocketList; // used to keep track of socket to Client object mapping
	ZLList				m_gNameLookupList; // used to keep track of async name lookups
	HWND				m_g_hWndNotify;
	ZBool				m_gNetworkEnableMessages;

	/* ZSystem.cpp Globals */
	//HPALETTE			m_gPal;
	HINSTANCE			m_g_hInstanceLocal;
	ZTimer				m_gIdleTimer;
	POINT				m_gptCursorLast;
	UINT				m_gnMsgLast;
	BOOL				m_gClientDisabled;

	/* ZCliRoom.c Globals */
	ZSConnection		m_gConnection;
	ZWindow				m_gRoomWindow;
	ZScrollBar			m_gTableScrollBar;
	uint32				m_gUserID;
	uint32				m_gGroupID;
	TCHAR				m_gUserName[zUserNameLen + 1];
	uint32				m_gGameOptions;
	uint16				m_gNumTables;
	TableInfo*			m_gTables;
	uint16				m_gNumPlayers;
	int16				m_gFirstTableIndex;
	uint16				m_gNumTablesDisplayed;
	ZScrollBar			m_gNamesScrollBar;
	uint16				m_gFirstNameIndex;
	ZBool				m_gRoomInited;
	ZOffscreenPort		m_gTableOffscreen;
	int16				m_gJoinKibitzTable;
	int16				m_gJoinKibitzSeat;
	ZImage				m_gTableImage;
	ZImage				m_gGameIdleImage;
	ZImage				m_gGamingImage;
	ZImage				m_gStartButtonUpImage;
	ZImage				m_gStartButtonDownImage;
	ZImage				m_gPendingImage;
	ZImage				m_gVoteImage[zMaxNumPlayersPerTable];
	ZImage				m_gEmptySeatImage[zMaxNumPlayersPerTable];
	ZImage				m_gComputerPlayerImage[zMaxNumPlayersPerTable];
	ZImage				m_gHumanPlayerImage[zMaxNumPlayersPerTable];
	ZRect				m_gTableRect;
	ZRect				m_gTableNumRect;
	ZRect				m_gStartRect;
	ZRect				m_gGameMarkerRect;
	ZRect				m_gEmptySeatRect[zMaxNumPlayersPerTable];
	ZRect				m_gComputerPlayerRect[zMaxNumPlayersPerTable];
	ZRect				m_gHumanPlayerRect[zMaxNumPlayersPerTable];
	ZRect				m_gVoteRects[zMaxNumPlayersPerTable];
	ZRect				m_gNameRects[zMaxNumPlayersPerTable];
	ZRect				m_gRects[zRoomNumRects];
	TCHAR				m_gGameName[zGameRoomNameLen + 1];
	int16				m_gNumPlayersPerTable;
	ZInfo				m_gConnectionInfo;
	int16				m_gTableWidth;
	int16				m_gTableHeight;
	int16				m_gNumTablesAcross;
	int16				m_gNumTablesDown;
	ZColor				m_gBackgroundColor;
	int16				m_gRoomInfoStrIndex;
	ZTimer				m_gTimer;
	int16				m_gInfoBarButtonMargin;
	ZHelpWindow			m_gRoomHelpWindow;
	ZHelpButton			m_gRoomHelpButton;
	ZBool				m_gLeaveRoomPrompted;
	ZTimer				m_gPingTimer;
	ZBool				m_gPingServer;
	uint32				m_gPingLastSentTime;
	uint32				m_gPingLastTripTime;
	uint32				m_gPingCurTripTime;
	uint32				m_gPingInterval;
	uint32				m_gPingMinInterval;
	int16				m_gPingBadCount;
	PlayerInfo			m_gShowPlayerInfo;
	ZWindow				m_gShowPlayerInfoWindow;
	int16				m_gShowPlayerInfoNumMenuItems;
	int16				m_gShowPlayerInfoMenuHeight;
	int16				m_gShowPlayerInfoMenuItem;
	ZImage				m_gLightImages[zNumLightImages];
    IFriends*           m_gFriendsFile;
	ZHashTable			m_gFriends;
	ZHashTable			m_gIgnoreList;
	ZClientRoomGetObjectFunc		m_gGetObjectFunc;
	ZClientRoomDeleteObjectsFunc	m_gDeleteObjectsFunc;
	ZClientRoomGetHelpTextFunc		m_gGetHelpTextFunc;
	ZClientRoomCustomItemFunc		m_gCustomItemFunc;
	ZImage				m_gRoom4Images[zRoom4NumImages];
	ZRect				m_gRoom4Rects[zRoom4NumRects];
	ZClientRoomGetObjectFunc		m_gRoom4GetObjectFunc;
	ZClientRoomDeleteObjectsFunc	m_gRoom4DeleteObjectsFunc;
	ZImage				m_gRoom2Images[zRoom2NumImages];
	ZRect				m_gRoom2Rects[zRoom2NumRects];
	ZClientRoomGetObjectFunc		m_gRoom2GetObjectFunc;
	ZClientRoomDeleteObjectsFunc	m_gRoom2DeleteObjectsFunc;

	int16							m_gChatOnly; // mdm 8.18.97

	/* ZWindow.cpp additions -- HI 10/17/97 */
	BOOL				m_bBackspaceWorks;

	/* ZCliRoom.c addition -- HI 11/08/97 */
	NameCellType		m_gNameCells[zNumNamesDown];

	/* ZCliRoom.c Tips -- jdb 2/13/99 */
    struct CDialogTip   *m_gpCurrentTip;
	uint32				m_gdwTipDisplayMask;
	struct CDialogTip	*m_gpTipFinding;
	struct CDialogTip	*m_gpTipStarting;
	struct CDialogTip	*m_gpTipWaiting;
    BOOL                 m_gExiting;
    uint16               m_gServerPort;

    /* Game Host Interface for Z6 framework */
    IGameShell          *m_gGameShell;
} ClientDllGlobalsType, *ClientDllGlobals;

#endif

/* Global function macros. */
extern ZClientMainFunc ZClientMain;
extern ZClientExitFunc ZClientExit;
extern ZClientMessageHandlerFunc ZClientMessageHandler;
extern ZClientNameFunc ZClientName;
extern ZClientInternalNameFunc ZClientInternalName;
extern ZClientVersionFunc ZClientVersion;
extern ZCGameNewFunc ZCGameNew;
extern ZCGameDeleteFunc ZCGameDelete;
extern ZCGameProcessMessageFunc ZCGameProcessMessage;
extern ZCGameAddKibitzerFunc ZCGameAddKibitzer;
extern ZCGameRemoveKibitzerFunc ZCGameRemoveKibitzer;


#ifdef __cplusplus
extern "C" {
#endif


/*
	Functions to retrieve TLS (Thread Local Storage) index for global pointer access.
*/
extern void* ZGetClientGlobalPointer(void);
extern void ZSetClientGlobalPointer(void* globalPointer);
extern void* ZGetGameGlobalPointer(void);
extern void ZSetGameGlobalPointer(void* globalPointer);


/* Exported Routine Prototypes */
ZError ZClientDllInitGlobals(HINSTANCE hModInst, GameInfo gameInfo);
void ZClientDllDeleteGlobals(void);


#ifdef __cplusplus
}
#endif

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zeeverm.h ===
// zeeverm.h
//
// The Version DLL


#ifndef _ZEEVERM_
#define _ZEEVERM_

#include <zgameinfo.h>

struct ZeeVerPack
{
    char szSetupToken[GAMEINFO_SETUP_TOKEN_LEN + 1];
    char szVersionStr[24];
    char szVersionName[32];
    DWORD dwVersion;
};


STDAPI GetVersionPack(char *szSetupToken, ZeeVerPack *pVersion);
STDAPI StartUpdate(char *szSetupToken, DWORD dwTargetVersion, char *szLocation);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zcliroom.h ===
/*******************************************************************************

	ZCliRoom.h
	
		Zone(tm) client room header file.
	
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on Monday, November 11, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	4		02/03/97	HI		Changed zNumNamesDown to 18.
	3		01/29/97	HI		Modified room data constants.
	2		12/27/96	HI		Modified for layout rearragement.
	1		11/13/96	HI		Added ZCRoomPromptExit() prototype.
	0		11/11/96	HI		Created.
	 
*******************************************************************************/


#ifndef _ZCLIROOM_
#define _ZCLIROOM_

#ifdef __cplusplus
extern "C" {
#endif


#ifndef _ZROOM_
#include "zroom.h"
#endif

#include "GameShell.h"

typedef void * ZSGame;

#define zGameRoomNameLen			127

#define zNumNamesDown				18


/* -------- Light Images -------- */
enum
{
	zLightFast = 0,
	zLightSlow,
	zLightBad,
	zNumLightImages
};


enum
{
	zRoomRectWindow = 0,
	zRoomRectInfo,
	zRoomRectTables,
	zRoomRectNames,
	zRoomNumRects
};


/* -------- BlockedMessage -------- */
typedef struct
{
	uint32			msgType;
	int32			msgLen;
	ZBool			fProcessed;
	void*			msg;
} BlockedMessageType, *BlockedMessage;

/* Table Info */
typedef struct
{
	ZSGame			gameID;
	ZCGame			game;
	ZUserID			players[zMaxNumPlayersPerTable];
	ZBool			votes[zMaxNumPlayersPerTable];
	uint32			tableOptions;
	int16			tableState;
	int16			seatReq;					/* Seat number requested. */
	ZPictButton		startButton;
	int16			kibitzing;					/* Kibitzing seat number. */
	ZBool			blockingMessages;
	ZLList			blockedMessages;
	int16			blockMethod;
	int32			blockException;
	ZLList			kibitzers[zMaxNumPlayersPerTable];
} TableInfo;

/* Player Info */
typedef struct
{
	ZUserID			userID;
	TCHAR			userName[zUserNameLen + 1];
    uint32          hostAddr;
	ZBool			isFriend;
	ZBool			isIgnored;
	int16			rating;						/* User's rating, <0 is unknown */
	int16			gamesPlayed;				/* number of games user has played, <0 is unknown */
	int16			gamesAbandoned;				/* number of games user has abandoned, <0 is unknown */
	int16			tablesOnSize;
	int16*			tablesOn;					/* TableID + 1; terminated by 0. */
	int16			kibitzingOnSize;
	int16*			kibitzingOn;				/* TableID + 1; terminated by 0. */
} PlayerInfoType, *PlayerInfo;

enum
{
	eListFriends = 0,
	eListSysops,
	eListUsers,
	kNumListTypes,
};

typedef struct
{
	TCHAR			text[zUserNameLen + 1];
	int16			count;
	int16			type;
	PlayerInfo		playerInfo;
} NameCellType, *NameCell;



/*******************************************************************************
	4 PLAYER ROOM DEFINITIONS
*******************************************************************************/

#define zRoom4FileName					_T("zroom4.dll")
#define zRoom4NumPlayersPerTable		4
#define zRoom4TableAreaWidth			162
#define zRoom4TableAreaHeight			144
#define zRoom4NumTablesAcross			3
#define zRoom4NumTablesDown				2

enum
{
	/* Images */
	zRoom4NumImages = 18,
	zRoom4ImageTable = 0,
	zRoom4ImageEmpty0,
	zRoom4ImageEmpty1,
	zRoom4ImageEmpty2,
	zRoom4ImageEmpty3,
	zRoom4ImageComputer0,
	zRoom4ImageComputer1,
	zRoom4ImageComputer2,
	zRoom4ImageComputer3,
	zRoom4ImageHuman0,
	zRoom4ImageHuman1,
	zRoom4ImageHuman2,
	zRoom4ImageHuman3,
	zRoom4ImageStartUp,
	zRoom4ImageStartDown,
	zRoom4ImagePending,
	zRoom4ImageVoteLeft,
	zRoom4ImageVoteRight,
	
	/* Rectangles */
	zRoom4RectResID = 18,
	zRoom4NumRects = 25,
	zRoom4RectTableArea = 0,
	zRoom4RectTable,
	zRoom4RectGameMarker,
	zRoom4RectEmpty0,
	zRoom4RectEmpty1,
	zRoom4RectEmpty2,
	zRoom4RectEmpty3,
	zRoom4RectComputer0,
	zRoom4RectComputer1,
	zRoom4RectComputer2,
	zRoom4RectComputer3,
	zRoom4RectHuman0,
	zRoom4RectHuman1,
	zRoom4RectHuman2,
	zRoom4RectHuman3,
	zRoom4RectName0,
	zRoom4RectName1,
	zRoom4RectName2,
	zRoom4RectName3,
	zRoom4RectTableID,
	zRoom4RectStart,
	zRoom4RectVote0,
	zRoom4RectVote1,
	zRoom4RectVote2,
	zRoom4RectVote3
};



/*******************************************************************************
	2 PLAYER ROOM ROUTINES
*******************************************************************************/

#define zRoom2FileName					_T("zroom2.dll")
#define zRoom2NumPlayersPerTable		2
#define zRoom2TableAreaWidth			162
#define zRoom2TableAreaHeight			144
#define zRoom2NumTablesAcross			3
#define zRoom2NumTablesDown				2

enum
{
	/* Images */
	zRoom2NumImages = 12,
	zRoom2ImageTable = 0,
	zRoom2ImageEmpty0,
	zRoom2ImageEmpty1,
	zRoom2ImageComputer0,
	zRoom2ImageComputer1,
	zRoom2ImageHuman0,
	zRoom2ImageHuman1,
	zRoom2ImagePending,
	zRoom2ImageStartUp,
	zRoom2ImageStartDown,
	zRoom2ImageVoteLeft,
	zRoom2ImageVoteRight,
	
	/* Rectangles */
	zRoom2RectResID = 12,
	zRoom2NumRects = 15,
	zRoom2RectTableArea = 0,
	zRoom2RectTable,
	zRoom2RectGameMarker,
	zRoom2RectEmpty0,
	zRoom2RectEmpty1,
	zRoom2RectComputer0,
	zRoom2RectComputer1,
	zRoom2RectHuman0,
	zRoom2RectHuman1,
	zRoom2RectName0,
	zRoom2RectName1,
	zRoom2RectStart,
	zRoom2RectVote0,
	zRoom2RectVote1,
	zRoom2RectTableID
};


/* -------- Exported Routines -------- */
ZBool ZCRoomPromptExit(void);



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zoneping.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZonePing.h
 *
 * Contents:	Peer-to-peer latency measurments
 *
 *****************************************************************************/

#ifndef _ZPING_H
#define _ZPING_H
     
#include "ServiceId.h"

///////////////////////////////////////////////////////////////////////////////
// ZonePing object
///////////////////////////////////////////////////////////////////////////////

// {76E0E4C2-3675-11d3-AE4E-0000F803F3DE}
DEFINE_GUID(CLSID_ZonePing, 
0x76e0e4c2, 0x3675, 0x11d3, 0xae, 0x4e, 0x0, 0x0, 0xf8, 0x3, 0xf3, 0xde);

class __declspec(uuid("{76E0E4C2-3675-11d3-AE4E-0000F803F3DE}")) CZonePing;


///////////////////////////////////////////////////////////////////////////////
// IZonePing
///////////////////////////////////////////////////////////////////////////////

// {76E0E4C1-3675-11d3-AE4E-0000F803F3DE}
DEFINE_GUID(IID_IZonePing, 
0x76e0e4c1, 0x3675, 0x11d3, 0xae, 0x4e, 0x0, 0x0, 0xf8, 0x3, 0xf3, 0xde);

interface __declspec(uuid("{76E0E4C1-3675-11d3-AE4E-0000F803F3DE}"))
IZonePing : public IUnknown
{
    STDMETHOD(StartupServer)() = 0;
    STDMETHOD(StartupClient)( DWORD ping_interval_sec ) = 0;
    STDMETHOD(Shutdown)() = 0;
    STDMETHOD(Add)( DWORD inet ) = 0;
    STDMETHOD(Ping)( DWORD inet ) = 0;
    STDMETHOD(Remove)( DWORD inet ) = 0;
    STDMETHOD(RemoveAll)() = 0;
    STDMETHOD(Lookup)( DWORD inet, DWORD *pLatency ) = 0;
};

#ifdef __cplusplus
extern "C" {
#endif
HRESULT ZONECALL ZonePingCreate( IZonePing **ppPing );
#ifdef __cplusplus
}
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zgdi.h ===
#pragma once

#include <atlgdi.h>
#include <DataStore.h>

#ifndef _INC_VFW
//!! hmm. #pragma message ("NOTE: You can speed compilation by including <vfw.h> in stdafx.h")
#include <vfw.h>
#endif

#pragma comment(lib, "vfw32.lib")

/////////////////////////////////////////////////////////////////////////////
// CDrawDC - usefull when you are given a DC (such as ATLs Draw()) and 
//           therefore don't want to call DeleteObject()
class CDrawDC : public CDC
{
public:

	CDrawDC(HDC hDC = NULL, BOOL bAutoRestore = TRUE) : CDC(hDC, bAutoRestore)
	{
	}
	~CDrawDC()
	{
		if ( m_hDC != NULL )
		{
			if(m_bAutoRestore)
				RestoreAllObjects();

			Detach();
		}
	}
};


class CZoneFont : public CFont
{
public:
	HFONT CreateFont(ZONEFONT& zf,BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE)
	{
		return CreateFont( zf.lfHeight, zf.lfFaceName, zf.lfWeight, bItalic, bUnderline, bStrikeOut );
	}

	HFONT CreateFont(LONG nPointSize, LPCTSTR lpszFaceName, LONG nWeight, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE)
	{
//!! hmm. Should I ask for the DC too?
		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;

		// If font size > 0, it is a fixed pixel size, otherwise it is a
		// true logical font size which respects the user's "large font" setting.

		if ( nPointSize > 0 )
			logFont.lfHeight = -MulDiv(nPointSize, 96, 72);
		else
		{
			CWindowDC dc(NULL);
			logFont.lfHeight = MulDiv(nPointSize, dc.GetDeviceCaps(LOGPIXELSY), 72);
		}
		logFont.lfWeight = nWeight;
		logFont.lfItalic = bItalic;
		logFont.lfUnderline = bUnderline;
		logFont.lfStrikeOut = bStrikeOut;
		lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
		return CreateFontIndirect(&logFont);
	}

	// Font degredation
	HFONT SelectFont(ZONEFONT& zfPreferred, ZONEFONT&zfBackup, CDC& dc, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE)
	{
		// select the Preferred font if it is available, otherwise blindly
		// select the Backup font
		CreateFont(zfPreferred, bItalic, bUnderline, bStrikeOut);
		HFONT hOldFont = dc.SelectFont(m_hFont);

	    TCHAR lfFaceName[LF_FACESIZE];
		dc.GetTextFace(lfFaceName, LF_FACESIZE);

		//Return the original font to the DC
		dc.SelectFont( hOldFont );
		
		if ( !lstrcmpi(lfFaceName, zfPreferred.lfFaceName) )
		{				
			return m_hFont;
		}

		DeleteObject();

		CreateFont(zfBackup, bItalic, bUnderline, bStrikeOut);				
#if _DEBUG		
		hOldFont = dc.SelectFont(m_hFont);
		dc.GetTextFace(lfFaceName, LF_FACESIZE);
		ASSERT(!lstrcmpi(lfFaceName, zfBackup.lfFaceName));
		dc.SelectFont( hOldFont );
#endif

		return m_hFont;
	}

	int GetHeight();
};


// global functions for ordinary CBitmap too
//
extern CSize GetBitmapSize(CBitmap& Bitmap);
extern bool  DrawBitmap(CDC& dc, CBitmap& Bitmap,
	const CRect* rcDst=NULL, const CRect* rcSrc=NULL);
extern HRESULT DrawDynTextToBitmap(HBITMAP hbm, IDataStore *pIDS, CONST TCHAR *szKey);
extern void GetScreenRectWithMonitorFromWindow( HWND hWnd, CRect* prcOut );
extern void GetScreenRectWithMonitorFromRect( CRect* prcIn, CRect* prcOut );

////////////////
// CDib implements Device Independent Bitmaps as a form of CBitmap. 
//
class CDib : public CBitmap {
protected:
	BITMAP	m_bm;		// stored for speed
	DIBSECTION m_ds;	// cached

	CPalette m_pal;		// palette
	HDRAWDIB m_hdd;		// for DrawDib

public:
	CDib();
	~CDib();

	long	Width() { return m_bm.bmWidth; }
	long	Height() { return m_bm.bmHeight; }
	CSize	GetSize() { return CSize(m_bm.bmWidth, m_bm.bmHeight); }
	CRect	GetRect() { return CRect(CPoint(0,0), GetSize()); }
	bool Attach(HBITMAP hbm);
	bool LoadBitmap(LPCTSTR lpResourceName, IResourceManager *pResMgr = NULL);
	bool LoadBitmap(UINT uID, IResourceManager *pResMgr = NULL)
		{ return LoadBitmap(MAKEINTRESOURCE(uID), pResMgr); }
    bool LoadBitmapWithText(LPCTSTR lpResourceName, IResourceManager *pResMgr, IDataStore *pIDS, CONST TCHAR *szKey = NULL);
    bool LoadBitmapWithText(UINT uID, IResourceManager *pResMgr, IDataStore *pIDS, CONST TCHAR *szKey = NULL)
        { return LoadBitmapWithText(MAKEINTRESOURCE(uID), pResMgr, pIDS, szKey); }

	// Universal Draw function can use DrawDib or not.
	bool Draw(CDC& dc, const CRect* rcDst=NULL, const CRect* rcSrc=NULL,
		bool bUseDrawDib=TRUE, HPALETTE hPal=NULL, bool bForeground=FALSE);

	void DeleteObject();
	bool CreatePalette(CPalette& pal);
	HPALETTE GetPalette()  { return m_pal; }

	UINT GetColorTable(RGBQUAD* colorTab, UINT nColors);

	bool CreateCompatibleDIB( CDC& dc, const CSize& size)
	{
		return CreateCompatibleDIB(dc, size.cx, size.cy);
	}
	bool CreateCompatibleDIB( CDC& dc, long width, long height)
	{
		struct
		{
			BITMAPINFOHEADER	bmiHeader; 
			WORD				bmiColors[256];	// need some space for a color table
			WORD				unused[256];	// extra space, just in case
		} bmi;

		int	nSizePalette = 0;		// Assume no palette initially

		if (dc.GetDeviceCaps(RASTERCAPS) & RC_PALETTE)
		{
			_ASSERTE(dc.GetDeviceCaps(SIZEPALETTE) == 256);
			nSizePalette = 256;
		}

		memset(&bmi.bmiHeader, 0, sizeof(BITMAPINFOHEADER));
		bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
		bmi.bmiHeader.biWidth = width;
		bmi.bmiHeader.biHeight = height;
//!!		bmi.bmiHeader.biPlanes      = dc.GetDeviceCaps(PLANES);
//		bmi.bmiHeader.biBitCount    = dc.GetDeviceCaps(BITSPIXEL);
		bmi.bmiHeader.biPlanes      = 1;
		bmi.bmiHeader.biBitCount    = dc.GetDeviceCaps(BITSPIXEL) * dc.GetDeviceCaps(PLANES);
		bmi.bmiHeader.biCompression = BI_RGB;
		//bmi.bmiHeader.biSizeImage		= 0;  header already zero'd
		//bmi.bmiHeader.biXPelsPerMeter	= 0;
		//bmi.bmiHeader.biYPelsPerMeter	= 0;
		//bmi.bmiHeader.biClrUsed		= 0;  // implies full palette specified, if palette required
		//bmi.bmiHeader.biClrImportant	= 0;

		// fill out the color table. Not used if a true color device
		void* pBits;
        if(bmi.bmiHeader.biBitCount == 8)
        {
		    WORD* pIndexes = bmi.bmiColors;
		    for (int i = 0; i < 256; i++)
			    *pIndexes++ = i;

		    Attach(CreateDIBSection(dc, (BITMAPINFO*)&bmi, DIB_PAL_COLORS, &pBits, NULL, 0));
        }
        else
		    Attach(CreateDIBSection(dc, (BITMAPINFO*)&bmi, DIB_RGB_COLORS, &pBits, NULL, 0));

		_ASSERTE(m_hBitmap != NULL);

		return ( m_hBitmap != NULL );


#if 0
		// Create device context
		m_hDC = CreateCompatibleDC( NULL );
		if ( !m_hDC )
			return E_FAIL;
		m_hOldPalette = SelectPalette( m_hDC, palette, FALSE );

		// fill in bitmapinfoheader
		bmi.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
		bmi.bmiHeader.biWidth			= width;
		bmi.bmiHeader.biHeight			= height;
		bmi.bmiHeader.biPlanes			= 1;
		bmi.bmiHeader.biBitCount		= 8;
		bmi.bmiHeader.biCompression		= 0;
		bmi.bmiHeader.biSizeImage		= WidthBytes( width * 8 ) * height;
		bmi.bmiHeader.biClrUsed			= 0;
		bmi.bmiHeader.biClrImportant	= 0;
		bmi.bmiHeader.biXPelsPerMeter	= 0;
		bmi.bmiHeader.biYPelsPerMeter	= 0;

		// fill in palette
		pIdx = (WORD*) bmi.bmiColors;
		for ( int i = 0; i < 256; i++ )
		{
			*pIdx++ = (WORD) i;
		}
		
		// create section
		m_hBmp = CreateDIBSection( m_hDC, (BITMAPINFO*) &bmi, DIB_PAL_COLORS, (void**) &m_pBits, NULL, 0 );
		if ( !m_hBmp )
		{
			DeleteBitmap();
			return E_FAIL;
		}
		if ( !GetObject( m_hBmp, sizeof(DIBSECTION), &m_DS ) )
		{
			DeleteBitmap();
			return E_FAIL;
		}
		m_lPitch = WidthBytes( m_DS.dsBmih.biBitCount * m_DS.dsBmih.biWidth );
		m_hOldBmp = SelectObject( m_hDC, m_hBmp );
			
	    return NOERROR;
#endif
	}

};

#if 0

//!! missing transparency functionality.
//   if we decide we need it, I plan on having a CImage class where an 
//   image is a CDib plus transparency. 


// functions for offscreen blting?
//   creating a compatible DC, appropriate Dib, etc.





HRESULT CDibSection::SetColorTable( CPalette& palette )
{
	PALETTEENTRY* palColors;
	RGBQUAD dibColors[256], *pDibColors;
	int i;
	
	// Convert palette entries to dib color table
	palColors = palette.GetLogPalette()->palPalEntry;
	pDibColors = dibColors;
	for ( i = 0; i < 256; i++ )
	{
		pDibColors->rgbRed		= palColors->peRed;
		pDibColors->rgbGreen	= palColors->peGreen;
		pDibColors->rgbBlue		= palColors->peBlue;
		pDibColors->rgbReserved = 0;
		pDibColors++;
		palColors++;
	}

	// Attach color table to dib section
	if (  m_hOldPalette )
		SelectPalette( m_hDC, m_hOldPalette, FALSE );
	m_hOldPalette = SelectPalette( m_hDC, palette, FALSE );
	if (SetDIBColorTable( m_hDC, 0, 256, dibColors ) != 256)
		return E_FAIL;

	return NOERROR;
}




//!! hmm.  Do we want remapping functionality?
HRESULT CDib::RemapToPalette( CPalette& palette, BOOL bUseIndex )
{
	BYTE map[256];
	PALETTEENTRY* pe;
	BYTE* bits;
	RGBQUAD* dibColors;
	DWORD i;

	// Create dib to palette translation table
	dibColors = m_pBMI->bmiColors;
	for ( i = 0; i < 256; i++ )
	{
		map[i] = GetNearestPaletteIndex( palette, RGB( dibColors->rgbRed, dibColors->rgbGreen, dibColors->rgbBlue ) );
		dibColors++;
	}
	if ( m_iTransIdx >= 0 )
	{
		map[ m_iTransIdx ] = palette.GetTransparencyIndex();
		m_iTransIdx = palette.GetTransparencyIndex();
	}

	// run bits through translation table
	bits = m_pBits;
	for ( i = 0; i < m_pBMI->bmiHeader.biSizeImage; i++ )
		*bits++ = map[ *bits ];

	// reset dib's color table to palette
	if ( bUseIndex )
	{
		m_iColorTableUsage = DIB_PAL_COLORS;
		dibColors = m_pBMI->bmiColors;
		for ( i = 0; i < 256; i++ )
		{
			*((WORD*) dibColors) = (WORD) i;
			dibColors++;
		}
	}
	else
	{
		m_iColorTableUsage = DIB_RGB_COLORS;
		pe = palette.GetLogPalette()->palPalEntry;
		dibColors = m_pBMI->bmiColors;
		for ( i = 0; i < 256; i++ )
		{
			dibColors->rgbRed = pe->peRed;
			dibColors->rgbGreen = pe->peGreen;
			dibColors->rgbBlue = pe->peBlue;
			dibColors->rgbReserved = 0;
			dibColors++;
			pe++;
		}
	}

	// we're done
	return NOERROR;
}

#endif

/////////////////////////////////////////////////////////////////////////////
// COffscreenBitmapDC - an offscreen bitmap compatible
//           therefore don't want to call DeleteObject()
class CMemDC : public CDC
{
	CDib m_dib;

public:

	~CMemDC()
	{
		if(m_bAutoRestore)
			RestoreAllObjects();
	}

	HDC CreateOffscreenBitmap(const CSize& size, HPALETTE hPalette = NULL, HDC hDC = NULL)
	{
		return CreateOffscreenBitmap( size.cx, size.cy, hPalette, hDC);
	}

	HDC CreateOffscreenBitmap(long width, long height, HPALETTE hPalette = NULL, HDC hDC = NULL)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateCompatibleDC(hDC);
		
		if ( hPalette )
		{
			SelectPalette( hPalette, TRUE);
			RealizePalette();
		}

		m_dib.CreateCompatibleDIB(*this, width, height);

		SelectBitmap(m_dib);

		return m_hDC;
	}


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zoneevent.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneEvent.h
 *
 * Contents:	Event definitions
 *
 *****************************************************************************/

#ifndef _ZONEEVENT_H_
#define	_ZONEEVENT_H_

#include <ZoneDef.h>


//
// Events consists of a class and id
// 
//  3         1 1
//  1         6 5          0
// +-----------+------------+
// | class     | id         |
// +-----------+------------+
//

//
// Returns the class id
//
#define	EVENT_CLASS(e)	((e) >> 16)

//
// Returns the sub id
//
#define EVENT_ID(e)		((e) & 0xffff)

//
// Create an Event from component pieces
//
#define MAKE_EVENT(c,id)	((DWORD) (((DWORD)(c << 16)) | (((DWORD)(id)) & 0xffff)))


//
// Macros to define events
// 
struct EventEntry
{
	DWORD	id;
	char*	name;
};

#ifndef __INIT_EVENTS
	#define BEGIN_ZONE_EVENTS(n)	extern EventEntry n[]; enum {
	#define ZONE_CLASS(c)			RESERVED_##c = MAKE_EVENT(c,0),
	#define ZONE_EVENT(c,n,v)		n = MAKE_EVENT(c,v),
	#define END_ZONE_EVENTS()		};
#else
	#define BEGIN_ZONE_EVENTS(n)	EventEntry n[] = {
	#define ZONE_CLASS(c)			{ MAKE_EVENT(c,0), "RESERVED_"#c },
	#define ZONE_EVENT(c,n,v)		{ MAKE_EVENT(c,v), #n },
	#define END_ZONE_EVENTS()		{ 0, NULL} };
#endif


//
// Priority levels
//
#define PRIORITY_HIGH			1
#define PRIORITY_NORMAL			2
#define PRIORITY_LOW			3


//
// Event classes
//
#define EVENT_CLASS_ALL			0
#define EVENT_CLASS_NETWORK		1
#define EVENT_CLASS_UI          2
#define EVENT_CLASS_LOBBY		3
#define EVENT_CLASS_LAUNCHER	4
#define EVENT_CLASS_LAUNCHPAD	5
#define EVENT_CLASS_CHAT		6
#define EVENT_CLASS_SYSOP		7
#define EVENT_CLASS_EXTERNAL	8
#define EVENT_CLASS_INTERNAL	9

#define EVENT_CLASS_GRAPHICALACC  50
#define EVENT_CLASS_ACCESSIBILITY 51
#define EVENT_CLASS_INPUT         52

#define EVENT_CLASS_GAME       10
#define EVENT_CLASS_ZONE       11

#define EVENT_CLASS_TEST      101


//
// Event definitions
//
BEGIN_ZONE_EVENTS( ZoneEvents )

	///////////////////////////////////////////////////////////////////////////
	// physical network events
	ZONE_CLASS( EVENT_CLASS_NETWORK )
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_CONNECT,			1 )
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_DISCONNECT,		2 )
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_RECEIVE,			3 )		// pData = EventNetwork struct
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_DO_CONNECT,		4 )
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_DO_DISCONNECT,	5 )
	ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_SEND,			6 )		// pData = EventNetwork struct
    ZONE_EVENT( EVENT_CLASS_NETWORK, EVENT_NETWORK_RESET,           7 )

	///////////////////////////////////////////////////////////////////////////
	// logical network events
	ZONE_CLASS( EVENT_CLASS_ZONE )
	ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_CONNECT,			1 )
	ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_CONNECT_FAIL,		2 )
	ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_DISCONNECT,		3 )
	ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_DO_CONNECT,		4 )
//	ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_DO_DISCONNECT, 	5 )  // not implemented
    ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_VERSION_FAIL,      6 )
    ZONE_EVENT( EVENT_CLASS_ZONE, EVENT_ZONE_UNAVAILABLE,       7 )

	///////////////////////////////////////////////////////////////////////////
	// ui events
	ZONE_CLASS( EVENT_CLASS_UI )
	ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_WINDOW_CLOSE,			1  )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_MENU_EXIT,             11 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_MENU_NEWOPP,           12 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_MENU_SHOWSCORE,        13 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_PROMPT_EXIT,           21 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_PROMPT_NEWOPP,         22 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_PROMPT_NETWORK,        31 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_UPSELL_BLOCK,          41 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_UPSELL_UNBLOCK,        42 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_UPSELL_UP,             43 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_UPSELL_DOWN,           44 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_FRAME_ACTIVATE,        50 )
    ZONE_EVENT( EVENT_CLASS_UI, EVENT_UI_SHOWFOCUS,             51 )

	///////////////////////////////////////////////////////////////////////////
	// lobby events
	ZONE_CLASS( EVENT_CLASS_LOBBY )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_BOOTSTRAP,				1 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_INITIALIZE,				2 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_PREFERENCES_LOADED,		3 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_INITIALIZED,				4 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_CLEAR_ALL,				5 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_BATCH_BEGIN,				6 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_BATCH_END,				7 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_QUICK_HOST,				8 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_QUICK_JOIN,				9 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_NEW,				10 )	// pData = user's name
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_DEL,				11 )	// pData = user's name
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_DEL_COMPLETE,       12 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_UPDATE,				13 )	// dwData1 = TRUE if user status changed
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_UPDATE_REQUEST,		14 )	// pData = DataStore with new settings
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_NEW,				20 )	// pData = user's name
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_DEL,				21 )	// pData = user's name
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_UPDATE,			22 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_UPDATE_REQUEST,	23 )	// pData = DataStore with new settings
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_ADD_USER,			24 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_DEL_USER,			25 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_DEL_USER_REQUEST,	26 )	// dwData1 = Id of user to boot
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_HOST_REQUEST,		27 )	// dwData1 = app idx if generic dplay
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_JOIN_REQUEST,		28 )	// pData = Password if group protected
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GROUP_JOIN_FAIL,			29 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_SUSPEND,					40 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_RESUME,					41 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_UNIGNORE_ALL,			42 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_USER_SET_IGNORE,			43 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_COMFORT_USER,			44 )
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_ABOUT,                   45 )
	ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_SERVER_STATUS,			47 )
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_CHAT_SWITCH,             48 )
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_MATCHMAKE,               49 )
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_DISCONNECT,              50 )
    ZONE_EVENT( EVENT_CLASS_LOBBY, EVENT_LOBBY_GOING_DOWN,              51 )

	///////////////////////////////////////////////////////////////////////////
	// game events
	ZONE_CLASS( EVENT_CLASS_GAME )
	ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_OVER,   	         		1 )
	ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_BEGUN,   	         		2 )
	ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_PLAYER_READY,         		3 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_LOCAL_READY,               4 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_LAUNCHING,                 5 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_CLIENT_ABORT,              6 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_TERMINATED,                7 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_PROMPT,                    8 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_SEND_MESSAGE,              9 )
    ZONE_EVENT( EVENT_CLASS_GAME, EVENT_GAME_FATAL_PROMPT,             10 )

	///////////////////////////////////////////////////////////////////////////
	// launcher events
	ZONE_CLASS( EVENT_CLASS_LAUNCHER )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_INSTALLED_REQUEST,		1 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_INSTALLED_RESPONSE,	2 )		// dwData1= EventLauncherCodes
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_LAUNCH_REQUEST,		3 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_LAUNCH_RESPONSE,		4 )		// dwData1= EventLauncherCodes
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_LAUNCH_STATUS,			5 )		// dwData1 = EventLauncherCodes
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_SET_PROPERTY_REQUEST,	6 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_SET_PROPERTY_RESPONSE,	7 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_GET_PROPERTY_REQUEST,	8 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHER, EVENT_LAUNCHER_GET_PROPERTY_RESPONSE,	9 )

	///////////////////////////////////////////////////////////////////////////
	// launchpad events
	ZONE_CLASS( EVENT_CLASS_LAUNCHPAD )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_CREATE,			1 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_DESTROY,			2 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_LAUNCH,			3 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_RESUME,			4 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_HOST_LAUNCHING,	5 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_GAME_STATUS,		6 )		// pData = ZLPMsgGameStatus structure
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_ABORT,			7 )
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_LAUNCH_STATUS,	8 )		// dwData1 = EventLauncherCodes
	ZONE_EVENT( EVENT_CLASS_LAUNCHPAD, EVENT_LAUNCHPAD_ZSETUP,	        9 )		// pData = ZPrmMsgSetupParam

	///////////////////////////////////////////////////////////////////////////
	// chat events
	ZONE_CLASS( EVENT_CLASS_CHAT )
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_RECV,			1 )	// pData = EventChat struct
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_RECV_USERID,	2 )	// pData = chat string
    ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_RECV_SYSTEM,   3 )
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_SEND,			4 )	// pData = chat string
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_INVITE,		5 )	// pData = invite list
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_ENTER_EXIT,	6 )	// toggle enter exit msgs
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_FILTER,		7 )	// toggle chat filter
	ZONE_EVENT( EVENT_CLASS_CHAT, EVENT_CHAT_FONT,			8 )	// set chat font

	///////////////////////////////////////////////////////////////////////////
	// sysop events
	ZONE_CLASS( EVENT_CLASS_SYSOP )
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_WARN_USER,			1 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_GET_IP_USER,			2 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_GAG_USER,			3 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_GAG_USER_ZONEWIDE,	4 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_UNGAG_USER,			5 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_BOOT_USER,			6 )	
	ZONE_EVENT( EVENT_CLASS_SYSOP, EVENT_SYSOP_BOOT_USER_ZONEWIDE,	7 )	

	///////////////////////////////////////////////////////////////////////////
	// external events - trigger external actions
	ZONE_CLASS( EVENT_CLASS_EXTERNAL )
	ZONE_EVENT( EVENT_CLASS_EXTERNAL, EVENT_SEND_ZONEMESSAGE,		1 )
	ZONE_EVENT( EVENT_CLASS_EXTERNAL, EVENT_VIEW_PROFILE,			2 )
    ZONE_EVENT( EVENT_CLASS_EXTERNAL, EVENT_LAUNCH_HELP,            3 )
    ZONE_EVENT( EVENT_CLASS_EXTERNAL, EVENT_LAUNCH_URL,             4 )
    ZONE_EVENT( EVENT_CLASS_EXTERNAL, EVENT_LAUNCH_ICW,             5 )

	///////////////////////////////////////////////////////////////////////////
	// internal events 
	ZONE_CLASS( EVENT_CLASS_INTERNAL )
	ZONE_EVENT( EVENT_CLASS_INTERNAL, EVENT_EXIT_APP,				1 )
	ZONE_EVENT( EVENT_CLASS_INTERNAL, EVENT_DESTROY_WINDOW,			2 )
    ZONE_EVENT( EVENT_CLASS_INTERNAL, EVENT_FINAL,                  3 )

	///////////////////////////////////////////////////////////////////////////
	// CGraphicalAccessibility private events
	ZONE_CLASS( EVENT_CLASS_GRAPHICALACC )
	ZONE_EVENT( EVENT_CLASS_GRAPHICALACC, EVENT_GRAPHICALACC_UPDATE, 1 )

	///////////////////////////////////////////////////////////////////////////
	// CAccessibilityManager private events
	ZONE_CLASS( EVENT_CLASS_ACCESSIBILITY )
	ZONE_EVENT( EVENT_CLASS_ACCESSIBILITY, EVENT_ACCESSIBILITY_UPDATE, 1 )
	ZONE_EVENT( EVENT_CLASS_ACCESSIBILITY, EVENT_ACCESSIBILITY_CTLTAB, 2 )

	///////////////////////////////////////////////////////////////////////////
	// CInputManager events
	ZONE_CLASS( EVENT_CLASS_INPUT )
	ZONE_EVENT( EVENT_CLASS_INPUT, EVENT_INPUT_KEYBOARD_ALERT,  1 )
    ZONE_EVENT( EVENT_CLASS_INPUT, EVENT_INPUT_MOUSE_ALERT,     2 )

	///////////////////////////////////////////////////////////////////////////
	// test events
	ZONE_CLASS( EVENT_CLASS_TEST )
	ZONE_EVENT( EVENT_CLASS_TEST, EVENT_TEST_STRESS_CHAT, 1 )

END_ZONE_EVENTS()


struct EventNetwork
{
	DWORD	dwType;
	DWORD	dwLength;
	BYTE	pData[1];	// variable size
};

enum EventNetworkCodes
{
	EventNetworkUnknown = 0,
	EventNetworkCloseNormal,
	EventNetworkCloseConnectFail,
	EventNetworkCloseCanceled,
	EventNetworkCloseFail
};


struct EventChat
{
	TCHAR	szUserName[ ZONE_MaxUserNameLen ];
	TCHAR	szChat[ ZONE_MaxChatLen ];
};


enum EventLauncherCodes
{
	EventLauncherUnknown = 0,
	EventLauncherOk,
	EventLauncherFail,				// generic failure
	EventLauncherNotFound,			// game not installed
	EventLauncherNoSupport,			// required lib not installed
	EventLauncherOldVersion,		// old version
	EventLauncherWrongOS,			// wrong OS
	EventLauncherAborted,			// launch aborted by user
	EventLauncherRunning,			// already running
	EventLauncherGameReady,			// game started successfully
	EventLauncherGameFailed,		// game failed to start
	EventLauncherGameTerminated,	// game terminated
};


//
// Helper functions
//
inline const char* GetZoneEventName(EventEntry* pEntry, DWORD id) 
{	
	while ( pEntry->name )
	{
		if ( pEntry->id == id )
			return pEntry->name;
		pEntry++;
	}
	return NULL;
}

inline DWORD GetZoneEventId(EventEntry* pEntry, const char* name) 
{	
	while ( pEntry->name )
	{
		if ( !strcmp(pEntry->name, name) )
			return pEntry->id;
		pEntry++;
	}
	return 0;
}

#endif //__ZONEEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zoneresource.h ===
// this file defines the resource "namespace"

// for now, we just include all the subcomponent resource files


#include "commonres.h"

// all of these should be included, but unfortunately they have many namespace conflicts.
//#include "spadesres.h"
//#include "backgammonres.h"
//#include "heartsres.h"
//#include "checkersres.h"
//#include "reversires.h"


// Stuff for AlertMessage - Default Button Resources
#define AlertButtonOK         (MAKEINTRESOURCE(IDS_BUTTON_OK))
#define AlertButtonCancel     (MAKEINTRESOURCE(IDS_BUTTON_CANCEL))
#define AlertButtonYes        (MAKEINTRESOURCE(IDS_BUTTON_YES))
#define AlertButtonNo         (MAKEINTRESOURCE(IDS_BUTTON_NO))
#define AlertButtonNewOpp     (MAKEINTRESOURCE(IDS_BUTTON_NEWOPP))
#define AlertButtonQuit       (MAKEINTRESOURCE(IDS_BUTTON_QUIT))
#define AlertButtonRetry      (MAKEINTRESOURCE(IDS_BUTTON_RETRY))
#define AlertButtonIgnore     (MAKEINTRESOURCE(IDS_BUTTON_IGNORE))
#define AlertButtonHelp       (MAKEINTRESOURCE(IDS_BUTTON_HELP))


// Default Error Texts
#define ErrorTextUnknown           (MAKEINTRESOURCE(IDS_ERROR_UNKNOWN))
#define ErrorTextOutOfMemory       (MAKEINTRESOURCE(IDS_ERROR_MEMORY))
#define ErrorTextResourceNotFound  (MAKEINTRESOURCE(IDS_ERROR_RESOURCE))
#define ErrorTextSync              (MAKEINTRESOURCE(IDS_ERROR_SYNC))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zoneshell.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneShell.h
 *
 * Contents:	Shell interfaces
 *
 *****************************************************************************/

#ifndef _ZONESHELL_H_
#define _ZONESHELL_H_

#include "ServiceId.h"
#include "ZoneShellEx.h"

///////////////////////////////////////////////////////////////////////////////
// ZoneShell object
///////////////////////////////////////////////////////////////////////////////

// {064FFB6B-C06E-11d2-8B1B-00C04F8EF2FF}
DEFINE_GUID(CLSID_ZoneShell, 
0x64ffb6b, 0xc06e, 0x11d2, 0x8b, 0x1b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{064FFB6B-C06E-11d2-8B1B-00C04F8EF2FF}")) CZoneShell ;


///////////////////////////////////////////////////////////////////////////////
// IZoneShell
//
// There are four methods here for registering interfaces where the Shell can
// only have one of each interface registered at a time.  The other option is
// to have the Shell configurable so that it can receive via the DataStore
// four optional SRVIDs which should be queried for the respective interface.
///////////////////////////////////////////////////////////////////////////////

// {96556B40-C03F-11d2-8B1B-00C04F8EF2FF}
DEFINE_GUID(IID_IZoneShell, 
0x96556b40, 0xc03f, 0x11d2, 0x8b, 0x1b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{96556B40-C03F-11d2-8B1B-00C04F8EF2FF}"))
IZoneShell : public IUnknown
{
	//
	// IZoneShell::Init
	//
	// Initialize ZoneShell object.
	//
	// Parameters:
	//	arBootDlls
	//		Array of bootstrap dll names
	//	nBootDlls
	//		Number of elements in arBootDlls
	//	arDlls
	//		Array of resource Dll hinstances
	//	nElts
	//		Number of elements in arDlls
	//
	STDMETHOD(Init)( TCHAR** arBootDlls, DWORD nBootDlls, HINSTANCE* arDlls, DWORD nElts ) = 0;

	//
	// IZoneShell::LoadPreferenes
	//
	// Ideally the preferences would be loaded during initialization,
	// but the lobby does not know the user name at that stage.
	//
	// Parameters:
	//	szInternalName
	//		Lobby internal name for loading / storing preferences
	//	szUserName
	//		User name for loading / storing preferences
	//
	STDMETHOD(LoadPreferences)( CONST TCHAR* szInternalName, CONST TCHAR* szUserName ) = 0;

	//
	// IZoneShell::Close
	//
	// Unload ZoneShell objects.
	//
	//
	STDMETHOD(Close)() = 0;

	//
	// IZoneShell::HandleWindowMessage
	//
	// Perform the main actions of a Windows message loop, from IsDialogMessage to DispatchMessage.
	//
	STDMETHOD(HandleWindowMessage)(MSG *pMsg) = 0;

	//
	// IZoneShell::SetZoneFrameWindow
	//
	// Set the Zone Frame Window IZoneFrameWindow for the shell.  If ppZFW is non-NULL, it receives the old
    // Zone Frame Window, or NULL.  pZFW can be NULL to remove the Zone Frame Window.
	//
	STDMETHOD(SetZoneFrameWindow)(IZoneFrameWindow *pZFW, IZoneFrameWindow **ppZFW = NULL) = 0;

	//
	// IZoneShell::SetInputTranslator
	//
	// Set the Input Translator IInputTranslator for the shell.  If ppIT is non-NULL, it receives the old
    // Input Translator, or NULL.  pIT can be NULL to remove the Input Translator.
	//
	STDMETHOD(SetInputTranslator)(IInputTranslator *pIT, IInputTranslator **ppIT = NULL) = 0;

	//
	// IZoneShell::SetAcceleratorTranslator
	//
	// Set the Accelerator Translator IAcceleratorTranslator for the shell.  If ppAT is non-NULL, it receives the old
    // Accelerator Translator, or NULL.  pAT can be NULL to remove the Accelerator Translator.
	//
	STDMETHOD(SetAcceleratorTranslator)(IAcceleratorTranslator *pAT, IAcceleratorTranslator **ppAT = NULL) = 0;

	//
	// IZoneShell::SetCommandHandler
	//
	// Set the Command Handler ICommandHandler for the shell.  If ppCH is non-NULL, it receives the old
    // Command Handler, or NULL.  pCH can be NULL to remove the Command Handler.
	//
	STDMETHOD(SetCommandHandler)(ICommandHandler *pCH, ICommandHandler **ppCH = NULL) = 0;

	//
	// IZoneShell::ReleaseReferences
	//
    // Force the Shell to release all references to this interface, that it has received through the
    // various registration functions.
	//
	STDMETHOD(ReleaseReferences)(IUnknown *pUnk) = 0;

	//
	// IZoneShell::CommandSink
	//
    // Sink for Application-Global WM_COMMAND messages.  Passed through to the Command Handler
    // if one has been set up.
    //
    // Example: Call this from the main frame window's WM_COMMAND handler, since that's where menu selection events end up.
	//
	STDMETHOD(CommandSink)(WPARAM wParam, LPARAM lParam, BOOL& bHandled) = 0;

	//
	// IZoneShell::Attach
	//
	// Attach application created objects to shell.
	//
	// Parameters:
	//	srvid
	//		Service guid of the object
	//	pIUnk
	//		Pointer to objects IUnknown
	//
	STDMETHOD(Attach)( const GUID& srvid, IUnknown* pIUnk ) = 0;

	//
	// IZoneShell::AddTopWindow
	//
	// Add window to top (overlapped) window list.
	// 
	// Parameters:
	//	hWnd
	//		top window's window handle 
	//
	STDMETHOD(AddTopWindow)( HWND hWnd ) = 0;

	//
	// IZoneShell::RemoveTopWindow
	//
	// Remove window from top (overlapped) window list.
	// 
	// Parameters:
	//	hWnd
	//		top window's window handle 
	//
	STDMETHOD(RemoveTopWindow)( HWND hWnd ) = 0;
	//
	// Enables/Disables any or all top windows. 
	// 
	STDMETHOD_(void,EnableTopWindow)( HWND hWnd, BOOL fEnable ) = 0;

    STDMETHOD_(HWND, FindTopWindow)(HWND hWnd) = 0;

    // owned windows, like modeless dialogs, that have captions but do not show up in the alt-tab list or taskbar
    STDMETHOD(AddOwnedWindow)(HWND hWndTop, HWND hWnd) = 0;
    STDMETHOD(RemoveOwnedWindow)(HWND hWndTop, HWND hWnd) = 0;
    STDMETHOD_(HWND, GetNextOwnedWindow)(HWND hWndTop, HWND hWnd) = 0;

	//
	// IZoneShell::GetFrameWindow
	//
	// Returns HWND of shell's window
	//
	STDMETHOD_(HWND,GetFrameWindow)() = 0;

	//
	// IZoneShell::SetPalette
	//
	// Set HPALETTE of shell's window
	//
	// Parameters:
	//	hPalette
	//		palette handle for top window
	//
	STDMETHOD_(void,SetPalette)( HPALETTE hPalette ) = 0;

	//
	// IZoneShell::GetPalette
	//
	// Returns HPALETTE of shell's window
	//
	STDMETHOD_(HPALETTE,GetPalette)() = 0;

	//
	// IZoneShell::CreateZonePalette
	//
	// Returns new HPALETTE created from IDR_ZONE_PALETTE as
	// loaded by the resource manager.
	//
	STDMETHOD_(HPALETTE,CreateZonePalette)() = 0;

	//
	// IZoneShell::GetApplicationLCID
	//
	// Returns the LCID of the binaries - localized
	// strings will be in this language.
	//
    STDMETHOD_(LCID, GetApplicationLCID)() = 0;

	//
	// IZoneShell::AddDialog
	//
	// Add dialog to IsDialogMessage list.
	// 
	// Parameters:
	//	hDlg
	//		dialog's window handle
    //  fOwned
    //      for convenience, also adds the window as an Owned window if it has an ancestor who is a Top window
	//
	STDMETHOD(AddDialog)(HWND hDlg, bool fOwned = false) = 0;

	//
	// IZoneShell::RemoveDialog
	//
	// Remove dialog from IsDialogMessage list.
	// 
	// Parameters:
	//	hDlg
	//		dialog's window handle 
    //  fOwned
    //      for convenience, also removes the window as an Owned window if it has an ancestor who is a Top window
	//
	STDMETHOD(RemoveDialog)(HWND hDlg, bool fOwned = false) = 0;

	//
	// IZoneShell::IsDialog
	//
	// Returns S_TRUE if hWnd is in the known dialog list, otherwise S_FALSE.
	// 
	// Parameters:
	//	hWnd
	//		window to lookup
	//
	STDMETHOD_(bool,IsDialogMessage)( MSG* pMsg ) = 0;

	//
	// IZoneShell::QueryService
	//
	// Returns pointer of the running instance of the requested service.
	//
	// Parameters:
	//	srvid
	//		serice id being requested
	//	uuid
	//		interface id being requested
	//	ppObject
	//		address of pointer to variable that receives requested interface.
	//
	STDMETHOD(QueryService)( const GUID& srvid, const GUID& iid, void** ppObject ) = 0;


	//
	// IZoneShell::CreateService
	//
	// Creates new instance of requested service.  The new object is not
	// automatically registered with ZoneShell, that is left up to the caller.
	//
	// Parameters:
	//	srvid
	//		serice id being requested
	//	uuid
	//		interface id being requested
	//	ppObject
	//		address of pointer to variable that receives requested interface.
	//	bInitialize
	//		flag indicating object should initialized via it's IZoneShellClient
	//	dwGroupId
	//		if bInitialize, group to initialize to
	//
	STDMETHOD(CreateService)( const GUID& srvid, const GUID& iid, void** ppObject, DWORD dwGroupId, bool bInitialize = true ) = 0;


	//
	//
	// IZoneShell::ExitApp
	//
	// Exit application
	//
	// Parameters:
	//	none
	//
	STDMETHOD(ExitApp)() = 0;

	//
	// IZoneShell dialog functions
	//

	STDMETHOD(AlertMessage)(
			HWND		hWndParent,
			LPCTSTR		lpszText,
			LPCTSTR		lpszCaption,
            LPCTSTR     szYes,
            LPCTSTR     szNo = NULL,
            LPCTSTR     szCancel = NULL,
            long        nDefault = 0,
			DWORD		dwEventId = 0,
			DWORD		dwGroupId = ZONE_NOGROUP,
			DWORD		dwUserId  = ZONE_NOUSER,
            DWORD       dwCookie = 0 ) = 0;

	STDMETHOD(AlertMessageDialog)(
			HWND		hWndParent,
			HWND		hDlg, 
			DWORD		dwEventId = 0,
			DWORD		dwGroupId = ZONE_NOGROUP,
			DWORD		dwUserId  = ZONE_NOUSER,
            DWORD       dwCookie = 0 ) = 0;

	STDMETHOD_(void,DismissAlertDlg)( HWND hWndParent, DWORD dwCtlID, bool bDestoryDlg ) = 0;
	STDMETHOD_(void,ActivateAlert)( HWND hWndParent) = 0;
    STDMETHOD_(void,ClearAlerts)(HWND hWndParent) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IZoneShellClient
///////////////////////////////////////////////////////////////////////////////

// {96556B3F-C03F-11d2-8B1B-00C04F8EF2FF}
DEFINE_GUID(IID_IZoneShellClient, 
0x96556b3f, 0xc03f, 0x11d2, 0x8b, 0x1b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{96556B3F-C03F-11d2-8B1B-00C04F8EF2FF}"))
IZoneShellClient : public IUnknown
{
	//
	// IZoneShellClient::Init
	// 
	// Receives pointer to IZoneShell
	//
	// Parameters:
	//	pIZoneShell
	//		pointer to IZoneShell that is NOT already reference counted.
	//
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey ) = 0;

	//
	// IZoneShellClient::Close
	//
	// IZoneShell wants to close, so client needs to release its pointer to it.
	//
	STDMETHOD(Close)() = 0;

	//
	// IZoneShellClient::SetGroupId
	//
	// Inform clients of a change in their identity. Not necessarily used by all.
	//
	STDMETHOD(SetGroupId)(DWORD dwGroupId) = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zoneshellex.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneShellEx.h
 *
 * Contents:	Interfaces which can be registered with the shell by an app in
 *              order to hook or supplement the shell's behavior.
 *
 *****************************************************************************/

#ifndef _ZONESHELLEX_H_
#define _ZONESHELLEX_H_


///////////////////////////////////////////////////////////////////////////////
// IZoneFrameWindow
///////////////////////////////////////////////////////////////////////////////

// {229A68F0-F98F-11d2-89BA-00C04F8EC0A2}
DEFINE_GUID(IID_IZoneFrameWindow, 
0x229a68f0, 0xf98f, 0x11d2, 0x89, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xc0, 0xa2);

interface __declspec(uuid("{229A68F0-F98F-11d2-89BA-00C04F8EC0A2}"))
IZoneFrameWindow : public IUnknown
{
	STDMETHOD_(HWND,ZCreateEx)(HWND hWndParent, LPRECT lpRect, TCHAR* szTitle = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0) = 0;
    STDMETHOD_(HWND,ZGetHWND)() = 0;
	STDMETHOD_(BOOL,ZShowWindow)(int nCmdShow) = 0;
	STDMETHOD_(BOOL,ZPreTranslateMessage)(MSG* pMsg) = 0;
	STDMETHOD_(BOOL,ZOnIdle)(int nIdleCount) = 0;
	STDMETHOD_(BOOL,ZDestroyWindow)() = 0;
	STDMETHOD_(BOOL,ZAddMenu)(HWND hWnd) = 0;
	STDMETHOD_(BOOL,ZAddToolBar)(HWND hWnd) = 0;
	STDMETHOD_(BOOL,ZAddStatusBar)(HWND hWnd) = 0;
	STDMETHOD_(BOOL,ZAddWindow)(HWND hWnd) = 0;
	STDMETHOD_(BOOL,ZEnable)(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZSetCheck)(int nID, int nCheck, BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZToggleCheck)(int nID, BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZSetRadio)(int nID, BOOL bRadio, BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZSetText)(int nID, LPCTSTR lpstrText, BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZSetState)(int nID, DWORD dwState) = 0;
	STDMETHOD_(DWORD,ZGetState)(int nID) = 0;
	STDMETHOD_(BOOL,ZUpdateMenu)(BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZUpdateToolBar)(BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZUpdateStatusBar)(BOOL bForceUpdate = FALSE) = 0;
	STDMETHOD_(BOOL,ZUpdateChildWnd)(BOOL bForceUpdate = FALSE) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IInputTranslator
///////////////////////////////////////////////////////////////////////////////

// {B12D3E5D-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IInputTranslator, 
0xb12d3e5d, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E5D-9681-11d3-884D-00C04F8EF45B}"))
IInputTranslator : public IUnknown
{
	STDMETHOD_(bool,TranslateInput)(MSG *pMsg) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// ICommandHandler
///////////////////////////////////////////////////////////////////////////////

// {B12D3E5C-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_ICommandHandler, 
0xb12d3e5c, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E5C-9681-11d3-884D-00C04F8EF45B}"))
ICommandHandler : public IUnknown
{
	STDMETHOD(Command)(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// IAcceleratorTranslator
///////////////////////////////////////////////////////////////////////////////

// {B12D3E5E-9681-11d3-884D-00C04F8EF45B}
DEFINE_GUID(IID_IAcceleratorTranslator, 
0xb12d3e5e, 0x9681, 0x11d3, 0x88, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x5b);

interface __declspec(uuid("{B12D3E5E-9681-11d3-884D-00C04F8EF45B}"))
IAcceleratorTranslator : public ICommandHandler
{
	STDMETHOD_(bool,TranslateAccelerator)(MSG *pMsg) = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zres.h ===
/*******************************************************************************

	ZRes.h
	
		Zone(tm) resource file.
	
	Copyright (c) Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Thursday, March 16, 1995 03:44:38 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		03/16/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZRES_
#define _ZRES_


typedef struct
{
	uint32			version;			/* File version. */
	uint32			signature;			/* File signature. */
	uint32			fileDataSize;		/* File data size. */
	uint32			dirOffset;			/* Offset to directory. */
} ZResourceHeader;

typedef struct
{
	uint32			type;				/* Resource item type. */
	uint32			id;					/* ID of item. */
	uint32			offset;				/* File offset of item. */
	uint32			size;				/* Size of item. */
} ZResourceItem;

typedef struct
{
	uint32			count;				/* Number of items in file. */
	ZResourceItem	items[1];			/* Variable array of items. */
} ZResourceDir;


#ifdef __cplusplus
extern "C" {
#endif

/* -------- Endian Conversion Routines -------- */
void		ZResourceHeaderEndian(ZResourceHeader* header);
void		ZResourceDirEndian(ZResourceDir* dir);
void		ZResourceItemEndian(ZResourceItem* resItem);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zrollover.h ===
/*******************************************************************************

	ZRollover.h
	
		Zone(tm) Rollover object API.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on Monday, July 22, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		07/22/96	HI		Created.
	 
*******************************************************************************/


#ifndef _ZROLLOVER_
#define _ZROLLOVER_


#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#include "MultiStateFont.h"


enum
{
	zRolloverButtonDown = 0,
	zRolloverButtonUp,
	zRolloverButtonMovedIn,
	zRolloverButtonMovedOut,
    zRolloverButtonClicked
};


enum
{
	zRolloverStateIdle = 0,
	zRolloverStateHilited,
	zRolloverStateSelected,
	zRolloverStateDisabled,
    zNumStates
};


typedef void* ZRolloverButton;


/*******************************************************************************
		ZRolloverButton
*******************************************************************************/

typedef ZBool (*ZRolloverButtonFunc)(ZRolloverButton rolloverButton, int16 state, void* userData);
	/*
		This function is called whenever the button state changes:
			zRolloverButtonDown = mouse clicked in button
			zRolloverButtonUp = mouse button up within button
			zRolloverMovedIn = cursor inside button
			zRolloverMovedOut = cursor outside button
	*/

typedef ZBool (*ZRolloverButtonDrawFunc)(ZRolloverButton rolloverButton, ZGrafPort grafPort, int16 state,
                                          ZRect* rect, void* userData);
	/*
		This function is called to draw the background of the rollover button.
	*/

#ifdef __cplusplus
extern "C" {
#endif

ZRolloverButton ZRolloverButtonNew(void);
ZError ZRolloverButtonInit(ZRolloverButton rollover, ZWindow window, ZRect* bounds, ZBool visible,
		ZBool enabled, ZImage idleImage, ZImage hiliteImage, ZImage selectedImage,
		ZImage disabledImage, ZRolloverButtonDrawFunc drawFunc, ZRolloverButtonFunc rolloverFunc, void* userData);

ZError ZRolloverButtonInit2(ZRolloverButton rollover, ZWindow window, ZRect *bounds, 
                            ZBool visible, ZBool enabled,
                            ZImage idleImage, ZImage hiliteImage, ZImage selectedImage, 
                            ZImage disabledImage, ZImage maskImage,
                            LPCTSTR pszText,
                            ZRolloverButtonDrawFunc drawFunc,
                            ZRolloverButtonFunc rolloverFunc,
                            void *userData );
                             
void ZRolloverButtonGetText( ZRolloverButton rollover, LPTSTR pszText, int cchBuf );
void ZRolloverButtonSetText( ZRolloverButton rollover, LPCTSTR pszText );
void ZRolloverButtonDelete(ZRolloverButton rollover);
void ZRolloverButtonSetRect(ZRolloverButton rollover, ZRect* rect);
void ZRolloverButtonGetRect(ZRolloverButton rollover, ZRect* rect);
void ZRolloverButtonDraw(ZRolloverButton rollover);
ZBool ZRolloverButtonIsEnabled(ZRolloverButton rollover);
void ZRolloverButtonEnable(ZRolloverButton rollover);
void ZRolloverButtonDisable(ZRolloverButton rollover);
ZBool ZRolloverButtonIsVisible(ZRolloverButton rollover);
void ZRolloverButtonShow(ZRolloverButton rollover);
void ZRolloverButtonHide(ZRolloverButton rollover, ZBool immediate);

ZBool ZRolloverButtonSetMultiStateFont( ZRolloverButton rollover, IZoneMultiStateFont *pFont );
 
#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zroom.h ===
/*******************************************************************************

	ZRoom.h
	
		Zone(tm) game room definitions.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Friday, March 10, 1995 09:51:12 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	10     05/21/98	leonp added ZCRoomGetRoomOptions()
	9		05/21/97	HI		Removed some enumerations into cmnroom.h.
    8       03/03/97  craigli   redefined protocols
    7       11/15/96    HI      Changed ZClientRoomInit() prototypes.
	6		10/23/96	HI		Changed ZClientRoomInit().
	5		10/23/96	HI		Changed ZClientRoomInit prototype.
    4       09/11/96  craigli   added zfilter.h
    3       08/28/96  craigli   expanded __cplusplus scope
	2		05/01/96	HI		Added zRoomSeatActionDenied.
								Also modified ZSRoomWait() parameters to
								include current game client version and minimum
								supported version.
	1		03/15/96	HI		Added ZRoomMsgPing.
	0		03/10/95	HI		Created.
	 
*******************************************************************************/

#ifndef _ROOM_
#define _ROOM_

#ifdef __cplusplus
extern "C" {
#endif

#include "GameMsg.h"


#define zRoomProtocolSignature              zGameRoomProtocolSignature
#define zRoomProtocolVersion                zGameRoomProtocolVersion


/* -------- Routines Exported by Room Client to Game Client -------- */
typedef ZBool (*ZClientRoomGetObjectFunc)(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
	/*
		Returns the image and rectangle of the requested object. Modifier parameter
		contains additional information to specify an object in more detail (like
		seat numbers).
		
		If an image does not exist for the specified object, then image is set to
		NULL.
		
		If a rectangle position does not exist for the specified object, then the
		rect is set to an empty rectangle.
		
		If either image or rect parameter is NULL, then that particular information
		is not wanted.
		
		Returns TRUE if it returned either the image or rect of the object.
		Returns FALSE if it has no information on the specified object.
	*/

typedef void (*ZClientRoomDeleteObjectsFunc)(void);
	/*
		Called when exiting the room. This allows the client program to properly
		dispose of the objects.
	*/
	
typedef char* (*ZClientRoomGetHelpTextFunc)(void);  // obsolete
	/*
		Called to get the room specific help text. The returned text should be
		null-terminated. ZClientRoom will free the text when it is done with
		the text.
	*/

typedef void (*ZClientRoomCustomItemFunc)(void);
	/*
		Called when the custom menu item is selected in the shell
		(or whenever the view window gets a LM_CUSTOM_ITEM_GO message).
	*/

uint32 ZCRoomGetRoomOptions(void);


/*
		Called to get the user id of player at table seat , added to use during game delete
	*/

uint32 ZCRoomGetSeatUserId(int16 table,int16 seat);
	/*
		Returns the room options to game clients
	*/

ZError		ZClientRoomInit(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, int16 numPlayersPerTable, int16 tableAreaWidth,
					int16 tableAreaHeight, int16 numTablesAcross, int16 numTablesDown,
					ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc);
	/*
		Initiates a client game room with the specified parameters.
		
		In order to get game specific images and image positions, it uses the caller
		provided getObjectFunc routine to get the images and rectangles.
		
		It calls the deleteObjectsFunc routine when exiting the room so that the
		client program may properly delete the objects.
	*/

ZError		ZClient4PlayerRoom(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc);
ZError		ZClient2PlayerRoom(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc);
void		ZCRoomExit(void);
void		ZCRoomSendMessage(int16 table, uint32 messageType, void* message,
					int32 messageLen);
void		ZCRoomGameTerminated(int16 table);
void		ZCRoomGetPlayerInfo(ZUserID playerID, ZPlayerInfo playerInfo);
void		ZCRoomBlockMessages(int16 table, int16 filter, int32 filterOnlyThis);
	/*
		Blocks game messages for the table until ZCRoomUnblockMessages() is called.
		
		If filter is 0, then all messages are automatically blocked.
		
		If filter is -1, then all messages are filtered through the
		ZCGameProcessMessage(). Any messages not handled by it are blocked.
		
		If filter is 1, then only filterOnlyThis is filtered through the game
		processing routine and all other messages are automatically blocked. If the
		filtered message is not handled, then it is also blocked.
	*/
	
void		ZCRoomUnblockMessages(int16 table);
int16		ZCRoomGetNumBlockedMessages(int16 table);
void		ZCRoomDeleteBlockedMessages(int16 table);
void		ZCRoomAddBlockedMessage(int16 table, uint32 messageType, void* message, int32 messageLen);
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\inputmanager\cinputmanager.h ===
//
// CInputManager.h
//
// Internal header for input manager
//

#ifndef _CINPUTMANAGER_H_
#define _CINPUTMANAGER_H_

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ClientImpl.h"
#include "InputManager.h"
#include "ZoneShellEx.h"


class ATL_NO_VTABLE CInputManager :
	public IInputTranslator,
    public IInputManager,
	public IZoneShellClientImpl<CInputManager>,
	public IEventClientImpl<CInputManager>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CInputManager, &CLSID_InputManager>
{
public:
    CInputManager() : m_cnIVKH(NULL), m_cnICH(NULL), m_cnIMH(NULL) { ZeroMemory(m_rgbKbdState, sizeof(m_rgbKbdState)); }
    ~CInputManager() { if(m_cnIVKH) delete m_cnIVKH; if(m_cnICH) delete m_cnICH; if(m_cnIMH) delete m_cnIMH; }

	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CInputManager)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IInputTranslator)
        COM_INTERFACE_ENTRY(IInputManager)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
	END_EVENT_MAP()

// IZoneShellClient
public:
    STDMETHOD(Init)(IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey);
	STDMETHOD(Close)();

// IInputTranslator
public:
	STDMETHOD_(bool,TranslateInput)(MSG *pMsg);

// IInputManager
public:
    STDMETHOD(RegisterVKeyHandler)(IInputVKeyHandler *pIVKH, long nOrdinal, bool fGlobal = false)
    {
        if(fGlobal)
            return E_NOTIMPL;

        IM_CChain<IInputVKeyHandler> *cn = new IM_CChain<IInputVKeyHandler>(pIVKH, nOrdinal);
        if(!cn)
            return E_OUTOFMEMORY;

        cn->AttachTo(&m_cnIVKH);
        return S_OK;
    }


    STDMETHOD(UnregisterVKeyHandler)(IInputVKeyHandler *pIVKH)
    {
        IM_CChain<IInputVKeyHandler> *cn = m_cnIVKH->FindInterface(pIVKH);
        if(!cn)
            return S_FALSE;

        cn->DetachFrom(&m_cnIVKH);
        delete cn;
        return S_OK;
    }


    STDMETHOD(RegisterCharHandler)(IInputCharHandler *pICH, long nOrdinal, bool fGlobal = false)
    {
        if(fGlobal)
            return E_NOTIMPL;

        IM_CChain<IInputCharHandler> *cn = new IM_CChain<IInputCharHandler>(pICH, nOrdinal);
        if(!cn)
            return E_OUTOFMEMORY;

        cn->AttachTo(&m_cnICH);
        return S_OK;
    }


    STDMETHOD(UnregisterCharHandler)(IInputCharHandler *pICH)
    {
        IM_CChain<IInputCharHandler> *cn = m_cnICH->FindInterface(pICH);
        if(!cn)
            return S_FALSE;

        cn->DetachFrom(&m_cnICH);
        delete cn;
        return S_OK;
    }


    STDMETHOD(RegisterMouseHandler)(IInputMouseHandler *pIMH, long nOrdinal, bool fGlobal = false)
    {
        if(fGlobal)
            return E_NOTIMPL;

        IM_CChain<IInputMouseHandler> *cn = new IM_CChain<IInputMouseHandler>(pIMH, nOrdinal);
        if(!cn)
            return E_OUTOFMEMORY;

        cn->AttachTo(&m_cnIMH);
        return S_OK;
    }


    STDMETHOD(UnregisterMouseHandler)(IInputMouseHandler *pIMH)
    {
        IM_CChain<IInputMouseHandler> *cn = m_cnIMH->FindInterface(pIMH);
        if(!cn)
            return S_FALSE;

        cn->DetachFrom(&m_cnIMH);
        delete cn;
        return S_OK;
    }


    STDMETHOD(ReleaseReferences)(IUnknown *pIUnk)
    {
        IM_CChain<IInputVKeyHandler> *cnVKH = m_cnIVKH->FindInterface(pIUnk);
        if(cnVKH)
        {
            cnVKH->DetachFrom(&m_cnIVKH);
            delete cnVKH;
        }

        IM_CChain<IInputCharHandler> *cnCH = m_cnICH->FindInterface(pIUnk);
        if(cnCH)
        {
            cnCH->DetachFrom(&m_cnICH);
            delete cnCH;
        }

        IM_CChain<IInputMouseHandler> *cnMH = m_cnIMH->FindInterface(pIUnk);
        if(cnMH)
        {
            cnMH->DetachFrom(&m_cnIMH);
            delete cnMH;
        }

        return S_OK;
    }

protected:
    template <class T>
    class IM_CChain
    {
    public:
        IM_CChain(T* pI, long nOrdinal) : m_pI(pI), m_nOrdinal(nOrdinal), m_cnNext(NULL) { }
        ~IM_CChain() { if(m_cnNext) delete m_cnNext; }

        void AttachTo(IM_CChain<T> **ppChain)
        {
            ASSERT(!m_cnNext);

            if(!*ppChain)
            {
                *ppChain = this;
                return;
            }

            if(m_nOrdinal > (*ppChain)->m_nOrdinal)
            {
                AttachTo(&(*ppChain)->m_cnNext);
                return;
            }

            m_cnNext = *ppChain;
            *ppChain = this;
        }

        void DetachFrom(IM_CChain<T> **ppChain)
        {
            ASSERT(*ppChain);

            if(*ppChain == this)
            {
                *ppChain = m_cnNext;
                m_cnNext = NULL;
                return;
            }

            DetachFrom(&(*ppChain)->m_cnNext);
        }

        IM_CChain<T>* FindInterface(IUnknown* pI)
        {
            if(!this)
                return NULL;

            if(!m_pI.IsEqualObject(pI))
                return m_cnNext->FindInterface(pI);

            return this;
        }

        long m_nOrdinal;
        CComPtr<T> m_pI;
        IM_CChain<T> *m_cnNext;
    };

    IM_CChain<IInputVKeyHandler> *m_cnIVKH;
    IM_CChain<IInputCharHandler> *m_cnICH;
    IM_CChain<IInputMouseHandler> *m_cnIMH;

    BYTE m_rgbKbdState[256];
};


#endif // _CINPUTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\include\zui.h ===
//  File: zui.h : defines specific windows zsystem stuff
//
//  Copyright(c) 1995, Electric Gravity, Inc.
//	Copyright(c) 1996, Microsoft Corp.
//

#include <stdlib.h>
#include <windows.h>
#include "zone.h"
#include "zonedebug.h"
#include "BasicATL.h"
#include "DataStore.h"

void ZSystemAssert(ZBool x);
#define FONT_MULT 96
#define FONT_MULT 96

HFONT ZCreateFontIndirect(ZONEFONT* zFont, HDC hDC = NULL, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE);
HFONT ZCreateFontIndirectBackup(ZONEFONT* zfPreferred, ZONEFONT* zfBackup, HDC hDC = NULL, BYTE bItalic = FALSE, BYTE bUnderline = FALSE ,BYTE bStrikeOut = FALSE);

// windows zone library version
// highword is major rev, loword is minor rev
#define zVersionWindows 0x00010001

#define MySetProp32 SetProp
#define MyRemoveProp32 RemoveProp
#define MyGetProp32 GetProp

#define ZLIBPUBLIC

// usefull defines
#define RectWidth(r) ((r)->right - (r)->left)
#define RectHeight(r) ((r)->bottom - (r)->top)


#ifdef __cplusplus
extern "C" {
#endif

// functions that should be in the API?

ZFont ZFontCopyFont(ZFont font);
ZError ZLIBPUBLIC ZWindowClearMouseCapture(ZWindow window);
ZError ZLIBPUBLIC ZWindowSetMouseCapture(ZWindow window);
ZError ZWindowInitApplication();
void ZWindowTermApplication();
void ZWindowIdle();
ZError ZLIBPUBLIC ZWindowEnable(ZWindow window);
ZError ZLIBPUBLIC ZWindowDisable(ZWindow window);
ZBool ZLIBPUBLIC ZWindowIsEnabled(ZWindow window);
void ZButtonClickButton(ZButton button);
void ZButtonSetDefaultButton(ZButton button);

// functions specific to the windows library
ZBool ZInfoInitApplication(void);
void ZInfoTermApplication();
BOOL ZTimerInitApplication();
void ZTimerTermApplication();
HFONT ZFontWinGetFont(ZFont font);
HWND ZWindowWinGetWnd(ZWindow window);
uint16 ZWindowWinGetNextControlID(ZWindow window);
HDC ZWindowWinGetPaintDC(ZWindow window);
HBITMAP ZImageGetMask(ZImage image);
HBRUSH ZBrushGetHBrush(ZBrush brush);
HBITMAP ZImageGetHBitmapImage(ZImage image);
void ZImageSetHBitmapImage(ZImage image, HBITMAP hBitmap);
void ZImageSetHBitmapImageMask(ZImage image, HBITMAP hBitmapMask);

HWND ZWinGetDesktopWindow(void);
void ZWinCenterPopupWindow(HWND parent, int width, int height, RECT* rect);
HDC ZGrafPortGetWinDC(ZGrafPort grafPort);
HWND ZWindowWinGetOCXWnd(void);
void ZMessageBox(ZWindow parent, TCHAR* title, TCHAR* text);
void ZMessageBoxEx(ZWindow parent, TCHAR* title, TCHAR* text);
void ZWindowChangeFont(ZWindow window);
void ZWindowDisplayPrelude(void);

LRESULT ZScrollBarDispatchProc(ZScrollBar scrollBar, WORD wNotifyCode, short nPos);
LRESULT ZEditTextDispatchProc(ZEditText editText, WORD wNotifyCode);
LRESULT ZRadioDispatchProc(ZRadio radio, WORD wNotifyCode);
LRESULT ZCheckBoxDispatchProc(ZCheckBox checkBox, WORD wNotifyCode);
LRESULT ZButtonDispatchProc(ZButton button, WORD wNotifyCode);

ZBool ZNetworkEnableMessages(ZBool enable);
ZBool ZNetworkInitApplication();
void ZNetworkTermApplication();

#ifdef __cplusplus
}
#endif

#define printf ZPrintf
void ZPrintf(char *format, ...);

//////////////////////////////////////////////////////////////////////////
// Private Types:

typedef enum tagZObjectType { 
	zTypeWindow, zTypeCheckBox, zTypeScrollBar, zTypeRadio,
	zTypeButton, zTypeEditText, zTypePicture, zTypePen, zTypeImage, zTypePattern,
	zTypeTimer, zTypeSound, zTypeOffscreenPort, zTypeCursor, zTypeFont, zTypeInfo,
} ZObjectType;


#ifdef __cplusplus


class ZObjectHeader {
public:
	ZObjectType nType;
};

class ZGraphicsObjectHeader : public ZObjectHeader {
public:
	// drawing state information
	RECT portRect;
	HBITMAP hBitmap; // for Offscreen use
	HBITMAP hBitmapSave;

	int16 penWidth;
	int32 penStyle;

	uint16 nDrawingCallCount;
	HDC hDC;
	int nDrawMode;
	HPEN hPenSave;
	HPEN hPenForeColor;
	HPEN hPenBackColor;
	HBRUSH hBrushSave;
	HBRUSH hBrushForeColor;
	HBRUSH hBrushBackColor;
	ZColor colorBackColor;
	COLORREF nBackColor;
	ZColor colorForeColor;
	COLORREF nForeColor;
	HFONT hFontSave;
	HPALETTE hPalSave;

	// current position of pen
	int16 penX;
	int16 penY;
};


#endif

//////////////////////////////////////////////////////////////////////////
// Private Function prototypes:

///////////////////////////////////////////////////////////////////////////////
// Helper functions

void ZRectToWRect(RECT* rect, ZRect* zrect);
void WRectToZRect(ZRect* zrect, RECT* rect);

void ZPointToWPoint(POINT* point, ZPoint* zpoint);
void WPointToZPoint(ZPoint* zpoint, POINT* point);


///////////////////////////////////////////////////////////////////////////////
// global variables

#ifdef ZONECLI_DLL

#define g_hInstanceLocal			(pGlobals->m_g_hInstanceLocal)
#define gHWNDMainWindow				(pGlobals->m_gHWNDMainWindow)
//#define gPal						(pGlobals->m_gPal)

#else

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE g_hInstanceLocal; // the instance of this app

#ifdef __cplusplus
}
#endif

extern HWND gHWNDMainWindow; // the main window of the application
// PCWPAL
//extern HPALETTE gPal; // the one palette we use

#endif

// we need this because when we compile in Unicode we call CallWindowProcU
// with a WNDPROC, but when we compile in ANSI we call CallWindowProcU 
// (really CallWindowProcA) with a FARPROC.
#ifdef UNICODE
typedef FARPROC ZONECLICALLWNDPROC;
#else
typedef FARPROC ZONECLICALLWNDPROC;
#endif


extern const TCHAR *g_szWindowClass; // the one wnd class we use
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\inputmanager\cinputmanager.cpp ===
#include <ZoneResource.h>
#include <BasicATL.h>
#include <ATLFrame.h>
#include "CInputManager.h"
#include "ZoneShell.h"


///////////////////////////////////////////////////////////////////////////////
// Interface methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInputManager::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CInputManager>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

    // register with the shell as the input translator
    ZoneShell()->SetInputTranslator(this);

	return S_OK;
}


STDMETHODIMP CInputManager::Close()
{
    // tell the shell that I'm going away
    ZoneShell()->ReleaseReferences((IInputTranslator *) this);

	return IZoneShellClientImpl<CInputManager>::Close();
}


STDMETHODIMP_(bool) CInputManager::TranslateInput(MSG *pMsg)
{
    UINT message = pMsg->message;
    bool fHandled = false;

    if(message == WM_KEYDOWN || message == WM_KEYUP || message == WM_SYSKEYDOWN || message == WM_SYSKEYUP)
    {
        // send a generic keyboard-action event
        if((message == WM_KEYDOWN || message == WM_SYSKEYDOWN) && !(pMsg->lParam & 0x40000000))
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_INPUT_KEYBOARD_ALERT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);

        IM_CChain<IInputVKeyHandler> *pCur;
        int bit = ((message == WM_KEYDOWN || message == WM_KEYUP) ? 0x01 : 0x02);
        DWORD dwVKey = pMsg->wParam & 0xff;
        bool ret;

        // for eating some number of repeats
        DWORD cRepeatMsg;
        DWORD cRepeatEaten = pMsg->lParam & 0x0000ffff;

        // since we do this kbd state management, this kindof has to be kept flat - you can't prevent other hooks from getting it
        for(pCur = m_cnIVKH; pCur; pCur = pCur->m_cnNext)
        {
            cRepeatMsg = pMsg->lParam & 0x0000ffff;
            ret = pCur->m_pI->HandleVKey(message, dwVKey, (pMsg->lParam & 0x00ff0000) >> 16, (pMsg->lParam & 0xff000000) >> 24, &cRepeatMsg, pMsg->time);
            if(!cRepeatMsg)
                ret = true;
            else
                if(cRepeatMsg < cRepeatEaten)
                    cRepeatEaten = cRepeatMsg;
            fHandled = (fHandled || ret);
        }

        // replace the repeat count with the new one if not totally eaten
        if(!fHandled)
            pMsg->lParam = (pMsg->lParam & 0xffff0000) | (cRepeatEaten & 0x0000ffff);

        // force consistency
        if(message == WM_KEYDOWN || message == WM_SYSKEYDOWN)
        {
            // if they've been being ignored but this one isn't, make it look like the first
            if((m_rgbKbdState[dwVKey] & bit) && !fHandled)
            {
                m_rgbKbdState[dwVKey] &= ~bit;
                pMsg->lParam &= 0xbfffffff;
            }
            else
            {
                // if this one is ignored and it's the first, set the bit
                if(fHandled && !(pMsg->lParam & 0x40000000))
                    m_rgbKbdState[dwVKey] |= bit;
            }
        }
        else
        {
            // if they've been ignored, force this one ignored, otherwise don't
            if(m_rgbKbdState[dwVKey] & bit)
                fHandled = true;
            else
                fHandled = false;

            m_rgbKbdState[dwVKey] &= ~bit;
        }
    }

    if(message == WM_CHAR || message == WM_DEADCHAR || message == WM_SYSCHAR || message == WM_SYSDEADCHAR ||
		message == WM_IME_SETCONTEXT || message == WM_IME_STARTCOMPOSITION || message==WM_IME_COMPOSITION || message == WM_IME_NOTIFY ||
		message == WM_IME_SELECT)
    {
        IM_CChain<IInputCharHandler> *pCur;

        // this one isn't flat - too bad if you want consistency with the virtual key one
        // i think it makes sense this way
        for(pCur = m_cnICH; pCur && !fHandled; pCur = pCur->m_cnNext)
		{
            if(pCur->m_pI->HandleChar(&pMsg->hwnd, message, pMsg->wParam, pMsg->lParam, pMsg->time))
                fHandled = true;
		}
    }

    // mouse unimplemented - needs more definition
    // just send a generic mouse-action event
    // leave double-clicks out of this, that counts as one mouse event
    if(message == WM_LBUTTONDOWN || message == WM_MBUTTONDOWN || message == WM_RBUTTONDOWN ||
        message == WM_NCLBUTTONDOWN || message == WM_NCMBUTTONDOWN || message == WM_NCRBUTTONDOWN)
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_INPUT_MOUSE_ALERT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);

    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbydatastore\clobbydatastore.h ===
#include "ZoneDef.h"
#include "BasicATL.h"
#include "ZoneLocks.h"
#include "ZoneString.h"
#include "Queue.h"
#include "Hash.h"
#include "LobbyDataStore.h"

class CLobbyDataStore :
	public ILobbyDataStore,
	public ILobbyDataStoreAdmin,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CLobbyDataStore, &CLSID_LobbyDataStore>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CLobbyDataStore)
		COM_INTERFACE_ENTRY(ILobbyDataStore)
		COM_INTERFACE_ENTRY(ILobbyDataStoreAdmin)
	END_COM_MAP()

// CLobbyDataStore
public:
	ZONECALL CLobbyDataStore();
	ZONECALL ~CLobbyDataStore();

// ILobbyDataStoreAdmin
public:

	STDMETHOD(Init)( IDataStoreManager* pIDataStoreManager );

	STDMETHOD(NewUser)( DWORD dwUserId, TCHAR* szUserName );

	STDMETHOD(SetLocalUser)( DWORD dwUserId );

	STDMETHOD(DeleteUser)( DWORD dwUserId );

	STDMETHOD(DeleteAllUsers)();

	STDMETHOD(NewGroup)( DWORD dwGroupId );

	STDMETHOD(DeleteGroup)( DWORD dwGroupId );

	STDMETHOD(DeleteAllGroups)();
	
	STDMETHOD(AddUserToGroup)( DWORD dwUserId, DWORD dwGroupId );

	STDMETHOD(RemoveUserFromGroup)( DWORD dwUserId, DWORD dwGroupId );

	STDMETHOD(ResetGroup)( DWORD dwGroupId );

	STDMETHOD(ResetAllGroups)();

// ILobbyDataStore
public:
	STDMETHOD(GetDataStore)( DWORD dwGroupId, DWORD dwUserId, IDataStore** ppIDataStore );

	STDMETHOD_(DWORD,GetUserId)( TCHAR*	szUserName );

	STDMETHOD_(bool,IsUserInLobby)( DWORD dwUserId );

	STDMETHOD_(bool,IsGroupInLobby)( DWORD dwGroupId );

	STDMETHOD_(bool,IsUserInGroup)( DWORD dwGroupId, DWORD dwUserId );

	STDMETHOD_(long,GetGroupUserCount)( DWORD dwGroupId );

	STDMETHOD_(long,GetUserGroupCount)( DWORD dwUserId );

	STDMETHOD(EnumGroups)(
		DWORD			dwUserId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext );

	STDMETHOD(EnumUsers)(
		DWORD			dwGroupId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext );

// internal functions and data
protected:

	class User;
	class Group;
	class GroupUser;

	class User
	{
	public:
		ZONECALL User( DWORD dwUserId, TCHAR* szUserName );
		ZONECALL ~User();
		ULONG ZONECALL AddRef();
		ULONG ZONECALL Release();

		static void ZONECALL Del( User* pUser, LPVOID pContext );
		static bool ZONECALL CmpId( User* pUser, DWORD dwUserId )			{ return pUser->m_dwUserId == dwUserId; }
		static bool ZONECALL CmpName( User* pUser, TCHAR* szUserName )		{ return CompareUserNames( pUser->m_szUserName, szUserName ); }

		CList<GroupUser>	m_listGroups;
		DWORD				m_dwUserId;
		TCHAR				m_szUserName[ZONE_MaxUserNameLen];
		ULONG				m_nRefCnt;
		IDataStore*			m_pIDataStore;

	private:
		ZONECALL User() {}
	};

	class Group
	{
	public:
		ZONECALL Group( DWORD dwGroupId );
		ZONECALL ~Group();
		ULONG ZONECALL AddRef();
		ULONG ZONECALL Release();

		static void ZONECALL Del( Group* pGroup, LPVOID pContext );
		static bool ZONECALL CmpId( Group* pGroup, DWORD dwGroupId )		{ return pGroup->m_dwGroupId == dwGroupId; }

		CList<GroupUser>	m_listUsers;
		DWORD				m_dwGroupId;
		ULONG				m_nRefCnt;
		IDataStore*			m_pIDataStore;
	
	private:
		ZONECALL Group() {}
	};

	class GroupUser
	{
	public:
		ZONECALL GroupUser( Group* pGroup, User* pUser );
		ZONECALL ~GroupUser();
		ULONG ZONECALL AddRef();
		ULONG ZONECALL Release();

		void ZONECALL ClearUser();
		void ZONECALL ClearGroup();

		Group*		m_pGroup;
		User*		m_pUser;
		ULONG		m_nRefCnt;
		IDataStore*	m_pIDataStore;
	
	private:
		ZONECALL GroupUser() {}
	};


	struct FindGroupUserContext
	{
		CLobbyDataStore*	m_pDS;
		Group*				m_pGroup;
		User*				m_pUser;
		GroupUser*			m_pGroupUser;
	};

	struct EnumContext
	{
		DWORD			m_dwGroupId;
		DWORD			m_dwUserId;
		PFENTITYENUM	m_pfCallback;
		void*			m_pContext;
	};

	struct KeyEnumContext
	{
		DWORD		m_dwGroupId;
		DWORD		m_dwUserId;
		PFKEYENUM	m_pfCallback;
		void*		m_pContext;
	};

	// list callbacks
	static bool ZONECALL FindGroupUser( GroupUser* p, ListNodeHandle h, void* pContext );
	static bool ZONECALL RemoveGroupUser( GroupUser* p, ListNodeHandle h, void* pContext );

	// hash callbacks
	static bool ZONECALL HashEnumClearGroup( Group* p, MTListNodeHandle h, void* pContext );
	static bool ZONECALL HashEnumGroupsCallback( Group* p, MTListNodeHandle h, void* pContext );
	static bool ZONECALL ListEnumGroupsCallback( GroupUser* p, ListNodeHandle h, void* pContext );
	static bool ZONECALL HashEnumUsersCallback( User* p, MTListNodeHandle h, void* pContext );
	static bool ZONECALL ListEnumCallback( GroupUser* p, ListNodeHandle h, void* pContext );

	// datastore callbacks
	static HRESULT ZONECALL KeyEnumCallback( CONST TCHAR*	szKey, CONST LPVARIANT	pVariant, DWORD dwSize, LPVOID pContext );

	// member variables
	CCriticalSection	m_csLock;				// object syncronizatoin
	CHash<User,DWORD>	m_hashUserId;			// user hash table indexed by id
	CHash<User,TCHAR*>	m_hashUserName;			// user hash table indexed by name
	CHash<Group,DWORD>	m_hashGroupId;			// group hash table indexed by group
	CPool<User>			m_poolUser;				// memory pool for users
	CPool<Group>		m_poolGroup;			// memory pool for groups
	CPool<GroupUser>	m_poolGroupUser;		// memory pool for group / user mapping
	IDataStoreManager*	m_pIDataStoreManager;	// low-level data store manager
	IDataStore*			m_pIDSLobby;			// low-level data store of lobby parameters
	DWORD				m_dwLocalUserId;		// Local user id
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\dsviewer.cpp ===
// EventSpy.cpp : Implementation of CEventSpy
#include "stdafx.h"
#include "DSViewer.h"

/////////////////////////////////////////////////////////////////////////////
// CDSViewer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbydatastore\test\main.cpp ===
#include "BasicATL.h"

#include "ZoneDebug.h"
#include "ZoneCom.h"
#include "LobbyDataStore.h"
#include "CLobbyDataStore.h"

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LobbyDataStore, CLobbyDataStore )
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

void TestAdmin( ILobbyDataStoreAdmin* pIAdmin )
{
	pIAdmin->NewUser( 1, "User1" );
	pIAdmin->NewUser( 2, "User2" );
	pIAdmin->NewUser( 3, "User3" );

	pIAdmin->NewGroup( 1 );
	pIAdmin->NewGroup( 2 );

	ASSERT( pIAdmin->GetUserId( "User1" ) == 1 );
	ASSERT( pIAdmin->GetUserId( "User2" ) == 2 );
	ASSERT( pIAdmin->GetUserId( "User3" ) == 3 );

	pIAdmin->AddUserToGroup( 1, 1 );
	pIAdmin->AddUserToGroup( 2, 1 );
	pIAdmin->AddUserToGroup( 3, 1 );
	pIAdmin->RemoveUserFromGroup( 3, 1 );
	pIAdmin->AddUserToGroup( 3, 1 );

	pIAdmin->AddUserToGroup( 1, 2 );
	pIAdmin->AddUserToGroup( 2, 2 );
	pIAdmin->ResetGroup( 2 );
}


HRESULT ZONECALL PrintUserData( DWORD dwGroupId, DWORD dwUserId, CONST TCHAR* szKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	printf("   Key %s, ", szKey );

	if ( pVariant )
	{
		switch( pVariant->vt )
		{
		case VT_I4:
			printf("type = long, value = %d", pVariant->lVal );
			break;
		case VT_BYREF | VT_UI1:
			printf("type = string, value = %s", (TCHAR*) pVariant->byref );
			break;
		case VT_BYREF:
			printf("type = blob, size = %s", dwSize );
			break;
		}
	}
	else 
		printf("no data", szKey );

	printf( "\n" );
	return S_OK;
}


HRESULT ZONECALL PrintUsers( DWORD	dwGroupId, DWORD dwUserId, LPVOID pContext )
{
	ILobbyDataStore* pIDS = (ILobbyDataStore*) pContext;
	printf( "\nGroupId = %d, UserId = %d:\n", dwGroupId, dwUserId );
	return pIDS->EnumKeys( dwGroupId, dwUserId, NULL, PrintUserData, NULL );
}


void TestDS( ILobbyDataStore* pIDS )
{
	VARIANT vName, vLatency;
	DWORD sz;

	{
		// test user data for lobby
		SetString( vName, "User1", &sz );
		SetLong( vLatency, 100 );
		pIDS->SetKey( ZONE_NOGROUP, 1, _T("UserName"), &vName, sz );
		pIDS->SetKey( ZONE_NOGROUP, 1, _T("Latency"), &vLatency, 0 );

		SetString( vName, "User2", &sz );
		SetLong( vLatency, 200 );
		pIDS->SetKey( ZONE_NOGROUP, 2, _T("UserName"), &vName, sz );
		pIDS->SetKey( ZONE_NOGROUP, 2, _T("Latency"), &vLatency, 0 );

		SetString( vName, "User3", &sz );
		SetLong( vLatency, 300 );
		pIDS->SetKey( ZONE_NOGROUP, 3, _T("UserName"), &vName, sz );
		pIDS->SetKey( ZONE_NOGROUP, 3, _T("Latency"), &vLatency, 0 );
		
		pIDS->EnumUsers( ZONE_NOGROUP, PrintUsers, pIDS );
	}

	{
		// test user data per group
		SetLong( vLatency, 110 );
		pIDS->SetKey( 1, 1, _T("Dummy"), &vLatency, 0 );

		SetLong( vLatency, 220 );
		pIDS->SetKey( 1, 2, _T("Dummy"), &vLatency, 0 );

		SetLong( vLatency, 320 );
		pIDS->SetKey( 1, 3, _T("Dummy"), &vLatency, 0 );
		
		pIDS->EnumUsers( 1, PrintUsers, pIDS );
	}
}


void __cdecl main ()
{
	CZoneComManager loader;
	IDataStoreManager* pIDataStore = NULL;
	IClassFactory* pIClassFactory = NULL;
	ILobbyDataStore* pILobbyDataStore = NULL;
	ILobbyDataStoreAdmin* pILobbyDataStoreAdmin = NULL;

	// instantiate lobby data store
	_Module.Init(ObjectMap, GetModuleHandle(NULL) );
	_Module.GetClassObject( CLSID_LobbyDataStore, IID_IClassFactory, (void**) &pIClassFactory );
	pIClassFactory->CreateInstance( NULL, IID_ILobbyDataStoreAdmin, (void**) &pILobbyDataStoreAdmin );
	pILobbyDataStoreAdmin->QueryInterface( IID_ILobbyDataStore, (void**) &pILobbyDataStore );

	// instantiate low-level data store
	loader.Create( "E:\\z6\\ZoneNT\\Common\\Shared\\DataStore\\debug\\DataStore.dll", NULL, CLSID_DataStoreManager, IID_IDataStoreManager, (void**) &pIDataStore );
	pIDataStore->Init();
	pILobbyDataStoreAdmin->Init( pIDataStore );

	// test interfaces
	TestAdmin( pILobbyDataStoreAdmin );
	TestDS( pILobbyDataStore );

	// release lobby data store
	pILobbyDataStoreAdmin->Release();
	pILobbyDataStore->Release();
	pIClassFactory->Release();
	_Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\dsviewer.h ===
// DSViewer.h : Declaration of the CDSViewer

#pragma once

#include "ZoneResource.h"       // main symbols
#include "ZDialogImpl.h"

#include <atlgdi.h>
#include <atlctrls.h>
//#include <eventqueue.h>

//#include <ZoneEvent.h>
#include "splitter.h"
#include <ClientIMPL.h>

#include "..\ZoneClient\resource.h"

class CTreeItemData
{
public:
	virtual int PopulateSubKeys(CTreeItem& item) = 0;
	virtual void PopulateData(CListViewCtrl& lvList) = 0;
};


// Used for a node which represents a (sub)key of a DataStore
class CTidIDataStore : public CTreeItemData
{
	CString m_szKey;
	CComPtr<IDataStore> m_pIDataStore;

	CTreeItem*	m_pTreeItem;		// only valid during EnumKeys callback
	int			m_KeysAdded;		// only valid during EnumKeys callback

	CListViewCtrl*	m_plvList;		// only valid during EnumData callback
	
public:
	CTidIDataStore(IDataStore* pIDataStore, CONST TCHAR* szKey) :
		m_pIDataStore(pIDataStore),
		m_szKey(szKey)
	{}
	
	int PopulateSubKeys(CTreeItem& item)
	{
		m_pTreeItem = &item;
		m_KeysAdded = 0;

		m_pIDataStore->EnumKeys( m_szKey, EnumKeys, this);
		return m_KeysAdded;
	}

	void PopulateData( CListViewCtrl& lvList)
	{
		m_plvList = &lvList;
		m_pIDataStore->EnumKeys( m_szKey, EnumData, this);
	}

	static HRESULT ZONECALL EnumKeys(CONST TCHAR* szFullKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext)
	{	return ((CTidIDataStore*)pContext)->EnumKeys( szFullKey, szRelKey, pVariant, dwSize);	}

	static HRESULT ZONECALL EnumData(CONST TCHAR* szFullKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext)
	{	return ((CTidIDataStore*)pContext)->EnumData( szFullKey, szRelKey, pVariant, dwSize);	}

	HRESULT EnumKeys(CONST TCHAR* szFullKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize)
	{
		if ( !pVariant && !_tcschr(szRelKey,_T('/')) )
		{
			CTreeItem item = m_pTreeItem->AddTail( szRelKey, -1);
			CTreeItemData* pItemData = new CTidIDataStore(m_pIDataStore, m_szKey+szRelKey);
			item.SetData((DWORD)pItemData);

			TV_ITEM tv_item;
			tv_item.cChildren = 1;
			tv_item.mask = TVIF_CHILDREN ;
			tv_item.hItem = item;
			item.m_pTreeView->SetItem( &tv_item ) ;

			m_KeysAdded++;
		}
		return S_OK;
	}

	HRESULT EnumData(CONST TCHAR* szFullKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize)
	{
		if ( pVariant )
		{
			m_plvList->InsertItem(0, szRelKey);

			TCHAR buf[256];

			wsprintf( buf, _T("[UNKNOWN]"));

			switch ( pVariant->vt )
			{
			case ZVT_BLOB: {
				TCHAR * pChar = (TCHAR*)pVariant->byref;
				wsprintf(buf, _T("[BLOB] %d('%c')"), pChar[0]);
				}
				break;
			case ZVT_LONG:
				wsprintf(buf, _T("[LONG] %d"), pVariant->lVal);
				break;
			case ZVT_LPTSTR:
				wsprintf(buf, _T("[SZ] \"%s\""), (TCHAR*)pVariant->byref);
				break;
			case ZVT_RGB: {
				BYTE red = GetRValue( pVariant->lVal );
				BYTE green = GetGValue( pVariant->lVal );
				BYTE blue = GetBValue( pVariant->lVal );
				wsprintf(buf, _T("[RGB] { %d, %d, %d }"), red, green, blue);
				}
				break;
			case ZVT_PT: {
				POINT& pt = *(POINT*)pVariant->byref;
				wsprintf( buf, _T("[PT] { %d, %d }"), pt.x, pt.y );
				break;
				}
			case ZVT_RECT: {
				RECT& rc = *(RECT*)pVariant->byref;
				wsprintf( buf, _T("[RECT] { l:%d, t:%d, r:%d, b:%d }"), rc.left, rc.top, rc.right, rc.bottom );
				break;
				}
			case ZVT_FONT: {
				ZONEFONT& font = *(ZONEFONT*)pVariant->byref;

				const TCHAR* szWeight[] = { _T("Don't Care"),		//   0
										   _T("Thin"),				// 100
										   _T("Extra/Ultra Light"),	// 200
										   _T("Light"),				// 300
										   _T("Normal/Regular"),	// 400
										   _T("Medium"),			// 500
										   _T("Semi/Demi Bold"),	// 600
										   _T("Bold"),				// 700
										   _T("Extra/Ultra Bold"),	// 800
										   _T("Heavy/Black" });		// 900

				wsprintf( buf, _T("[FONT] { %s %d, %s }"), font.lfFaceName, font.lfHeight, szWeight[font.lfWeight/100] );
				break;
				}
			}

			m_plvList->SetItemText(0, 1, buf);

		}
		return S_OK;
	}
};

// Used for the node which represents the LobbyDataStore
class CTidLobby : public CTreeItemData
{
	DWORD m_UserId;
	CComPtr<ILobbyDataStore> m_pILobbyDataStore;
public:
	CTidLobby(ILobbyDataStore* pILobbyDataStore, DWORD UserId) :
		m_pILobbyDataStore(pILobbyDataStore),
		m_UserId(UserId)
	{}

	int PopulateSubKeys(CTreeItem& item)
	{
		TV_ITEM tv_item;
		tv_item.cChildren = 1;
		tv_item.mask = TVIF_CHILDREN;

		CComPtr<IDataStore> pIDS;

		// Lobby wide common stuff
		m_pILobbyDataStore->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
		CTreeItem subitem = item.AddTail( _T("Common"), -1);
		CTreeItemData* pItemData = new CTidIDataStore(pIDS, NULL);
		subitem.SetData((DWORD)pItemData);
		pIDS.Release();
		tv_item.hItem = subitem;
		subitem.m_pTreeView->SetItem( &tv_item ) ;

//!! hmm, id isn't set.
		// personal settings for the lobby
		m_pILobbyDataStore->GetDataStore( ZONE_NOGROUP, m_UserId, &pIDS );
		subitem = item.AddTail( _T("Personal"), -1);
		pItemData = new CTidIDataStore(pIDS, NULL);
		subitem.SetData((DWORD)pItemData);
		pIDS.Release();
		tv_item.hItem = subitem;
		subitem.m_pTreeView->SetItem( &tv_item ) ;

//!! go to max games.
		for ( int game=0; game<4; game++ )
		{
			m_pILobbyDataStore->GetDataStore( game, ZONE_NOUSER, &pIDS );
			TCHAR buf[30];
			wsprintf( buf, _T("Game %d"), game+1);
			subitem = item.AddTail( buf, -1);
			pItemData = new CTidIDataStore(pIDS, NULL);
			subitem.SetData((DWORD)pItemData);
			pIDS.Release();
			tv_item.hItem = subitem;
			subitem.m_pTreeView->SetItem( &tv_item ) ;
		}

		return 0;
	}
	void PopulateData(CListViewCtrl& lvList)
	{
	}
};

/////////////////////////////////////////////////////////////////////////////
// CDSViewer
class ATL_NO_VTABLE CDSViewer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ZDialogImpl<CDSViewer>,
	public IZoneShellClientImpl<CDSViewer>
{
	CRect m_rcList;						
	CRect m_rcTree;

	CListViewCtrl		m_wndList;
	CTreeViewCtrlEx		m_wndTree;

	// Splitter bar information
	CSplitterFixed m_splitterVertical;				
	bool m_bSplitterActive;					
	CRect m_rcVertical;								

public:
	CDSViewer() :
		m_bSplitterActive(false),
		m_splitterVertical(CRect(100,200,300,1000), CSplitter::VERTICAL, 140, CSplitterFixed::LEFT)
	{
	}

	~CDSViewer()
	{
	}

BEGIN_COM_MAP(CDSViewer)
	COM_INTERFACE_ENTRY(IZoneShellClient)
END_COM_MAP()

	void PopulateDataStore(CTreeItem& item)
	{
		CTreeItemData* pItemData = (CTreeItemData*)item.GetData();
		pItemData->PopulateSubKeys(item);
	}
	
	enum { IDD = IDD_DSVIEWER };


BEGIN_MSG_MAP(CDSViewer)

	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUP)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
	MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)


	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

	NOTIFY_ID_HANDLER(IDC_DSVIEWER_LIST, OnNotifyList)
	NOTIFY_ID_HANDLER(IDC_DSVIEWER_TREE, OnNotifyTree)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_wndList.Attach(GetDlgItem(IDC_DSVIEWER_LIST));
		::SendMessage(m_wndList.m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT);
		m_wndList.InsertColumn(0, _T("Name"), LVCFMT_LEFT, 100, -1);
		m_wndList.InsertColumn(1, _T("Data"), LVCFMT_LEFT, 25000, -1);


		m_wndTree.Attach(GetDlgItem(IDC_DSVIEWER_TREE));

		TV_ITEM tv_item;
		tv_item.cChildren = 1;
		tv_item.mask = TVIF_CHILDREN ;

		CTreeItem item = m_wndTree.InsertItem( _T("Lobby"), NULL, NULL);
		CTreeItemData* pItemData = new CTidLobby(LobbyDataStore(), GetUserId());
		item.SetData((DWORD)pItemData);
		tv_item.hItem = item;
		item.m_pTreeView->SetItem( &tv_item ) ;

		item = m_wndTree.InsertItem( _T("Config"), NULL, NULL);
		pItemData = new CTidIDataStore(DataStoreConfig(), NULL);
		item.SetData((DWORD)pItemData);
		tv_item.hItem = item;
		item.m_pTreeView->SetItem( &tv_item ) ;

		item = m_wndTree.InsertItem( _T("UI"), NULL, NULL);
		pItemData = new CTidIDataStore(DataStoreUI(), NULL);
		item.SetData((DWORD)pItemData);
		tv_item.hItem = item;
		item.m_pTreeView->SetItem( &tv_item ) ;

		item = m_wndTree.InsertItem( _T("Preferences"), NULL, NULL);
		pItemData = new CTidIDataStore(DataStorePreferences(), NULL);
		item.SetData((DWORD)pItemData);
		tv_item.hItem = item;
		item.m_pTreeView->SetItem( &tv_item ) ;

		// go through the resize code once to setup sizes
		CRect rcClient;
		GetClientRect(&rcClient);
		MoveWindow(&rcClient);

		return 1;  // Let the system set the focus
	}


	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CPaintDC dc(m_hWnd);

		// draw the vertical splitter splitter bar
		DrawEdge( dc, &m_rcVertical, EDGE_RAISED, BF_RECT|BF_MIDDLE);

		return 0;
	}

	LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return 1;		// we've handled the erase
	}

	void RecalcLayout()
	{
		CRect rcClient;
		GetClientRect(&rcClient);
		
		CRect rcList;
		CRect rcTree;

		// Tree
		rcTree = rcClient;
		rcTree.right = m_splitterVertical.SizeLeft();
		rcClient.left = rcTree.right;

		// vertical splitter
		m_rcVertical = rcClient;
		m_rcVertical.right = m_rcVertical.left + m_splitterVertical.GetSplitterWidth();
		rcClient.left = m_rcVertical.right;

		// List
		rcList = rcClient;

		// if the positions have changed, update 'em.
		if ( m_rcTree != rcTree )
		{
			m_wndTree.MoveWindow(&rcTree);
			m_rcTree = rcTree;
		}

		if ( m_rcList != rcList )
		{
			m_wndList.MoveWindow(&rcList);
			m_rcList = rcList;

			// give the data column all the extra room
			m_wndList.SetColumnWidth(1, m_rcList.Width() - m_wndList.GetColumnWidth(0) - 5 );
		}
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// when the window resizes, let the splitter determine how to divide the space vertically, then
		// recalculate our layout.

		CSize szClient(lParam);

		m_splitterVertical.Resize(szClient.cx);

		RecalcLayout();

		Invalidate(FALSE);
		return 0;
	}

	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CPoint ptMouse(lParam);

		if ( m_rcVertical.PtInRect(ptMouse) )
		{
			m_bSplitterActive = true;
			SetCapture();
			m_splitterVertical.Start(ptMouse);
		}

		return 0;
	}

	LRESULT OnLButtonUP(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{

		if ( m_bSplitterActive )
		{
			m_splitterVertical.End();
			m_bSplitterActive = false;
			ReleaseCapture();
//!! need to handle other cases which release capture. (WM_CANCELMODE, etc.)
		}
		
		return 0;
	}

	LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CPoint ptMouse(lParam);

		if ( m_bSplitterActive )
		{
			// ensure we erase the scroll bar where it currently is ...
			InvalidateRect(m_rcVertical, FALSE);	

			m_splitterVertical.Move(ptMouse);

			RecalcLayout();

			// ... and redraw it where it ends up.
			InvalidateRect(m_rcVertical, FALSE);
			UpdateWindow();
		}
		return 0;
	}

	LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CPoint pt;

		GetCursorPos( &pt );
		ScreenToClient( &pt );

		if ( m_rcVertical.PtInRect(pt) )
			SetCursor(LoadCursor(NULL, IDC_SIZEWE));
		else 
			bHandled = FALSE;
		
		return 0;
	}


	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ShowWindow(SW_HIDE);
		return 0;
	}

    LRESULT OnNotifyList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		NMLISTVIEW* pnmlv = (NMLISTVIEW*) pnmh;

		switch (pnmh->code)
		{
		case NM_CLICK:
			// set the current event parameters to the selected event

			if ( pnmlv->iItem < 0 )			
				break;
			break;
		default:
			break;
		}
		return 0;
	}

    LRESULT OnNotifyTree(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		NMTREEVIEW* pnmlv = (NMTREEVIEW*) pnmh;

		CTreeItemData* pItem = (CTreeItemData*)pnmlv->itemNew.lParam;

		switch (pnmh->code)
		{
		case TVN_SELCHANGED:
			// set the current event parameters to the selected event
			m_wndList.DeleteAllItems();
			if ( pnmlv->itemNew.lParam )
			{
				pItem->PopulateData(m_wndList);
			}
			break;

		case TVN_ITEMEXPANDING: {
				CTreeItem item(pnmlv->itemNew.hItem, &m_wndTree);
				int children = pItem->PopulateSubKeys(item);

				if ( !children )
				{
					TV_ITEM tv_item;
					tv_item.cChildren = 0;
					tv_item.mask = TVIF_CHILDREN ;
					tv_item.hItem = item;
					item.m_pTreeView->SetItem( &tv_item ) ;
				}
			}
			break;

		default:
			break;
		}
		return 0;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\eventspy.cpp ===
// EventSpy.cpp : Implementation of CEventSpy
#include "stdafx.h"
#include "EventSpy.h"

/////////////////////////////////////////////////////////////////////////////
// CEventSpy


STDMETHODIMP CEventSpySink::ProcessEvent(DWORD dwPriority, DWORD	dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2, void* pCookie )
{
	m_pEventSpy->ProcessEvent(dwPriority, dwEventId, dwGroupId, dwUserId, dwData1, dwData2, pCookie );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbydatastore\clobbydatastore.cpp ===
#include "CLobbyDataStore.h"
#include "KeyName.h"
#include "Hash.h"


ZONECALL CLobbyDataStore::CLobbyDataStore() :
	m_pIDataStoreManager( NULL ),
	m_pIDSLobby( NULL ),
	m_hashGroupId( ::HashDWORD, Group::CmpId, NULL, 16, 2 ),
	m_hashUserId( ::HashDWORD, User::CmpId, NULL, 16, 2 ),
	m_hashUserName( (CHash<User,TCHAR*>::PFHASHFUNC) ::HashUserName, User::CmpName, NULL, 16, 2 ),
	m_dwLocalUserId( ZONE_INVALIDUSER )
{
}


ZONECALL CLobbyDataStore::~CLobbyDataStore()
{
	// delete each group
	m_hashGroupId.RemoveAll( Group::Del, this );
	m_hashUserId.RemoveAll( User::Del, this );
	m_hashUserName.RemoveAll( User::Del, this );

	// release low-level data store
	if ( m_pIDSLobby )
	{
		m_pIDSLobby->Release();
		m_pIDSLobby = NULL;
	}
	if ( m_pIDataStoreManager )
	{
		m_pIDataStoreManager->Release();
		m_pIDataStoreManager = NULL;
	}
}


STDMETHODIMP CLobbyDataStore::Init( IDataStoreManager* pIDataStoreManager )
{
	if ( !pIDataStoreManager )
		return E_INVALIDARG;

	if ( m_pIDataStoreManager )
		return ZERR_ALREADYEXISTS;

	m_pIDataStoreManager = pIDataStoreManager;
	m_pIDataStoreManager->AddRef();
	HRESULT hr = m_pIDataStoreManager->Create( &m_pIDSLobby );
	if ( FAILED(hr) )
		return hr;

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::NewUser( DWORD dwUserId, TCHAR* szUserName )
{
	// validate user information
	if ( (dwUserId == ZONE_INVALIDUSER) || !szUserName || !szUserName[0] )
		return E_INVALIDARG;

	// validate object state
	if ( !m_pIDataStoreManager )
		return ZERR_NOTINIT;

	// already have the user?
	User* p = m_hashUserId.Get( dwUserId );
	if ( p )
		return ZERR_ALREADYEXISTS;

	// create a new user
	p = new (m_poolUser) User( dwUserId, szUserName );
	if ( !p )
		return E_OUTOFMEMORY;

	HRESULT hr = m_pIDataStoreManager->Create( &(p->m_pIDataStore) );
	if ( FAILED(hr) || !(p->m_pIDataStore) )
	{
		p->Release();
		return E_OUTOFMEMORY;
	}

	// add user to hashes
	if ( !m_hashUserId.Add( p->m_dwUserId, p ) )
	{
		p->Release();
		return E_OUTOFMEMORY;
	}

	if ( !m_hashUserName.Add( p->m_szUserName, p ) )
	{
		m_hashUserId.Delete( p->m_dwUserId );
		p->Release();
		return E_OUTOFMEMORY;
	}
	else
		p->AddRef();

	// add user name to data store
	hr = p->m_pIDataStore->SetString( key_Name, szUserName );
	if ( FAILED(hr) )
		return hr;

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::SetLocalUser( DWORD dwUserId )
{
	m_dwLocalUserId = dwUserId;
	return S_OK;
}


STDMETHODIMP CLobbyDataStore::DeleteUser( DWORD dwUserId )
{
	// find the user?
	User* p = m_hashUserId.Get( dwUserId );
	if ( !p )
		return ZERR_NOTFOUND;

	// remove user from groups
	for ( GroupUser* g = p->m_listGroups.PopHead(); g; g = p->m_listGroups.PopHead() )
	{
		if ( g->m_pUser )
		{
			ASSERT( p == g->m_pUser );
			g->m_pUser->Release();
			g->m_pUser = NULL;
		}
	}

	// remove user from hashes
	p = m_hashUserId.Delete( p->m_dwUserId );
	if ( p )
		p->Release();
	p = m_hashUserName.Delete( p->m_szUserName );
	if ( p )
		p->Release();

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::DeleteAllUsers()
{
	m_hashUserId.RemoveAll( User::Del, this );
	m_hashUserName.RemoveAll( User::Del, this );
	return S_OK;
}


STDMETHODIMP_(DWORD) CLobbyDataStore::GetUserId( TCHAR* szUserName )
{
	if ( !szUserName )
	{
		return m_dwLocalUserId;
	}
	else
	{
		User* p = m_hashUserName.Get( szUserName );
		if ( p )
			return p->m_dwUserId;
	}
	return ZONE_INVALIDUSER;
}



STDMETHODIMP CLobbyDataStore::NewGroup( DWORD dwGroupId )
{
	// validate parameters
	if ( dwGroupId == ZONE_INVALIDGROUP )
		return E_INVALIDARG;

	// validate object state
	if ( !m_pIDataStoreManager )
		return ZERR_NOTINIT;

	// group already exsists?
	Group* p = m_hashGroupId.Get( dwGroupId );
	if ( p )
		return ZERR_ALREADYEXISTS;

	// create a new group
	p = new (m_poolGroup) Group( dwGroupId );
	if ( !p )
		return E_OUTOFMEMORY;

	HRESULT hr = m_pIDataStoreManager->Create( &(p->m_pIDataStore) );
	if ( FAILED(hr) || !(p->m_pIDataStore) )
	{
		p->Release();
		return E_OUTOFMEMORY;
	}

	// add group to hash
	if ( !m_hashGroupId.Add( p->m_dwGroupId, p ) )
	{
		p->Release();
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::DeleteGroup( DWORD dwGroupId )
{
	// find group
	Group* p = m_hashGroupId.Get( dwGroupId );
	if ( !p )
		return ZERR_NOTFOUND;

	// remove group from users
	for ( GroupUser* g = p->m_listUsers.PopHead(); g; g = p->m_listUsers.PopHead() )
	{
		if ( g->m_pGroup )
		{
			ASSERT( p == g->m_pGroup );
			g->m_pGroup->Release();
			g->m_pGroup = NULL;
		}
	}

	// remove group from hash
	m_hashGroupId.Delete( p->m_dwGroupId );

	// release group
	p->Release();
	return S_OK;
}


STDMETHODIMP CLobbyDataStore::DeleteAllGroups()
{
	m_hashGroupId.RemoveAll( Group::Del, this );
	return S_OK;
}


STDMETHODIMP CLobbyDataStore::AddUserToGroup( DWORD dwUserId, DWORD dwGroupId )
{
	FindGroupUserContext context1;
	FindGroupUserContext context2;

	// validate object state
	if ( !m_pIDataStoreManager )
		return ZERR_NOTINIT;

	// find group
	Group* g = m_hashGroupId.Get( dwGroupId );
	if ( !g )
		return ZERR_NOTFOUND;

	// find user
	User* u = m_hashUserId.Get( dwUserId );
	if ( !u )
		return ZERR_NOTFOUND;

	// is group already in user's list?
	context1.m_pDS = this;
	context1.m_pGroup = g;
	context1.m_pUser = u;
	context1.m_pGroupUser = NULL;
	u->m_listGroups.ForEach( FindGroupUser, &context1 );

	// is user already in group's list?
	context2.m_pDS = this;
	context2.m_pGroup = g;
	context2.m_pUser = u;
	context2.m_pGroupUser = NULL;
	g->m_listUsers.ForEach( FindGroupUser, &context2 );

	// make sure user and group data is consistent?
	if ( context1.m_pGroupUser == context2.m_pGroupUser )
	{
		if ( context1.m_pGroupUser )
		{
			// user already in the group
			return ZERR_ALREADYEXISTS;
		}
		else
		{
			// create group mapping from user and group list
			GroupUser* gu = new (m_poolGroupUser) GroupUser( g, u );
			if ( !gu )
				return E_OUTOFMEMORY;

			HRESULT hr = m_pIDataStoreManager->Create( &(gu->m_pIDataStore) );
			if ( FAILED(hr) || !(gu->m_pIDataStore) )
			{
				gu->ClearUser();
				gu->ClearGroup();
				gu->Release();
				return E_OUTOFMEMORY;
			}

			// add GroupUser to user and group lists
			if ( u->m_listGroups.AddHead( gu ) && g->m_listUsers.AddHead( gu ) )
			{
				// increase reference count for new user and group pointers.
				// Note: New returns a GroupUser with a RefCnt of one so we
				// only need a single AddRef call.
				gu->AddRef();
			}
			else
			{
				// undo partial inserts
				gu->ClearUser();
				gu->ClearGroup();
				gu->Release();
				return E_OUTOFMEMORY;
			}

		}
	}
	else
	{
		ASSERT( !"Mismatch between user and group data." );
	}

	// update group's NumUsers
	if ( g->m_pIDataStore )
	{
		long lNumUsers = 0;
		g->m_pIDataStore->GetLong( key_NumUsers, &lNumUsers );
		g->m_pIDataStore->SetLong( key_NumUsers, ++lNumUsers );
	}

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::RemoveUserFromGroup( DWORD dwUserId, DWORD dwGroupId )
{
	FindGroupUserContext context1;
	FindGroupUserContext context2;

	// find group
	Group* g = m_hashGroupId.Get( dwGroupId );
	if ( !g )
		return ZERR_NOTFOUND;

	// find user
	User* u = m_hashUserId.Get( dwUserId );
	if ( !u )
		return ZERR_NOTFOUND;

	// is group in user's list?
	context1.m_pDS = this;
	context1.m_pGroup = g;
	context1.m_pUser = u;
	context1.m_pGroupUser = NULL;
	u->m_listGroups.ForEach( FindGroupUser, &context1 );

	// is user in group's list?
	context2.m_pDS = this;
	context2.m_pGroup = g;
	context2.m_pUser = u;
	context2.m_pGroupUser = NULL;
	g->m_listUsers.ForEach( FindGroupUser, &context2 );

	// make sure user and group data is consistent?
	if ( context1.m_pGroupUser == context2.m_pGroupUser )
	{
		if ( context1.m_pGroupUser )
		{
			GroupUser* gu = context1.m_pGroupUser;
			gu->ClearUser();
			gu->ClearGroup();
		}
		else
		{
			return ZERR_NOTFOUND;
		}
	}
	else
	{
		ASSERT( !"Mismatch between user and group data." );
	}

	// update group's NumUsers
	if ( g->m_pIDataStore )
	{
		long lNumUsers = 1;
		g->m_pIDataStore->GetLong( key_NumUsers, &lNumUsers );
		g->m_pIDataStore->SetLong( key_NumUsers, --lNumUsers );
	}

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::ResetGroup( DWORD dwGroupId )
{
	// find group
	Group* g = m_hashGroupId.Get( dwGroupId );
	if ( !g )
		return ZERR_NOTFOUND;

	// remove each user from group
	g->m_listUsers.ForEach( RemoveGroupUser, this );

	// wipe group's data store
	if ( g->m_pIDataStore )
	{
		g->m_pIDataStore->DeleteKey( NULL );
		g->m_pIDataStore->SetLong( key_NumUsers, 0 );
	}

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::ResetAllGroups()
{
	m_hashGroupId.ForEach( HashEnumClearGroup, this );
	return S_OK;
}


STDMETHODIMP CLobbyDataStore::GetDataStore(
		DWORD			dwGroupId,
		DWORD			dwUserId,
		IDataStore**	ppIDataStore )
{
	IDataStore* pIDS = NULL;

	// verify parameters
	if ((ppIDataStore == NULL ) || (dwGroupId == ZONE_INVALIDGROUP) || (dwUserId == ZONE_INVALIDUSER))
		return E_INVALIDARG;

	// get requested data store
	if ( dwGroupId == ZONE_NOGROUP && dwUserId == ZONE_NOUSER )
	{
		// lobby's data store
		pIDS = m_pIDSLobby;
	}
	else if ( dwGroupId != ZONE_NOGROUP && dwUserId == ZONE_NOUSER )
	{
		// group's data store
		Group *p = m_hashGroupId.Get( dwGroupId );
		if ( !p )
			return ZERR_NOTFOUND;
		pIDS = p->m_pIDataStore;
	}
	else if ( dwGroupId == ZONE_NOGROUP && dwUserId != ZONE_NOUSER)
	{
		// user's lobby data store
		User *p = m_hashUserId.Get( dwUserId );
		if ( !p )
			return ZERR_NOTFOUND;
		pIDS = p->m_pIDataStore;
	}
	else
	{
		// user's data store for specified group
		Group *g = m_hashGroupId.Get( dwGroupId ); 
		if ( !g )
			return ZERR_NOTFOUND;

		User *u = m_hashUserId.Get( dwUserId );
		if ( !u )
			return ZERR_NOTFOUND;

		FindGroupUserContext context;
		context.m_pDS = this;
		context.m_pGroup = g;
		context.m_pUser = u;
		context.m_pGroupUser = NULL;
		u->m_listGroups.ForEach( FindGroupUser, &context );
		if ( !context.m_pGroupUser )
			return ZERR_NOTFOUND;
		pIDS = context.m_pGroupUser->m_pIDataStore;
	}

	// return data store
	if ( pIDS )
	{
		*ppIDataStore = pIDS;
		pIDS->AddRef();
		return S_OK;
	}
	else
	{
		return ZERR_NOTFOUND;
	}
}


STDMETHODIMP_(bool) CLobbyDataStore::IsUserInLobby( DWORD dwUserId )
{
	// check parameters
	if ( (dwUserId == ZONE_INVALIDUSER) || (dwUserId == ZONE_NOUSER) )
		return false;

	// does user exist?
	User* u = m_hashUserId.Get( dwUserId );
	return u ? true : false;
}


STDMETHODIMP_(bool) CLobbyDataStore::IsGroupInLobby( DWORD dwGroupId )
{
	// check parameters
	if ( (dwGroupId == ZONE_INVALIDGROUP) || (dwGroupId == ZONE_NOGROUP) )
		return false;

	// does user exist?
	Group* g = m_hashGroupId.Get( dwGroupId );
	return g ? true : false;
}


STDMETHODIMP_(bool) CLobbyDataStore::IsUserInGroup( DWORD dwGroupId, DWORD dwUserId )
{
	// check parameters
	if (	(dwUserId == ZONE_INVALIDUSER)
		||	(dwUserId == ZONE_NOUSER)
		||	(dwGroupId == ZONE_INVALIDGROUP) )
		return false;

	// does user exist
	User* u = m_hashUserId.Get( dwUserId );
	if ( !u )
		return false;

	// only asking if user in lobby
	if ( dwGroupId == ZONE_NOGROUP )
		return true;

	// does group exist
	Group* g = m_hashGroupId.Get( dwGroupId );
	if ( !g )
		return false;

	// is user in group
	FindGroupUserContext context;
	context.m_pDS = this;
	context.m_pGroup = g;
	context.m_pUser = u;
	context.m_pGroupUser = NULL;
	u->m_listGroups.ForEach( FindGroupUser, &context );
	if ( context.m_pGroupUser )
		return true;

	// guess not
	return false;
}


STDMETHODIMP_(long) CLobbyDataStore::GetGroupUserCount( DWORD dwGroupId )
{
	// asking for lobby's number of users
	if ( dwGroupId == ZONE_NOGROUP )
		return m_hashUserId.Count();

	// asking for group's number of users
	Group* g = m_hashGroupId.Get( dwGroupId );
	if ( g )
		return g->m_listUsers.Count();
	else
		return 0;
}


STDMETHODIMP_(long) CLobbyDataStore::GetUserGroupCount( DWORD dwUserId )
{
	// asking for lobby's number of groups
	if ( dwUserId == ZONE_NOUSER )
		return m_hashGroupId.Count();

	// asking for user's number of groups
	User* u = m_hashUserId.Get( dwUserId );
	if ( u )
		return u->m_listGroups.Count();
	else
		return 0;
}


STDMETHODIMP CLobbyDataStore::EnumGroups(
		DWORD			dwUserId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext )
{
	// check parameters
	if ( (dwUserId == ZONE_INVALIDUSER) || !(pfCallback) )
		return E_INVALIDARG;

	if ( dwUserId == ZONE_NOUSER )
	{
		// enumerate groups in lobby
		EnumContext context;
		context.m_dwUserId = ZONE_NOUSER;
		context.m_dwGroupId = ZONE_NOGROUP;
		context.m_pfCallback = pfCallback;
		context.m_pContext = pContext;
		m_hashGroupId.ForEach( HashEnumGroupsCallback, &context );
	}
	else
	{
		// enumerate groups the user belongs too
		User* u = m_hashUserId.Get( dwUserId );
		if ( !u )
			return ZERR_NOTFOUND;

		EnumContext context;
		context.m_dwUserId = dwUserId;
		context.m_dwGroupId = ZONE_NOGROUP;
		context.m_pfCallback = pfCallback;
		context.m_pContext = pContext;
		u->m_listGroups.ForEach( ListEnumCallback, &context );
	}

	return S_OK;
}


STDMETHODIMP CLobbyDataStore::EnumUsers(
		DWORD			dwGroupId,
		PFENTITYENUM	pfCallback,
		LPVOID			pContext )
{
	// check parameters
	if ( (dwGroupId == ZONE_INVALIDGROUP) || !(pfCallback) )
		return E_INVALIDARG;

	if ( dwGroupId == ZONE_NOGROUP )
	{
		// enumerate users in lobby
		EnumContext context;
		context.m_dwUserId = ZONE_NOUSER;
		context.m_dwGroupId = ZONE_NOGROUP;
		context.m_pfCallback = pfCallback;
		context.m_pContext = pContext;
		m_hashUserId.ForEach( HashEnumUsersCallback, &context );
	}
	else
	{
		// enumerate users in group
		Group* g = m_hashGroupId.Get( dwGroupId );
		if ( !g )
			return ZERR_NOTFOUND;

		EnumContext context;
		context.m_dwUserId = ZONE_NOUSER;
		context.m_dwGroupId = dwGroupId;
		context.m_pfCallback = pfCallback;
		context.m_pContext = pContext;
		g->m_listUsers.ForEach( ListEnumCallback, &context );
	}
	return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// internal methods
///////////////////////////////////////////////////////////////////////////////

bool ZONECALL CLobbyDataStore::FindGroupUser( GroupUser* p, ListNodeHandle h, void* pContext )
{
	FindGroupUserContext* data = (FindGroupUserContext*) pContext;

	if ( (data->m_pGroup == p->m_pGroup) &&	(data->m_pUser == p->m_pUser) )
	{
		data->m_pGroupUser = p;
		return false;
	}

	return true;
}


bool ZONECALL CLobbyDataStore::RemoveGroupUser( GroupUser* p, ListNodeHandle h, void* pContext )
{
	CLobbyDataStore* pDS = (CLobbyDataStore*) pContext;

	// remove group from user
	p->ClearUser();

	// remove user from group
	if ( p->m_pGroup )
	{
		p->m_pGroup->m_listUsers.DeleteNode( h );
		p->m_pGroup->Release();
		p->m_pGroup = NULL;
		p->Release();
	}

	return true;
}


bool ZONECALL CLobbyDataStore::HashEnumClearGroup( Group* p, MTListNodeHandle h, void* pContext )
{
	p->m_listUsers.ForEach( RemoveGroupUser, pContext );
	p->m_pIDataStore->DeleteKey( NULL );
	p->m_pIDataStore->SetLong( key_NumUsers, 0 );
	return true;
}


bool ZONECALL CLobbyDataStore::HashEnumGroupsCallback( Group* p, MTListNodeHandle h, void* pContext )
{
	EnumContext* pCT = (EnumContext*) pContext;
	if ( pCT->m_pfCallback( p->m_dwGroupId, pCT->m_dwUserId ,pCT->m_pContext) == S_FALSE )
		return false;
	else
		return true;
}


bool ZONECALL CLobbyDataStore::HashEnumUsersCallback( User* p, MTListNodeHandle h, void* pContext )
{
	EnumContext* pCT = (EnumContext*) pContext;
	if ( pCT->m_pfCallback( pCT->m_dwGroupId, p->m_dwUserId ,pCT->m_pContext) == S_FALSE )
		return false;
	else
		return true;
}


bool ZONECALL CLobbyDataStore::ListEnumCallback( GroupUser* p, ListNodeHandle h, void* pContext )
{
	EnumContext* pCT = (EnumContext*) pContext;
	
	// skip invalid GroupUser object?
	if ( !p->m_pGroup || !p->m_pUser )
		return true;

	// pass info to user's callback
	if ( pCT->m_pfCallback( p->m_pGroup->m_dwGroupId, p->m_pUser->m_dwUserId ,pCT->m_pContext) == S_FALSE )
		return false;
	else
		return true;
}


HRESULT ZONECALL CLobbyDataStore::KeyEnumCallback( CONST TCHAR* szKey, CONST LPVARIANT	pVariant, DWORD dwSize, LPVOID pContext )
{
	KeyEnumContext* pCT = (KeyEnumContext*) pContext;
	return pCT->m_pfCallback( pCT->m_dwGroupId, pCT->m_dwUserId, szKey, pVariant, dwSize, pCT->m_pContext );
}


///////////////////////////////////////////////////////////////////////////////
// internal User class
///////////////////////////////////////////////////////////////////////////////

ZONECALL CLobbyDataStore::User::User( DWORD dwUserId, TCHAR* szUserName )
{
	ASSERT( dwUserId != ZONE_NOUSER );
	ASSERT( dwUserId != ZONE_INVALIDUSER );
	ASSERT( szUserName && szUserName[0] );

	m_nRefCnt = 1;
	m_pIDataStore = NULL;
	m_dwUserId = dwUserId;
	lstrcpyn( m_szUserName, szUserName, NUMELEMENTS(m_szUserName) );
}


ZONECALL CLobbyDataStore::User::~User()
{
	ASSERT( m_nRefCnt == 0 );
	ASSERT( m_listGroups.IsEmpty() );

	if ( m_pIDataStore )
	{
		m_pIDataStore->Release();
		m_pIDataStore = NULL;
	}
}


ULONG ZONECALL CLobbyDataStore::User::AddRef()
{
	return ++m_nRefCnt;
}


ULONG ZONECALL CLobbyDataStore::User::Release()
{
	if ( --m_nRefCnt == 0 )
	{
		delete this;
		return 0;
	}
	return m_nRefCnt;
}


void ZONECALL CLobbyDataStore::User::Del( User* pUser, LPVOID pContext )
{
	// valid arguments?
	if ( pUser == NULL )
		return;

	// remove group from users
	for ( GroupUser* g = pUser->m_listGroups.PopHead(); g; g = pUser->m_listGroups.PopHead() )
	{
		if ( g->m_pUser )
		{
			ASSERT( pUser == g->m_pUser );
			g->m_pUser->Release();
			g->m_pUser = NULL;
			g->Release();
		}
	}

	// release hash table reference
	pUser->Release();
}


///////////////////////////////////////////////////////////////////////////////
// internal Group class
///////////////////////////////////////////////////////////////////////////////

ZONECALL CLobbyDataStore::Group::Group( DWORD dwGroupId )
{
	ASSERT( dwGroupId != ZONE_INVALIDGROUP );

	m_nRefCnt = 1;
	m_pIDataStore = NULL;
	m_dwGroupId = dwGroupId;
}


ZONECALL CLobbyDataStore::Group::~Group()
{
	ASSERT( m_nRefCnt == 0 );
	ASSERT( m_listUsers.IsEmpty() );

	if ( m_pIDataStore )
	{
		m_pIDataStore->Release();
		m_pIDataStore = NULL;
	}
}


ULONG ZONECALL CLobbyDataStore::Group::AddRef()
{
	return ++m_nRefCnt;
}


ULONG ZONECALL CLobbyDataStore::Group::Release()
{
	if ( --m_nRefCnt == 0 )
	{
		delete this;
		return 0;
	}
	return m_nRefCnt;
}

void ZONECALL CLobbyDataStore::Group::Del( Group* pGroup, LPVOID pContext )
{
	// valid arguments?
	if ( pGroup == NULL )
		return;

	// remove group from users
	for ( GroupUser* g = pGroup->m_listUsers.PopHead(); g; g = pGroup->m_listUsers.PopHead() )
	{
		if ( g->m_pGroup )
		{
			ASSERT( pGroup == g->m_pGroup );
			g->m_pGroup->Release();
			g->m_pGroup = NULL;
			g->Release();
		}
	}

	// release hash table reference
	pGroup->Release();
}

///////////////////////////////////////////////////////////////////////////////
// internal GroupUser class
///////////////////////////////////////////////////////////////////////////////

ZONECALL CLobbyDataStore::GroupUser::GroupUser( Group* pGroup, User* pUser )
{
	m_nRefCnt = 1;
	m_pIDataStore = NULL;

	m_pGroup = pGroup;
	if ( m_pGroup )
		m_pGroup->AddRef();

	m_pUser = pUser;
	if ( m_pUser )
		m_pUser->AddRef();

}


ZONECALL CLobbyDataStore::GroupUser::~GroupUser()
{
	ASSERT( m_nRefCnt == 0 );
	ASSERT( m_pGroup == NULL );
	ASSERT( m_pUser == NULL );

	if ( m_pIDataStore )
	{
		m_pIDataStore->Release();
		m_pIDataStore = NULL;
	}
}


ULONG ZONECALL CLobbyDataStore::GroupUser::AddRef()
{
	return ++m_nRefCnt;
}


ULONG ZONECALL CLobbyDataStore::GroupUser::Release()
{
	if ( --m_nRefCnt == 0 )
	{
		delete this;
		return 0;
	}
	return m_nRefCnt;
}


void ZONECALL CLobbyDataStore::GroupUser::ClearUser()
{
	if ( m_pUser )
	{
		// remove reference to user
		User* u = m_pUser;
		m_pUser->Release();
		m_pUser = NULL;

		// remove GroupUser node from user's list
		if ( u->m_listGroups.Remove( this ) )
			this->Release();
	}
}


void ZONECALL CLobbyDataStore::GroupUser::ClearGroup()
{
	if ( m_pGroup )
	{
		// remove reference to user
		Group* g = m_pGroup;
		m_pGroup->Release();
		m_pGroup = NULL;

		// remove GroupUser node from group's list
		if ( g->m_listUsers.Remove( this ) )
			this->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\lobbywindow.cpp ===
// LobbyWindow.cpp : Implementation of CLobbyWindow

#include "stdafx.h"
#include "ClientIDL.h"
#include "LobbyWindow.h"

/////////////////////////////////////////////////////////////////////////////
// CLobbyWindow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\eventspy.h ===
// EventSpy.h : Declaration of the CEventSpy

#pragma once

#include "ZoneResource.h"       // main symbols
#include "ZoneString.h"       


#include "..\ZoneClient\Resource.h"

#include <atlctrls.h>
#include <eventqueue.h>

#include <ZoneEvent.h>


// forward declarations
class CEventSpy;

/////////////////////////////////////////////////////////////////////////////
// CEventSpySink

// This class exists only to be a COM object sink for IEventClient

class ATL_NO_VTABLE CEventSpySink : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IEventClient
{

	CEventSpy* m_pEventSpy;
public:
	CEventSpySink()
	{
	}

	void SetEventSpy(CEventSpy* pEventSpy) { m_pEventSpy = pEventSpy; }

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEventSpySink)
	COM_INTERFACE_ENTRY(IEventClient)
END_COM_MAP()

// IEventClient
	STDMETHOD(ProcessEvent)(DWORD dwPriority, DWORD	dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2, void* pCookie );

public:
};


/////////////////////////////////////////////////////////////////////////////
// CEventSpy
class CEventSpy : 
	public CAxDialogImpl<CEventSpy>
{

	CComPtr<IEventQueue> m_pEventQueue;
	CComPtr<IEventClient> m_pEventClient;

	CStatic			m_staticTotalEvents;
	CListViewCtrl	m_lvList;

	CComboBox		m_comboPriority;
	CComboBox		m_comboEvent;
	CComboBox		m_comboGroup;
	CComboBox		m_comboUser;


	ULONG m_TotalEvents;
public:
	CEventSpy() :
		m_TotalEvents(0)
	{
	}

	~CEventSpy()
	{
		if ( m_pEventQueue )
		{
			m_pEventQueue->UnregisterClient(m_pEventClient, NULL);
		}
	}

	LPCSTR NameFromId(DWORD id) 
	{	
		LPCSTR pName;
		static char buf[20];	// what are the chances?

		pName = GetZoneEventName(ZoneEvents, id);

		if ( !pName )
		{
			wsprintfA( buf, "%d", id);
			pName = buf; 
		}
		return pName;
	}

	DWORD IdFromName(LPCSTR name) 
	{	
		DWORD id;

		id = GetZoneEventId(ZoneEvents, name);

		if ( id == 0 )
		{
			id = atoi(name);
		}
		return id;
	}

	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		HWND hwnd = CAxDialogImpl<CEventSpy>::Create(hWndParent,dwInitParam);
		USES_CONVERSION;

		if ( hwnd )
		{
			m_staticTotalEvents.Attach(GetDlgItem(IDSPY_EVENTS));

			m_lvList.Attach(GetDlgItem(IDSPY_LIST));
		    ::SendMessage(m_lvList.m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT);
			m_lvList.InsertColumn(0, _T("Priority"), LVCFMT_CENTER, 45, -1);
			m_lvList.InsertColumn(1, _T("Event"), LVCFMT_LEFT, 250, -1);
			m_lvList.InsertColumn(2, _T("Group"), LVCFMT_LEFT, 45, -1);
			m_lvList.InsertColumn(3, _T("User"), LVCFMT_LEFT, 100, -1);
			m_lvList.InsertColumn(4, _T("Data1"), LVCFMT_LEFT, 100, -1);
			m_lvList.InsertColumn(5, _T("Data2"), LVCFMT_LEFT, 100, -1);


			m_comboPriority.Attach(GetDlgItem(IDSPY_PRIORITY));
			m_comboEvent.Attach(GetDlgItem(IDSPY_EVENT));
			m_comboGroup.Attach(GetDlgItem(IDSPY_GROUP));
			m_comboUser.Attach(GetDlgItem(IDSPY_USER));

			m_comboPriority.AddString(_T("0"));
			m_comboPriority.AddString(_T("1"));
			m_comboPriority.AddString(_T("2"));
			m_comboPriority.AddString(_T("3"));

			EventEntry* pEntry = ZoneEvents;
			while ( pEntry->name )
				m_comboEvent.AddString(A2T(pEntry++->name));

			m_comboGroup.AddString(_T("0"));
			m_comboGroup.AddString(_T("1"));
		}

		return hwnd;
	}
	
	void SetEventQueue(IEventQueue* pEventQueue)
	{
		m_pEventQueue = pEventQueue;

		CComObject<CEventSpySink>* pSink;
		CComObject<CEventSpySink>::CreateInstance(&pSink);
		pSink->SetEventSpy(this);

		pSink->QueryInterface(&m_pEventClient);

		m_pEventQueue->RegisterClient(m_pEventClient, NULL);
	}

	enum { IDD = IDD_EVENTSPY };

	STDMETHOD(ProcessEvent)(DWORD dwPriority, DWORD	dwEventId, DWORD dwGroupId, DWORD dwUserId, DWORD dwData1, DWORD dwData2, void* pCookie )
	{
		TCHAR buf[20];
		USES_CONVERSION;

		// update total events
		m_TotalEvents++;

        // bail if there's no window
        if(!::IsWindow(m_hWnd))
            return S_FALSE;

		wsprintf(buf, _T("%d"), m_TotalEvents);
		m_staticTotalEvents.SetWindowText(buf);

		// add bits of the event to the list
		// if something is unique, add it to the drop down too

		wsprintf(buf, _T("%d"), dwPriority);
		m_lvList.InsertItem(0, buf);

		LPSTR pStr = (LPSTR)NameFromId(dwEventId);
		m_lvList.SetItemText(0, 1, A2T(pStr) );
		if ( m_comboEvent.FindStringExact(0,A2T(pStr)) == CB_ERR )
			m_comboEvent.AddString(A2T(pStr));

		wsprintf(buf, _T("%d"), dwGroupId);
		m_lvList.SetItemText(0, 2, buf);
		if ( m_comboGroup.FindStringExact(0,buf) == CB_ERR )
			m_comboGroup.AddString(buf);

		wsprintf(buf, _T("0x%x"), dwUserId);
		m_lvList.SetItemText(0, 3, buf);
		if ( m_comboUser.FindStringExact(0,buf) == CB_ERR )
			m_comboUser.AddString(buf);

		wsprintf(buf, _T("0x%x"), dwData1);
		m_lvList.SetItemText(0, 4, buf);
		if ( m_comboUser.FindStringExact(0,buf) == CB_ERR )
			m_comboUser.AddString(buf);

		wsprintf(buf, _T("0x%x"), dwData2);
		m_lvList.SetItemText(0, 5, buf);
		if ( m_comboUser.FindStringExact(0,buf) == CB_ERR )
			m_comboUser.AddString(buf);

		return S_OK;
	}


BEGIN_MSG_MAP(CEventSpy)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDSPY_FIRE, OnFire)
	COMMAND_ID_HANDLER(IDSPY_CLEAR, OnClear)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	NOTIFY_ID_HANDLER(IDSPY_LIST, OnNotifyList)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return 1;  // Let the system set the focus
	}

	LRESULT OnClear(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		m_lvList.DeleteAllItems();
		return 0;
	}

	LRESULT OnFire(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{

		DWORD dwPriority;
		DWORD dwEventId;
		DWORD dwGroupId;
		DWORD dwUserId;
		USES_CONVERSION;

		TCHAR  buf[40];
		m_comboPriority.GetWindowText(buf,sizeof(buf));
		/*dwPriority = */sscanf(T2A(buf), "%d", &dwPriority);

		m_comboEvent.GetWindowText(buf,sizeof(buf));
		dwEventId = IdFromName(T2A(buf));

		m_comboGroup.GetWindowText(buf,sizeof(buf));
		dwGroupId = zatol(buf);

		m_comboUser.GetWindowText(buf,sizeof(buf));
		/*dwUserId =*/ sscanf(T2A(buf), "0x%x", &dwUserId);

		m_pEventQueue->PostEvent(dwPriority, dwEventId, dwGroupId, dwUserId, NULL, 0);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ShowWindow(SW_HIDE);
		return 0;
	}

    LRESULT OnNotifyList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		NMLISTVIEW* pnmlv = (NMLISTVIEW*) pnmh;

		switch (pnmh->code)
		{
		case NM_CLICK:
			// set the current event parameters to the selected event

			if ( pnmlv->iItem < 0 )			
				break;

			TCHAR buf[60];

			m_lvList.GetItemText( pnmlv->iItem, 0, buf, sizeof(buf));
			m_comboPriority.SetWindowText(buf);
			m_lvList.GetItemText( pnmlv->iItem, 1, buf, sizeof(buf));
			m_comboEvent.SetWindowText(buf);
			m_lvList.GetItemText( pnmlv->iItem, 2, buf, sizeof(buf));
			m_comboGroup.SetWindowText(buf);
			m_lvList.GetItemText( pnmlv->iItem, 3, buf, sizeof(buf));
			m_comboUser.SetWindowText(buf);
			break;
		default:
			break;
		}
		return 0;
	}
};


#if 0
//!!
#undef INIT_EVENTS
#undef BEGIN_ZONE_EVENTS
#undef ZONE_CLASS
#undef ZONE_EVENT
#undef END_ZONE_EVENTS

//	#define BEGIN_ZONE_EVENTS(n)	static EventEntry n[] = {
//	#define ZONE_CLASS(c)			{ MAKE_EVENT(c,0), "RESERVED_"#c },
//	#define ZONE_EVENT(c,n,v)		{ MAKE_EVENT(c,v), #n },
//	#define END_ZONE_EVENTS()		{ 0, NULL} };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millcommand\cmillcommand.h ===
//
// CMillCommand.h
//
// Internal header for millennium command manager
//

#ifndef _CMILLCOMMAND_H_
#define _CMILLCOMMAND_H_

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ClientImpl.h"
#include "ZoneShellEx.h"
#include "MillCommand.h"
#include "accessibilitymanager.h"

class ATL_NO_VTABLE CMillCommand :
	public ICommandHandler,
	public IZoneShellClientImpl<CMillCommand>,
	public IEventClientImpl<CMillCommand>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMillCommand, &CLSID_MillCommand>
{
public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMillCommand)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(ICommandHandler)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
        EVENT_HANDLER( EVENT_LOBBY_BOOTSTRAP, OnBootstrap );
		EVENT_HANDLER( EVENT_LOBBY_PREFERENCES_LOADED, OnPreferencesLoaded );
        EVENT_HANDLER( EVENT_UI_UPSELL_UP, OnUpsellUp );
        EVENT_HANDLER( EVENT_UI_UPSELL_DOWN, OnUpsellDown );
        EVENT_HANDLER( EVENT_GAME_LAUNCHING, OnGameLaunching );
        EVENT_HANDLER( EVENT_GAME_TERMINATED, OnGameTerminated );
	END_EVENT_MAP()

// event handlers
	void OnBootstrap( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnPreferencesLoaded( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnUpsellUp( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnUpsellDown( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnGameLaunching( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);
	void OnGameTerminated( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId);

// command handlers
    void OnExit();
    void OnHelp();
	void OnLink( DWORD dwLinkId );
    void OnSkill( long eSkillLevel );
    void OnChat();
    void OnSound();
    void OnScore();
    void OnFindNew();
    void OnAbout();
    void OnShowFocus();

// IZoneShellClient
public:
    STDMETHOD(Init)(IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey);
	STDMETHOD(Close)();

// ICommandHandler
public:
	STDMETHOD(Command)(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled);

// Utilities
    void UpdatePreferences(bool fSkill = true, bool fChat = true, bool fSound = true);


// member variables
protected:
	CComPtr<IZoneFrameWindow> m_pIWindow;
    CComPtr<IAccessibility> m_pIAcc;
};

#endif // _CMILLCOMMAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millcommand\cmillcommand.cpp ===
#include <ZoneResource.h>
#include <BasicATL.h>
#include <ATLFrame.h>
#include "CMillCommand.h"
#include "protocol.h"

// zone proxy commands
#include "OpName.h"


///////////////////////////////////////////////////////////////////////////////
// Interface methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMillCommand::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CMillCommand>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

    // hook up to the window specified in object.txt
	GUID srvid;
    TCHAR szFrame[ZONE_MAXSTRING];
    DWORD cb = NUMELEMENTS(szFrame);
    hr = DataStoreConfig()->GetString(GetDataStoreKey() + key_FrameWindow, szFrame, &cb);
    if ( FAILED(hr) )
        return hr;
	StringToGuid( szFrame, &srvid );
    if ( srvid == GUID_NULL )
        return E_FAIL;
    hr = ZoneShell()->QueryService(srvid, IID_IZoneFrameWindow, (void**) &m_pIWindow);
    if(FAILED(hr))
        return hr;

    // register with the shell as the command handler
    ZoneShell()->SetCommandHandler(this);

    // tell accessibility about the menu shortcuts
    hr = ZoneShell()->QueryService(SRVID_AccessibilityManager, IID_IAccessibility, (void**) &m_pIAcc);
    if(FAILED(hr))
        return hr;
    m_pIAcc->InitAcc(NULL, 100);   // we don't care about callbacks and don't implement IAccessibleControl

	return S_OK;
}


STDMETHODIMP CMillCommand::Close()
{
    // tell the shell that I'm going away
    ZoneShell()->ReleaseReferences((ICommandHandler *) this);

    m_pIAcc.Release();
	m_pIWindow.Release();
	return IZoneShellClientImpl<CMillCommand>::Close();
}


STDMETHODIMP CMillCommand::Command(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled)
{
	bHandled = true;

	switch(wID)
	{
        case ID_GAME_EXIT_APP:
            OnExit();
            break;

        case ID_GAME_FINDNEWOPPONENT:
            OnFindNew();
            break;

        case ID_GAME_SKILLLEVEL_BEGINNER:
            OnSkill( KeySkillLevelBeginner );
            break;

        case ID_GAME_SKILLLEVEL_INTERMEDIATE:
            OnSkill( KeySkillLevelIntermediate );
            break;

        case ID_GAME_SKILLLEVEL_EXPERT:
            OnSkill( KeySkillLevelExpert );
            break;

        case ID_GAME_TURNCHATON:
            OnChat();
            break;

        case ID_GAME_SOUND:
            OnSound();
            break;

        case ID_GAME_SCORE:
            OnScore();
            break;

        case ID_HELP_HELPTOPICS:
		    OnHelp();
		    break;

	    case ID_HELP_GAMEONTHEWEB:
		    OnLink( ZONE_ContextOfMenu );
		    break;

        case ID_HELP_ABOUTGAME:
            OnAbout();
            break;

        case ID_HOTKEY_SHOWFOCUS:
            OnShowFocus();
            break;

	    default:
		    bHandled = false;
		    break;
	}
	
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Handlers
///////////////////////////////////////////////////////////////////////////////

void CMillCommand::OnBootstrap( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    // put in our command shortcuts
    // sine we only have two, with no use of letters, i'm not using an acelerator table
//    HACCEL hAccel = ResourceManager()->LoadAccelerators(MAKEINTRESOURCE(IDR_COMMAND_ACCEL));

    ACCITEM rgItems[2];
    long i;
    for(i = 0; i < NUMELEMENTS(rgItems); i++)
    {
        CopyACC(rgItems[i], ZACCESS_DefaultACCITEM);

        rgItems[i].fVisible = false;
        rgItems[i].eAccelBehavior = ZACCESS_Ignore;  // the accessibility manager need not do anything
    }

    rgItems[0].oAccel.cmd = ID_HELP_HELPTOPICS;
    rgItems[0].oAccel.key = VK_F1;
    rgItems[0].oAccel.fVirt = FVIRTKEY;

    rgItems[1].oAccel.cmd = ID_HOTKEY_SHOWFOCUS;
    rgItems[1].oAccel.key = VK_INSERT;
    rgItems[1].oAccel.fVirt = FVIRTKEY;

    m_pIAcc->PushItemlist(rgItems, NUMELEMENTS(rgItems));
}


void CMillCommand::OnPreferencesLoaded( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    UpdatePreferences();
}


void CMillCommand::OnUpsellUp( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    m_pIWindow->ZEnable(ID_HELP_ABOUTGAME, false);
}


void CMillCommand::OnUpsellDown( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    m_pIWindow->ZEnable(ID_HELP_ABOUTGAME, true);
}


void CMillCommand::OnGameLaunching( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    m_pIWindow->ZEnable(ID_GAME_SCORE, true);
}


void CMillCommand::OnGameTerminated( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    m_pIWindow->ZEnable(ID_GAME_SCORE, false);
}


void CMillCommand::OnExit()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_MENU_EXIT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}


void CMillCommand::OnHelp()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LAUNCH_HELP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}


void CMillCommand::OnLink( DWORD dwLinkID )
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LAUNCH_URL, ZONE_NOGROUP, ZONE_NOUSER, dwLinkID, 0);
}


void CMillCommand::OnSkill( long eSkillLevel )
{
	const TCHAR* arKeys[] = { key_Lobby, key_SkillLevel };
    DataStorePreferences()->SetLong( arKeys, 2, eSkillLevel );

    long fSeenWarning = 0;
    arKeys[1] = key_SeenSkillLevelWarning;
    DataStorePreferences()->GetLong(arKeys, 2, &fSeenWarning);

    if(!fSeenWarning)
    {
        DataStorePreferences()->SetLong(arKeys, 2, 1);

        TCHAR sz[ZONE_MAXSTRING];
        TCHAR szFormat[ZONE_MAXSTRING];
        TCHAR szGame[ZONE_MAXSTRING];
        TCHAR szSkill[ZONE_MAXSTRING];

        if(ResourceManager()->LoadString(IDS_SKILLLEVEL_WARNING, szFormat, NUMELEMENTS(szFormat)))
            if(ResourceManager()->LoadString(IDS_GAME_NAME, szGame, NUMELEMENTS(szGame)))
                if(ResourceManager()->LoadString(eSkillLevel == KeySkillLevelExpert ? IDS_LEVEL_EXPERT :
                    eSkillLevel == KeySkillLevelIntermediate ? IDS_LEVEL_INTERMEDIATE : IDS_LEVEL_BEGINNER, szSkill, NUMELEMENTS(szSkill)))
                    if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szGame, szSkill))
                        ZoneShell()->AlertMessage(NULL, sz, MAKEINTRESOURCE(IDS_SKILLLEVEL_WARN_TTL), AlertButtonOK);
    }

    UpdatePreferences();
}


void CMillCommand::OnChat()
{
    m_pIWindow->ZToggleCheck(ID_GAME_TURNCHATON);

	const TCHAR* arKeys[] = { key_Lobby, key_ChatOnAtStartup };
    long fChatOn = (m_pIWindow->ZGetState(ID_GAME_TURNCHATON) & UPDUI_CHECKED ? 1 : 0);
    DataStorePreferences()->SetLong( arKeys, 2, fChatOn );
}

void CMillCommand::OnSound()
{
    m_pIWindow->ZToggleCheck(ID_GAME_SOUND);

	const TCHAR* arKeys[] = { key_Lobby, key_PrefSound };
    long lSound = (m_pIWindow->ZGetState(ID_GAME_SOUND) & UPDUI_CHECKED ? 1 : 0);
    DataStorePreferences()->SetLong( arKeys, 2, lSound );
}

void CMillCommand::OnScore()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_MENU_SHOWSCORE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}

void CMillCommand::OnFindNew()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_MENU_NEWOPP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}

void CMillCommand::OnAbout()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_ABOUT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}

void CMillCommand::OnShowFocus()
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_SHOWFOCUS, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}



///////////////////////////////////////////////////////////////////////////////
// Utilities
///////////////////////////////////////////////////////////////////////////////

void CMillCommand::UpdatePreferences(bool fSkill, bool fChat, bool fSound)
{
	// reset menu and toolbar to match user's preferences
	const TCHAR* arKeys[] = { key_Lobby, key_SkillLevel };
	IDataStore* pIDS = DataStorePreferences();
	if ( !pIDS )
		return;

	// update skill level
    if(fSkill)
    {
	    long lSkillLevel = KeySkillLevelBeginner;
	    pIDS->GetLong( arKeys, 2, &lSkillLevel );
        m_pIWindow->ZSetCheck(ID_GAME_SKILLLEVEL_BEGINNER, lSkillLevel == KeySkillLevelBeginner ? 1 : 0);
	    m_pIWindow->ZSetCheck(ID_GAME_SKILLLEVEL_INTERMEDIATE, lSkillLevel == KeySkillLevelIntermediate ? 1 : 0);
	    m_pIWindow->ZSetCheck(ID_GAME_SKILLLEVEL_EXPERT, lSkillLevel == KeySkillLevelExpert ? 1 : 0);
    }

    // update chat on
    if(fChat)
    {
	    long lChatOn = DEFAULT_ChatOnAtStartup;
        arKeys[1] = key_ChatOnAtStartup;
	    pIDS->GetLong( arKeys, 2, &lChatOn );
        m_pIWindow->ZSetCheck(ID_GAME_TURNCHATON, lChatOn ? 1 : 0);
    }

    if(fSound)
    {
	    long lSound = DEFAULT_PrefSound;
        arKeys[1] = key_PrefSound;
	    pIDS->GetLong( arKeys, 2, &lSound );
        m_pIWindow->ZSetCheck(ID_GAME_SOUND, lSound ? 1 : 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millcore\cmillcore.h ===
#include "ZoneDef.h"
#include "ZoneError.h"
#include "LobbyDataStore.h"
#include "ClientImpl.h"
#include "ZoneShell.h"
#include "EventQueue.h"
#include "Queue.h"
#include "MillCore.h"
#include "commonmsg.h"
#include "Conduit.h"


class ATL_NO_VTABLE CMillCore :
    public IConnectee,
	public IZoneShellClientImpl<CMillCore>,
	public IEventClient,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMillCore, &CLSID_MillCore>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMillCore)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
	END_COM_MAP()


// CEventQueue
public:
	ZONECALL CMillCore();
	ZONECALL ~CMillCore();

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

// IConnectee
public:
    STDMETHOD(Connected)(DWORD dwChannel, DWORD evSend, DWORD evReceive, LPVOID pCookie, DWORD dweReason);
    STDMETHOD(ConnectFailed)(LPVOID pCookie, DWORD dweReason);
    STDMETHOD(Disconnected)(DWORD dwChannel, DWORD dweReason);

// IEventClient
public:
	STDMETHOD(ProcessEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2,
		void*	pCookie );

// internals
private:
	// network functions
	void NetworkSend(DWORD dwType, char* pBuff, DWORD cbBuff, bool fHighPriority = false);
	void ProcessMessage( EventNetwork* pEvent, DWORD dwLength );

	// dynamic chat functions
//	void InviteToChat( TCHAR* szWho, TCHAR* szMsg );
//	void InviteToChat( IDataStore* pIDS );

	// send lobby messages
	void HandleStartGame( BYTE* pBuffer, DWORD dwLen );
	void HandleStatus( BYTE* pBuffer, DWORD dwLen );
	void HandleDisconnect( BYTE* pBuffer, DWORD dwLen );
	void HandleServerStatus( BYTE* pBuffer, DWORD dwLen );
    void HandleUserIDResponse( BYTE* pBuffer, DWORD dwLen );
    void HandleChatSwitch(BYTE* pBuffer, DWORD dwLen);
    void HandlePlayerReplaced(BYTE* pBuffer, DWORD dwLen);

	void SendFirstMessage();
    void SendUserStatusChange();
	/*
	void SendChat( DWORD dwUserId, TCHAR* szText, DWORD dwLen );
	void SendLeaveRequest( DWORD dwGroupId, DWORD dwUserId );
	void SendBootRequest( DWORD dwGroupId, DWORD dwUserId, DWORD dwBootId );
	void SendUserStatusChange( DWORD dwGroupId, DWORD dwUserId, IDataStore* pIDS );
	
	// handle lobby messages
	void HandleDisconnect( BYTE* pBuffer, DWORD dwLen );
	void HandleAccessedMessage( BYTE* pBuffer, DWORD dwLen );
	void HandleRoomInfoMessage( BYTE* pBuffer, DWORD dwLen );
	void HandleTalkResponse( BYTE* pBuffer, DWORD dwLen );
	void HandleTalkResponseID( BYTE* pBuffer, DWORD dwLen );
	void HandleEnter( BYTE* pBuffer, DWORD dwLen );
	void HandleLeave( BYTE* pBuffer, DWORD dwLen );
	void HandleSeatAction( BYTE* pBuffer, DWORD dwLen );
	void HandleStartGame( BYTE* pBuffer, DWORD dwLen );
//	void HandleLaunchPadMessage( BYTE* pBuffer, DWORD dwLen );
	void HandleSystemAlert( BYTE* pBuffer, DWORD dwLen );
	void HandleSystemAlertEx( BYTE* pBuffer, DWORD dwLen );
	void HandleNewHost( BYTE* pBuffer, DWORD dwLen );

	// theater chat
	void HandleTheaterList( BYTE* pBuffer, DWORD dwLen );
	void HandleTheaterStateChange( BYTE* pBuffer, DWORD dwLen );

	// handle launch pad messages
//	void HandleLaunchPadTalk( IDataStore* pGroupDS, DWORD dwGroupId, BYTE* pBuffer, DWORD dwLen );
//	void HandleLaunchPadNewHost( IDataStore* pGroupDS, DWORD dwGroupId, BYTE* pBuffer, DWORD dwLen );

	// send launch pad messages
	void SendHostRequest( DWORD dwUserId );
	void SendJoinRequest( DWORD dwGroupId, DWORD dwUserId );
//	void SendLaunchPadMsg( DWORD dwGroupId, DWORD dwType, BYTE* pMsg, DWORD dwLen );
//	void SendLaunchPadChat( DWORD dwGroupId, DWORD dwUserId, TCHAR* szText, DWORD dwLen );
//	void SendLaunchPadEnter( DWORD dwGroupId, DWORD dwUserId );
//	void SendLaunchPadLaunch( DWORD dwGroupId, DWORD dwUserId );
//	void SendLaunchPadLaunchStatus( DWORD dwGroupId, DWORD dwUserId, bool bSuccess );

	// helper functions
	void ZONECALL FillInSeatRequest( DWORD dwUserId, BYTE* pBuffer );

	// LobbyDataStore callbacks
	//
	struct GroupFromGameIdContext
	{
		DWORD				m_dwGameId;
		DWORD				m_dwGroupId;
		ILobbyDataStore*	m_pILobbyDataStore;
	};

	static HRESULT ZONECALL EnumRemoveUser( DWORD dwGroupId, DWORD	dwUserId, LPVOID pContext );
	static HRESULT ZONECALL FindGroupFromGameId( DWORD dwGroupId, DWORD	dwUserId, LPVOID pContext );

	// lobby helpers
	//
	bool ZONECALL IsUserLocalAndInGroup( DWORD dwGroupId, DWORD dwUserId );
	bool ZONECALL IsUserHost( DWORD dwGroupId, DWORD dwUserId );
	bool ZONECALL GetUserName( DWORD dwUserId, char* szName, DWORD* pcbName );
	*/

    // utils
    //
    BOOL InitClientConfig(ZRoomMsgClientConfig * pConfig);

	// class member variables
	//
    bool    m_fLastChatSent;

    bool    m_fConnected;
	bool	m_bRoomInitialized;
	bool	m_bPreferencesLoaded;
    bool    m_bGameStarted;
    bool    m_fIntentionalDisconnect;
	DWORD	m_dwChannel;

    DWORD m_evSend;
    DWORD m_evReceive;

	CComQIPtr<ILobbyDataStoreAdmin>	m_pIAdmin;
    CComPtr<IConduit> m_pConduit;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millcore\cmillcore.cpp ===
#include <BasicATL.h>
#include <ZoneResource.h>
#include <ZoneEvent.h>
#include <ZoneString.h>
#include <ZoneProxy.h>
#include <ZoneUtil.h>
#include <KeyName.h>
#include <OpName.h>
#include <UserPrefix.h>
#include <CommonMsg.h>
#include <LcidMap.h>
#include <protocol.h>
#include <millengine.h>
//#include <ChatMsg.h>

//#include <LaunchMsg.h>

#include "CMillCore.h"
//#include "CClient.h"


///////////////////////////////////////////////////////////////////////////////
// Local helper functions
///////////////////////////////////////////////////////////////////////////////

static HRESULT ZONECALL IsUserInAGroupCallback( DWORD dwGroupId, DWORD dwUserId, LPVOID	pContext )
{
	*((bool*) pContext) = true;
	return S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// CMillCore
///////////////////////////////////////////////////////////////////////////////

ZONECALL CMillCore::CMillCore() :
	m_bRoomInitialized( false ),
	m_bPreferencesLoaded( false ),
    m_fLastChatSent( false ),
    m_fConnected( false ),
    m_bGameStarted(false),
    m_fIntentionalDisconnect(false),
	m_dwChannel( ZONE_INVALIDGROUP )
{
}


ZONECALL CMillCore::~CMillCore()
{
}


STDMETHODIMP CMillCore::ProcessEvent(
	DWORD	dwPriority,
	DWORD	dwEventId,
	DWORD	dwGroupId,
	DWORD	dwUserId,
	DWORD	dwData1,
	DWORD	dwData2,
	void*	pCookie )
{
    if(m_fConnected && dwEventId == m_evReceive && dwGroupId == zProtocolSigLobby && dwUserId == m_dwChannel)
	    ProcessMessage( (EventNetwork*) dwData1, dwData2 );

	switch ( dwEventId )
	{
	    case EVENT_LOBBY_MATCHMAKE:
            m_bRoomInitialized = false;
            m_fIntentionalDisconnect = false;
            if(m_fConnected)
            {
                m_fConnected = false;
                m_pConduit->Reconnect(m_dwChannel);
            }
            else
                m_pConduit->Connect(this);
		    break;

        case EVENT_GAME_CLIENT_ABORT:
            if(m_fConnected)
            {
                m_pConduit->Disconnect(m_dwChannel);
                m_fIntentionalDisconnect = true;
            }
            break;

        case EVENT_GAME_TERMINATED:
	        m_pIAdmin->ResetAllGroups();
	        m_pIAdmin->DeleteAllUsers();
	        EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_CLEAR_ALL, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            m_bGameStarted = false;
            break;

	    case EVENT_LOBBY_CHAT_SWITCH:
            if(m_fConnected)
		        SendUserStatusChange();
		    break;

        case EVENT_LOBBY_USER_DEL_COMPLETE:
            m_pIAdmin->DeleteUser(dwUserId);
            break;

        case EVENT_GAME_SEND_MESSAGE:
            if(m_fConnected)
                NetworkSend( zRoomMsgGameMessage, (char *) dwData1, dwData2, true );
            break;
	}

	return S_OK;
}


STDMETHODIMP CMillCore::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CMillCore>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

	// query for lobby data store admin
	m_pIAdmin = LobbyDataStore();
	if ( !m_pIAdmin )
		return E_FAIL;

    // now hook up to the conduit specified in object.txt
	GUID	srvid;
    TCHAR szConduit[ZONE_MAXSTRING];
    DWORD cb = NUMELEMENTS(szConduit);
    hr = DataStoreConfig()->GetString(GetDataStoreKey() + key_conduit, szConduit, &cb);
    if ( FAILED(hr) )
        return hr;
	StringToGuid( szConduit, &srvid );
    if ( srvid == GUID_NULL )
        return E_FAIL;
    hr = ZoneShell()->QueryService(srvid, IID_IConduit, (void**) &m_pConduit);
    if(FAILED(hr))
        return hr;

	return S_OK;
}


STDMETHODIMP CMillCore::Close()
{
	// release ZoneShell objects
	m_pIAdmin.Release();
    m_pConduit.Release();
	IZoneShellClientImpl<CMillCore>::Close();
	return S_OK;
}


void CMillCore::NetworkSend( DWORD dwType, char* pBuff, DWORD cbBuff, bool fHighPriority /* = false */)
{
    if(!m_fConnected)
        return;

	// convert message to EventNetwork and send to rest of lobby
	EventNetwork* pEventNetwork = (EventNetwork*) _alloca( sizeof(EventNetwork) + cbBuff );
	pEventNetwork->dwType = dwType;
	pEventNetwork->dwLength = cbBuff;
	CopyMemory( pEventNetwork->pData, pBuff, cbBuff );
	EventQueue()->PostEventWithBuffer(
			fHighPriority ? PRIORITY_HIGH : PRIORITY_NORMAL, m_evSend,
			zProtocolSigLobby, m_dwChannel, pEventNetwork, sizeof(EventNetwork) + cbBuff );
}


///////////////////////////////////////////////////////////////////////////////
// Lobby messages
///////////////////////////////////////////////////////////////////////////////

void CMillCore::ProcessMessage( EventNetwork* pEvent, DWORD dwLength )
{
	DWORD dwDelta = 0;
	DWORD dwType = pEvent->dwType;
	DWORD dwLen = pEvent->dwLength;
	BYTE* pBuffer = pEvent->pData;

    if(dwLen > dwLength - offsetof(EventNetwork, pData))
        return;

    switch ( dwType )
	{
		case zRoomMsgStartGameM:
			HandleStartGame( pBuffer, dwLen );
			break;

		case zRoomMsgServerStatus:
			HandleServerStatus( pBuffer, dwLen );
			break;

	    case zRoomMsgZUserIDResponse:
	        HandleUserIDResponse( pBuffer, dwLen );
            break;

	    case zRoomMsgChatSwitch:
	        HandleChatSwitch( pBuffer, dwLen );
            break;

        case zRoomMsgPlayerReplaced:
            HandlePlayerReplaced( pBuffer, dwLen );
            break;
	}
}


///////////////////////////////////////////////////////////////////////////////
// Handle messages
///////////////////////////////////////////////////////////////////////////////

void CMillCore::HandleUserIDResponse(BYTE *pBuffer, DWORD dwLen)
{
    ZRoomMsgZUserIDResponse* msg = (ZRoomMsgZUserIDResponse *) pBuffer;
    if(m_bRoomInitialized || dwLen < sizeof(*msg))
        return;

    m_pIAdmin->SetLocalUser(msg->userID);

    m_bRoomInitialized = true;

    // set local chat language from the lcid that the server returns
    CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
    if ( FAILED( hr ) )
        return;

    TCHAR szLang[ZONE_MAXSTRING];
    hr = LanguageFromLCID(msg->lcid, szLang, NUMELEMENTS(szLang), ResourceManager());
    if(FAILED(hr))
    {
        hr = LanguageFromLCID(ZONE_NOLCID, szLang, NUMELEMENTS(szLang), ResourceManager());
        if(FAILED(hr))
            lstrcpy(szLang, TEXT("Unknown Language"));
    }
    pIDS->SetString(key_LocalLanguage, szLang);
    pIDS->SetLong(key_LocalLCID, (long) msg->lcid);
}


void CMillCore::HandleStartGame( BYTE* pBuffer, DWORD dwLen )
{
    static DWORD s_rgPlayerNameIDs[] = { IDS_PLAYER_1, IDS_PLAYER_2, IDS_PLAYER_3, IDS_PLAYER_4 };

	ZRoomMsgStartGameM* pMsg = (ZRoomMsgStartGameM *) pBuffer;
    TCHAR szName[ZONE_MaxUserNameLen];
	HRESULT hr;
	CComPtr<IDataStore> pIDS;

    if(!m_bRoomInitialized || m_bGameStarted || dwLen < sizeof(*pMsg))
        return;

    if(pMsg->numseats > NUMELEMENTS(s_rgPlayerNameIDs))
        return;

    if(dwLen < sizeof(*pMsg) + (pMsg->numseats - 1) * sizeof(pMsg->rgUserInfo[0]))
        return;

	// lobby invalid.  clear everythign and don't bother painting
	// until everything is ready.
	EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_BATCH_BEGIN, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
	EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_CLEAR_ALL, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
	
	// reset lobby
	m_pIAdmin->ResetAllGroups();
	m_pIAdmin->DeleteAllUsers();

	// add players
	for ( int i = 0; i < pMsg->numseats; i++ )
	{
        if(!ResourceManager()->LoadString(s_rgPlayerNameIDs[i], szName, NUMELEMENTS(szName)))
            return;

		// create user
		hr = m_pIAdmin->NewUser( pMsg->rgUserInfo[i].userID, szName );
		if ( FAILED(hr) )
			return;

		// get user's data store
		hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, pMsg->rgUserInfo[i].userID, &pIDS );
		if ( FAILED(hr) )
			continue;

        // need to keep track of their order all the time
        pIDS->SetLong( key_PlayerNumber, i);

        // everyone starts out not ready to play another game
        pIDS->SetLong( key_PlayerReady, KeyPlayerDeciding );

        // chat from server
        pIDS->SetLong( key_ChatStatus, pMsg->rgUserInfo[i].fChat ? 1 : 0 );

        // skill from server
        long sk = pMsg->rgUserInfo[i].eSkill;
        pIDS->SetLong( key_PlayerSkill, (sk == KeySkillLevelIntermediate || sk == KeySkillLevelExpert) ? sk : KeySkillLevelBeginner);

        // language from server
        TCHAR szLang[ZONE_MAXSTRING];
        hr = LanguageFromLCID(pMsg->rgUserInfo[i].lcid, szLang, NUMELEMENTS(szLang), ResourceManager());
        if(FAILED(hr))
        {
            hr = LanguageFromLCID(ZONE_NOLCID, szLang, NUMELEMENTS(szLang), ResourceManager());
            if(FAILED(hr))
                lstrcpy(szLang, TEXT("Unknown Language"));
        }
        pIDS->SetString(key_Language, szLang);

	    pIDS.Release();

		EventQueue()->PostEventWithBuffer(
			PRIORITY_NORMAL, EVENT_LOBBY_USER_NEW,
			ZONE_NOGROUP, pMsg->rgUserInfo[i].userID,
			szName, (lstrlen(szName) + 1) * sizeof(TCHAR) );
	}

	// room initialized, i.e. can process other messages
	EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_BATCH_END, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
	EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_GAME_LAUNCHING, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) pMsg->gameID, (DWORD) pMsg->seat );

	// done initializing the room
	m_bGameStarted = true;
}


void CMillCore::HandleServerStatus( BYTE* pBuffer, DWORD dwLen )
{
	ZRoomMsgServerStatus* pMsg = (ZRoomMsgServerStatus*) pBuffer;

    if(!m_bRoomInitialized || m_bGameStarted || dwLen < sizeof(*pMsg) || pMsg->playersWaiting > 4)
        return;

	EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_SERVER_STATUS, ZONE_NOGROUP, ZONE_NOUSER, pMsg->playersWaiting, pMsg->status );
}


void CMillCore::HandleChatSwitch(BYTE* pBuffer, DWORD dwLen)
{
    ZRoomMsgChatSwitch* pMsg = (ZRoomMsgChatSwitch *) pBuffer;

    if(!m_bGameStarted || dwLen < sizeof(*pMsg))
        return;

    if(LobbyDataStore()->IsUserInGroup(ZONE_NOGROUP, pMsg->userID))
    {
        CComPtr<IDataStore> pIDS;

		HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, pMsg->userID, &pIDS );
		if ( FAILED(hr) )
			return;

        pIDS->SetLong( key_ChatStatus, pMsg->fChat ? 1 : 0);
	    EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_USER_UPDATE, ZONE_NOGROUP, pMsg->userID, 0, 0 );

        // make updation message
        if( pMsg->userID != LobbyDataStore()->GetUserId(NULL) )
        {
            TCHAR sz[ZONE_MAXSTRING];
            TCHAR szFormat[ZONE_MAXSTRING];
            TCHAR szLanguage[ZONE_MAXSTRING];
            TCHAR szName[ZONE_MAXSTRING];

            if(!ResourceManager()->LoadString(pMsg->fChat ? IDS_SYSCHAT_CHATON : IDS_SYSCHAT_CHATOFF, szFormat, NUMELEMENTS(szFormat)))
                return;

            DWORD cb = sizeof(szName);
            hr = pIDS->GetString(key_Name, szName, &cb);
            if(FAILED(hr))
                return;

            cb = sizeof(szLanguage);
            hr = pIDS->GetString(key_Language, szLanguage, &cb);
            if(FAILED(hr))
                return;

            if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName, szLanguage))
                return;

            EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
        }
    }
}


// currently assumes that it has to have been a bot
void CMillCore::HandlePlayerReplaced( BYTE* pBuffer, DWORD dwLen )
{
    static DWORD s_rgComputerNameIDs[] = { IDS_COMPUTER_1, IDS_COMPUTER_2, IDS_COMPUTER_3, IDS_COMPUTER_4 };

	ZRoomMsgPlayerReplaced* pMsg = (ZRoomMsgPlayerReplaced *) pBuffer;

    if(!m_bGameStarted || dwLen < sizeof(*pMsg))
        return;

	HRESULT hr;
    DWORD cb;
    TCHAR szName[ZONE_MaxUserNameLen];
    TCHAR szNameOld[ZONE_MaxUserNameLen];
	CComPtr<IDataStore> pIDSOld;
	CComPtr<IDataStore> pIDS;

    // get existing user's data store
    long seat;
    hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, pMsg->userIDOld, &pIDSOld);
    if(FAILED(hr))
        return;
    hr = pIDSOld->GetLong(key_PlayerNumber, &seat);
    if(FAILED(hr))
        return;

    // get existing user's name
    cb = sizeof(szNameOld);
    hr = pIDSOld->GetString(key_Name, szNameOld, &cb);
    if(FAILED(hr))
        return;

    // get existing user's play again status
    long fReady;
    hr = pIDSOld->GetLong(key_PlayerReady, &fReady);
    if(FAILED(hr))
        return;

    // delete user
    pIDSOld.Release();
    // postponed.  other objects may need to access the data store as well.
//  hr = m_pIAdmin->DeleteUser(pMsg->userIDOld);
//  if(FAILED(hr))
//      return;
    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_LOBBY_USER_DEL, ZONE_NOGROUP, pMsg->userIDOld, szNameOld, (lstrlen(szNameOld) + 1) * sizeof(TCHAR));
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_USER_DEL_COMPLETE, ZONE_NOGROUP, pMsg->userIDOld, 0, 0);

    // get computer's name
    if(!ResourceManager()->LoadString(s_rgComputerNameIDs[seat], szName, NUMELEMENTS(szName)))
        return;

    // create user
    hr = m_pIAdmin->NewUser( pMsg->userIDNew, szName );
    if(FAILED(hr))
        return;

    // get user's data store
    hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, pMsg->userIDNew, &pIDS);
    if(FAILED(hr))
        return;

    // preserve seat
    pIDS->SetLong(key_PlayerNumber, seat);

    // preserve play again status
    pIDS->SetLong(key_PlayerReady, fReady);

    // chat is off for bots
    pIDS->SetLong(key_ChatStatus, 0);

    // skill is bot skill
    pIDS->SetLong(key_PlayerSkill, KeySkillLevelBot);

    // language is unknown
    TCHAR szLang[ZONE_MAXSTRING];
    hr = LanguageFromLCID(ZONE_NOLCID, szLang, NUMELEMENTS(szLang), ResourceManager());
    if(FAILED(hr))
        lstrcpy(szLang, TEXT("Unknown Language"));
    pIDS->SetString(key_Language, szLang);

    pIDS.Release();

    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_LOBBY_USER_NEW, ZONE_NOGROUP, pMsg->userIDNew, szName, (lstrlen(szName) + 1) * sizeof(TCHAR));
}


///////////////////////////////////////////////////////////////////////////////
// IConnectee
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMillCore::Connected(DWORD dwChannel, DWORD evSend, DWORD evReceive, LPVOID pCookie, DWORD dweReason)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_fConnected)
        return S_FALSE;

    m_dwChannel = dwChannel;
    m_fConnected = true;
    m_evSend = evSend;
    m_evReceive = evReceive;

    SendFirstMessage();

    return S_OK;
}

STDMETHODIMP CMillCore::ConnectFailed(LPVOID pCookie, DWORD dweReason)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_fConnected)
        return S_FALSE;

    // see Disconnected() for reasoning.  the differece is, here, you should never get m_bGameStarted
    ASSERT(!m_bGameStarted);
    ASSERT(!m_fIntentionalDisconnect);

    DWORD dwReason = 0x0;
    if(!m_bGameStarted && !m_fIntentionalDisconnect)
        dwReason |= 0x1;
    if(LobbyDataStore()->GetGroupUserCount(ZONE_NOGROUP) != 2)
        dwReason |= 0x2;
    if(dweReason == ZConduit_DisconnectServiceStop)
        dwReason |= 0x4;
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, dwReason, 0);

    return S_OK;
}

STDMETHODIMP CMillCore::Disconnected(DWORD dwChannel, DWORD dweReason)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!m_fConnected || dwChannel != m_dwChannel)
        return S_FALSE;

    m_fConnected = false;

    // the same thing always happens here - the IDD_PLAY_LEFT dialog needs to be displayed.
    // the only question is what the text should be.
    // that is decided here and put into dwData1
    // no bits set - the usual case, a two player game ended because the other player left
    // first bit   - no game, the lobby server must have crashed during matchmaking
    // second bit  - four player game, use four player text.
    // third bit   - the service was stopped
    DWORD dwReason = 0x0;
    if(!m_bGameStarted && !m_fIntentionalDisconnect)
        dwReason |= 0x1;
    if(LobbyDataStore()->GetGroupUserCount(ZONE_NOGROUP) != 2)
        dwReason |= 0x2;
    if(dweReason == ZConduit_DisconnectServiceStop)
        dwReason |= 0x4;
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, dwReason, 0);

    return S_OK;
}


BOOL CMillCore::InitClientConfig(ZRoomMsgClientConfig * pConfig)
{

    TCHAR info[MAX_PATH+1];   
    DWORD cbSize;
    LCID slcid,ulcid,ilcid;
    USES_CONVERSION;

    if(!pConfig)
        return FALSE;

    // system language
    slcid = GetSystemDefaultLCID();

    // user language
    ulcid = GetUserDefaultLCID();

    // interface language
    ilcid = ZoneShell()->GetApplicationLCID();

    TIME_ZONE_INFORMATION zone;

    GetTimeZoneInformation(&zone);

    // skill
    long lSkill = KeySkillLevelBeginner;
	const TCHAR* arKeys[] = { key_Lobby, key_SkillLevel };
    DataStorePreferences()->GetLong( arKeys, 2, &lSkill );

    // get user's chat setting
    CComPtr<IDataStore> pIDS;
    long fChat = 0;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( SUCCEEDED(hr) )
        pIDS->GetLong( key_LocalChatStatus, &fChat );

    m_fLastChatSent = (fChat ? true : false);

    pConfig->protocolSignature=VERSION_MROOM_SIGNATURE;
    pConfig->protocolVersion=VERSION_MROOM_PROTOCOL;

    CComPtr<IMillUtils> pIMU;
    ZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);

    wsprintfA(pConfig->config,
        "SLCID=<%d>ULCID=<%d>ILCID=<%d>UTCOFFSET=<%d>Skill=<%s>Chat=<%s>Exit=<%d>",
        slcid, ulcid, ilcid, zone.Bias,
        lSkill == KeySkillLevelExpert ? "Expert" : lSkill == KeySkillLevelIntermediate ? "Intermediate" : "Beginner",
        m_fLastChatSent ? "On" : "Off", pIMU ? pIMU->GetCounter(IMillUtils::M_CounterGamesAbandonedRunning) : 0);
	
    return TRUE;
}


void CMillCore::SendFirstMessage()
{
    ZRoomMsgClientConfig msg;

    InitClientConfig(&msg);
    NetworkSend( zRoomMsgClientConfig, (char*) &msg, sizeof(msg) );
}


void CMillCore::SendUserStatusChange()
{
    CComPtr<IDataStore> pIDS;
    long fChat = 0;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( SUCCEEDED(hr) )
        pIDS->GetLong( key_LocalChatStatus, &fChat );

    if(m_fLastChatSent != (fChat ? true : false))
    {
        ZRoomMsgChatSwitch oMsg;

        m_fLastChatSent = (fChat ? true : false);
        oMsg.userID = LobbyDataStore()->GetUserId(NULL);
        oMsg.fChat = m_fLastChatSent;
        NetworkSend( zRoomMsgChatSwitch, (char *) &oMsg, sizeof(oMsg));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millengine\cmillengine.h ===
#include "ZoneDef.h"
#include "ZoneError.h"
#include "LobbyDataStore.h"
#include "ClientImpl.h"
#include "ZoneShell.h"
#include "EventQueue.h"
#include "Queue.h"
#include "MillEngine.h"
#include "ProxyMsg.h"


class ATL_NO_VTABLE CMillEngine :
	public IZoneShellClientImpl<CMillEngine>,
	public IEventClient,
    public IMillUtils,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMillEngine, &CLSID_MillEngine>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMillEngine)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
        COM_INTERFACE_ENTRY(IMillUtils)
	END_COM_MAP()


// CEventQueue
public:
	ZONECALL CMillEngine();
	ZONECALL ~CMillEngine();

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

// IEventClient
public:
	STDMETHOD(ProcessEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2,
		void*	pCookie );

// IMillUtils
    STDMETHOD(GetURLQuery)(TCHAR *buf, DWORD cch, long nContext = 0);
    STDMETHOD(IncrementCounter)(long eCounter);
    STDMETHOD(ResetCounter)(long eCounter);
    STDMETHOD_(DWORD, GetCounter)(long eCounter, bool fLifetime = true);
    STDMETHOD(WriteTime)(long nMinutes, TCHAR *sz, DWORD cch);

// internals
private:
    static HRESULT ZONECALL SendIntroEnumStatic(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext);
    HRESULT SendIntroEnum(DWORD dwUserId);

    // event functions
    void AppInitialize();
    bool LaunchUrl(DWORD dwCode);
    bool LaunchHelp();
    bool LaunchICW();
    void DisconnectAlert();

    TCHAR m_szIntroFormat[ZONE_MAXSTRING];
    TCHAR m_szIntroFormatYou[ZONE_MAXSTRING];
    TCHAR m_szIntroChat[2][ZONE_MAXSTRING];
    TCHAR m_szIntroLevel[3][ZONE_MAXSTRING];

	bool m_bPreferencesLoaded;
    bool m_fZoneConnected;
    DWORD m_eDisconnectType;

    BYTE m_rgbLastVersionBuf[sizeof(ZProxyWrongVersionMsg) + ZONE_MAXSTRING];
    ZProxyWrongVersionMsg *m_pLastVersionBuf;

	CComQIPtr<ILobbyDataStoreAdmin>	m_pIAdmin;

    int m_i;

    DWORD m_rgcCounters[M_NumberOfCounters][2];   //  0 = ever, 1 = session
    long m_nFirstLaunch;

    char m_szUpdateTarget[ZONE_MAXSTRING];

    // for timing the processor speed
    int m_msecTimerMHZ;
    __int64 m_mhzTimerMHZ;
    bool m_fTimingMHZ;

    void InitializeMHZTimer();
    DWORD GetMHZTimer();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\lobbywindow\lobbywindow.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 *****************************************************************************/

#pragma once
#include <ZoneResource.h>       // main symbols


#include <atlframe.h>
#include <atlapp.h>
#include "zonestring.h"

//!! hey, move this to someplace special
template <class T>
class CZoneUpdateUI : public CUpdateUI<T>
{
public:
	// replace the buggy ATL function. They just OR flags in.
	BOOL UISetState(int nID, DWORD dwState)
	{
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{		
				// bug here in ATL version
				p->m_wState = (SHORT)dwState;
				m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}
		return bRet;
	}


	BOOL UIToggleCheck(int nID, BOOL bForceUpdate = FALSE)
	{
		return UISetState(nID, UIGetState(nID) ^ UPDUI_CHECKED);
	}
};



#include "EventSpy.h"
#include "DSViewer.h"
#include <ClientIDL.h>
#include <ZoneShell.h>
#include <EventQueue.h>
#include <ZoneEvent.h>
#include <LobbyDataStore.h>
#include <ClientImpl.h>
#include <zoneutil.h>

// this actually is for providing fake stubs, but has all the needed types
#include <multimon.h>
#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors
#ifdef UNICODE  // restore this part
#define GetMonitorInfo  GetMonitorInfoW
#else
#define GetMonitorInfo  GetMonitorInfoA
#endif // !UNICODE

inline DECLARE_MAYBE_FUNCTION(HMONITOR, MonitorFromWindow, (HWND hwnd, DWORD dwFlags), (hwnd, dwFlags), user32, NULL);
inline DECLARE_MAYBE_FUNCTION(BOOL, GetMonitorInfo, (HMONITOR hMonitor, LPMONITORINFO lpmi), (hMonitor, lpmi), user32, FALSE);


typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE> CZoneFrameWinTraits;

class CLobbyWindow :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CFrameWindowImpl<CLobbyWindow, CWindow, CZoneFrameWinTraits>,
	public CComCoClass<CLobbyWindow, &CLSID_LobbyWindow>,
	public CZoneUpdateUI<CLobbyWindow>,
	public IZoneShellClientImpl<CLobbyWindow>,
	public IEventClientImpl<CLobbyWindow>,
	public IZoneFrameWindowImpl<CLobbyWindow>,
	public CMessageFilter,
	public CUpdateUIObject
{
    typedef CFrameWindowImpl<CLobbyWindow, CWindow, CZoneFrameWinTraits>  CFrameWindowImplType;

	HICON					m_hIcon;
	HICON					m_hIconSm;

public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_FRAME_WND_CLASS(_T("ZoneLobbyWindow"), IDR_WINDOWFRAME)

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
	{	
		IZoneShellClientImpl<CLobbyWindow>::Init(pIZoneShell, dwGroupId, szKey);

        // register with shell as the ZoneFrameWindow
        ZoneShell()->SetZoneFrameWindow(this);

		// load icon from ui config
		m_hIcon = ResourceManager()->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR);
		m_hIconSm = ResourceManager()->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);

#if _DEBUG
		m_dlgEventSpy.Create(m_hWnd);
		m_dlgEventSpy.SetEventQueue(EventQueue());
#endif

		return S_OK;
	}

	STDMETHOD(Close)()
	{
        // unregister with the shell
        ZoneShell()->ReleaseReferences((IZoneFrameWindow *) this);

		return IZoneShellClientImpl<CLobbyWindow>::Close();
	}

	CZoneAxWindow m_wndWindowManager;

#ifdef _DEBUG
	CMenu		m_mnuDebug;
	CEventSpy	m_dlgEventSpy;
	CComObject<CDSViewer>* m_pDSViewer;
#endif

	CLobbyWindow() 
#ifdef _DEBUG
	  :  m_pDSViewer(NULL)
#endif
	{
		m_hIcon = NULL;
        m_hIconSm = NULL;
	}

	~CLobbyWindow()
	{
		if ( m_hIcon )
		{
			DestroyIcon( m_hIcon );
			m_hIcon = NULL;
		}

		if ( m_hIconSm )
		{
			DestroyIcon( m_hIconSm );
			m_hIconSm = NULL;
		}
	}

	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return CFrameWindowImplType::PreTranslateMessage(pMsg);
	}

	virtual BOOL OnIdle(int nIdleCount)
	{
		return DoUpdate();
	}

	virtual BOOL DoUpdate()
	{
		return FALSE;
	}

	BEGIN_COM_MAP(CLobbyWindow)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneFrameWindow)
	END_COM_MAP()

	BEGIN_MSG_MAP(CLobbyWindow)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_CLOSE, OnClose)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		MESSAGE_HANDLER(WM_ACTIVATEAPP, OnActivate)
		MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
		MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnTransmit)
		MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnTransmit)
		MESSAGE_HANDLER(WM_EXITSIZEMOVE, OnExitSizeMove)
		MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
		MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
		MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
		MESSAGE_HANDLER(WM_ENTERMENULOOP, OnEnterMenuLoop )
		MESSAGE_HANDLER(WM_ENTERMENULOOP, OnExitMenuLoop )
		MESSAGE_HANDLER(WM_ENTERIDLE, OnEnterIdle)
#ifdef _DEBUG
		COMMAND_ID_HANDLER(ID_DEBUG_EVENTSPY, OnEventSpy)
		COMMAND_ID_HANDLER(ID_DEBUG_DATASTOREVIEWER, OnDSViewer)
#endif
		CHAIN_MSG_MAP(CUpdateUI<CLobbyWindow>)
		CHAIN_MSG_MAP(CFrameWindowImplType)
	END_MSG_MAP()


	BEGIN_UPDATE_UI_MAP(CLobbyWindow)
		UPDATE_ELEMENT(ID_GAME_FINDNEWOPPONENT,		    UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_GAME_SKILLLEVEL_BEGINNER,		UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_GAME_SKILLLEVEL_INTERMEDIATE,	UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_GAME_SKILLLEVEL_EXPERT,		UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_GAME_TURNCHATON,		    	UPDUI_MENUPOPUP)
        UPDATE_ELEMENT(ID_GAME_SOUND,                   UPDUI_MENUPOPUP)
        UPDATE_ELEMENT(ID_GAME_SCORE,                   UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_GAME_EXIT_APP,			    UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_HELP_HELPTOPICS,				UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_HELP_GAMEONTHEWEB,		    UPDUI_MENUPOPUP)
		UPDATE_ELEMENT(ID_HELP_ABOUTGAME,				UPDUI_MENUPOPUP)
	END_UPDATE_UI_MAP()

	BEGIN_EVENT_MAP()
		EVENT_HANDLER( EVENT_LOBBY_PREFERENCES_LOADED, OnLobbyPreferencesLoaded );
        EVENT_HANDLER_WITH_DATA( EVENT_UI_FRAME_ACTIVATE, OnFrameActivate );
	END_EVENT_MAP()

	void OnLobbyPreferencesLoaded(DWORD eventId,DWORD groupId,DWORD userId)
	{
		// Load and restore the main window position
        // need to remove the use of WindowManager's stuff somehow
		CRect rcTop;
        bool fCenter = false;
		const TCHAR* arKeys[] = { key_Lobby, key_WindowManager, key_WindowRect };
		HRESULT hr = DataStorePreferences()->GetRECT( arKeys, 3, &rcTop);
		if(FAILED(hr))
        {
            // set up a default size
            CPoint ptGameSize;
            long nChatHeight;

            fCenter = TRUE;
            SetRectEmpty(&rcTop);

	        const TCHAR* arKeys[] = { key_WindowManager, key_GameSize };
            hr = DataStoreUI()->GetPOINT(arKeys, 2, &ptGameSize);
	        if(SUCCEEDED(hr))
            {
                rcTop.right = ptGameSize.x;
                rcTop.bottom = ptGameSize.y;
            }

            if(GetSystemMetrics(SM_CYSCREEN) >= 550)
                arKeys[1] = key_ChatDefaultHeight;
            else
                arKeys[1] = key_ChatMinHeight;

            hr = DataStoreUI()->GetLong(arKeys, 2, &nChatHeight);
            if(SUCCEEDED(hr))
                rcTop.bottom += nChatHeight;

            // adjust to frame window
            AdjustWindowRectEx(&rcTop, GetWndStyle(0), TRUE, GetWndExStyle(0));
        }

        MoveWindow(rcTop);
    	// ensure window meets the minimum size constraints

		CRect rcCurrent;
		GetWindowRect(&rcCurrent);

		MINMAXINFO MinMax;
		BOOL bHandled = TRUE;
        MinMax.ptMinTrackSize = CPoint(0, 0);
        MinMax.ptMaxTrackSize = CPoint(20000, 20000);
		if(!OnGetMinMaxInfo(WM_GETMINMAXINFO, 0, (LPARAM)&MinMax, bHandled) &&
            bHandled &&
			(rcCurrent.Size().cx < MinMax.ptMinTrackSize.x || rcCurrent.Size().cy < MinMax.ptMinTrackSize.y ||
            rcCurrent.Size().cx > MinMax.ptMaxTrackSize.x || rcCurrent.Size().cy > MinMax.ptMaxTrackSize.y)
		    )
		{
			MoveWindow( CRect(CPoint(0,0), MinMax.ptMinTrackSize) );
            fCenter = TRUE;
		}
        else
        {
            CRect rcWork(0, 0, 0, 0);

            // ensure it is on-screen
            HMONITOR hMon = CALL_MAYBE(MonitorFromWindow)(m_hWnd, MONITOR_DEFAULTTOPRIMARY);
            if(hMon)
            {
			    MONITORINFO mi;
			    ZeroMemory(&mi, sizeof(mi));
			    mi.cbSize = sizeof(mi);
			    if(CALL_MAYBE(GetMonitorInfo)(hMon, &mi))
                    rcWork = mi.rcWork;
            }

            if(rcWork.IsRectEmpty())
                SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

            CRect rc;
            rc.IntersectRect(&rcCurrent, &rcWork);
            if(rc.IsRectEmpty() || rcCurrent.top + GetSystemMetrics(SM_CYCAPTION) / 2 < rcWork.top || rc.Height() < 20 || rc.Width() < 20)
                fCenter = true;
        }

        if(fCenter)
		    CenterWindow( NULL );
	}


	void OnFrameActivate(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
	{
        // sometimes the system fails to send WM_QUERYNEWPALETTE, such as when restoring a window that's been minimized by clicking its taskbar button
        // this hacks around that
        bool fActive = false;

        // WM_ACTIVATEAPP else WM_ACTIVATE
        if(dwData1)
        {
            if(dwData2)
                fActive = true;
        }
        else
        {
            if(LOWORD(dwData2) == WA_ACTIVE || LOWORD(dwData2) == WA_CLICKACTIVE)
                fActive = true;
        }

        if(fActive)
            SendMessage(WM_QUERYNEWPALETTE, NULL, NULL);
    }


	HWND CreateEx(HWND hWndParent = NULL, LPRECT lpRect = NULL, TCHAR* szTitle = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		HMENU hMenu = ResourceManager()->LoadMenu(MAKEINTRESOURCE(GetWndClassInfo().m_uCommonResourceID));
		HWND hWnd = this->Create(hWndParent, lpRect, szTitle, dwStyle, dwExStyle, hMenu, lpCreateParam);
		return hWnd;
	}

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		USES_CONVERSION;
		AtlAxWinInit();

		RECT rcClient;
		GetClientRect(&rcClient);

		m_hWndClient = m_wndWindowManager.Create( m_hWnd, rcClient, _T(""), WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0);


		CComPtr<IZoneShellClient> pControl;
		HRESULT hr = ZoneShell()->CreateService( SRVID_LobbyWindowManager, IID_IZoneShellClient, (void**) &pControl, GetGroupId());
		if ( SUCCEEDED(hr) )
		{
//!! probably don't really want to attach.
			ZoneShell()->Attach( SRVID_LobbyWindowManager, pControl );
			m_wndWindowManager.AttachControl(pControl, NULL);
		}
		pControl.Release();
				

		SetIcon( m_hIcon, TRUE );
		SetIcon( m_hIconSm, FALSE );

#ifdef MAINFRAME
		CMessageLoop* pLoop = _Module.GetMessageLoop();
		pLoop->AddMessageFilter(this);
		pLoop->AddUpdateUI(this);
#endif

		HMENU mnuMain = GetMenu();
#ifdef _DEBUG
        HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_DEBUG_MENU));
		if (hMenu)
		{
			m_mnuDebug.Attach(hMenu);
			HMENU mnuDebug = m_mnuDebug.GetSubMenu(0);
			InsertMenu(mnuMain,-1,MF_BYPOSITION|MF_POPUP, (UINT)(HMENU)mnuDebug,_T("Debug"));
		}
#endif

        // fix up the menu item names
        TCHAR sz[ZONE_MAXSTRING];
        TCHAR szFormat[ZONE_MAXSTRING];
        TCHAR szName[ZONE_MAXSTRING];

        if(ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
        {
            MENUITEMINFO mio;
            mio.cbSize = sizeof(mio);
            mio.fMask = MIIM_TYPE;
            mio.fType = MFT_STRING;
            mio.dwTypeData = sz;

            if(ResourceManager()->LoadString(IDS_MENU_GAMEHELP, szFormat, NUMELEMENTS(szFormat)))
                if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName))
                    SetMenuItemInfo(GetSubMenu(mnuMain, 1), ID_HELP_HELPTOPICS, false, &mio);

            if(ResourceManager()->LoadString(IDS_MENU_GAMEONTHEWEB, szFormat, NUMELEMENTS(szFormat)))
                if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName))
                    SetMenuItemInfo(GetSubMenu(mnuMain, 1), ID_HELP_GAMEONTHEWEB, false, &mio);

            if(ResourceManager()->LoadString(IDS_MENU_ABOUTGAME, szFormat, NUMELEMENTS(szFormat)))
                if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName))
                    SetMenuItemInfo(GetSubMenu(mnuMain, 1), ID_HELP_ABOUTGAME, false, &mio);

            if(ResourceManager()->LoadString(IDS_MENU_FINDNEW, sz, NUMELEMENTS(sz)))
                SetMenuItemInfo(GetSubMenu(mnuMain, 0), ID_GAME_FINDNEWOPPONENT, false, &mio);
        }

        const TCHAR *arKeys[] = { key_Menu, key_SoundAvail };
        long lSoundAvail = 0;
        DataStoreUI()->GetLong(arKeys, 2, &lSoundAvail);
        if(!lSoundAvail)
            DeleteMenu(GetSubMenu(mnuMain, 0), ID_GAME_SOUND, MF_BYCOMMAND);

        ZEnable(ID_GAME_SCORE, FALSE, FALSE);
        arKeys[1] = key_ScoreAvail;
        long lScoreAvail = 0;
        DataStoreUI()->GetLong(arKeys, 2, &lScoreAvail);
        if(!lScoreAvail)
            DeleteMenu(GetSubMenu(mnuMain, 0), ID_GAME_SCORE, MF_BYCOMMAND);

        DrawMenuBar();

		m_wndWindowManager.SetFocus();

		ZoneShell()->AddTopWindow(m_hWnd);
		return 0;
	}

	LRESULT OnEnterMenuLoop(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		EventQueue()->SetWindowMessage( GetCurrentThreadId(), WM_NULL, 0, 0 );
		return 0;
	}

	LRESULT OnExitMenuLoop(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		EventQueue()->DisableWindowMessage();
		return 0;
	}

	LRESULT OnEnterIdle(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// menus are modal, so we use the WM_ENTERIDLE messages process our events.
		EventQueue()->ProcessEvents( false );
		return 0;
	}

	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
	{
#ifdef _DEBUG
        m_dlgEventSpy.DestroyWindow();
#endif

		ZoneShell()->RemoveTopWindow(m_hWnd);
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnTransmit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return m_wndWindowManager.SendMessageToControl(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_UI_FRAME_ACTIVATE, ZONE_NOGROUP, ZONE_NOUSER, (uMsg == WM_ACTIVATEAPP) ? TRUE : FALSE, wParam);
		return m_wndWindowManager.SendMessageToControl(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnExitSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// save away the window position in the user preferences

		CRect rc;
		GetWindowRect(&rc);

		const TCHAR* arKeys[] = { key_Lobby, key_WindowManager, key_WindowRect };
		DataStorePreferences()->SetRECT( arKeys, 3, rc);

		// Transmit this message to chat control through window manager - 
		// to stop flickers while resizing the chat window
		BOOL bUnused;
		m_wndWindowManager.SendMessageToControl(uMsg, wParam, lParam, bUnused);
		return 0;
	}

	LRESULT OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		LPMINMAXINFO pMinMax = (LPMINMAXINFO)lParam;

	    // don't handle message if we haven't created the window manager yet.
		if(m_wndWindowManager.m_hWnd)
        {
		    MINMAXINFO minMax;
            minMax.ptMinTrackSize = CPoint(0, 0);
            minMax.ptMaxTrackSize = CPoint(20000, 20000);
		    m_wndWindowManager.SendMessageToControl(uMsg, wParam, (LPARAM)&minMax, bHandled);

		    if(bHandled)
		    {
                CRect rc(0, 0, minMax.ptMinTrackSize.x, minMax.ptMinTrackSize.y);
                AdjustWindowRectEx(&rc, GetWndStyle(0), TRUE, GetWndExStyle(0));
                pMinMax->ptMinTrackSize.x = max(rc.Width(), pMinMax->ptMinTrackSize.x);
                pMinMax->ptMinTrackSize.y = max(rc.Height(), pMinMax->ptMinTrackSize.y);

                rc = CRect(0, 0, minMax.ptMaxTrackSize.x, minMax.ptMaxTrackSize.y);
                AdjustWindowRectEx(&rc, GetWndStyle(0), TRUE, GetWndExStyle(0));
                pMinMax->ptMaxTrackSize.x = min(rc.Width(), pMinMax->ptMaxTrackSize.x);
                pMinMax->ptMaxTrackSize.y = min(rc.Height(), pMinMax->ptMaxTrackSize.y);
		    }
        }

        // calculate maximized size
        CRect rcWork(0, 0, 0, 0);
        HMONITOR hMon = CALL_MAYBE(MonitorFromWindow)(m_hWnd, MONITOR_DEFAULTTOPRIMARY);
        if(hMon)
        {
            MONITORINFO mi;
			ZeroMemory(&mi, sizeof(mi));
			mi.cbSize = sizeof(mi);
			if(CALL_MAYBE(GetMonitorInfo)(hMon, &mi))
                rcWork = mi.rcWork;
        }

        if(rcWork.IsRectEmpty())
            SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

        pMinMax->ptMaxSize.x = min(pMinMax->ptMaxTrackSize.x, rcWork.Width() + GetSystemMetrics(SM_CXFRAME) * 2);
        pMinMax->ptMaxSize.y = min(pMinMax->ptMaxTrackSize.y, rcWork.Height() + GetSystemMetrics(SM_CYFRAME) * 2);

        pMinMax->ptMaxPosition.x = (rcWork.Width() - pMinMax->ptMaxSize.x) / 2;
        pMinMax->ptMaxPosition.y = (rcWork.Height() - pMinMax->ptMaxSize.y) / 2;

        bHandled = FALSE;
		return 0;
	}

/*
	LRESULT OnInitMenuPopup(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return m_wndWindowManager.SendMessageToControl(nMsg, wParam, lParam, bHandled);
	}
*/

	LRESULT OnFileExit(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		PostMessage(WM_CLOSE);
		return 0;
	}

#ifdef _DEBUG
	LRESULT OnEventSpy(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if ( !m_dlgEventSpy.m_hWnd )
		{
			m_dlgEventSpy.Create(m_hWnd);
			m_dlgEventSpy.SetEventQueue(EventQueue());
		}

		m_dlgEventSpy.ShowWindow(SW_SHOW);

		return 0;
	}
	LRESULT OnDSViewer(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		if ( !m_pDSViewer )
		{
			CComObject<CDSViewer>::CreateInstance(&m_pDSViewer);
			m_pDSViewer->Init(ZoneShell(), GetGroupId(), NULL);
			m_pDSViewer->Create(m_hWnd, NULL);
		}

		m_pDSViewer->ShowWindow(SW_SHOW);

		return 0;
	}
#endif

	LRESULT OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
		HPALETTE hOldPal;  // Handle to previous logical palette

		// If this application did not change the palette, select
		// and realize this application's palette
		if ((HWND)wParam != m_hWnd)
		{
			// Need the window's DC for SelectPalette/RealizePalette
			CDC dc = GetDC();
			// Select and realize hPalette
			hOldPal = dc.SelectPalette(ZoneShell()->GetPalette(), TRUE);
			dc.RealizePalette();

			// When updating the colors for an inactive window,
			// UpdateColors can be called because it is faster than
			// redrawing the client area (even though the results are
			// not as good)
			dc.UpdateColors();

			// Clean up
		    if (hOldPal)
				dc.SelectPalette(hOldPal, TRUE);
		}

		// pass the message on to any children
		BOOL bUnused;			
		m_wndWindowManager.SendMessageToControl(nMsg, wParam, lParam, bUnused);

		return 0;
	}

	LRESULT OnQueryNewPalette(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
		// Need the window's DC for SelectPalette/RealizePalette
		CDC dc = GetDC();

		// Select and realize hPalette
 		// UnrealizeObject(m_cPalette);
		HPALETTE hOldPal = dc.SelectPalette(ZoneShell()->GetPalette(), FALSE);
 
		if(dc.RealizePalette())
		{    
			Invalidate(FALSE);
			UpdateWindow();
		}  

		// Clean up
		dc.SelectPalette(hOldPal, TRUE);

		return TRUE;
	}

	LRESULT OnCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        // give WM_COMMAND messages to the shell sink
        HRESULT hr = ZoneShell()->CommandSink(wParam, lParam, bHandled);

        // if it didn't process it, then give it to the Window Manager
        if(SUCCEEDED(hr) && !bHandled)
		    return m_wndWindowManager.SendMessageToControl(nMsg, wParam, lParam, bHandled);

        return 0;
	}

	LRESULT OnClose(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_WINDOW_CLOSE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millengine\cmillengine.cpp ===
#include <BasicATL.h>
#include <HtmlHelp.h>
#include <ras.h>
#include <wininet.h>
#include <ZoneResource.h>
#include <ZoneEvent.h>
#include <ZoneString.h>
#include <ZoneProxy.h>
#include <KeyName.h>
#include <OpName.h>
#include <LcidMap.h>
#include <icwcfg.h>
#include <ZoneUtil.h>

#include "CMillEngine.h"


enum
{
    zDisconnectRegular,
    zDisconnectVersion,
    zDisconnectUnavailable
};


///////////////////////////////////////////////////////////////////////////////
// CMillEngine
///////////////////////////////////////////////////////////////////////////////

ZONECALL CMillEngine::CMillEngine() :
	m_bPreferencesLoaded( false ),
    m_fTimingMHZ(false),
    m_fZoneConnected(false),
    m_pLastVersionBuf((ZProxyWrongVersionMsg *) m_rgbLastVersionBuf)
{
    int i;
    for(i = 0; i < M_NumberOfCounters; i++)
        m_rgcCounters[i][0] = m_rgcCounters[i][1] = 0;

    InitializeMHZTimer();
}


ZONECALL CMillEngine::~CMillEngine()
{
}


STDMETHODIMP CMillEngine::ProcessEvent(
	DWORD	dwPriority,
	DWORD	dwEventId,
	DWORD	dwGroupId,
	DWORD	dwUserId,
	DWORD	dwData1,
	DWORD	dwData2,
	void*	pCookie )
{
	static bool fShutdownDialog = false;
	switch ( dwEventId )
	{
	    case EVENT_LOBBY_BOOTSTRAP:
            AppInitialize();
		    break;

        case EVENT_LOBBY_PREFERENCES_LOADED:
        {
            // deal with counters
            int i;
            TCHAR szNumberKey[ZONE_MaxString];
            const TCHAR* arKeys[3] = { key_Lobby, key_Numbers, szNumberKey };
            for(i = 0; i < M_NumberOfCounters; i++)
            {
                ZoneFormatMessage(_T("Number%1!d!"), szNumberKey, NUMELEMENTS(szNumberKey), i);
                DataStorePreferences()->GetLong(arKeys, 3, (long *) &m_rgcCounters[i][0]);
            }

            IncrementCounter(M_CounterLaunches);

            // record first launch
            ZoneFormatMessage(_T("Number%1!d!"), szNumberKey, NUMELEMENTS(szNumberKey), M_NumberOfCounters);
            HRESULT hr = DataStorePreferences()->GetLong(arKeys, 3, &m_nFirstLaunch);
            if(FAILED(hr))
            {
                SYSTEMTIME oTime;
                GetSystemTime(&oTime);
                m_nFirstLaunch = ((((DWORD) oTime.wYear) << 16) | (oTime.wMonth << 8) | oTime.wDay) ^ 0x5f3da215;
                DataStorePreferences()->SetLong(arKeys, 3, m_nFirstLaunch);
            }

            // launch comfort dialog?
            long fSkip = 0;
            arKeys[1] = key_SkipOpeningQuestion;
            DataStorePreferences()->GetLong(arKeys, 2, &fSkip);
            if(fSkip)
	            EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LAUNCH_ICW, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            else
                EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_COMFORT_USER, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            break;
        }

        case EVENT_LAUNCH_URL:
            LaunchUrl(dwData1);
            break;

        case EVENT_LAUNCH_HELP:
            LaunchHelp();
            break;

        case EVENT_LAUNCH_ICW:
            if(LaunchICW())
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            else
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ZONE_DO_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        // always need to start matchmaking right after we get a connection
        case EVENT_ZONE_CONNECT:
            ASSERT(!m_fZoneConnected);
            m_fZoneConnected = true;
            m_eDisconnectType = zDisconnectRegular;
            IncrementCounter(M_CounterZoneConnectEst);
            EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            break;

        case EVENT_ZONE_CONNECT_FAIL:
            IncrementCounter(M_CounterZoneConnectFail);
            break;

        case EVENT_ZONE_DISCONNECT:
            ASSERT(m_fZoneConnected);
            m_fZoneConnected = false;
            IncrementCounter(M_CounterZoneConnectLost);
            DisconnectAlert();
            break;

        case EVENT_ZONE_UNAVAILABLE:
            m_eDisconnectType = zDisconnectUnavailable;
            if(!m_fZoneConnected)
                DisconnectAlert();
            break;

        case EVENT_ZONE_VERSION_FAIL:
            m_eDisconnectType = zDisconnectVersion;
            CopyMemory((char *) m_pLastVersionBuf, (char *) dwData1, dwData2);
            if(!m_fZoneConnected)
                DisconnectAlert();
            break;

        // if lobby fails during matchmaking, just restart
        case EVENT_LOBBY_DISCONNECT:
            if((dwData1 & 0x1) && m_fZoneConnected)
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        case EVENT_LOBBY_GOING_DOWN:
        {
            TCHAR szFormat[ZONE_MAXSTRING];
            TCHAR szName[ZONE_MAXSTRING];
            TCHAR szDowntime[ZONE_MAXSTRING];
            TCHAR szWhen[ZONE_MAXSTRING];
            TCHAR sz[ZONE_MAXSTRING];
            DWORD dwBaseResource;

	        CComPtr<IDataStore> pIDS;
	        HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
	        if(FAILED(hr))
		        break;

            long fUnavailable = FALSE;
            long nDowntime = 0;
            szDowntime[0] = _T('\0');

            pIDS->GetLong(key_ServiceUnavailable, &fUnavailable);
            if(fUnavailable)
            {
                pIDS->GetLong(key_ServiceDowntime, &nDowntime);

                if(nDowntime)
                {
                    dwBaseResource = IDS_SHUTDOWN_A;
                    if(FAILED(WriteTime(nDowntime, szDowntime, NUMELEMENTS(szDowntime))))
                        break;
                }
                else
                    dwBaseResource = IDS_SHUTDOWN_B;
            }
            else
                dwBaseResource = IDS_SHUTDOWN_C;

            if(!ResourceManager()->LoadString(dwBaseResource, szFormat, NUMELEMENTS(szFormat)))
                break;

            if(!ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
                szName[0] = _T('\0');

            if(FAILED(WriteTime(dwData1, szWhen, NUMELEMENTS(szWhen))))
                break;

            if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName, szWhen, szDowntime))
                break;

            ZoneShell()->AlertMessage(NULL, sz, NULL, AlertButtonOK);

            break;
        }

        case EVENT_GAME_LAUNCHING:
        {
            for(m_i = 0; m_i < 4; m_i++)
                LobbyDataStore()->EnumUsers(ZONE_NOGROUP, SendIntroEnumStatic, this);

            // send your own
            if(!m_szIntroFormatYou[0])
                break;

            CComPtr<IDataStore> pIDS;
            HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, LobbyDataStore()->GetUserId(NULL), &pIDS);
	        if(FAILED(hr))
		        break;

            TCHAR szName[ZONE_MAXSTRING];
            DWORD cb = sizeof(szName);
            hr = pIDS->GetString(key_Name, szName, &cb);
            if(FAILED(hr))
                break;

            TCHAR sz[ZONE_MAXSTRING];
            if(!ZoneFormatMessage(m_szIntroFormatYou, sz, NUMELEMENTS(sz), szName))
                break;

            EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
            break;
        }

        // make chat message - this only occurs with bot replacement
        case EVENT_LOBBY_USER_DEL:
        {
            TCHAR szFormat[ZONE_MAXSTRING];
            TCHAR sz[ZONE_MAXSTRING];

            if(!ResourceManager()->LoadString(IDS_SYSCHAT_BOT, szFormat, NUMELEMENTS(szFormat)))
                break;

            if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), (TCHAR *) dwData1))
                break;

            EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
            break;
        }

	    case EVENT_DESTROY_WINDOW:
        {
            HWND hWnd = (HWND) dwData1;
            if(IsWindow(hWnd))
		        DestroyWindow(hWnd);
            if(dwData2)
                delete (void *) dwData2;
		    break;
        }

        // nobody else should ever key off of EVENT_FINAL - they should use EVENT_EXIT_APP.  they're not guaranteed to even get EVENT_FINAL.
	    case EVENT_EXIT_APP:
            EventQueue()->PostEvent(PRIORITY_LOW, EVENT_FINAL, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
		    break;

        case EVENT_FINAL:
            ZoneShell()->ExitApp();
            break;

        case EVENT_UI_MENU_EXIT:
        case EVENT_UI_WINDOW_CLOSE:
            if(LobbyDataStore()->GetGroupUserCount(ZONE_NOGROUP))
            {
            	if( !fShutdownDialog )
            	{
            		ZoneShell()->AlertMessage(NULL, MAKEINTRESOURCE(IDS_PROMPT_EXIT), NULL, AlertButtonYes, NULL, AlertButtonNo, 0, EVENT_UI_PROMPT_EXIT);
            		fShutdownDialog = true;
            	}
            }
            else
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        case EVENT_UI_PROMPT_EXIT:
        	fShutdownDialog = false;
            if(dwData1 == IDYES)
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        case EVENT_UI_MENU_NEWOPP:
        {
            long n = LobbyDataStore()->GetGroupUserCount(ZONE_NOGROUP);

            if(n >= 2)
                ZoneShell()->AlertMessage(NULL, MAKEINTRESOURCE(n == 2 ? IDS_PROMPT_NEWOPP2 : IDS_PROMPT_NEWOPP4),
                    MAKEINTRESOURCE(n == 2 ? IDS_PROMPT_NEWOPP_TITLE2 : IDS_PROMPT_NEWOPP_TITLE4),
                    AlertButtonYes, NULL, AlertButtonNo, 0, EVENT_UI_PROMPT_NEWOPP);
            else
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;
        }

        case EVENT_UI_PROMPT_NEWOPP:
            if(dwData1 == IDYES)
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        case EVENT_UI_PROMPT_NETWORK:
            if(dwData1 == IDYES)
            {
                ASSERT(!m_fZoneConnected);
	            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ZONE_DO_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_UPSELL_UNBLOCK, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
                break;
            }

            if(dwData1 == IDNO)
            {
                SHELLEXECUTEINFOA oSE;
                oSE.cbSize = sizeof(oSE);
                oSE.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_FLAG_NO_UI;
                oSE.hwnd = NULL;
                oSE.lpVerb = NULL;
                oSE.lpFile = m_szUpdateTarget;
                oSE.lpParameters = NULL;
                oSE.lpDirectory = NULL;
                oSE.nShow = SW_SHOWNORMAL;
	            ShellExecuteExA(&oSE);
            }

            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;
	}

	return S_OK;
}


void CMillEngine::DisconnectAlert()
{
    USES_CONVERSION;

    // block the upsell on high priority before it switches to the Disconnected From Lobby message
    EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_UI_UPSELL_BLOCK, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);

    switch(m_eDisconnectType)
    {
        case zDisconnectRegular:
            ZoneShell()->AlertMessage(NULL, MAKEINTRESOURCE(IDS_NETWORK_DISCONNECT), MAKEINTRESOURCE(IDS_NETWORK),
                MAKEINTRESOURCE(IDS_NETWORK_BUTTON), NULL, AlertButtonQuit, 0, EVENT_UI_PROMPT_NETWORK);
            break;

        case zDisconnectUnavailable:
        {
            long nDowntime = 0;

	        CComPtr<IDataStore> pIDS;
	        HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	        if(SUCCEEDED(hr))
            {
                long fUnavailable = FALSE;
                pIDS->GetLong(key_ServiceUnavailable, &fUnavailable);
                if(fUnavailable)
                    pIDS->GetLong(key_ServiceDowntime, &nDowntime);
            }

            TCHAR szFormat[ZONE_MAXSTRING];
            TCHAR szName[ZONE_MAXSTRING];
            TCHAR szTime[ZONE_MAXSTRING];
            TCHAR sz[ZONE_MAXSTRING];
            if(!ResourceManager()->LoadString(nDowntime ? IDS_ZONE_UNAVAILABLE2 : IDS_ZONE_UNAVAILABLE, szFormat, NUMELEMENTS(szFormat)))
                break;

            if(!ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
                szName[0] = _T('\0');

            if(FAILED(WriteTime(nDowntime, szTime, NUMELEMENTS(szTime))))
                break;

            if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName, szTime))
                break;

            ZoneShell()->AlertMessage(NULL, sz, NULL,
                AlertButtonRetry, NULL, AlertButtonQuit, 2, EVENT_UI_PROMPT_NETWORK);
            break;
        }

        case zDisconnectVersion:
        {
            DWORD dwBaseResource = IDS_VERFAIL_GENERIC;
            m_szUpdateTarget[0] = '\0';

            if(m_pLastVersionBuf->dweLocationCode == zProxyLocationURLManual)
            {
                dwBaseResource = IDS_VERFAIL_URL;
                char *rgszPrefixes[] = { "http://zone.msn.com/", "http://www.zone.com/", "http://www.microsoft.com/", NULL };
                char **p;
                int i;

                lstrcpynA(m_szUpdateTarget, m_pLastVersionBuf->szLocation, NUMELEMENTS(m_szUpdateTarget));
                for(p = rgszPrefixes; *p; p++)
                {
                    for(i = 0; (*p)[i]; i++)
                        if(m_szUpdateTarget[i] != (*p)[i])
                            break;
                    if(!(*p)[i])
                        break;
                }
                if(!*p)
                    lstrcpynA(m_szUpdateTarget, rgszPrefixes[0], NUMELEMENTS(m_szUpdateTarget));
            }

            if(m_pLastVersionBuf->dweLocationCode == zProxyLocationWindowsUpdate)
            {
                WORD wPLang;
                TCHAR szPVer[ZONE_MAXSTRING] = _T("");
                OSVERSIONINFO oOSVer;
                TCHAR szGameID[ZONE_MAXSTRING] = _T("");
                int i;

                wPLang = LANGIDFROMLCID(ZoneShell()->GetApplicationLCID());

                const TCHAR *arKeys[] = { key_Version, key_VersionStr };
                DWORD cchVer = NUMELEMENTS(szPVer);
                CComPtr<IDataStore> pIDS;
                LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
                if(pIDS)
                    pIDS->GetString(arKeys, 2, szPVer, &cchVer);

                // replace the second '.' with a '\0' - only major and minor version is used for now
                // if they ever get their system working properly, this should be removed & we should send the
                // complete version
                for(i = 0; szPVer[i]; i++)
                    if(szPVer[i] == '.')
                        for(i++; szPVer[i]; i++)
                            if(szPVer[i] == '.')
                                szPVer[i--] = '\0';

                oOSVer.dwOSVersionInfoSize = sizeof(oOSVer);
                GetVersionEx(&oOSVer);

                HRESULT hr = E_FAIL;
                TCHAR szInternalName[ZONE_MAXSTRING] = _T("");
                DWORD cchInternalName = NUMELEMENTS(szInternalName);
                if(pIDS)
                    hr = pIDS->GetString(key_InternalName, szInternalName, &cchInternalName);
                if(SUCCEEDED(hr) && szInternalName[0])
                    lstrcpyn(szGameID, szInternalName + 1, 5);
                else
                    szGameID[0] = 0;

                dwBaseResource = IDS_VERFAIL_WINUPD;
/*              wsprintfA(m_szUpdateTarget, "http://www.microsoft.com/isapi/redir.dll?PRD=Zone&SBP=IGames&PLCD=0x%04X&PVER=%S&OS=%s&OVER=%d.%d&OLCID=0x%04X&CLCID=0x%04X&AR=WinUpdate&O1=%S",
                    wPLang,
                    szPVer,
                    (oOSVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? "Win" : "WinNT",
                    oOSVer.dwMajorVersion, oOSVer.dwMinorVersion,
                    GetSystemDefaultLangID(),
                    GetUserDefaultLangID(),
                    szGameID);
*/
                wsprintfA(m_szUpdateTarget, "http://www.microsoft.com/isapi/redir.dll?PRD=Zone&SBP=IGames&PVER=%S&AR=WinUpdate", szPVer);
            }

            if(m_pLastVersionBuf->dweLocationCode == zProxyLocationPackaged)
                dwBaseResource = IDS_VERFAIL_PACKAGED;

            TCHAR szFormat[ZONE_MAXSTRING];
            TCHAR sz[ZONE_MAXSTRING];
            if(!ResourceManager()->LoadString(dwBaseResource, szFormat, NUMELEMENTS(szFormat)))
                break;

            if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), A2T(m_pLastVersionBuf->szLocation)))
                break;

            ZoneShell()->AlertMessage(NULL, sz, NULL,
                NULL, m_szUpdateTarget[0] ? MAKEINTRESOURCE(IDS_VERFAIL_BUTTON) : NULL, AlertButtonQuit, m_szUpdateTarget[0] ? 1 : 2, EVENT_UI_PROMPT_NETWORK);

            break;
        }
    }
}


HRESULT ZONECALL CMillEngine::SendIntroEnumStatic(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext)
{
    CMillEngine *pThis = (CMillEngine *) pContext;

    return pThis->SendIntroEnum(dwUserId);
}


HRESULT CMillEngine::SendIntroEnum(DWORD dwUserId)
{
    if(dwUserId == LobbyDataStore()->GetUserId(NULL))
        return S_OK;

    if(!m_szIntroFormat[0])
        return E_FAIL;

    CComPtr<IDataStore> pIDS;
    HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, dwUserId, &pIDS);
	if(FAILED(hr))
		return S_OK;

    long nPlayer = -1;
    pIDS->GetLong(key_PlayerNumber, &nPlayer);
    if(nPlayer != m_i)
        return S_OK;

    TCHAR szLang[ZONE_MAXSTRING];
    DWORD cb = sizeof(szLang);
    hr = pIDS->GetString(key_Language, szLang, &cb);
    if(FAILED(hr))
        return S_OK;

    long nLevel = KeySkillLevelBeginner;
    pIDS->GetLong(key_PlayerSkill, &nLevel);
    if(nLevel < 0 || nLevel >= 3)
        nLevel = 0;
    if(!m_szIntroLevel[nLevel][0])
        return S_OK;

    long fChat = 0;
    pIDS->GetLong(key_ChatStatus, &fChat);
    if(fChat)
        fChat = 1;
    if(!m_szIntroChat[fChat][0])
        return S_OK;

    TCHAR szName[ZONE_MAXSTRING];
    cb = sizeof(szName);
    hr = pIDS->GetString(key_Name, szName, &cb);
    if(FAILED(hr))
        return S_OK;

    TCHAR sz[ZONE_MAXSTRING];
    if(!ZoneFormatMessage(m_szIntroFormat, sz, NUMELEMENTS(sz), szName, szLang, m_szIntroLevel[nLevel], m_szIntroChat[fChat]))
        return S_OK;

    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
    return S_OK;
}


STDMETHODIMP CMillEngine::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
    int i;

	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CMillEngine>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

	// query for lobby data store admin
	m_pIAdmin = LobbyDataStore();
	if ( !m_pIAdmin )
		return E_FAIL;

    // load some stuff only once
    if(!ResourceManager()->LoadString(IDS_SYSCHAT_INTRO, m_szIntroFormat, NUMELEMENTS(m_szIntroFormat)))
        m_szIntroFormat[0] = 0;
    if(!ResourceManager()->LoadString(IDS_SYSCHAT_INTROYOU, m_szIntroFormatYou, NUMELEMENTS(m_szIntroFormatYou)))
        m_szIntroFormatYou[0] = 0;
    for(i = 0; i < 2; i++)
        if(!ResourceManager()->LoadString(i ? IDS_SYSCHAT_ON : IDS_SYSCHAT_OFF, m_szIntroChat[i], NUMELEMENTS(m_szIntroChat[i])))
            m_szIntroChat[i][0] = 0;
    for(i = 0; i < 3; i++)
        if(!ResourceManager()->LoadString(i ? i == 2 ? IDS_LEVEL_EXPERT : IDS_LEVEL_INTERMEDIATE : IDS_LEVEL_BEGINNER, m_szIntroLevel[i], NUMELEMENTS(m_szIntroLevel[i])))
            m_szIntroLevel[i][0] = 0;

	return S_OK;
}


STDMETHODIMP CMillEngine::Close()
{
	// release ZoneShell objects
	m_pIAdmin.Release();
	return IZoneShellClientImpl<CMillEngine>::Close();
}


void CMillEngine::AppInitialize()
{
    HRESULT hr;
    TCHAR szTitle[ZONE_MAXSTRING];
    TCHAR szFormat[ZONE_MAXSTRING];
    TCHAR szName[ZONE_MAXSTRING];

    // set window title
    if(!ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
        lstrcpy(szName, TEXT("Zone"));
    if(!ResourceManager()->LoadString(IDS_WINDOW_TITLE, szFormat, NUMELEMENTS(szFormat)))
        lstrcpy(szFormat, TEXT("%1"));
    if(!ZoneFormatMessage(szFormat, szTitle, NUMELEMENTS(szTitle), szName))
        lstrcpy(szTitle, szName);
    ::SetWindowText(ZoneShell()->GetFrameWindow(), szTitle);

	// load user preferences
	if ( !m_bPreferencesLoaded )
	{
		m_bPreferencesLoaded = true;

	    CComPtr<IDataStore> pIDS;

		TCHAR szInternalName[ZONE_MaxInternalNameLen];
		DWORD cbInternalName = sizeof(szInternalName);
		szInternalName[0] = '\0';
		hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
		if ( SUCCEEDED( hr ) )
			pIDS->GetString( key_InternalName, szInternalName, &cbInternalName );

		if ( szInternalName[0] )
		{
			hr = ZoneShell()->LoadPreferences( szInternalName, TEXT("Windows User") );
			if ( SUCCEEDED(hr) )
			{
                // do a bit of pre-processing
                long lChatOn = DEFAULT_ChatOnAtStartup;
                const TCHAR *arKeys[] = { key_Lobby, key_ChatOnAtStartup };
                DataStorePreferences()->GetLong(arKeys, 2, &lChatOn);

                pIDS->SetLong( key_LocalChatStatus, lChatOn ? 1 : 0 );

                TCHAR szLang[ZONE_MAXSTRING];
                long lcid = GetUserDefaultLCID();
                hr = LanguageFromLCID(lcid, szLang, NUMELEMENTS(szLang), ResourceManager());
                if(FAILED(hr))
                {
                    hr = LanguageFromLCID(ZONE_NOLCID, szLang, NUMELEMENTS(szLang), ResourceManager());
                    if(FAILED(hr))
                        lstrcpy(szLang, TEXT("Unknown Language"));
                }
                pIDS->SetString(key_LocalLanguage, szLang);
                pIDS->SetLong(key_LocalLCID, lcid);

				EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_PREFERENCES_LOADED, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
			}
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// LaunchUrl - copied from ProxyCore.cpp
///////////////////////////////////////////////////////////////////////////////

bool CMillEngine::LaunchUrl(DWORD dwCode)
{
    USES_CONVERSION;

	TCHAR szUrl[ZONE_MAXSTRING];
    DWORD cch = NUMELEMENTS(szUrl) - 2;  // guarantee room for later manipulation
    szUrl[0] = 0;
    HRESULT hr = DataStoreConfig()->GetString(GetDataStoreKey() + key_SoftURL, szUrl, &cch);
    if(FAILED(hr))
        return false;

    lstrcat(szUrl, _T("?"));

    GetURLQuery(szUrl + lstrlen(szUrl), NUMELEMENTS(szUrl) - lstrlen(szUrl), dwCode);

	// run the browser
    SHELLEXECUTEINFOA oSE;
    oSE.cbSize = sizeof(oSE);
    oSE.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_FLAG_NO_UI;
    oSE.hwnd = NULL;
    oSE.lpVerb = NULL;
    oSE.lpFile = T2A(szUrl);
    oSE.lpParameters = NULL;
    oSE.lpDirectory = NULL;
    oSE.nShow = SW_SHOWNORMAL;
	if(!ShellExecuteExA(&oSE))
		return false;
	else
		return true;
}


bool CMillEngine::LaunchHelp()
{
    TCHAR szFile[ZONE_MAXSTRING];
    TCHAR szName[ZONE_MAXSTRING];
    int i;

    DWORD cb = NUMELEMENTS(szName);
    HRESULT hr = DataStoreConfig()->GetString(GetDataStoreKey() + key_HelpFile, szName, &cb);
    if(FAILED(hr))
        return false;

    // try our install path.  this will also check the registry and windows help.
    if(!GetModuleFileName(NULL, szFile, NUMELEMENTS(szFile)))
        return false;

    // this could be bad on other languages.
    for(i = lstrlen(szFile) - 1; i >= 0; i--)
        if(szFile[i] == _T('\\') || szFile[i] == _T(':'))
            break;
    i++;
    if(i)
    {
        if(szFile[i - 1] != '\\')
            szFile[i++] = '\\';
        szFile[i] = '\0';

        if(i + lstrlen(szName) < NUMELEMENTS(szFile))
        {
            lstrcat(szFile, szName);
            if(HtmlHelp(NULL, szFile, HH_DISPLAY_TOPIC, 0))
                return true;  // success
        }
    }

    // we failed.
    return false;
}

inline DECLARE_MAYBE_FUNCTION(DWORD, CheckConnectionWizard, (DWORD dwRunFlags, LPDWORD lpdwReturnFlags), (dwRunFlags, lpdwReturnFlags), inetcfg, ERROR_INVALID_FUNCTION);
inline DECLARE_MAYBE_FUNCTION(DWORD, SetShellNext, (CHAR *szShellNext), (szShellNext), inetcfg, ERROR_INVALID_FUNCTION);
inline DECLARE_MAYBE_FUNCTION(DWORD, SetShellNextA, (CHAR *szShellNext), (szShellNext), inetcfg, ERROR_INVALID_FUNCTION);

// returns true if ICW launched
bool CMillEngine::LaunchICW()
{
    CComPtr<IDataStore> pIDS;
    HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
    if(FAILED(hr))
        return false;

    TCHAR szCmdLine[ZONE_MAXSTRING / 2] = _T("");  // ensure enough space for extra slashes
    DWORD cch = NUMELEMENTS(szCmdLine);
    pIDS->GetString(key_icw, szCmdLine, &cch);
    if(!szCmdLine[0])
        return false;

    // change / into //
    int i, j;
    CHAR szCmdLineFinal[ZONE_MAXSTRING];
    for(i = j = 0; szCmdLine[j]; j++)
    {
        ASSERT(!(szCmdLine[j] & ~0x7f));
        szCmdLineFinal[i++] = (CHAR) (szCmdLine[j] & 0x7f);
        if(szCmdLine[j] == '/')
            szCmdLineFinal[i++] = '/';
    }
    szCmdLineFinal[i] = '\0';

	if(CALL_MAYBE(SetShellNextA)(szCmdLineFinal) != ERROR_SUCCESS)
	    if(CALL_MAYBE(SetShellNext)(szCmdLineFinal) != ERROR_SUCCESS)
		    return false;

	DWORD dwRet = 0;
	if(CALL_MAYBE(CheckConnectionWizard)(ICW_CHECKSTATUS | ICW_LAUNCHFULL | ICW_USE_SHELLNEXT | ICW_FULL_SMARTSTART, &dwRet) != ERROR_SUCCESS)
		return false;

	if(dwRet & ICW_LAUNCHEDFULL || dwRet & ICW_LAUNCHEDMANUAL)
		return true;

    // take our command line out so we don't get randomly launched later
	if(CALL_MAYBE(SetShellNextA)("iexplore") != ERROR_SUCCESS)
	    CALL_MAYBE(SetShellNext)("iexplore");

    return false;
}


///////////////////////////////////////////////////////////////////////////////
// IMillUtils - Exposed Utilities
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMillEngine::GetURLQuery(TCHAR *buf, DWORD cch, long nContext)
{
    int i;
    TCHAR szInternalName[ZONE_MaxInternalNameLen + 1];
    DWORD cbInternalName = NUMELEMENTS(szInternalName);
    TCHAR szGameAbbr[5];
    ZeroMemory(szInternalName, sizeof(szInternalName));
    CComPtr<IDataStore> pIDS;
    HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
    if(FAILED(hr))
        return E_FAIL;

    //
    // Game (GM)
    hr = pIDS->GetString(key_InternalName, szInternalName, &cbInternalName);
    if(SUCCEEDED(hr) && szInternalName[0])
        lstrcpyn(szGameAbbr, szInternalName + 1, 5);
    else
        szGameAbbr[0] = 0;

    //
    // Zone Language (ZL)
    LCID lcid = MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT);
    pIDS->GetLong(key_LocalLCID, (long *) &lcid);

    //
    // Time Zone (Z)
    TIME_ZONE_INFORMATION tzInfo;
    GetTimeZoneInformation(&tzInfo);

    //
    // System Parameters (Y)
    HDC hdcScreen = GetDC(NULL);
    if(!hdcScreen)
        return E_FAIL;

    int cxScreen = GetDeviceCaps(hdcScreen, HORZRES);
    int cyScreen = GetDeviceCaps(hdcScreen, VERTRES);
    int nColorDepth = GetDeviceCaps(hdcScreen, BITSPIXEL);

    ReleaseDC(NULL, hdcScreen);

    // try to find baud in this way  (KB article Q163236 was the most helpful in creating this)
    // this is intentionally pretty un-failsafe, but hopefully the majority of cases will get a
    // correct baud reported.  doing anything more complicated would be too complicated to be worth it
    // to catch the marginal, weird configuration cases.  definitely will not work for NT (but there
    // is actually an easier way with NT using RasGetConnectionStatistics)
    DWORD dwBaud = 0;
    RASCONNA oRasConn;
    DWORD cb = sizeof(RASCONN);
    DWORD cEntries;

    oRasConn.dwSize = cb;
    if(!RasEnumConnectionsA(&oRasConn, &cb, &cEntries) && cEntries == 1)
    {
        RASCONNSTATUSA oRasConnStatus;

        if(!RasGetConnectStatusA(oRasConn.hrasconn, &oRasConnStatus) && !lstrcmpA(oRasConnStatus.szDeviceType, "modem"))
        {
            DEVCFG *pDevCfg;

            cb = 0;
            RasGetEntryPropertiesA(NULL, oRasConn.szEntryName, NULL, NULL, NULL, &cb);

            if(cb >= sizeof(DEVCFG))
            {
                pDevCfg = (DEVCFG *) _alloca(cb);  // this will crash if it fails anyway
                ZeroMemory(pDevCfg, cb);
                if(!RasGetEntryPropertiesA(NULL, oRasConn.szEntryName, NULL, NULL, (LPBYTE) pDevCfg, &cb) &&
                    pDevCfg->dfgHdr.dwSize >= sizeof(DEVCFG) &&
                    pDevCfg->dfgHdr.dwVersion == 0x00010003 &&
                    pDevCfg->commconfig.dwProviderSubType == PST_MODEM)
                {
                    dwBaud = pDevCfg->commconfig.dcb.BaudRate;
                }
            }
        }
    }

    DWORD dwInternetFlags = 0;
    InternetGetConnectedState(&dwInternetFlags, 0);

    DWORD mhz = GetMHZTimer();

    WORD rgwValues[8];
    BYTE rgbBytes[16];

    rgwValues[0] = (WORD) cxScreen;
    rgwValues[1] = (WORD) cyScreen;
    rgwValues[2] = (WORD) nColorDepth;
    rgwValues[3] = (WORD) dwBaud;
    rgwValues[4] = (WORD) dwInternetFlags;
    rgwValues[5] = (WORD) mhz;
    for(i = 0; i < 6; i++)
    {
        rgbBytes[i * 2] = rgwValues[i] >> 8;
        rgbBytes[i * 2 + 1] = rgwValues[i] & 0xff;
    }

    BYTE rgbMask[12] = { 0xf6, 0x05, 0x9e, 0x5a, 0x2b, 0x11, 0x3a, 0xae, 0x86, 0x0a, 0x29, 0xf4 };
    TCHAR szSysParam[25];
    for(i = 0; i < 12; i++)
    {
        rgbBytes[i] ^= rgbMask[i];
        ZoneFormatMessage(_T("%1!02X!"), szSysParam + 2 * i, 3, rgbBytes[i]);
    }

    //
    // Advertizing Counters (X)
    for(i = 0; i < 3; i++)
    {
        if(m_rgcCounters[i + M_CounterAdsRequested][0] & 0xffff0000)
            rgwValues[i * 2] = 0xffff;
        else
            rgwValues[i * 2] = (WORD) (m_rgcCounters[i + M_CounterAdsRequested][0] & 0x0000ffff);

        if(m_rgcCounters[i + M_CounterAdsRequested][1] & 0xffff0000)
            rgwValues[i * 2 + 1] = 0xffff;
        else
            rgwValues[i * 2 + 1] = (WORD) (m_rgcCounters[i + M_CounterAdsRequested][1] & 0x0000ffff);
    }

    for(i = 0; i < 6; i++)
    {
        rgbBytes[i * 2] = rgwValues[i] >> 8;
        rgbBytes[i * 2 + 1] = rgwValues[i] & 0xff;
    }

    BYTE rgbMask2[12] = { 0x6f, 0x58, 0xa2, 0x21, 0x7b, 0xc0, 0xee, 0x42, 0x95, 0xf3, 0xc0, 0x94 };
    TCHAR szAdCount[25];
    for(i = 0; i < 12; i++)
    {
        rgbBytes[i] ^= rgbMask2[i];
        ZoneFormatMessage(_T("%1!02X!"), szAdCount + 2 * i, 3, rgbBytes[i]);
    }

    //
    // Game Counters (W)
    for(i = 0; i < 4; i++)
    {
        if(m_rgcCounters[i + M_CounterGamesCompleted][0] & 0xffff0000)
            rgwValues[i] = 0xffff;
        else
            rgwValues[i] = (WORD) (m_rgcCounters[i + M_CounterGamesCompleted][0] & 0x0000ffff);
    }

    for(i = 0; i < 4; i++)
    {
        rgbBytes[i * 2] = rgwValues[i] >> 8;
        rgbBytes[i * 2 + 1] = rgwValues[i] & 0xff;
    }

    BYTE rgbMask3[8] = { 0x57, 0x3e, 0xa0, 0x21, 0x32, 0x89, 0x4b, 0xf3 };
    TCHAR szGameCount[17];
    for(i = 0; i < 8; i++)
    {
        rgbBytes[i] ^= rgbMask3[i];
        ZoneFormatMessage(_T("%1!02X!"), szGameCount + 2 * i, 3, rgbBytes[i]);
    }

    //
    // Use Counters (V)
    for(i = 0; i < 5; i++)
    {
        if(m_rgcCounters[i + M_CounterLaunches][0] & 0xffff0000)
            rgwValues[i] = 0xffff;
        else
            rgwValues[i] = (WORD) (m_rgcCounters[i + M_CounterLaunches][0] & 0x0000ffff);
    }

    for(i = 0; i < 5; i++)
    {
        rgbBytes[i * 2] = rgwValues[i] >> 8;
        rgbBytes[i * 2 + 1] = rgwValues[i] & 0xff;
    }

    BYTE rgbMask4[10] = { 0x6a, 0x31, 0x95, 0xe0, 0x82, 0xcc, 0xcd, 0x3d, 0x2a, 0x11 };
    TCHAR szUseCount[21];
    for(i = 0; i < 10; i++)
    {
        rgbBytes[i] ^= rgbMask4[i];
        ZoneFormatMessage(_T("%1!02X!"), szUseCount + 2 * i, 3, rgbBytes[i]);
    }

    //
    // Settings (T)
    DWORD dwSettings = 0;

    long f = DEFAULT_ChatOnAtStartup;
    const TCHAR* arKeys[] = { key_Lobby, key_ChatOnAtStartup };
    DataStorePreferences()->GetLong(arKeys, 2, &f);
    if(f)
        dwSettings |= 2;

    f = DEFAULT_PrefSound;
    arKeys[1] = key_PrefSound;
    DataStorePreferences()->GetLong(arKeys, 2, &f);
    if(f)
        dwSettings |= 1;

    f = 0;
    arKeys[1] = key_SkillLevel;
    DataStorePreferences()->GetLong(arKeys, 2, &f);
    dwSettings |= ((f == KeySkillLevelExpert) ? 0x10 : (f == KeySkillLevelIntermediate) ? 0x08 : 0);

    f = 0;
    pIDS->GetLong(key_LocalChatStatus, &f);
    if(f)
        dwSettings |= 4;

    dwSettings ^= 0x6A;

    //
    // Version (S)
    DWORD dwVersion;
    const TCHAR *arKeysVer[] = { key_Version, key_VersionNum };
    pIDS->GetLong(arKeysVer, 2, (long *) &dwVersion);

    //
    // Mac Address (R)
    TCHAR szGUID[] = _T("GUID");
    DWORD disposition;
    HKEY hkey = NULL;
    GUID mac;
    TCHAR szMac[33];

    ZeroMemory((void *) &mac, sizeof(mac));
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, _T("CLSID\\{32b9f4be-3472-11d1-927d-00c04fc2db04}"),0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE, NULL, &hkey, &disposition) && hkey)
    {
        DWORD cbSize = sizeof(mac);
        DWORD type = 0;

        if(!(ERROR_SUCCESS == RegQueryValueEx(hkey, szGUID, 0, &type, (LPBYTE) &mac, &cbSize) &&
            type == REG_BINARY &&
            cbSize == sizeof(mac)))
        {
            ZeroMemory((void *) &mac, sizeof(mac));
        }

        RegCloseKey(hkey);
    }

    bool fValid = false;
    for(i = 0; i < 16; i++)
    {
        rgbBytes[i] = ((LPBYTE) &mac)[i] ^ 0xA3;
        if(rgbBytes[i] != 0xA3)
            fValid = true;
        ZoneFormatMessage(_T("%1!02X!"), szMac + 2 * i, 3, rgbBytes[i]);
    }

    if(!fValid)
    {
        szMac[0] = _T('0');
        szMac[1] = _T('\0');
    }

    // put it all together - three ways depending on server switch
    TCHAR szPrelim[ZONE_MaxString];

    long eStats = zProxyMillStatsUnknown;
    pIDS->GetLong(key_StatsAbility, &eStats);

    if(eStats == zProxyMillStatsAll)
    {
        if(!ZoneFormatMessage(_T("GM=%1&ID=%2!d!&AL=%3!04X!&SL=%4!04X!&UL=%5!04X!&ZL=%6!04X!&Z=%7!d!&Y=%8&X=%9&W=%10&V=%11&U=%12!08X!&T=%13!02X!&S=%14!08X!&R=%15"),
            szPrelim, NUMELEMENTS(szPrelim),
            szGameAbbr,
            nContext,
            LANGIDFROMLCID(ZoneShell()->GetApplicationLCID()),
            GetSystemDefaultLangID(),
            GetUserDefaultLangID(),
            LANGIDFROMLCID(lcid),
            tzInfo.Bias,
            szSysParam,
            szAdCount,
            szGameCount,
            szUseCount,
            m_nFirstLaunch,
            dwSettings,
            dwVersion,
            szMac))
            return E_FAIL;
    }
    else
        if(eStats == zProxyMillStatsMost)
        {
            if(!ZoneFormatMessage(_T("GM=%1&ID=%2!d!&AL=%3!04X!&SL=%4!04X!&UL=%5!04X!&ZL=%6!04X!&Z=%7!d!&X=%8&W=%9&V=%10&U=%11!08X!&T=%12!02X!&S=%13!08X!&R=%14"),
                szPrelim, NUMELEMENTS(szPrelim),
                szGameAbbr,
                nContext,
                LANGIDFROMLCID(ZoneShell()->GetApplicationLCID()),
                GetSystemDefaultLangID(),
                GetUserDefaultLangID(),
                LANGIDFROMLCID(lcid),
                tzInfo.Bias,
                szAdCount,
                szGameCount,
                szUseCount,
                m_nFirstLaunch,
                dwSettings,
                dwVersion,
                szMac))
                return E_FAIL;
        }
        else
        {
            ASSERT(eStats == zProxyMillStatsMinimal);
            if(!ZoneFormatMessage(_T("GM=%1&ID=%2!d!&AL=%3!04X!&S=%4!08X!"),
                szPrelim, NUMELEMENTS(szPrelim),
                szGameAbbr,
                nContext,
                LANGIDFROMLCID(ZoneShell()->GetApplicationLCID()),
                dwVersion))
                return E_FAIL;
        }


    //
    // Checksum (Q)
    DWORD acc = 0;
    WORD w;
    i = 0;
    while(true)
    {
        if(!szPrelim[i])
            break;
        ASSERT(!(szPrelim[i] & 0xff00));

        w = szPrelim[i] << 8;

        i++;
        ASSERT(!(szPrelim[i] & 0xff00));
        if(!szPrelim[i])
            w |= 'J';
        else
            w |= szPrelim[i];

        acc += w;

        if(!szPrelim[i])
            break;

        i++;
    }

    while(acc & 0xffff0000)
        acc = (acc & 0x0000ffff) + ((acc & 0xffff0000) >> 16);

    acc = (acc * 11) & 0x0000ffff;


    // final URL
    if(!ZoneFormatMessage(_T("%1&Q=%2!04X!"), buf, cch, szPrelim, acc))
        return E_FAIL;

    return S_OK;
}


STDMETHODIMP CMillEngine::IncrementCounter(long eCounter)
{
    if(eCounter < 0 || eCounter >= M_NumberOfCounters)
        return E_INVALIDARG;

    m_rgcCounters[eCounter][0]++;
    m_rgcCounters[eCounter][1]++;

    TCHAR szNumberKey[ZONE_MaxString];
    const TCHAR* arKeys[3] = { key_Lobby, key_Numbers, szNumberKey };
    ZoneFormatMessage(_T("Number%1!d!"), szNumberKey, NUMELEMENTS(szNumberKey), eCounter);
    DataStorePreferences()->SetLong(arKeys, 3, m_rgcCounters[eCounter][0]);

    return S_OK;
}


STDMETHODIMP CMillEngine::ResetCounter(long eCounter)
{
    if(eCounter < 0 || eCounter >= M_NumberOfCounters)
        return E_INVALIDARG;

    m_rgcCounters[eCounter][0] = 0;
    m_rgcCounters[eCounter][1] = 0;

    TCHAR szNumberKey[ZONE_MaxString];
    const TCHAR* arKeys[3] = { key_Lobby, key_Numbers, szNumberKey };
    ZoneFormatMessage(_T("Number%1!d!"), szNumberKey, NUMELEMENTS(szNumberKey), eCounter);
    DataStorePreferences()->SetLong(arKeys, 3, m_rgcCounters[eCounter][0]);

    return S_OK;
}


STDMETHODIMP_(DWORD) CMillEngine::GetCounter(long eCounter, bool fLifetime)
{
    if(eCounter < 0 || eCounter >= M_NumberOfCounters)
        return 0;

    return m_rgcCounters[eCounter][fLifetime ? 0 : 1];
}


STDMETHODIMP CMillEngine::WriteTime(long nMinutes, TCHAR *sz, DWORD cch)
{
    TCHAR szFormat[ZONE_MAXSTRING];

    if(nMinutes > 90)
    {
        if(!ResourceManager()->LoadString(IDS_HOURS, szFormat, NUMELEMENTS(szFormat)))
            return E_FAIL;

        nMinutes = (nMinutes + 10) / 60;
    }
    else
        if(!ResourceManager()->LoadString(IDS_MINUTES, szFormat, NUMELEMENTS(szFormat)))
            return E_FAIL;

    if(nMinutes < 2)
        nMinutes = 2;

    if(!ZoneFormatMessage(szFormat, sz, cch, nMinutes))
        return E_FAIL;

    return S_OK;
}


// internal utils

void CMillEngine::InitializeMHZTimer()
{
    __int64 *pmhzTimerMHZ = &m_mhzTimerMHZ;

	__asm
	{
		pushfd							; push extended flags
		pop		eax						; store eflags into eax
		mov		ebx, eax				; save EBX for testing later
		xor		eax, (1<<21)			; switch bit 21
		push	eax						; push eflags
		popfd							; pop them again
		pushfd							; push extended flags
		pop		eax						; store eflags into eax
		cmp		eax, ebx				; see if bit 21 has changed
		jz		no_cpuid				; make sure it's now on
	}

    m_msecTimerMHZ = -(int)timeGetTime();

	__asm
	{
		mov		ecx, pmhzTimerMHZ		; get the offset
		mov		dword ptr [ecx], 0		; zero the memory
		mov		dword ptr [ecx+4], 0	;
		rdtsc							; read time-stamp counter
		sub		[ecx], eax				; store the negative
		sbb		[ecx+4], edx			; in the variable
	}

    m_fTimingMHZ = true;
    return;

no_cpuid:
    m_fTimingMHZ = false;
}


DWORD CMillEngine::GetMHZTimer()
{
    if(!m_fTimingMHZ)
        return 0;

    __int64 mhz = m_mhzTimerMHZ;
    __int64 *pmhz = &mhz;

    DWORD msec = (DWORD) (m_msecTimerMHZ + (int)timeGetTime());

	__asm
	{
		mov		ecx, pmhz   			; get the offset
		rdtsc							; read time-stamp counter
		add		[ecx], eax				; add the tick count
		adc		[ecx+4], edx			;
	}

	float fSpeed = ((float) mhz) / ((float) msec * 1000.0f);
    int iQuantums = (int) ((fSpeed / 16.66666666666666666666667f) + 0.5f);

    return (iQuantums * 4267) >> 8;    // 4267 = 16.66666666666666666666667 << 8
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\networkmanager\cnetworkmanager.cpp ===
#include <BasicATL.h>
#include "CNetworkManager.h"
#include "protocol.h"


CNetworkManager::CNetworkManager() :
	m_hThreadHandler( NULL ),
	m_hEventStop( NULL )
{
}


CNetworkManager::~CNetworkManager()
{
	ASSERT( m_hEventStop == NULL );
	ASSERT( m_hThreadHandler == NULL );
    ASSERT(!m_fRunning);
}


STDMETHODIMP CNetworkManager::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// chain to base class
	HRESULT hr = IZoneShellClientImpl<CNetworkManager>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

	// initialize stop event
	m_hEventStop = CreateEvent( NULL, TRUE, FALSE, NULL );
	if ( !m_hEventStop )
		return E_FAIL;

	// initialize network object
	hr = _Module.Create( _T("znetm.dll"), CLSID_Network, IID_INetwork, (void**) &m_pNet );
	if ( FAILED(hr) )
	{
		ASSERT( !_T("Unable to create network object") );
		return hr;
	}

	return InitNetwork();
}


HRESULT CNetworkManager::InitNetwork()
{
	HRESULT hr = m_pNet->Init( FALSE, TRUE );
	if ( FAILED(hr) )
	{
		ASSERT( !_T("Unable to initialize network object") );
		m_pNet.Release();
		return hr;
	}

    // set options
    ZNETWORK_OPTIONS oOpt;

    m_pNet->GetOptions(&oOpt);

    oOpt.ProductSignature = zProductSigMillennium;
    if(oOpt.KeepAliveInterval > 10000)
        oOpt.KeepAliveInterval = 10000;

    m_pNet->SetOptions(&oOpt);

	// initialize network thread
	DWORD dwThreadId;
	m_hThreadHandler = CreateThread( NULL, 0, ThreadProcHandler, this, 0, &dwThreadId );
	if ( !m_hThreadHandler )
		return E_FAIL;

    return S_OK;
}


STDMETHODIMP CNetworkManager::Close()
{
    StopNetwork();

	// clean up event
	if ( m_hEventStop )
	{
		CloseHandle( m_hEventStop );
		m_hEventStop = NULL;
	}

	// chain to base close
	return IZoneShellClientImpl<CNetworkManager>::Close();
}


void CNetworkManager::StopNetwork()
{
	// signal shutdown to thread
	if ( m_hEventStop  )
		SetEvent( m_hEventStop );

	// close connection
	if ( m_pConnection )
	{
		m_pNet->CloseConnection( m_pConnection );
		ASSERT(!m_pConnection);  // should have been released on close
	}

	// shutdown network library
	if ( m_pNet )
		m_pNet->Exit();

	// close handler thread
	if ( m_hThreadHandler )
	{
		if ( WaitForSingleObject( m_hThreadHandler, 10000 ) == WAIT_TIMEOUT )
			TerminateThread( m_hThreadHandler, 0 );
		CloseHandle( m_hThreadHandler );
		m_hThreadHandler = NULL;
	}
}


void CNetworkManager::OnDoConnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    ASSERT(m_fRunning);

	// start connect thread
	if ( !m_pNet->QueueAPCResult( ConnectFunc, this ) )
		EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_NETWORK_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, EventNetworkCloseConnectFail, 0 );
}


void CNetworkManager::OnNetworkSend( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, void* pData, DWORD cbData )
{
	// ignore if network not initialized
	if ( !m_pNet || !m_pConnection )
		return;

	// send message
	EventNetwork* p = (EventNetwork*) pData;
	m_pConnection->Send( p->dwType, p->pData, p->dwLength, dwGroupId, dwUserId );
}


void CNetworkManager::OnDoDisconnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
	// close connection
	if ( m_pConnection )
	{
		m_pNet->CloseConnection( m_pConnection );
		m_pConnection.Release();
	}
}


void CNetworkManager::OnReset( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    if(!m_pNet)
        return;

    StopNetwork();
    m_pNet->ShutDown();
    if(m_hEventStop)
        ResetEvent(m_hEventStop);
    InitNetwork();    
}


DWORD WINAPI CNetworkManager::ThreadProcHandler( void* lpParameter )
{
	CNetworkManager* pThis = (CNetworkManager*) lpParameter;
	pThis->m_pNet->Wait( NULL, pThis, QS_ALLINPUT );
	return 0;
}


void __stdcall CNetworkManager::ConnectFunc(void* data)
{
    USES_CONVERSION;
	CNetworkManager* pThis = (CNetworkManager*) data;
	TCHAR	szServer[128];
//	TCHAR	szInternal[128];
	DWORD	cbServer = sizeof(szServer);
//	DWORD	cbInternal = sizeof(szInternal);
//	long	lPort = 0;

	// get server, port, and internal name
	CComPtr<IDataStore> pIDS;
	HRESULT hr = pThis->LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if ( FAILED(hr) )
		return;
	pIDS->GetString( key_Server, szServer, &cbServer );
//	pIDS->GetString( key_InternalName, szInternal, &cbInternal );
//	pIDS->GetLong( key_Port, &lPort );
	pIDS.Release();

	// establish connection
	int32 ports[] = { zPortMillenniumProxy, 6667, 0 };

    if ( WaitForSingleObject( pThis->m_hEventStop, 0 ) == WAIT_OBJECT_0 )
		return;
	pThis->m_pConnection = pThis->m_pNet->CreateSecureClient(
		T2A(szServer), ports, NetworkFunc, NULL, pThis,
		NULL, NULL, NULL, ZNET_NO_PROMPT);

    if ( pThis->m_pConnection )
        return;

	// connection failed
	pThis->EventQueue()->PostEvent(
				PRIORITY_NORMAL, EVENT_NETWORK_DISCONNECT,
				ZONE_NOGROUP, ZONE_NOUSER, EventNetworkCloseConnectFail, 0 );
}


void __stdcall CNetworkManager::NetworkFunc( IConnection* con, DWORD event, void* userData )
{
    USES_CONVERSION;
	CNetworkManager* pThis = (CNetworkManager*) userData;

	switch (event)
	{
		case zSConnectionOpen:
		{
			// retrieve user name
			char szUserName[ZONE_MaxUserNameLen];
			con->GetUserName( szUserName );

			// get lobby's data store
			CComPtr<IDataStore> pIDS;
			pThis->LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );

			// save user name
			const TCHAR* arKeys[] = { key_User, key_Name };
			pIDS->SetString( arKeys, 2, A2T( szUserName ) );

			// save server ip address
			pIDS->SetLong( key_ServerIp, con->GetRemoteAddress() );

			// tell reset of lobby we're connected
			pThis->EventQueue()->PostEvent(
						PRIORITY_NORMAL, EVENT_NETWORK_CONNECT,
						ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
			break;
		}

		case zSConnectionClose:
		{
			// determine reason and send to rest of lobby
			long lReason = EventNetworkCloseFail;
            if(pThis->m_pConnection)
            {
			    switch ( con->GetAccessError() )
			    {
			    case zAccessGranted:
				    lReason = EventNetworkCloseNormal;
				    break;
			    case zAccessDeniedGenerateContextFailed:
				    lReason = EventNetworkCloseCanceled;
				    break;
			    }

			    // clean up connection
			    pThis->m_pConnection.Release();
			    pThis->m_pNet->DeleteConnection( con );
            }

			pThis->EventQueue()->PostEvent(
					PRIORITY_NORMAL, EVENT_NETWORK_DISCONNECT,
					ZONE_NOGROUP, ZONE_NOUSER, lReason, 0 );
			break;
		}

		case zSConnectionMessage:
		{
			// get network message
			DWORD dwType = 0;
			DWORD dwLen = 0;
            DWORD dwSig = 0;
            DWORD dwChannel = 0;
			BYTE* pMsg = (BYTE*) con->Receive( &dwType, (long*) &dwLen, &dwSig, &dwChannel );

			// convert message to EventNetwork and send to rest of lobby
			EventNetwork* pEventNetwork = (EventNetwork*) _alloca( sizeof(EventNetwork) + dwLen );
			pEventNetwork->dwType = dwType;
			pEventNetwork->dwLength = dwLen;
			CopyMemory( pEventNetwork->pData, pMsg, dwLen );
			pThis->EventQueue()->PostEventWithBuffer(
						PRIORITY_NORMAL, EVENT_NETWORK_RECEIVE,
						dwSig, dwChannel, pEventNetwork, sizeof(EventNetwork) + dwLen );

			break;
		}

		case zSConnectionTimeout:
		{
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millnetworkcore\cmillnetworkcore.h ===
#include "ZoneDef.h"
#include "ZoneError.h"
#include "LobbyDataStore.h"
#include "ClientImpl.h"
#include "ZoneShell.h"
#include "EventQueue.h"
#include "Queue.h"
#include "MillNetworkCore.h"
#include "Conduit.h"
#include "proxymsg.h"
#include "zgameinfo.h"


class ATL_NO_VTABLE CMillNetworkCore :
    public IConduit,
    public IConnectee,
	public IZoneShellClientImpl<CMillNetworkCore>,
	public IEventClient,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMillNetworkCore, &CLSID_MillNetworkCore>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMillNetworkCore)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IConduit)
	END_COM_MAP()


// CEventQueue
public:
	ZONECALL CMillNetworkCore();
	ZONECALL ~CMillNetworkCore();

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

// IEventClient
public:
	STDMETHOD(ProcessEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2,
		void*	pCookie );

// IConnectee
public:
    STDMETHOD(Connected)(DWORD dwChannel, DWORD evSend, DWORD evReceive, LPVOID pCookie, DWORD dweReason);
    STDMETHOD(ConnectFailed)(LPVOID pCookie, DWORD dweReason);
    STDMETHOD(Disconnected)(DWORD dwChannel, DWORD dweReason);

// IConduit
public:
    STDMETHOD(Connect)(IConnectee *pCtee, LPVOID pCookie = NULL);
    STDMETHOD(Reconnect)(DWORD dwChannel, LPVOID pCookie = NULL);
    STDMETHOD(Disconnect)(DWORD dwChannel);

// internals
private:

	// network functions
	void NetworkSend( DWORD dwType, char* pBuff, DWORD cbBuff );
	void ProcessMessage( EventNetwork* pEvent, DWORD dwLength );
    void DisconnectLobby(bool fStopped = false);
    void SendConnectRequest();
    void SendDisconnectRequest();
    void UpdateServerString();

    void HandleProxyHello(char *pBuffer, DWORD dwLen);
    void HandleServiceInfo(char *pBuffer, DWORD dwLen);
    void HandleIntakeServiceInfo(ZProxyServiceInfoMsg *pIntake, bool fConnectNeeded = false);

    // intake information
    bool m_fIntakeRemote;
    IN_ADDR m_ipIntake;

    DWORD m_eState;
    bool m_fZoneConnected;
    WORD m_wMyChannelPart;

    // lobby states - filled in when state is not Unconnected
    DWORD m_eLobbyState;
    void *m_pCookie;
    CComPtr<IConnectee> m_pCtee;

    DWORD m_evSend;
    DWORD m_evReceive;
    DWORD m_dwLobbyChannel;
    char m_szLobbyService[GAMEINFO_INTERNAL_NAME_LEN + 1];
    char m_szIntakeService[GAMEINFO_INTERNAL_NAME_LEN + 1];

    TCHAR m_szServers[ZONE_MaxString];

    CComPtr<IConduit> m_pConduit;
};


// proxy states
enum
{
    Proxy_Unconnected,
    Proxy_SocketWait,
    Proxy_HelloWait,
    Proxy_Standby,
    Proxy_ConnectWait,
    Proxy_Connected,
    Proxy_ConnectFail,
    Proxy_RedirectWait,
    Proxy_PauseWait,
    Proxy_Paused,
    Proxy_ReconnectWait
};


// lobby states
enum
{
    Lobby_Unconnected,
    Lobby_ConnectWait,
    Lobby_Connected
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\proxyidl\guids.c ===
//
// Stupid build environment doesn't know how to
// compile a file in a different directory.
//
#include "ZoneProxy_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\proxyidl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZoneProxy.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\physicalnetwork\cphysicalnetwork.cpp ===
#include "CPhysicalNetwork.h"


STDMETHODIMP CPhysicalNetwork::Close()
{
    if(m_fConnected)
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_NETWORK_DO_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);

    m_fAvailable = false;
    DoDisconnectNotify();

	return IZoneShellClientImpl<CPhysicalNetwork>::Close();
}


// IConduit
STDMETHODIMP CPhysicalNetwork::Connect(IConnectee *pCtee, LPVOID pCookie)
{
    if(!m_fRunning)
        return E_FAIL;

    if(!pCtee)
        return E_INVALIDARG;

    // no multiple connections
    if(!m_fAvailable)
        return E_NOTIMPL;

    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_NETWORK_DO_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    m_fAvailable = false;
    m_pCtee = pCtee;
    m_pCookie = pCookie;
    return S_OK;
}

STDMETHODIMP CPhysicalNetwork::Reconnect(DWORD dwChannel, LPVOID pCookie)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_fAvailable || dwChannel != mc_dwChannel || !m_pCtee)
        return S_FALSE;

    // not sure what to do here... not allowing this for now
    if(!m_fConnected || m_fReconnecting)
        return S_FALSE;

    m_fReconnecting = true;
    m_pCookie = pCookie;
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_NETWORK_DO_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return S_OK;
}

STDMETHODIMP CPhysicalNetwork::Disconnect(DWORD dwChannel)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_fAvailable || dwChannel != mc_dwChannel)
        return S_FALSE;

    if(m_fReconnecting)
        // just let it fail
        m_fReconnecting = false;
    else
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_NETWORK_DO_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return S_OK;
}


// event handlers
void CPhysicalNetwork::OnConnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    m_fConnected = true;
    if(m_pCtee)
        m_pCtee->Connected(mc_dwChannel, EVENT_NETWORK_SEND, EVENT_NETWORK_RECEIVE, m_pCookie, ZConduit_ConnectGeneric);
}

void CPhysicalNetwork::OnDisconnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId )
{
    if(m_fReconnecting)
    {
        m_fReconnecting = false;
        m_fConnected = false;
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_NETWORK_DO_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        return;
    }

    m_fAvailable = true;
    DoDisconnectNotify();
}


// internal
void CPhysicalNetwork::DoDisconnectNotify()
{
    IConnectee *pCtee = m_pCtee;
    LPVOID pCookie = m_pCookie;
    bool fConnected = m_fConnected;

    m_pCtee = NULL;
    m_pCookie = NULL;
    m_fConnected = false;

    if(pCtee)
        if(fConnected && !m_fReconnecting)
            pCtee->Disconnected(mc_dwChannel, ZConduit_DisconnectGeneric);
        else
            pCtee->ConnectFailed(pCookie, ZConduit_FailGeneric);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\networkmanager\cnetworkmanager.h ===
//
// CNetworkManager.h
//
// Internal header for network manager
//

#ifndef _CNETWORKMANAGER_H_
#define _CNETWORKMANAGER_H_

#include <ZoneDef.h>
#include <ClientImpl.h>
#include <ClientIDL.h>
#include <ZNet.h>

class ATL_NO_VTABLE CNetworkManager :
	public IZoneShellClientImpl<CNetworkManager>,
	public IEventClientImpl<CNetworkManager>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNetworkManager, &CLSID_NetworkManager>
{
public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CNetworkManager)
		COM_INTERFACE_ENTRY(IEventClient)
		COM_INTERFACE_ENTRY(IZoneShellClient)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
		EVENT_HANDLER( EVENT_NETWORK_DO_CONNECT, OnDoConnect );
		EVENT_HANDLER_WITH_BUFFER( EVENT_NETWORK_SEND, OnNetworkSend );
        EVENT_HANDLER( EVENT_NETWORK_DO_DISCONNECT, OnDoDisconnect );
        EVENT_HANDLER( EVENT_NETWORK_RESET, OnReset );
	END_EVENT_MAP()

	// event handlers
	void OnDoConnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId );
	void OnNetworkSend( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId, void* pData, DWORD cbData );
	void OnDoDisconnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId );
	void OnReset( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId );

	
// CNetworkManager
public:
	CNetworkManager();
	~CNetworkManager();

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

private:
	static DWORD WINAPI	ThreadProcHandler( void* lpParameter );
	static void __stdcall NetworkFunc( IConnection* con, DWORD event,void* userData );
	static void __stdcall ConnectFunc(void* data);

    HRESULT InitNetwork();
    void StopNetwork();

	HANDLE	m_hThreadHandler;
	HANDLE	m_hEventStop;
	CComPtr<INetwork>		m_pNet;
	CComPtr<IConnection>	m_pConnection;
};

#endif //!_CNETWORKMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\millnetworkcore\cmillnetworkcore.cpp ===
#include <BasicATL.h>
#include <ZoneResource.h>
#include <ZoneEvent.h>
#include <ZoneString.h>
#include <ZoneProxy.h>
#include <KeyName.h>
#include <OpName.h>
#include <CommonMsg.h>
#include <Protocol.h>
#include <ProxyMsg.h>

#include "CMillNetworkCore.h"


///////////////////////////////////////////////////////////////////////////////
// CMillNetworkCore
///////////////////////////////////////////////////////////////////////////////

ZONECALL CMillNetworkCore::CMillNetworkCore() :
    m_eState(Proxy_Unconnected),
    m_fIntakeRemote(false),
    m_eLobbyState(Lobby_Unconnected),
    m_fZoneConnected(false),
    m_wMyChannelPart(1)
{
}


ZONECALL CMillNetworkCore::~CMillNetworkCore()
{
}


STDMETHODIMP CMillNetworkCore::ProcessEvent(
	DWORD	dwPriority,
	DWORD	dwEventId,
	DWORD	dwGroupId,
	DWORD	dwUserId,
	DWORD	dwData1,
	DWORD	dwData2,
	void*	pCookie )
{
    USES_CONVERSION;

    if(dwEventId == m_evReceive && dwGroupId == zProtocolSigProxy && !dwUserId)
	    ProcessMessage((EventNetwork*) dwData1, dwData2);

    HRESULT hr;
	switch(dwEventId)
	{
        case EVENT_ZONE_DO_CONNECT:
            if(m_eState != Proxy_Unconnected)
                break;
            ASSERT(!m_fZoneConnected);
            m_eState = Proxy_SocketWait;
            hr = m_pConduit->Connect(this);
            ASSERT(SUCCEEDED(hr));
            break;

        case EVENT_LOBBY_BOOTSTRAP:
            // get intake name and server names
            lstrcpy(m_szServers, _T("localhost"));
            m_szIntakeService[0] = '\0';

            CComPtr<IDataStore> pIDS;
	        hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	        if(FAILED(hr))
	            return S_OK;

	        TCHAR szInternal[ZONE_MaxString];
            DWORD dwLen = NUMELEMENTS(szInternal);
            hr = pIDS->GetString( key_InternalName, szInternal, &dwLen );
            if(FAILED(hr))
	            return S_OK;
            lstrcpynA(m_szIntakeService, T2A(szInternal), NUMELEMENTS(m_szIntakeService));

            dwLen = NUMELEMENTS(szInternal);
            hr = pIDS->GetString( key_Server, szInternal, &dwLen );
            if(FAILED(hr))
	            return S_OK;
            lstrcpyn(m_szServers, szInternal, NUMELEMENTS(m_szServers));
            UpdateServerString();
            break;
	}

	return S_OK;
}


STDMETHODIMP CMillNetworkCore::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CMillNetworkCore>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

    // now hook up to the conduit specified in object.txt
	GUID	srvid;
    TCHAR szConduit[ZONE_MAXSTRING];
    DWORD cb = NUMELEMENTS(szConduit);
    hr = DataStoreConfig()->GetString(GetDataStoreKey() + key_conduit, szConduit, &cb);
    if ( FAILED(hr) )
        return hr;
	StringToGuid( szConduit, &srvid );
    if ( srvid == GUID_NULL )
        return E_FAIL;
    hr = ZoneShell()->QueryService(srvid, IID_IConduit, (void**) &m_pConduit);
    if(FAILED(hr))
        return hr;

	return S_OK;
}


STDMETHODIMP CMillNetworkCore::Close()
{
    if(m_eLobbyState != Lobby_Unconnected)
        DisconnectLobby();

    if(m_pConduit)
        m_pConduit.Release();

	// release ZoneShell objects
	return IZoneShellClientImpl<CMillNetworkCore>::Close();
}


void CMillNetworkCore::NetworkSend( DWORD dwType, char* pBuff, DWORD cbBuff )
{
    if(m_eState != Proxy_HelloWait && m_eState != Proxy_ConnectWait && m_eState != Proxy_ConnectFail &&
        m_eState != Proxy_Connected && m_eState != Proxy_Standby && m_eState != Proxy_ReconnectWait)
        return;

	// convert message to EventNetwork and send to rest of lobby
	EventNetwork* pEventNetwork = (EventNetwork*) _alloca( sizeof(EventNetwork) + cbBuff );
	pEventNetwork->dwType = dwType;
	pEventNetwork->dwLength = cbBuff;
	CopyMemory( pEventNetwork->pData, pBuff, cbBuff );
	EventQueue()->PostEventWithBuffer(
			PRIORITY_NORMAL, m_evSend,
			zProtocolSigProxy, 0, pEventNetwork, sizeof(EventNetwork) + cbBuff );
}


void CMillNetworkCore::DisconnectLobby(bool fStopped)
{
    ASSERT(m_eLobbyState != Lobby_Unconnected);
    if(m_eLobbyState == Lobby_Unconnected)
        return;

    ASSERT(m_pCtee);
    if(m_eLobbyState == Lobby_ConnectWait)
        m_pCtee->ConnectFailed(m_pCookie, ZConduit_FailGeneric);
    else
        m_pCtee->Disconnected(m_dwLobbyChannel, fStopped ? ZConduit_DisconnectServiceStop : ZConduit_DisconnectGeneric);

    m_pCtee.Release();
    m_pCookie = NULL;

    m_eLobbyState = Lobby_Unconnected;
}


///////////////////////////////////////////////////////////////////////////////
// Proxy messages
///////////////////////////////////////////////////////////////////////////////

void CMillNetworkCore::ProcessMessage(EventNetwork* pEvent, DWORD dwLength)
{
    if(m_eState != Proxy_HelloWait && m_eState != Proxy_ConnectWait && m_eState != Proxy_ConnectFail &&
        m_eState != Proxy_Connected && m_eState != Proxy_Standby && m_eState != Proxy_ReconnectWait)
        return;

	DWORD dwType = pEvent->dwType;
	DWORD dwLen = pEvent->dwLength;
	char* pBuffer = (char *) pEvent->pData;

    ZProxyMsgHeader *pMsg = (ZProxyMsgHeader *) pBuffer;

    // for proxy messages, the dwType is the number of sub-messages
    if(!dwType || dwLen < sizeof(*pMsg))
    {
        m_pConduit->Disconnect(0);
        return;
    }

    // we might just be handshaking still
    // there are three possibilities here - a Hello, a Goodbye, or a WrongVersion
    if(m_eState == Proxy_HelloWait)
    {
        switch(pMsg->weType)
        {
            case zProxyHelloMsg:
                if(dwType != 3)  // must be a package of Hello, MillSettings, and ServiceInfo
                {
                    m_pConduit->Disconnect(0);
                    return;
                }
                HandleProxyHello(pBuffer, dwLen);
                break;

            case zProxyWrongVersionMsg:
                if(dwType == 1 && dwLen >= sizeof(ZProxyWrongVersionMsg))
                    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_ZONE_VERSION_FAIL, ZONE_NOGROUP, ZONE_NOUSER, pMsg, dwLen);
                m_pConduit->Disconnect(0);
                break;

            default:  // also when Goodbye
                m_pConduit->Disconnect(0);
                break;
        }

        return;
    }

    if(dwType > 2 || dwLen < (sizeof(ZProxyServiceInfoMsg) * dwType) || pMsg->weType != zProxyServiceInfoMsg || pMsg->wLength < sizeof(ZProxyServiceInfoMsg))
    {
        m_pConduit->Disconnect(0);
        return;
    }

    if(dwType == 1)  // must be just an intake ServiceInfo
        HandleIntakeServiceInfo((ZProxyServiceInfoMsg *) pBuffer);
    else
        HandleServiceInfo(pBuffer, dwLen);
}


void CMillNetworkCore::HandleProxyHello(char *pBuffer, DWORD dwLen)
{
    ZProxyHelloMsg *pHello = (ZProxyHelloMsg *) pBuffer;
    if(dwLen < sizeof(ZProxyHelloMsg) || pHello->oHeader.wLength < sizeof(ZProxyHelloMsg) || pHello->oHeader.wLength > dwLen)
    {
        m_pConduit->Disconnect(0);
        return;
    }
    pBuffer += pHello->oHeader.wLength;
    dwLen -= pHello->oHeader.wLength;

    ZProxyMillSettingsMsg *pSettings = (ZProxyMillSettingsMsg *) pBuffer;
    if(dwLen < sizeof(ZProxyMillSettingsMsg) || pSettings->oHeader.wLength < sizeof(ZProxyMillSettingsMsg) || pSettings->oHeader.wLength > dwLen)
    {
        m_pConduit->Disconnect(0);
        return;
    }
    pBuffer += pSettings->oHeader.wLength;
    dwLen -= pSettings->oHeader.wLength;

    ZProxyServiceInfoMsg *pIntake = (ZProxyServiceInfoMsg *) pBuffer;
    if(dwLen < sizeof(ZProxyServiceInfoMsg) || pIntake->oHeader.wLength < sizeof(ZProxyServiceInfoMsg) || pIntake->oHeader.wLength > dwLen)
    {
        m_pConduit->Disconnect(0);
        return;
    }

    if(pHello->oHeader.weType != zProxyHelloMsg || pSettings->oHeader.weType != zProxyMillSettingsMsg || pIntake->oHeader.weType != zProxyServiceInfoMsg)
    {
        m_pConduit->Disconnect(0);
        return;
    }

    if((pSettings->weChat != zProxyMillChatFull && pSettings->weChat != zProxyMillChatRestricted && pSettings->weChat != zProxyMillChatNone) ||
        (pSettings->weStatistics != zProxyMillStatsAll && pSettings->weStatistics != zProxyMillStatsMost && pSettings->weStatistics != zProxyMillStatsMinimal))
    {
        m_pConduit->Disconnect(0);
        return;
    }

    CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if(SUCCEEDED(hr))
    {
        pIDS->SetLong(key_ChatAbility, pSettings->weChat);
        pIDS->SetLong(key_StatsAbility, pSettings->weStatistics);
    }

    if(!m_fZoneConnected)
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ZONE_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    m_fZoneConnected = true;

    m_eState = Proxy_ConnectWait;
    HandleIntakeServiceInfo(pIntake);
}


void CMillNetworkCore::HandleServiceInfo(char *pBuffer, DWORD dwLen)
{
    bool fConnectNeeded = false;

    ZProxyServiceInfoMsg *pService = (ZProxyServiceInfoMsg *) pBuffer;
    if(dwLen < sizeof(ZProxyServiceInfoMsg) || pService->oHeader.wLength < sizeof(ZProxyServiceInfoMsg) || pService->oHeader.wLength > dwLen)
    {
        m_pConduit->Disconnect(0);
        return;
    }
    pBuffer += pService->oHeader.wLength;
    dwLen -= pService->oHeader.wLength;

    ZProxyServiceInfoMsg *pIntake = (ZProxyServiceInfoMsg *) pBuffer;
    if(dwLen < sizeof(ZProxyServiceInfoMsg) || pIntake->oHeader.wLength < sizeof(ZProxyServiceInfoMsg) || pIntake->oHeader.wLength > dwLen)
    {
        m_pConduit->Disconnect(0);
        return;
    }

    switch(pService->dweReason)
    {
        case zProxyServiceConnect:
            if(m_eState != Proxy_ConnectWait)
            {
                m_pConduit->Disconnect(0);
                return;
            }
            m_eState = Proxy_Connected;
            m_dwLobbyChannel = pService->dwChannel;
            lstrcpynA(m_szLobbyService, pService->szService, NUMELEMENTS(m_szLobbyService));
            ASSERT(m_eLobbyState != Lobby_Connected);
            if(m_eLobbyState == Lobby_ConnectWait)
            {
                ASSERT(m_pCtee);
                m_eLobbyState = Lobby_Connected;
                m_pCtee->Connected(m_dwLobbyChannel, m_evSend, m_evReceive, m_pCookie, ZConduit_ConnectGeneric);
            }
            break;

        case zProxyServiceDisconnect:  // also sent if connection failed
            if(m_eState == Proxy_ReconnectWait)  // this gets handled in the Intake handler
            {
                fConnectNeeded = true;
                m_eState = Proxy_ConnectWait;
                break;
            }

            // else fall through

        case zProxyServiceStop:
            if(m_eState != Proxy_ConnectWait && m_eState != Proxy_ReconnectWait &&
                (m_eState != Proxy_Connected ||
                pService->dwChannel != m_dwLobbyChannel || lstrcmpiA(m_szLobbyService, pService->szService)))
                break;

            if(m_eLobbyState != Lobby_Unconnected)
                DisconnectLobby(pService->dweReason == zProxyServiceStop);
            if(m_eState == Proxy_Connected)
                m_eState = Proxy_Standby;
            else
                m_eState = Proxy_ConnectFail;
            break;

        case zProxyServiceBroadcast:
            if(m_eState != Proxy_Connected || pService->dwChannel != m_dwLobbyChannel || lstrcmpiA(m_szLobbyService, pService->szService))
                break;

            if((pService->dwFlags & 0x0f) != 0x0f)
            {
                m_pConduit->Disconnect(0);
                return;
            }
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_GOING_DOWN, ZONE_NOGROUP, ZONE_NOUSER, pService->dwMinutesRemaining, 0);
            break;
    }

    HandleIntakeServiceInfo(pIntake, fConnectNeeded);
}


void CMillNetworkCore::HandleIntakeServiceInfo(ZProxyServiceInfoMsg *pIntake, bool fConnectNeeded)
{
    if((m_eState != Proxy_Standby && m_eState != Proxy_Connected && m_eState != Proxy_ConnectWait && m_eState != Proxy_ReconnectWait && m_eState != Proxy_ConnectFail) ||
        lstrcmpiA(pIntake->szService, m_szIntakeService))
    {
        m_pConduit->Disconnect(0);
        return;
    }

    CComPtr<IDataStore> pIDS;
	LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );

    if(!(pIntake->dwFlags & zProxyServiceAvailable))
    {
        if(pIDS)
        {
            pIDS->SetLong(key_ServiceUnavailable, TRUE);
            pIDS->SetLong(key_ServiceDowntime, pIntake->dwMinutesDowntime);
        }

        m_fIntakeRemote = false;
        UpdateServerString();

        if(m_eState == Proxy_ConnectWait || m_eState == Proxy_ReconnectWait || m_eState == Proxy_ConnectFail)
        {
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ZONE_UNAVAILABLE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            m_pConduit->Disconnect(0);
        }
        else
            if(m_eState == Proxy_Standby)
            {
                m_eState = Proxy_PauseWait;
                m_pConduit->Disconnect(0);
            }
    }
    else
    {
        if(pIDS)
        {
            pIDS->SetLong(key_ServiceUnavailable, FALSE);
            pIDS->SetLong(key_ServiceDowntime, 0);
        }

        if(!(pIntake->dwFlags & zProxyServiceLocal))
        {
            m_fIntakeRemote = true;
            m_ipIntake = pIntake->ox.ipAddress;
            UpdateServerString();

            // need to redirect
            if(m_eState == Proxy_ConnectWait || m_eState == Proxy_ReconnectWait || m_eState == Proxy_ConnectFail)
            {
                m_eState = Proxy_RedirectWait;
                HRESULT hr = m_pConduit->Reconnect(0);
                ASSERT(SUCCEEDED(hr));
            }
            else
                if(m_eState == Proxy_Standby)
                {
                    m_eState = Proxy_PauseWait;
                    m_pConduit->Disconnect(0);
                }
        }
        else
        {
            m_fIntakeRemote = false;
            UpdateServerString();
            if(fConnectNeeded)
            {
                ASSERT(m_eState == Proxy_ConnectWait);
                SendConnectRequest();
            }
        }
    }
}


void CMillNetworkCore::UpdateServerString()
{
    USES_CONVERSION;
    TCHAR szServer[ZONE_MaxString];

    if(m_fIntakeRemote)
    {
        lstrcpy(szServer, A2T(inet_ntoa(m_ipIntake)));
        lstrcat(szServer, _T(","));
    }
    else
        szServer[0] = 0;

    // append server names and put in data store
    lstrcat(szServer, m_szServers);
    CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	if(FAILED(hr))
	    return;
    pIDS->SetString(key_Server, szServer);
}


///////////////////////////////////////////////////////////////////////////////
// IConduit
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMillNetworkCore::Connect(IConnectee *pCtee, LPVOID pCookie)
{
    if(!m_fRunning || !m_fZoneConnected)
        return E_FAIL;

    if(!pCtee)
        return E_INVALIDARG;

    if(m_eLobbyState != Lobby_Unconnected)  // can't have two at the same time
        return E_NOTIMPL;

    m_eLobbyState = Lobby_ConnectWait;
    m_pCtee = pCtee;
    m_pCookie = pCookie;

    ASSERT(m_eState != Proxy_ReconnectWait);  // probably ignorable, just want to see if it comes up

    // if none of these, then it'll get handled on the transition
    switch(m_eState)
    {
        case Proxy_Unconnected:
        case Proxy_Paused:
        {
            m_eState = Proxy_SocketWait;
            HRESULT hr = m_pConduit->Connect(this);
            ASSERT(SUCCEEDED(hr));
            break;
        }

        case Proxy_Connected:
            m_eLobbyState = Lobby_Connected;
            m_pCtee->Connected(m_dwLobbyChannel, m_evSend, m_evReceive, m_pCookie, ZConduit_ConnectGeneric);
            break;

        case Proxy_Standby:
        case Proxy_ConnectFail:
            m_eState = Proxy_ConnectWait;
            SendConnectRequest();
            break;
    }

    return S_OK;
}

STDMETHODIMP CMillNetworkCore::Reconnect(DWORD dwChannel, LPVOID pCookie)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_eLobbyState != Lobby_Connected || dwChannel != m_dwLobbyChannel)
        return S_FALSE;

    m_eLobbyState = Lobby_ConnectWait;
    m_pCookie = pCookie;
    ASSERT(m_eState == Proxy_Connected);

    m_eState = Proxy_ReconnectWait;
    SendDisconnectRequest();

    return S_OK;
}

STDMETHODIMP CMillNetworkCore::Disconnect(DWORD dwChannel)
{
    if(!m_fRunning)
        return E_FAIL;

    if(m_eLobbyState != Lobby_Connected || dwChannel != m_dwLobbyChannel)
        return S_FALSE;

    ASSERT(m_eState == Proxy_Connected);

//  m_eState = Proxy_Standby;  should there be a disconnect-wait state?
    SendDisconnectRequest();

    return S_OK;
}


void CMillNetworkCore::SendConnectRequest()
{
    ZProxyServiceRequestMsg oMsg;

    oMsg.oHeader.weType = zProxyServiceRequestMsg;
    oMsg.oHeader.wLength = sizeof(oMsg);

    oMsg.dweReason = zProxyRequestConnect;
    lstrcpynA(oMsg.szService, m_szIntakeService, NUMELEMENTS(oMsg.szService));
    oMsg.dwChannel = (m_wMyChannelPart++) << 16;

    NetworkSend(1, (char *) &oMsg, sizeof(oMsg));
}


void CMillNetworkCore::SendDisconnectRequest()
{
    ZProxyServiceRequestMsg oMsg;

    oMsg.oHeader.weType = zProxyServiceRequestMsg;
    oMsg.oHeader.wLength = sizeof(oMsg);

    oMsg.dweReason = zProxyRequestDisconnect;
    lstrcpynA(oMsg.szService, m_szLobbyService, NUMELEMENTS(oMsg.szService));
    oMsg.dwChannel = m_dwLobbyChannel;

    NetworkSend(1, (char *) &oMsg, sizeof(oMsg));
}


///////////////////////////////////////////////////////////////////////////////
// IConnectee
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMillNetworkCore::Connected(DWORD dwChannel, DWORD evSend, DWORD evReceive, LPVOID pCookie, DWORD dweReason)
{
    USES_CONVERSION;

    if(!m_fRunning)
        return S_FALSE;

    ASSERT(!dwChannel);
    m_evSend = evSend;
    m_evReceive = evReceive;

    ASSERT(m_eState == Proxy_SocketWait || m_eState == Proxy_RedirectWait);
    m_eState = Proxy_HelloWait;

    // send Hi message
    char pBuffer[sizeof(ZProxyHiMsg) + sizeof(ZProxyMillIDMsg) + sizeof(ZProxyServiceRequestMsg)];
    ZProxyHiMsg *pHi = (ZProxyHiMsg *) pBuffer;
    ZProxyMillIDMsg *pID = (ZProxyMillIDMsg *) (pBuffer + sizeof(ZProxyHiMsg));
    ZProxyServiceRequestMsg *pService = (ZProxyServiceRequestMsg *) (pBuffer + sizeof(ZProxyHiMsg) + sizeof(ZProxyMillIDMsg));

    pHi->oHeader.weType = zProxyHiMsg;
    pHi->oHeader.wLength = sizeof(ZProxyHiMsg);

    pHi->dwProtocolVersion = zProxyProtocolVersion;
    pHi->dwClientVersion = 0;
    pHi->szSetupToken[0] = _T('\0');
    CComPtr<IDataStore> pIDS;
	LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
    if(pIDS)
    {
        const TCHAR *arKeys[] = { key_Version, key_VersionNum };
        pIDS->GetLong(arKeys, 2, (long *) &pHi->dwClientVersion);

        TCHAR szToken[ZONE_MAXSTRING] = _T("");
        arKeys[1] = key_SetupToken;
        DWORD cch = NUMELEMENTS(pHi->szSetupToken);
        pIDS->GetString(arKeys, 2, szToken, &cch);

        lstrcpynA(pHi->szSetupToken, T2A(szToken), NUMELEMENTS(pHi->szSetupToken));
    }

    pID->oHeader.weType = zProxyMillIDMsg;
    pID->oHeader.wLength = sizeof(ZProxyMillIDMsg);

    TIME_ZONE_INFORMATION tzInfo;
    GetTimeZoneInformation(&tzInfo);
    pID->wTimeZoneMinutes = (int16) tzInfo.Bias;

    pID->wSysLang = GetSystemDefaultLangID();
    pID->wUserLang = GetUserDefaultLangID();
    pID->wAppLang = LANGIDFROMLCID(ZoneShell()->GetApplicationLCID());

    pService->oHeader.weType = zProxyServiceRequestMsg;
    pService->oHeader.wLength = sizeof(ZProxyServiceRequestMsg);

    pService->dweReason = zProxyRequestConnect;
    lstrcpynA(pService->szService, m_szIntakeService, NUMELEMENTS(pService->szService));
    pService->dwChannel = (m_wMyChannelPart++) << 16;

    NetworkSend(3, pBuffer, NUMELEMENTS(pBuffer));

    return S_OK;
}

STDMETHODIMP CMillNetworkCore::ConnectFailed(LPVOID pCookie, DWORD dweReason)
{
    if(!m_fRunning)
        return S_FALSE;

    ASSERT(m_eState == Proxy_SocketWait || m_eState == Proxy_RedirectWait);

    m_eState = Proxy_Unconnected;
    if(!m_fZoneConnected)
    {
        ASSERT(m_eLobbyState == Lobby_Unconnected);
        EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_ZONE_CONNECT_FAIL, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
    }
    else
    {
        ASSERT(m_eLobbyState != Lobby_Connected);
        EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_ZONE_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );

        if(m_eLobbyState != Lobby_Unconnected)
            DisconnectLobby();
    }
    EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_NETWORK_RESET, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
    m_fZoneConnected = false;

    return S_OK;
}

STDMETHODIMP CMillNetworkCore::Disconnected(DWORD dwChannel, DWORD dweReason)
{
    if(!m_fRunning || dwChannel)
        return S_FALSE;

    switch(m_eState)
    {
        case Proxy_HelloWait:
        case Proxy_Standby:
        case Proxy_ConnectFail:
        case Proxy_ConnectWait:
        case Proxy_Connected:
        case Proxy_ReconnectWait:
            if(m_fZoneConnected)
            {
                EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_ZONE_DISCONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
                m_fZoneConnected = false;
            }
            else
            {
                ASSERT(m_eLobbyState == Lobby_Unconnected);
                EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_ZONE_CONNECT_FAIL, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            }
            EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_NETWORK_RESET, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            m_eState = Proxy_Unconnected;

            if(m_eLobbyState != Lobby_Unconnected)
                DisconnectLobby();

            break;

        case Proxy_PauseWait:
            ASSERT(m_eLobbyState != Lobby_Connected);
            m_eState = Proxy_Paused;

            if(m_eLobbyState == Lobby_ConnectWait)
            {
                m_eState = Proxy_SocketWait;
                HRESULT hr = m_pConduit->Connect(this);
                ASSERT(SUCCEEDED(hr));
            }
            break;

        default:
            ASSERT(false);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED_)
#define AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
#include <ZoneATL.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CZoneComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};


extern CExeModule _Module;

#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B5A42A14_F44B_11D2_8B66_00C04F8EF2FF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\physicalnetwork\cphysicalnetwork.h ===
#include "BasicATL.h"
#include "ClientImpl.h"
#include "Conduit.h"


///////////////////////////////////////////////////////////////////////////////
// CPhysicalNetwork
///////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPhysicalNetwork :
	public IConduit,
	public IZoneShellClientImpl<CPhysicalNetwork>,
    public IEventClientImpl<CPhysicalNetwork>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPhysicalNetwork, &CLSID_PhysicalNetwork>
{
// ATL definitions
public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CPhysicalNetwork)
		COM_INTERFACE_ENTRY(IConduit)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
	END_COM_MAP()

	BEGIN_EVENT_MAP()
		EVENT_HANDLER( EVENT_NETWORK_CONNECT, OnConnect );
        EVENT_HANDLER( EVENT_NETWORK_DISCONNECT, OnDisconnect );
	END_EVENT_MAP()


// IZoneShellClientImpl
public:
	STDMETHOD(Close)();

// IConduit
public:
    STDMETHOD(Connect)(IConnectee *pCtee, LPVOID pCookie = NULL);
    STDMETHOD(Reconnect)(DWORD dwChannel, LPVOID pCookie = NULL);
    STDMETHOD(Disconnect)(DWORD dwChannel);

// event handlers
private:
	void OnConnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId );
	void OnDisconnect( DWORD dwEventId, DWORD dwGroupId, DWORD dwUserId );

// internals
public:
	ZONECALL ~CPhysicalNetwork() { }
	ZONECALL CPhysicalNetwork() :
        m_fAvailable(true), m_fConnected(false), m_fReconnecting(false),
        m_pCtee(NULL), m_pCookie(NULL), mc_dwChannel(0) { }

    void DoDisconnectNotify();

protected:
    bool m_fAvailable;
    bool m_fConnected;
    bool m_fReconnecting;
    const DWORD mc_dwChannel;
    CComPtr<IConnectee> m_pCtee;
    LPVOID m_pCookie;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\stresscore.h ===
// StressCore.h : Declaration of the CStressCore

#ifndef __CLIENTCORE_H_
#define __CLIENTCORE_H_

#include "Resource.h"
#include "ZoneResource.h"
#include "zClient.h"
#include "OpName.h"
#include "EventQueue.h"
#include "ZoneShell.h"
#include "ZoneProxy.h"
#include "DataStore.h"
#include "LobbyDataStore.h"
#include "ZoneString.h"


///////////////////////////////////////////////////////////////////////////////
// Forward references
///////////////////////////////////////////////////////////////////////////////

class CStressCore;

///////////////////////////////////////////////////////////////////////////////
// Application global variables
///////////////////////////////////////////////////////////////////////////////

extern CStressCore*		gpCore;			// primary object
extern IEventQueue**		gppEventQueues;	// pointer to list of event queues
extern IZoneShell**        gppZoneShells;
extern TCHAR				gszLanguage[16];		// language extension
extern TCHAR				gszInternalName[128];	// internal name
extern TCHAR				gszFamilyName[128];		// family name
extern TCHAR				gszGameName[128];		// game name
extern TCHAR				gszGameCode[128];
extern TCHAR				gszServerName[128];		// server's ip address
extern DWORD				gdwServerPort;		// server's port
extern DWORD				gdwServerAnonymous;	// server's authentication

extern HINSTANCE			ghResourceDlls[32];		// resource dll array
extern int					gnResourceDlls;		// resource dll array count
extern HANDLE				ghEventQueue;	// event queue notification event
extern HANDLE              ghQuit;

extern DWORD               gnClients;
extern HANDLE              ghStressThread;
extern DWORD               gdwStressThreadID;

extern int                  grgnParameters[10];

///////////////////////////////////////////////////////////////////////////////
// CStressCore
///////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CStressCore : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStressCore, &CLSID_ZClient>,
	public IZoneProxy
{
public:
	// constructor and destructor
	CStressCore();
	void FinalRelease();


DECLARE_NOT_AGGREGATABLE(CStressCore)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStressCore)
	COM_INTERFACE_ENTRY(IZoneProxy)
END_COM_MAP()

// IZoneProxy
public:
	STDMETHOD(Command)( BSTR bstrCmd, BSTR bstrArg1, BSTR bstrArg2, BSTR* pbstrOut, long* plCode );
	STDMETHOD(Close)();
	STDMETHOD(KeepAlive)();
    STDMETHOD(Stress)();

public:
	// command implementations
	HRESULT DoLaunch( TCHAR* szArg1, TCHAR* szArg2 );

private:
    STDMETHOD(RunStress)();
    static DWORD WINAPI StressThreadProc(LPVOID p);

};


#endif //__CLIENTCORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\resourcemanager\cresourcemanager.cpp ===
// ResourceManager.cpp : Implementation of CResourceManager

#include "BasicATL.h"
#include "ResourceManager.h"
#include "CResourceManager.h"


/////////////////////////////////////////////////////////////////////////////
// CResourceManager

STDMETHODIMP_(HINSTANCE) CResourceManager::GetResourceInstance(LPCTSTR lpszName, LPCTSTR lpszType)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HANDLE h = ::FindResource( m_hInstance[ii], lpszName, lpszType))
			return m_hInstance[ii];
	}
	return NULL;
}

STDMETHODIMP_(HANDLE) CResourceManager::LoadImage(LPCTSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HANDLE h = ::LoadImage( m_hInstance[ii], lpszName, uType, cxDesired, cyDesired, fuLoad) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(HBITMAP) CResourceManager::LoadBitmap(LPCTSTR lpBitmapName)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HBITMAP h = ::LoadBitmap( m_hInstance[ii], lpBitmapName) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(HMENU) CResourceManager::LoadMenu(LPCTSTR lpMenuName)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HMENU h = ::LoadMenu( m_hInstance[ii], lpMenuName) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(HACCEL) CResourceManager::LoadAccelerators(LPCTSTR lpTableName)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HACCEL h = ::LoadAccelerators( m_hInstance[ii], lpTableName) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(HCURSOR) CResourceManager::LoadCursor(LPCTSTR lpCursorName)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HCURSOR h = ::LoadCursor( m_hInstance[ii], lpCursorName) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(HICON) CResourceManager::LoadIcon(LPCTSTR lpIconName)
{
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( HICON h = ::LoadIcon( m_hInstance[ii], lpIconName) )
			return h;
	}
	return NULL;
}

STDMETHODIMP_(int) CResourceManager::LoadString(UINT uID, LPTSTR lpBuffer, int nBufferMax)
{

	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( int n = ::LoadString( m_hInstance[ii], uID, lpBuffer, nBufferMax) )
			return n;
	}
	lpBuffer[0] = _T('\0');
	return 0;
}

STDMETHODIMP_(int) CResourceManager::LoadStringA1(UINT uID, LPSTR lpBuffer, int nBufferMax)
{

	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( int n = ::LoadStringA( m_hInstance[ii], uID, lpBuffer, nBufferMax) )
			return n;
	}
	lpBuffer[0] = '\0';
	return 0;
}

STDMETHODIMP_(int) CResourceManager::LoadStringW1(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{

	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if ( int n = ::LoadStringW( m_hInstance[ii], uID, lpBuffer, nBufferMax) )
			return n;
	}
	lpBuffer[0] = L'\0';
	return 0;
}


STDMETHODIMP CResourceManager::AddInstance(HINSTANCE hInstance)
{
	m_hInstance[m_cInstance++] = hInstance;
	return S_OK;
}

STDMETHODIMP_(HWND) CResourceManager::CreateDialogParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
)
{
    HWND hwnd ;
	for ( int ii=0; ii<m_cInstance; ii++ )
	{
		if (hwnd= ::CreateDialogParam( m_hInstance[ii], 
		                        lpTemplateName,
		                        hWndParent,
		                        lpDialogFunc,
		                        dwInitParam))
			return hwnd;
		GetLastError();
	}
	//GetLastError will ERROR_RESOURCE_NAME_NOT_FOUND 
	//when resource doesn't exist
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\stresscore.cpp ===
// StressCore.cpp : Implementation of CStressCore
#include "stdafx.h"
#include "StressCore.h"
#include "ZoneEvent.h"
#include "KeyName.h"
#include "ZoneUtil.h"
#include "zeeverm.h"
//#include "zProxy.h"

inline DECLARE_MAYBE_FUNCTION(HRESULT, GetVersionPack, (char *a, ZeeVerPack *b), (a, b), zeeverm, E_NOTIMPL);

///////////////////////////////////////////////////////////////////////////////
// CStressCore IZoneProxy
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CStressCore::Command( BSTR bstrCmd, BSTR bstrArg1, BSTR bstrArg2, BSTR* pbstrOut, long* plCode )
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	TCHAR* szOp   = W2T( bstrCmd );
	TCHAR* szArg1 = W2T( bstrArg1 );
	TCHAR* szArg2 = W2T( bstrArg2 );
	
	if ( lstrcmpi( op_Launch, szOp ) == 0 )
	{
		hr = DoLaunch( szArg1, szArg2 );
		if ( FAILED(hr) )
		{
			// release self-reference since we didn't launch
			Release();
			*plCode = ZoneProxyFail;
		}
        else
            if(hr != S_OK)  // didn't run, but no error
                Release();
	}
	else if ( lstrcmpi( op_Status, szOp ) == 0 )
	{
		*plCode = ZoneProxyOk;
	}
	else
	{
		*plCode = ZoneProxyUnknownOp;
	}
	return hr;
}


STDMETHODIMP CStressCore::Close()
{
	return S_OK;
}


STDMETHODIMP CStressCore::KeepAlive()
{
	return S_OK;
}


STDMETHODIMP CStressCore::Stress()
{
    ghStressThread = CreateThread(NULL, 0, StressThreadProc, this, 0, &gdwStressThreadID);
    return S_OK;
}


DWORD WINAPI CStressCore::StressThreadProc(LPVOID p)
{
    CStressCore *pThis = (CStressCore *) p;

	CComBSTR bCommand=op_Launch;
	CComBSTR bResult;
	CComBSTR bArg1;
    CComBSTR bArg2="";
    TCHAR szCmd[1024];
    long lResult;
    USES_CONVERSION;

	if(!ZoneFormatMessage(_T("data=[ID=[m%1_zm_***]data=[game=<Stress>dll=<ZCorem.dll,cmnClim.dll,stressdll.dll>datafile=<stressdll.dll,%1Res.dll,CmnResm.dll>]server=[%2:0]name=[Stress]family=[Stress]icw=[]setup=[STRESS]]"), szCmd,NUMELEMENTS(szCmd),gszGameCode,gszServerName))
	{
        ASSERT(!"ZoneFormatMessage Failed");
	}
    else
    {
        bArg1 = szCmd;
	    HRESULT hr = pThis->Command( bCommand, bArg1, bArg2, &bResult, &lResult );
    }

    PostThreadMessage(gdwStressThreadID, WM_QUIT, 0, 0);
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
// CStressCore Implementation
///////////////////////////////////////////////////////////////////////////////

CStressCore::CStressCore()
{
	gpCore = this;
}


void CStressCore::FinalRelease()
{
	// zero out global reference
	gpCore = NULL;

	// release proxy object
	Close();
}


HRESULT CStressCore::DoLaunch( TCHAR* szArg1, TCHAR* szArg2 )
{
    USES_CONVERSION;

	HINSTANCE	hInst = NULL;
	HRESULT		hr;
	long		lStore = 0;
	TCHAR		szGameDir[128];
	TCHAR		szStore[16];
	TCHAR		szChatChannel[16];
	TCHAR		szDllList[256];
	TCHAR		szBootList[256];
	TCHAR		szICW[MAX_PATH + 1];
	TCHAR*		arResouceDlls[32];
    TCHAR       szSetupToken[128];
	DWORD		nResouceDlls = NUMELEMENTS(arResouceDlls) - 1;
	TCHAR*		arBootDlls[32];
	DWORD		nBootDlls = NUMELEMENTS(arBootDlls);

	// self-reference to prevent early exit
	AddRef();

	// clear local strings
	ZeroMemory( szGameDir, sizeof(szGameDir) );
	ZeroMemory( szStore, sizeof(szStore) );
	ZeroMemory( szChatChannel, sizeof(szChatChannel) );
	ZeroMemory( szDllList, sizeof(szDllList) );
	ZeroMemory( szBootList, sizeof(szBootList) );
	ZeroMemory( arResouceDlls, sizeof(arResouceDlls) );
	ZeroMemory( arBootDlls, sizeof(arBootDlls) );

	// parse launch args
	if ( TokenGetKeyValue( _T("store"), szArg1, szStore, NUMELEMENTS(szStore) ) )
	{
		lStore = zatol(szStore);
	}
	if ( !TokenGetServer( szArg1, gszServerName, NUMELEMENTS(gszServerName), &gdwServerPort ) )
	{
		ASSERT( !"Missing server name (server)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("lang"), szArg1, gszLanguage, NUMELEMENTS(gszLanguage) ) )
		lstrcpy( gszLanguage, _T("eng") );
	if ( !TokenGetKeyValue( _T("id"), szArg1, gszInternalName, NUMELEMENTS(gszInternalName) ) )
	{
		ASSERT( !"Missing internal name (id)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("name"), szArg1, gszGameName, NUMELEMENTS(gszGameName) ) )
	{
		ASSERT( !"Missing game name (name)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("family"), szArg1, gszFamilyName, NUMELEMENTS(gszFamilyName) ) )
	{
		ASSERT( !"Missing family name (family)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("dll"), szArg1, szBootList, NUMELEMENTS(szBootList) ) )
	{
		ASSERT( !"Missing bootstrap dll (dll)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("datafile"), szArg1, szDllList, NUMELEMENTS(szDllList) ) )
	{
		ASSERT( !"Missing dll list (datafiles)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("game"), szArg1, szGameDir, NUMELEMENTS(szGameDir) ) )
	{
		ASSERT( !"Missing game directory (game)" );
		return E_FAIL;
	}
	if ( !TokenGetKeyValue( _T("icw"), szArg1, szICW, NUMELEMENTS(szICW) ) )
	{
		ASSERT( !"Missing command line (icw)" );
		return E_FAIL;
	}
    if ( !TokenGetKeyValue( _T("setup"), szArg1, szSetupToken, NUMELEMENTS(szSetupToken) ) )
    {
        ASSERT( !"Missing setup token (setup)" );
        return E_FAIL;
    }


	// parse boot dlls
	StringToArray( szBootList, arBootDlls, &nBootDlls );

	// parse datafile dlls
	if ( StringToArray( szDllList, arResouceDlls, &nResouceDlls ) )
	{
		// first look for dll in game directory
		for ( DWORD i = 0; i < nResouceDlls; i++ )
		{
			TCHAR szDll[MAX_PATH];

			if ( !arResouceDlls[i] )
				continue;
			wsprintf( szDll, _T("%s\\%s"), szGameDir, arResouceDlls[i] );
			hInst = LoadLibrary( szDll );
			if ( hInst )
			{
				ghResourceDlls[gnResourceDlls++] = hInst;
				arResouceDlls[i] = NULL;
			}
		}

		// second look for dll in zone directory
		for ( i = 0; i < nResouceDlls; i++ )
		{
			if ( !arResouceDlls[i] )
				continue;
			hInst = LoadLibrary( arResouceDlls[i] );
			if ( hInst )
				ghResourceDlls[gnResourceDlls++] = hInst;
		}

		
		//t-gdosan Make sure all resource Dlls were loaded correctly
		for ( i = 0; i < nResouceDlls; i++ )
		{
			if ( !ghResourceDlls[i] )
			{				
				ASSERT(!"Error loading resource dlls");
				return E_FAIL;
			}
		}

		// always add module, i.e. NULL, as last resort
		ghResourceDlls[gnResourceDlls++] = NULL;
	}

    // loop through and create loads of clients
    int idx;
    for(idx = 0; idx < gnClients; idx++)
    {
	    // create zone shell
	    hr = E_FAIL;
	    for ( DWORD i = 0; i < nBootDlls; i++ )
	    {
		    hr = _Module.Create(arBootDlls[i], CLSID_ZoneShell, IID_IZoneShell, (void**) &gppZoneShells[idx]);
		    if ( SUCCEEDED(hr) )
			    break;
	    }
	    if ( FAILED(hr) )
        {
            ASSERT(!"Could not load code dlls.");
		    return hr;
        }

	    // initialize zone shell
	    hr = gppZoneShells[idx]->Init( arBootDlls, nBootDlls, ghResourceDlls, gnResourceDlls );
	    if ( FAILED(hr) )
	    {
		    ASSERT( !"ZoneShell initialization failed" );
		    return E_FAIL;
	    }

	    // initialize sub-components
	    CComPtr<IDataStoreManager>		pIDataStoreManager;
	    CComPtr<ILobbyDataStore>		pILobbyDataStore;
	    CComPtr<IResourceManager>		pIResourceManager;
	    CComQIPtr<ILobbyDataStoreAdmin>	pILobbyDataStoreAdmin;

	    gppZoneShells[idx]->QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &gppEventQueues[idx] );
	    gppZoneShells[idx]->QueryService( SRVID_DataStoreManager, IID_IDataStoreManager, (void**) &pIDataStoreManager );
	    gppZoneShells[idx]->QueryService( SRVID_LobbyDataStore, IID_ILobbyDataStore, (void**) &pILobbyDataStore );
	    gppZoneShells[idx]->QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &pIResourceManager );

	    pILobbyDataStoreAdmin = pILobbyDataStore;
//	    _Module.SetResourceManager( pIResourceManager );

	    // event queue signal
	    gppEventQueues[idx]->SetNotificationHandle( ghEventQueue );
	    // gpEventQueue->SetWindowMessage( GetCurrentThreadId(), WM_USER + 10666, 0, 0 );

	    if (	!gppEventQueues[idx]
		    ||	!pIDataStoreManager
		    ||	!pILobbyDataStore
		    ||	!pIResourceManager
		    ||	!pILobbyDataStoreAdmin
		    ||	FAILED(pILobbyDataStoreAdmin->Init(pIDataStoreManager)) )
	    {
            ASSERT(!"Could not load core objects.");
		    return E_FAIL;
	    }

	    // add startup parameters to lobby data store
	    CComPtr<IDataStore> pIDS;
	    pILobbyDataStore->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	    pIDS->SetString( key_StartData, szArg1 );
	    pIDS->SetString( key_Language, gszLanguage );
	    pIDS->SetString( key_FriendlyName, szGameDir );
	    pIDS->SetString( key_FamilyName, gszFamilyName );
	    pIDS->SetString( key_InternalName, gszInternalName );
	    pIDS->SetString( key_Server, gszServerName );
	    pIDS->SetString( key_icw, szICW);

	    pIDS->SetLong( key_Port, (long) gdwServerPort );
	    pIDS->SetLong( key_Store, lStore );

        char *szST = T2A(szSetupToken);
        ZeeVerPack oPack;
        hr = CALL_MAYBE(GetVersionPack)(szST, &oPack);
        if(SUCCEEDED(hr))
        {
            const TCHAR *arKeys[] = { key_Version, key_VersionNum };
            pIDS->SetLong(arKeys, 2, oPack.dwVersion);

            arKeys[1] = key_VersionStr;
            pIDS->SetString(arKeys, 2, A2T(oPack.szVersionStr));

            arKeys[1] = key_BetaStr;
            pIDS->SetString(arKeys, 2, A2T(oPack.szVersionName));

            arKeys[1] = key_SetupToken;
            pIDS->SetString(arKeys, 2, A2T(oPack.szSetupToken));
        }

	    pIDS.Release();

	    // load palette
	    gppZoneShells[idx]->SetPalette(gppZoneShells[idx]->CreateZonePalette());
    }

    RunStress();

	return S_OK;
}


STDMETHODIMP CStressCore::RunStress()
{
    int i;

    // set up parameter defaults
    if(!grgnParameters[0])
        grgnParameters[0] = 1000;

    if(!grgnParameters[1])
        grgnParameters[1] = 100;

    // get clients going
    for(i = 0; i < gnClients; i++)
    {
        if(WaitForSingleObject(ghQuit, grgnParameters[0]) != WAIT_TIMEOUT)
            return S_OK;

        gppEventQueues[i]->PostEvent(PRIORITY_LOW, EVENT_LOBBY_BOOTSTRAP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    }

    i = 0;
    while(true)
    {
        if(WaitForSingleObject(ghQuit, grgnParameters[1]) != WAIT_TIMEOUT)
            return S_OK;

        // send a chat
        gppEventQueues[i]->PostEvent(PRIORITY_LOW, EVENT_TEST_STRESS_CHAT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        i = (i + 1) % gnClients;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by zClient.rc
//
#define IDS_REGISTRATION_FAILED         1
#define IDS_REGISTRATION_TITLE          2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\resourcemanager\cresourcemanager.h ===
// ResourceManager.h : Declaration of the CResourceManager

#ifndef _CRESOURCEMANAGER_H_
#define _CRESOURCEMANAGER_H_

#include "ResourceManager.h"


/////////////////////////////////////////////////////////////////////////////
// CResourceManager
class ATL_NO_VTABLE CResourceManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CResourceManager, &CLSID_ResourceManager>,
	public IResourceManager
{

public:
	CResourceManager() : m_cInstance(0)
	{
	}

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CResourceManager)
	COM_INTERFACE_ENTRY(IResourceManager)
END_COM_MAP()

// IResourceManager
public:
	STDMETHOD(AddInstance)(HINSTANCE hInstance);
	STDMETHOD_(HBITMAP, LoadBitmap)(LPCTSTR lpBitmapName);
	STDMETHOD_(HMENU, LoadMenu)(LPCTSTR lpMenuName);
	STDMETHOD_(HANDLE, LoadImage)(LPCTSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
	STDMETHOD_(HACCEL, LoadAccelerators)(LPCTSTR lpTableName);
	STDMETHOD_(HCURSOR, LoadCursor)(LPCTSTR lpCursorName);
	STDMETHOD_(HICON, LoadIcon)(LPCTSTR lpIconName);
	STDMETHOD_(int, LoadString)(UINT uID, LPTSTR lpBuffer, int nBufferMax);

	//used for forcing load,name convention required because duplicate functions created otherwise
	STDMETHOD_(int, LoadStringA1)(UINT uID, LPSTR lpBuffer, int nBufferMax);
	STDMETHOD_(int, LoadStringW1)(UINT uID, LPWSTR lpBuffer, int nBufferMax);

	STDMETHOD_(HINSTANCE, GetResourceInstance)(LPCTSTR lpszName, LPCTSTR lpszType);
	STDMETHOD_(HWND,CreateDialogParam)(
		HINSTANCE hInstance,     
		LPCTSTR lpTemplateName,  		
		HWND hWndParent,         		
		DLGPROC lpDialogFunc,    		
		LPARAM dwInitParam);       


protected:
	int			m_cInstance;
	HINSTANCE	m_hInstance[20];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressdll\main.cpp ===
#include "BasicATL.h"

#include <clientidl.h>
#include "..\StressEngine\StressEngine.h"
#include "..\StressEngine\CStressEngine.h"


CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_StressEngine, CStressEngine)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		//DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressdll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressdll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#include <BasicATL.h>


#if 0
//!! do we want any of this?
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stress\stressm.cpp ===
#include "stdafx.h"
#include <commctrl.h>
#include "resource.h"
#include "StressCore.h"

#include <initguid.h>
#include "zClient.h"
#include "zClient_i.c"
//#include "zProxy.h"
//#include "zProxy_i.c"


///////////////////////////////////////////////////////////////////////////////
// Global variable initialization
///////////////////////////////////////////////////////////////////////////////

CStressCore*		gpCore = NULL;			// primary object
IEventQueue**		gppEventQueues = NULL;	// pointer to list of event queues
IZoneShell**        gppZoneShells = NULL;
TCHAR				gszLanguage[16];		// language extension
TCHAR				gszInternalName[128];	// internal name
TCHAR				gszFamilyName[128];		// family name
TCHAR				gszGameName[128];		// game name
TCHAR				gszGameCode[128];
TCHAR				gszServerName[128];		// server's ip address
DWORD				gdwServerPort = 0;		// server's port
DWORD				gdwServerAnonymous = 0;	// server's authentication

HINSTANCE			ghResourceDlls[32];		// resource dll array
int					gnResourceDlls = 0;		// resource dll array count
HANDLE				ghEventQueue = NULL;	// event queue notification event
HANDLE              ghQuit = NULL;

DWORD               gnClients = 1;
HANDLE              ghStressThread = NULL;
DWORD               gdwStressThreadID = 0;

int                 grgnParameters[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

static const DWORD	dwTimeOut = 0;			// time for EXE to be idle before shutting down
static const DWORD	dwPause = 1000;			// time to wait for threads to finish up


///////////////////////////////////////////////////////////////////////////////
// Process Monitor
///////////////////////////////////////////////////////////////////////////////

static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*) pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);

        // timed out, if no activity let's really bail
        if (!bActivity && m_nLockCnt == 0)
        {
			break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Object map
///////////////////////////////////////////////////////////////////////////////

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////
// Helper Functions
///////////////////////////////////////////////////////////////////////////////

static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// WinMain
/////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmd, int nShowCmd )
{
	int nRet = 0;
    LPTSTR lpCmdLine;
    int i;

	 // this line necessary for _ATL_MIN_CRT
    lpCmdLine = GetCommandLine();

	// initialize OLE
    HRESULT hRes = CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hRes));

	// initialize ATL
    _Module.Init(ObjectMap, hInstance );
	_Module.dwThreadID = GetCurrentThreadId();

    lstrcpy(gszGameCode, _T("chkr"));
    lstrcpy(gszServerName, _T("zmill01"));
	ZeroMemory( gszLanguage, sizeof(gszLanguage) );
	ZeroMemory( gszInternalName, sizeof(gszInternalName) );
	ZeroMemory( gszFamilyName, sizeof(gszFamilyName) );
	ZeroMemory( gszGameName, sizeof(gszGameName) );

    // parse command line
	TCHAR szTokens[] = _T("-/");
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if(lpszToken[0] >= '0' && lpszToken[0] <= '9')
            grgnParameters[lpszToken[0] - '0'] = zatol(lpszToken + 1);

        if(lpszToken[0] == _T('c') || lpszToken[0] == _T('C'))
            gnClients = zatol(lpszToken + 1);

        if(lpszToken[0] == _T('s') || lpszToken[0] == _T('S'))
        {
            lstrcpyn(gszServerName, lpszToken + 1, NUMELEMENTS(gszServerName));
            for(i = 0; gszServerName[i]; i++)
                if(gszServerName[i] == _T(' '))
                    break;
            gszServerName[i] = _T('\0');
        }

        if(lpszToken[0] == _T('g') || lpszToken[0] == _T('G'))
        {
            lstrcpyn(gszGameCode, lpszToken + 1, NUMELEMENTS(gszGameCode));
            for(i = 0; gszGameCode[i]; i++)
                if(gszGameCode[i] == _T(' '))
                    break;
            gszGameCode[i] = _T('\0');
        }

        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if(gnClients)
    {
		// initialize globals
		ZeroMemory( ghResourceDlls, sizeof(ghResourceDlls) );

        gppEventQueues = new IEventQueue *[gnClients];
        ZeroMemory(gppEventQueues, sizeof(*gppEventQueues) * gnClients);

        gppZoneShells = new IZoneShell *[gnClients];
        ZeroMemory(gppZoneShells, sizeof(*gppZoneShells) * gnClients);

		// register object
		_Module.StartMonitor();
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE );
        _ASSERTE(SUCCEEDED(hRes));

		// create event queue notification event
		ghEventQueue = CreateEvent( NULL, FALSE, FALSE, NULL );
        ghQuit = CreateEvent(NULL, TRUE, FALSE, NULL);
		ASSERT( ghEventQueue && ghQuit);

        // start stressing
        CComObject<CStressCore> *p;
        CComObject<CStressCore>::CreateInstance(&p);
        ASSERT(gpCore);
        gpCore->Stress();

		// pump messages
		for ( bool bContinue = true; bContinue; )
		{
			for ( bool bFoundItem = true; bFoundItem; )
			{
				bFoundItem = false;

				// process window message
				MSG msg;
				while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
				{
					if ( msg.message == WM_QUIT )
					{
						bContinue = false;
						break;
					}
					else
					{
						bFoundItem = true;
				        ::TranslateMessage( &msg );
					    ::DispatchMessage( &msg );
					}
				}

				// process event queues
				for(i = 0; i < gnClients; i++)
				{
					if(gppEventQueues[i] && gppEventQueues[i]->ProcessEvents( true ) != ZERR_EMPTY )
						bFoundItem = true;
				}
			}

			if ( bContinue )
				MsgWaitForMultipleObjects( 1, &ghEventQueue, FALSE, INFINITE, QS_ALLINPUT );
		}

		// unregister object
        _Module.RevokeClassObjects();
        Sleep(dwPause);
    }

    // make sure StressCore thread is dead
    SetEvent(ghQuit);
    WaitForSingleObject(ghStressThread, INFINITE);

	// close event queues
    if(gppEventQueues)
        for(i = 0; i < gnClients; i++)
	        if(gppEventQueues[i])
	        {
		        gppEventQueues[i]->SetNotificationHandle(NULL);
		        gppEventQueues[i]->Release();
		        gppEventQueues[i] = NULL;
	        }

	// close event queue handler
	if ( ghEventQueue )
	{
		CloseHandle( ghEventQueue );
		ghEventQueue = NULL;
	}

	if ( ghQuit )
	{
		CloseHandle( ghQuit );
		ghQuit = NULL;
	}

    // destroy the shells
    if(gppZoneShells)
        for(i = 0; i < gnClients; i++)
	        if(gppZoneShells[i])
	        {
		        gppZoneShells[i]->Close();
		        if(gppZoneShells[i]->GetPalette())
		        {
			        DeleteObject(gppZoneShells[i]->GetPalette());
			        gppZoneShells[i]->SetPalette(NULL);
		        }
		        gppZoneShells[i]->Release();
	        }

	// free resource libraries
	for(i = 0; i < gnResourceDlls; i++)
	{
		if ( ghResourceDlls[i] )
		{
			FreeLibrary( ghResourceDlls[i] );
			ghResourceDlls[i] = NULL;
		}
	}
	gnResourceDlls = 0;

	// release self-reference
	if ( gpCore )
	{
		gpCore->Release();
		gpCore = NULL;
	}

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressengine\stressengine.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		MillEngine.h
 *
 * Contents:	Millennium Engine module
 *
 *****************************************************************************/

#pragma once


///////////////////////////////////////////////////////////////////////////////
// MillEngine object
///////////////////////////////////////////////////////////////////////////////

// {611A72EC-BB98-4f4c-85FB-C5171EBF2030}
DEFINE_GUID(CLSID_StressEngine, 
0x611a72ec, 0xbb98, 0x4f4c, 0x85, 0xfb, 0xc5, 0x17, 0x1e, 0xbf, 0x20, 0x30);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressdll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZoneClient.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        236
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\timer\ctimer.cpp ===
#include "CTimer.h"


///////////////////////////////////////////////////////////////////////////////
// CTimerManager
///////////////////////////////////////////////////////////////////////////////


// NOTE: Implementation assumes ONE CTimerManager per application
CTimerManager* CTimerManager::sm_pTimerManager = NULL;


ZONECALL CTimerManager::CTimerManager() :
	m_hashTimers( HashDWORD, TimerInfo::Cmp, NULL, 2, 1 )
{
	InterlockedExchange( (long*) &sm_pTimerManager, (long) this );
}


ZONECALL CTimerManager::~CTimerManager()
{
}


STDMETHODIMP CTimerManager::Close()
{
	InterlockedExchange( (long*) &sm_pTimerManager, (long) NULL );
	m_hashTimers.RemoveAll( TimerInfo::Del, this );
	return IZoneShellClientImpl<CTimerManager>::Close();
}


STDMETHODIMP CTimerManager::CreateTimer( DWORD dwMilliseconds, PFTIMERCALLBACK	pfCallback, LPVOID pContext, DWORD* pdwTimerId )
{
	// create timer
	TimerInfo* p = new TimerInfo;
	if ( !p )
		return E_OUTOFMEMORY;
	p->m_pfCallback = pfCallback;
	p->m_pContext = pContext;
	p->m_dwTimerId = SetTimer( NULL, 0, dwMilliseconds, (TIMERPROC) TimerProc );
	if ( !p->m_dwTimerId )
	{
		delete p;
		return E_FAIL;
	}

	// add to hash table
	if ( !m_hashTimers.Add( p->m_dwTimerId, p ) )
	{
		delete p;
		return E_OUTOFMEMORY;
	}

	// return to application
	*pdwTimerId = p->m_dwTimerId;
	return S_OK;
}


STDMETHODIMP CTimerManager::DeleteTimer( DWORD dwTimerId )
{
	// delete timer
	TimerInfo* p = m_hashTimers.Delete( dwTimerId );
	if ( p )
		delete p;
	return S_OK;
}


void CALLBACK CTimerManager::TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime )
{
	// get context from global
	CTimerManager* pObj = sm_pTimerManager;
	if ( !pObj )
		return;

	// look up TimerInfo from idEvent
	TimerInfo* p = pObj->m_hashTimers.Get( idEvent );
	if ( !p )
		return;

	// do the callback
	if ( p->m_pfCallback )
		p->m_pfCallback( static_cast<ITimerManager*>(pObj), idEvent, dwTime, p->m_pContext ); 
}


ZONECALL CTimerManager::TimerInfo::TimerInfo()
{
	m_dwTimerId = 0;
	m_pfCallback = NULL;
	m_pContext = NULL;
}


ZONECALL CTimerManager::TimerInfo::~TimerInfo()
{
	if ( m_dwTimerId )
	{
		KillTimer( NULL, m_dwTimerId );
		m_dwTimerId = 0;
	}
}


void ZONECALL CTimerManager::TimerInfo::Del( TimerInfo* pObj, void* pContext )
{
	delete pObj;
}


bool ZONECALL CTimerManager::TimerInfo::Cmp( TimerInfo* pObj, DWORD dwTimerId )
{
	return (pObj->m_dwTimerId == dwTimerId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\cmultistatefont.cpp ===
#include "CMultiStateFont.h"
#include "ZoneDef.h"
#include "ZoneString.h"
#include "KeyName.h"
#include "zGDI.h"
#include "zui.h"



//
// helper function
//
//extern "C" 
HRESULT LoadZoneMultiStateFont( IDataStore *pIDS, const WCHAR* pszKey, 
                                IZoneMultiStateFont **ppFont )
{
    HRESULT hr;
    CZoneMultiStateFont *pFont = new CComObject<CZoneMultiStateFont>;

    if ( !pFont )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr = pFont->Init( pIDS, pszKey ) ) )
    {
        delete pFont;
        return hr;
    }
    pFont->AddRef();
    *ppFont = pFont;
    return S_OK;
}




// static
HRESULT CZoneMultiStateFont::EnumKeys(
	CONST TCHAR*	szFullKey,
	CONST TCHAR*	szRelativeKey,
	CONST LPVARIANT	pVariant,
	DWORD			dwSize,
	LPVOID			pContext )
{
    TCHAR szKey[ZONE_MaxString];
    DWORD cbSize;
    EnumContext *p = (EnumContext *) pContext;

    FontState newState;
    TCHAR szStateName[NUMELEMENTS(newState.szName)];
    cbSize = sizeof(szStateName);

    lstrcpyT2W( newState.szName, szRelativeKey );

    // do the required rects first

    wsprintf( szKey, _T("%s/%s"), szFullKey, key_DynFont );
    if ( FAILED( p->pIDS->GetFONT( szKey, &newState.zfBackup ) ) )
    {
        return S_OK;
    }


    wsprintf( szKey, _T("%s/%s"), szFullKey, key_DynRect );
    if ( FAILED( p->pIDS->GetRECT( szKey, &newState.rect ) ) )
    {
        return S_OK;
    }

    wsprintf( szKey, _T("%s/%s"), szFullKey, key_DynPrefFont );
	if ( FAILED( p->pIDS->GetFONT( szKey, &newState.zfPref ) ) )
    {
        // the preferred font will be the default font.
        CopyMemory( &newState.zfPref, &newState.zfBackup, sizeof(newState.zfPref) );
    }

    wsprintf( szKey, _T("%s/%s"), szFullKey, key_DynColor );
    if ( FAILED( p->pIDS->GetRGB( szKey, &newState.color ) ) )
    {
        newState.color = RGB( 255, 255, 255 );
    }

    POINT ptJust;

    wsprintf( szKey, _T("%s/%s"), szFullKey, key_DynJustify ); 
    if ( FAILED( p->pIDS->GetPOINT( szKey, &ptJust ) ) )
    {
        newState.nHJustify = newState.nVJustify = -1;
    }
    else
    {
        // make sure they are normalized
        newState.nHJustify = ptJust.x;
        if ( newState.nHJustify )
        {
            newState.nHJustify /= abs( newState.nHJustify );
        }

        newState.nVJustify = ptJust.y;
        if ( newState.nVJustify )
        {
            newState.nVJustify /= abs( newState.nVJustify );
        }
    }

	newState.hFont = ZCreateFontIndirectBackup( &(newState.zfPref), &(newState.zfBackup) );
    if ( !newState.hFont )
    {
        return S_OK;
    }

	/*
    // try to create the font.
	LOGFONT logFont;
	ZeroMemory(&logFont, sizeof(LOGFONT));
	logFont.lfCharSet = DEFAULT_CHARSET;
	logFont.lfHeight = -MulDiv(newState.zfPref.lfHeight, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
	logFont.lfWeight = newState.zfPref.lfWeight;
	lstrcpy( logFont.lfFaceName, newState.zfPref.lfFaceName );

    newState.hFont = CreateFontIndirect( &logFont );

    if ( !newState.hFont )
    {
	    logFont.lfHeight = -MulDiv(newState.zfBackup.lfHeight, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
	    logFont.lfWeight = newState.zfBackup.lfWeight;
	    lstrcpy( logFont.lfFaceName, newState.zfBackup.lfFaceName );
        newState.hFont = CreateFontIndirect( &logFont );

    }
	*/	

    // so if we've gotten this far it's a valid state and we can add
    // it to our state array. Hopefully we won't, like, run out of 
    // memory or some bastard thing like that.
    p->pThis->m_arStates = (FontState*)realloc( p->pThis->m_arStates, 
                                    sizeof(FontState)*(p->pThis->m_dwNumStates+1) );
    CopyMemory( &p->pThis->m_arStates[p->pThis->m_dwNumStates], 
                &newState, 
                sizeof(p->pThis->m_arStates[p->pThis->m_dwNumStates]) );
    p->pThis->m_dwNumStates++;
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::Init( IDataStore *pIDS, const WCHAR* pszKey )
{
    USES_CONVERSION;
    EnumContext ctxt;
    ctxt.pThis = this;
    ctxt.pIDS = pIDS;

    return pIDS->EnumKeysLimitedDepth( pszKey, 1, EnumKeys, &ctxt );
}


STDMETHODIMP CZoneMultiStateFont::GetHFont( DWORD dwState, HFONT *phFont )
{
    ASSERT( IsValidState( dwState ) );
    *phFont = m_arStates[dwState].hFont;
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::FindState( LPCWSTR pszName, LPDWORD pdwState )
{
    for ( DWORD i=0; i < m_dwNumStates; i++ )
    {
        if ( !lstrcmpi( pszName, m_arStates[i].szName ) )
        {
            *pdwState = i;
            return S_OK;
        }
    }
    return E_FAIL;
}


STDMETHODIMP CZoneMultiStateFont::GetStateName( DWORD dwState, LPWSTR pszName, DWORD cchName )
{
    ASSERT( IsValidState( dwState ) );
    lstrcpyn( pszName, m_arStates[dwState].szName, cchName );
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::GetNumStates( LPDWORD pdwNumStates )
{
    *pdwNumStates = m_dwNumStates;
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::GetPreferredFont( DWORD dwState, ZONEFONT *pzf )
{
    ASSERT( IsValidState( dwState ) );
    CopyMemory( pzf, &m_arStates[dwState].zfPref, sizeof(ZONEFONT) );
    return S_OK;
}
STDMETHODIMP CZoneMultiStateFont::SetPreferredFont( DWORD dwState, ZONEFONT *pzf )
{
    /*
    ASSERT( IsValidState( dwState ) );
    CopyMemory( &m_arStates[dwStates].zfPref, pzf, sizeof(ZONEFONT) );
    // TODO: re-create the font.
    return S_OK;
    */
    return E_NOTIMPL;
}

STDMETHODIMP CZoneMultiStateFont::GetZoneFont( DWORD dwState, ZONEFONT *pzf )
{
    ASSERT( IsValidState( dwState ) );
    CopyMemory( pzf, &m_arStates[dwState].zfBackup, sizeof(ZONEFONT) );
    return S_OK;
}

STDMETHODIMP CZoneMultiStateFont::SetZoneFont( DWORD dwState, ZONEFONT *pzf )
{
    // TODO: implement in the same way was SetPreferredFont()
    return E_NOTIMPL;
}

STDMETHODIMP CZoneMultiStateFont::GetColor( DWORD dwState, COLORREF *pcolor )
{
    ASSERT( IsValidState( dwState ) );
    *pcolor = m_arStates[dwState].color;
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::SetColor( DWORD dwState, COLORREF color )
{
    ASSERT( IsValidState( dwState ) );
    m_arStates[dwState].color = color;
    return S_OK;
}

STDMETHODIMP CZoneMultiStateFont::GetRect( DWORD dwState, LPRECT pRect )
{
    ASSERT( IsValidState( dwState ) );
    *pRect = m_arStates[dwState].rect;
    return S_OK;
}


STDMETHODIMP CZoneMultiStateFont::SetRect( DWORD dwState, LPRECT pRect )
{
    ASSERT( IsValidState( dwState ) );
    m_arStates[dwState].rect = *pRect;
    return S_OK;
}

// If you don't want to retrieve one (or set one)
// set it to NULL and it will be ignored.
STDMETHODIMP CZoneMultiStateFont::GetJustify( DWORD dwState, int *pnHJustify, int *pnVJustify )
{
    ASSERT( IsValidState( dwState ) );
    if ( pnHJustify )
    {
        m_arStates[dwState].nHJustify = *pnHJustify;
    }

    if ( pnVJustify )
    {
        m_arStates[dwState].nVJustify = *pnVJustify;
    }
    return S_OK;
}

STDMETHODIMP CZoneMultiStateFont::SetJustify( DWORD dwState, int *pnHJustify, int *pnVJustify )
{
    ASSERT( IsValidState( dwState ) );
    if ( pnHJustify )
    {
        *pnHJustify = m_arStates[dwState].nHJustify;
    }

    if ( pnVJustify )
    {
        *pnVJustify = m_arStates[dwState].nVJustify;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\timer\ctimer.h ===
#include "BasicATL.h"
#include "ClientImpl.h"
#include "Timer.h"
#include "Hash.h"


///////////////////////////////////////////////////////////////////////////////
// CTimerManager
///////////////////////////////////////////////////////////////////////////////

class CTimer;

class ATL_NO_VTABLE CTimerManager :
	public ITimerManager,
	public IZoneShellClientImpl<CTimerManager>,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTimerManager, &CLSID_TimerManager>
{
// ATL definitions
public:
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CTimerManager)
		COM_INTERFACE_ENTRY(ITimerManager)
		COM_INTERFACE_ENTRY(IZoneShellClient)
	END_COM_MAP()


// IZoneShellClientImpl
public:
	STDMETHOD(Close)();

// ITimerManager
public:
	STDMETHOD(CreateTimer)(
		DWORD			dwMilliseconds,
		PFTIMERCALLBACK	pfCallback,
		LPVOID			pContext,
		DWORD*			pdwTimerId );

	STDMETHOD(DeleteTimer)( DWORD dwTimerId );

// internals
public:
	ZONECALL CTimerManager();
	ZONECALL ~CTimerManager();

	static void CALLBACK TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );

protected:

	struct TimerInfo
	{
		DWORD			m_dwTimerId;
		PFTIMERCALLBACK	m_pfCallback;
		LPVOID			m_pContext;

		ZONECALL TimerInfo();
		ZONECALL ~TimerInfo();
		static void ZONECALL Del( TimerInfo* pObj, void* pContext );
		static bool ZONECALL Cmp( TimerInfo* pObj, DWORD dwTimerId );
	};

	CMTHash<TimerInfo,DWORD>	m_hashTimers;
	static CTimerManager*		sm_pTimerManager;	// needed for context free SetTimer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\cmultistatefont.h ===
//
// Multi state font
//

#ifndef __CMULTISTATEFONT_H
#define __CMULTISTATEFONT_H

#include "MultiStateFont.h"

class ATL_NO_VTABLE CZoneMultiStateFont :
	public IZoneMultiStateFont,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CZoneMultiStateFont)
		COM_INTERFACE_ENTRY(IZoneMultiStateFont)
	END_COM_MAP()

public:
	CZoneMultiStateFont()
    {
        m_arStates = NULL;
        m_dwNumStates = 0;
    }
	~CZoneMultiStateFont()
    {
        DWORD i;

        if ( m_arStates )
        {
            for(i = 0; i < m_dwNumStates; i++)
                if(m_arStates[i].hFont)
                    DeleteObject(m_arStates[i].hFont);

            free( m_arStates );
            m_arStates = NULL;
        }
        m_dwNumStates = 0;
    }
    bool IsValidState( DWORD dwState )
    {
        return ( dwState >= 0 ) && ( dwState < m_dwNumStates );
    }

    STDMETHOD(Init)( IDataStore *pIDS, const WCHAR* pszKeys );

// IZoneMultiStateFont
public:

    STDMETHOD(GetHFont)( DWORD dwState, HFONT *phFont );

    STDMETHOD(FindState)( LPCWSTR pszName, LPDWORD pdwState );
    STDMETHOD(GetStateName)( DWORD dwState, LPWSTR pszName, DWORD cchName );

    STDMETHOD(GetNumStates)( LPDWORD pdwNumStates );

    STDMETHOD(GetPreferredFont)( DWORD dwState, ZONEFONT *pzf );
    STDMETHOD(SetPreferredFont)( DWORD dwState, ZONEFONT *pzf );

    STDMETHOD(GetZoneFont)( DWORD dwState, ZONEFONT *pzf );
    STDMETHOD(SetZoneFont)( DWORD dwState, ZONEFONT *pzf );

    STDMETHOD(GetColor)( DWORD dwState, COLORREF *pcolor );
    STDMETHOD(SetColor)( DWORD dwState, COLORREF color );

    STDMETHOD(GetRect)( DWORD dwState, LPRECT pRect );
    STDMETHOD(SetRect)( DWORD dwState, LPRECT pRect );

    // If you don't want to retrieve one (or set one)
    // set it to NULL and it will be ignored.
    STDMETHOD(GetJustify)( DWORD dwState, int *pnHJustify, int *pnVJustify );
    STDMETHOD(SetJustify)( DWORD dwState, int *pnHJustify, int *pnVJustify );

private:
    struct EnumContext
    {
        CZoneMultiStateFont *pThis;
        IDataStore *pIDS;
    };  

	static HRESULT ZONECALL EnumKeys(
		CONST TCHAR*	szFullKey,
		CONST TCHAR*	szRelativeKey,
		CONST LPVARIANT	pVariant,
		DWORD			dwSize,
		LPVOID			pContext );


private:
    struct FontState
    {
        WCHAR szName[32];
        ZONEFONT zfPref;
        ZONEFONT zfBackup;
        HFONT hFont;
        RECT rect;
        COLORREF color;
        int nHJustify;
        int nVJustify;
    };

    FontState *m_arStates;
    DWORD m_dwNumStates;
};




#endif // __CMULTISTATEFONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressengine\cstressengine.h ===
#include "ZoneDef.h"
#include "ZoneError.h"
#include "LobbyDataStore.h"
#include "ClientImpl.h"
#include "ZoneShell.h"
#include "EventQueue.h"
#include "Queue.h"
#include "StressEngine.h"
#include "MillEngine.h"
#include "ProxyMsg.h"


class ATL_NO_VTABLE CStressEngine :
	public IZoneShellClientImpl<CStressEngine>,
	public IEventClient,
    public IMillUtils,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStressEngine, &CLSID_StressEngine>
{

// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CStressEngine)
		COM_INTERFACE_ENTRY(IZoneShellClient)
		COM_INTERFACE_ENTRY(IEventClient)
        COM_INTERFACE_ENTRY(IMillUtils)
	END_COM_MAP()


// CEventQueue
public:
	ZONECALL CStressEngine();
	ZONECALL ~CStressEngine();

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

// IEventClient
public:
	STDMETHOD(ProcessEvent)(
		DWORD	dwPriority,
		DWORD	dwEventId,
		DWORD	dwGroupId,
		DWORD	dwUserId,
		DWORD	dwData1,
		DWORD	dwData2,
		void*	pCookie );

// IMillUtils
    STDMETHOD(GetURLQuery)(TCHAR *buf, DWORD cch, long nContext = 0);
    STDMETHOD(IncrementCounter)(long eCounter);
    STDMETHOD(ResetCounter)(long eCounter);
    STDMETHOD_(DWORD, GetCounter)(long eCounter, bool fLifetime = true);
    STDMETHOD(WriteTime)(long nMinutes, TCHAR *sz, DWORD cch);

// internals
private:
    void AppInitialize();

	bool m_bPreferencesLoaded;

	CComQIPtr<ILobbyDataStoreAdmin>	m_pIAdmin;

    DWORD m_gameID;
    DWORD m_c;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\textwindow.cpp ===
#include "stdafx.h"
#include "TextWindow.h"


bool CTextWindow::InsertTextFile(TCHAR * pszTextFile)
{
    /*
	char* pszTextFileBuffer = NULL;
	bool bRetVal = true;

	HANDLE hTextFile = CreateFile( pszTextFile, GENERIC_READ, FILE_SHARE_READ, 
		(LPSECURITY_ATTRIBUTES) NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL); 

	if (hTextFile == (HANDLE)INVALID_HANDLE_VALUE)
	{
		return false;
	}
	else
	{
		DWORD dwFileSize = GetFileSize(hTextFile, (LPDWORD) NULL); 	
		pszTextFileBuffer = new char[dwFileSize+1];
	 	if (!pszTextFileBuffer)
			bRetVal = false;
		else
		{	
			DWORD dwBytesRead = 0;
			BOOL bResult = ReadFile(hTextFile, pszTextFileBuffer, dwFileSize, &dwBytesRead, NULL); 
			if (bResult &&  dwBytesRead == dwFileSize )  // Check for end of file
			{	
				// Null terminate buffer
				pszTextFileBuffer[dwFileSize] = '\0';
				InsertText(0, pszTextFileBuffer);
				bRetVal = true;
			} 
			else
				bRetVal = false;
		}

		CloseHandle(hTextFile);
		delete pszTextFileBuffer;
	}
	
	return bRetVal;
    */
    ASSERT( !_T("Implement me") );
    return false;
}

HWND CTextWindow::Create(HWND hWndParent, RECT& rcPos)
{
    /*
	CRichEditCtrl cRichEditCtl;
	HWND hSuccess = cRichEditCtl.Create(hWndParent, rcPos, NULL, GetTextWndStyle(), CTEXTWINDOW_STYLE_EX, 0, NULL);
	SubclassWindow(hSuccess);
	
	// Set font
	CHARFORMAT chFmt;
	ZeroMemory( &chFmt,sizeof(CHARFORMAT));
	chFmt.cbSize = sizeof(CHARFORMAT);
	chFmt.dwMask = CFM_FACE | CFM_SIZE;
	chFmt.yHeight = 200;
	lstrcpy(chFmt.szFaceName , "Arial");

	SetDefaultCharFormat(chFmt);

	return hSuccess;
    */
    ASSERT( !_T("Implement me") );
    return NULL;
}

bool CTextWindow::SetFontColor(COLORREF rgbColor)
{
    /*
	// Set font
	CHARFORMAT chFmt;
	ZeroMemory( &chFmt,sizeof(CHARFORMAT));
	chFmt.cbSize = sizeof(CHARFORMAT);
	chFmt.dwMask = CFM_COLOR;
	chFmt.crTextColor = rgbColor;

	return (SetDefaultCharFormat(chFmt)?true:false);
    */

    ASSERT( !_T("Implement me") );
    return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\rollover.cpp ===
#include "basicatl.h"
#include <atlctrls.h>

#include "rollover.h"
#include <tchar.h>
#include "zoneutil.h"

// Static vars
HHOOK		CRolloverButtonWindowless::m_hMouseHook = NULL;
CRolloverButtonWindowless *		CRolloverButtonWindowless::m_hHookObj = NULL;

CRolloverButtonWindowless::CRolloverButtonWindowless()
{
	mParent = 0;
	mID = 0;
	mCaptured = false;
	mState = RESTING;
	mPressed = false;
	mFocused = 0;
	mSpaceBar = 0;
	mHDC = 0;
}

bool CRolloverButtonWindowless::Init(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,HDC dc,int focusWidth, TCHAR* psz, HFONT hFont, COLORREF color)
{
	HBITMAP hbmp = NULL;

	mID = id;
	mParent = wnd;
	mHDC = dc;
	mFocusWidth=focusWidth;

	if (pResMgr)
		hbmp = (HBITMAP)pResMgr->LoadImage(MAKEINTRESOURCE(resid),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
	else
		hbmp = (HBITMAP)LoadImage(_Module.GetModuleInstance(),MAKEINTRESOURCE(resid),IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);

	BITMAPINFO* m_pBMI = (BITMAPINFO*)new char[sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD)]; // wastes some space since 16 bit only needs 1 quad at most
	ASSERT(m_pBMI);
    if (!m_pBMI) {
        return FALSE;
    }
	BITMAPINFO* pbi = (BITMAPINFO*)m_pBMI;
	BITMAPINFOHEADER*  pBitmapInfo = &m_pBMI->bmiHeader;
	ZeroMemory(pBitmapInfo, sizeof(BITMAPINFOHEADER));
	pBitmapInfo->biSize = sizeof(BITMAPINFOHEADER);
	pBitmapInfo->biBitCount = 0;

	CDC memDC;
	memDC.CreateCompatibleDC();  // create a dc compatible with screen
	GetDIBits(memDC, hbmp, 0, 0, NULL, pbi, DIB_RGB_COLORS); // get bitmapinfo only


	mWidth = pbi->bmiHeader.biWidth/4;    // dividing bitmap width by number of buttons we expect to be in bitmap to determine button width
	mHeight = pbi->bmiHeader.biHeight;

	// if there's a string passed in, we're drawing some text on the button
	if(psz)
	{
		memDC.SelectBitmap(hbmp);
		if(hFont)
			memDC.SelectFont(hFont);
		memDC.SetBkMode(TRANSPARENT);
		memDC.SetTextColor(color);

		CRect rect(0,0,mWidth,mHeight);
		// Draw the text in each of the buttons
		for(int i=0;i<4;i++)
		{
			if(i==2) // pressed button text needs to be offset
			{
				CRect pressedRect = rect;
				pressedRect.DeflateRect(2,2,0,0);
				memDC.DrawText(psz, -1, &pressedRect, DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_RTLREADING);
			}
			else
			{
				if(i==3)   // disabled button text needs to be gray
					memDC.SetTextColor(RGB(128, 128, 128)); 
				// Beta3 Bug #15676 : The disabled button text color should not change with windows color settings.
				//It should always be Black when enabled and Gray when disabled.
					//memDC.SetTextColor(GetSysColor(COLOR_GRAYTEXT));
				memDC.DrawText(psz, -1, &rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_RTLREADING);
			}
			rect.OffsetRect(rect.Width(),0);
		}

		memDC.RestoreAllObjects(); // mostly since having a bitmap selected into 2 DC's is bad, and mImageList.Add seems to select this bitmap into a DC
	}

	mImageList.Create(mWidth,mHeight,ILC_COLOR8|ILC_MASK,4,0);
	mImageList.Add(hbmp,RGB(255,0,255));
	DeleteObject(hbmp);
	delete m_pBMI;
	RECT r = {x,y,x+mWidth+mFocusWidth,y+mHeight+mFocusWidth};
	mRect = r;
	m_hPal = hPal;
	return TRUE;
}

CRolloverButtonWindowless::~CRolloverButtonWindowless()
{
	mImageList.Destroy();
	
	if (m_hMouseHook)
		UnhookWindowsHookEx(m_hMouseHook);
	m_hMouseHook = NULL;

}

bool CRolloverButtonWindowless::PtInRect(POINT pt)
{
	if (::PtInRect(&mRect,pt))
		return true;
	else
		return false;
}

inline DECLARE_MAYBE_FUNCTION(DWORD, SetLayout, (HDC hdc, DWORD dwLayout), (hdc, dwLayout), gdi32, GDI_ERROR);

void CRolloverButtonWindowless::DrawResting(HDC dc,int x,int y)
{
	POINT p = {x,y};

	CALL_MAYBE(SetLayout)(dc,LAYOUT_BITMAPORIENTATIONPRESERVED);
	mImageList.Draw(dc,0,p,0);
}
void CRolloverButtonWindowless::DrawRollover(HDC dc,int x,int y)
{
	POINT p = {x,y};

	CALL_MAYBE(SetLayout)(dc,LAYOUT_BITMAPORIENTATIONPRESERVED);
	mImageList.Draw(dc,1,p,0);
}
void CRolloverButtonWindowless::DrawPressed(HDC dc,int x,int y)
{
	POINT p = {x,y};

	CALL_MAYBE(SetLayout)(dc,LAYOUT_BITMAPORIENTATIONPRESERVED);
	mImageList.Draw(dc,2,p,0);
}
void CRolloverButtonWindowless::DrawDisabled(HDC dc,int x,int y)
{
	POINT p = {x,y};

	CALL_MAYBE(SetLayout)(dc,LAYOUT_BITMAPORIENTATIONPRESERVED);
	mImageList.Draw(dc,3,p,0);
}

void CRolloverButtonWindowless::Draw(bool callHasRepainted)
{
	switch(mState){
	case DISABLED:
		DrawDisabled(mHDC,mRect.left+mFocusWidth,mRect.top+mFocusWidth);
		break;
	case RESTING:
		DrawResting(mHDC,mRect.left+mFocusWidth,mRect.top+mFocusWidth);
		break;
	case ROLLOVER:
		DrawRollover(mHDC,mRect.left+mFocusWidth,mRect.top+mFocusWidth);
		break;
	case PRESSED:
		DrawPressed(mHDC,mRect.left+mFocusWidth,mRect.top+mFocusWidth);
		break;
	}
	if(callHasRepainted)
		HasRepainted();
}

LRESULT CRolloverButtonWindowless::OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	int	x = LOWORD(lParam);  // horizontal position of cursor 
	int	y = HIWORD(lParam);  // vertical position of cursor 
	if(!mCaptured){
		CaptureOn();
		if(!mSpaceBar)
			mState = ROLLOVER;
		Draw();
	}else{
		if(x<mRect.left||x>=mRect.right||y<mRect.top||y>=mRect.bottom){		 // moved out of button area
			if(mPressed){	 // if we're not in a button pressed state can release capture
				if(mState!=ROLLOVER){
					mState = ROLLOVER;   // put in rollover state
					Draw();
				}
			}else{
				CaptureOff();
			}
		}else{ // moving within button area
			if(mState==ROLLOVER && mPressed){ // if in rollover draw state but button is pressed must have re-entered button 
				mState = PRESSED;
				Draw();
			}
		}
	}
	return 0;
}


LRESULT CRolloverButtonWindowless::OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	mState = PRESSED;
	mPressed = 1;
	
	::SetCapture(GetOwner());
	
	Draw();
	return 0;
}

LRESULT CRolloverButtonWindowless::OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	int x,y;

	if(mCaptured){
		x = LOWORD(lParam);  // horizontal position of cursor 
		y = HIWORD(lParam);  // vertical position of cursor 
		if(x<mRect.left||x>=mRect.right||y<mRect.top||y>=mRect.bottom) // if releasing mouse out of button can release capture
			CaptureOff();
		else{	 // else still in button so set to rollover state
			if(!mSpaceBar){
				mState = ROLLOVER; 
				Draw();
				if(mPressed)  // maybe should just use state for this..extra variable is kind of redundant
					ButtonPressed();
			}
		}
		mPressed = 0;
	}
	
	::ReleaseCapture();
	
	return 0;
}

void CRolloverButtonWindowless::ButtonPressed()
{
	::PostMessage(mParent,WM_COMMAND,MAKEWPARAM(mID,0),(long)mParent);
}

/*
LRESULT CRolloverButtonWindowless::OnKeyDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	UINT nVirtKey;
	UINT keyData;
	HDC hdc;

	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	keyData = keyData >> 30;
	if(!(1 & keyData))  // changed from keyup to keydn - otherwise its just a repeat key     
		if(nVirtKey==VK_SPACE){
			mSpaceBar = 1;
			if(!mPressed){
				mState = PRESSED;
				Draw(hdc);
			}
		}
	return 0;
}

LRESULT CRolloverButtonWindowless::OnKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	UINT nVirtKey;
	UINT keyData;
	HDC hdc;
	HWND parent = (HWND) GetParent();
	int id = GetWindowLong(GWL_ID);

	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	if(nVirtKey==VK_SPACE){
		mSpaceBar = 0;
		if(!mPressed){
			::PostMessage(parent,WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);
			mState = mCaptured?ROLLOVER:RESTING;
			Draw(hdc);
		}
		return 0;
	}
	unsigned char c;
	c = GetMnemonic();
	c = toupper(c);
	if(toupper(nVirtKey) == c)
		::PostMessage(parent,WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);

	return 0;
}

LRESULT CRolloverButtonWindowless::OnSysKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	int id = GetWindowLong(GWL_ID);
	UINT nVirtKey;
	UINT keyData;
	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	char c = GetMnemonic();
	c = toupper(c);
	if(toupper(nVirtKey)== c)
		::PostMessage(GetParent(),WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);

	return 0;
}
*/

void CRolloverButtonWindowless::CaptureOn()
{
	mCaptured = true;
	m_hHookObj = this;

	m_hMouseHook = SetWindowsHookEx(WH_MOUSE, (HOOKPROC) MouseHook, NULL, GetCurrentThreadId());
}

void CRolloverButtonWindowless::CaptureOff()
{
	mCaptured = false;
	mPressed = false;
	m_hHookObj = NULL;
	if (m_hMouseHook)
		UnhookWindowsHookEx(m_hMouseHook);
	m_hMouseHook = NULL;
	
	if(mState){  // only set if not disabled
		if(!mSpaceBar){
			mState = RESTING;
		}
		ForceRepaint();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	MouseHook		Filter function for the WH_MOUSE
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK CRolloverButtonWindowless::MouseHook (int nCode, WPARAM wParam, LPARAM lParam )
{
	MOUSEHOOKSTRUCT*	mouse = (MOUSEHOOKSTRUCT*) lParam;
	bool				bReleaseCapture = false;

	if ( nCode >= 0 && m_hHookObj && m_hHookObj->GetOwner()) 
	{
		switch (wParam)
		{
			case WM_LBUTTONDOWN:
			case WM_LBUTTONUP:
			case WM_RBUTTONDOWN:
			case WM_RBUTTONUP:
			case WM_MOUSEMOVE:
			{
				POINT pt = mouse->pt;
				ScreenToClient( m_hHookObj->GetOwner(), &pt );
				::SendMessage( m_hHookObj->GetOwner(), wParam, 0, MAKELPARAM(pt.x, pt.y));
				break;
			}
			default:
				break;
		}
	}

	// Pass all messages on to CallNextHookEx.
	LRESULT lResult = CallNextHookEx(m_hMouseHook, nCode, wParam, lParam);
	
	return lResult;
}

void CRolloverButtonWindowless::ForceRepaint(bool mCallHasRepainted)
{
	Draw(mCallHasRepainted);
}

void CRolloverButtonWindowless::HasRepainted()
{
}

void CRolloverButtonWindowless::SetEnabled(bool enable)
{
}


// CRolloverButton (window)
//

CRolloverButton* CRolloverButton::CreateButton(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,int focusWidth)
{
	CRolloverButton* b = new CRolloverButton();
	if(b->Init(wnd,hPal,id,x,y,resid,pResMgr,focusWidth)){
		delete b;
		return 0;
	}
	return b;
}

bool CRolloverButton::Init(HWND wnd,HPALETTE hPal,int id,int x,int y,int resid,IResourceManager *pResMgr,int focusWidth, TCHAR* psz, HFONT hFont, COLORREF color)
{
	CRolloverButtonWindowless::Init(wnd,hPal,id,x,y,resid,pResMgr,0,focusWidth,psz,hFont,color);
	RECT r = {x,y,x+GetWidth(),y+GetHeight()};
	
	HWND buttonWnd = Create(wnd,r,NULL,WS_CHILD| WS_VISIBLE| WS_TABSTOP,0,id);

	return buttonWnd==0;
}

CRolloverButton::CRolloverButton()
{
}

CRolloverButton::~CRolloverButton()
{		
	if (m_hMouseHook)
		UnhookWindowsHookEx(m_hMouseHook);
	m_hMouseHook = NULL;

}

void CRolloverButton::Draw(bool callHasRepainted)
{
	HDC dc = GetDC();
	HPALETTE oldPal = SelectPalette(dc,m_hPal,TRUE);
	RealizePalette(dc);
	switch(mState){
	case DISABLED:
		DrawDisabled(dc,mFocusWidth,mFocusWidth);
		break;
	case RESTING:
		DrawResting(dc,mFocusWidth,mFocusWidth);
		break;
	case ROLLOVER:
		DrawRollover(dc,mFocusWidth,mFocusWidth);
		break;
	case PRESSED:
		DrawPressed(dc,mFocusWidth,mFocusWidth);
		break;
	}
	if(mFocused&&mFocusWidth){
		HBRUSH hTempBrush;
		RECT r;
        hTempBrush = CreateSolidBrush(RGB(0,0,0));
		GetClientRect(&r);
		FrameRect(dc,&r,hTempBrush);
		DeleteObject(hTempBrush);
	}
	SelectPalette(dc,oldPal,TRUE);
	ReleaseDC(dc);
}

void CRolloverButton::SetEnabled(bool enable)
{
	if(!enable){	// switching to disabled
		mState = DISABLED;
		mPressed = 0;
		if(mCaptured)
			ReleaseCapture();
		InvalidateRect(NULL,0);
	}else if(enable){  // switching to enabled
		POINT pnt;
		RECT r;
		GetCursorPos(&pnt);
		GetClientRect(&r);
		MapWindowPoints(NULL,&r); 		
		// is cursor in button
		if(::PtInRect(&r,pnt)){
			// and window is active
			if(GetActiveWindow()){
				SetCapture();
				mCaptured=true;
				mState = ROLLOVER;
			}
		}else{
			mState = RESTING;  
		}
		InvalidateRect(NULL,0);
	}
}

TCHAR CRolloverButton::GetMnemonic()
{
	TCHAR buf[256];
	buf[0]= _T('\0');
	GetWindowText(buf,256);
	TCHAR* c = buf;
	while(*c){
		if(*c==_T('&')){
			c++;
			return *c;
		}
		c++;
	}
	return 0;
}

LRESULT CRolloverButton::OnKeyDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	UINT nVirtKey;
	UINT keyData;

	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	keyData = keyData >> 30;
	if(!(1 & keyData))  // changed from keyup to keydn - otherwise its just a repeat key     
		if(nVirtKey==VK_SPACE){
			mSpaceBar = 1;
			if(!mPressed){
				mState = PRESSED;
				Draw();
			}
		}
	return 0;
}

LRESULT CRolloverButton::OnKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	UINT nVirtKey;
	UINT keyData;
	HWND parent = (HWND) GetParent();
    int id = GetWindowLong(GWL_ID);

	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	if(nVirtKey==VK_SPACE){
		mSpaceBar = 0;
		if(!mPressed){
			::PostMessage(parent,WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);
			mState = mCaptured?ROLLOVER:RESTING;
			Draw();
		}
		return 0;
	}
    _TUCHAR c;
	c = GetMnemonic();
	c = _totupper(c);
	if(_totupper(nVirtKey) == c)
		::PostMessage(parent,WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);

	return 0;
}

LRESULT CRolloverButton::OnSysKeyUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	int id = GetWindowLong(GWL_ID);
	UINT nVirtKey;
	UINT keyData;
	nVirtKey = (int) wParam;	   // virtual-key code 
	keyData = lParam;		       // key data 
	TCHAR c = GetMnemonic();
	c = _totupper(c);
	if(_totupper(nVirtKey)== c)
		::PostMessage(GetParent(),WM_COMMAND,MAKEWPARAM(id,0),(long)m_hWnd);

	return 0;
}

LRESULT CRolloverButton::OnEnable(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	if (wParam)
		SetEnabled(true);
	else
		SetEnabled(false);
	return 0;
}

LRESULT CRolloverButton::OnSetFocus(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	mOldDefId = SendMessage(GetParent(), DM_GETDEFID, 0, 0) & 0xffff;                          
	SendMessage(GetParent(), DM_SETDEFID, GetWindowLong(GWL_ID),0L);
	mFocused = 1;
	InvalidateRect(NULL,0);
	return 0;
}

LRESULT CRolloverButton::OnKillFocus(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	RECT r;
	SendMessage(GetParent(), DM_SETDEFID, mOldDefId,0L);
	mFocused = 0;
	mSpaceBar = 0;
	if(mCaptured)
		ReleaseCapture();
	else{
		mState = RESTING;
		GetClientRect(&r);
		MapWindowPoints(GetParent(),&r); 		
		::InvalidateRect(GetParent(),&r,0);
	}
	return 0;
}

LRESULT CRolloverButton::OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	SetFocus();

	return CRolloverButtonWindowless::OnLButtonDown(nMsg,wParam,lParam,bHandled);
}

LRESULT CRolloverButton::OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	GetClientRect(&mRect);

	return CRolloverButtonWindowless::OnLButtonUp(nMsg,wParam,lParam,bHandled);
}

void CRolloverButton::ButtonPressed()
{
	::PostMessage(GetParent(),WM_COMMAND,MAKEWPARAM(mID,0),(long)m_hWnd);
}

LRESULT CRolloverButton::OnErase(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	return 1;
}

LRESULT CRolloverButton::OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	PAINTSTRUCT ps;
	HDC hdc;
	hdc = BeginPaint (&ps);
	Draw();
	EndPaint (&ps);
	return 0;
}

void CRolloverButton::CaptureOn()
{
	CRolloverButtonWindowless::CaptureOn();
//	SetCapture();
//	mCaptured=true;
}

void CRolloverButton::CaptureOff()
{
	CRolloverButtonWindowless::CaptureOff();
//	ReleaseCapture();
}

LRESULT CRolloverButton::OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	GetClientRect(&mRect);
	
	return CRolloverButtonWindowless::OnMouseMove(nMsg,wParam,lParam,bHandled);
}

LRESULT CRolloverButton::OnCaptureChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
  if ((HWND)lParam && ((HWND)lParam != this->m_hWnd) && mCaptured)
  {
	CaptureOff();
#if 0
	if(mState)
	{  // only set if not disabled
		if(!mSpaceBar){
			mState = RESTING;
		}
		GetClientRect(&r);
		MapWindowPoints(GetParent(),&r); 		
		::InvalidateRect(GetParent(),&r,0);
	}
#endif
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\test\stressengine\cstressengine.cpp ===
#include <BasicATL.h>
#include <HtmlHelp.h>
#include <ras.h>
#include <wininet.h>
#include <ZoneResource.h>
#include <ZoneEvent.h>
#include <ZoneString.h>
#include <ZoneFile.h>
#include <ZoneProxy.h>
#include <KeyName.h>
#include <OpName.h>
#include <LcidMap.h>
#include <icwcfg.h>
#include <ZoneUtil.h>

#include "CStressEngine.h"

#include <commonmsg.h>

typedef int16 ZSeat;

//#include <zone.h>
//#include "..\\..\\..\\..\\games\\checkers\\include\\checklib.h"
//#include "..\\..\\..\\..\\games\\checkers\\include\\checkers.h"
//#include "..\\..\\..\\..\\games\\reversi\\include\\reverlib.h"
//#include "..\\..\\..\\..\\games\\reversi\\include\\reversi.h"
//#include "..\\..\\..\\..\\games\\hearts\\include\\hearts.h"
//#include "..\\..\\..\\..\\games\\spades\\include\\spades.h"
//#include "..\\..\\..\\..\\games\\backgammon\\include\\bgmsgs.h"

// actually can't include all those 'cause they have conflicting stuff redefined - so copied out the structures
typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZCheckersMsgTalk;

typedef struct
{
	ZUserID		playerID;
	uint16		messageLen;
	int16		rfu;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZSpadesMsgTalk;

typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZReversiMsgTalk;

typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZHeartsMsgTalk;

typedef struct
{
	ZUserID	userID;
	ZSeat	seat;
	uint16	messageLen;
	// message body
} ZBGMsgTalk;


///////////////////////////////////////////////////////////////////////////////
// CStressEngine
///////////////////////////////////////////////////////////////////////////////

ZONECALL CStressEngine::CStressEngine() :
	m_bPreferencesLoaded(false),
    m_gameID(0), m_c(0)
{
}


ZONECALL CStressEngine::~CStressEngine()
{
}


STDMETHODIMP CStressEngine::ProcessEvent(
	DWORD	dwPriority,
	DWORD	dwEventId,
	DWORD	dwGroupId,
	DWORD	dwUserId,
	DWORD	dwData1,
	DWORD	dwData2,
	void*	pCookie )
{
	switch ( dwEventId )
	{
	    case EVENT_LOBBY_BOOTSTRAP:
            AppInitialize();
		    break;

        case EVENT_LOBBY_PREFERENCES_LOADED:
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_ZONE_DO_CONNECT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        case EVENT_ZONE_CONNECT:
            EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            break;

        case EVENT_ZONE_DISCONNECT:
			ZoneShell()->ExitApp();
            break;

        case EVENT_LOBBY_DISCONNECT:
            if(m_gameID)
            {
                EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_GAME_TERMINATED, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
                m_gameID = 0;
            }
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

	    case EVENT_EXIT_APP:
		    ZoneShell()->ExitApp();
		    break;

        case EVENT_GAME_LAUNCHING:
            m_gameID = dwData1;
            break;

        case EVENT_TEST_STRESS_CHAT:
        {
            if(!m_gameID)
                break;

	        CComPtr<IDataStore> pIDS;

		    TCHAR szInternalName[ZONE_MaxInternalNameLen];
		    DWORD cbInternalName = sizeof(szInternalName);
		    szInternalName[0] = '\0';
            szInternalName[1] = '\0';

		    HRESULT hr = LobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
		    if(SUCCEEDED(hr))
			    pIDS->GetString(key_InternalName, szInternalName, &cbInternalName);
            pIDS.Release();

            BYTE rgb[2048];
            ZRoomMsgGameMessage* msg = (ZRoomMsgGameMessage *) rgb;
            TCHAR *sz = NULL;
            DWORD uid = LobbyDataStore()->GetUserId(NULL);

            switch(szInternalName[1])
            {
                // backgammon
                case 'b':
                case 'B':
                {
                    ZBGMsgTalk *pMsg = (ZBGMsgTalk *) (rgb + sizeof(ZRoomMsgGameMessage));
                    pMsg->userID = ((uid >> 24) & 0xff) | ((uid >> 8) & 0xff00) | ((uid << 8) & 0xff0000) | ((uid << 24) & 0xff000000);
                    pMsg->seat = 0;
                    sz = (TCHAR *) (pMsg + 1);
                    msg->messageType = 0x100;
                    break;
                }

                // checkers
                case 'c':
                case 'C':
                {
                    ZCheckersMsgTalk *pMsg = (ZCheckersMsgTalk *) (rgb + sizeof(ZRoomMsgGameMessage));
                    pMsg->userID = ((uid >> 24) & 0xff) | ((uid >> 8) & 0xff00) | ((uid << 8) & 0xff0000) | ((uid << 24) & 0xff000000);
                    sz = (TCHAR *) (pMsg + 1);
                    msg->messageType = 0x102;
                    break;
                }

                // hearts
                case 'h':
                case 'H':
                {
                    ZHeartsMsgTalk *pMsg = (ZHeartsMsgTalk *) (rgb + sizeof(ZRoomMsgGameMessage));
                    pMsg->userID = ((uid >> 24) & 0xff) | ((uid >> 8) & 0xff00) | ((uid << 8) & 0xff0000) | ((uid << 24) & 0xff000000);
                    sz = (TCHAR *) (pMsg + 1);
                    msg->messageType = 0x10a;
                    break;
                }

                // reversi
                case 'r':
                case 'R':
                {
                    ZReversiMsgTalk *pMsg = (ZReversiMsgTalk *) (rgb + sizeof(ZRoomMsgGameMessage));
                    pMsg->userID = ((uid >> 24) & 0xff) | ((uid >> 8) & 0xff00) | ((uid << 8) & 0xff0000) | ((uid << 24) & 0xff000000);
                    sz = (TCHAR *) (pMsg + 1);
                    msg->messageType = 0x102;
                    break;
                }

                // spades
                case 's':
                case 'S':
                {
                    ZSpadesMsgTalk *pMsg = (ZSpadesMsgTalk *) (rgb + sizeof(ZRoomMsgGameMessage));
                    pMsg->playerID = ((uid >> 24) & 0xff) | ((uid >> 8) & 0xff00) | ((uid << 8) & 0xff0000) | ((uid << 24) & 0xff000000);
                    sz = (TCHAR *) (pMsg + 1);
                    msg->messageType = 0x10c;
                    break;
                }
            }

            if(sz)
            {
                if(!m_c)
                    lstrcpy(sz, _T("Stress Test"));
                else
                    if(m_c == 1)
                        lstrcpy(sz, _T("Stress"));
                    else
                        lstrcpy(sz, _T("Oh"));
                m_c = (m_c + 1) % 3;

	            int32 msgLen = (BYTE *) (sz + lstrlen(sz) + 1) - rgb;
                ASSERT(msgLen <= sizeof(rgb));

                msg->gameID = m_gameID;
	            msg->messageLen = (uint16) msgLen - sizeof(ZRoomMsgGameMessage);

	            EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_GAME_SEND_MESSAGE, ZONE_NOGROUP, ZONE_NOUSER, msg, msgLen);
            }
            break;
        }
	}

	return S_OK;
}


STDMETHODIMP CStressEngine::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
    int i;

	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CStressEngine>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

	// query for lobby data store admin
	m_pIAdmin = LobbyDataStore();
	if ( !m_pIAdmin )
		return E_FAIL;

	return S_OK;
}


STDMETHODIMP CStressEngine::Close()
{
	// release ZoneShell objects
	m_pIAdmin.Release();
	IZoneShellClientImpl<CStressEngine>::Close();
	return S_OK;
}


void CStressEngine::AppInitialize()
{
    HRESULT hr;
    TCHAR szTitle[ZONE_MAXSTRING];
    TCHAR szFormat[ZONE_MAXSTRING];
    TCHAR szName[ZONE_MAXSTRING];

	// load user preferences
	if ( !m_bPreferencesLoaded )
	{
		m_bPreferencesLoaded = true;

	    CComPtr<IDataStore> pIDS;

		TCHAR szInternalName[ZONE_MaxInternalNameLen];
		DWORD cbInternalName = sizeof(szInternalName);
		szInternalName[0] = '\0';
		hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
		if ( SUCCEEDED( hr ) )
			pIDS->GetString( key_InternalName, szInternalName, &cbInternalName );

		if ( szInternalName[0] )
		{
			hr = ZoneShell()->LoadPreferences( szInternalName, TEXT("Windows User") );
			if ( SUCCEEDED(hr) )
			{
                // do a bit of pre-processing
                long lChatOn = DEFAULT_ChatOnAtStartup;
                const TCHAR *arKeys[] = { key_Lobby, key_ChatOnAtStartup };
                DataStorePreferences()->GetLong(arKeys, 2, &lChatOn);

                pIDS->SetLong( key_LocalChatStatus, lChatOn ? 1 : 0 );

                TCHAR szLang[ZONE_MAXSTRING];
                long lcid = GetUserDefaultLCID();
                hr = LanguageFromLCID(lcid, szLang, NUMELEMENTS(szLang), ResourceManager());
                if(FAILED(hr))
                {
                    hr = LanguageFromLCID(ZONE_NOLCID, szLang, NUMELEMENTS(szLang), ResourceManager());
                    if(FAILED(hr))
                        lstrcpy(szLang, TEXT("Unknown Language"));
                }
                pIDS->SetString(key_LocalLanguage, szLang);
                pIDS->SetLong(key_LocalLCID, lcid);

				EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_PREFERENCES_LOADED, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
			}
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// IMillUtils - Exposed Utilities
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CStressEngine::GetURLQuery(TCHAR *buf, DWORD cch, long nContext)
{
    if(buf && cch)
        buf[0] = _T('\0');

    return S_OK;
}


STDMETHODIMP CStressEngine::IncrementCounter(long eCounter)
{
    return S_OK;
}


STDMETHODIMP CStressEngine::ResetCounter(long eCounter)
{
    return S_OK;
}


STDMETHODIMP_(DWORD) CStressEngine::GetCounter(long eCounter, bool fLifetime)
{
    return 0;
}


STDMETHODIMP CStressEngine::WriteTime(long nMinutes, TCHAR *sz, DWORD cch)
{
    TCHAR szFormat[ZONE_MAXSTRING];

    if(nMinutes > 90)
    {
        if(!ResourceManager()->LoadString(IDS_HOURS, szFormat, NUMELEMENTS(szFormat)))
            return E_FAIL;

        nMinutes = (nMinutes + 10) / 60;
    }
    else
        if(!ResourceManager()->LoadString(IDS_MINUTES, szFormat, NUMELEMENTS(szFormat)))
            return E_FAIL;

    if(nMinutes < 2)
        nMinutes = 2;

    if(!ZoneFormatMessage(szFormat, sz, cch, nMinutes))
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\lcidmap.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		LcidMap.cpp
 * 
 * Contents:	LCID to Language string
 *
 *****************************************************************************/
#include "ZoneDef.h"
#include "ClientIdl.h"
#include "ResourceManager.h"
#include "ZoneResource.h"

#include "LcidMap.h"

const DWORD gc_mapLangToRes[][2] = ZONE_PLANGIDTORESMAP;

HRESULT ZONECALL LanguageFromLCID(LCID lcid, TCHAR *sz, DWORD cch, IResourceManager *pIRM)
{
    DWORD plangid;
    DWORD nRes;
    int i;

    plangid = PRIMARYLANGID(LANGIDFROMLCID(lcid));
    for(i = 0; gc_mapLangToRes[i][0] != LANG_NEUTRAL; i++)
        if(gc_mapLangToRes[i][0] == plangid)
            break;

    if(!pIRM->LoadString(gc_mapLangToRes[i][1], sz, cch))
        return E_FAIL;

    return gc_mapLangToRes[i][0] == LANG_NEUTRAL ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\samples\rolloversample.cpp ===
// ChatCtl.cpp : Implementation of CChatCtl

#include "stdafx.h"
#include "ZClient.h"
#include "ChatCtl.h"
#include "dib.h"
#include "dibpal.h"
#include "atlctrls.h"
#include "rollover.h"

class CToggleButton:public CWindowImpl<CToggleButton>{
private:
	CDIB* pDIBNormal;
	CDIB* pDIBPushed;
	int mState;
	CDIB* mCurrentDisplayState;
	int mSelectionState;
	CToggleButton(int normal,int pushed);
	~CToggleButton();
public:
	CContainedWindow mButton;
	static CToggleButton* CreateButton(HWND parent,int x,int y,int id,CDIBPalette* pal,int normal,int pushed);
	// Message Map
	BEGIN_MSG_MAP(CToggleButton)
	MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
    COMMAND_CODE_HANDLER( BN_CLICKED, OnButtonClicked)
    COMMAND_CODE_HANDLER( BN_DOUBLECLICKED, OnButtonClicked)
	ALT_MSG_MAP(1)		
    END_MSG_MAP()
	// Message Handlers
    LRESULT OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnDrawItem(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	// Command Message Handlers
    LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	//
	int GetWidth(){ return pDIBNormal->Width();}
	int GetHeight(){ return pDIBNormal->Height();}

};

CToggleButton::CToggleButton(int normal,int pushed)
:mButton(_T("BUTTON"), this, 1)
{
	mState = 0;
	mSelectionState = 0;
	mCurrentDisplayState = 0;
	pDIBNormal = new CDIB;
	pDIBNormal->Load(normal,_Module.GetModuleInstance());
	pDIBPushed = new CDIB;
	pDIBPushed->Load(pushed,_Module.GetModuleInstance());
}

CToggleButton::~CToggleButton()
{
	if(pDIBNormal)
		delete pDIBNormal;
	if(pDIBPushed)
		delete pDIBPushed;
}

CToggleButton* CToggleButton::CreateButton(HWND wnd,int x,int y,int id,CDIBPalette* pal,int normal,int pushed)
{
	CToggleButton* b = new CToggleButton(normal,pushed);
	RECT r = {x,y,x+b->GetWidth(),y+b->GetHeight()};

	HWND buttonWnd = b->Create(wnd,r,NULL,WS_CHILD| WS_VISIBLE| WS_TABSTOP,id);
	r.left = 0;
	r.right = b->GetWidth();
	r.bottom = b->GetHeight();
	r.top = 0;
	b->mButton.Create(b->m_hWnd, r, _T("hello"), WS_CHILD | WS_VISIBLE|BS_OWNERDRAW|BS_AUTOCHECKBOX);
	if(buttonWnd)
		return b;
	else{
		delete b;
		return 0;
	}
	return 0;
}

LRESULT CToggleButton::OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	mState = !mState;
	InvalidateRect(0,FALSE);
	return 0;
}

LRESULT CToggleButton::OnDrawItem(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	CDIB* pDIBNotSelected = mState ? pDIBPushed:pDIBNormal;
	CDIB* pDIBSelected = mState ? pDIBNormal:pDIBPushed;
	CDIB* newDisplayState = mCurrentDisplayState;

	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam; 

	if (lpdis->itemState & ODS_SELECTED){
		newDisplayState = pDIBSelected;
	}else{
		newDisplayState = pDIBNotSelected;
	}
	//if(mCurrentDisplayState!=newDisplayState && !(lpdis->itemAction&ODA_DRAWENTIRE)){
		newDisplayState->Draw(lpdis->hDC,lpdis->rcItem.left,lpdis->rcItem.top);
		mCurrentDisplayState = newDisplayState;
	//}

    return TRUE; 
}

/*

#define UP_ARROW (100)
#define DOWN_ARROW (101)
#define PAGE_UP (103)
#define PAGE_DOWN (104)

class UpArrowButton: public CRolloverButton
{
	public:
		UpArrowButton():CRolloverButton(){}

		LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);

};
class DownArrowButton: public CRolloverButton
{
	public:
		DownArrowButton():CRolloverButton(){}

		LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);

};

class VertScrollbar : public CWindowImpl<VertScrollbar>
{
protected:
	CDIBPalette*		m_Palette;
	HWND				m_hParent;
	RECT				m_ScrollArea;
	RECT				m_PageUpRect;
	RECT				m_PageDownRect;
	RECT				m_ThumbRect;

	UpArrowButton	*	m_pUpArrow;
	DownArrowButton	*	m_pDnArrow;
	CDIB			*	m_pThumbDib;
	
	HBITMAP				m_hBkgBitmap;
	HBRUSH				m_hBkgBrush;

	SCROLLINFO			m_ScrollInfo;
	int					m_nDstFromTop;

	// Scrollbar messages - set for Horizontal or Vertical
	UINT				m_ScrollMsg;
	WORD				m_PgDecrement;
	WORD				m_PgIncrement;
	WORD				m_LnDecrement;
	WORD				m_LnIncrement;
	
	void	KillMembers();

	virtual BOOL	InitButtons(int nUpNmID, int nUpHiID, int nUpDnID, 
					int nDnNmID, int nDnHiID, int nDnDnID );
	
	virtual BOOL	InitBackground(int nBkgID);

	virtual BOOL	InitWndRect(RECT * pRect, int nArrowID);
	
	virtual BOOL	InitThumb(int nThumbID);
	virtual void	MoveThumb(int xPos, int yPos, BOOL bRedraw = TRUE);

	virtual void	CalcPageRects();

	virtual int		GetTrackPosFromPt(POINT pt);
	virtual POINT	GetPtFromTrackPos(int pos);

public:
	VertScrollbar();
	~VertScrollbar();

	DECLARE_WND_CLASS("VertScrollbar") 
	
	virtual BOOL	Init( HWND hParent, CDIBPalette* pal,int nBkgID, int ThumbID,int nUpNmID, int nUpHiID, int nUpDnID, 
						int nDnNmID, int nDnHiID, int nDnDnId );
	
	virtual int		GetScrollPos(){	return (m_ScrollInfo.nPos); }
	virtual BOOL	SetScrollPos(int pos, BOOL bRedraw = TRUE);

	virtual void	GetScrollRange( LPINT lpMinPos, LPINT lpMaxPos );
	virtual void	SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw = TRUE );

	virtual void	ShowScrollBar( BOOL bShow = TRUE ){	ShowWindow((bShow) ? SW_SHOW : SW_HIDE); }

	// Message Map
	BEGIN_MSG_MAP(VertScrollbar)
		  MESSAGE_HANDLER(WM_COMMAND, OnCommand)
		  MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		  MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
		  MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
		  MESSAGE_HANDLER( WM_LBUTTONDOWN, OnLButtonDown )
		  MESSAGE_HANDLER( WM_LBUTTONUP, OnLButtonUp )
		  MESSAGE_HANDLER( WM_TIMER, OnTimer )
		  MESSAGE_HANDLER( WM_MOUSEMOVE, OnMouseMove )
		  MESSAGE_HANDLER( WM_PAINT, OnPaint )
	END_MSG_MAP()
	
	// Message Handlers
	virtual LRESULT OnCommand(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnDestroy(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled){PostQuitMessage(0); return 0; }
	virtual LRESULT OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnQueryNewPalette(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnTimer(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	virtual LRESULT OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
};	


////////////////////////////////////////////////////////////////
//
// VertScrollbar
//
// Constructor
//
////////////////////////////////////////////////////////////////
VertScrollbar::VertScrollbar()
{
	m_pUpArrow = NULL;
	m_pDnArrow = NULL;
	m_pThumbDib = NULL;
	m_hBkgBitmap  = NULL;
	m_hBkgBrush = NULL;
	m_Palette = NULL;

    m_ScrollInfo.nMin= 0; 
    m_ScrollInfo.nMax = 100; 
    m_ScrollInfo.nPage = 0; 
    m_ScrollInfo.nPos= 0; 
    m_ScrollInfo.nTrackPos= 0; 

	m_ScrollMsg = WM_VSCROLL;
	m_PgDecrement =	SB_PAGEUP;
	m_PgIncrement =	SB_PAGEDOWN;
	m_LnDecrement =	SB_LINEUP;
	m_LnIncrement =	SB_LINEDOWN;

}

////////////////////////////////////////////////////////////////
//
// ~VertScrollbar
//
// Destructor
//
////////////////////////////////////////////////////////////////
VertScrollbar::~VertScrollbar()
{
	KillMembers();
}

////////////////////////////////////////////////////////////////
//
// KillMembers
//
// Release Memory/Objects
//
////////////////////////////////////////////////////////////////
void VertScrollbar::KillMembers()
{
	if (m_hBkgBitmap)
	{
		DeleteObject(m_hBkgBitmap);
		m_hBkgBitmap = NULL;
	}

	if (m_hBkgBrush)
	{
		DeleteObject(m_hBkgBrush);
		m_hBkgBrush = NULL;
	}

	if (m_pThumbDib)
	{
		delete m_pThumbDib;
		m_pThumbDib = NULL;
	}
}

////////////////////////////////////////////////////////////////
//
// InitWndRect
// int nArrowID - Resource ID of arrow bitmap
//
// Load up the arrow bitmap to determine width of scrollbar
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::InitWndRect(RECT * pRect, int nArrowID)
{
	CDIB * pArrowDib = new CDIB();
	if (pArrowDib)
	{
		pArrowDib->Load(nArrowID,_Module.GetModuleInstance());
		
		::GetClientRect(m_hParent, pRect );
		pRect->left = pRect->right - pArrowDib->Width()-100;
		pRect->bottom = 200;
		delete pArrowDib;

		return TRUE;
	}

	return FALSE;
}

////////////////////////////////////////////////////////////////
//
// InitBackground
//
//	Load the background bitmap, grab palette from it, release it
//	Load background using LoadBitmap and pass it to CreatePatternBrush
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::InitBackground(int nBkgID)
{
	HRESULT hr;
	CDIB BkgDib;

	// Load background for creating palette
	hr = BkgDib.Load(nBkgID,_Module.GetModuleInstance());
	if ( FAILED(hr) )
		return FALSE;
	
	m_hBkgBitmap = LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(nBkgID));
	if (!m_hBkgBitmap)
		return FALSE;

	m_hBkgBrush = CreatePatternBrush(m_hBkgBitmap);		

	if (!m_hBkgBrush)
		return FALSE;
\
	return TRUE;
}

////////////////////////////////////////////////////////////////
//
// Init
//
// Initialize graphics, windows, etc.
//
//	hParent		Parent window
//	nBkgID		Res id of background brush (8x8x256Colors)
//	ThumbID		Res id of thumb
//	nUpNmID		Res id of Up Arrow Normal
//	nUpHiID		etc.
//	nUpDnID
//	nDnNmID
//	nDnHiID
//	nDnDnID
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::Init( HWND hParent, CDIBPalette* pal,int nBkgID, int ThumbID, 
				   int nUpNmID, int nUpHiID, int nUpDnID, 
				   int nDnNmID, int nDnHiID, int nDnDnID )
{
	RECT winRect;

	m_hParent = hParent;
	m_Palette = pal;
	if (!InitWndRect(&winRect, nUpNmID))
	{
		::MessageBox(NULL, "Failed to InitWndRect", "Scrollbar.cpp", MB_OK);
		return FALSE;
	}

	if (!InitBackground( nBkgID ))
	{
		::MessageBox(NULL, "Failed to InitBackground", "Scrollbar.cpp", MB_OK);
		return FALSE;
	}
	
	if (!InitThumb( ThumbID ))
	{
		::MessageBox(NULL, "Failed to InitThumb", "Scrollbar.cpp", MB_OK);
		return FALSE;
	}

	// Change the window class to include bkg brush and CS_OWNDC 
	CWndClassInfo& ClassInfo = GetWndClassInfo();
	ClassInfo.m_wc.style |= CS_OWNDC;
	ClassInfo.m_wc.hbrBackground = m_hBkgBrush;

	if ( Create(m_hParent, winRect) == NULL )
	{
		::MessageBox(NULL, "Failed to Create Window", "Bitmap Scrollbar", MB_OK);
		return E_FAIL;
	}

	HDC hdc = GetDC();
	SelectPalette(hdc, m_Palette->GetHPalette(),0);
	ReleaseDC(hdc);

	InitButtons( nUpNmID, nUpHiID, nUpDnID, nDnNmID, nDnHiID, nDnDnID);

	return TRUE;
}

////////////////////////////////////////////////////////////////
//
// InitButtons
//
// Create and Initialize button objects
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::InitButtons(	int nUpNmID, int nUpHiID, int nUpDnID, 
								int nDnNmID, int nDnHiID, int nDnDnID)

{
	RECT	ClientRect, TempRect;
	GetClientRect(&ClientRect);

	m_pUpArrow = new UpArrowButton();
	m_pUpArrow->Init( m_Palette,m_hWnd, UP_ARROW, ClientRect.left, ClientRect.top, nUpNmID);

	m_pDnArrow = new DownArrowButton();
	m_pDnArrow->Init( m_Palette, m_hWnd, DOWN_ARROW, 0, 0, nDnNmID);

	// Put thumb under Up arrow
	m_pUpArrow->GetClientRect(&TempRect);
	MoveThumb(TempRect.left, TempRect.bottom);

	// Calc top of scroll area
	m_ScrollArea.left = ClientRect.left;
	m_ScrollArea.right = ClientRect.right;
	m_ScrollArea.top = TempRect.bottom;

	// Put down arrow at bottom
	m_pDnArrow->GetClientRect(&TempRect);
	m_pDnArrow->SetWindowPos(NULL, ClientRect.left, ClientRect.bottom - TempRect.bottom, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE); 

	// Calc bottom of scroll area
	m_ScrollArea.bottom = ClientRect.bottom - TempRect.bottom;

	return TRUE;
}




////////////////////////////////////////////////////////////////
//
// InitThumb
// int nThumbID - Resource ID of arrow bitmap
//
// Load up the thumb bitmap
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::InitThumb(int nThumbID)
{
	// load normal bitmap
	m_pThumbDib = new CDIB();
	if (m_pThumbDib)
	{
		m_pThumbDib->Load(nThumbID,_Module.GetModuleInstance());
		return TRUE;
	}
	return FALSE;
	
}

////////////////////////////////////////////////////////////////
//
// MoveThumb
// int xPos			New X Pos
// int yPos			New Y Pos
// BOOL bRedraw		Redraw thumb in new position immediately?
//
// Moves the m_ThumbRect relative to the new location
//
////////////////////////////////////////////////////////////////
void VertScrollbar::MoveThumb(int xPos, int yPos, BOOL bRedraw)
{
	RECT oldThumbRect;
	CopyRect(&oldThumbRect, &m_ThumbRect);

	SetRect( &m_ThumbRect, xPos, yPos, xPos + m_pThumbDib->Width(), yPos + m_pThumbDib->Width());
	
	// Always calc new page rects after moving thumb
	CalcPageRects();

	if (bRedraw)
	{
		UnionRect(&oldThumbRect, &oldThumbRect, &m_ThumbRect);
		InvalidateRect(&oldThumbRect);
		UpdateWindow();
	}
}

////////////////////////////////////////////////////////////////
//
// CalcPageRects
//
// Recalculate the page rectangles for the scrollbar
//
////////////////////////////////////////////////////////////////
void VertScrollbar::CalcPageRects()
{
	// Set them both = to full scroll area
	CopyRect(&m_PageUpRect, &m_ScrollArea);
	CopyRect(&m_PageDownRect, &m_ScrollArea);

	// Calc bottom of page up area
	m_PageUpRect.bottom = m_ThumbRect.top;

	// Calc top of page down area
	m_PageDownRect.top = m_ThumbRect.bottom;

}

////////////////////////////////////////////////////////////////
//
// GetTrackPosFromPt
//
// POINT pt		Mouse Loc
//
//	Calculate Thumb position from mouse loc
//
////////////////////////////////////////////////////////////////
int VertScrollbar::GetTrackPosFromPt(POINT pt)
{
	int nThumbHeight = m_ThumbRect.bottom - m_ThumbRect.top;

	if ((m_ScrollArea.bottom - m_ScrollArea.top) == 0)
		return 0;

	// Relative to top of thumb
	pt.y -= m_nDstFromTop;
	
	if ( pt.y <= m_ScrollArea.top )
		return m_ScrollInfo.nMin;

	if ( pt.y >= (m_ScrollArea.bottom - nThumbHeight) )
		return m_ScrollInfo.nMax;

	// Relative to scroll area
	pt.y -= m_ScrollArea.top;
	
	// For Vertical scrolling only
	double dSBPos = (double)pt.y * (double)m_ScrollInfo.nMax; 
	// Find the new position based on the scroll area accounting for the height of the thumb button
	int yNewPos = (int)(dSBPos / (m_ScrollArea.bottom - m_ScrollArea.top - nThumbHeight));

	return yNewPos;
}

////////////////////////////////////////////////////////////////
//
// GetPtFromTrackPos
//
// POINT pt		Mouse Loc
//
//	Calculate mouse loc from Thumb position
//
////////////////////////////////////////////////////////////////
POINT VertScrollbar::GetPtFromTrackPos(int pos)
{
	POINT pt = {0,0};
	int nThumbHeight = m_ThumbRect.bottom - m_ThumbRect.top;

	if (m_ScrollInfo.nMax == 0)
		return pt;

	// For Vertical scrolling only
	double dTemp = (double)pos * (double)(m_ScrollArea.bottom - m_ScrollArea.top - nThumbHeight);
	pt.y = (int)dTemp / m_ScrollInfo.nMax;

	// Account for scroll area
	pt.y += m_ScrollArea.top;
	pt.x = m_ScrollArea.left;

	return pt;
}

////////////////////////////////////////////////////////////////
//
// GetScrollRange
//
// Retrieve scroll range
//
////////////////////////////////////////////////////////////////
void VertScrollbar::GetScrollRange( LPINT lpMinPos, LPINT lpMaxPos )
{
	*lpMinPos = m_ScrollInfo.nMin;
	*lpMaxPos = m_ScrollInfo.nMax;
}

////////////////////////////////////////////////////////////////
//
// SetScrollRange
//
// Set scroll range
//
////////////////////////////////////////////////////////////////
void VertScrollbar::SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw)
{
	m_ScrollInfo.nMin = nMinPos;
	m_ScrollInfo.nMax = nMaxPos;
}

////////////////////////////////////////////////////////////////
//
// SetScrollPos
//
// Set the postion of the thumb
//
////////////////////////////////////////////////////////////////
BOOL VertScrollbar::SetScrollPos(int pos, BOOL bRedraw)
{
	POINT loc;

	if (m_ScrollInfo.nMin == m_ScrollInfo.nMax)
		return FALSE;

	if (pos < m_ScrollInfo.nMin || pos > m_ScrollInfo.nMax)
		return FALSE;

	loc = GetPtFromTrackPos(pos);
	
	MoveThumb( loc.x, loc.y, bRedraw);

	return TRUE;
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// WINDOWS MESSAGES
//
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
LRESULT VertScrollbar::OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	POINT curPos;
	RECT curRect;

	GetCursorPos(&curPos);

	// If the mouse is still down on button or area respond appropriately
	if ( !(GetAsyncKeyState(VK_LBUTTON) & 0x8000) )
	{
		KillTimer(wParam);
		return 0;
	}
	switch (wParam)
	{
		case UP_ARROW:
			m_pUpArrow->GetWindowRect(&curRect);
			if (PtInRect(&curRect, curPos))
				::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_LnDecrement,0), (LPARAM)m_hWnd);
			break;
		case DOWN_ARROW:
			m_pDnArrow->GetWindowRect(&curRect);
			if (PtInRect(&curRect, curPos))
				::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_LnIncrement,0), (LPARAM)m_hWnd);
			break;
		case PAGE_UP:
			ScreenToClient(&curPos);
			if (PtInRect(&m_PageUpRect, curPos))
				::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_PgDecrement,0), (LPARAM)m_hWnd);
			break;
		case PAGE_DOWN:
			ScreenToClient(&curPos);
			if (PtInRect(&m_PageDownRect, curPos))
				::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_PgIncrement,0), (LPARAM)m_hWnd);
			break;
	}

	return 0;
}

LRESULT VertScrollbar::OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
    HDC hDC;           // Handle to device context
    HPALETTE hOldPal;  // Handle to previous logical palette

    // If this application did not change the palette, select
    // and realize this application's palette
    if ((HWND)wParam != m_hWnd)
    {
       // Need the window's DC for SelectPalette/RealizePalette
       hDC = GetDC();

       // Select and realize hPalette
       hOldPal = SelectPalette(hDC, m_Palette->GetHPalette(), TRUE);
       RealizePalette(hDC);

       // When updating the colors for an inactive window,
       // UpdateColors can be called because it is faster than
       // redrawing the client area (even though the results are
       // not as good)
       UpdateColors(hDC);

       // Clean up
       if (hOldPal)
          SelectPalette(hDC, hOldPal, FALSE);

       ReleaseDC(hDC);
 
		// Send children message
		register HWND hwndChild;
		hwndChild = GetWindow (GW_CHILD);
		while (hwndChild)
		{
			::SendMessage (hwndChild, nMsg, wParam, lParam);
			hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
		}
	}

	return 0;
}

LRESULT VertScrollbar::OnQueryNewPalette(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	HDC hDC;           // Handle to device context
    HPALETTE hOldPal;  // Handle to previous logical palette

    // Need the window's DC for SelectPalette/RealizePalette
    hDC = GetDC();

    // Select and realize hPalette
    hOldPal = SelectPalette(hDC, m_Palette->GetHPalette(), FALSE);
 
	if(RealizePalette(hDC))
	{    
		InvalidateRect(NULL,TRUE);
	    UpdateWindow();
	}  

    // Clean up
    if (hOldPal)
      SelectPalette(hDC, hOldPal, FALSE);
    ReleaseDC(hDC);

	// Send children message
	register HWND hwndChild;
	hwndChild = GetWindow (GW_CHILD);
	while (hwndChild)
	{
		::SendMessage (hwndChild, nMsg, wParam, lParam);
		hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
	}

	return 0;
}

LRESULT VertScrollbar::OnCommand(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{

	int nID = (int)LOWORD(wParam);			// item, control, or accelerator identifier 
	UINT uNotifyCode = (UINT)HIWORD(wParam);		// notification code 
	HWND hwndCtl = (HWND) lParam;			// handle of control 
	
	switch (nID)
	{
	case UP_ARROW:
		::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_LnDecrement,0), (LPARAM)m_hWnd);
		break;
	case DOWN_ARROW:
		::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_LnIncrement,0), (LPARAM)m_hWnd);
		break;
	default:
		break;
	}
	return 0;
}

LRESULT VertScrollbar::OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	int id;
	POINT pt = {LOWORD(lParam), HIWORD(lParam)};

	if (PtInRect(&m_ThumbRect, pt))
	{
		m_nDstFromTop = pt.y - m_ThumbRect.top; 
		SetCapture();
		return 0;
	}
	if (PtInRect(&m_PageUpRect, pt))
	{
		::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_PgDecrement,0), (LPARAM)m_hWnd);
		id = PAGE_UP;
	}
	else if (PtInRect(&m_PageDownRect, pt))
	{
		::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(m_PgIncrement,0), (LPARAM)m_hWnd);
		id = PAGE_DOWN;
	}
	if (GetAsyncKeyState(VK_LBUTTON) & 0x8000) 
		SetTimer(id, 100);

	return 0;
}

LRESULT VertScrollbar::OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	POINT pt = {LOWORD(lParam), HIWORD(lParam)};
	RECT parentRect;

	if (GetCapture() == m_hWnd)
	{	
		ReleaseCapture();
		
		m_nDstFromTop = 0;
		
		GetClientRect(&parentRect);
		if (PtInRect(&parentRect, pt))
		{
			m_ScrollInfo.nPos = m_ScrollInfo.nTrackPos; 
			SetScrollPos(m_ScrollInfo.nPos);
			::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(SB_THUMBPOSITION,m_ScrollInfo.nPos), (LPARAM)m_hWnd);
		}
	}

	return 0;
}

LRESULT VertScrollbar::OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	POINT pt = {LOWORD(lParam), HIWORD(lParam)};
	RECT clientRect;

	if (GetCapture() == m_hWnd)
	{	
		GetClientRect(&clientRect);
		if (PtInRect(&clientRect, pt)) // We are still within the scrollbar
		{
			m_ScrollInfo.nTrackPos= GetTrackPosFromPt(pt); 
			SetScrollPos(m_ScrollInfo.nTrackPos);
			::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(SB_THUMBTRACK,m_ScrollInfo.nTrackPos), (LPARAM)m_hWnd);
		}
		else // We have left the scrollbar client area
		{
			SetScrollPos(m_ScrollInfo.nPos);
			::SendMessage (m_hParent, m_ScrollMsg, MAKELONG(SB_THUMBPOSITION,m_ScrollInfo.nPos), (LPARAM)m_hWnd);
		}

	}

	return 0;
}

LRESULT VertScrollbar::OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	PAINTSTRUCT ps;
	HDC hdc;
	
	hdc = BeginPaint( &ps );

    HPALETTE hOldPal = SelectPalette(hdc, m_Palette->GetHPalette(), TRUE);
    RealizePalette(hdc);

	m_pThumbDib->Draw( hdc, m_ThumbRect.left, m_ThumbRect.top);

    SelectPalette(hdc, hOldPal, TRUE);
    RealizePalette(hdc);

	EndPaint( &ps );

	return 0;
}

LRESULT UpArrowButton::OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	if (GetAsyncKeyState(VK_LBUTTON) & 0x8000) 
		::SetTimer(GetParent(),UP_ARROW, 100, NULL);

	return (CRolloverButton::OnLButtonDown( nMsg, wParam, lParam, bHandled));
}

LRESULT DownArrowButton::OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
{
	if (GetAsyncKeyState(VK_LBUTTON) & 0x8000) 
		::SetTimer(GetParent(),DOWN_ARROW, 100, NULL);

	return (CRolloverButton::OnLButtonDown( nMsg, wParam, lParam, bHandled));
}

*/



/////////////////////////////////////////////////////////////////////////////
// CChatCtl

CChatCtl::CChatCtl()
:mButton(this)
{
	CDIB g_pDIB;
	
    g_pDIB.Load(IDB_BACKGROUND,_Module.GetModuleInstance());
    pDIBPalette = new CDIBPalette(&g_pDIB);
	m_bWindowOnly = TRUE;
	mCapture = 0;
}

CChatCtl::~CChatCtl()
{
	delete pDIBPalette;
}

LRESULT CChatCtl::OnErase(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
    HDC dc = (HDC) wParam; // handle to device context

    HPALETTE oldPal = SelectPalette(dc,pDIBPalette->GetHPalette(), FALSE);
	int i = RealizePalette(dc);
	RECT rc;
    GetClientRect(&rc);
	int dx = rc.right/16;
	int dy = rc.bottom/16;
	int ndx = 0;
	rc.right = dx;
	rc.bottom = dy;
	for(int y = 0;y<16;y++){
		for(int x= 0 ; x< 16;x++){
			HBRUSH hTempBrush = CreateSolidBrush(PALETTEINDEX(ndx++));
			FillRect(dc,&rc,hTempBrush);
			DeleteObject(hTempBrush);
			rc.left+=dx;
			rc.right+=dx;
		}
		rc.left =0;
		rc.right = dx;
		rc.top+=dy;
		rc.bottom+=dy;
	}
    bHandled = TRUE;
    return 1;

}

LRESULT CChatCtl::OnPaint(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{	
    PAINTSTRUCT p;
    HDC dc = BeginPaint(&p);
	CRect r(0,0,200,200);
	memDC.RestoreAllObjects();
	mDIB.Draw(CDC(dc),0,&r,FALSE);
	memDC.SelectBitmap(mDIB);
	EndPaint(&p);

	return 0;
}


void MyRollover::CaptureOff()
{
	CRolloverButtonWindowless::CaptureOff();
	mOwner->mCapture = 0;
	ReleaseCapture();
}

void MyRollover::CaptureOn()
{
	CRolloverButtonWindowless::CaptureOn();
	mOwner->mCapture = this;
	SetCapture(mParent);
}

void MyRollover::HasRepainted()
{
	InvalidateRect(mParent,0,0);
}

LRESULT CChatCtl::OnMouseMove(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	int	x = LOWORD(lParam);  // horizontal position of cursor 
	int	y = HIWORD(lParam);  // vertical position of cursor 

	POINT pt = {x,y};
	if(mButton.PtInRect(pt) || mCapture==&mButton)
		return mButton.OnMouseMove(nMsg,wParam,lParam,bHandled);
	return 0;
}

LRESULT CChatCtl::OnLButtonDown(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	if(mCapture==&mButton)
		return mButton.OnLButtonDown(nMsg,wParam,lParam,bHandled);
	return 0;
}

LRESULT CChatCtl::OnLButtonUp(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	if(mCapture==&mButton)
		return mButton.OnLButtonUp(nMsg,wParam,lParam,bHandled);
	return 0;
}

LRESULT CChatCtl::OnCreate(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	CPalette* pal = new CPalette(pDIBPalette->GetHPalette());
	//CRolloverButton::CreateButton(pal,(HWND)m_hWnd,0,0,0,IDB_JOIN);
	
	memDC.CreateCompatibleDC();
	HDC dc = ::GetDC(0);
	CDC screen(dc);
	mDIB.CreateCompatibleDIB(memDC,200,200);
	memDC.SelectBitmap(mDIB);
	RECT r ={0,0,200,200};
	memDC.FillRect(&r,(HBRUSH)2);
	mButton.Init(m_hWnd,pal,1,20,10,IDB_JOIN,memDC);
	mButton.ForceRepaint();
	//CRect cr(0,0,200,200);
	//mDIB.Draw(screen,0,&cr,FALSE);

	//CToggleButton::CreateButton((HWND)m_hWnd,0,100,0,pDIBPalette,IDB_BUTTON_RESTING,IDB_BUTTON_ROLLOVER);
	//VertScrollbar* v = new VertScrollbar();
	//v->Init(m_hWnd,pDIBPalette,IDB_BACKGROUND,IDB_BUTTON_RESTING,IDB_BUTTON_RESTING,IDB_BUTTON_ROLLOVER,IDB_BUTTON_PRESSED,
	//	IDB_BUTTON_RESTING,IDB_BUTTON_ROLLOVER,IDB_BUTTON_PRESSED);
    return 0;
}

LRESULT CChatCtl::OnPaletteChanged(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
	HWND hwnd = (HWND) wParam;
    if(hwnd != m_hWnd)
    {
        HDC hdc = GetDC();
        HPALETTE oldPal = SelectPalette(hdc,pDIBPalette->GetHPalette(),TRUE);
        int i = RealizePalette(hdc);
		if(i)
			InvalidateRect(0);
        SelectPalette(hdc,oldPal,TRUE);
        ReleaseDC(hdc);
    }
    return 0;
}

LRESULT CChatCtl::OnQueryNewPalette(UINT nMsg,WPARAM wParam,LPARAM lParam,BOOL& bHandled)
{
    HDC hdc = GetDC();
    HPALETTE oldPal = SelectPalette(hdc,pDIBPalette->GetHPalette(), FALSE);
	int i = RealizePalette(hdc);
	if(i)
		InvalidateRect(0);
    SelectPalette(hdc,oldPal,TRUE);
	ReleaseDC(hdc);
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\zgdi.cpp ===
// CDib - DibSection helper class

#include <windows.h>
#include <multimon.h>
#include "basicatl.h"
#include "zGDI.h"
#include "ZoneString.h"
#include "KeyName.h"

const  int		MAXPALCOLORS = 256;

CDib::CDib()
{
	memset(&m_bm, 0, sizeof(m_bm));
	m_hdd = NULL;
}

CDib::~CDib()
{
	if ( m_hBitmap )
		DeleteObject();
}

//////////////////
// Delete Object. Delete DIB and palette.
//
void CDib::DeleteObject()
{
	m_pal.DeleteObject();

	if (m_hdd) 
	{
		DrawDibClose(m_hdd);
		m_hdd = NULL;
	}

	memset(&m_bm, 0, sizeof(m_bm));

	CBitmap::DeleteObject();
}

//////////////////
// Load bitmap resource.
//
bool CDib::LoadBitmap(LPCTSTR lpResourceName, IResourceManager *pResMgr /* = NULL */)
{
	{
        if(!pResMgr)
		    pResMgr = _Module.GetResourceManager();
		if (pResMgr)
			return	Attach((HBITMAP)pResMgr->LoadImage(lpResourceName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE));
		else
			return	Attach((HBITMAP)::LoadImage(_Module.GetResourceInstance(), lpResourceName, IMAGE_BITMAP, 0, 0,
					LR_CREATEDIBSECTION | LR_DEFAULTSIZE));
	}
}


//////////////////
// Load bitmap resource, and draw text onto it.
//
bool CDib::LoadBitmapWithText(LPCTSTR lpResourceName, IResourceManager *pResMgr, IDataStore *pIDS, CONST TCHAR *szKey /* = NULL */)
{
    TCHAR sz[ZONE_MAXSTRING];

    if(!LoadBitmap(lpResourceName, pResMgr))
        return FALSE;

    if(HIWORD((DWORD) lpResourceName))
        wsprintf(sz, _T("BitmapText/%s"), lpResourceName);
    else
        wsprintf(sz, _T("BitmapText/%d"), (DWORD) lpResourceName);
    HRESULT hr = DrawDynTextToBitmap((HBITMAP) *this, pIDS, szKey ? szKey : sz);
    if(FAILED(hr))
        return FALSE;
    return TRUE;
}

//////////////////
// Attach is just like the CGdiObject version,
// except it also creates the palette
//
bool CDib::Attach(HBITMAP hbm)
{
	if ( !hbm )
		return FALSE;

	CBitmap::Attach(hbm);

	if (!GetBitmap(&m_bm))			// load BITMAP for speed
		return FALSE;

	if( !GetObject(m_hBitmap, sizeof(m_ds), &m_ds) )
		return FALSE;

	return CreatePalette(m_pal);	// create palette
}


typedef struct
{
    HBITMAP hbm;
    IDataStore *pIDS;
} DynTextContext;

static STDMETHODIMP DrawDynTextToBitmapEnum(
		CONST TCHAR*	szFullKey,
		CONST TCHAR*	szRelativeKey,
		CONST LPVARIANT	pVariant,
		DWORD			dwSize,
		LPVOID			pContext )
{
    DynTextContext *p = (DynTextContext *) pContext;
    ZoneString szKey(szFullKey);
    szKey += _T('/');

    TCHAR sz[ZONE_MAXSTRING];
    DWORD cb = sizeof(sz);
    HRESULT hr = p->pIDS->GetString(szKey + key_DynText, sz, &cb);
    if(FAILED(hr))
        return hr;

    COLORREF rgb = PALETTERGB( 255, 255, 255 );
    p->pIDS->GetRGB(szKey + key_DynColor, &rgb);

    CRect rc;
    hr = p->pIDS->GetRECT(szKey + key_DynRect, &rc);
    if(FAILED(hr))
        return hr;

    CPoint ptJust(-1, -1);
    p->pIDS->GetPOINT(szKey + key_DynJustify, &ptJust);

    CWindowDC dc(NULL);
	CDC memdc;
	memdc.CreateCompatibleDC(dc);
	memdc.SelectBitmap(p->hbm);

	ZONEFONT zfPreferred;	// impossible to match
	ZONEFONT zfBackup(10);	// will provide a reasonable 10 point default
	p->pIDS->GetFONT(szKey + key_DynPrefFont, &zfPreferred );
	hr = p->pIDS->GetFONT(szKey + key_DynFont, &zfBackup );
    if(FAILED(hr))
        return hr;

    CZoneFont font;
	font.SelectFont(zfPreferred, zfBackup, memdc);

    HFONT hOldFont = memdc.SelectFont(font);
	memdc.SetBkMode(TRANSPARENT);
	memdc.SetTextColor(rgb);

    memdc.DrawText(sz, -1, &rc, DT_SINGLELINE | (ptJust.x < 0 ? DT_LEFT : ptJust.x > 0 ? DT_RIGHT : DT_CENTER) |
        (ptJust.y < 0 ? DT_TOP : ptJust.y > 0 ? DT_BOTTOM : DT_VCENTER));

	memdc.SelectFont( hOldFont );
	
    return S_OK;
}

HRESULT DrawDynTextToBitmap(HBITMAP hbm, IDataStore *pIDS, CONST TCHAR *szKey)
{
    DynTextContext o;

    if(!hbm || !pIDS || !szKey)
        return FALSE;

    o.hbm = hbm;
    o.pIDS = pIDS;

    return pIDS->EnumKeysLimitedDepth(szKey, 1, DrawDynTextToBitmapEnum, &o);
}


//////////////////
// Get size (width, height) of bitmap.
// extern fn works for ordinary CBitmap objects.
//
CSize GetBitmapSize(CBitmap& Bitmap)
{
	BITMAP bm;
	return Bitmap.GetBitmap(&bm) ?
		CSize(bm.bmWidth, bm.bmHeight) : CSize(0,0);
}


//////////////////
// You can use this static function to draw ordinary
// CBitmaps as well as CDibs
//
bool DrawBitmap(CDC& dc, CBitmap& Bitmap,
	const CRect* rcDst, const CRect* rcSrc)
{
	// Compute rectangles where NULL specified
	CRect rc;
	if (!rcSrc) {
		// if no source rect, use whole bitmap
		rc = CRect(CPoint(0,0), GetBitmapSize(Bitmap));
		rcSrc = &rc;
	}
	if (!rcDst) {
		// if no destination rect, use source
		rcDst=rcSrc;
	}

	// Create memory DC.
	// 6/7/99 JeremyM.  This seems to randomly fail. Giving it a few reties helps.
	CDC memdc;

	for ( int ii=0; ii<10; ii++ )
	{
		memdc.CreateCompatibleDC(dc);
		if ( memdc )
			break;

		DWORD error = GetLastError();
		ATLTRACE("Can't create compatible DC, error %d *****************, Time: 0x%08x\n", error, GetTickCount());
	}

	ASSERT(memdc);

	if ( !memdc )
		return false;

	memdc.SelectBitmap(Bitmap);

	// Blast bits from memory DC to target DC.
	// Use StretchBlt if size is different.
	//
	BOOL bRet = false;
	if (rcDst->Size()==rcSrc->Size()) {
		bRet = dc.BitBlt(rcDst->left, rcDst->top, 
			rcDst->Width(), rcDst->Height(),
			memdc, 
			rcSrc->left, rcSrc->top, SRCCOPY);
	} else {
		dc.SetStretchBltMode(COLORONCOLOR);
		bRet = dc.StretchBlt(rcDst->left, rcDst->top, rcDst->Width(),
			rcDst->Height(), memdc, rcSrc->left, rcSrc->top, rcSrc->Width(),
			rcSrc->Height(), SRCCOPY);
	}
	return bRet ? true : false;
}

////////////////////////////////////////////////////////////////
// Draw DIB on caller's DC. Does stretching from source to destination
// rectangles. Generally, you can let the following default to zero/NULL:
//
//		bUseDrawDib = whether to use use DrawDib, default TRUE
//		pPal	      = palette, default=NULL, (use DIB's palette)
//		bForeground = realize in foreground (default FALSE)
//
// If you are handling palette messages, you should use bForeground=FALSE,
// since you will realize the foreground palette in WM_QUERYNEWPALETTE.
//
bool CDib::Draw(CDC& dc, const CRect* prcDst, const CRect* prcSrc,
	bool bUseDrawDib, HPALETTE hPal, bool bForeground)
{
	if (!m_hBitmap)
		return FALSE;

	// Select, realize palette
	if (hPal==NULL)					// no palette specified:
//!! are we leaking here???
		hPal = GetPalette();		// use default
	HPALETTE OldPal = 
		dc.SelectPalette(hPal, !bForeground);
	dc.RealizePalette();

	BOOL bRet = FALSE;
	if (bUseDrawDib) {
//!!	if (1) {
		// Compute rectangles where NULL specified
		//
//!!		CRect rc(0,0,-1,-1);	// default for DrawDibDraw
		CRect rc(GetRect());	// default for DrawDibDraw
		if (!prcSrc)
			prcSrc = &rc;
		if (!prcDst)
			prcDst=prcSrc;

		// Get BITMAPINFOHEADER/color table. I copy into stack object each time.
		// This doesn't seem to slow things down visibly.
		//
		DIBSECTION ds;
//!! error check?
//!! why call GetObject again? Can we store the DIBSECTION?
		GetObject(m_hBitmap, sizeof(ds), &ds);
		char buf[sizeof(BITMAPINFOHEADER) + MAXPALCOLORS*sizeof(RGBQUAD)];
		BITMAPINFOHEADER& bmih = *(BITMAPINFOHEADER*)buf;
		RGBQUAD* colors = (RGBQUAD*)(&bmih+1);
		memcpy(&bmih, &ds.dsBmih, sizeof(bmih));
		GetColorTable(colors, MAXPALCOLORS);

		// DrawDibDraw() likes to AV if the source isn't entirely backed by data,
		// so clip to the source data to be sure. 

		CRect rcClipSrc;
		if ( rcClipSrc.IntersectRect(prcSrc, &GetRect()) )
		{
			// If we clipped the source, remove that associated area from the dest.
			// Note: this assumes we never want to stretch. If we want to stretch, we
			// should probably remove a proportional amount.
			CRect rcClipDst(*prcDst);

			rcClipDst.top += rcClipSrc.top - prcSrc->top;
			rcClipDst.left += rcClipSrc.left - prcSrc->left;

			rcClipDst.bottom += rcClipSrc.bottom - prcSrc->bottom;
			rcClipDst.right += rcClipSrc.right - prcSrc->right;

			
			if (!m_hdd)
				m_hdd = DrawDibOpen();

			// Let DrawDib do the work!
			bRet = DrawDibDraw(m_hdd, dc,
				rcClipDst.left, rcClipDst.top, rcClipDst.Width(), rcClipDst.Height(),
				&bmih,			// ptr to BITMAPINFOHEADER + colors
				m_bm.bmBits,	// bits in memory
				rcClipSrc.left, rcClipSrc.top, rcClipSrc.Width(), rcClipSrc.Height(),
				bForeground ? 0 : DDF_BACKGROUNDPAL);
		}

	} else {
		// use normal draw function
		bRet = DrawBitmap(dc, *this, prcDst, prcSrc);
	}
	if (OldPal)
		dc.SelectPalette(OldPal, TRUE);
	return bRet ? true : false;
}

#define PALVERSION 0x300	// magic number for LOGPALETTE

//////////////////
// Create the palette. Use halftone palette for hi-color bitmaps.
//
bool CDib::CreatePalette(CPalette& pal)
{ 
	// should not already have palette
	ASSERT((HPALETTE)pal==NULL);

	RGBQUAD* colors = (RGBQUAD*)_alloca(sizeof(RGBQUAD[MAXPALCOLORS]));
	UINT nColors = GetColorTable(colors, MAXPALCOLORS);
	if (nColors > 0) {
		// Allocate memory for logical palette 
		int len = sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * nColors;
		LOGPALETTE* pLogPal = (LOGPALETTE*)_alloca(len);
		if (!pLogPal)
			return NULL;

		// set version and number of palette entries
		pLogPal->palVersion = PALVERSION;
		pLogPal->palNumEntries = nColors;

		// copy color entries 
		for (UINT i = 0; i < nColors; i++) {
			pLogPal->palPalEntry[i].peRed   = colors[i].rgbRed;
			pLogPal->palPalEntry[i].peGreen = colors[i].rgbGreen;
			pLogPal->palPalEntry[i].peBlue  = colors[i].rgbBlue;
			pLogPal->palPalEntry[i].peFlags = 0;
		}

		// create the palette and destroy LOGPAL
		pal.CreatePalette(pLogPal);
	} else {
		CWindowDC dcScreen(NULL);
		pal.CreateHalftonePalette(dcScreen);
	}
	return (HPALETTE)pal != NULL;
}

//////////////////
// Helper to get color table. Does all the mem DC voodoo.
//
UINT CDib::GetColorTable(RGBQUAD* colorTab, UINT nColors)
{
	CWindowDC dcScreen(NULL);
	CDC memdc;
	memdc.CreateCompatibleDC(dcScreen);
	memdc.SelectBitmap(*this);
	nColors = GetDIBColorTable(memdc, 0, nColors, colorTab);
	return nColors;
}

int CZoneFont::GetHeight()
{
	LOGFONT logFont;
	
	if(GetLogFont(&logFont))
	{
		return -logFont.lfHeight;
	}
	return 0;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

typedef HMONITOR (WINAPI *PFMONITORFROMWINDOW)( HWND hwnd, DWORD dwFlags );
typedef HMONITOR (WINAPI *PFMONITORFROMRECT)( LPCRECT lprc, DWORD dwFlags );
typedef BOOL	 (WINAPI *PFGETMONITORINFO)( HMONITOR hMonitor, LPMONITORINFO lpmi );

static bMonitorFunctionsLoaded = false;
static PFMONITORFROMWINDOW pfMonitorFromWindow = NULL;
static PFGETMONITORINFO pfGetMonitorInfo = NULL;
static PFMONITORFROMRECT pfMonitorFromRect = NULL;

static void InitGetScreenRectStubs()
{
	if ( !bMonitorFunctionsLoaded )
	{
		bMonitorFunctionsLoaded = true;
		HINSTANCE hLib = GetModuleHandle( _T("USER32") );
		if ( hLib )
		{
			pfMonitorFromWindow = (PFMONITORFROMWINDOW) GetProcAddress( hLib, "MonitorFromWindow" );
			pfMonitorFromRect = (PFMONITORFROMRECT) GetProcAddress( hLib, "MonitorFromRect" );
			// Watch out. There is a W version of this function, to return the monitor device name.
			// But we don't use that functionality, so we just use the A version.
			pfGetMonitorInfo = (PFGETMONITORINFO) GetProcAddress( hLib, "GetMonitorInfoA" );
		}
		else
		{
			pfMonitorFromWindow = NULL;
			pfMonitorFromRect = NULL;
			pfGetMonitorInfo = NULL;
		}
	}
}


void GetScreenRectWithMonitorFromWindow( HWND hWnd, CRect* prcOut )
{
	InitGetScreenRectStubs();

	if ( pfMonitorFromWindow && pfGetMonitorInfo )
	{
		HMONITOR hMonitor = pfMonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);
		if ( hMonitor )
		{
			MONITORINFO mi;
			ZeroMemory( &mi, sizeof(mi) );
			mi.cbSize = sizeof(mi);
			pfGetMonitorInfo( hMonitor, &mi );
			*prcOut = mi.rcWork;
			return;
		}
	}

	::SystemParametersInfo(SPI_GETWORKAREA, NULL, prcOut, NULL);
}


void GetScreenRectWithMonitorFromRect( CRect* prcIn, CRect* prcOut )
{
	InitGetScreenRectStubs();

	if ( pfMonitorFromRect && pfGetMonitorInfo )
	{
		HMONITOR hMonitor = pfMonitorFromRect(prcIn, MONITOR_DEFAULTTONEAREST);
		if ( hMonitor )
		{
			MONITORINFO mi;
			ZeroMemory( &mi, sizeof(mi) );
			mi.cbSize = sizeof(mi);
			pfGetMonitorInfo( hMonitor, &mi );
			*prcOut = mi.rcWork;
			return;
		}
	}

	::SystemParametersInfo(SPI_GETWORKAREA, NULL, prcOut, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\ui\samples\rolloversample.h ===
// ChatCtl.h : Declaration of the CChatCtl

#ifndef __CHATCTL_H_
#define __CHATCTL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "dibpal.h"
#include "zgdi.h"
#include "rollover.h"

class CChatCtl;

class MyRollover:public CRolloverButtonWindowless{
private:
	CChatCtl* mOwner;
public:
	MyRollover(CChatCtl* owner):mOwner(owner){}
	void CaptureOn();
	void CaptureOff();
	void HasRepainted();
};

/////////////////////////////////////////////////////////////////////////////
// CChatCtl
class ATL_NO_VTABLE CChatCtl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IChatCtl, &IID_IChatCtl, &LIBID_ZCLIENTLib>,
	public CComControl<CChatCtl>,
	public IPersistStreamInitImpl<CChatCtl>,
	public IOleControlImpl<CChatCtl>,
	public IOleObjectImpl<CChatCtl>,
	public IOleInPlaceActiveObjectImpl<CChatCtl>,
	public IViewObjectExImpl<CChatCtl>,
	public IOleInPlaceObjectWindowlessImpl<CChatCtl>,
	public CComCoClass<CChatCtl, &CLSID_ChatCtl>,
	public IShellComponentImpl<CChatCtl>

{
public:
	CChatCtl();
	~CChatCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_CHATCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChatCtl)
	COM_INTERFACE_ENTRY(IChatCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IShellComponent)
END_COM_MAP()

BEGIN_PROP_MAP(CChatCtl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CChatCtl)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)

	CHAIN_MSG_MAP(CComControl<CChatCtl>)
	DEFAULT_REFLECTION_HANDLER()
	//MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
	//MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
	//MESSAGE_HANDLER(WM_ERASEBKGND, OnErase)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IChatCtl
public:
	static DWORD GetWndStyle(DWORD dwStyle){ return WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS;}

	LRESULT OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnQueryNewPalette(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnMouseMove(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnLButtonUp(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnLButtonDown(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnPaint(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	LRESULT OnErase(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
	
public:
	CDIBPalette* pDIBPalette;
	CDib mDIB;
	MyRollover mButton;
	MyRollover* mCapture;
	CDC memDC;
};

#endif //__CHATCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\globaldv.cpp ===
//
// GlobalDv.cpp
//
// This sample application demonstrates several principles of writing 
// a globalized application. The main techniques demonstrated are:
//
// 1. Single binary Win32 application that will run on any version of 
// Windows 95, Windows 98, or Windows NT (localized, enabled or plain 
// vanilla English) using Unicode for (almost) all text encoding.
// 
// 2. Multi-lingual user interface using satellite DLLs.
//
// 3. New APIs for right to left layout ("mirroring") of windows in an
// application localized to Arabic or Hebrew.
//
// See the README.HTM file for more details
//
// This module contains the standard Windows Application WinMain and
// WinProc functions, as well as some initialization routines used only
// in this module.
//
// Written by F. Avery Bishop
// Copyright (c) 1998, 1999 Microsoft Systems Journal

#define STRICT

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "UAPI.h"
#include "UpdtLang.h"
#include "UMhandlers.h"

#include "..\resource.h"

// standard global variables
HINSTANCE g_hInst                        ;  // current instance
WCHAR     g_szTitle      [MAX_LOADSTRING];  // title bar text
WCHAR     g_szWindowClass[MAX_LOADSTRING];

// Forward declarations of functions defined in this module:
ATOM             RegisterThisClass(HINSTANCE)             ;
HWND             InitInstance(HINSTANCE, int, PGLOBALDEV) ;
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM)      ;


//
//  FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
//
//  PURPOSE:  WinMain entry point
//
//  COMMENTS:
//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG         msg       ;
    PLANGSTATE  pLState   ; // Language state struct, typedef in UPDTLANG.H
    PAPP_STATE  pAppState ; // Application state struct, typedef in UMHANDLERS.H
    GLOBALDEV   GlobalDev ; // Overall state struct

    pLState   
        = (PLANGSTATE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LANGSTATE) ) ;
    
    pAppState 
        = (PAPP_STATE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(APP_STATE) ) ;

    GlobalDev.pLState   = pLState   ;
    GlobalDev.pAppState = pAppState ;

    
    if( !InitUnicodeAPI(hInstance)      // Initialize Unicode/ANSI functions
        ||
        !InitUILang(hInstance, pLState) // Initialize UI and language dependent state
      ) {

        // Failed too early in initialization to use the resources, must fall back on
        // a hard coded English message
        MessageBoxW(NULL, L"Cannot initialize application. Press OK to exit...", NULL, MB_OK | MB_ICONEXCLAMATION) ;
        
        return FALSE ;
    }

    // Initialize global strings
    LoadStringU(pLState->hMResource, IDS_APP_TITLE, g_szTitle,       MAX_LOADSTRING) ;
    LoadStringU(pLState->hMResource, IDS_GLOBALDEV, g_szWindowClass, MAX_LOADSTRING) ;

    RegisterThisClass(hInstance) ;

    // Perform application initialization:
    if (!InitInstance(hInstance, nCmdShow, &GlobalDev) ) {

        RcMessageBox(NULL, pLState, IDS_INITFAILED, MB_OK | MB_ICONEXCLAMATION, L"GlobalDev") ;

        return FALSE ;
    }

    // Main message loop:
    while ( GetMessageU(&msg, NULL, 0, 0) > 0 ) 
	{
        if ( !TranslateAcceleratorU(msg.hwnd, pLState->hAccelTable, &msg) ) 
		{
            TranslateMessage(&msg) ;
            DispatchMessageU(&msg) ;
        }
    }

    HeapFree( GetProcessHeap(), 0, (LPVOID) pLState   ) ;
    HeapFree( GetProcessHeap(), 0, (LPVOID) pAppState ) ;

    return msg.wParam;
}

//
//  FUNCTION: RegisterThisClass(HINSTANCE)
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
ATOM RegisterThisClass (HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize        = sizeof(WNDCLASSEXW)                        ;

    wcex.style         = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc   = WndProc                                    ;
    wcex.cbClsExtra    = 0                                          ;
    wcex.cbWndExtra    = 0                                          ;
    wcex.hInstance     = hInstance                                  ;
    wcex.hIcon         = LoadIcon(hInstance, (LPCTSTR)IDI_GLOBALDEV);
    wcex.hCursor       = LoadCursor(NULL, IDC_ARROW)                ;
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1)                   ;
    wcex.lpszMenuName  = NULL                                       ;
    wcex.lpszClassName = g_szWindowClass                            ;
    wcex.hIconSm       = LoadIcon (hInstance, (LPCTSTR)IDI_SMALL)   ;

    return RegisterClassExU(&wcex) ;
}

//
//   FUNCTION: InitInstance(HANDLE, int, PLANGSTATE)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
HWND InitInstance(HINSTANCE hInstance, int nCmdShow, PGLOBALDEV pGlobalDev)
{
    HWND hWnd;

    g_hInst = hInstance; // Store instance handle in global variable

    hWnd = CreateWindowExU(
                0                   , 
                g_szWindowClass     , 
                g_szTitle           , 
                WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | 
				WS_BORDER | ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | 
				ES_AUTOHSCROLL | ES_AUTOVSCROLL,
                CW_USEDEFAULT       ,
                0                   ,
                CW_USEDEFAULT       , 
                0                   , 
                NULL                , 
                NULL                , 
                hInstance           , 
                (LPVOID) pGlobalDev // Pass state struct to OnCreate
            ) ;

    if (NULL == hWnd) 
	{
        return NULL ;
    }

    ShowWindow   (hWnd, nCmdShow) ;
    UpdateWindow (hWnd) ;

    return hWnd ;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Process messages for the main window.
//
//  Comments: Calls ConvertMessage to convert message parameters (wParam and lParam) to Unicode 
//            if necessary, and passes the message on to the appropriate message 
//            handler. All message handlers are in the module UMHANLDERS.CPP.
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PGLOBALDEV pGlobalDev = (PGLOBALDEV) GetWindowLongA(hWnd, GWL_USERDATA) ;

    PLANGSTATE pLState   = NULL ;
    PAPP_STATE pAppState = NULL ;
           
    if(pGlobalDev) { // Don't try to use pGlobalDev until it's been initialized in OnCreate 

        pLState   = pGlobalDev->pLState   ;
        pAppState = pGlobalDev->pAppState ;
    }

    // Preprocess messages to convert to/from Unicode if necessary
    if(!ConvertMessage(hWnd, message, &wParam, &lParam) ) {

        return 0 ;
    }

    switch (message) 
	{

        case WM_CREATE :
            
            OnCreate(hWnd, wParam, lParam, (LPVOID) NULL) ;

            break ;

        case WM_INPUTLANGCHANGE:

            if( !OnInputLangChange(hWnd, wParam, lParam, (LPVOID) pLState)) {

                return FALSE ;
            } 

            break ;

        case WM_COMMAND:

            if( !OnCommand(hWnd, wParam, lParam, (LPVOID) pGlobalDev) ) {

                DefWindowProcU(hWnd, message, wParam, lParam) ;
            }
            break ;

        case WM_IME_CHAR:
            // By the time we get a WM_IME_CHAR message, the character in wParam is
            // in Unicode, so we can treat it just like a WM_CHAR message.

        case WM_CHAR:

            OnChar(hWnd, wParam, lParam, (LPVOID) pAppState) ;
            break ;
 
        case WM_PAINT:
           
            OnPaint(hWnd, wParam, lParam, (LPVOID) pAppState) ;
            break ;

        case WM_DESTROY:

            OnDestroy (hWnd, wParam, lParam, (LPVOID) pAppState) ;
            break ;
        
        default:

            return DefWindowProcU(hWnd, message, wParam, lParam) ;
    }

    return 0 ;
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GlobalDv.rc
//
#define IDS_TEST1                       1
#define IDS_STRING2                     2
#define IDD_DIALOG1                     137
#define IDR_WAVE1                       141
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32781
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           119
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\updtlang.h ===
//
// UPDTLANG.H
//

#ifndef _UPDTLANG
#define _UPDTLANG

// Constants
#define MAX_LOADSTRING  200
#define BUFFER_SIZE     200
#define MAX_NAME        100
#define LARGEBUFFER     1000

// GDI defines for RTL mirroring standard windows 
#ifndef LAYOUT_RTL

#define LAYOUT_RTL                         0x00000001 // Right to left
#define LAYOUT_BTT                         0x00000002 // Bottom to top
#define LAYOUT_VBH                         0x00000004 // Vertical before horizontal
#define LAYOUT_ORIENTATIONMASK             (LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH)
#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008

#endif /* #ifndef LAYOUT_RTL */

// USER defines for RTL mirroring standard windows
#ifndef WS_EX_LAYOUTRTL

#define WS_EX_NOINHERITLAYOUT   0x00100000L // Disable inheritence of mirroring by children
#define WS_EX_LAYOUTRTL         0x00400000L  // Right to left mirroring

#endif /* #ifndef WS_EX_LAYOUTRTL */

// Structure to store language/locale state
typedef struct tagLangState {
    UINT        InputCodePage ;
    BOOL        IsRTLLayout   ;
    LANGID      UILang        ;
    HMENU       hMenu         ;
    HMODULE     hMResource    ;
    HACCEL      hAccelTable   ;
} LANGSTATE, *PLANGSTATE ;

#ifndef MIN
#define MIN(_aa, _bb) ((_aa) < (_bb) ? (_aa) : (_bb))
#endif

// Functions provided in this module
BOOL    InitUILang(HINSTANCE hInstance , PLANGSTATE pLState) ;
BOOL    UpdateUILang(HINSTANCE , LANGID, PLANGSTATE)         ;
UINT    LangToCodePage(IN LANGID wLangID)                  ;
BOOL    FindResourceDirectory (HINSTANCE , LPWSTR )        ;
HMODULE GetResourceModule     (HINSTANCE , LCID   )        ;
int     RcMessageBox (HWND , PLANGSTATE, int nMessageID, int nOptions, ...) ;

#define FALLBACK_UI_LANG MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#endif /* _UPDTLANG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\uniansidll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__39C5350C_4797_401B_A668_44558F79370A__INCLUDED_)
#define AFX_STDAFX_H__39C5350C_4797_401B_A668_44558F79370A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__39C5350C_4797_401B_A668_44558F79370A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\uniansidll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	UnicodeAPI.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\uapiinit\uapiinit.cpp ===
//
// UAPIInit.CPP
//
// This module initializes the Unicode-ANSI API function pointers (the 'U' API).
// This is a set of entry points that parallel selected functions in the Win32 API.
// Each pointer is typedefed as a pointer to the corresponding W API entry point.
// See description of InitUnicodeAPI for more details.
//
// Copyright (c) 1998 Microsoft Systems Journal

#define STRICT

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef UNICODE
#define UNICODE
#endif

#define GLOBALS_HERE
#include "UAPI.h"

//
//  FUNCTION: BOOL ConvertMessageUStub(HWND hWnd, UINT message, WPARAM *pwParam, LPARAM *plParam)
//
//  PURPOSE:  Stub that does nothing
//
//  COMMENTS: Dummy routine used on Windows NT only. See ConvertMessageAU in UNIANSI.CPP for
//            an example of a real message converter for use on Windows 9x
//
BOOL WINAPI ConvertMessageUStub(HWND hWnd, UINT message, WPARAM *pwParam, LPARAM *plParam)
{
    return TRUE ;
}

//
//  FUNCTION: BOOL UpdateUnicodeAPIStub(LANGID wCurrentUILang, UINT InputCodePage)
//
//  PURPOSE:  Stub that does nothing
//
//  COMMENTS: Dummy routine used on Windows NT only. See UpdateUnicodeAPIAU in UNIANSI.CPP for
//            an example of an implementation for use on Windows 9x
//
BOOL WINAPI UpdateUnicodeAPIStub(LANGID wCurrentUILang, UINT InputCodePage)
{
    return TRUE ;
}


//
//  FUNCTION: BOOL InitUnicodeAPI(HINSTANCE hInstance)
//
//  PURPOSE:  Set U API function pointers to point appropriate entry point.
//            
//  COMMENTS: The U function pointers are set to the corresponding W entry
//            point by default in the header file UAPI.H. If running on 
//            Windows NT we leave these function pointers as is. Otherwise, 
//            we load a library of wrapper routines (UNIANSI.DLL) and set
//            the function pointer to the corresponding wrapper routine.
//            For example, LoadStringU is set to LoadStringW at compile time,
//            but if running on Windows 9x, it is set to LoadStringAU, which
//            calls LoadStringA and converts ANSI to Unicode.
// 
BOOL InitUnicodeAPI(HINSTANCE hInstance)
{
    OSVERSIONINFOA Osv ;
    BOOL IsWindowsNT  ;

    Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA) ;

    if(!GetVersionExA(&Osv)) {
        return FALSE ;
    }

    IsWindowsNT = (BOOL) (Osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ;

// define this symbol in UAPI.H to emulate Windows 9x when testing on Windows NT.
#ifdef EMULATE9X
    IsWindowsNT = FALSE ;
#endif

    if(IsWindowsNT) 
	{
        // On Windows NT, we just set the U function pointer to the W 
        // entry point. This was already done at compile time by the 
        // default assignment in UAPI.H
        // For these special cases (not Win32 functions) we do
        // the assignment here
        ConvertMessage   = (UAPI_ConvertMessage)    ConvertMessageUStub ;
        UpdateUnicodeAPI = (UAPI_UpdateUnicodeAPI)  UpdateUnicodeAPIStub;
    }
    else 
	{
        HMODULE hMUniAnsi   ;
        BOOL (*InitUniAnsi)(PUAPIINIT) ;
        UAPIINIT UAInit   ;

		// On Windows 9x, there are two broad implementation classes of Win32 APIs:

        // Case 1: The W and A versions pass exactly the same
        // parameters, so we can just set the U function pointer to the
        // A entry point without using a wrapper function
        GetMessageU					= GetMessageA;
        TranslateAcceleratorU		= TranslateAcceleratorA;
        DispatchMessageU			= DispatchMessageA;
        DefWindowProcU				= DefWindowProcA;
		GetObjectU					= GetObjectA;
		CreateAcceleratorTableU		= CreateAcceleratorTableA;
		SetWindowsHookExU			= SetWindowsHookExA;
		CreateDialogIndirectParamU  = CreateDialogIndirectParamA;
		PeekMessageU				= PeekMessageA;
		PostThreadMessageU			= PostThreadMessageA;
		CallWindowProcU				= CallWindowProcA;
		PostMessageU				= PostMessageA;

        // Case 2: Most functions require hand-written routines to convert between 
        // Unicode and ANSI and call the A entry point in the Win32 API. 
        // We set the U function pointer to those handwritten routines, 
        // which are in the following DLL:
        hMUniAnsi = LoadLibraryA("UniAnsi.dll");

        if(!hMUniAnsi) 
		{
            
            // Too early in intialization phase to use a localized message, so 
            // fall back to hard-coded English message
            MessageBoxW(
                NULL, 
                L"Cannot load Unicode conversion module. Press OK to exit ...", 
                L"Initialization Error",  
                MB_OK | MB_ICONERROR) ;

            return FALSE ;
        }

        // Get Initialization routine from the DLL
        InitUniAnsi = (BOOL (*)(PUAPIINIT)) GetProcAddress(hMUniAnsi, "InitUniAnsi") ;

		//GDI32.DLL
		UAInit.pGetTextFaceU				= &GetTextFaceU;
		UAInit.pCreateDCU					= &CreateDCU;
		UAInit.pGetTextMetricsU				= &GetTextMetricsU;
		UAInit.pCreateFontU					= &CreateFontU;
		UAInit.pCreateFontIndirectU			= &CreateFontIndirectU;
		UAInit.pEnumFontFamiliesU			= &EnumFontFamiliesU;

		//WINMM.DLL
		UAInit.pPlaySoundU					= &PlaySoundU;

		//SHELL32.DLL
		UAInit.pShellExecuteU				= &ShellExecuteU;

		//COMDLG32.DLL
		UAInit.pChooseFontU					= &ChooseFontU;

		//KERNEL32.dll
		UAInit.pGetPrivateProfileStringU     = &GetPrivateProfileStringU;
		UAInit.pGetProfileStringU			 = &GetProfileStringU;
		UAInit.pGetProfileStringU			 = &GetProfileStringU;
		UAInit.pCreateFileMappingU			 = &CreateFileMappingU;
		UAInit.pFindFirstChangeNotificationU = &FindFirstChangeNotificationU;

		UAInit.pFormatMessageU				= &FormatMessageU;
		UAInit.plstrcmpU					= &lstrcmpU;
		UAInit.plstrcatU					= &lstrcatU;
		UAInit.plstrcpyU					= &lstrcpyU;
		UAInit.plstrcpynU					= &lstrcpynU;
		UAInit.plstrlenU					= &lstrlenU;
		UAInit.plstrcmpiU					= &lstrcmpiU;
		UAInit.pGetStringTypeExU			= &GetStringTypeExU;
		UAInit.pCreateMutexU				= &CreateMutexU;
		UAInit.pGetShortPathNameU			= &GetShortPathNameU;
		UAInit.pCreateFileU					= &CreateFileU;
		UAInit.pWriteConsoleU				= &WriteConsoleU;
		UAInit.pOutputDebugStringU			= &OutputDebugStringU;
		UAInit.pGetVersionExU				= &GetVersionExU;
		UAInit.pGetLocaleInfoU				= &GetLocaleInfoU;
		UAInit.pGetDateFormatU				= &GetDateFormatU;
		UAInit.pFindFirstFileU				= &FindFirstFileU;
		UAInit.pFindNextFileU				= &FindNextFileU;
		UAInit.pLoadLibraryExU				= &LoadLibraryExU;
		UAInit.pLoadLibraryU				= &LoadLibraryU;
		UAInit.pGetModuleFileNameU			= &GetModuleFileNameU;
		UAInit.pGetModuleHandleU			= &GetModuleHandleU;
		UAInit.pCreateEventU				= &CreateEventU;
		UAInit.pGetCurrentDirectoryU		= &GetCurrentDirectoryU;
		UAInit.pSetCurrentDirectoryU		= &SetCurrentDirectoryU;

		//USER32.DLL
		UAInit.pCreateDialogParamU			= &CreateDialogParamU;
		UAInit.pIsDialogMessageU			= &IsDialogMessageU;
		UAInit.pSystemParametersInfoU		= &SystemParametersInfoU;
		UAInit.pRegisterWindowMessageU		= &RegisterWindowMessageU;
		UAInit.pSetMenuItemInfoU			= &SetMenuItemInfoU;
		UAInit.pGetClassNameU				= &GetClassNameU;
		UAInit.pInsertMenuU					= &InsertMenuU;
		UAInit.pIsCharAlphaNumericU			= &IsCharAlphaNumericU;
		UAInit.pCharNextU					= &CharNextU;
		UAInit.pDeleteFileU					= &DeleteFileU;
		UAInit.pIsBadStringPtrU				= &IsBadStringPtrU;
		UAInit.pLoadBitmapU					= &LoadBitmapU;
		UAInit.pLoadCursorU					= &LoadCursorU;
		UAInit.pLoadIconU					= &LoadIconU;
		UAInit.pLoadImageU					= &LoadImageU;
		UAInit.pSetPropU					= &SetPropU;
		UAInit.pGetPropU					= &GetPropU;
		UAInit.pRemovePropU					= &RemovePropU;
		UAInit.pGetDlgItemTextU				= &GetDlgItemTextU;
		UAInit.pSetDlgItemTextU				= &SetDlgItemTextU;
		UAInit.pSetWindowLongU				= &SetWindowLongU;
		UAInit.pGetWindowLongU				= &GetWindowLongU;
		UAInit.pFindWindowU					= &FindWindowU;
		UAInit.pDrawTextU					= &DrawTextU;
		UAInit.pDrawTextExU					= &DrawTextExU;
		UAInit.pSendMessageU				= &SendMessageU;
		UAInit.pSendDlgItemMessageU			= &SendDlgItemMessageU;
		UAInit.pSetWindowTextU				= &SetWindowTextU;
		UAInit.pGetWindowTextU				= &GetWindowTextU;
		UAInit.pGetWindowTextLengthU		= &GetWindowTextLengthU;
		UAInit.pLoadStringU					= &LoadStringU;
		UAInit.pGetClassInfoExU				= &GetClassInfoExU;
		UAInit.pGetClassInfoU				= &GetClassInfoU;
		UAInit.pwsprintfU					= &wsprintfU;
		UAInit.pwvsprintfU					= &wvsprintfU;
		UAInit.pRegisterClassExU			= &RegisterClassExU;
		UAInit.pRegisterClassU				= &RegisterClassU;
		UAInit.pCreateWindowExU				= &CreateWindowExU;		
		UAInit.pLoadAcceleratorsU			= &LoadAcceleratorsU;
		UAInit.pLoadMenuU					= &LoadMenuU;
		UAInit.pDialogBoxParamU				= &DialogBoxParamU;
		UAInit.pCharUpperU					= &CharUpperU;
		UAInit.pCharLowerU					= &CharLowerU;
		UAInit.pGetTempFileNameU			= &GetTempFileNameU;
		UAInit.pGetTempPathU				= &GetTempPathU;
		UAInit.pCompareStringU				= &CompareStringU;

		//ADVAPI32.DLL
		UAInit.pRegQueryInfoKeyU			= &RegQueryInfoKeyU;
		UAInit.pRegEnumValueU				= &RegEnumValueU;
		UAInit.pRegQueryValueExU			= &RegQueryValueExU;
		UAInit.pRegEnumKeyExU				= &RegEnumKeyExU;
		UAInit.pRegSetValueExU				= &RegSetValueExU;
		UAInit.pRegCreateKeyExU				= &RegCreateKeyExU;
		UAInit.pRegOpenKeyExU				= &RegOpenKeyExU;
		UAInit.pRegDeleteKeyU				= &RegDeleteKeyU;
		UAInit.pRegDeleteValueU				= &RegDeleteValueU;

        // Add new entries here

        // Special cases, not corresponding to any Win32 API
        UAInit.pConvertMessage      = &ConvertMessage     ;
        UAInit.pUpdateUnicodeAPI    = &UpdateUnicodeAPI   ;
		
        if( NULL == InitUniAnsi    // Make sure we have a valid initialization function
             ||
            !InitUniAnsi(&UAInit) // Initialize U function pointers
          ) 
        {
            // Too early in intialization phase to use a localized message, so 
            // fall back to hard-coded English message
            MessageBoxW(
                NULL, 
                L"Cannot initialize Unicode functions. Press OK to exit ...", 
                L"Initialization Error",  
                MB_OK | MB_ICONERROR) ;
            
            return FALSE ;
        }
    }

    if(!(       // Confirm that the initialization was OK
	   GetTextFaceU		     &&
       CreateDCU             &&
       GetTextMetricsU       &&
       CreateFontU		     &&
       EnumFontFamiliesU     &&

       PlaySoundU		     &&

	   ShellExecuteU         &&

       ChooseFontU           &&

	   CreateFileMappingU		    &&
	   FindFirstChangeNotificationU &&
	   FormatMessageU		 &&
       lstrcmpU				 &&
       lstrcatU			     &&
       lstrcpyU	             &&
       lstrcpynU		     &&
       lstrlenU	             &&
       lstrcmpiU	         &&
       GetStringTypeExU      &&
       CreateMutexU	         &&
       GetShortPathNameU     &&
       CreateFileU           &&
       WriteConsoleU         &&
       OutputDebugStringU    &&
       GetVersionExU         &&
       GetLocaleInfoU        &&
	   GetDateFormatU        &&
	   FindFirstFileU		 &&
	   FindNextFileU		 &&
	   LoadLibraryExU		 &&
	   LoadLibraryU			 &&
	   GetModuleFileNameU	 &&
	   GetModuleHandleU		 &&
	   CreateEventU			 &&
	   GetCurrentDirectoryU	 &&
	   SetCurrentDirectoryU  &&

	   CreateDialogParamU		  &&
	   IsDialogMessageU			  &&
	   CreateDialogIndirectParamU &&
	   SystemParametersInfoU	  &&
	   RegisterWindowMessageU	  &&
	   SetMenuItemInfoU			  &&
	   GetClassNameU			  &&
	   InsertMenuU				  &&
	   IsCharAlphaNumericU		  &&
	   CharNextU				  &&
	   DeleteFileU				  &&
	   IsBadStringPtrU			  &&
	   LoadBitmapU				  &&
	   LoadCursorU				  &&
	   LoadIconU				  &&
	   LoadImageU				  &&
	   SetPropU					  &&
	   GetPropU					  &&
	   RemovePropU				  &&
	   GetDlgItemTextU			  &&
	   SetDlgItemTextU			  &&
	   SetWindowLongU			  &&
	   GetWindowLongU			  &&
	   FindWindowU				  &&
	   DrawTextU				  &&
	   DrawTextExU				  &&
	   SendMessageU				  &&
	   SendDlgItemMessageU		  &&
	   SetWindowTextU			  &&
	   GetWindowTextU			  &&
	   GetWindowTextLengthU		  &&
	   LoadStringU				  &&
	   GetClassInfoExU			  &&
	   GetClassInfoU			  &&
	   RegisterClassExU			  &&
	   RegisterClassU			  &&
	   CreateWindowExU			  &&
	   LoadAcceleratorsU		  &&
	   LoadMenuU				  &&
	   DialogBoxParamU			  &&
	   CharUpperU				  &&
	   CharLowerU				  &&
	   GetTempFileNameU			  &&
	   GetTempPathU				  &&
	   CompareStringU			  &&

	   RegQueryInfoKeyU			  &&
	   RegEnumValueU			  &&
	   RegQueryValueExU			  &&
	   RegEnumKeyExU			  &&
	   RegSetValueExU			  &&
	   RegCreateKeyExU			  &&
	   RegOpenKeyExU			  &&
	   RegDeleteKeyU			  &&
	   RegDeleteValueU			  &&

       TranslateAcceleratorU	  &&
	   GetMessageU				  &&
	   DispatchMessageU			  &&
	   DefWindowProcU			  &&
	   GetObjectU				  &&
	   CreateAcceleratorTableU	  &&
	   SetWindowsHookExU		  &&
	   CreateDialogIndirectParamU &&
	   PeekMessageU				  &&
	   PostThreadMessageU		  &&

        // Add test for new U functions here

       UpdateUnicodeAPI			  &&
       ConvertMessage
       ) ) 
    {
        // Too early in intialization phase to use a localized message, so 
        // fall back to hard-coded English message
        MessageBoxW(
            NULL, 
            L"Cannot initialize Unicode functions. Press OK to exit ...", 
            L"Initialization Error",  
            MB_OK | MB_ICONERROR) ;

        return FALSE ;
    }

    return TRUE ;
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\umhandlers.h ===
//
// UMhandlers.h
//
// Copyright (c) 1998 Microsoft Systems Journal

#ifndef __UMHANDLERS
#define __UMHANDLERS

#include "..\app\usp10.h"

#define MAX_BUFFER      128000

// GDI constants for RTL mirroring standard windows 
#ifndef LAYOUT_RTL

#define LAYOUT_RTL                         0x00000001 // Right to left
#define LAYOUT_BTT                         0x00000002 // Bottom to top
#define LAYOUT_VBH                         0x00000004 // Vertical before horizontal
#define LAYOUT_ORIENTATIONMASK             (LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH)
#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008

#endif /* #ifndef LAYOUT_RTL */

#ifndef DATE_RTLREADING

#define DATE_LTRREADING           0x00000010  // add marks for left to right reading order layout
#define DATE_RTLREADING           0x00000020  // add marks for right to 

#endif /* DATE_RTLREADING */



// USER constants for RTL mirroring standard windows
#ifndef WS_EX_LAYOUTRTL

#define WS_EX_NOINHERITLAYOUT   0x00100000L // Disable inheritence of mirroring by children
#define WS_EX_LAYOUTRTL         0x00400000L  // Right to left mirroring

#endif /* #ifndef WS_EX_LAYOUTRTL */



// New langIDs that might not be in current header files
#ifndef LANG_HINDI
#define LANG_HINDI 0x39
#endif /* #ifndef LANG_HINDI */

#ifndef LANG_TAMIL
#define LANG_TAMIL 0x49
#endif /* #ifndef LANG_TAMIL */



// Global state specific to this application
typedef struct tagAppState {
    int         nChars    ;				// Number of chars in text buffer
    WCHAR       TextBuffer[MAX_BUFFER];
    CHOOSEFONTW cf        ;				// Save default values for next call to ChooseFont
    LOGFONTW    lf        ;				// Default lf struct
    HFONT       hTextFont ;				// Currently selected font handle
    UINT        uiAlign   ;				// Current alignment 
}   APP_STATE, *PAPP_STATE;

#define XSTART 10
#define YSTART 10

// Struct App State and Language/locale state
typedef struct tagGlobalDev
{
    PAPP_STATE pAppState ;
    PLANGSTATE pLState   ; // Language/locale state
}   GLOBALDEV, *PGLOBALDEV        ;

// typedefs of Uniscribe function pointers
typedef HRESULT (WINAPI *pfnScriptStringAnalyse) (  
        HDC            ,
        const void *   ,
        int            ,
        int            ,
        int            ,
        DWORD          ,
        int            ,
        SCRIPT_CONTROL *,
        SCRIPT_STATE * ,
        const int *    ,
        SCRIPT_TABDEF *,
        const BYTE *   ,
        SCRIPT_STRING_ANALYSIS * );

typedef HRESULT (WINAPI *pfnScriptStringOut)(  
        SCRIPT_STRING_ANALYSIS ,
        int                    ,
        int                    ,
        UINT                   ,
        const RECT *           ,
        int                    ,
        int                    ,
        BOOL) ;

typedef HRESULT (WINAPI *pfnScriptStringFree) (SCRIPT_STRING_ANALYSIS * ) ; 

// Prototypes for message handlers in this module
BOOL OnChar(HWND, WPARAM, LPARAM, LPVOID) ;
BOOL OnCreate(HWND, WPARAM, LPARAM, LPVOID) ;
BOOL OnInputLangChange(HWND, WPARAM, LPARAM, LPVOID) ;
BOOL OnPaint(HWND, WPARAM, LPARAM, LPVOID) ;
BOOL OnCommand(HWND, WPARAM, LPARAM, LPVOID) ;
BOOL OnDestroy(HWND, WPARAM, LPARAM, LPVOID) ;


// Miscellaneous
#define MB_BANG     (MB_OK | MB_ICONWARNING)

#ifndef MIN
#define MIN(_aa, _bb) ((_aa) < (_bb) ? (_aa) : (_bb))
#endif

// Just a handy macro for deleting a font in a control when the
// dialog is about to shut down or change fonts.
#define DeleteFontObject(_hDlg, _hFont, _CntlID) \
do{ \
_hFont = (HFONT) SendDlgItemMessageU(_hDlg, _CntlID, WM_GETFONT, \
        (WPARAM) 0,  (LPARAM) 0) ; \
if (_hFont) DeleteObject (_hFont) ; \
} while (0)

// Macro to get scan code on WM_CHAR
#ifdef _DEBUG
#define LPARAM_TOSCANCODE(_ArglParam) (((_ArglParam) >> 16) & 0x000000FF)
#endif

#endif /* __UMHANDLERS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\uniansidll\uaconv.h ===
#include <windows.h>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  NOTES TAKEN FROM MSDN 
//
//	Other Considerations
//
//	Dont use the macros in a tight loop. For example, you do NOT want to write the following kind of code:
//
//	void BadIterateCode(LPCTSTR lpsz)
//	{
//		USES_CONVERSION;
//		for (int ii = 0; ii < 10000; ii++)
//			pI->SomeMethod(ii, T2COLE(lpsz));
//	}
//
//	The code above could result in allocating megabytes of memory on the stack depending on what the contents 
//	of the string lpsz is!  It also takes time to convert the string for each iteration of the loop. Instead move 
//	such constant conversions out of the loop:
//
//	void MuchBetterIterateCode(LPCTSTR lpsz)
//	{
//		USES_CONVERSION;
//		LPCOLESTR lpszT = T2COLE(lpsz);
//		for (int ii = 0; ii < 10000; ii++)
//			pI->SomeMethod(ii, lpszT);
//	}
//
//	If the string is not constant, then encapsulate the method call into a function. This will allow the conversion 
//	buffer to be freed each time. For example:
//
//	void CallSomeMethod(int ii, LPCTSTR lpsz)
//	{
//		USES_CONVERSION;
//		pI->SomeMethod(ii, T2COLE(lpsz));
//	}
//	
//	void MuchBetterIterateCode2(LPCTSTR* lpszArray)
//	{
//		for (int ii = 0; ii < 10000; ii++)
//			CallSomeMethod(ii, lpszArray[ii]);
//	}
//
//	Never return the result of one of the macros, unless the return value implies making a copy of the data before the 
//	return. For example, this code is bad:
//
//	LPTSTR BadConvert(ISomeInterface* pI)
//	{
//		USES_CONVERSION;
//		LPOLESTR lpsz = NULL;
//		pI->GetFileName(&lpsz);
//		LPTSTR lpszT = OLE2T(lpsz);
//		CoMemFree(lpsz);
//		return lpszT; // bad! returning alloca memory
//	}
//	
//	The code above could be fixed by changing the return value to something which copies the value:
//
//	CString BetterConvert(ISomeInterface* pI)
//	{
//		USES_CONVERSION;
//		LPOLESTR lpsz = NULL;
//		pI->GetFileName(&lpsz);
//		LPTSTR lpszT = OLE2T(lpsz);
//		CoMemFree(lpsz);
//		return lpszT; // CString makes copy
//	}
//
//	The macros are easy to use and easy to insert into your code, but as you can tell from the caveats above, 
//	you need to be careful when using them.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef _INC_MALLOC
#include <malloc.h>
#endif // _INC_MALLOC

//////////////////////////////////////////////////////
// Code Ripped out of ATL Conversion header ATLCONV.H
//////////////////////////////////////////////////////

#ifdef _CONVERSION_USES_THREAD_LOCALE
	#ifndef _DEBUG
		#define USES_CONVERSION int _convert; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
	#else
		#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
	#endif
#else
	#ifndef _DEBUG
		#define USES_CONVERSION int _convert; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
	#else
		#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
	#endif
#endif


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	_ASSERT(lpa != NULL);
	_ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	
	if ( MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars) == 0 )
	{
		_ASSERT( TRUE );
		lpw = NULL; 
	}
	
	return lpw;
}

inline LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	_ASSERT(lpw != NULL);
	_ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	if ( WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL) == 0 )
	{
		_ASSERT( TRUE );
		lpa = NULL; 
	}
	return lpa;
}

inline LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	return A2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	return W2AHelper(lpa, lpw, nChars, CP_ACP);
}

#ifdef _CONVERSION_USES_THREAD_LOCALE
	#ifdef A2WHELPER
		#undef A2WHELPER
		#undef W2AHELPER
	#endif
	#define A2WHELPER A2WHelper
	#define W2AHELPER W2AHelper
#else
	#ifndef A2WHELPER
		#define A2WHELPER A2WHelper
		#define W2AHELPER W2AHelper
	#endif
#endif


//////////////////////////////////



#ifdef _CONVERSION_USES_THREAD_LOCALE
	#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			A2WHELPER((LPWSTR) alloca(_convert*2), _lpa, _convert, _acp)))
#else
	#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			A2WHELPER((LPWSTR) alloca(_convert*2), _lpa, _convert)))
#endif

#ifdef _CONVERSION_USES_THREAD_LOCALE
	#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			W2AHELPER((LPSTR) alloca(_convert), _lpw, _convert, _acp)))
#else
	#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			W2AHELPER((LPSTR) alloca(_convert), _lpw, _convert)))
#endif

//////////////////////////////////////
// MACROS FOR CONSTANTS
//////////////////////////////////////

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\updtlang.cpp ===
//
// UpdtLang.cpp
//

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "UAPI.h"
#include "UpdtLang.h"
#include "..\\resource.h"

extern WCHAR g_szTitle[MAX_LOADSTRING] ;

LANGID GetDefaultLangID() ;

//
//  FUNCTION: BOOL InitUILang(HINSTANCE hInstance, PLANGSTATE pLState) 
//
//  PURPOSE:  Determines the appropriate user interface language and calls 
//            UpdateUILang to set the user interface parameters
//
//  COMMENTS: 
// 
BOOL InitUILang(HINSTANCE hInstance, PLANGSTATE pLState) 
{
    OSVERSIONINFO Osv ;
    BOOL IsWindowsNT = FALSE ;

    LANGID wUILang = 0 ;

    Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;

    if(!GetVersionEx(&Osv)) {
        return FALSE ;
    }

    IsWindowsNT = (BOOL) (Osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ;

#ifdef EMULATE9X
//    IsWindowsNT = FALSE ;
#endif

    // Get the UI language by one of three methods, depending on the system
    if(!IsWindowsNT) {
        // Case 1: Running on Windows 9x. Get the system UI language from registry:
        CHAR szData[32]   ;
        DWORD dwErr, dwSize = sizeof(szData) ;
        HKEY hKey          ;

        dwErr = RegOpenKeyEx(
                    HKEY_USERS, 
                    ".Default\\Control Panel\\desktop\\ResourceLocale", 
                    0, 
                    KEY_READ, 
                    &hKey
                    ) ;

        if(ERROR_SUCCESS != dwErr) { // Hard coded error message, no resources loaded
            MessageBoxW(NULL,L"Failed RegOpenKey", L"Fatal Error", MB_OK | MB_ICONWARNING) ; 
            return FALSE ;
        }

        dwErr = RegQueryValueEx(   
                    hKey, 
                    "", 
                    NULL,  //reserved
                    NULL,  //type
                    (LPBYTE) szData,
                    &dwSize
                ) ; 

        if(ERROR_SUCCESS != dwErr) { // Hard coded error message, no resources loaded
            MessageBoxW(NULL, L"Failed RegQueryValueEx", L"Fatal Error", MB_OK | MB_ICONWARNING) ;
            return FALSE ;
        }

        dwErr = RegCloseKey(hKey) ;

        // Convert string to number
        wUILang = (LANGID) strtol(szData, NULL, 16) ;

    }
#if 1   
    /* Disable this section to emulate Windows NT before Windows 2000, when testing
           on Windows 2000 */   
    else if (Osv.dwMajorVersion >= 5.0) {
    // Case 2: Running on Windows 2000 or later. Use GetUserDefaultUILanguage to find 
    // the user's prefered UI language

        // Declare function pointer
        LANGID (WINAPI *pfnGetUserDefaultUILanguage) () = NULL ;

        HMODULE hMKernel32 = LoadLibraryW(L"kernel32.dll") ;
        
        pfnGetUserDefaultUILanguage = 
            (unsigned short (WINAPI *)(void)) 
                GetProcAddress(hMKernel32, "GetUserDefaultUILanguage") ;

        if(NULL != pfnGetUserDefaultUILanguage) {
            wUILang = pfnGetUserDefaultUILanguage() ;
        }
    }
#endif
    else {
    // Case 3: Running on Windows NT 4.0 or earlier. Get UI language
    // from locale of .default user in registry:
    // HKEY_USERS\.DEFAULT\Control Panel\International\Locale
        
        WCHAR szData[32]   ;
        DWORD dwErr, dwSize = sizeof(szData) ;
        HKEY hKey          ;

        dwErr = RegOpenKeyExW(
                    HKEY_USERS, 
                    L".DEFAULT\\Control Panel\\International", 
                    0, 
                    KEY_READ, 
                    &hKey
                    ) ;

        if(ERROR_SUCCESS != dwErr) {
            return FALSE ;
        }

        dwErr = RegQueryValueExW(   
                    hKey, 
                    L"Locale", 
                    NULL,  //reserved
                    NULL,  //type
                    (LPBYTE) szData,
                    &dwSize
                ) ; 

        if(ERROR_SUCCESS != dwErr) {
            return FALSE ;
        }

        dwErr = RegCloseKey(hKey) ;

        // Convert string to number
        wUILang = (LANGID) wcstol(szData, NULL, 16) ;
    }

    if(!wUILang) {
        return FALSE ;
    }

    // Get UI module resource module that matches wUILang.
    if(!UpdateUILang(hInstance, wUILang, pLState)
        &&  // In case we can't find the desired resource DLL ...
       !UpdateUILang(hInstance, FALLBACK_UI_LANG, pLState)
       ) { 

        return FALSE ;
    }

    return TRUE ;
}

//
//  FUNCTION: BOOL UpdateUILang(IN HINSTANCE hInstance, IN LANGID wUILang, OUT PLANGSTATE pLState) 
//
//  PURPOSE:  
//
//  COMMENTS: 
// 
BOOL UpdateUILang(IN HINSTANCE hInstance, IN LANGID wUILang, OUT PLANGSTATE pLState) 
{
    HMODULE hMRes = NULL ;
    HMENU      hNewMenu  = NULL ;

    pLState->UILang = wUILang ;

    // Find a resource dll file of the form .\resources\res<langid>.dll
    if(NULL == (hMRes = GetResourceModule(hInstance, pLState->UILang) )) {

        return FALSE ;
    }

    pLState->hMResource = hMRes ;

#if 0
    // If you don't trust that your res<langid>.dll files have the right
    // resources, activate this section. It will slow down the search. In a large project
    // the performance loss may be considerable.
    if(NULL == FindResourceExA(pLState->hMResource, RT_MENU, MAKEINTRESOURCEA(IDM_MENU), pLState->UILang)) {
        
        return FALSE ;
    }
#endif 

    hNewMenu = LoadMenuU (pLState->hMResource, MAKEINTRESOURCEW(IDM_MENU)) ;

    if(!hNewMenu) {

        return FALSE ;
    }

    if(pLState->hMenu) {
        
        DestroyMenu(pLState->hMenu) ;
    }

    pLState->hMenu = hNewMenu ;

    pLState->hAccelTable = LoadAcceleratorsU (pLState->hMResource, MAKEINTRESOURCEW(IDA_GLOBALDEV) ) ;

    pLState->InputCodePage = LangToCodePage( LOWORD(GetKeyboardLayout(0)) ) ;

    pLState->IsRTLLayout // Set right-to-left Window layout for relevant languages
        = PRIMARYLANGID(wUILang) == LANG_ARABIC 
       || PRIMARYLANGID(wUILang) == LANG_HEBREW ;

    if(pLState->IsRTLLayout) {
        
        // Another case where we have to get the function pointer explicitly.
        // You should just call SetProcessDefaultLayout directly if you know  
        // you're on Windows 2000 or greater, or on Arabic or Hebrew Windows 95/98
        BOOL   (CALLBACK *pfnSetProcessDefaultLayout) (DWORD) ;
        HMODULE hInstUser32 = LoadLibraryA("user32.dll") ;
        
        if (
            pfnSetProcessDefaultLayout = 
                (BOOL (CALLBACK *) (DWORD)) GetProcAddress (hInstUser32, "SetProcessDefaultLayout")
            ) {
                pfnSetProcessDefaultLayout(LAYOUT_RTL) ;
        }
    }

    UpdateUnicodeAPI(wUILang, pLState->InputCodePage) ;

    return TRUE ;
}

//
//  FUNCTION: UINT LangToCodePage(IN LANGID wLangID)
//
//  PURPOSE:  
//
//  COMMENTS: 
// 
UINT LangToCodePage(IN LANGID wLangID)
{
    WCHAR szLocaleData[6] ;

    // In this case there is no advantage to using the W or U
    // interfaces. We know the string in szLocaleData will consist of
    // digits 0-9, so there is no multilingual functionality lost by
    // using the A interface.
    GetLocaleInfoU(MAKELCID(wLangID, SORT_DEFAULT) , LOCALE_IDEFAULTANSICODEPAGE, szLocaleData, 6);

		
    return wcstoul(szLocaleData, NULL, 10);
}


//
//  FUNCTION: HMODULE GetResourceModule(HINSTANCE hInstance, LCID dwLocaleID)
//
//  PURPOSE:  
//
//  COMMENTS: 
// 
HMODULE GetResourceModule(HINSTANCE hInstance, LCID dwLocaleID)
{
    WCHAR  szResourceFileName[MAX_PATH] = {L'\0'} ;

    if(!FindResourceDirectory(hInstance, szResourceFileName)) {

        return NULL ;
    }

    wcscat(szResourceFileName, L"\\res") ;

    // Convert the LocaleID to Unicode and append to resourcefile name.
    _itow(dwLocaleID, szResourceFileName+wcslen(szResourceFileName), 16) ;

    // Add DLL extention to file name
    wcscat(szResourceFileName, L".dll") ;

    return LoadLibraryExU(szResourceFileName, NULL, 0) ;

}

//
//  FUNCTION: BOOL FindResourceDirectory(IN HINSTANCE hInstance, OUT LPWSTR szResourceFileName)
//
//  PURPOSE:  
//
//  COMMENTS: 
// 
BOOL FindResourceDirectory(IN HINSTANCE hInstance, OUT LPWSTR szResourceFileName)
{
    LPWSTR pExeName ;

    if(!GetModuleFileNameU(hInstance, szResourceFileName, MAX_PATH)) {

        return FALSE;
    }

    CharLowerU (szResourceFileName) ;

    if((pExeName = wcsstr(szResourceFileName, L"globaldv.exe"))) {
        *pExeName = L'\0' ;
    }

    // This assumes that all resources DLLs are in a directory called
    // "resources" below the directory where the application exe
    // file is
    wcscat(szResourceFileName, L"resources") ;

    return TRUE ;
}


//
//  FUNCTION: RcMessageBox (HWND, INT, INT, INT, ...)
//
//  PURPOSE: Display a message box with formated output similar to sprintf
//
//  COMMENTS:
//      This function loads the string identified by nMessageID from the 
//      resource segment, uses vswprintf to format it using the variable
//      parameters, and displays it to the user in a message box using the
//      icons and options specified by nOptions.
//
int RcMessageBox(
        HWND hWnd         ,   // Window handle for displaying MessageBox
        PLANGSTATE pLState,   // Language data
        int nMessageID    ,   // Message ID in resources
        int nOptions      ,   // Options to pass to MessageBox
        ...)                  // Optional parameters, depending on string resource 
{
    WCHAR szLoadBuff[MAX_LOADSTRING], szOutPutBuff[3*MAX_LOADSTRING] ;
    va_list valArgs ;

    int nCharsLoaded = 0 ;
    
    va_start(valArgs, nOptions) ;
    
    if (!(nCharsLoaded
            =LoadStringU(
                pLState->hMResource,
                nMessageID, 
                szLoadBuff, 
                MAX_LOADSTRING
            ))
        ) {
        return 0 ;
    }

    vswprintf(szOutPutBuff, szLoadBuff, valArgs) ;
    
    va_end(valArgs) ;

    if (pLState->IsRTLLayout)  {
        nOptions |= MB_RTLREADING ;
    }

    return (MessageBoxExW(hWnd, szOutPutBuff, g_szTitle, nOptions, pLState->UILang)) ;
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\test\globaldv\umhandlers.cpp ===
//
// UMhandlers.cpp
//
// This module contains the message handlers used by GlobalDv.cpp
/// Copyright (c) 1998 Microsoft Systems Journal


#define WINVER 0x5000

#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#include "tests.h"
#define BUF_SIZE  512

#include "UAPI.h"
#include "UpdtLang.h"
#include "UMhandlers.h"
#include <malloc.h>
#include <crtdbg.h>
#include "..\resource.h"
#include "resource.h"
// Dialog Box callback functions
INT_PTR CALLBACK DlgAbout(HWND, UINT, WPARAM, LPARAM) ;
INT_PTR CALLBACK DlgTestNLS(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) ;
INT_PTR CALLBACK DlgSelectUILang(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) ;
INT_PTR CALLBACK DlgEditControl(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) ;

// Utility functions used only herein
void InitializeFont(HWND , LPCWSTR, LONG , LPCHOOSEFONTW , LPLOGFONTW) ;
BOOL SetupComboBox(HWND hDlg, PLANGSTATE pLState) ;
BOOL UniscribeTextOut(HDC hdc, int x, int y, DWORD, UINT fuOptions, CONST RECT *lprc,
                      LPCWSTR lpString, UINT cbCount) ;

HRESULT WINAPI ScriptStringInit(  // Initialization routine for Uniscribe functions
    HDC             ,
    const void *    ,
    int             ,
    int             ,
    int             ,
    DWORD           ,
    int             ,
    SCRIPT_CONTROL *,
    SCRIPT_STATE *  ,
    const int *     ,
    SCRIPT_TABDEF * ,
    const BYTE *    ,
    SCRIPT_STRING_ANALYSIS *) ;

// Global variables used only by UniscribeTextOut
HMODULE g_hUniscribe = NULL ;

pfnScriptStringAnalyse pScriptStringAnalyse // Initially set to intialization function
            = (pfnScriptStringAnalyse) ScriptStringInit ;
pfnScriptStringOut     pScriptStringOut     = NULL ;
pfnScriptStringFree    pScriptStringFree    = NULL ;

// Global variables used throughout this sample
extern    HINSTANCE g_hInst                         ;
extern    WCHAR     g_szTitle[MAX_LOADSTRING]       ;
extern    WCHAR     g_szWindowClass[MAX_LOADSTRING] ;

WCHAR               g_szWindowText[MAX_LOADSTRING]  ;


//
//  FUNCTION: BOOL OnCreate(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_CREATE Message.
//
//  COMMENTS: 
//      Initialization done in this function is dependent on the hWnd or specific to 
//      the application. Other initialization is done in InitUnicodeAPI and InitUILang.
//      The pAppParams parameter is not used.
//
BOOL OnCreate(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
    PGLOBALDEV pGlobalDev = (PGLOBALDEV) ((CREATESTRUCT *) lParam)->lpCreateParams ;

    PLANGSTATE pLState    = (PLANGSTATE) pGlobalDev->pLState   ; 
    PAPP_STATE pAppState  = (PAPP_STATE) pGlobalDev->pAppState ;

    SYSTEMTIME   stDate ;

    // Set USERDATA to point to the state structure so it can be used by all message
    // handlers without using global variables
    SetWindowLongA(hWnd, GWL_USERDATA, (LONG) pGlobalDev) ;

    // pLState was initialized already in UpdtLang module, InitUILang entry point
    // We couldn't do this there because we didn't have an hWnd.
    SetMenu(hWnd, pLState->hMenu) ;

    // Initialize state specific to this application
    InitializeFont(hWnd, L"Arial", 36, &pAppState->cf, &pAppState->lf ) ;

    pAppState->hTextFont = CreateFontIndirectU(&(pAppState->lf) ) ;
    pAppState->nChars    = 0       ;
    pAppState->uiAlign   = TA_LEFT ;

    wcscpy(g_szWindowText, g_szWindowClass) ;

    GetLocalTime(&stDate) ;

    GetDateFormatU(
        pLState->UILang, 
        DATE_LONGDATE,
        &stDate,
        NULL,
        g_szWindowText + wcslen(g_szWindowText) , // Append date to end of Window Text
        MAX_LOADSTRING - wcslen(g_szWindowText)
        ) ;

    SetWindowTextU(hWnd, g_szWindowText) ;

    return TRUE;
}


//
//  FUNCTION:  BOOL OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_COMMAND Message.
//
//  COMMENTS: 
// 
BOOL OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
    PGLOBALDEV pGlobalDev = (PGLOBALDEV) pAppParams ;

    PLANGSTATE pLState   = pGlobalDev->pLState   ;
    PAPP_STATE pAppState = pGlobalDev->pAppState ;
    LANGID     wUILang   = 0                     ;
    HMODULE    hNewModule= NULL                  ;
    SYSTEMTIME stDate                            ;
    LONG lExStyles       = 0                     ;
    LPWSTR     szBuffPtr = NULL                  ;                  

    WCHAR szNewLangName[32] ;

    // Parse the menu selections:
    switch (LOWORD(wParam)) {
        
        case IDM_ABOUT:

            DialogBoxU(
                pLState->hMResource, 
                MAKEINTRESOURCEW(IDD_ABOUTBOX) , 
                hWnd, 
                DlgAbout
                ) ;
           
            break ;
        
        case IDM_CHANGEFONT:

             if(NULL != pAppState->hTextFont) 
			 {
                 DeleteObject(pAppState->hTextFont) ;
             }
            
             ChooseFontU(&pAppState->cf ) ;
             pAppState->hTextFont = CreateFontIndirectU(&pAppState->lf) ;
             InvalidateRect(hWnd, NULL, TRUE) ;
            
             break ;

        case IDM_INTERFACE:

            wUILang = DialogBoxParamU( // Get the new UI language from Dialog
                        pLState->hMResource, 
                        MAKEINTRESOURCEW(IDD_SELECTUI), 
                        hWnd, 
                        DlgSelectUILang, 
                        (LONG) pLState) ;

            if(0 == wUILang || wUILang == pLState->UILang ) {
                // No change in UI lang
                break ;
            }

            if(!UpdateUILang(g_hInst, wUILang, pLState)) {

                return FALSE ;
            }

            // Using ANSI versions of GetWindowLong and SetWindowLong because 
            // Unicode is not needed for these calls
            lExStyles = GetWindowLongA(hWnd, GWL_EXSTYLE) ;

            // Check whether new layout is opposite the current layout
            if(!!(pLState->IsRTLLayout) != !!(lExStyles & WS_EX_LAYOUTRTL)) {
                // The following lines will update the application layout to 
                // be right to left or left to right as appropriate
                lExStyles ^= WS_EX_LAYOUTRTL ; // Toggle layout

                SetWindowLongA(hWnd, GWL_EXSTYLE, lExStyles) ;
                // This is to update layout in the client area
                InvalidateRect(hWnd, NULL, TRUE) ;
            }

            SetMenu(hWnd, pLState->hMenu) ;

            LoadStringU(pLState->hMResource, IDS_GLOBALDEV, g_szWindowText, MAX_LOADSTRING) ;
            LoadStringU(pLState->hMResource, IDS_APP_TITLE, g_szTitle, MAX_LOADSTRING) ;

            GetSystemTime(&stDate) ;

            GetDateFormatU(
                wUILang,  
                DATE_LONGDATE, 
                &stDate,
                NULL,
                g_szWindowText + wcslen(g_szWindowText) ,
                MAX_LOADSTRING - wcslen(g_szWindowText)
                ) ;

            SetWindowTextU(hWnd, g_szWindowText) ;

            GetLocaleInfoU(
                MAKELCID(wUILang, SORT_DEFAULT), 
                LOCALE_SNATIVELANGNAME, 
                szNewLangName, 
                32) ;

            // Announce the new language to the user
            RcMessageBox(hWnd, pLState, IDS_UILANGCHANGED, MB_OK, szNewLangName) ;

            break ;

	//	case IDM_LOADLIBRARY:


			


			break;
        case IDM_PLAYSOUNDS:
/*			
			//Allocate buffer to play sounds
			szBuffPtr = (LPWSTR) alloca( BUF_SIZE );

			//Load the sound
			if ( LoadStringU( pLState->hMResource, IDS_FILESOUND, szBuffPtr, BUF_SIZE ) == 0 )
			{
				_ASSERT( FALSE );
				break;
			}
			
			//First test loading a sound from a file
			if ( !PlaySoundU( szBuffPtr, NULL ,SND_SYNC | SND_FILENAME) )
			{
				_ASSERT( FALSE );
				break;
			}

			//Now try loading a resource			
			if ( !PlaySoundU( (LPCWSTR) MAKEINTRESOURCE(IDR_WAVE1),(HINSTANCE) GetWindowLong(hWnd, GWL_HINSTANCE) ,SND_SYNC | SND_RESOURCE) )
			{
				_ASSERT( FALSE );
				break;
			}
*/
			TestKernel32(hWnd, GetDC(hWnd) );

			break;
        case IDM_TOGGLEREADINGORDER:

            pAppState->uiAlign ^= TA_RTLREADING ;
            InvalidateRect (hWnd, NULL, TRUE) ;

            break ;

        case IDM_TOGGLEALIGNMENT:

            pAppState->uiAlign ^= (TA_RIGHT & ~TA_LEFT) ;
            InvalidateRect (hWnd, NULL, TRUE) ;

            break ;

        case IDM_USEEDITCONTROL :
             
            // Use an edit control to enter and display text.
            pAppState->TextBuffer[pAppState->nChars] = L'\0' ;

            szBuffPtr = (LPWSTR) 
                DialogBoxParamU(
                    pLState->hMResource                 ,
                    MAKEINTRESOURCEW(IDD_USEEDITCONTROL),
                    hWnd                                ,
                    DlgEditControl            ,
                    (LONG) pAppState->TextBuffer ) ;

            pAppState->nChars = wcslen(szBuffPtr) ;

            InvalidateRect(hWnd, NULL, TRUE) ;

            break ;

        case IDM_CLEAR:

            pAppState->nChars = 0 ;
            InvalidateRect(hWnd, NULL, TRUE) ;

            break ;

        case IDM_EXIT:

            DestroyWindow(hWnd) ;
            
            break ;
        
        default:
            return FALSE ; 
    }
    return TRUE ;
}

//
//  FUNCTION:  BOOL OnDestroy(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_DESTROY message.  
//
//  COMMENTS: 
// 
BOOL OnDestroy(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
    PLANGSTATE pLState = (PLANGSTATE) pAppParams ;

    DestroyMenu(pLState->hMenu) ;
    PostQuitMessage(0);
    return TRUE ;
}

//
//  FUNCTION:  BOOL OnChar(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_CHAR Message.  
//
//  COMMENTS: 
// 
BOOL OnChar(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
// Note that we only get Unicode characters here, even on Windows 95/98,
// because we converted all characters in the message preprocessor
// ConvertMessage

    PAPP_STATE pAppState= (PAPP_STATE) pAppParams ;

    switch (wParam) 
	{
    
    case VK_BACK :
        
        if (pAppState->nChars > 0) {

            pAppState->nChars-- ;           
            InvalidateRect(hWnd, NULL, TRUE) ;
        }

        break ;
        
    // Add processing for other special characters (e.g, return) here.
    default:
        {
#ifdef _DEBUG
            int nScanCode = LPARAM_TOSCANCODE(lParam) ;
#endif
            // Process all normal characters
            pAppState->TextBuffer[pAppState->nChars] = (WCHAR) wParam ;

            if(pAppState->nChars < MAX_BUFFER) {
        
                pAppState->nChars++ ;
            }

            InvalidateRect(hWnd, NULL, TRUE) ;
        
            return TRUE;
        }
    }

    return TRUE ;        
}

//
//  FUNCTION:  BOOL OnInputLangChange(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_INPUTLANGCHANGE Message.  
//
//  COMMENTS: 
// 
BOOL OnInputLangChange(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
    PLANGSTATE pLState = (PLANGSTATE) pAppParams ;

    HKL NewInputLocale = (HKL) lParam ;

    pLState->InputCodePage = LangToCodePage( LOWORD(NewInputLocale) ) ;

    return TRUE ;
}

//
//  FUNCTION:  BOOL UniscribeTextOut(HDC hdc, int x, int y, DWORD dwFlags, UINT fuOptions, CONST RECT *lprt,
//                      LPCWSTR lpString, UINT cbCount) 
//
//  PURPOSE:  
//
//  COMMENTS: 
// 
BOOL UniscribeTextOut(HDC hdc, int x, int y, DWORD dwFlags, UINT fuOptions, CONST RECT *lprt,
                      LPCWSTR lpString, UINT cbCount) 
{

    SCRIPT_STRING_ANALYSIS Ssa ;
    HRESULT hr                 ;

    hr = pScriptStringAnalyse(
            hdc          ,
            lpString     ,
            cbCount      ,
            cbCount*3/2+1, // Worse case for Thai, if every other character is SARA AM
            -1           ,
            dwFlags      ,
            0            ,
            NULL, NULL, NULL, NULL, NULL, &Ssa) ;


    if(SUCCEEDED(hr)) {
        hr = pScriptStringOut(
                Ssa      ,
                x        , 
                y        , 
                fuOptions,
                lprt     ,
                0,0, FALSE ) ;

        pScriptStringFree(&Ssa) ;

    }

    if(SUCCEEDED(hr)) {
        
        return TRUE ;
    }

    return FALSE ;
}

//
//  FUNCTION: BOOL OnPaint(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
//
//  PURPOSE:  Handles the WM_PAINT Message.  
//
//  COMMENTS: 
// 
BOOL OnPaint(HWND hWnd, WPARAM wParam, LPARAM lParam, LPVOID pAppParams)
{
    PAPP_STATE pAppState= (PAPP_STATE) pAppParams ;

    PAINTSTRUCT ps ;
    HDC         hdc;

    int xStart = XSTART , yStart = YSTART ;

    hdc = BeginPaint(hWnd, &ps) ;
    
    if(pAppState->nChars) 
	{
        RECT rt;
        DWORD dwFlags = SSA_GLYPHS | SSA_FALLBACK ;

        if (pAppState->uiAlign & TA_RTLREADING) 
		{
            dwFlags |= SSA_RTL ;
        } 

        GetClientRect(hWnd, &rt) ;
        SelectObject(hdc, pAppState->hTextFont) ;
        SetTextAlign(hdc, pAppState->uiAlign)   ;

        if (pAppState->uiAlign & TA_RIGHT) 
		{
            xStart = rt.right - XSTART ;
        } 

//      // Try using Uniscribe to display text
      if( !UniscribeTextOut(hdc, xStart, yStart, dwFlags, ETO_OPAQUE, &rt, pAppState->TextBuffer, pAppState->nChars ) ) 
		{

			for(;;)
			{
				// If Uniscribe not available, give up, use TextOut
				ExtTextOutW (hdc, xStart , yStart , ETO_OPAQUE, &rt, pAppState->TextBuffer, pAppState->nChars, NULL) ;
				break;
			}

       }
    }

    EndPaint(hWnd, &ps) ;

    return TRUE ;
}


//
//   FUNCTION: InitializeFont(HWND , LPCWSTR, LONG , LPCHOOSEFONT , LPLOGFONT)
//
//   PURPOSE:  Fills in font structures with initial values. 
//
//   COMMENTS:  Since it contains only assignment statements, this function does no
//              error checking, has no return value..
//
void InitializeFont(HWND hWnd, LPCWSTR szFaceName, LONG lHeight, LPCHOOSEFONTW lpCf, LPLOGFONTW lpLf)
{
    lpCf->lStructSize   = sizeof(CHOOSEFONTW) ;
    lpCf->hwndOwner     = hWnd ;
    lpCf->hDC           = NULL ;
    lpCf->lpLogFont     = lpLf ;
    lpCf->iPointSize    = 10;
    lpCf->Flags         = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT
        | CF_NOSIZESEL ;
    lpCf->rgbColors     = RGB(0,0,0);
    lpCf->lCustData     = 0;
    lpCf->lpfnHook      = NULL;
    lpCf->lpTemplateName= NULL;
    lpCf->hInstance     = g_hInst;
    lpCf->lpszStyle     = NULL;
    lpCf->nFontType     = SIMULATED_FONTTYPE;
    lpCf->nSizeMin      = 0;
    lpCf->nSizeMax      = 0;
    
    lpLf->lfHeight      = lHeight ; 
    lpLf->lfWidth       = 0 ; 
    lpLf->lfEscapement  = 0 ; 
    lpLf->lfOrientation = 0 ; 
    lpLf->lfWeight      = FW_DONTCARE ; 
    lpLf->lfItalic      = FALSE ; 
    lpLf->lfUnderline   = FALSE ; 
    lpLf->lfStrikeOut   = FALSE ; 
    lpLf->lfCharSet     = DEFAULT_CHARSET ; 
    lpLf->lfOutPrecision= OUT_DEFAULT_PRECIS ; 
    lpLf->lfClipPrecision = CLIP_DEFAULT_PRECIS ; 
    lpLf->lfQuality     = DEFAULT_QUALITY ; 
    lpLf->lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE ; 
    lstrcpyW(lpLf->lfFaceName, szFaceName) ;
}

//
//  FUNCTION: INT_PTR CALLBACK DlgAbout(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  Dialog callback function for about box.
//
//  COMMENTS: 
// 
INT_PTR CALLBACK DlgAbout(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:

            return TRUE;

        case WM_COMMAND:

            if(LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }

    return FALSE ;
}

//
//   FUNCTION: INT_PTR CALLBACK EditDialogProc (HWND , UINT , WPARAM , LPARAM)
//
//   PURPOSE: Dialog callback function for the edit control dialog box.
//
//   COMMENTS:
//        This is standard processing for edit controls.
//
INT_PTR CALLBACK DlgEditControl(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Should get rid of these statics some day
    static LPWSTR       psEditBuffer ;
    static CHOOSEFONTW  cf           ; 
    static LOGFONTW     lf           ;
    static LONG         lAlign = 0   ;

    HFONT               hEditFont    ;
    HWND                hWndEdit     ;
    int                 nChars       ;

    switch (uMsg)
    {
    case WM_INITDIALOG :

        InitializeFont(hDlg, L"Arial", 24, &cf, &lf) ;
        hEditFont = CreateFontIndirectU(&lf) ;
        
        // Set font of edit control
        SendDlgItemMessageU(hDlg, ID_EDITCONTROL, WM_SETFONT, 
            (WPARAM) hEditFont,  MAKELPARAM(TRUE, 0)) ;
        psEditBuffer = (LPWSTR) lParam ; // lParam is the display buffer
        nChars = wcslen(psEditBuffer) ;

        SendDlgItemMessageU(hDlg, ID_EDITCONTROL, WM_SETTEXT, (WPARAM)0,  
            (LPARAM) psEditBuffer) ; 
        
        return TRUE ;
        
    case WM_CLOSE :
        
        // Macro in UMHANDLERS.H 
        DeleteFontObject (hDlg, hEditFont, ID_EDITCONTROL ) ;

        EndDialog (hDlg, wParam) ; 
        
        return 0 ;
        
    case WM_COMMAND :
        
        switch (wParam)
        {
        case IDE_EDIT_FONT :

            // Macro in UMHANDLERS.H 
            DeleteFontObject(hDlg, hEditFont, ID_EDITCONTROL ) ;

            ChooseFontU(&cf) ;
            hEditFont = CreateFontIndirectU(&lf) ;
            
            SendDlgItemMessageU(hDlg, ID_EDITCONTROL, WM_SETFONT, 
                (WPARAM) hEditFont,  MAKELPARAM(TRUE, 0)) ;

            break ;
            
        case IDE_READINGORDER :

            hWndEdit = GetDlgItem(hDlg, ID_EDITCONTROL)  ;

            lAlign   = GetWindowLongA(hWndEdit, GWL_EXSTYLE) ^ WS_EX_RTLREADING ;
            
            SetWindowLongA(hWndEdit, GWL_EXSTYLE, lAlign); 
            InvalidateRect(hWndEdit ,NULL, TRUE)         ;
       
            break ;

        case IDE_TOGGLEALIGN :
            
            hWndEdit = GetDlgItem (hDlg, ID_EDITCONTROL) ;
 
            lAlign   = GetWindowLongA(hWndEdit, GWL_EXSTYLE) ^ WS_EX_RIGHT ;
            
            SetWindowLongA(hWndEdit, GWL_EXSTYLE, lAlign); 
            InvalidateRect(hWndEdit, NULL, FALSE)        ;

            break ;

        case IDE_CLEAR :
            
            hWndEdit = GetDlgItem (hDlg, ID_EDITCONTROL) ;
            SetWindowTextU(hWndEdit, L"") ;
            
            break ;
            
        case IDE_CLOSE :
            
            // Send the current text back to the parent window
            hWndEdit = GetDlgItem (hDlg, ID_EDITCONTROL) ; 

            nChars   = GetWindowTextU(hWndEdit, psEditBuffer, BUFFER_SIZE-1) ;
            psEditBuffer[nChars] = 0 ;

            // Macro in UMHANDLERS.H 
            DeleteFontObject (hDlg, hEditFont, ID_EDITCONTROL ) ;

            EndDialog (hDlg, (int) psEditBuffer) ; 
        }
    }
    
    return FALSE ;
}

//
//  FUNCTION: INT_PTR CALLBACK DlgSelectUILang(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  Dialog callback function for dialog box for selecting user interface language 
//
//  COMMENTS: 
// 
INT_PTR CALLBACK DlgSelectUILang(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PLANGSTATE pLState      ;
    static LCID       s_dwUILocale ;

    int   nIndex      ;
    HFONT hFont       ; 
    int   nReturn = 0 ;

    switch (message) 
	{

    case WM_INITDIALOG:

        pLState = (PLANGSTATE) lParam ;

        s_dwUILocale = pLState->UILang  ;

        if(!SetupComboBox(hDlg, pLState)) {

            // Macro in UMHANDLERS.H 
            DeleteFontObject(hDlg, hFont, IDC_UILANGLIST ) ;

            EndDialog(hDlg, 0) ;
        }

        return TRUE ;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK :

            nReturn = (int) s_dwUILocale ;

        case IDCANCEL :

            // Macro in UMHANDLERS.H 
            DeleteFontObject(hDlg, hFont, IDC_UILANGLIST ) ;

            EndDialog(hDlg, nReturn) ;

            return TRUE ;

        }



        switch (HIWORD(wParam)) {

            case CBN_SELCHANGE :
            case CBN_DBLCLK :

                nIndex = (int) SendMessageU((HWND) lParam, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0) ;

                if(CB_ERR == nIndex)
                {
                    return 0 ;
                }
        
                s_dwUILocale = (LCID) SendMessageU( (HWND) lParam, CB_GETITEMDATA, (WPARAM) nIndex, (LPARAM) 0 ) ;

                return 0 ;
        }

    }

    return FALSE;
}

//
//  FUNCTION: BOOL SetupComboBox(HWND hDlg, PLANGSTATE pLState) 
//
//  PURPOSE:  Fill in the list and Edit control in the Combo Box for selecting
//            a new user interface
//
//  COMMENTS: 
//        This function finds all resource DLLs and puts an entry for each
//        DLL found in the list of languages in the combo box 
// 
BOOL SetupComboBox(HWND hDlg, PLANGSTATE pLState) 
{
    HFONT hFont = NULL  ;
    int   nIndex = 0    ;

    WIN32_FIND_DATAW wfd;
    HANDLE hFindFile    ;
    WCHAR  szResourceFileName[MAX_PATH] = {L'\0'} ;

    CHOOSEFONTW  cf     ;
    LOGFONTW     lf     ;

    // For now, use font that displays most languages, with the help of font
    // linking and font fallback. Might not work on some localized Windows 98
    // systems
    InitializeFont(hDlg, L"MS UI Gothic", 18, &cf, &lf) ;
    hFont = CreateFontIndirectU(&lf) ;
    SendDlgItemMessageU(hDlg, IDC_UILANGLIST, WM_SETFONT, (WPARAM) hFont, (LPARAM) FALSE) ;

    FindResourceDirectory(g_hInst, szResourceFileName) ;

    wcscat(szResourceFileName, L"\\res*.dll") ;

    if(INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileU(szResourceFileName, &wfd))) {
        // This should never happen, since we had to have at least one resource file to get
        // to this point in the application
        return FALSE ;
    }	

    do {
        // Having found a resource file, put an entry in the combox box with the name
        // of the language respresented by the resource file name
        LANGID wFileLang ;
        
        WCHAR szLangName[32] = {L'\0'} ;
        
        wFileLang  // Skip first three letters ("RES") of filename, convert the rest to a langID.
            = (LANGID) wcstoul(wfd.cFileName+3, NULL, 16) ;

        GetLocaleInfoU( MAKELCID(wFileLang, SORT_DEFAULT) , LOCALE_SNATIVELANGNAME, szLangName, 32) ;

        if(CB_ERR == SendDlgItemMessageU(hDlg, IDC_UILANGLIST, CB_INSERTSTRING, nIndex, (LPARAM) szLangName)) 
		{ 
            break ;
        }

        // Store the langID of the current resource DLL in the combo-box data area
        // for later use
        SendDlgItemMessageU(hDlg, IDC_UILANGLIST, CB_SETITEMDATA, nIndex, (LPARAM) wFileLang) ;

        if(wFileLang == pLState->UILang) {
            // Put the current language in the combo box edit control
            SendDlgItemMessageU(hDlg, IDC_UILANGLIST, CB_SETCURSEL, nIndex, 0L ) ;
        }

        nIndex++ ;
    }
    // Look for another resouce DLL 
    while (FindNextFileU(hFindFile, &wfd) ) ;

    FindClose(hFindFile) ;

    return TRUE ;

} 

//
//  FUNCTION: HRESULT ScriptStringInit(HDC, ...)
//
//  PURPOSE:  Initialize ScriptString* function pointers. 
//
//  COMMENTS: 
//        The function pointer pScriptStringAnalyze is initially set to point to this
//        function, so that the first time it is called this function will load USP10.DLL
//        and set all three function pointers to the appropriate addresses. If that
//        completes successfully, this function calls ScriptStringAnalyze with the parameters
//        it was passed. Thereafter function calls to pScriptStringAnalyze and the other
//        function pointers will go to the corresponcing entry point in the DLL. 
// 
HRESULT WINAPI ScriptStringInit(
    HDC                      hdc,       //In  Device context (required)
    const void              *pString,   //In  String in 8 or 16 bit characters
    int                      cString,   //In  Length in characters (Must be at least 1)
    int                      cGlyphs,   //In  Required glyph buffer size (default cString*3/2 + 1)
    int                      iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                    dwFlags,   //In  Analysis required
    int                      iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL          *psControl, //In  Analysis control (optional)
    SCRIPT_STATE            *psState,   //In  Analysis initial state (optional)
    const int               *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF           *pTabdef,   //In  Tab positions (optional)
    const BYTE              *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    SCRIPT_STRING_ANALYSIS  *pssa)     //Out Analysis of string
{
    g_hUniscribe = LoadLibraryExA("USP10.DLL", NULL, 0 ) ;

    if(g_hUniscribe) {
        pScriptStringOut 
            = (pfnScriptStringOut) GetProcAddress(g_hUniscribe, "ScriptStringOut") ;
        pScriptStringAnalyse 
            = (pfnScriptStringAnalyse) GetProcAddress(g_hUniscribe, "ScriptStringAnalyse") ;
        pScriptStringFree
            = (pfnScriptStringFree) GetProcAddress(g_hUniscribe, "ScriptStringFree") ;
    }

    if(    NULL == pScriptStringAnalyse 
        || NULL == pScriptStringOut
        || NULL == pScriptStringFree)  {

        return E_NOTIMPL ;
    }

    return pScriptStringAnalyse(
        hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl,
            psState, piDx, pTabdef, pbInClass, pssa) ;
}





#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\plugnplay.cpp ===
#include "stdafx.h"
#include "mshtml.h"   // the local one, updated from the one currenrly in our build (also includes dimm.h...???)
#include <ExDispID.h>
#include "ZoneShell.h"
#include "thing.h"
#include "plugnplay.h"
#include "ZoneString.h"
#include "keyname.h"
#include "zoneutil.h"
#include "protocol.h"
#include "MillEngine.h"

#include "ZoneResource.h"       // main symbols
#include <zGDI.h>
#include <zDialogImpl.h>

#undef MILL_EASTEREGG

#define NOACC -1
#define YESACC 2

inline DECLARE_MAYBE_FUNCTION(DWORD, SetLayout, (HDC hdc, DWORD dwLayout), (hdc, dwLayout), gdi32, GDI_ERROR);

class CPaneSplash : public CPaneImpl<CPaneSplash>
{
    // desired margin and dialog size set on init
    int16 m_nMarginWidth;

	CDib m_bitmap;		// splash bitmap
    CDib m_bitmapAbout; // about bitmap

    bool m_fAbout;
	
public:
	enum { IDD = IDD_PLUG_SPLASH };
    enum { AccOrdinal = NOACC };

	
BEGIN_MSG_MAP(CPaneSplash)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_COMMAND, OnCommand)
    MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    CHAIN_MSG_MAP(CPaneImpl<CPaneSplash>)
END_MSG_MAP()

	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;

		m_bitmap.LoadBitmapWithText(IDB_GAME_SPLASH, m_pMgr->GetResourceManager(), m_pMgr->GetDataStoreUI());
        DrawDynTextToBitmap((HBITMAP) m_bitmap, m_pMgr->GetDataStoreUI(), _T("BitmapText/Splash"));

        m_bitmapAbout.LoadBitmapWithText(IDB_GAME_SPLASH, m_pMgr->GetResourceManager(), m_pMgr->GetDataStoreUI());

        m_fAbout = false;

	    return S_OK;
	}


	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        // find size we like - fix height to match bitmap
        CRect rcDialog;
        GetWindowRect(&rcDialog);
        m_ze = rcDialog.Size();

		CRect rcBitmap;
		CWindow wndBitmap(GetDlgItem(IDC_SPLASH_IMAGE));
		wndBitmap.GetWindowRect(&rcBitmap);
        m_ze.cy -= rcBitmap.Height() - m_bitmap.Height();

        // remember the total width of the margins we have
        GetClientRect(&rcDialog);
        m_nMarginWidth = rcDialog.Width() - rcBitmap.Width();

        // in case i don't get a resize, make the static control the right height now
		SuperScreenToClient(rcBitmap);
        rcBitmap.bottom -= rcBitmap.Height() - m_bitmap.Height();
        wndBitmap.MoveWindow(rcBitmap, FALSE);

        Register();

		return TRUE;
	}


	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();
		
		return TRUE;
	}


    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPDRAWITEMSTRUCT pDrawItem = (LPDRAWITEMSTRUCT) lParam;
        CDC dc;
        CDib *pDib;

        if(pDrawItem->CtlType != ODT_STATIC || (UINT) wParam != IDC_SPLASH_IMAGE)
        {
            bHandled = FALSE;
            return 0;
        }

        if(m_fAbout)
            pDib = &m_bitmapAbout;
        else
            pDib = &m_bitmap;

        CRect r(pDrawItem->rcItem);
        CRect rBitmap(r.left, r.top, r.left + pDib->Width(), r.top + pDib->Height());

        CALL_MAYBE(SetLayout)(pDrawItem->hDC, LAYOUT_BITMAPORIENTATIONPRESERVED);
        dc.Attach(pDrawItem->hDC);
		pDib->Draw(dc, &rBitmap);
        dc.Detach();

        r.left += pDib->Width();
        if(r.left < r.right)
            FillRect(pDrawItem->hDC, r, GetStockObject(WHITE_BRUSH));

        bHandled = TRUE;
        return 0;
    }


    // may need to change the width of the static control
    LRESULT OnSize(UINT uMsg, WPARAM /* wParam */, LPARAM lParam, BOOL& /* bHandled */)
    {
        WORD nWidth = LOWORD(lParam);  // width of client area 

		CRect rcBitmap;
		CWindow wndBitmap(GetDlgItem(IDC_SPLASH_IMAGE));
		wndBitmap.GetWindowRect(&rcBitmap);

        if(nWidth - m_nMarginWidth != rcBitmap.Width())
        {
            rcBitmap.right += nWidth - m_nMarginWidth - rcBitmap.Width();
		    SuperScreenToClient(rcBitmap);
            wndBitmap.MoveWindow(rcBitmap, TRUE);
        }

        return 0;
    }


	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this,wParam,0,NULL);
		return 0;
	}

    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        if(m_hWnd)
            return S_FALSE;

        switch(code)
        {
            case PaneSplashSplash:
                m_fAbout = false;
                return S_OK;

            case PaneSplashAbout:
                m_fAbout = true;
                return S_OK;
        }

	    return S_FALSE;
	}
};


class CPaneIE;

/////////////////////////////////////////////////////////////////////////////
// CWebBrowserEvents2Sink

// This class is used to receive disp events from a web browser

class ATL_NO_VTABLE CWebBrowserEvents2Sink : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatch
{
public:
	CWebBrowserEvents2Sink() {}
	~CWebBrowserEvents2Sink() {}
BEGIN_COM_MAP(CWebBrowserEvents2Sink)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
END_COM_MAP()

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) { return E_NOTIMPL; }
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo) { return E_NOTIMPL; }
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid) { return E_NOTIMPL; }
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

	class CPaneIE* 	m_pCPaneIE;
	IWebBrowser2*	m_pIE;
};


class CPaneIE : public CPaneImpl<CPaneIE>
{
	CZoneAxWindow m_hWndDefault;
	CZoneAxWindow m_hWndDownload;
	CComPtr<IWebBrowser2> m_pIEDefault;
	CComPtr<IWebBrowser2> m_pIEDownload;
    CComPtr<IAccessibility> m_pIAccIE;

	DWORD	m_dwDownloadCookie;		// holds advise cookie from the browser connection point for the download
	DWORD	m_dwDownloadCookie2;	// holds advise cookie from the browser connection point for the default
    bool    m_fShowing;             // is the ie pane showing
    bool    m_fAdAvail;             // is the ad (as opposed to evergreen page) ready
    bool    m_fNavigationEnabled;   // are we allowed to connect
	POINT	m_PaneSize;				// size of IE Pane
    int		m_nMarginWidth;		    // desired margin size set on init
public:
	enum { IDD = IDD_PLUG_IE };
    enum { AccOrdinal = NOACC };

	CPaneIE() : m_dwDownloadCookie(0), m_dwDownloadCookie2(0), m_fShowing(false),
        m_fAdAvail(false), m_fNavigationEnabled(true) { m_PaneSize.x = 0; m_PaneSize.y = 0; }

	// IPane methods
	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;

		// Get size we want IE pane to be
		const TCHAR *arKeysUI[] = { key_WindowManager, key_Upsell, key_IEPaneSize };
        m_pMgr->GetDataStoreUI()->GetPOINT(arKeysUI, 3, &m_PaneSize);

		// Create our dialog early, so it can download stuff. We must have a parent, so we use the desktop.
		HWND hWnd = Create(GetDesktopWindow(), NULL);
        if(!hWnd)
            return E_FAIL;

        // do this stuff to make drawing nicer
        SetClassLong(hWnd, GCL_HBRBACKGROUND, (LONG) GetStockObject(NULL_BRUSH));

        LONG lStyle = GetWindowLong(GWL_STYLE);
        lStyle |= WS_CLIPCHILDREN;
        SetWindowLong(GWL_STYLE, lStyle);
        RECT dummy = { 0, 0, 0, 0 };
        SetWindowPos(HWND_NOTOPMOST, &dummy, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

        HRESULT hr = m_pMgr->GetZoneShell()->QueryService(SRVID_AccessibilityManager, IID_IAccessibility, (void **) &m_pIAccIE);
        if(SUCCEEDED(hr))
        {
            ACCITEM o;
            CopyACC(o, ZACCESS_DefaultACCITEM);
            o.rgfWantKeys = ZACCESS_WantAllKeys;

            m_pIAccIE->InitAcc(NULL, 101);
            m_pIAccIE->PushItemlist(&o, 1);
            m_pIAccIE->GeneralDisable();
        }

	    return S_OK;
	}

    STDMETHOD(CreatePane)(HWND hWndParent,LPARAM dwInitParam)
    {
    	if(!m_hWnd)
    	    return E_FAIL;

		// reparent to the dialog and show ourselves.
		SetParent(hWndParent);
		ShowWindow(SW_SHOW);
        m_fShowing = true;

        CComPtr<IMillUtils> pIMU;
        HRESULT hr = m_pMgr->GetZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
        if(SUCCEEDED(hr))
            pIMU->IncrementCounter(m_fAdAvail ? IMillUtils::M_CounterAdsViewed : IMillUtils::M_CounterEvergreenViewed);

   	    return S_OK;
	}

    STDMETHOD(DestroyPane)()
    {
        m_pIAccIE->GeneralDisable();
        m_fShowing = false;
		ShowWindow(SW_HIDE);
		SetParent(NULL);

        AdNavigate();
	    return S_OK;
	}


    STDMETHOD(LastCall)()
    {
        m_pIAccIE.Release();
        m_pIEDefault.Release();
        m_pIEDownload.Release();
        DestroyWindow();
	    return S_OK;
	}


	BEGIN_MSG_MAP(CPaneIE)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	    MESSAGE_HANDLER(WM_SIZE, OnSize)
        CHAIN_MSG_MAP(CPaneImpl<CPaneIE>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{

		m_hWndDefault.Attach( GetDlgItem(IDC_PLUG_IE_DEFAULT) );
		m_hWndDownload.Attach( GetDlgItem(IDC_PLUG_IE_DOWNLOAD) );

		// Need to size IE window dialog item to proper size
        CRect rcDialog;
        GetWindowRect(&rcDialog);
        m_ze = rcDialog.Size();

		CRect rcIEPane;
		m_hWndDefault.GetWindowRect(&rcIEPane);
        m_ze.cy -= rcIEPane.Height() - m_PaneSize.y;	// shrink/grow dialog to compensate for us resizing ie pane so layout stays the same
		m_ze.cx -= rcIEPane.Width() - m_PaneSize.x;

        // remember the total width of the margins we have
        GetClientRect(&rcDialog);
        m_nMarginWidth = rcDialog.Width() - rcIEPane.Width();

        // in case i don't get a resize, make the static control the right height now
		SuperScreenToClient(rcIEPane);
        rcIEPane.bottom -= rcIEPane.Height() - m_PaneSize.y;
        rcIEPane.right -= rcIEPane.Width() - m_PaneSize.x;
        m_hWndDefault.MoveWindow(rcIEPane, FALSE);
        m_hWndDownload.MoveWindow(rcIEPane, FALSE);

        Register();

		m_hWndDefault.QueryControl(IID_IWebBrowser2, (void**)&m_pIEDefault);
		m_hWndDownload.QueryControl(IID_IWebBrowser2, (void**)&m_pIEDownload);

		CComPtr<IAxWinAmbientDispatch> pAmbient;

		// setup the Default Ad browser
		
		m_hWndDefault.QueryHost(&pAmbient);
		if (pAmbient)
		{
			DWORD dwFlags;
			pAmbient->get_DocHostFlags(&dwFlags);
			dwFlags |= DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_DISABLE_HELP_MENU 
				     | DOCHOSTUIFLAG_SCROLL_NO; // | DOCHOSTUIFLAG_OPENNEWWIN;   ads have to be responsible for this
			pAmbient->put_DocHostFlags(dwFlags);

			pAmbient->put_AllowContextMenu(0);
			pAmbient.Release();
		}

		// setup the Download Ad browser
		m_hWndDownload.QueryHost(&pAmbient);
		if (pAmbient)
		{
			DWORD dwFlags;
			pAmbient->get_DocHostFlags(&dwFlags);
			dwFlags |= DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_DISABLE_HELP_MENU 
				     | DOCHOSTUIFLAG_SCROLL_NO; // | DOCHOSTUIFLAG_OPENNEWWIN;   ads have to be responsible for this
			pAmbient->put_DocHostFlags(dwFlags);

			pAmbient->put_AllowContextMenu(0);
			pAmbient.Release();
		}

		// disallow dialog boxes
        m_pIEDefault->put_Silent(TRUE);
        m_pIEDownload->put_Silent(TRUE);

		// connect up for notifications from the Download Ad browser
		CComObject<CWebBrowserEvents2Sink>*	pSinkObject = NULL;
		CComObject<CWebBrowserEvents2Sink>::CreateInstance(&pSinkObject);

		CComPtr<IUnknown> pISinkObject;
		if	(pSinkObject)
		{
			pSinkObject->m_pCPaneIE = this;
			pSinkObject->m_pIE = m_pIEDownload;
			pSinkObject->QueryInterface(IID_IUnknown, (void**)&pISinkObject);
		}
		if	(pISinkObject && m_pIEDownload)
			AtlAdvise(m_pIEDownload, pISinkObject, DIID_DWebBrowserEvents2, &m_dwDownloadCookie);

		// connect up for notifications from local default ad
		CComObject<CWebBrowserEvents2Sink>*	pSinkObject2 = NULL;
		CComObject<CWebBrowserEvents2Sink>::CreateInstance(&pSinkObject2);

		CComPtr<IUnknown> pISinkObject2;
		if	(pSinkObject2)
		{
			pSinkObject2->m_pCPaneIE = this;
			pSinkObject2->m_pIE = m_pIEDefault;
			pSinkObject2->QueryInterface(IID_IUnknown, (void**)&pISinkObject2);
		}
		if	(pISinkObject2 && m_pIEDefault)
			AtlAdvise(m_pIEDefault, pISinkObject2, DIID_DWebBrowserEvents2, &m_dwDownloadCookie2);


		// load and navigate to our default HTML resource
		HINSTANCE hInstanceHTML = _Module.GetResourceInstance( _T("HTML_UPSELL.HTM"),RT_HTML);

		TCHAR szModuleName[_MAX_PATH];
		if ( hInstanceHTML && GetModuleFileName(hInstanceHTML, szModuleName, _MAX_PATH) )
		{
			TCHAR szURL[_MAX_PATH+25];
			wsprintf(szURL, _T("res://%s/HTML_UPSELL.HTM"), szModuleName);

			m_pIEDefault->Navigate(CComBSTR(szURL), NULL, NULL, NULL, NULL);
		}

        // navigate to the ad
        
		AdNavigate();
		
		return TRUE;
	}

    // may need to change the width of the static control
    LRESULT OnSize(UINT uMsg, WPARAM /* wParam */, LPARAM lParam, BOOL& /* bHandled */)
    {
        WORD nWidth = LOWORD(lParam);  // width of client area 

        CRect rcDialog;
        GetWindowRect(&rcDialog);

		CRect rcIEPane;
		m_hWndDefault.GetWindowRect(&rcIEPane);

        if( nWidth > (rcIEPane.Width() + m_nMarginWidth) )
        {
			m_nMarginWidth = nWidth - rcIEPane.Width(); // Get new margin
			rcIEPane.OffsetRect(-(rcIEPane.left-rcDialog.left),0);			
			rcIEPane.OffsetRect(m_nMarginWidth/2,0);	// Center pane in dialog
		    SuperScreenToClient(rcIEPane);
            m_hWndDefault.MoveWindow(rcIEPane, TRUE);
			m_hWndDownload.MoveWindow(rcIEPane, TRUE);
        }

        return 0;
    }

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if ( m_pIEDownload && m_dwDownloadCookie ) 
			AtlUnadvise(m_pIEDownload, DIID_DWebBrowserEvents2, m_dwDownloadCookie);

		if ( m_pIEDefault && m_dwDownloadCookie2 ) 
			AtlUnadvise(m_pIEDefault, DIID_DWebBrowserEvents2, m_dwDownloadCookie2);

        Unregister();

		return TRUE;
	}

	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this,wParam,0,NULL);
		return TRUE;
	}

    // only called when navigation needs to begin anew
    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        HWND hwnd = NULL;
        HRESULT hr;
		CComPtr<IDispatch> pDisp;
		CComQIPtr<IHTMLDocument2> pDoc;
		CComQIPtr<IHTMLWindow2> pWin;
		CComQIPtr<IHTMLAnchorElement> pA;
		CComPtr<IHTMLElementCollection> pTags;
		CComQIPtr<IHTMLElementCollection> pAnchors;
        CComVariant varName;
        CComVariant varID;
        CComVariant varAnchor;

        switch(code)
        {
            case PaneIENavigate:
                m_fNavigationEnabled = (id ? true : false);
                AdNavigate();
                break;

            case PaneIEFocus:
                if(!m_fShowing)
                    break;

                if(m_fAdAvail)
                    hr = m_pIEDownload->get_Document(&pDisp);
                else
                    hr = m_pIEDefault->get_Document(&pDisp);
		        if(FAILED(hr))
			        break;

		        pDoc = pDisp;
		        if(!pDoc)
			        break;

		        hr = pDoc->get_parentWindow(&pWin);
		        if(FAILED(hr) || !pWin)
			        break;

                m_pIAccIE->GeneralEnable();
                m_pIAccIE->SetFocus(0);
                pWin->focus();
                break;
/*
		        hr = pDoc->get_all(&pTags);
		        if(FAILED(hr) || !pTags)
			        break;

                pDisp.Release();
                varAnchor = _T("A");
                hr = pTags->tags(varAnchor, &pDisp);
		        if(FAILED(hr))
			        break;

                pAnchors = pDisp;
                if(!pAnchors)
                    break;

                pDisp.Release();
                varName = 0;
                varID = 0;
                hr = pAnchors->item(varName, varID, &pDisp);
		        if(FAILED(hr))
			        break;

                pA = pDisp;
                if(!pA)
                    break;

                m_pIAccIE->GeneralEnable();
                m_pIAccIE->SetFocus(0);
                pA->focus();
                break;
*/
            case PaneIEUnfocus:
                m_pIAccIE->GeneralDisable();
                break;
        }

        return S_OK;
    }

	void NavigateComplete(IWebBrowser2* pIE) 
	{
        AppendZoneTag(pIE);

		if(pIE == m_pIEDownload)
		{
			// check if the ad is good. If it is, we hide the default ad and display the 
			// downloaded ad.

			// The ad must contain a HTML tag of WindowManager/Upsell/AdValid to be considered valid

			const TCHAR* arKeys[] = { key_WindowManager, key_Upsell, key_AdValid };
			TCHAR szAdValid[ZONE_MaxString];
			szAdValid[0] = _T('\0');
			DWORD cb = sizeof(szAdValid);
			m_pMgr->GetDataStoreUI()->GetString( arKeys, 3, szAdValid, &cb );

			CComPtr<IDispatch> pDocDisp;
			CComQIPtr<IHTMLDocument2> pDoc;
			
			m_pIEDownload->get_Document(&pDocDisp);
			pDoc = pDocDisp;

			CComPtr<IHTMLElementCollection> pAll;
			if ( pDoc )
				pDoc->get_all(&pAll);

			CComPtr<IDispatch> pTagsDisp;
			CComQIPtr<IHTMLElementCollection> pTags;
			CComVariant szZone(szAdValid);
			if ( pAll )
				pAll->tags( szZone, &pTagsDisp);
			pTags = pTagsDisp;

			long length = 0;
			if ( pTags )
				pTags->get_length(&length);

			if(length > 0 && !m_fShowing)
			{
                m_fAdAvail = true;
				m_hWndDownload.ShowWindow(SW_SHOW);
				m_hWndDefault.ShowWindow(SW_HIDE);
				return;
			}
		}
	}

private:
    void AdNavigate()
    {
		m_hWndDownload.ShowWindow(SW_HIDE);
		m_hWndDefault.ShowWindow(SW_SHOW);
        m_fAdAvail = false;

        if(!m_fNavigationEnabled)
            return;

		// load and navigate to our downloaded URL
		// The URL comes from WindowManager/Upsell/AdUrl in the UI datastore.
		// The ad must contain a HTML tag of WindowManager/Upseel/AdValid to be considered valid
		const TCHAR* arKeys[] = { key_WindowManager, key_Upsell, key_AdURL };
		TCHAR szAdURL[ZONE_MAXSTRING];
		DWORD cb = NUMELEMENTS(szAdURL) - 2;  // guarantee a little extra space for later manipulation
		m_pMgr->GetDataStoreUI()->GetString( arKeys, 3, szAdURL, &cb );

        CComPtr<IMillUtils> pIMU;
        HRESULT hr = m_pMgr->GetZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
        if(pIMU)
        {
            lstrcat(szAdURL, _T("?"));
            pIMU->GetURLQuery(szAdURL + lstrlen(szAdURL), NUMELEMENTS(szAdURL) - lstrlen(szAdURL), ZONE_ContextOfAdRequest);
        }

        // try to make sure the browser isn't offline, but triple-check since the penalty is so bad (system locks up)
        m_pIEDownload->put_Offline(FALSE);
        VARIANT_BOOL fOffline = TRUE;
        m_pIEDownload->get_Offline(&fOffline);
        if(fOffline)
            return;

		m_pIEDownload->Navigate(CComBSTR(szAdURL), NULL, NULL, NULL, NULL);

        fOffline = TRUE;
        m_pIEDownload->get_Offline(&fOffline);
        if(fOffline)
        {
            m_pIEDownload->Stop();
            return;
        }

        if(pIMU)
            pIMU->IncrementCounter(IMillUtils::M_CounterAdsRequested);
    }

	// Insert zone tag into html page with proper game and other info
	void AppendZoneTag(IWebBrowser2* iWebBrowser2)
	{
		// Walk DHTML object model to get html body
		CComPtr<IDispatch> pDocDisp;
		CComQIPtr<IHTMLDocument2> pDoc;
		
		HRESULT hr = iWebBrowser2->get_Document(&pDocDisp);
		
		if(FAILED(hr))
			return;

		pDoc = pDocDisp;

		if(pDoc==NULL)
			return;

		CComPtr<IHTMLElement> p;

		hr = pDoc->get_body(&p);
		
		if(FAILED(hr))
			return;

		// Get querystring that HTML link will use as appropriate args for window.open navigation
        
		CComPtr<IMillUtils> pIMU;
        
		hr = m_pMgr->GetZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
        
		if(SUCCEEDED(hr))
        {
			TCHAR szParams[ZONE_MAXSTRING];
			
			szParams[0]=NULL;

			// hack - apparently IE is stupid and doesn't reparse the html unless you're inserting a visible element
			// so we fake it out by adding a visible element that doesn't display and append what we really want 
			// to insert after it
			lstrcat(szParams, _T("<span style='display:none'>h</span>" ));
			
			lstrcat(szParams, _T("<ZONE ID=\"?")); // begin the zone tag

            pIMU->GetURLQuery(szParams + lstrlen(szParams), NUMELEMENTS(szParams) - lstrlen(szParams) - 9 /* number of chars appended below */,
                (iWebBrowser2 == m_pIEDownload) ? ZONE_ContextOfAd : ZONE_ContextOfEvergreen);
			
			lstrcat(szParams, _T("\"></ZONE>"));  // end zone tag
			
			CComBSTR arg1(OLESTR("BeforeEnd"));
			CComBSTR arg2(szParams);
				
			// insert the zone tag into   
			p->insertAdjacentHTML(arg1,arg2);  
		}
	}
};

STDMETHODIMP CWebBrowserEvents2Sink::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	HRESULT	hr = S_OK;

	// check for NULL
	if	(pdispparams)
	{
		switch	(dispidMember)
		{
			//case	DISPID_NAVIGATECOMPLETE2:
			case	DISPID_DOCUMENTCOMPLETE:  // navigatecomplete doesn't really tell you the page is ready for display/modification
			{
				if ( m_pCPaneIE )
				{
					m_pCPaneIE->NavigateComplete(m_pIE);
				}
				break;
			}

			default:
			{
				hr = DISP_E_MEMBERNOTFOUND;
				break;
			}
		}
	}
	else
		hr = DISP_E_PARAMNOTFOUND;

	return	hr;
}

class CPaneComfort : public CPaneImpl<CPaneComfort>
{
public:
	enum { IDD = IDD_PLAY_COMFORT };
    enum { AccOrdinal = NOACC };

	BEGIN_MSG_MAP(CPaneComfort)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_PRINTCLIENT, OnPrintClient)
        CHAIN_MSG_MAP(CPaneImpl<CPaneComfort>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        // find size we like
        SetSugSizeFromCurSize();

        CheckDlgButton(IDC_KEEP_COMFORTING, BST_CHECKED);
        
        Register();

        TCHAR szBuff[ZONE_MAXSTRING];
        TCHAR szName[ZONE_MAXSTRING];
        TCHAR szFinal[ZONE_MAXSTRING];
        if(!m_pMgr->GetResourceManager()->LoadString(IDS_SPLASH_OPENING, szBuff, NUMELEMENTS(szBuff)))
            return TRUE;
        if(!m_pMgr->GetResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
            return TRUE;

        if(!ZoneFormatMessage(szBuff, szFinal, NUMELEMENTS(szFinal), szName))
            return TRUE;

        SetDlgItemText(IDC_SPLASH_TEXT, szFinal);

		return TRUE;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();
		
		return TRUE;
	}

	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		ASSERT(m_pMgr);
        WORD id = LOWORD(wParam);

        if(id == IDC_KEEP_COMFORTING)
            m_pMgr->Input(this, ID_UNUSED_BY_RES, IsDlgButtonChecked(IDC_KEEP_COMFORTING) == BST_CHECKED ? PNP_COMFORT_ON : PNP_COMFORT_OFF, NULL);
        else
    	    m_pMgr->Input(this, id, 0, NULL);
		return TRUE;
	}


	LRESULT OnPrintClient(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        HDC hdc = (HDC) wParam;

        bHandled = FALSE;

        if((lParam & PRF_CHECKVISIBLE) && !IsWindowVisible())
            return 0;

        // as far as i can tell, this is a performance hack they're forcing us to do
        // to support themes, where we have to paint the various backgrounds.
        if(lParam & (PRF_CLIENT | PRF_ERASEBKGND | PRF_CHILDREN))
        {
            COLORREF colOld = GetTextColor(hdc);
            COLORREF colOldBk = GetBkColor(hdc);

            HBRUSH hBrush = (HBRUSH) SendMessage(WM_CTLCOLORBTN, wParam, 0);

            RECT rc;
            ::GetWindowRect(GetDlgItem(IDC_KEEP_COMFORTING), &rc);
            SuperScreenToClient(&rc);
            FillRect(hdc, &rc, hBrush);

            SetTextColor(hdc, colOld);
            SetBkColor(hdc, colOldBk);
        }

        return 0;
    }
};


#define PLAYERRESIDS { IDC_PLAYER1_TEXT, IDC_PLAYER2_TEXT, IDC_PLAYER3_TEXT, IDC_PLAYER4_TEXT }
#define BULLETRESIDS { IDC_BULLET1, IDC_BULLET2, IDC_BULLET3, IDC_BULLET4 }

#define TIMER_EV  499
#define TIMER_NET 498

class CPaneConnecting : public CPaneImpl<CPaneConnecting>
{
public:
	enum { IDD = IDD_PLAY_CONNECTING };
    enum { AccOrdinal = YESACC };

	BEGIN_MSG_MAP(CPaneConnecting)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
	    COMMAND_CODE_HANDLER(1, OnButtonClicked)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        CHAIN_MSG_MAP(CPaneImpl<CPaneConnecting>)
	END_MSG_MAP()


    STDMETHOD_(DWORD, GetFirstItem)() { return IDCANCEL; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDHELP; }

	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;
		m_bmpAnim.LoadBitmap(IDB_SPLASH_ANIM, m_pMgr->GetResourceManager());

	    return S_OK;
	}


	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        const TCHAR *arKeys[] = { key_WindowManager, key_Upsell, key_NetWaitMsgTime };

        // find size we like
        SetSugSizeFromCurSize();

        m_nMsecNetWait = 30000;  // thirty seconds
        m_pMgr->GetDataStoreUI()->GetLong( arKeys, 3, (long *) &m_nMsecNetWait );

        SetDlgItemText(IDC_SPLASH_TEXT, _T(""));
        UpdateFounds(0);

        m_fNetTimerOn = true;
        NetTimer(false);

        // initialize animation
        if(m_bmpAnim)
        {
            arKeys[2] = key_AnimStartFrame;
            long nAnimFrame = 0;
            m_pMgr->GetDataStoreUI()->GetLong( arKeys, 3, &nAnimFrame );

            arKeys[2] = key_AnimFrameTime;
            m_nMsecPerFrame = 80;
            m_pMgr->GetDataStoreUI()->GetLong( arKeys, 3, (long *) &m_nMsecPerFrame );

            m_fStopped = false;
            m_clkAnimStartTime = GetTickCount() - nAnimFrame * m_nMsecPerFrame;
            SetAnimTimer();

            // make sure the control is in the right place
            arKeys[2] = key_AnimSize;
            CPoint zeAnim(40, 40);
            m_pMgr->GetDataStoreUI()->GetPOINT(arKeys, 3, &zeAnim);

            CRect rc;
            CWindow wndAnim(GetDlgItem(IDC_SPLASH_ANIM));
            wndAnim.GetWindowRect(&rc);
            SuperScreenToClient(&rc);
            wndAnim.MoveWindow(rc.left, rc.bottom - zeAnim.y, zeAnim.x, zeAnim.y, false);
        }
        else
        {
            m_fStopped = true;
            ::ShowWindow(GetDlgItem(IDC_SPLASH_ANIM), SW_HIDE);
        }

        Register();
		return TRUE;
	}


    // set timer to right when next frame should display
    void SetAnimTimer()
    {
        if(!m_fStopped)
            SetTimer(TIMER_EV, m_nMsecPerFrame - (GetTickCount() - m_clkAnimStartTime) % m_nMsecPerFrame + 1);
    }


    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPDRAWITEMSTRUCT pDrawItem = (LPDRAWITEMSTRUCT) lParam;
        CDC dc;

        if(pDrawItem->CtlType != ODT_STATIC || (UINT) wParam != IDC_SPLASH_ANIM)
        {
            bHandled = FALSE;
            return 0;
        }

        SetAnimTimer();

        CRect r(pDrawItem->rcItem);
        r.bottom = r.top + m_bmpAnim.Height();

        // make sure no div by zero, as can happen when the resource was not loaded
        if(!m_nMsecPerFrame || !m_bmpAnim.Width() || !r.Width())
            return 0;

        long nFrame = CalcFrame() % (m_bmpAnim.Width() / r.Width());
        CRect rBitmap(nFrame * r.Width(), 0, (nFrame + 1) * r.Width(), r.Height());

        CALL_MAYBE(SetLayout)(pDrawItem->hDC, LAYOUT_BITMAPORIENTATIONPRESERVED);
        dc.Attach(pDrawItem->hDC);
		m_bmpAnim.Draw(dc, &r, &rBitmap);
        dc.Detach();

        bHandled = TRUE;
        return 0;
    }


    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // the double-check of m_fStopped (and m_fNetTimerOn below) is necessary in case the WM_TIMER was posted before KillTimer() was called
        if(wParam == TIMER_EV && !m_fStopped)
        {
            KillTimer(TIMER_EV);
            CWindow wndAnim(GetDlgItem(IDC_SPLASH_ANIM));
            wndAnim.Invalidate(false);
        }

        if(wParam == TIMER_NET && m_fNetTimerOn)
        {
            KillTimer(TIMER_NET);
            ::ShowWindow(GetDlgItem(IDC_SPLASH_TEXT2), SW_SHOW);
        }

        return false;
    }


	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();

		return TRUE;
	}


    STDMETHOD(DestroyPane)()
    {
        if(m_fDestroyed)
            return S_FALSE;
        m_fDestroyed = true;

        KillTimer(TIMER_EV);

        // say what frame the animation was on
        if(m_pMgr)
            m_pMgr->Input(this, ID_UNUSED_BY_RES, CalcFrame(), NULL);

        m_pMgr->GetEventQueue()->PostEvent(PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) m_hWnd, 0);
	    return S_OK;
	}


	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, wID, 0, NULL);
		return 0;
	}


    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        TCHAR sz[ZONE_MAXSTRING];
        TCHAR szFormat[ZONE_MAXSTRING];
        TCHAR szName[ZONE_MAXSTRING];
        TCHAR szLevel[ZONE_MAXSTRING];
        HRESULT hr;

        if(!m_hWnd)
            return S_FALSE;

        switch(code)
        {
            case PaneConnectingConnecting:
                if(m_fStopped && m_bmpAnim)
                {
                    m_clkAnimStartTime += GetTickCount() - m_clkAnimStopTime;
                    m_fStopped = false;
                    SetAnimTimer();
                }

                NetTimer(true);

                UpdateFounds(0);

                if(!m_pMgr->GetResourceManager()->LoadString(IDS_SPLASH_CONNECTING, sz, NUMELEMENTS(sz)))
                    return E_FAIL;

                SetDlgItemText(IDC_SPLASH_TEXT, sz);
                break;

            case PaneConnectingLooking:
            {
                if(m_fStopped && m_bmpAnim)
                {
                    m_clkAnimStartTime += GetTickCount() - m_clkAnimStopTime;
                    m_fStopped = false;
                    SetAnimTimer();
                }

                NetTimer(false);

                UpdateFounds(id);

                if(!m_pMgr->GetResourceManager()->LoadString(IDS_SPLASH_LOOKING, szFormat, NUMELEMENTS(szFormat)))
                    return E_FAIL;
                if(!m_pMgr->GetResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
                    return E_FAIL;

                const TCHAR *arKeys[] = { key_Lobby, key_SkillLevel };
                long nLevel = KeySkillLevelBeginner;
                m_pMgr->GetDataStorePreferences()->GetLong(arKeys, 2, &nLevel);
                if(!m_pMgr->GetResourceManager()->LoadString(nLevel == KeySkillLevelIntermediate ? IDS_LEVEL_INTERMEDIATE :
                                                             nLevel == KeySkillLevelExpert ? IDS_LEVEL_EXPERT :
                                                             IDS_LEVEL_BEGINNER, szLevel, NUMELEMENTS(szLevel)))
                    return E_FAIL;

                CComPtr<IDataStore> pIDS;
                TCHAR szLang[ZONE_MAXSTRING] = TEXT("Unknown Language");
                DWORD cb = sizeof(szLang);
                hr = m_pMgr->GetLobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
                if(SUCCEEDED(hr))
                    pIDS->GetString(key_LocalLanguage, szLang, &cb);

                if(!ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szLevel, szName, szLang))
                    return E_FAIL;

                SetDlgItemText(IDC_SPLASH_TEXT, sz);
                break;
            }

            case PaneConnectingStop:
                if(!m_fStopped)
                {
                    m_fStopped = true;
                    m_clkAnimStopTime = GetTickCount();
                    KillTimer(TIMER_EV);
                }

                NetTimer(false);
                break;

            case PaneConnectingFrame:
                m_clkAnimStartTime = GetTickCount() - id * m_nMsecPerFrame;
                SetAnimTimer();
                break;
        }

	    return S_OK;
	}

private:
    void UpdateFounds(DWORD nNum)
    {
        static DWORD s_rgnResIDs[] = PLAYERRESIDS;
        DWORD i;

        if(NUMELEMENTS(s_rgnResIDs) < 3)
            return;

        for(i = 0; i < 3; i++)
            ::ShowWindow(GetDlgItem(s_rgnResIDs[i]), i < nNum ? SW_SHOW : SW_HIDE);
    }

    long CalcFrame()
    {
        return ((m_fStopped ? m_clkAnimStopTime : GetTickCount()) - m_clkAnimStartTime) / m_nMsecPerFrame;
    }


    void NetTimer(bool fOn)
    {
        if(m_fNetTimerOn == fOn)
            return;

        ::SetWindowPos(GetDlgItem(IDC_SPLASH_TEXT2), fOn ? HWND_TOP : HWND_BOTTOM, 0, 0, 0, 0,
            SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);

        if(fOn)
            SetTimer(TIMER_NET, m_nMsecNetWait);
        else
            KillTimer(TIMER_NET);

        m_fNetTimerOn = fOn;
    }


    DWORD m_nMsecPerFrame;
    DWORD m_clkAnimStartTime;
    DWORD m_clkAnimStopTime;
    bool m_fStopped;
    bool m_fNetTimerOn;
    DWORD m_nMsecNetWait;
    CDib m_bmpAnim;
};


class CPaneGameOver : public CPaneImpl<CPaneGameOver>
{
public:
	enum { IDD = IDD_PLAY_GAMEOVER };
    enum { AccOrdinal = YESACC };

	BEGIN_MSG_MAP(CPaneGameOver)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
	    COMMAND_CODE_HANDLER(1, OnButtonClicked)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColorStatic)
        CHAIN_MSG_MAP(CPaneImpl<CPaneGameOver>)
	END_MSG_MAP()

    STDMETHOD_(DWORD, GetFirstItem)() { return ::IsWindowEnabled(GetDlgItem(IDYES)) ? IDYES : IDNO; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDHELP; }

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        static DWORD s_rgnResIDs[] = PLAYERRESIDS;
        static DWORD s_rgnBulletResIDs[] = BULLETRESIDS;

        int i;

        // find size we like
        SetSugSizeFromCurSize();
        ::ShowWindow(GetDlgItem(IDC_SPLASH_TEXT2), SW_HIDE);

        long nPlayers = m_pMgr->GetLobbyDataStore()->GetGroupUserCount(ZONE_NOGROUP);
        m_nPlayerOffset = (nPlayers == 2 ? 0 : 0);

        if(nPlayers > 2)
        {
            TCHAR sz[ZONE_MAXSTRING];
            if(m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_BUTTON4, sz, NUMELEMENTS(sz)))
                SetDlgItemText(IDNO, sz);

            if(m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_ASKTEXT4, sz, NUMELEMENTS(sz)))
                SetDlgItemText(IDC_SPLASH_TEXT, sz);

            if(m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_WAITTEXT4, sz, NUMELEMENTS(sz)))
                SetDlgItemText(IDC_SPLASH_TEXT2, sz);
        }

        m_szDeciding[0] = m_szReady[0] = (TCHAR) '\0';
        m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_DECIDING, m_szDeciding, NUMELEMENTS(m_szDeciding));
        m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_READY, m_szReady, NUMELEMENTS(m_szReady));

        for(i = 0; i < 4; i++)
            if(i < NUMELEMENTS(s_rgnResIDs) || i < NUMELEMENTS(s_rgnBulletResIDs))
            {
                m_fDrawBlack[i] = false;
                SetDlgItemText(s_rgnResIDs[i], _T(""));
//                ::EnableWindow(GetDlgItem(s_rgnResIDs[i]), false);
                ::ShowWindow(GetDlgItem(s_rgnBulletResIDs[i]), SW_HIDE);
            }

	    m_pMgr->GetLobbyDataStore()->EnumUsers(ZONE_NOGROUP, UpdatePlayerEnum, this);

        Register();
		return TRUE;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();
	
		return TRUE;
	}

	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, wID, 0, NULL);
		return 0;
	}

    LRESULT OnCtlColorStatic(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        static DWORD s_rgnResIDs[] = PLAYERRESIDS;

        int i;
        HWND hCtl = (HWND) lParam;
        HDC hDC = (HDC) wParam;

        for(i = 0; i < 4; i++)
            if(GetDlgItem(s_rgnResIDs[i]) == hCtl)
            {
                if(!m_fDrawBlack[i] && GetSysColor(COLOR_GRAYTEXT))
                {
                    SetTextColor(hDC, GetSysColor(COLOR_GRAYTEXT));
                    SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
                    return (BOOL) GetSysColorBrush(COLOR_3DFACE);
                }

                break;
            }

        return false;
    }

    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        if(!m_hWnd)
            return S_FALSE;

        switch(code)
        {
            case PaneGameOverSwap:
                SuperGotoDlgControl(IDNO);
                ::EnableWindow(GetDlgItem(IDYES), FALSE);
                ::ShowWindow(GetDlgItem(IDC_SPLASH_TEXT2), SW_SHOW);
                ::ShowWindow(GetDlgItem(IDC_SPLASH_TEXT), SW_HIDE);
                return S_OK;

            case PaneGameOverUserState:
                UpdatePlayer((ZUserID) id);
                return S_OK;
        }

	    return S_FALSE;
	}

private:
    static HRESULT ZONECALL UpdatePlayerEnum(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext)
    {
        CPaneGameOver *pThis = (CPaneGameOver *) pContext;

        pThis->UpdatePlayer(dwUserId);
        return S_OK;
    }

    void UpdatePlayer(ZUserID nUserID)
    {
        static DWORD s_rgnResIDs[] = PLAYERRESIDS;
        static DWORD s_rgnBulletResIDs[] = BULLETRESIDS;

	    CComPtr<IDataStore> pIDS;
	    HRESULT hr = m_pMgr->GetLobbyDataStore()->GetDataStore( ZONE_NOGROUP, nUserID, &pIDS );
	    if ( FAILED(hr) )
		    return;

        long nStatus;
        hr = pIDS->GetLong(key_PlayerReady, &nStatus);
        if(FAILED(hr))
            return;

        TCHAR szBuff[ZONE_MAXSTRING];

        if(nUserID != m_pMgr->GetLobbyDataStore()->GetUserId(NULL))
        {
	        TCHAR szUserName[ ZONE_MaxUserNameLen ];
	        DWORD dwLen = sizeof(szUserName);
	        hr = pIDS->GetString( key_Name, szUserName, &dwLen );
	        if ( FAILED(hr) )
		        return;

            if(!ZoneFormatMessage(nStatus == KeyPlayerReady ? m_szReady : m_szDeciding, szBuff, NUMELEMENTS(szBuff), szUserName))
                return;
        }
        else
        {
            if(!m_pMgr->GetResourceManager()->LoadString(nStatus == KeyPlayerReady ? IDS_UPSELL_YOU_READY : IDS_UPSELL_YOU_DECIDING, szBuff, NUMELEMENTS(szBuff)))
                return;
        }

        long nSpot;
        hr = pIDS->GetLong(key_PlayerNumber, &nSpot);
        if(FAILED(hr))
            return;

        nSpot += m_nPlayerOffset;
        if(nSpot < 0 || nSpot >= NUMELEMENTS(s_rgnResIDs))
            return;

        m_fDrawBlack[nSpot] = (nStatus == KeyPlayerReady);
//        ::EnableWindow(GetDlgItem(s_rgnResIDs[nSpot]), nStatus == KeyPlayerReady ? true : false);
        SetDlgItemText(s_rgnResIDs[nSpot], szBuff);
    }

    TCHAR m_szDeciding[ZONE_MAXSTRING];
    TCHAR m_szReady[ZONE_MAXSTRING];

    bool m_fDrawBlack[4];
    int16 m_nPlayerOffset;
};


class CPaneError : public CPaneImpl<CPaneError>
{
public:
	enum { IDD = IDD_PLAY_ERROR };
    enum { AccOrdinal = YESACC };

	BEGIN_MSG_MAP(CPaneError)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
	    COMMAND_CODE_HANDLER(1, OnButtonClicked)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
        CHAIN_MSG_MAP(CPaneImpl<CPaneError>)
	END_MSG_MAP()

    STDMETHOD_(DWORD, GetFirstItem)() { return IDOK; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDHELP; }

	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;
		m_bmpAnim.LoadBitmap(IDB_SPLASH_ANIM, m_pMgr->GetResourceManager());
        m_nFrame = 0;

	    return S_OK;
	}


	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        // find size we like
        SetSugSizeFromCurSize();

        // initialize animation
        if(m_bmpAnim)
        {
            // make sure the control is in the right place
            const TCHAR *arKeys[] = { key_WindowManager, key_Upsell, key_AnimSize };
            CPoint zeAnim(40, 40);
            m_pMgr->GetDataStoreUI()->GetPOINT(arKeys, 3, &zeAnim);

            CRect rc;
            CWindow wndAnim(GetDlgItem(IDC_SPLASH_ANIM));
            wndAnim.GetWindowRect(&rc);
            SuperScreenToClient(&rc);
            wndAnim.MoveWindow(rc.left, rc.bottom - zeAnim.y, zeAnim.x, zeAnim.y, false);
        }
        else
        {
            ::ShowWindow(GetDlgItem(IDC_SPLASH_ANIM), SW_HIDE);
        }

        Register();
		return TRUE;
	}

    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPDRAWITEMSTRUCT pDrawItem = (LPDRAWITEMSTRUCT) lParam;
        CDC dc;

        if(pDrawItem->CtlType != ODT_STATIC || (UINT) wParam != IDC_SPLASH_ANIM)
        {
            bHandled = FALSE;
            return 0;
        }

        CRect r(pDrawItem->rcItem);
        r.bottom = r.top + m_bmpAnim.Height();

        // make sure no div by zero, as can happen when the resource was not loaded
        if(!m_bmpAnim.Width() || !r.Width())
            return 0;

        long nFrame = m_nFrame % (m_bmpAnim.Width() / r.Width());
        CRect rBitmap(nFrame * r.Width(), 0, (nFrame + 1) * r.Width(), r.Height());

        CALL_MAYBE(SetLayout)(pDrawItem->hDC, LAYOUT_BITMAPORIENTATIONPRESERVED);
        dc.Attach(pDrawItem->hDC);
		m_bmpAnim.Draw(dc, &r, &rBitmap);
        dc.Detach();

        bHandled = TRUE;
        return 0;
    }

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();

		return TRUE;
	}

    STDMETHOD(DestroyPane)()
    {
        if(m_fDestroyed)
            return S_FALSE;
        m_fDestroyed = true;

        // say what frame the animation was on
        if(m_pMgr)
            m_pMgr->Input(this, ID_UNUSED_BY_RES, m_nFrame, NULL);

        m_pMgr->GetEventQueue()->PostEvent(PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) m_hWnd, 0);
	    return S_OK;
	}

	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, wID, 0, NULL);
		return 0;
	}

    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        m_nFrame = id;
        return S_OK;
    }

private:
    long m_nFrame;
    CDib m_bmpAnim;
};


#ifdef MILL_EASTEREGG

#define CRED_MSEC_PER_FRAME 60
#define CRED_FRAME_PER_SCREEN 100
#define CRED_NUM_SCREENS 20

#define CRED_WIPE_START 0
#define CRED_T_FADE_HALF (CRED_FRAME_PER_SCREEN - 2)
#define CRED_T_FADE_FULL (CRED_FRAME_PER_SCREEN - 1)
#define CRED_T_GROW_HALF 2
#define CRED_T_GROW_FULL 3
#define CRED_P_FADE_HALF (CRED_FRAME_PER_SCREEN - 3)
#define CRED_P_FADE_FULL (CRED_FRAME_PER_SCREEN - 2)
#define CRED_P_GROW_HALF 9
#define CRED_P_GROW_FULL 10

struct CreditScreen
{
    TCHAR *szTitle;
    TCHAR *szName;
    DWORD nScreenOfTitle;
};

class CPaneCredits : public CPaneImpl<CPaneCredits>
{
public:
    enum { IDD = IDD_PLAY_CREDITS };
    enum { AccOrdinal = NOACC };

    // the actual script
    static CreditScreen ms_rgrg[CRED_NUM_SCREENS][4];

	BEGIN_MSG_MAP(CPaneCredits)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColorStatic)
        MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
        MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLDown)
        CHAIN_MSG_MAP(CPaneImpl<CPaneCredits>)
	END_MSG_MAP()

    STDMETHOD_(DWORD, GetFirstItem)() { return IDCLOSE; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDCLOSE; }

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        int i;

        // find size we like
        SetSugSizeFromCurSize();

        // set up colors and texts
        for(i = 0; i < 8; i++)
        {
            m_rgColors[i] = GetSysColor(COLOR_3DSHADOW);
            m_rgTexts[i] = NULL;
        }

        // put in icon
        m_hIcon = m_pMgr->GetResourceManager()->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
        if(m_hIcon)
            SendDlgItemMessage(IDC_CRED_ICON, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) m_hIcon);

        // make font for title larger
        ZONEFONT fntPref(11, _T("Tahoma"), 700);
        ZONEFONT fntBack(11, _T("Arial"), 400);
        HFONT hFont = NULL;

        CClientDC dc(m_hWnd);

        hFont = m_fnt.SelectFont(fntPref, fntBack, dc);
        if(hFont)
            SendDlgItemMessage(IDC_CRED_TITLE, WM_SETFONT, (WPARAM) hFont);
        SetDlgItemText(IDC_CRED_TITLE, _T("The Internet Games"));

        // start timing
        m_clkStartTime = GetTickCount();
        SetTimer(TIMER_EV, CRED_MSEC_PER_FRAME - (GetTickCount() - m_clkStartTime) % CRED_MSEC_PER_FRAME + 1);

        Register();
		return TRUE;
	}


    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        int i;
        int32 nFrame = (GetTickCount() - m_clkStartTime) / CRED_MSEC_PER_FRAME;
        int32 nInScr = nFrame % CRED_FRAME_PER_SCREEN;
        int32 nScr = nFrame / CRED_FRAME_PER_SCREEN;
        DWORD color;
        TCHAR *text;

        if(wParam != TIMER_EV)
            return false;

        KillTimer(TIMER_EV);

        if(nScr >= CRED_NUM_SCREENS)
        {
            CComPtr<IDataStore> pIDS;
            HRESULT hr = m_pMgr->GetLobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS);
            if(FAILED(hr))
                return hr;

            long fChat = 0;
            pIDS->GetLong(key_LocalChatStatus, &fChat);
            if(fChat)
            {
                const TCHAR *sz = _T("I know a secret!");
                m_pMgr->GetEventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_SEND, ZONE_NOGROUP, ZONE_NOUSER, (void *) sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
            }
            return false;
        }

        for(i = IDC_CRED_T1; i <= IDC_CRED_P4; i++)
        {
            FindInfo(i - IDC_CRED_T1, nScr, nInScr, &color, &text);
            if(color != m_rgColors[i - IDC_CRED_T1])
            {
                m_rgColors[i - IDC_CRED_T1] = color;
                if(text != m_rgTexts[i - IDC_CRED_T1])
                {
                    m_rgTexts[i - IDC_CRED_T1] = text;
                    SetDlgItemText(i, text);
                }
                CWindow wnd(GetDlgItem(i));
                wnd.Invalidate(false);
            }
        }

        SetTimer(TIMER_EV, CRED_MSEC_PER_FRAME - (GetTickCount() - m_clkStartTime) % CRED_MSEC_PER_FRAME + 1);

        return false;
    }


	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        KillTimer(TIMER_EV);
        Unregister();
        if(m_fnt.m_hFont)
            m_fnt.DeleteObject();
        if(m_hIcon)
        {
            ::DeleteObject(m_hIcon);
            m_hIcon = NULL;
        }
		return TRUE;
	}


    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LPDRAWITEMSTRUCT pDrawItem = (LPDRAWITEMSTRUCT) lParam;
        RECT rc;

        if(pDrawItem->CtlType != ODT_STATIC || (UINT) wParam != IDC_CRED_ICON_FRAME)
        {
            bHandled = FALSE;
            return 0;
        }

        ::GetClientRect(GetDlgItem(IDC_CRED_ICON_FRAME), &rc);
        FillRect(pDrawItem->hDC, &rc, (HBRUSH) (COLOR_3DFACE + 1));
        DrawEdge(pDrawItem->hDC, &rc, EDGE_RAISED, BF_RECT);
        return 0;
    }


	LRESULT OnCtlColorStatic(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        int i;
	    HDC dc = (HDC) wParam;
        HWND hwnd = (HWND) lParam;

        for(i = IDC_CRED_T1; i <= IDC_CRED_P4; i++)
            if(GetDlgItem(i) == hwnd)
                break;

        if(i > IDC_CRED_P4)
        {
            bHandled = false;
            return false;
        }

        SetTextColor(dc, m_rgColors[i - IDC_CRED_T1]);
	    SetBkColor(dc, GetSysColor(COLOR_3DSHADOW));

	    return (BOOL)GetSysColorBrush(COLOR_3DSHADOW);
	}


	LRESULT OnLDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, IDCLOSE, 0, NULL);
		return 0;
	}


private:
    CZoneFont m_fnt;
    DWORD m_clkStartTime;
    COLORREF m_rgColors[8];
    TCHAR *m_rgTexts[8];
    HICON m_hIcon;

    void FindInfo(int i, int32 nScr, int32 nInScr, DWORD *pColor, TCHAR **pText)
    {
        bool fTitle = (i % 2 == 0) ? true : false;
        bool fNewTitle;

        if(fTitle)
            *pText = ms_rgrg[nScr - ms_rgrg[nScr][i / 2].nScreenOfTitle][i / 2].szTitle;
        else
            *pText = ms_rgrg[nScr][i / 2].szName;

        if(nInScr >= CRED_T_FADE_HALF)
            if(nScr + 1 < CRED_NUM_SCREENS && !ms_rgrg[nScr + 1][i / 2].szTitle)
                fNewTitle = false;
            else
                fNewTitle = true;
        else
            if(!ms_rgrg[nScr][i / 2].szTitle)
                fNewTitle = false;
            else
                fNewTitle = true;

        if(fTitle)
            if(!fNewTitle)
                *pColor = GetSysColor(COLOR_3DHILIGHT);
            else
                if(nInScr < CRED_T_GROW_HALF)
                    *pColor = GetSysColor(COLOR_3DSHADOW);
                else
                    if(nInScr < CRED_T_GROW_FULL)
                        *pColor = GetSysColor(COLOR_3DFACE);
                    else
                        if(nInScr < CRED_T_FADE_HALF)
                            *pColor = GetSysColor(COLOR_3DHILIGHT);
                        else
                            if(nInScr < CRED_T_FADE_FULL)
                                *pColor = GetSysColor(COLOR_3DFACE);
                            else
                                *pColor = GetSysColor(COLOR_3DSHADOW);
        else
            if(nInScr < CRED_P_GROW_HALF)
                *pColor = GetSysColor(COLOR_3DSHADOW);
            else
                if(nInScr < CRED_P_GROW_FULL)
                    *pColor = GetSysColor(COLOR_3DFACE);
                else
                    if(nInScr < CRED_P_FADE_HALF)
                        *pColor = GetSysColor(COLOR_3DHILIGHT);
                    else
                        if(nInScr < CRED_P_FADE_FULL)
                            *pColor = GetSysColor(COLOR_3DFACE);
                        else
                            *pColor = GetSysColor(COLOR_3DSHADOW);
     }
};

CreditScreen CPaneCredits::ms_rgrg[CRED_NUM_SCREENS][4] =
    { { { _T(""), _T("Microsoft"), 0 },                                         { _T(""), _T("zone.com"), 0 },
        { _T(""), _T(""), 0 },                                                  { _T(""), _T(""), 0 } },

      { { _T("M         I         L         L         E"), _T(""), 0 },         { _T("N         N         I         U         M"), _T(""), 0 },
        { _T("Internet"), _T(""), 0 },                                          { _T("Games"), _T(""), 0 } },

      { { _T("Development"), _T("Justin Brown"), 0 },                           { _T("Program Management"), _T("Jason Mai"), 0 },
        { _T("Test"), _T("Jennifer Boespflug"), 0 },                            { _T("Art"), _T("Jeff Fong"), 0 } },

      { { NULL, _T("John Smith"), 1 },                                          { NULL, _T("Susan Winokur"), 1 },
        { NULL, _T("Jesse McGatha"), 1 },                                       { NULL, _T("David McMurray"), 1 } },

      { { NULL, _T("Paul Watts"), 2 },                                          { _T("Web Development"), _T("Scott Tomlin"), 0 },
        { NULL, _T("Brett Roark"), 2 },                                         { _T("Content"), _T("Jo Lee Robinson"), 0 } },

      { { NULL, _T("Tim Thibault"), 3 },                                        { NULL, _T("Meiji Yugawa"), 1 },
        { NULL, _T("Scott Amis"), 3 },                                          { _T("Sound"), _T("Barry Dowsett"), 0 }, },

      { { NULL, _T("George DosSantos"), 4 },                                    { NULL, _T("Dean Pachosa"), 2 },
        { NULL, _T("Matt Vaughn"), 4 },                                         { _T("Localization"), _T("Michael Buch-Andersen"), 0 } },

      { { NULL, _T("Jeremy Mercer"), 5 },                                       { NULL, _T("Syne Mitchell"), 3 },
        { NULL, _T("Dan Phillips"), 5 },                                        { NULL, _T("Jonathon Young"), 1 } },

      { { NULL, _T("Barna Bhattacharyya"), 6 },                                 { _T("Web Test"), _T("Carl Bystrom"), 0 },
        { NULL, _T("Eric Helbig"), 6 },                                         { NULL, _T("Atsushi Miyake"), 2 } },

      { { NULL, _T("Jim Boer"), 7 },                                            { NULL, _T("Matt Golz"), 1 },
        { NULL, _T("Marsha VanEaton"), 7 },                                     { NULL, _T("Yuko Yoshida"), 3 } },

      { { NULL, _T("Hoon Im"), 8 },                                             { _T("Operations"), _T("Terry Hostetler"), 0 },
        { NULL, _T("Rolland Clark"), 8 },                                       { NULL, _T("Shigeto Mayumi"), 4 } },

      { { _T("Planning"), _T("Michael Mott"), 0 },                              { NULL, _T("Coby McGuire"), 1 },
        { NULL, _T("Brad Steele"), 9 },                                         { NULL, _T("John White"), 5 } },

      { { _T("Marketing"), _T("Eddie Ranchigoda"), 0 },                         { NULL, _T("Jason Graf"), 2 },
        { _T("Usability"), _T("Kevin Keeker"), 0 },                             { NULL, _T("Susan Mykytiuk"), 6 } },

      { { _T("Hardcore Consultant"), _T("Fiona J. Goodwillie"), 0 },            { _T("Assistant Hevvywate"), _T("Jeffrey Henderson"), 0 },
        { _T("Architot"), _T("Brick Blank"), 0 },                               { _T("Dyoody, the Queen of Sketch"), _T("Judy Guchu"), 0 } },

      { { _T("Roman Tour Guide"), _T("Susan Brooks"), 0 },                      { _T("Supporting Goldfish"), _T("Benny && Joon"), 0 },
        { _T("Best Boy"), _T("Adam Babb"), 0 },                                 { _T("Key Grip"), _T("Ben Arnette"), 0 } },

      { { _T(""), _T(""), 0 },                                                  { _T(""), _T(""), 0 },
        { _T(""), _T(""), 0 },                                                  { _T("Life is short."), _T("Drink margaritas first."), 0 } },

      { { _T("f                             o"), _T("K r i s t e n"), 0 },      { _T("o                             d"), _T("W i l l i a m s o n"), 0 },
        { _T(""), _T(""), 0 },                                                  { _T(""), _T(""), 0 } },

      { { _T(""), _T(""), 0 },                                                  { _T("Katie Dodd"), _T("the word 'internet'"), 0 },
        { _T("Susanna Tenny"), _T("grit && grip"), 0 },                         { _T(""), _T(""), 0 } },

      { { _T("zone.com"), _T("Play Games Now"), 0 },                            { _T(""), _T(""), 0 },
        { _T(""), _T(""), 0 },                                                  { _T(""), _T(""), 0 } },

      { { _T(""), _T(""), 0 },                                                  { _T(""), _T(""), 0 },
        { _T(""), _T(""), 0 },                                                  { _T(""), _T("bye"), 0 } } };

#endif  // MILL_EASTEREGG


class CPaneAbout : public CPaneImpl<CPaneAbout>
{
public:
	enum { IDD = IDD_PLAY_ABOUT };
    enum { AccOrdinal = YESACC };

	BEGIN_MSG_MAP(CPaneAbout)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
	    COMMAND_CODE_HANDLER(1, OnButtonClicked)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)


#ifdef MILL_EASTEREGG

        MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRDown)
        MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLDown)
        MESSAGE_HANDLER(WM_LBUTTONUP, OnLUp)
        MESSAGE_HANDLER(WM_RBUTTONUP, OnRUp)
        MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLDbl)
        MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnRDbl)

#endif  // MILL_EASTEREGG


        CHAIN_MSG_MAP(CPaneImpl<CPaneAbout>)
	END_MSG_MAP()

    STDMETHOD_(DWORD, GetFirstItem)() { return IDCLOSE; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDCLOSE; }

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        // find size we like
        SetSugSizeFromCurSize();

        m_nCred = 0;

        TCHAR szFormat[ZONE_MAXSTRING];
        TCHAR szName[ZONE_MAXSTRING];
        TCHAR sz[ZONE_MAXSTRING];

        const TCHAR *arVerKeys[] = { key_Version, key_VersionStr };
        TCHAR szVerStr[ZONE_MAXSTRING];
        DWORD cchVer = NUMELEMENTS(szVerStr);

        const TCHAR *arBetaKeys[] = { key_Version, key_BetaStr };
        TCHAR szBetaStr[ZONE_MAXSTRING];
        DWORD cchBeta = NUMELEMENTS(szBetaStr);

        CComPtr<IDataStore> pIDS;
        m_pMgr->GetLobbyDataStore()->GetDataStore(ZONE_NOGROUP, ZONE_NOUSER, &pIDS);

        if(m_pMgr->GetResourceManager()->LoadString(IDS_ABOUT_TM, szFormat, NUMELEMENTS(szFormat)))
            if(m_pMgr->GetResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
                if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szName))
                    SetDlgItemText(IDC_SPLASH_TEXT, sz);
        if(m_pMgr->GetResourceManager()->LoadString(IDS_ABOUT_VERSION, szFormat, NUMELEMENTS(szFormat)))
            if(m_pMgr->GetResourceManager()->LoadString(IDS_ABOUT_VERSION_HYP, szName, NUMELEMENTS(szName)))
                if(pIDS && SUCCEEDED(pIDS->GetString(arVerKeys, 2, szVerStr, &cchVer)))
                    if(pIDS && SUCCEEDED(pIDS->GetString(arBetaKeys, 2, szBetaStr, &cchBeta)))
                        if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szVerStr, szBetaStr[0] ? szName : _T(""), szBetaStr))
                            SetDlgItemText(IDC_SPLASH_TEXT2, sz);
        if(m_pMgr->GetResourceManager()->LoadString(IDS_ABOUT_WARNING, sz, NUMELEMENTS(sz)))
            SetDlgItemText(IDC_SPLASH_TEXT3, sz);

        // make font for warning smaller
        ZONEFONT fntPref;
        ZONEFONT fntBack;
        HRESULT hr1, hr2;

        HFONT hFont = NULL;
        ZeroMemory(&fntPref, sizeof(fntPref));
        ZeroMemory(&fntBack, sizeof(fntBack));

        CClientDC dc(m_hWnd);

        const TCHAR *arKeys[3] = { key_WindowManager, key_About, key_WarningFontPref };
        hr1 = m_pMgr->GetDataStoreUI()->GetFONT(arKeys, 3, &fntPref);
        arKeys[2] = key_WarningFont;
        hr2 = m_pMgr->GetDataStoreUI()->GetFONT(arKeys, 3, &fntBack);
        if(SUCCEEDED(hr1) || SUCCEEDED(hr2))
            hFont = m_fnt.SelectFont(fntPref, fntBack, dc);
        if(hFont)
            SendDlgItemMessage(IDC_SPLASH_TEXT3, WM_SETFONT, (WPARAM) hFont);

        Register();
		return TRUE;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();
        if(m_fnt.m_hFont)
            m_fnt.DeleteObject();
		return TRUE;
	}

	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, wID, 0, NULL);
		return 0;
	}


#ifdef MILL_EASTEREGG

    // I finally caved and put in a cheat - press 'shift' to enable.  Then, double-clicks don't matter (they can be single).
    //
    // The strict version is:
    // R Down
    // L Down
    // L Up
    // R Up
    // L Dbl
    // R Down
    // R Up
    // L Up
    // R Dbl
	LRESULT OnRDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        ASSERT(m_pMgr);
        if((wParam & MK_SHIFT) && !(wParam & MK_LBUTTON) && m_nCred == 8)   // shift cheat
            m_pMgr->Input(this, ID_UNUSED_BY_RES, 0, NULL);
        if(!(wParam & MK_LBUTTON))
            m_nCred = 1;
        else
            if((wParam & MK_LBUTTON) && m_nCred == 5)
                m_nCred = 6;
            else
                m_nCred = 0;
		return 0;
	}

	LRESULT OnLDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        if((wParam & MK_RBUTTON) && m_nCred == 1)
            m_nCred = 2;
        else
            if((wParam & MK_SHIFT) && !(wParam & MK_RBUTTON) && m_nCred == 4)    // shift cheat
                m_nCred = 5;
            else
                m_nCred = 0;
		return 0;
	}

	LRESULT OnLUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        if((wParam & MK_RBUTTON) && m_nCred == 2)
            m_nCred = 3;
        else
            if(!(wParam & MK_RBUTTON) && m_nCred == 7)
                m_nCred = 8;
            else
                m_nCred = 0;
		return 0;
	}

	LRESULT OnRUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        if(!(wParam & MK_LBUTTON) && m_nCred == 3)
            m_nCred = 4;
        else
            if((wParam & MK_LBUTTON) && m_nCred == 6)
                m_nCred = 7;
            else
                m_nCred = 0;
		return 0;
	}

    LRESULT OnLDbl(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        if(!(wParam & MK_RBUTTON) && m_nCred == 4)
            m_nCred = 5;
        else
            m_nCred = 0;
		return 0;
    }

    LRESULT OnRDbl(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
		ASSERT(m_pMgr);
        if(!(wParam & MK_LBUTTON) && m_nCred == 8)
    	    m_pMgr->Input(this, ID_UNUSED_BY_RES, 0, NULL);
        m_nCred = 0;
		return 0;
    }

#endif  // MILL_EASTEREGG


private:
    CZoneFont m_fnt;
    DWORD m_nCred;
};


class CPaneLeft : public CPaneImpl<CPaneLeft>
{
public:
	enum { IDD = IDD_PLAY_LEFT };
    enum { AccOrdinal = YESACC };

	BEGIN_MSG_MAP(CPaneLeft)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
	    COMMAND_CODE_HANDLER(1, OnButtonClicked)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        CHAIN_MSG_MAP(CPaneImpl<CPaneLeft>)
	END_MSG_MAP()


    STDMETHOD_(DWORD, GetFirstItem)() { return IDNO; }
    STDMETHOD_(DWORD, GetLastItem)() { return IDHELP; }

	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;
        m_fMultiOpps = false;
        m_fServerFail = false;

	    return S_OK;
	}

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        TCHAR sz[ZONE_MAXSTRING];
        TCHAR szFormat[ZONE_MAXSTRING];

        // find size we like
        SetSugSizeFromCurSize();

        // set text
        bool fRegularText = true;
        if(m_fServiceStop)
        {
            if(m_pMgr->GetResourceManager()->LoadString(IDS_LEFT_SERVICE_STOP, sz, NUMELEMENTS(sz)))
                SetDlgItemText(IDC_SPLASH_TEXT, sz);

            long fUnavailable = FALSE;
	        CComPtr<IDataStore> pIDS;
	        HRESULT hr = m_pMgr->GetLobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	        if(SUCCEEDED(hr))
                pIDS->GetLong(key_ServiceUnavailable, &fUnavailable);

            if(fUnavailable)
            {
                long nDowntime = 0;
                pIDS->GetLong(key_ServiceDowntime, &nDowntime);

                if(nDowntime)
                {
                    TCHAR szTime[ZONE_MAXSTRING];
                    CComPtr<IMillUtils> pIMU;
                    m_pMgr->GetZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
                    if(pIMU && SUCCEEDED(pIMU->WriteTime(nDowntime, szTime, NUMELEMENTS(szTime))))
                        if(m_pMgr->GetResourceManager()->LoadString(IDS_LEFT_UNAVAILABLE2, szFormat, NUMELEMENTS(szFormat)))
                            if(ZoneFormatMessage(szFormat, sz, NUMELEMENTS(sz), szTime))
                                SetDlgItemText(IDC_SPLASH_TEXT2, sz);
                }
                else
                    if(m_pMgr->GetResourceManager()->LoadString(IDS_LEFT_UNAVAILABLE, sz, NUMELEMENTS(sz)))
                        SetDlgItemText(IDC_SPLASH_TEXT2, sz);

                fRegularText = false;
            }
        }
        else
            if(m_fServerFail)
                if(m_pMgr->GetResourceManager()->LoadString(IDS_LEFT_SERVER_FAIL, sz, NUMELEMENTS(sz)))
                    SetDlgItemText(IDC_SPLASH_TEXT, sz);

        if(m_fMultiOpps)
        {
            if(m_pMgr->GetResourceManager()->LoadString(IDS_UPSELL_BUTTON4, sz, NUMELEMENTS(sz)))
                SetDlgItemText(IDNO, sz);
            if(fRegularText)
                if(m_pMgr->GetResourceManager()->LoadString(IDS_LEFT_MULTI_OPPS, sz, NUMELEMENTS(sz)))
                    SetDlgItemText(IDC_SPLASH_TEXT2, sz);
        }

        Register();
		return TRUE;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
        Unregister();
		return TRUE;
	}

	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		ASSERT(m_pMgr);
    	m_pMgr->Input(this, wID, 0, NULL);
		return 0;
	}

    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
        // must be set BEFORE window is created
        if(m_hWnd)
            return S_FALSE;

        // 0x1 = lobby server crashed
        m_fServerFail = (code & 0x1) || (code & 0x2);

        // 0x2 = more than two player game
        m_fMultiOpps = ((code & 0x2) ? true : false);

        // 0x4 = service was stopped
        m_fServiceStop = ((code & 0x4) ? true : false);

	    return S_OK;
	}

private:
    bool m_fMultiOpps;
    bool m_fServerFail;
    bool m_fServiceStop;
};


/////////////////////////////////////////////////////////////////////////////
// CPlugNPlayDialog
typedef CWinTraits<WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_SYSMENU, 
WS_EX_APPWINDOW | WS_EX_DLGMODALFRAME | WS_EX_RTLREADING>		CPlugNPlayTraits;

typedef CWinTraits<WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 
WS_EX_DLGMODALFRAME | WS_EX_RTLREADING>		CPlugNPlayTraitsChild;


class CPlugNPlayWindow : 
	public CWindowImpl<CPlugNPlayWindow,CWindow,CPlugNPlayTraits>
{
public:
	CPalette m_Palette;			// palette we realize (we're a topmost window)
    HICON m_hIcon;
    HICON m_hIconSm;

	DECLARE_WND_CLASS(_T("PlugNPlay"));

	CPlugNPlayWindow(HPALETTE hPal, HICON hIcon, HICON hIconSm) : m_Palette(hPal), m_hIcon(hIcon), m_hIconSm(hIconSm), m_hSinkWnd(NULL) { }
	~CPlugNPlayWindow() { m_Palette.Detach(); }

	BEGIN_MSG_MAP(CPlugNPlayWindow)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
		MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
        MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnErase)
	END_MSG_MAP()
	   
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, 
                   LPARAM lParam, BOOL& bHandled)
	{
        SetClassLong(m_hWnd, GCL_HBRBACKGROUND, (LONG) GetStockObject(NULL_BRUSH));

        // for top-level dialogs, we have to do all this crap
        if(GetWindowLong(GWL_STYLE) & WS_SYSMENU)
        {
            if(m_hIcon)
                SetIcon(m_hIcon, true);

            if(m_hIconSm)
                SetIcon(m_hIconSm, false);

            // set up the system menu
            HMENU hMenu = GetSystemMenu(false);
            if(hMenu)
            {
                DeleteMenu(hMenu, SC_RESTORE, MF_BYCOMMAND);
                DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
                DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
                DeleteMenu(hMenu, SC_SIZE, MF_BYCOMMAND);
            }
        }
		return TRUE;
	}

	LRESULT OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		LPMINMAXINFO pMinMax = (LPMINMAXINFO)lParam;
        CRect rc;

        if(!GetParent())
        {
            GetWindowRect(&rc);

            pMinMax->ptMaxSize = CPoint(rc.Size());
            pMinMax->ptMaxPosition = rc.TopLeft();
            pMinMax->ptMinTrackSize = CPoint(rc.Size());
            pMinMax->ptMaxTrackSize = CPoint(rc.Size());
        }

		return 0;
	}

	LRESULT OnErase(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return true;
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        if(m_hSinkWnd)
            ::SetFocus(m_hSinkWnd);
        return 0;
	}

	LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        bHandled = true;
        if(!GetParent() && m_hSinkWnd)
            ::PostMessage(m_hSinkWnd, WM_COMMAND, IDCANCEL, NULL);
        return 0;
	}

	LRESULT OnQueryNewPalette(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
		// Need the window's DC for SelectPalette/RealizePalette
		CDC dc = GetDC();

		// Select and realize hPalette
		HPALETTE hOldPal = dc.SelectPalette(m_Palette, FALSE);
 
		if(dc.RealizePalette())
		{    
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
		}  

		// Clean up
		dc.SelectPalette(hOldPal, TRUE);

		return TRUE;
	}

	LRESULT OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
		HPALETTE hOldPal;  // Handle to previous logical palette

		// If this application did not change the palette, select
		// and realize this application's palette
		if ((HWND)wParam != m_hWnd)
		{
			// Need the window's DC for SelectPalette/RealizePalette
			CDC dc = GetDC();
			// Select and realize hPalette
			hOldPal = dc.SelectPalette(m_Palette, TRUE);
			dc.RealizePalette();

			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);

		    HWND hWnd = GetWindow(GW_CHILD);
		    while(hWnd)
		    {
			    ::SendMessage(hWnd, nMsg, wParam, lParam);
			    hWnd = ::GetWindow(hWnd, GW_HWNDNEXT);
		    }

			// Clean up
		    if (hOldPal)
				dc.SelectPalette(hOldPal, TRUE);
		}

		return 0;
	}

    HRESULT SetSinkWnd(HWND hWnd)
    {
        m_hSinkWnd = hWnd;
        return S_OK;
    }

private:
    HWND m_hSinkWnd;
};


HRESULT CreatePlugNPlayWindow(HWND hWndParent, HPALETTE hPal, HICON hIcon, HICON hIconSm, LPCTSTR szTitle, CPlugNPlayWindow **ppWindow)
{
    HWND hwnd;
    CPlugNPlayWindow *pWin;

    if (!ppWindow)
        return E_INVALIDARG;

    *ppWindow =NULL;

    pWin = new CPlugNPlayWindow(hPal, hIcon, hIconSm);

    if (!pWin)
        return E_OUTOFMEMORY;

    if(hWndParent)
        hwnd = pWin->Create(hWndParent, CWindow::rcDefault, NULL, CPlugNPlayTraitsChild::GetWndStyle(0), CPlugNPlayTraitsChild::GetWndExStyle(0));
    else
        hwnd = pWin->Create(NULL, CWindow::rcDefault, szTitle);

    if (!hwnd)
    {
        delete pWin;
        return E_FAIL;
    }
    *ppWindow = pWin;
    return S_OK;
}


HRESULT CPlugNPlay::Init(IZoneShell *pZoneShell)
{
    m_pZoneShell = pZoneShell;

    CComPtr<IResourceManager> pRes;
    HRESULT hr = m_pZoneShell->QueryService(SRVID_ResourceManager, IID_IResourceManager, (void**) &pRes);
    if(SUCCEEDED(hr))
    {
        m_hIcon = pRes->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR);
        m_hIconSm = pRes->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
    }

    return S_OK;
}


HRESULT CPlugNPlay::Close()
{
    m_pZoneShell.Release();
    return S_OK;
}


HRESULT CPlugNPlay::CreatePNP(HWND hWndParent, LPCTSTR szTitle, long cyTopMargin, long cyBottomMargin)
{
    HRESULT hr;

    if(m_pPNP)
        return E_INVALIDARG;   // should learn better E codes

	hr = CreatePlugNPlayWindow(hWndParent, m_pZoneShell->GetPalette(), m_hIcon, m_hIconSm, szTitle, &m_pPNP);
	if (FAILED(hr))
	    return hr;

    m_cyTopMargin = cyTopMargin;
    m_cyBottomMargin = cyBottomMargin;

    if(!hWndParent)
    {
        m_pZoneShell->AddTopWindow(*m_pPNP);
        return S_OK;
    }

    CComPtr<IEventQueue> pEv;
    hr = m_pZoneShell->QueryService(SRVID_EventQueue, IID_IEventQueue, (void**) &pEv);
    if(SUCCEEDED(hr))
        pEv->PostEvent(PRIORITY_NORMAL, EVENT_UI_UPSELL_UP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);

    return S_OK;
}


HRESULT CPlugNPlay::DestroyPNP()
{
    HWND hWndParent = NULL;

    if(m_pPNP)
    {
        hWndParent = m_pPNP->GetParent();
        if(!hWndParent)
            m_pZoneShell->RemoveTopWindow(*m_pPNP);
    }

	if ( m_pCurrentPlay )
	{
		m_pCurrentPlay->DestroyPane();
		m_pCurrentPlay = NULL;
	}

	if ( m_pCurrentPlug )
	{
		m_pCurrentPlug->DestroyPane();
		m_pCurrentPlug = NULL;
	}

    if(m_pPNP)
	{
        CComPtr<IEventQueue> pEv;
        HRESULT hr = m_pZoneShell->QueryService(SRVID_EventQueue, IID_IEventQueue, (void**) &pEv);
        if(SUCCEEDED(hr))
            pEv->PostEvent(PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) m_pPNP->m_hWnd, (DWORD) m_pPNP);
        else
        {
			ASSERT(FALSE);
            m_pPNP->DestroyWindow();
            delete m_pPNP;
        }

	    m_pPNP = NULL;

        if(hWndParent)
        {
            CComPtr<IEventQueue> pEv;
            HRESULT hr = m_pZoneShell->QueryService(SRVID_EventQueue, IID_IEventQueue, (void**) &pEv);
            if(SUCCEEDED(hr))
                pEv->PostEvent(PRIORITY_NORMAL, EVENT_UI_UPSELL_DOWN, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        }
	}

    m_rcPNP.SetRectEmpty();

    return S_OK;
}


void CPlugNPlay::Block()
{
    m_nBlockCount++;
    if(m_pPNP && m_pPNP->GetParent())
        m_pPNP->ShowWindow(SW_HIDE);
}


void CPlugNPlay::Unblock()
{
    if(!m_nBlockCount)
        return;
    m_nBlockCount--;

    if(!m_pPNP || m_nBlockCount)
        return;

    if(m_pPNP->GetParent())
    {
        if(m_fPostponedShow)
            Show(SW_SHOW);
    }
    else
    {
        if(m_pPostPlug || m_pPostPlay)
            SetPlugAndOrPlay(m_pPostPlug, m_pPostPlay);
    }
}


HRESULT CPlugNPlay::SetPlugAndOrPlay(IPane *pPlug, IPane *pPlay)
{
    BOOL fChanged = FALSE;
    IPane *pOldPlug = NULL;
    IPane *pOldPlay = NULL;
    HWND h;

    if(!m_pPNP)
        return E_INVALIDARG;   // should learn better E codes

    // if it's blocked but visible because it's the only window, ignore this (!)
    // unless there is nothing there yet
    if(m_nBlockCount && !m_pPNP->GetParent() && m_pCurrentPlug && m_pCurrentPlay)
    {
        // save for later
        if(pPlug)
            m_pPostPlug = pPlug;
        if(pPlay)
            m_pPostPlay = pPlay;

        return S_FALSE;
    }

    m_pPostPlug = NULL;
    m_pPostPlay = NULL;

    if(pPlug && pPlug != m_pCurrentPlug)
    {
        pOldPlug = m_pCurrentPlug;
        m_pCurrentPlug = pPlug;

        m_pCurrentPlug->CreatePane(m_pPNP->m_hWnd, NULL);
        fChanged = TRUE;
    }

    if(pPlay && pPlay != m_pCurrentPlay)
    {
        pOldPlay = m_pCurrentPlay;
        m_pCurrentPlay = pPlay;

        m_pCurrentPlay->CreatePane(m_pPNP->m_hWnd, NULL);
        fChanged = TRUE;

        // the play window is the sink for interesting messages received by the PNP main window
        m_pCurrentPlay->GetWindowPane(&h);
        m_pPNP->SetSinkWnd(h);
    }

    if(fChanged && m_pCurrentPlug && m_pCurrentPlay)
    {
        RecalcLayout();
        ImplementLayout(TRUE);

        if(pOldPlug)
        {
            pOldPlug->GetWindowPane(&h);
            if(IsWindowVisible(h))
            {
                m_pCurrentPlug->GetWindowPane(&h);
                ::ShowWindow(h, SW_SHOW);
            }

            pOldPlug->DestroyPane();
        }

        if(pOldPlay)
        {
            pOldPlay->GetWindowPane(&h);
            if(IsWindowVisible(h))
            {
                m_pCurrentPlay->GetWindowPane(&h);
                ::ShowWindow(h, SW_SHOW);
            }

            pOldPlay->DestroyPane();
        }
    }

    return S_OK;
}


HRESULT CPlugNPlay::Show(int cmd)
{
    HWND hPlug;
    HWND hPlay;

    m_fPostponedShow = false;

	m_pCurrentPlug->GetWindowPane(&hPlug);
    m_pCurrentPlay->GetWindowPane(&hPlay);

    if(cmd == SW_HIDE)
        m_pPNP->ShowWindow(cmd);

    ::ShowWindow(hPlug, cmd);
    ::ShowWindow(hPlay, cmd);

    if(cmd != SW_HIDE)
        if(!m_nBlockCount || !m_pPNP->GetParent())
            m_pPNP->ShowWindow(cmd);
        else
            m_fPostponedShow = true;

    return S_OK;
}


HRESULT CPlugNPlay::RePosition()
{
    HWND hParent;
    CRect rcParent;
    CRect rc;

    rc = m_rcPNP;

    hParent = m_pPNP->GetParent();
    if(!hParent)
        return S_FALSE;

    ::GetClientRect(hParent, &rcParent);

    if(m_rcPNP.Height() < rcParent.Height() - m_cyTopMargin - m_cyBottomMargin)
        m_rcPNP.OffsetRect(0, m_cyTopMargin - m_rcPNP.top);
    else
        if(m_rcPNP.Height() < rcParent.Height() - m_cyBottomMargin)
            m_rcPNP.OffsetRect(0, rcParent.Height() - m_cyBottomMargin - m_rcPNP.bottom);
        else
            if(m_rcPNP.Height() < rcParent.Height())
                m_rcPNP.OffsetRect(0, -m_rcPNP.top);
            else
                m_rcPNP.OffsetRect(0, rcParent.Height() - m_rcPNP.bottom);

    if(m_rcPNP.Width() < rcParent.Width())
        m_rcPNP.OffsetRect((rcParent.Width() - m_rcPNP.Width()) / 2 - m_rcPNP.left, 0);
    else
        m_rcPNP.OffsetRect(rcParent.Width() - m_rcPNP.right, 0);

    if(!m_rcPNP.EqualRect(rc))
        return S_OK;
    else
        return S_FALSE;
}


BOOL CPlugNPlay::RecalcLayout()
{
    SIZE zePlug;
    SIZE zePlay;
    CRect rcPlug;
    CRect rcPlay;
    CRect rcWindow;
    BOOL fChanged = FALSE;
    HWND hWndParent;
    CRect rcParent;

    if(!m_pCurrentPlug || !m_pCurrentPlay)
        return FALSE;

    m_pCurrentPlug->GetSuggestedSize(&zePlug);
    m_pCurrentPlay->GetSuggestedSize(&zePlay);

    // Plug always gets the height it wants
    rcPlug.SetRectEmpty();
    rcPlug.bottom = zePlug.cy;

    // Play always gets the height it wants, below Plug
    rcPlay.SetRectEmpty();
    rcPlay.bottom = zePlay.cy;
    rcPlay.OffsetRect(0, rcPlug.bottom);

    // They both get at least the width they want
    rcPlug.right = rcPlay.right = (zePlug.cx > zePlay.cx ? zePlug.cx : zePlay.cx);

    //determine size of window
    rcWindow.SetRectEmpty();
    rcWindow.right = rcPlug.right;
    rcWindow.bottom = rcPlay.bottom;

    // see if this is already on-screen - if so, keep existing top
    hWndParent = m_pPNP->GetParent();
    if(!hWndParent)
    {
        AdjustWindowRectEx(rcWindow, CPlugNPlayTraits::GetWndStyle(0), FALSE, CPlugNPlayTraits::GetWndExStyle(0));
        rcWindow.OffsetRect(-rcWindow.left, -rcWindow.top);

        if(!m_rcPNP.IsRectNull())
            rcWindow.OffsetRect((GetSystemMetrics(SM_CXSCREEN) - rcWindow.right) / 2, m_rcPNP.top);
        else
            rcWindow.OffsetRect((GetSystemMetrics(SM_CXSCREEN) - rcWindow.right) / 2, (GetSystemMetrics(SM_CYSCREEN) - rcWindow.bottom) / 2);
    }
    else
    {
        AdjustWindowRectEx(rcWindow, CPlugNPlayTraitsChild::GetWndStyle(0), FALSE, CPlugNPlayTraitsChild::GetWndExStyle(0));
        rcWindow.OffsetRect(-rcWindow.left, -rcWindow.top);

        ::GetClientRect(hWndParent, &rcParent);
        if(!m_rcPNP.IsRectNull())
            rcWindow.OffsetRect((rcParent.Width() - rcWindow.right) / 2, m_rcPNP.top);
        else
            rcWindow.OffsetRect((rcParent.Width() - rcWindow.right) / 2, (rcParent.Height() - rcWindow.bottom) / 2);
    }

    if(!rcPlug.EqualRect(m_rcPlug))
    {
        m_rcPlug = rcPlug;
        fChanged = TRUE;
    }

    if(!rcPlay.EqualRect(m_rcPlay))
    {
        m_rcPlay = rcPlay;
        fChanged = TRUE;
    }

    if(!rcWindow.EqualRect(m_rcPNP))
    {
        // for this, the position is actually set elsewhere, just chek the size for change
        if(m_rcPNP.Height() != rcWindow.Height() || m_rcPNP.Width() != rcWindow.Width())
            fChanged = TRUE;

        m_rcPNP = rcWindow;
    }

    return fChanged;
}


HRESULT CPlugNPlay::ImplementLayout(BOOL fRepaint)
{
    HWND hPlug;
    HWND hPlay;

    if(!m_pCurrentPlug || !m_pCurrentPlay)
        return E_INVALIDARG;

	m_pCurrentPlug->GetWindowPane(&hPlug);
    m_pCurrentPlay->GetWindowPane(&hPlay);

    if(m_pPNP->GetParent())
        RePosition();

	m_pPNP->MoveWindow(&m_rcPNP, fRepaint);
    ::MoveWindow(hPlug, &m_rcPlug, fRepaint);
    ::MoveWindow(hPlay, &m_rcPlay, fRepaint);

    if(m_pPNP->GetParent())
        m_pPNP->BringWindowToTop();

    return S_OK;
}


LRESULT CPlugNPlay::TransferMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    if(!m_pPNP)
        return 0;

    return m_pPNP->SendMessage(nMsg, wParam, lParam);
}


HRESULT CPlugNPlay::CreateSplashPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;

    CComObject<CPaneSplash> *p = NULL;
    HRESULT hr = CComObject<CPaneSplash>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateIEPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneIE> *p = NULL;
    HRESULT hr = CComObject<CPaneIE>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateComfortPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneComfort> *p = NULL;
    HRESULT hr = CComObject<CPaneComfort>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateConnectingPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneConnecting> *p = NULL;
    HRESULT hr = CComObject<CPaneConnecting>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateGameOverPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneGameOver> *p = NULL;
    HRESULT hr = CComObject<CPaneGameOver>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateErrorPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneError> *p = NULL;
    HRESULT hr = CComObject<CPaneError>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateAboutPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneAbout> *p = NULL;
    HRESULT hr = CComObject<CPaneAbout>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}


HRESULT CPlugNPlay::CreateCreditsPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;


#ifdef MILL_EASTEREGG

    CComObject<CPaneCredits> *p = NULL;
    HRESULT hr = CComObject<CPaneCredits>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;

#else

    *ppPane = NULL;

#endif  // MILL_EASTEREGG


    return S_OK;
}


HRESULT CPlugNPlay::CreateLeftPane(IPane **ppPane)
{
    if (!ppPane)
        return E_INVALIDARG;
        
    CComObject<CPaneLeft> *p = NULL;
    HRESULT hr = CComObject<CPaneLeft>::CreateInstance(&p);

    if(FAILED(hr))
        return hr;

    p->AddRef();  // hack because this never gets released, just deleted
    *ppPane = p;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\shellm.cpp ===
// LobbyWindow.cpp : Implementation of CLobbyWindow

#include "stdafx.h"
#include "shellm.h"
#include "thing.h"


/////////////////////////////////////////////////////////////////////////////
// CShellM
class CShellClient: public CTClient
{

};

class CShellThing: public CThing
{
public:
    CShellClient m_client;

    CShellThing()
    {
        pClient = &m_client;
    };
    
};



class CShellM : public IWorldExports
{
public:
// IWorldExports
	STDMETHOD(Init)();
	STDMETHOD(Shutdown)();

	//Client functions
	STDMETHOD(ClientCreate)(CThing** ppThing);
	STDMETHOD(ClientBegin)(CThing* pThing);
    STDMETHOD(ClientCommand)(CThing* pThing);
    STDMETHOD(ClientDisconnect)(CThing* pThing);
	
	STDMETHOD(ClientThink)(CThing* pThing);
	STDMETHOD(RunFrame)();
	
	STDMETHOD(GetVersion)(LONG *pValue)
	{
	    *pValue = WORLD_VERSION;
	    return S_OK;
	};


public:
	CShellM() 
	{
	}

	~CShellM()
	{
	}

    IWorldImports * m_pWI ;

protected:
    CShellThing m_thing;
//      CShellClient m_clients;
};



STDMETHODIMP SetupWorld(IWorldImports *pWI,IWorldExports **ppWE)
{
    if (!ppWE || !pWI)
        return E_INVALIDARG;
        
    CShellM *pWE = new CShellM;

    if (!pWE)
        return E_OUTOFMEMORY;

    pWE->m_pWI = pWI;

    *ppWE = pWE;

    return S_OK;
};


STDMETHODIMP CShellM::Init()
{
    return S_OK;
};

STDMETHODIMP CShellM::Shutdown()
{
    return S_OK;
};


STDMETHODIMP CShellM::ClientCreate(CThing** ppThing)
{
    if (!ppThing)
        return E_INVALIDARG;

    ASSERT(!m_thing.inuse);
    *ppThing = &m_thing;
    
    return S_OK;
};

STDMETHODIMP CShellM::ClientBegin(CThing* pThing)
{
    return S_OK;
};


STDMETHODIMP CShellM::ClientCommand(CThing* pThing)
{
    return S_OK;
};

STDMETHODIMP CShellM::ClientDisconnect(CThing* pThing)
{
    return S_OK;
};


STDMETHODIMP CShellM::ClientThink(CThing* pThing)
{
    return S_OK;
};

STDMETHODIMP CShellM::RunFrame()
{
    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\unicodeapi\uniansidll\unicodeapi.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 *****************************************************************************/

///************** Needs to be tested with MB char sets GetClassName

#include <windows.h>
#include <winreg.h>
#include <crtdbg.h>
#include <richedit.h>
#include "UAConv.h"
#include "stdafx.h"


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#include "UnicodeAPI.h"
									 
//////////////////////////
// Constants
//////////////////////////
#define NUMBERS					 L"0123456789"
#define FMFORMATOUTPUTTYPES		 L"-+0123456789 #*.LI"
#define FMREGTYPES				 L"%oeEdDhHilpuxXfgGn"
#define FMSORC					 L"cs"


#define MAX_FORMAT_MESSAGE_SIZE  10000
#define WPRINTF_CHARS			 10000
#define FORMAT_MESSAGE_EXTRA	   512
#define UNICODE_ERROR			    -1

#ifndef MIN
#define MIN(_aa, _bb) ((_aa) < (_bb) ? (_aa) : (_bb))
#endif


//Used for setting flags in variables
#define FLAGON( X, F )  ( X |=F )
#define FLAGOFF( X, F ) ( X & F ) ? X ^= F : X

#define NUMBERS			L"0123456789"
#define ISNUM(N)		( ((wcschr( NUMBERS, N ) != NULL) && (N != L'\0' )) ? TRUE : FALSE )

//Used for format message, wsprintf, and wvsprintf
#define ISFMREGTYPE(c)	( wcschr( FMREGTYPES, c )   != NULL ? TRUE : FALSE )
#define ISFMSORC(c)     ( wcschr( FMSORC,     c )	!= NULL ? TRUE : FALSE )
#define ISFORMATOUTPUTTYPE(c) ( wcschr( FMFORMATOUTPUTTYPES, c ) != NULL ? TRUE : FALSE )

//Check if a ptr is an atom
#define ISATOM(a)		( ( !((DWORD) a & 0xFFFF0000) )		       ? TRUE  : FALSE )
//Checks if Wstr is valid then onverts string to ansi and return true or false 
#define RW2A(A,W)		( ( (W != NULL) && ((A = W2A(W)) == NULL)) ? FALSE : TRUE )
//Returns the size of a needed Ansi buffer based on length of wide string
#define BUFSIZE(x)		((x+1)*sizeof(WCHAR))
//Determines if the param is a character or a string
#define ISCHAR			ISATOM

int CALLBACK EnumFontFamProcWrapperAU( const LOGFONTA		*lpelf,     // logical-font data
									   const TEXTMETRICA    *lpData,	// physical-font data
									   DWORD   				FontType,  // type of font
									   LPARAM				lParam     // application-defined data
									 );
// Bits for UCheckOS()

#define OS_ARABIC_SUPPORT	0x00000001
#define OS_HEBREW_SUPPORT	0x00000002
#define OS_BIDI_SUPPORT		(OS_ARABIC_SUPPORT | OS_HEBREW_SUPPORT)
#define OS_WIN95			0x00000004
#define OS_NT 				0x00000008
#define LCID_FONT_INSTALLED	0x08
#define LCID_KBD_INSTALLED	0x10
#define LCID_LPK_INSTALLED	0x20
#define BIDI_LANG_INSTALLED ( LCID_INSTALLED | LCID_FONT_INSTALLED | LCID_KBD_INSTALLED | LCID_LPK_INSTALLED)

UINT LangToCodePage(IN LANGID wLangID       ) ;
int  StandardAtoU  (LPCSTR , int , LPWSTR   ) ; // Default ANSI to Unicode conversion
int  StandardUtoA  (LPCWSTR, int , LPSTR    ) ; // Default Unicode to ANSI conversion
BOOL CopyLfaToLfw  (LPLOGFONTA , LPLOGFONTW ) ;
BOOL CopyLfwToLfa  (LPLOGFONTW , LPLOGFONTA ) ;

// Global variables used only in this module, not exported
typedef struct _tagGLOBALS
{
	BOOL	bInit;
	UINT	UICodePage;
	UINT	InputCodePage;
	UINT    uFlags;
} GLOBALS, *PGLOBALS;

GLOBALS globals;

void  SetInit()		 			    { globals.bInit = TRUE;							}
BOOL  IsInit()		 			    { return globals.bInit; 						}
BOOL  ISNT() 		 			    { return globals.uFlags & OS_NT ? TRUE : FALSE; }
UINT  InputPage() 	 			    { return globals.InputCodePage; 				}
UINT  UICodePage()   			    { return globals.UICodePage;    				}
void  SetInputPage(UINT uCodePage)  { globals.InputCodePage = uCodePage;			}
void  SetUIPage(UINT uCodePage) 	{ globals.UICodePage    = uCodePage;			}


UINT WINAPI UCheckOS(void)
{
	UINT uRetVal = 0;

	OSVERSIONINFOA ovi;
	ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	GetVersionExA(&ovi);
#ifdef EMULATE9X
		HFONT hFontSys;
		LOGFONTA lfASys;
		uRetVal |= OS_WIN95;
		hFontSys = (HFONT)GetStockObject(SYSTEM_FONT);
		if ((HFONT)NULL != hFontSys)
		{	
			if (GetObjectA(hFontSys, sizeof(LOGFONTA), &lfASys))
			{
				if(ARABIC_CHARSET == lfASys.lfCharSet)
					uRetVal |= OS_ARABIC_SUPPORT;
				else if(HEBREW_CHARSET == lfASys.lfCharSet)
					uRetVal |= OS_HEBREW_SUPPORT;
			}	
		}	
#else

	if(VER_PLATFORM_WIN32_WINDOWS == ovi.dwPlatformId)
	{
		HFONT hFontSys;
		LOGFONTA lfASys;
		uRetVal |= OS_WIN95;
		hFontSys = (HFONT)GetStockObject(SYSTEM_FONT);
		if ((HFONT)NULL != hFontSys)
		{	
			if (GetObjectA(hFontSys, sizeof(LOGFONTA), &lfASys))
			{
				if(ARABIC_CHARSET == lfASys.lfCharSet)
					uRetVal |= OS_ARABIC_SUPPORT;
				else if(HEBREW_CHARSET == lfASys.lfCharSet)
					uRetVal |= OS_HEBREW_SUPPORT;
			}	
		}	
	}
	else if(VER_PLATFORM_WIN32_NT == ovi.dwPlatformId) //NT
	{
		uRetVal |= OS_NT;
		if ( IsValidLocale( MAKELCID(MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT), SORT_DEFAULT), BIDI_LANG_INSTALLED))
			uRetVal |= OS_ARABIC_SUPPORT;
			if (IsValidLocale( MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT), SORT_DEFAULT), BIDI_LANG_INSTALLED))
				uRetVal |= OS_HEBREW_SUPPORT;
	}
#endif	
	return(uRetVal);
}

BOOL Initialize()
{
	if ( !globals.bInit )
	{
	 	globals.UICodePage 	   = CP_ACP;
	 	globals.InputCodePage  = CP_ACP;
		globals.uFlags 		   = UCheckOS();			
		globals.bInit 		   = TRUE;
	}

	return TRUE;
}	

BOOL APIENTRY DllMain( 
					   HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{

	//The DisableThreadLibraryCalls function disables the DLL_THREAD_ATTACH and 
	//DLL_THREAD_DETACH notifications for the dynamic-link library (DLL) specified 
	//by hLibModule. This can reduce the size of the working code set for some 
	//applications
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) 
	{
		Initialize();
		/*
        DisableThreadLibraryCalls((HMODULE) hModule);
		*/
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI ConvertMessageAU( IN      HWND hWnd       , 
							  IN      UINT message    , 
							  IN OUT  WPARAM *pwParam , 
							  IN OUT  LPARAM *plParam
							)
{

    static CHAR s_sANSIchar[3] = "\0" ;

    int nReturn ;

    switch (message)
    {
    case WM_CHAR:

        // We have to go through all this malarky because DBCS characters arrive one byte
        // at a time. It's much better to get DBCS characters via WM_IME_CHAR messages, 
        // because even in ANSI mode, you get both bytes at once. 
        // In this sample application, most of this code is never used because DBCS chars
        // are handled by WM_IME_CHAR below. You can comment out that case (and the 
        // corresponding one in WinProc) to test this code.

        if(!s_sANSIchar[0]) 
		{  // No lead byte already waiting for trail byte

#ifdef _DEBUG
			int nScanCode = LPARAM_TOSCANCODE(*plParam) ;
#endif
            s_sANSIchar[0] = (CHAR) *pwParam ; 
            if(IsDBCSLeadByteEx(InputPage() , *pwParam)) 
			{
                // This is a lead byte. Save it and wait for trail byte
                return FALSE;
            }
            // Not a DBCS character. Convert to Unicode.
            MultiByteToWideChar(InputPage(), 0, s_sANSIchar, 1, (LPWSTR) pwParam, 1) ;
            s_sANSIchar[0] = 0 ;    // Reset to indicate no Lead byte waiting
            return TRUE ;
        }
        else 
		{ // Have lead byte, pwParam should contain the trail byte
            s_sANSIchar[1] = (CHAR) *pwParam ;
            // Convert both bytes into one Unicode character
            MultiByteToWideChar(InputPage(), 0, s_sANSIchar, 2, (LPWSTR) pwParam, 1) ;
            s_sANSIchar[0] = 0 ;    // Reset to non-waiting state
            return TRUE ;
        }

// Change to #if 0 to test WM_CHAR logic for DBCS characters
#if 1
    case WM_IME_CHAR:

        // The next 3 lines replace all but one line in the WM_CHAR case above. This is why 
        // it's best to get IME chars through WM_IME_CHAR rather than WM_CHAR when in 
        // ANSI mode.
        s_sANSIchar[1] = LOBYTE((WORD) *pwParam) ;
        s_sANSIchar[0] = HIBYTE((WORD) *pwParam) ;
        
        nReturn = MultiByteToWideChar(InputPage(), 0, s_sANSIchar, 2, (LPWSTR) pwParam, 1) ;
        return (nReturn > 0) ;
#endif

    case WM_INPUTLANGCHANGEREQUEST:
    {
        HKL NewInputLocale = (HKL) *plParam ;

        LANGID wPrimaryLang 
            = PRIMARYLANGID(LANGIDFROMLCID(LOWORD(NewInputLocale))) ;

        // Reject change to Indic keyboards, since they are not supported by
        // ANSI applications
        switch (wPrimaryLang) 
		{

            case LANG_ASSAMESE :
            case LANG_BENGALI :
            case LANG_GUJARATI :
            case LANG_HINDI :
            case LANG_KANNADA :
            case LANG_KASHMIRI :
            case LANG_KONKANI :
            case LANG_MALAYALAM :
            case LANG_MARATHI :
            case LANG_NEPALI :
            case LANG_ORIYA :
            case LANG_PUNJABI :
            case LANG_SANSKRIT :
            case LANG_SINDHI :
            case LANG_TAMIL :
            case LANG_TELUGU :

                return FALSE ;
        }

        // Utility program defined below
        SetInputPage( LangToCodePage( LOWORD(NewInputLocale) ) );

        return TRUE ;
    }

    default:

        return TRUE ;
    }
}
///////////////////////////////
//
//
// GDI32.DLL
//
//
///////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//
// int GetTextFaceAU(	HDC		hdc,         // handle to DC
//						int		nCount,      // length of typeface name buffer
//						LPWSTR  lpFaceName   // typeface name buffer
//					)
//
//  PURPOSE:  Wrapper over GetTextFaceA that mimics GetTextFaceW
//
//  NOTES:    SEE Win32 GetTextFace for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

int WINAPI GetTextFaceAU(	HDC		hdc,         // handle to DC
							int		nCount,      // length of typeface name buffer
							LPWSTR  lpFaceName   // typeface name buffer
						)
{

	if ( ISNT() )
	{
		return GetTextFaceW( hdc, nCount, lpFaceName );
	}
	
	LPSTR lpFaceNameA = (LPSTR)alloca( BUFSIZE( nCount ) );

	_ASSERT( lpFaceNameA != NULL );

	//Make sure it was allocated correctly
	if ( nCount && lpFaceNameA == NULL )
	{		
		_ASSERT( FALSE );
		return 0;
	}

	//Call the ansi version
	int iRet = GetTextFaceA( hdc, BUFSIZE( nCount ), lpFaceNameA );

	//check if the function failed or need bigger buffer
	if ( iRet == 0 || iRet > nCount )
	{
		return iRet;
	}

	//Convert the name to Unicode
	if ( !StandardAtoU( lpFaceNameA, nCount, lpFaceName ) )
	{
		_ASSERT( FALSE );
		return 0;
	}

	return iRet;
}



/////////////////////////////////////////////////////////////////////////////////
//
// HDC CreateDCAU(	LPCWSTR		   lpszDriver,        // driver name
//					LPCWSTR		   lpszDevice,        // device name
//					LPCWSTR		   lpszOutput,        // not used; should be NULL
//					CONST DEVMODE *lpInitData  // optional printer data
//				 )
//
//  PURPOSE:  Wrapper over CreateDCA that mimics CreateDCW
//
//  NOTES:    SEE Win32 CreateDC for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

HDC WINAPI CreateDCAU(	LPCWSTR		   lpszDriver,        // driver name
						LPCWSTR		   lpszDevice,        // device name
						LPCWSTR		   lpszOutput,        // not used; should be NULL
						CONST DEVMODEW *lpInitData  // optional printer data
					  )
{

	if ( ISNT() )
	{
		return CreateDCW( lpszDriver, lpszDevice, lpszOutput, lpInitData);
	}

	USES_CONVERSION;

	LPSTR lpszDriverA = NULL;
	LPSTR lpszDeviceA = NULL;
	LPSTR lpszOutputA = NULL;
	
	//Convert the strings
	if ( !RW2A(lpszDriverA,lpszDriver) || !RW2A(lpszDeviceA, lpszDevice) || !RW2A(lpszOutputA, lpszOutput) )
		return NULL;

	_ASSERT( lpInitData == NULL );

	//Call and return the ansi version
	return CreateDCA( lpszDriverA, lpszDeviceA, lpszOutputA, NULL );
}

/////////////////////////////////////////////////////////////////////////////////
//
// BOOL WINAPI GetTextMetricsAU(	HDC hdc,			// handle of device context 
//									LPTEXTMETRICW lptm 	// address of text metrics structure 
//  						   )
//
//  PURPOSE:  Wrapper over GetTextMetricsA that mimics GetTextMetricsW
//
//  NOTES:    SEE Win32 GetTextMetrics for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetTextMetricsAU(	HDC hdc,			// handle of device context 
								LPTEXTMETRICW lptm 	// address of text metrics structure 
							)
{
	if ( ISNT() )
	{
		return GetTextMetricsW( hdc, lptm );	
	}
	
	BOOL		 fRetVal	= FALSE;
	TEXTMETRICA	 tmA;

	//Call the ansi version
	if (fRetVal = GetTextMetricsA(hdc, &tmA))
	{

		//Convert the structure
		lptm->tmHeight			 = tmA.tmHeight;
		lptm->tmAscent			 = tmA.tmAscent;
		lptm->tmDescent			 = tmA.tmDescent;
		lptm->tmInternalLeading  = tmA.tmInternalLeading;
		lptm->tmExternalLeading  = tmA.tmExternalLeading;
		lptm->tmAveCharWidth	 = tmA.tmAveCharWidth;
		lptm->tmMaxCharWidth	 = tmA.tmMaxCharWidth;
		lptm->tmWeight			 = tmA.tmWeight;
		lptm->tmOverhang		 = tmA.tmOverhang;
		lptm->tmDigitizedAspectX = tmA.tmDigitizedAspectX;
		lptm->tmDigitizedAspectY = tmA.tmDigitizedAspectY;
		
		//Convert the bytes to unicode
		MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(tmA.tmFirstChar), 1,   &(lptm->tmFirstChar),   1);
		MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(tmA.tmLastChar), 1,    &(lptm->tmLastChar),    1);
		MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(tmA.tmDefaultChar), 1, &(lptm->tmDefaultChar), 1);
		MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(tmA.tmBreakChar), 1,   &(lptm->tmBreakChar),   1);

		lptm->tmItalic		   = tmA.tmItalic;
		lptm->tmUnderlined	   = tmA.tmUnderlined;
		lptm->tmStruckOut	   = tmA.tmStruckOut;
		lptm->tmPitchAndFamily = tmA.tmPitchAndFamily;
		lptm->tmCharSet		   = tmA.tmCharSet;
	}							

	return fRetVal;
}

/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CreateFontAU
//
//  PURPOSE:  Wrapper over CreateFontA that mimics CreateFontW
//
//  NOTES:    SEE Win32 CreateFont for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

HFONT WINAPI CreateFontAU (	int		nHeight,		// logical height of font 
							int		nWidth,			// logical average character width 
							int		nEscapement,	// angle of escapement 
							int		nOrientation,	// base-line orientation angle 
							int		fnWeight,		// font weight 
							DWORD	fdwItalic,		// italic attribute flag 
							DWORD	fdwUnderline,	// underline attribute flag 
							DWORD	fdwStrikeOut,	// strikeout attribute flag 
							DWORD	fdwCharSet,		// character set identifier 
							DWORD	fdwOutputPrecision,	// output precision 
							DWORD	fdwClipPrecision,	// clipping precision 
							DWORD	fdwQuality,			// output quality 
							DWORD	fdwPitchAndFamily,	// pitch and family 
							LPCWSTR	lpszFace 			// pointer to typeface name string 
						   )
{

	if ( ISNT() )
	{
		return CreateFontW( nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet,
						    fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace );
	}

	USES_CONVERSION;
	
	LPSTR   lpszFaceA = NULL;

	//Convert face to ansi
	if ( !RW2A( lpszFaceA, lpszFace ) )
	{
		_ASSERT( FALSE );
		return NULL;
	}

	//Call and return the ansi function
	return CreateFontA( nHeight,	// logical height of font 
						nWidth,	// logical average character width 
						nEscapement,	// angle of escapement 
						nOrientation,	// base-line orientation angle 
						fnWeight,	// font weight 
						fdwItalic,	// italic attribute flag 
						fdwUnderline,	// underline attribute flag 
						fdwStrikeOut,	// strikeout attribute flag 
						fdwCharSet,	// character set identifier 
						fdwOutputPrecision,	// output precision 
						fdwClipPrecision,	// clipping precision 
						fdwQuality,	// output quality 
						fdwPitchAndFamily,	// pitch and family 
						lpszFaceA 	// pointer to typeface name string 
					  );

}


/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CreateFontIndirectAU 
//
//  PURPOSE:  Wrapper over CreateFontIndirectA that mimics CreateFontIndirectW
//
//  NOTES:    SEE Win32 CreateFontIndirect for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

HFONT WINAPI CreateFontIndirectAU(CONST LOGFONTW *lpLfw)
{

	if ( ISNT() )
	{
		return CreateFontIndirectW( lpLfw );
	}

    LOGFONTA lfa ;	//Ansi font structure

	//Copy the structure
    if(!CopyLfwToLfa((LPLOGFONTW) lpLfw, &lfa)) 
	{
		_ASSERT( FALSE );
        return NULL ;
    }

	//Call the ansi ver and return the code
    return CreateFontIndirectA(&lfa) ;
}


/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: EnumFontFamProcWrapperAU 
//
//  PURPOSE:  Wrapper over the Callback function that is passed to EnumFontFamilies, need to
//            convert the data to Unicode before passing it to the given callback function
//
//  NOTES:    
// 
//////////////////////////////////////////////////////////////////////////////////

int CALLBACK EnumFontFamProcWrapperAU( const LOGFONTA		*lpelf,     // logical-font data
									   const TEXTMETRICA    *lpData,	// physical-font data
									   DWORD   				FontType,  // type of font
									   LPARAM				lParam     // application-defined data
									 )
{

		LOGFONTW				lfw;				
		LPENUMFONTFAMPROCDATA	lpEnumData = (LPENUMFONTFAMPROCDATA) lParam; //Get the enum struct
		
		//Convert the logfont structure		
	    if( !CopyLfaToLfw( (LPLOGFONTA) lpelf, &lfw ) ) 
		{
			_ASSERT( FALSE );	
			return 1;   //Continue Enumeration?
		}

		if ( FontType & TRUETYPE_FONTTYPE )
		{
		
			TEXTMETRICW				  tmW;
			LPTEXTMETRICA             lptmA = (LPTEXTMETRICA)lpData;

			//Convert the structure
			tmW.tmHeight			 = lptmA->tmHeight;
			tmW.tmAscent			 = lptmA->tmAscent;
			tmW.tmDescent			 = lptmA->tmDescent;
			tmW.tmInternalLeading    = lptmA->tmInternalLeading;
			tmW.tmExternalLeading    = lptmA->tmExternalLeading;
			tmW.tmAveCharWidth		 = lptmA->tmAveCharWidth;
			tmW.tmMaxCharWidth		 = lptmA->tmMaxCharWidth;
			tmW.tmWeight			 = lptmA->tmWeight;
			tmW.tmOverhang			 = lptmA->tmOverhang;
			tmW.tmDigitizedAspectX	 = lptmA->tmDigitizedAspectX;
			tmW.tmDigitizedAspectY	 = lptmA->tmDigitizedAspectY;
		
			//Convert the bytes to unicode
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(lptmA->tmFirstChar), 1, &(tmW.tmFirstChar), 1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(lptmA->tmLastChar), 1, &(tmW.tmLastChar), 1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(lptmA->tmDefaultChar), 1, &(tmW.tmDefaultChar), 1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(lptmA->tmBreakChar), 1, &(tmW.tmBreakChar), 1);

			tmW.tmItalic		   = lptmA->tmItalic;
			tmW.tmUnderlined	   = lptmA->tmUnderlined;
			tmW.tmStruckOut		   = lptmA->tmStruckOut;
			tmW.tmPitchAndFamily   = lptmA->tmPitchAndFamily;
			tmW.tmCharSet		   = lptmA->tmCharSet;

			//Call the Unicode callback function
			return lpEnumData->lpEnumFontFamProc( &lfw, &tmW, FontType, lpEnumData->lParam );
		}
		else
		{

			NEWTEXTMETRICW				 ntmW;
			LPNEWTEXTMETRICA             nlptmA = (LPNEWTEXTMETRICA)lpData;
	
			//Convert the newtext metrix structure
			ntmW.tmHeight			 = nlptmA->tmHeight;
			ntmW.tmAscent			 = nlptmA->tmAscent;
			ntmW.tmDescent			 = nlptmA->tmDescent;
			ntmW.tmInternalLeading   = nlptmA->tmInternalLeading;
			ntmW.tmExternalLeading   = nlptmA->tmExternalLeading;
			ntmW.tmAveCharWidth		 = nlptmA->tmAveCharWidth;
			ntmW.tmMaxCharWidth		 = nlptmA->tmMaxCharWidth;
			ntmW.tmWeight			 = nlptmA->tmWeight;
			ntmW.tmOverhang			 = nlptmA->tmOverhang;
			ntmW.tmDigitizedAspectX	 = nlptmA->tmDigitizedAspectX;
			ntmW.tmDigitizedAspectY	 = nlptmA->tmDigitizedAspectY;
		
			//Convert the bytes to unicode
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(nlptmA->tmFirstChar),   1, &(ntmW.tmFirstChar),   1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(nlptmA->tmLastChar),    1, &(ntmW.tmLastChar),    1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(nlptmA->tmDefaultChar), 1, &(ntmW.tmDefaultChar), 1);
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&(nlptmA->tmBreakChar),   1, &(ntmW.tmBreakChar),   1);

			ntmW.tmItalic		   = nlptmA->tmItalic;
			ntmW.tmUnderlined	   = nlptmA->tmUnderlined;
			ntmW.tmStruckOut	   = nlptmA->tmStruckOut;
			ntmW.tmPitchAndFamily  = nlptmA->tmPitchAndFamily;
			ntmW.tmCharSet		   = nlptmA->tmCharSet;

			ntmW.ntmFlags		   = nlptmA->ntmFlags; 
			ntmW.ntmSizeEM         = nlptmA->ntmSizeEM; 
			ntmW.ntmCellHeight     = nlptmA->ntmCellHeight; 
			ntmW.ntmAvgWidth       = nlptmA->ntmAvgWidth; 

			//Call the Unicode callback function 
			return lpEnumData->lpEnumFontFamProc( &lfw,(LPTEXTMETRICW) &ntmW, FontType, lpEnumData->lParam );
		}
		
		return 1;
}

/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: EnumFontFamiliesAU 
//
//  PURPOSE:  Wrapper over EnumFontFamiliesA that mimics EnumFontFamiliesW
//
//  NOTES:    SEE Win32 EnumFontFamilies for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

int WINAPI EnumFontFamiliesAU( HDC			  hdc,               // handle to DC
							   LPCWSTR		  lpszFamily,        // font family
							   FONTENUMPROCW  lpEnumFontFamProc, // callback function
							   LPARAM		  lParam             // additional data
							 )
{

	if ( ISNT() )
	{
		return EnumFontFamiliesW( hdc, lpszFamily, lpEnumFontFamProc, lParam );
	}


	USES_CONVERSION;

	LPSTR					lpszFamilyA = NULL;
	ENUMFONTFAMPROCDATA		effpd;

	//Convert the family name if nessesary
	if ( !RW2A(lpszFamilyA, lpszFamily) )
		return 0;
	
	//Init the structure to pass to the wrapper callback function
	effpd.lpEnumFontFamProc = (USEFONTENUMPROCW)lpEnumFontFamProc;
	effpd.lParam            = lParam;

	return EnumFontFamiliesA( hdc, lpszFamilyA, (FARPROC)EnumFontFamProcWrapperAU, (LPARAM) &effpd);

}

///////////////////////////////
//
//  
//   WINMM.DLL
//
//
///////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: BOOL WINAPI PlaySoundAU (LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
//
// PURPOSE:  Wrapper over PlaySoundA that mimics PlaySoundW
//
// NOTES:    SEE Win32 PlaySound for functionality
//
//////////////////////////////////////////////////////////////////////////////


BOOL WINAPI PlaySoundAU( LPCWSTR pszSound, 
					       HMODULE hmod, 
					       DWORD   fdwSound
				         )
{

	if ( ISNT() )
	{
		return PlaySoundW( pszSound, hmod, fdwSound );	
	}

	USES_CONVERSION;

	//Convert to asni
	LPSTR  pszSoundA = NULL;
	
	
	if ( pszSound != NULL && (fdwSound & SND_FILENAME || fdwSound & SND_ALIAS ) )
	{
		
		pszSoundA = W2A( pszSound ); //Convert the string

		//Make sure the conversion was successful
		if ( pszSoundA == NULL )
			return FALSE;

	}
	else
	{
		pszSoundA = (LPSTR) pszSound;
	}

	//Call and return the ansi version
	return PlaySoundA( pszSoundA, hmod, fdwSound );
}


////////////////////////////////
//
//
// SHELL32.DLL
//
//
////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: HINSTANCE APIENTRY ShellExecuteAU( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
//
// PURPOSE: Wrapper over ShellExecuteA that mimics ShellExecuteW
//
// NOTES: See Win32 ShellExecute for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

HINSTANCE WINAPI ShellExecuteAU(   HWND	   hwnd, 
								   LPCWSTR lpOperation, 
								   LPCWSTR lpFile, 
								   LPCWSTR lpParameters, 
								   LPCWSTR lpDirectory, 
								   INT	   nShowCmd
								 )
{

	if ( ISNT() )
	{
		return ShellExecuteW( hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd );
	}

	USES_CONVERSION;

	LPCSTR lpOperationA		= NULL;
	LPCSTR lpFileA			= NULL;
	LPCSTR lpParametersA	= NULL;
	LPCSTR lpDirectoryA	    = NULL;

	//Convert any input vars to ansi
	if ( !RW2A(lpOperationA, lpOperation) || !RW2A(lpFileA, lpFile) || !RW2A(lpParametersA, lpParameters) || !RW2A(lpDirectoryA, lpDirectory) )
		return FALSE;

	//Call and return the Ansi version
	return ShellExecuteA( hwnd, lpOperationA, lpFileA, lpParametersA, lpDirectoryA, nShowCmd );
}


//////////////////////////////////
//
//
// COMDLG32.DLL
//
//
//////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: BOOL APIENTRY ChooseFontAU( LPCHOOSEFONTW lpChooseFontW )
//
// PURPOSE: Wrapper over ChooseFontA that mimics ChooseFontW
//
// NOTES: See Win32 ChooseFont for Functionality
//		  Test for returning style name... not yet added
//
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseFontAU( LPCHOOSEFONTW lpChooseFontW )
{

	if ( ISNT() )
	{
		return ChooseFontW( lpChooseFontW );
	}

	USES_CONVERSION;
	
	CHOOSEFONTA     cfa;  //Ansi ChooseFont Structure
	LOGFONTA        lfa;  //Ansi LogFont Structure
	
	//Convert ChooseFont Structure
	cfa.lStructSize    = sizeof(CHOOSEFONTA);
	cfa.hwndOwner      = lpChooseFontW->hwndOwner;
	cfa.hDC            = lpChooseFontW->hDC;
	cfa.lpLogFont      = &lfa; 
	cfa.iPointSize     = lpChooseFontW->iPointSize;
	cfa.Flags          = lpChooseFontW->Flags;
	cfa.rgbColors      = lpChooseFontW->rgbColors;
	cfa.lCustData      = lpChooseFontW->lCustData;
	cfa.lpfnHook       = lpChooseFontW->lpfnHook;
	cfa.hInstance      = lpChooseFontW->hInstance;
	cfa.nFontType      = lpChooseFontW->nFontType;
	cfa.nSizeMax       = lpChooseFontW->nSizeMax;
	cfa.nSizeMin       = lpChooseFontW->nSizeMin;


	//Convert the Template if it is given
	if ( cfa.Flags & CF_ENABLETEMPLATE )
	{
		if ( ISATOM( CF_ENABLETEMPLATE ) )
		{
			cfa.lpTemplateName = ( LPSTR ) lpChooseFontW->lpTemplateName;
		}
		else if ( !RW2A(cfa.lpTemplateName, lpChooseFontW->lpTemplateName ) )
		{
			return FALSE;
		}
	}

	//Conver the style
	if ( (cfa.Flags & CF_USESTYLE) && (!RW2A(cfa.lpszStyle, lpChooseFontW->lpszStyle)) ) 
	{
		return FALSE;
	}

	//Copy the LogFont structure
    if(	!CopyLfwToLfa( lpChooseFontW->lpLogFont , cfa.lpLogFont) ) 
	{
        return FALSE ;
    }

	//Call the Ansi ChooseFont
	if ( !ChooseFontA( &cfa ) )
	{
		return FALSE;
	}

	//Need to Copy the Font information back into the CHOOSEFONTW structure	
	lpChooseFontW->iPointSize = cfa.iPointSize;
	lpChooseFontW->Flags	  = cfa.Flags;
	lpChooseFontW->rgbColors  = cfa.rgbColors;
	lpChooseFontW->nFontType  = cfa.nFontType;

    // We have to copy the infomation in cfa back into lpCfw because it
    // will be used in calls to CreateFont hereafter
    return CopyLfaToLfw(cfa.lpLogFont, lpChooseFontW->lpLogFont) ;

}



//////////////////////////////////////
//
//
// KERNEL32.DLL
//
//
//////////////////////////////////////
DWORD WINAPI GetPrivateProfileStringAU(	LPCWSTR lpAppName,        // points to section name
								LPCWSTR lpKeyName,        // points to key name
								LPCWSTR lpDefault,        // points to default string
								LPWSTR lpReturnedString,  // points to destination buffer
								DWORD nSize,              // size of destination buffer
								LPCWSTR lpFileName        // points to initialization filename
							 )
{
	if ( ISNT() )
	{
		return GetPrivateProfileStringW( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName );
	}
	

	USES_CONVERSION;

	LPSTR lpAppNameA = NULL;
	LPSTR lpKeyNameA = NULL;
	LPSTR lpDefaultA = NULL;
	LPSTR lpFileNameA = NULL;
	LPSTR lpReturnedStringA = (LPSTR)alloca( BUFSIZE( nSize ) );

	if ( lpReturnedStringA == NULL || !RW2A(lpAppNameA, lpAppName) || !RW2A(lpKeyNameA, lpKeyName )
		||  !RW2A(lpDefaultA, lpDefault) || !RW2A( lpFileNameA, lpFileName) ) 
	{
		_ASSERT( FALSE );
		return 0;
	}

	DWORD dwRet = GetPrivateProfileStringA( lpAppNameA, lpKeyNameA, lpDefaultA, lpReturnedStringA, BUFSIZE(nSize), lpFileNameA );

	if (dwRet)
	{
		dwRet = StandardAtoU( lpReturnedStringA, nSize, lpReturnedString );
	}
	

	return dwRet;
}


DWORD WINAPI GetProfileStringAU( LPCWSTR lpAppName,        // address of section name
							     LPCWSTR lpKeyName,        // address of key name
							     LPCWSTR lpDefault,        // address of default string
							     LPWSTR  lpReturnedString,  // address of destination buffer
							     DWORD   nSize               // size of destination buffer
							   )
{
	
	if ( ISNT() )
	{
		return GetProfileStringW( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize );
	}


	USES_CONVERSION;

	LPSTR lpAppNameA = NULL;
	LPSTR lpKeyNameA = NULL;
	LPSTR lpDefaultA = NULL;
	LPSTR lpReturnedStringA = (LPSTR)alloca( BUFSIZE( nSize ) );

	if ( lpReturnedStringA == NULL || !RW2A(lpAppNameA, lpAppName) || !RW2A(lpKeyNameA, lpKeyName) || !RW2A(lpDefaultA, lpDefault) )
	{
		_ASSERT( FALSE );
		return 0;
	}

	//Call the ansi version
	DWORD dwRet = GetProfileStringA( lpAppNameA, lpKeyNameA, lpDefaultA, lpReturnedStringA, BUFSIZE(nSize) );

	//Convert the returned string to Unicode
	if ( dwRet )
	{
		dwRet = StandardAtoU( lpReturnedStringA, nSize, lpReturnedString );
	}

	return dwRet;
}

HANDLE WINAPI CreateFileMappingAU(	HANDLE				  hFile,				   // handle to file to map
									LPSECURITY_ATTRIBUTES lpFileMappingAttributes, // optional security attributes
									DWORD				  flProtect,			   // protection for mapping object
									DWORD				  dwMaximumSizeHigh,       // high-order 32 bits of object size
									DWORD				  dwMaximumSizeLow,		   // low-order 32 bits of object size
									LPCWSTR				  lpName             // name of file-mapping object
								)
{
	if ( ISNT() )
	{
		return CreateFileMappingW( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName );
	}


	USES_CONVERSION;

	LPSTR lpNameA = NULL;

	//Convert the name to ansi
	if (!RW2A( lpNameA, lpName ) )
	{
		_ASSERT( FALSE );
		return NULL;
	}

	//Call and return the ansi version	
	return CreateFileMappingA( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpNameA );
}


HANDLE WINAPI FindFirstChangeNotificationAU(	LPCWSTR lpPathName,    // pointer to name of directory to watch
												BOOL	bWatchSubtree, // flag for monitoring directory or 
																	   // directory tree
												DWORD	dwNotifyFilter // filter conditions to watch for
											)
{
	if ( ISNT() )
	{
		return FindFirstChangeNotificationW( lpPathName, bWatchSubtree, dwNotifyFilter );
	}


	USES_CONVERSION;
	
	LPSTR lpPathNameA = NULL;

	//Convert path to ansi
	if (!RW2A( lpPathNameA, lpPathName ) || !lpPathNameA)
	{
        SetLastError(ERROR_OUTOFMEMORY);
		return INVALID_HANDLE_VALUE;
	}

	//Call and return the ansi version
	return FindFirstChangeNotificationA( lpPathNameA, bWatchSubtree, dwNotifyFilter );
}



////////////////////////////////////////////
// lstring functions
//
// One should really just call the wc.. verions in the first place....
//
////////////////////////////////////////////


int WINAPI lstrcmpAU(	LPCWSTR lpString1,  // pointer to first string
		 				LPCWSTR lpString2   // pointer to second string
					)
{
	if ( ISNT() )
	{
		return lstrcmpW( lpString1, lpString2 );
	}


	return wcscmp( lpString1, lpString2 );
}

LPWSTR WINAPI lstrcatAU(	LPWSTR lpString1,  // pointer to buffer for concatenated strings
							LPCWSTR lpString2  // pointer to string to add to string1
					   )
{
	if ( ISNT() )
	{
		return lstrcatW( lpString1, lpString2 );
	}

	return wcscat(lpString1, lpString2 );
}


LPWSTR WINAPI lstrcpyAU(	LPWSTR  lpString1,  // pointer to buffer
							LPCWSTR lpString2  // pointer to string to copy
					   )
{
	if ( ISNT() )
	{
		return lstrcpyW( lpString1, lpString2 );
	}

	return wcscpy( lpString1, lpString2 );
}


LPWSTR WINAPI lstrcpynAU(	LPWSTR  lpString1,  // pointer to target buffer
							LPCWSTR lpString2, // pointer to source string
							int		iMaxLength     // number of bytes or characters to copy
						)
{
	if ( ISNT() )
	{
		return lstrcpynW( lpString1, lpString2, iMaxLength );
	}
	
	iMaxLength--;

	for ( int iCount = 0; iCount < iMaxLength && lpString2[iCount] != L'\0'; iCount++ )
		lpString1[ iCount ] = lpString2[ iCount ];

	lpString1[iCount] = L'\0';

	return lpString1;
}


int WINAPI lstrlenAU(	LPCWSTR lpString   // pointer to string to count
					)
{
	if ( ISNT() )
	{
		return lstrlenW( lpString );
	}
	return wcslen( lpString );
}

int WINAPI lstrcmpiAU(	LPCWSTR lpString1,  // pointer to first string
						LPCWSTR lpString2   // pointer to second string
					 )
{
	if ( ISNT() )
	{
		return lstrcmpiW( lpString1, lpString2 );
	}

	return _wcsicmp( lpString1, lpString2 );
}


int WINAPI	wvsprintfAU(	LPWSTR  lpOut,    // pointer to buffer for output
							LPCWSTR lpFmt,   // pointer to format-control string
							va_list arglist  // optional arguments
					  )
{
	if ( ISNT() )
	{
		return wvsprintfW( lpOut, lpFmt, arglist );
	}

	if ( lpFmt == NULL )
	{
		//NULL format string passed in.
		_ASSERT( FALSE );
		return 0;
	}


	USES_CONVERSION;
	
	LPSTR	lpOutA	  = (LPSTR) alloca( WPRINTF_CHARS );	
	LPWSTR  lpNFmtW	  = (LPWSTR) alloca( ( wcslen(lpFmt) + 1 )*sizeof(WCHAR) );	
	LPSTR	lpFmtA	  = NULL;

	//Make sure allocation and conversion went ok
	if ( lpOutA == NULL || lpNFmtW == NULL )
		return 0;

	LPWSTR lpPos = lpNFmtW;
	//Walk along the Unicode Version, need to find any %s or %c calls and change them to %ls and %lc
		for (DWORD x = 0; x <= wcslen(lpFmt) ; x++)
		{
			//Test if we have a var
			if ( lpFmt[x] == L'%' )
			{
				*lpPos = lpFmt[x]; lpPos++;	//Add the percent sign
				//Walk the format portion to find ls or lc sits to change
				for(x++;x <= wcslen(lpFmt);x++)
				{					
					if ( ISFMREGTYPE( lpFmt[x] ) )
					{
							*lpPos = lpFmt[x];lpPos++;
							break;
					}
					else if ( ISFMSORC( lpFmt[x] ) )
					{
							*lpPos = L'l'; //Insert the l and the c or s..
							lpPos++;
							*lpPos = lpFmt[x];
							lpPos++;
							break;
					}
					else
					{
							*lpPos = lpFmt[x];
							lpPos++;
					} //end if 
				}//end for
			}
			else
			{
				*lpPos = lpFmt[x];
				lpPos++;
			}//end if
		}//end for
			
	
	//Now Convert to Ansi and call ansi ver
	if (!RW2A(lpFmtA, lpNFmtW))
		return 0;

	wvsprintfA( lpOutA, lpFmtA, arglist );

	return StandardAtoU( lpOutA, lstrlenA( lpOutA )+1, lpOut );
}

/////////////////////////////////////////////////////////////////////////////////
//
// int WINAPI	wsprintfAU(	LPWSTR lpOut,    // pointer to buffer for output
//							LPCWSTR lpFmt,   // pointer to format-control string
//							...              // optional arguments
//						  )
//
//  PURPOSE:  Wrapper over wsprintfA that mimics wsprintfW
//
//  NOTES:    SEE Win32 wsprintfA for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

int WINAPI	wsprintfAU(	LPWSTR lpOut,    // pointer to buffer for output
						LPCWSTR lpFmt,   // pointer to format-control string
						...              // optional arguments
					  )
{
	va_list marker;
	va_start( marker, lpFmt );

	if ( ISNT() )
	{
		return wvsprintfW( lpOut, lpFmt, marker );
	}

	if ( lpFmt == NULL )
	{
		// Error, NULL format string passed in.
		_ASSERT( false );
		return 0;
	}

	USES_CONVERSION;
	
	LPSTR	lpOutA	  = (LPSTR) alloca( WPRINTF_CHARS );	
	LPWSTR  lpNFmtW	  = (LPWSTR) alloca( ( wcslen(lpFmt) + 1 )*sizeof(WCHAR) );	
	LPSTR	lpFmtA	  = NULL;//(LPSTR) W2A( lpFmt );

	//Make sure allocation and conversion went ok
	if ( lpOutA == NULL || lpNFmtW == NULL )
		return 0;

	LPWSTR lpPos = lpNFmtW;
	//Walk along the Unicode Version, need to find any %s or %c calls and change them to %ls and %lc
		for (DWORD x = 0; x <= wcslen(lpFmt) ; x++)
		{
			//Test if we have a var
			if ( lpFmt[x] == L'%' )
			{
				*lpPos = lpFmt[x]; lpPos++;	//Add the percent sign
				//Walk the format portion to find ls or lc sits to change
				for(x++;x <= wcslen(lpFmt);x++)
				{					
					if ( ISFMREGTYPE( lpFmt[x] ) )
					{
							*lpPos = lpFmt[x];lpPos++;
							break;
					}
					else if ( ISFMSORC( lpFmt[x] ) )
					{
							*lpPos = L'l'; //Insert the l and the c or s..
							lpPos++;
							*lpPos = lpFmt[x];
							lpPos++;
							break;
					}
					else
					{
							*lpPos = lpFmt[x];
							lpPos++;
					} //end if 
				}//end for
			}
			else
			{
				*lpPos = lpFmt[x];
				lpPos++;
			}//end if
		}//end for
			
	
	//Now Convert to Ansi and call ansi ver
	if (!RW2A(lpFmtA, lpNFmtW))
		return 0;

	/*va_start( marker, lpFmt );*/
	wvsprintfA( lpOutA, lpFmtA, marker );

	return StandardAtoU( lpOutA, lstrlenA( lpOutA )+1, lpOut );
}


/////////////////////////////////////////////////////////////////////////////////
//
// DWORD FormatMessageAU(	DWORD	 dwFlags,      // source and processing options
//							LPCVOID  lpSource,   // pointer to  message source
//							DWORD	 dwMessageId,  // requested message identifier
//							DWORD	 dwLanguageId, // language identifier for requested message
//							LPWSTR	 lpBuffer,    // pointer to message buffer
//							DWORD	 nSize,        // maximum size of message buffer
//							va_list *Arguments  // pointer to array of message inserts
//						)
//
//  PURPOSE:  Wrapper over FormatMessageA that mimics FormatMessageW
//
//  NOTES:    SEE Win32 FormatMessage for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI FormatMessageAU(	DWORD	 dwFlags,      // source and processing options
						LPCVOID  lpSource,   // pointer to  message source
						DWORD	 dwMessageId,  // requested message identifier
						DWORD	 dwLanguageId, // language identifier for requested message
						LPWSTR	 lpBuffer,    // pointer to message buffer
						DWORD	 nSize,        // maximum size of message buffer
						va_list *Arguments  // pointer to array of message inserts
					)
{
	
	if ( ISNT() )
	{
		return FormatMessageW( dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments );
	}


	USES_CONVERSION;

	LPWSTR lpSourceW = NULL;	
	LPWSTR lpPos     = NULL;
	LPSTR  lpSourceA = NULL;
	LPSTR  lpBufferA = NULL;
	DWORD  nSizeA    = 0;
	DWORD  dwRet     = 0;

	if ( dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER )
	{
		FLAGOFF( dwFlags, FORMAT_MESSAGE_ALLOCATE_BUFFER );
		lpBufferA = (LPSTR) alloca( MAX_FORMAT_MESSAGE_SIZE );
		nSizeA	  = MAX_FORMAT_MESSAGE_SIZE;
	}
	else //Given Max size for buffer
	{
		lpBufferA = (LPSTR) alloca( BUFSIZE( nSize ) );
		nSizeA    = BUFSIZE( nSize );
	}
	
	//Make sure the buffer was allocated correctly
	_ASSERT( lpBufferA != NULL && nSize > 0);
	if ( lpBufferA == NULL )
		return 0;

	if ( dwFlags & FORMAT_MESSAGE_FROM_STRING )
	{
		//Allocate a little extra room to hold any needed extra characters.. l's added
		//lpNSource = (LPWSTR) alloca( BUFSIZE(wcslen(lpSource)) + FORMAT_MESSAGE_EXTRA );
		lpSourceW = (LPWSTR)lpSource;
	}
	else if ( dwFlags & FORMAT_MESSAGE_FROM_HMODULE || dwFlags && FORMAT_MESSAGE_FROM_SYSTEM)
	{	
		//Call format message in ansi with the FORMAT_MESSAGE_IGNORE_INSERTS flag so we have a chance
		//to alter the string		
		DWORD dwRet = FormatMessageA( dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS, (LPSTR)lpSource, dwMessageId, dwLanguageId, lpBufferA, nSizeA, 0);

		_ASSERT( dwRet != 0 );
		if ( dwRet == 0 )
			return 0;
		
		// If we're going to have to alter the string then convert the ansi buffer to Wide
		if ( !(dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) && (Arguments!=NULL) )
		{
			//Convert the string to Wide characters
			lpSourceW = A2W( lpBufferA );

			//Make sure string converted correctly
			_ASSERT( lpSourceW != NULL );
			if ( lpSourceW == NULL )
				return 0;
		}
	}
	else
	{	
		//Prefix detected error, if the two above if's fail, lpSourceW is not allocated.
		return 0;
	}
	
	//Check if we have to alter the string
	if ( !(dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) && (Arguments!=NULL) )
	{

		//Allocate the new wide buffer
		LPWSTR lpNSource = (LPWSTR) alloca( BUFSIZE(wcslen(lpSourceW)) + FORMAT_MESSAGE_EXTRA );
		_ASSERT( lpNSource != NULL );

		if (lpNSource == NULL)
			return 0;

		//If we are not asked to ignore the message inserts then change up the
		//%n!printf crap]s! and %n!printf crap]c! to force them to be treated as unicode
		LPWSTR lpPos = lpNSource;
		
		//Walk along the Unicode Version, need to find any %n!printf crap]s! and %n!printf crap]c! calls and change them to %n!printf crap]ls! and %n!printf crap]lc!
		for (DWORD x = 0; x <= wcslen(lpSourceW) ; x++)
		{

			//Try and make sure we don't go out of range
			_ASSERT( (DWORD)lpPos - (DWORD)lpNSource < (DWORD)(BUFSIZE(wcslen(lpSourceW)) + FORMAT_MESSAGE_EXTRA) );

			//Test if we have a var
			if ( lpSourceW[x] == L'%')
			{
				
				*lpPos = lpSourceW[x]; lpPos++;	//Add the percent sign

				//Test if its of %n type
				if ( ISNUM( lpSourceW[x+1] ) && lpSourceW[x+1] != L'0' )
				{
					//Add the number that should come after the percent sign
					for(x++; x <= wcslen(lpSourceW) && ISNUM( lpSourceW[x] );x++)
					{
						*lpPos = lpSourceW[x];lpPos++;
					}
					
					//Printf format given, run though change !c! and !s! to !lc! and !ls!
					if ( lpSourceW[x] == L'!' )
					{

						*lpPos = lpSourceW[x];lpPos++;//And the exclamation point

						//Add any characters that are used to format the output
						for(x++; x <= wcslen(lpSourceW) && ISFORMATOUTPUTTYPE( lpSourceW[x] ) ;x++)
						{
							*lpPos = lpSourceW[x];lpPos++;
						}

						//Walk the format portion to find ls or lc sits to change
						for(;x <= wcslen(lpSourceW);x++)
						{					
							if ( ISFMREGTYPE( lpSourceW[x] ) )
							{	
								*lpPos = lpSourceW[x];lpPos++;
								break;
							}
							else if ( ISFMSORC(lpSourceW[x]) )
							{
								*lpPos = L'l';
								lpPos++;
								*lpPos = lpSourceW[x];
								lpPos++;
								break;
							}
							else
							{
								//Unknown type found
								_ASSERT(!"Unknown Type in Format Message");

								//Just add the character and hope its just a unknown output format char
								*lpPos = lpSourceW[x];
								lpPos++;
							} //end if
							
						}//end for
					}
					else
					{
						//they didn't put a printf format spec default to string add fmt to force unicode
						*lpPos = L'!';lpPos++;
						*lpPos = L'l';lpPos++;
						*lpPos = L's';lpPos++;
						*lpPos = L'!';lpPos++;	
						x--;
					}
				}
			}
			else
			{
				*lpPos = lpSourceW[x];
				lpPos++;
			}//end if
		}//end for

		//Now call convert the string to Ansi and call format message with the new string
		if ( !RW2A(lpSourceA, lpNSource) )
		{
			_ASSERT( FALSE );
			return 0;
		}

		//Turn off unneeded flags
		FLAGOFF( dwFlags, FORMAT_MESSAGE_FROM_HMODULE );
		FLAGOFF( dwFlags, FORMAT_MESSAGE_FROM_SYSTEM  );
		
		//Formating the generated string
		FLAGON( dwFlags, FORMAT_MESSAGE_FROM_STRING );

		dwRet = FormatMessageA( dwFlags, lpSourceA, 0, dwLanguageId, lpBufferA, nSizeA, Arguments );

		_ASSERT( dwRet != 0 );
		if (dwRet == 0 )
			return 0;
	}

	if ( dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER )
	{

		//Allocate the buffer off the heap
		lpBuffer  = (LPWSTR)LocalAlloc( LPTR, BUFSIZE( dwRet ) );		
		nSize	  = dwRet;

		_ASSERT( lpBuffer != NULL );
		if ( lpBuffer == NULL )
			return 0;
	}

	_ASSERT( dwRet != 0 );

	//Convert the string to WideChars
	dwRet = StandardAtoU(lpBufferA, nSize, lpBuffer );

	//Free the lpBufferW buffer if the conversion failed
	if ( dwRet == 0 && dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER )
		LocalFree( lpBuffer );

	return dwRet;
	
}

/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetStringTypeExAU 
//
//  PURPOSE:  Wrapper over GetStringTypeExA that mimics GetStringTypeExW
//
//  NOTES:    SEE Win32 GetStringTypeEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeExAU(	LCID	Locale,      // locale identifer
								DWORD	dwInfoType,  // information-type options
								LPCWSTR lpSrcStr,	 // pointer to source string
								int		cchSrc,      // size, in bytes or characters, of source string
								LPWORD  lpCharType   // pointer to buffer for output
							  )
{

	if ( ISNT() )
	{
		return GetStringTypeExW( Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType );
	}

	USES_CONVERSION;

	LPSTR lpSrcStrA = NULL;
	
	//Convert the source string
	if ( !RW2A(lpSrcStrA, lpSrcStr) || !lpSrcStrA)
    {
        SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
    }

	//Call and return the ansi version
	return GetStringTypeExA( Locale, dwInfoType, lpSrcStrA, lstrlenA(lpSrcStrA), lpCharType );

}

/////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CreateMutexAU 
//
//  PURPOSE:  Wrapper over CreateMutexA that mimics CreateMutexW
//
//  NOTES:    SEE Win32 CreateMutex for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

HANDLE WINAPI CreateMutexAU(	LPSECURITY_ATTRIBUTES lpMutexAttributes,	// pointer to security attributes
								BOOL				  bInitialOwner,		// flag for initial ownership
								LPCWSTR				  lpName				// pointer to mutex-object name
							)
{
	if ( ISNT() )
	{
		return CreateMutexW( lpMutexAttributes, bInitialOwner, lpName );
	}


	USES_CONVERSION;
	
	LPSTR lpNameA = NULL;

	//Convert the name to ansi
	if ( !RW2A(lpNameA, lpName) )
		return NULL;
	
	//Call and return the ansi version
	return CreateMutexA( lpMutexAttributes, bInitialOwner, lpNameA );
	
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetShortPathNameAU 
//
//  PURPOSE:  Wrapper over GetShortPathNameA that mimics GetShortPathNameW
//
//  NOTES:    SEE Win32 GetShortPathName for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI GetShortPathNameAU(	LPCWSTR lpszLongPath,  // pointer to a null-terminated path string
									LPWSTR  lpszShortPath,  // pointer to a buffer to receive the 
														   // null-terminated short form of the path
									DWORD cchBuffer		   // specifies the size of the buffer pointed 
														   // to by lpszShortPath
								)
{
	if ( ISNT() )
	{
		return GetShortPathNameW( lpszLongPath, lpszShortPath, cchBuffer );
	}


	USES_CONVERSION;

	LPSTR lpszLongPathA  = NULL;
	LPSTR lpszShortPathA = (LPSTR) alloca( BUFSIZE( cchBuffer ) );	//Allocate buffer
	
	//Make sure allocated correctly
	if ( lpszShortPathA == NULL || !RW2A(lpszLongPathA, lpszLongPath) )
	{
		return 0;
	}

	_ASSERT( lpszShortPathA != NULL && lpszLongPathA != NULL );

	//Call the ansi version
	DWORD dwRet = GetShortPathNameA( lpszLongPathA, lpszShortPathA, BUFSIZE( cchBuffer ) );

	//Convert back to unicode
	if ( dwRet && !StandardAtoU(lpszShortPathA, cchBuffer, lpszShortPath) )
	{
		return 0;
	}

	return dwRet;
}



//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: HANDLE CreateFileAU(	LPCTSTR				  lpFileName,			 // pointer to name of the file
//								DWORD				  dwDesiredAccess,		 // access (read-write) mode
//								DWORD				  dwShareMode,			 // share mode
//								LPSECURITY_ATTRIBUTES lpSecurityAttributes,	 // pointer to security attributes
//								DWORD				  dwCreationDisposition, // how to create
//								DWORD				  dwFlagsAndAttributes,  // file attributes
//								HANDLE				  hTemplateFile          // handle to file with attributes to 
//																			 //  copy
//							  )
//
// PURPOSE: Wrapper over CreateFileA that mimics CreateFileW
//
// NOTES: See Win32 CreateFile for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

HANDLE WINAPI CreateFileAU( LPCWSTR				  lpFileName,			 // pointer to name of the file
							DWORD				  dwDesiredAccess,		 // access (read-write) mode
							DWORD				  dwShareMode,			 // share mode
							LPSECURITY_ATTRIBUTES lpSecurityAttributes,	 // pointer to security attributes
							DWORD				  dwCreationDisposition, // how to create
							DWORD				  dwFlagsAndAttributes,  // file attributes
							HANDLE				  hTemplateFile          // handle to file with attributes to 
																 //  copy
						   )
{
	if ( ISNT() )
	{
		return CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );
	}


	USES_CONVERSION;
	
	//Convert the filename to ansi
	LPCSTR lpFileNameA = W2A( lpFileName );

	//Make sure the string was created correctly
	if ( lpFileNameA == NULL )
		return NULL;

	//Call and return the ansi version
	return CreateFileA( lpFileNameA, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
						dwFlagsAndAttributes, hTemplateFile);


}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: VOID WriteConsoleAU(	HANDLE		hConsoleOutput,			// handle to a console screen buffer
//									CONST VOID *lpBuffer,				// pointer to buffer to write from
//									DWORD		nNumberOfCharsToWrite,	// number of characters to write
//									LPDWORD		lpNumberOfCharsWritten,	// pointer to number of characters written
//									LPVOID		lpReserved				// reserved
//								)
//
// PURPOSE: Wrapper over WriteConsoleA that mimics WriteConsoleW
//
// NOTES: See Win32 WriteConsole for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI	WriteConsoleAU(	HANDLE		hConsoleOutput,			// handle to a console screen buffer
							CONST VOID *lpBuffer,				// pointer to buffer to write from
							DWORD		nNumberOfCharsToWrite,	// number of characters to write
							LPDWORD		lpNumberOfCharsWritten,	// pointer to number of characters written
							LPVOID		lpReserved				// reserved
						   )
{

	if ( ISNT() )
	{
		return WriteConsoleW( hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved );
	}


	LPSTR lpBufferA = (LPSTR)alloca( BUFSIZE(nNumberOfCharsToWrite) ); //Allocate ansi buffer	
	int   iConvert  = 0;

	_ASSERT( lpBufferA != NULL );

	//Make sure the buffer was allocated ok
	if ( lpBufferA == NULL )
	{		
		return FALSE;
	}

	//Convert the string to Ansi need to use SU2A as we may not want the whole string
	if ( !(iConvert = StandardUtoA( (LPWSTR)lpBuffer, BUFSIZE(nNumberOfCharsToWrite), lpBufferA)) )
	{
		_ASSERT( FALSE );
		return FALSE;
	}

	//Call the ansi version
	return WriteConsoleA( hConsoleOutput, lpBufferA, iConvert, lpNumberOfCharsWritten, lpReserved );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: VOID OutputDebugStringAU( LPCWSTR lpOutputString  )
//
// PURPOSE: Wrapper over OutputDebugStringA that mimics OutputDebugStringW
//
// NOTES: See Win32 OutputDebugString for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

VOID WINAPI OutputDebugStringAU( LPCWSTR lpOutputString  )
{
	if ( ISNT() )
	{
		OutputDebugStringW( lpOutputString );
		return;
	}

	USES_CONVERSION;

	//Convert the string to Ansi
	LPCSTR lpOutputStringA = W2A( lpOutputString );
	
	//Make sure conversion succcessful
	if ( lpOutputStringA == NULL )
		return;

	//call the ansi version
	OutputDebugStringA( lpOutputStringA ); 
}


//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: BOOL GetVersionExAU( LPOSVERSIONINFOW lpVersionInformation )
//
// PURPOSE: Wrapper over GetVersionExA that mimics GetVersionExW
//
// NOTES: See Win32 GetVersionEx for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetVersionExAU( LPOSVERSIONINFOW lpVersionInformation
						  )		
{

	if ( ISNT() )
	{
		return GetVersionExW( lpVersionInformation );
	}

	USES_CONVERSION;

	OSVERSIONINFOA osvia;		//Ansi version info struct

	//Set the structure size
	osvia.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	//Call the ansi version
	if ( !GetVersionExA( &osvia ) )
		return FALSE;

	//Copy the structure information
	lpVersionInformation->dwBuildNumber   = osvia.dwBuildNumber;
	lpVersionInformation->dwMajorVersion  = osvia.dwMajorVersion; 
	lpVersionInformation->dwMinorVersion  = osvia.dwMinorVersion;
	lpVersionInformation->dwPlatformId    = osvia.dwPlatformId;

	//Copy the string	
	return StandardAtoU(osvia.szCSDVersion, sizeof(lpVersionInformation->szCSDVersion), lpVersionInformation->szCSDVersion );
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetLocaleInfoAU 
//
//  PURPOSE:  Wrapper over GetLocaleInfoA that mimics GetLocaleInfoW
//
//  Comments: See Win32 GetLocaleInfo for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

INT WINAPI GetLocaleInfoAU(		  LCID   dwLCID, 
								  LCTYPE lcType,
								  LPWSTR lpOutBufferW,
								  INT	 nBufferSize
								) 
{
	
	if ( ISNT() )
	{
		return GetLocaleInfoW( dwLCID, lcType, lpOutBufferW, nBufferSize );
	}

    LPSTR lpBufferA  = (LPSTR)alloca( BUFSIZE(nBufferSize) );  //Allocate ansi buffer on the stack

	//Make sure the memory was allocated correctly
	if ( lpBufferA == NULL && nBufferSize != 0)
	{
		_ASSERT(FALSE);
		return 0;
	}

	//Call the Ansi version
    DWORD nLength = GetLocaleInfoA(dwLCID, lcType, lpBufferA, BUFSIZE(nBufferSize));

    if(0 == nLength) 
	{
        return 0;
    }

	//Convert to Unicode
    return StandardAtoU(lpBufferA, nBufferSize, lpOutBufferW);
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetDateFormat AU 
//
//  PURPOSE:  Wrapper over GetDateFormatA that mimics GetDateFormatW
//
//  Comments: See Win32 GetDateFormat for Functionality
//
///////////////////////////////////////////////////////////////////////////////////
int WINAPI GetDateFormatAU( LCID			  dwLocale,
							DWORD			  dwFlags,
							CONST SYSTEMTIME *lpDate,
							LPCWSTR			  lpFormat,
							LPWSTR			  lpDateStr,
							int				  cchDate
						  )
{

	if ( ISNT() )
	{
		return GetDateFormatW( dwLocale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate );
	}

	USES_CONVERSION;

    LPSTR lpDateStrA = (LPSTR) alloca( BUFSIZE(cchDate) );	//Allocate ansi buffer on the stack
    LPSTR lpFormatA  = NULL;							//Ansi str to hold formate
	
	//Make sure the buffer is allocated correctly
	if ( lpDateStrA == NULL && cchDate != 0 )
		return 0;

	//If format input then convert to ansi
    if ( !RW2A(lpFormatA, lpFormat) )
	{    
        return 0;
    }

	//Call the ansi version
	if(!GetDateFormatA(dwLocale, dwFlags, lpDate, lpFormatA, lpDateStrA, cchDate)) 
	{
       return 0 ;
	}

	//Convert the date back to Unicode
    return StandardAtoU(lpDateStrA, cchDate, lpDateStr) ;  
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: FindFirstFileAU 
//
//  PURPOSE:  Wrapper over FindFirstFileA that mimics FindFirstFileW
//
//  Comments: See Win32 FindFirstFile for Functionality
// 
///////////////////////////////////////////////////////////////////////////////////
HANDLE WINAPI FindFirstFileAU(LPCWSTR lpInFileName, LPWIN32_FIND_DATAW lpFindFileData)
{

	if ( ISNT() )
	{
		return FindFirstFileW( lpInFileName, lpFindFileData );
	}

    WIN32_FIND_DATAA	fda;								//Ansi FindData struct
    CHAR				cInFileNameA[MAX_PATH] = {'\0'} ;	//Ansi string to hold path
    HANDLE				hFindFile ;							//Handle for the file

    // Convert file name from Unicode to ANSI
    if(!StandardUtoA(lpInFileName, MAX_PATH , cInFileNameA) ) 
	{
        return INVALID_HANDLE_VALUE ;
    }

    // Look for file using ANSI interface
    if(INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileA(cInFileNameA, &fda)) ) 
	{
        return INVALID_HANDLE_VALUE ;
    }

    // Copy results into the wide version of the find data struct
    lpFindFileData->dwFileAttributes = fda.dwFileAttributes ;
    lpFindFileData->ftCreationTime   = fda.ftCreationTime   ;
    lpFindFileData->ftLastAccessTime = fda.ftLastAccessTime ;
    lpFindFileData->ftLastWriteTime  = fda.ftLastWriteTime  ;  
    lpFindFileData->nFileSizeHigh    = fda.nFileSizeHigh    ;
    lpFindFileData->nFileSizeLow     = fda.nFileSizeLow     ;

	//Convert the returned strings to Unicode
    if(!StandardAtoU(fda.cFileName, MAX_PATH, lpFindFileData->cFileName) ||
       !StandardAtoU(fda.cAlternateFileName, 14, lpFindFileData->cAlternateFileName) )
    {
    	FindClose( hFindFile );
        return NULL ;
    }

    // Return handle if everything was successful
    return hFindFile ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: FindNextFileAU 
//
//  PURPOSE:  Wrapper over FindNextFileA that mimics FindNextFileW
//
//  Comments: See Win32 FindNextFile for Functionality
// 
///////////////////////////////////////////////////////////////////////////////////
BOOL  WINAPI FindNextFileAU( HANDLE				hFile, 
							 LPWIN32_FIND_DATAW lpFindFileData
						   )
{

	if ( ISNT() )
	{
		return FindNextFileW( hFile, lpFindFileData );
	}


    WIN32_FIND_DATAA fda;					//Ansi FindData struct

    // Look for file using ANSI interface
    if(FALSE == FindNextFileA(hFile, &fda) ) 
	{
        return FALSE ;
    }

    // Copy results into the wide version of the find data struct
    lpFindFileData->dwFileAttributes = fda.dwFileAttributes ;
    lpFindFileData->ftCreationTime   = fda.ftCreationTime   ;
    lpFindFileData->ftLastAccessTime = fda.ftLastAccessTime ;
    lpFindFileData->ftLastWriteTime  = fda.ftLastWriteTime  ;  
    lpFindFileData->nFileSizeHigh    = fda.nFileSizeHigh    ;
    lpFindFileData->nFileSizeLow     = fda.nFileSizeLow     ;

	//Copy the returned strings to unicode
    if(!StandardAtoU(fda.cFileName, MAX_PATH, lpFindFileData->cFileName) ||
       !StandardAtoU(fda.cAlternateFileName, 14, lpFindFileData->cAlternateFileName) )
    {
        return FALSE ;
    }

    return TRUE ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: LoadLibraryEx AU 
//
//  PURPOSE:  Wrapper over LoadLibraryExA that mimics LoadLibraryExW
//
//  Comments: See Win32 LoadLibraryEx for Functionality
// 
///////////////////////////////////////////////////////////////////////////////////

HMODULE WINAPI LoadLibraryExAU(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
	if ( ISNT() )
	{
		return LoadLibraryExW( lpLibFileName, hFile, dwFlags );
	}

    CHAR cLibFileNameA[MAX_PATH] ;		//Ansi str to hold the path

	//Convert the path to Ansi
    if(!StandardUtoA(lpLibFileName, MAX_PATH, cLibFileNameA)) 
	{
        return NULL ;
    }

	//Call and return the ansi version
    return LoadLibraryExA(cLibFileNameA, hFile, dwFlags) ; 
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: LoadLibraryAU 
//
//  PURPOSE:  Wrapper over LoadLibraryA that mimics LoadLibraryW
//
//  Comments: See Win32 LoadLibrary for Functionality
// 
///////////////////////////////////////////////////////////////////////////////////

HMODULE WINAPI LoadLibraryAU( LPCWSTR lpLibFileName )
{

	if ( ISNT() )
	{
		return LoadLibraryW( lpLibFileName );
	}

    CHAR cLibFileNameA[MAX_PATH] ;		//Ansi str to hold the path
	//Convert the path to Ansi
    if(!StandardUtoA(lpLibFileName, MAX_PATH, cLibFileNameA)) 
	{
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL ;
    }

	//Call and return the ansi version
    return LoadLibraryA( cLibFileNameA ) ; 
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetModuleFileNameAU 
//
//  PURPOSE:  Wrapper over GetModuleFileNameA that mimics GetModuleFileNameW
//
//  Comments: See Win32 GetModuleFileName for Functionality
//
// /////////////////////////////////////////////////////////////////////////
DWORD WINAPI GetModuleFileNameAU( HMODULE hModule,
							      LPWSTR  lpFileName,
								  DWORD   nSize
								)
{
	if ( ISNT() )
	{
		return GetModuleFileNameW( hModule, lpFileName, nSize );
	}

    CHAR cFileNameA[MAX_PATH] = {'\0'} ;	//Ansi str to hold the file name

	//Call the Ansi version
    if(!GetModuleFileNameA( hModule, cFileNameA, MIN(nSize, MAX_PATH)) ) 
	{
        return 0 ;
    }

	//Convert to Unicode and return 
    return StandardAtoU(cFileNameA, MIN(nSize, MAX_PATH), lpFileName) ;
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HMODULE GetModuleHandleAU(	LPCWSTR lpModuleName   // address of module name to return handle for
//						  )
//
//  PURPOSE:  Wrapper over GetModuleHandleA that mimics GetModuleHandleW
//
//  Comments: See Win32 GetModuleHandle for Functionality
//
// /////////////////////////////////////////////////////////////////////////
HMODULE WINAPI GetModuleHandleAU(	LPCWSTR lpModuleName   // address of module name to return handle for
								)
{
	if ( ISNT() )
	{
		return GetModuleHandleW( lpModuleName );
	}
		
	
	USES_CONVERSION;

	//Convert the name to Ansi
	LPCSTR lpModuleNameA = W2A( lpModuleName );

	_ASSERT( lpModuleNameA != NULL);

	//Make sure it was converted correctly
	if ( lpModuleNameA == NULL )
	{		
		return NULL;
	}

	//Call and return the ansi version
	return GetModuleHandleA( lpModuleNameA );
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HANDLE CreateEventAU(	LPSECURITY_ATTRIBUTES lpEventAttributes,	// pointer to security attributes
//									BOOL				  bManualReset,  // flag for manual-reset event
//									BOOL				  bInitialState, // flag for initial state
//									LPCWSTR				  lpName      // pointer to event-object name
//				                  )
//
//  PURPOSE:  Wrapper over CreateEventA that mimics CreateEventW
//
//  Comments: See Win32 CreateEvent for Functionality
//
// /////////////////////////////////////////////////////////////////////////

HANDLE WINAPI	CreateEventAU(	LPSECURITY_ATTRIBUTES lpEventAttributes,	// pointer to security attributes
								BOOL				  bManualReset,  // flag for manual-reset event
								BOOL				  bInitialState, // flag for initial state
								LPCWSTR				  lpName      // pointer to event-object name
							 )
{
	if ( ISNT() )
	{
		return CreateEventW( lpEventAttributes, bManualReset, bInitialState, lpName );
	}


	USES_CONVERSION;
	
	LPSTR lpNameA = NULL;

	//Convert the event name to ansi if one is given
	if ( !RW2A(lpNameA, lpName) )
		return NULL;
	
	//Call and return the Ansi version
	return CreateEventA( lpEventAttributes, bManualReset, bInitialState, lpNameA );
}


// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: DWORD GetCurrentDirectoryAU( DWORD  nBufferLength,  // size, in characters, of directory buffer
//											LPWSTR lpBuffer        // pointer to buffer for current directory
//						   )
//
//  PURPOSE:  Wrapper over GetCurrentDirectoryA that mimics GetCurrentDirectoryW
//
//  Comments: See Win32 GetCurrentDirectory for Functionality
//
// /////////////////////////////////////////////////////////////////////////


DWORD WINAPI GetCurrentDirectoryAU(  DWORD  nBufferLength,  // size, in characters, of directory buffer
									 LPWSTR lpBuffer        // pointer to buffer for current directory
								  )
{

	if ( ISNT() )
	{
		return GetCurrentDirectoryW( nBufferLength, lpBuffer );
	}

	LPSTR lpBufferA = (LPSTR)alloca( BUFSIZE(nBufferLength) );
	DWORD iRet      = 0;

	//Make sure the buffer was allocated correctly
	if ( nBufferLength != 0 && lpBufferA == NULL )
	{
		return 0;
	}

	//Call the Ansi version
	iRet = GetCurrentDirectoryA( BUFSIZE( nBufferLength ), lpBufferA );

	if ( iRet && iRet <= nBufferLength) //Enter only if the call succeeded
	{
		//Convert the directory to Unicode
		if ( !StandardAtoU( lpBufferA, nBufferLength, lpBuffer ) )
		{
			_ASSERT( FALSE );
			return 0;
		}
	}

	return iRet;
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL SetCurrentDirectory(	LPCWSTR lpPathName   // pointer to name of new current directory
//									  );
//
//  PURPOSE:  Wrapper over SetCurrentDirectoryA that mimics SetCurrentDirectoryW
//
//  Comments: See Win32 SetCurrentDirectory for Functionality
//
// /////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetCurrentDirectoryAU( LPCWSTR lpPathName   )// pointer to name of new current directory						);
{
	if ( ISNT() )
	{
		return SetCurrentDirectoryW( lpPathName );
	}

	USES_CONVERSION;

	//Convert the path name
	LPSTR lpPathNameA = W2A( lpPathName );

	//Make sure the path was converted correctly
	if ( lpPathNameA== NULL ) 
		return FALSE;

	//Call and return the ansi version
	return SetCurrentDirectoryA( lpPathNameA );
}




//////////////////////////////////////
//
//
// USER32.DLL
//
//
//////////////////////////////////////

BOOL WINAPI IsDialogMessageAU( HWND hDlg,   // handle to dialog box
							   LPMSG lpMsg  // message to be checked
							 )
{
	if ( ISNT() )
	{
		return IsDialogMessageW( hDlg, lpMsg );
	}


	MSG msg;

	msg.hwnd		= lpMsg->hwnd;
	msg.message		= lpMsg->message;
	msg.pt			= lpMsg->pt;
	msg.time		= lpMsg->time;
	msg.lParam		= lpMsg->lParam;
	msg.wParam		= lpMsg->wParam;

	ConvertMessageAU( hDlg, msg.message, &(msg.wParam), &(msg.lParam) );

	return IsDialogMessageA( hDlg, &msg );
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: SystemParametersInfoAU 
//
//  PURPOSE:  Wrapper over SystemParametersInfoA that mimics SystemParametersInfoW
//
//  NOTES:    SEE Win32 SystemParametersInfo for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SystemParametersInfoAU( UINT  uiAction,  // system parameter to query or set
									UINT  uiParam,   // depends on action to be taken
									PVOID pvParam,  // depends on action to be taken
									UINT  fWinIni    // user profile update flag
								  )
{

	if ( ISNT() )
	{
		return SystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );
	}

	switch ( uiAction )
	{
		case SPI_GETWORKAREA:
			return SystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );
		default: //Assert as we don't handle the action... if unhandled action 
				 //deals with a string must convert to ansi then call..
			_ASSERT( FALSE );
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegisterWindowMessageAU 
//
//  PURPOSE:  Wrapper over RegisterWindowMessageA that mimics RegisterWindowMessageW
//
//  NOTES:    SEE Win32 RegisterWindowMessage for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

UINT WINAPI RegisterWindowMessageAU(	LPCWSTR lpString   // message string
								   )
{
	if ( ISNT() )
	{
		return RegisterWindowMessageW( lpString );
	}


	USES_CONVERSION;
	LPSTR lpStringA = NULL;

	//Convert to Ansi
	if ( !RW2A( lpStringA, lpString) || !lpStringA )
    {
        SetLastError(ERROR_OUTOFMEMORY);
		return 0;
    }

	//Call and return the Ansi version
	return RegisterWindowMessageA( lpStringA );
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: SetMenuItemInfoAU 
//
//  PURPOSE:  Wrapper over SetMenuItemInfoA that mimics SetMenuItemInfoW
//
//  NOTES:    SEE Win32 SetMenuItemInfo for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI	SetMenuItemInfoAU(	HMENU	hMenu,          // handle to menu
								UINT	uItem,           // identifier or position
								BOOL	fByPosition,     // meaning of uItem
								LPCMENUITEMINFOW lpmii  // menu item information
							 )
{
	if ( ISNT() )
	{
		return SetMenuItemInfoW( hMenu, uItem, fByPosition, lpmii );
	}


	USES_CONVERSION;

	MENUITEMINFOA miia;

	//Convert the structure
    miia.cbSize        = sizeof( MENUITEMINFOA );
    miia.fMask         = lpmii->fMask; 
    miia.fType         = lpmii->fType; 
    miia.fState        = lpmii->fState; 
    miia.wID           = lpmii->wID; 
    miia.hSubMenu      = lpmii->hSubMenu; 
    miia.hbmpChecked   = lpmii->hbmpChecked; 
    miia.hbmpUnchecked = lpmii->hbmpUnchecked; 
    miia.dwItemData    = lpmii->dwItemData ;  
    miia.cch           = lpmii->cch;     
//	miia.hbmpItem      = lpmii->hbmpItem;

	//Check if it is a string, and if it is convert
	if ( (miia.fType == MFT_STRING) && (!RW2A(miia.dwTypeData, lpmii->dwTypeData)) )
	{
		return FALSE;
	}

	//Call the and return the ansi version
	return SetMenuItemInfoA( hMenu, uItem, fByPosition, &miia );
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetClassNameAU 
//
//  PURPOSE:  Wrapper over GetClassNameA that mimics GetClassNameW
//
//  NOTES:    SEE Win32 GetClassName for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

int WINAPI GetClassNameAU(	HWND	hWnd,         // handle to window
							LPWSTR  lpClassName,  // pointer to buffer for class name
							int		nMaxCount     // size of buffer, in characters
						 )
{

	if ( ISNT() )
	{
		return GetClassNameW( hWnd, lpClassName, nMaxCount );
	}

	LPSTR lpClassNameA = (LPSTR) alloca( BUFSIZE( nMaxCount )) ;

	//Make sure the buffer was allocated ok
	if ( lpClassNameA == NULL )
		return 0;

	//Call the ansi ver
	int iRet = GetClassNameA( hWnd, lpClassNameA, nMaxCount );


	if ( iRet ) //Convert if successful
	{
		//Convert it to Unicode
		return StandardAtoU(lpClassNameA, nMaxCount, lpClassName) ;
	}

	return 0;
}


// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL InsertMenuAU(	HMENU	 hMenu,          // handle to menu
//								UINT	 uPosition,       // item that new item precedes
//								UINT	 uFlags,          // options
//								UINT_PTR uIDNewItem,  // identifier, menu, or submenu
//								LPCWSTR  lpNewItem     // menu item content
//							 )				 
//
//  PURPOSE:  Wrapper over InsertMenuA that mimics InsertMenuW
//
//  Comments: See Win32 InsertMenu for Functionality
//
// /////////////////////////////////////////////////////////////////////////

BOOL WINAPI InsertMenuAU(	HMENU	 hMenu,       // handle to menu
							UINT	 uPosition,   // item that new item precedes
							UINT	 uFlags,      // options
							UINT     uIDNewItem,  // identifier, menu, or submenu
							LPCWSTR  lpNewItem    // menu item content
						)
{
	if ( ISNT() )
	{
		return InsertMenuW( hMenu, uPosition, uFlags, uIDNewItem, lpNewItem );
	}


	USES_CONVERSION;
	
	LPSTR lpNewItemA = NULL;

	//Check if lpNewItem Contains a string
	if ( !(uFlags & MF_BITMAP) && !(uFlags & MF_OWNERDRAW) )
	{
		if ( !RW2A(lpNewItemA, lpNewItem) )
			return FALSE;
	}
	else 
	{
		lpNewItemA = (LPSTR) lpNewItem; //Just cast it..				
	}

	//Call and return the ansi ver
	return InsertMenuA( hMenu, uPosition, uFlags, uIDNewItem, lpNewItemA );
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL IsCharAlphaNumericAU(	WCHAR ch   // character to test
//			    					   )
//
//  PURPOSE:  Wrapper over IsCharAlphaNumericA that mimics IsCharAlphaNumericW
//
//  Comments: See Win32 IsCharAlphaNumeric for Functionality
//
// /////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsCharAlphaNumericAU(	WCHAR ch   // character to test
								)
{

	if ( ISNT() )
	{
		return IsCharAlphaNumericW( ch );
	}

	USES_CONVERSION;
    
    // Single character, not an address
    WCHAR wcCharOut[2] ;
        
	LPSTR lpCharA;
		
	//Create string
    wcCharOut[0] = (WCHAR) ch ;
    wcCharOut[1] = L'\0' ;

	//Convert the character to Ansi
    if( (lpCharA = W2A(wcCharOut)) == NULL ) 
	{
        return NULL ;
    }
	
	return IsCharAlphaNumericA( *lpCharA );
}

// /////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: LPWSTR CharNextAU( LPCWSTR lpsz   // pointer to current character
//							   )
//
//  PURPOSE:  Wrapper over CharNextA that mimics CharNextW
//
//  Comments: See Win32 CharNext for Functionality
//
// /////////////////////////////////////////////////////////////////////////
LPWSTR WINAPI CharNextAU( LPCWSTR lpsz   // pointer to current character
						)
{	
	if ( ISNT() )
	{
		return CharNextW( lpsz );
	}

	//Only increase the character if we are not at the end of the string
	if ( *(lpsz) == L'\0' )
	{
		return (LPWSTR)lpsz;
	}
	
	return (LPWSTR)lpsz+1;
}


// //////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL DeleteFileAU( LPCTSTR lpFileName   // pointer to name of file to delete
//			   			       )
//
//  PURPOSE:  Wrapper over DeleteFileA that mimics DeleteFileW
//
//  Comments: See Win32 DeleteFile for Functionality
//
// //////////////////////////////////////////////////////////////////////////////

BOOL WINAPI	DeleteFileAU( LPCWSTR lpFileName   // pointer to name of file to delete
						)
{
	if ( ISNT() )
	{
		return DeleteFileW( lpFileName );
	}

	USES_CONVERSION;
	
	LPSTR lpFileNameA = W2A( lpFileName );

	//Make sure conversion was successfull
	if ( lpFileNameA == NULL )
		return FALSE;

	//Call and return the ansi version
	return DeleteFileA( lpFileNameA );
}

// //////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL IsBadStringPtrAU(	LPCWSTR lpsz,  // address of string
//										UINT ucchMax   // maximum size of string
//			   					   )
//
//  PURPOSE:  Wrapper over IsBadStringPtrA that mimics IsBadStringPtrW
//
//  Comments: See Win32 IsBadStringPtr for Functionality
//
// //////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsBadStringPtrAU(	LPCWSTR lpsz,  // address of string
								UINT ucchMax   // maximum size of string
							)
{
	if ( ISNT() )
	{
		return IsBadStringPtrW( lpsz, ucchMax );
	}

	return IsBadReadPtr( (LPVOID)lpsz, ucchMax * sizeof(WCHAR) );
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HCURSOR LoadBitmapAU( HINSTANCE hInstance,  // handle to application instance
//								    LPCWSTR   lpBitmapName  // name or resource identifier
//								  )  
//
//  PURPOSE:  Wrapper over LoadBitmapA that mimics LoadBitmapW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//  
///////////////////////////////////////////////////////////////////////////////////


HBITMAP WINAPI LoadBitmapAU(	HINSTANCE hInstance,  // handle to application instance
								LPCWSTR	  lpBitmapName  // address of bitmap resource name
						   )
{
	if ( ISNT() )
	{
		return LoadBitmapW( hInstance, lpBitmapName );
	}

	//Call and return Ansi ver
	return LoadBitmapA( hInstance, (LPCSTR) lpBitmapName);
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HCURSOR LoadCursorAU( HINSTANCE hInstance,  // handle to application instance
//								    LPCTSTR lpCursorName  // name or resource identifier
//								  )  
//
//  PURPOSE:  Wrapper over LoadCursorA that mimics LoadCursorW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//  
///////////////////////////////////////////////////////////////////////////////////


HCURSOR WINAPI LoadCursorAU( HINSTANCE hInstance,  // handle to application instance
							 LPCWSTR lpCursorName  // name or resource identifier
						   )  
{
	if ( ISNT() )
	{
		return LoadCursorW( hInstance, lpCursorName );
	}

	//Call and return Ansi ver
	return LoadCursorA( hInstance, (LPCSTR) lpCursorName );
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HICON LoadIconAU( HINSTANCE hInstance, // handle to application instance
//							    LPCWSTR lpIconName   // name string or resource identifier
//							  )
//
//  PURPOSE:  Wrapper over LoadIconA that mimics LoadIconW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//  
///////////////////////////////////////////////////////////////////////////////////


HICON WINAPI LoadIconAU(	HINSTANCE hInstance, // handle to application instance
							LPCWSTR lpIconName   // name string or resource identifier
					   )
{

	if ( ISNT() )
	{
		return LoadIconW( hInstance, lpIconName );
	}

	//Call and return Ansi ver
	return LoadIconA( hInstance, (LPCSTR) lpIconName );
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: HANDLE LoadImageUA( HINSTANCE hinst,   // handle of the image instance
//				  LPCWSTR lpszName,  // name or identifier of the image
//				  UINT uType,        // type of image
//				  int cxDesired,     // desired width
//				  int cyDesired,     // desired height
//				  UINT fuLoad        // load flags
//				)
//
//  PURPOSE:  Wrapper over LoadImageA that mimics LoadImageW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//  
///////////////////////////////////////////////////////////////////////////////////

HANDLE WINAPI LoadImageAU(  HINSTANCE	hinst,   // handle of the image instance
							LPCWSTR		lpszName,  // name or identifier of the image
							UINT		uType,        // type of image
							int			cxDesired,     // desired width
							int			cyDesired,     // desired height
							UINT		fuLoad        // load flags
						  )
{
	if ( ISNT() )
	{
		return LoadImageW( hinst, lpszName, uType, cxDesired, cyDesired, fuLoad );
	}


	//Call and return Ansi ver
	return LoadImageA( hinst, (LPCSTR)lpszName, uType, cxDesired, cyDesired, fuLoad );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: BOOL SetProp UA( HWND hWnd,         // handle of window
//							 LPCWSTR lpString,  // atom or address of string
//							 HANDLE hData       // handle of data
//						   )
//
// PURPOSE: Wrapper over SetPropA that mimics SetPropW
//
// NOTES: See Win32 SetProp for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetPropAU(  HWND    hWnd,         // handle of window
						LPCWSTR lpString,     // atom or address of string
						HANDLE  hData         // handle of data
					 )
{
	if ( ISNT() )
	{
		return SetPropW( hWnd, lpString, hData );
	}


	USES_CONVERSION;

	LPSTR lpStringA = NULL;			//Ansi str to hold string

	//Check if it is an Atom
	if ( ISATOM(lpString) )
	{
		lpStringA = (LPSTR) lpString;	//Simply cast it... 
	}
	else if ( !RW2A(lpStringA,lpString) ) //Convert it to Ansi
	{
		return FALSE;
	}

	//Call ansi version and return the value
	return SetPropA( hWnd, (LPCSTR)lpStringA, hData );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: HANDLE GetPropAU(  HWND hWnd,         // handle of window
//							    LPCWSTR lpString   // atom or address of string
//						     );
//
// PURPOSE: Wrapper over GetPropA that mimics GetPropW
//
// NOTES: See Win32 GetProp for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

HANDLE WINAPI GetPropAU( HWND    hWnd,         // handle of window
						 LPCWSTR lpString   // atom or address of string
					   )
{

	if ( ISNT() )
	{
		return GetPropW( hWnd, lpString );
	}

	USES_CONVERSION;

	LPSTR lpStringA = NULL;  //Ansi str to hold string

	//Check if it is an Atom
	if ( ISATOM(lpString) )
	{
		lpStringA = (LPSTR) lpString;	//Simply cast it
	}
	else if ( !RW2A(lpStringA,lpString) )//Convert to ansi 
	{
			return NULL;
	}

	//Call ansi version and return the value
	return GetPropA( hWnd, (LPCSTR)lpStringA );
}

/////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: HANDLE RemoveProp AU(  HWND hWnd,         // handle of window
//							    LPCWSTR lpString   // atom or address of string
//						     );
//
// PURPOSE: Wrapper over RemovePropA that mimics RemovePropW
//
// NOTES:   See Win32 RemoveProp for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

HANDLE WINAPI RemovePropAU( HWND    hWnd,         // handle of window
							LPCWSTR lpString   // atom or address of string
						  )
{
	
	if ( ISNT() )
	{
		return RemovePropW( hWnd, lpString );
	}


	USES_CONVERSION;

	LPSTR lpStringA = NULL;				//Ansi str to hold string

	//Check if it is an Atom
	if ( ISATOM(lpString) )
	{
		lpStringA = (LPSTR) lpString;	//Simply cast it
	}
	else if ( !RW2A(lpStringA, lpString) ) //Convert to ansi 
	{
			return NULL;
	}

	//Call ansi version and return the value
	return RemovePropA( hWnd, (LPCSTR)lpStringA );
}


//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: UINT GetDlgItemTextAU(	HWND hDlg,       // handle to dialog box
//									int nIDDlgItem,  // control identifier
//									LPWSTR lpString, // pointer to buffer for text
//									int nMaxCount    // maximum size of string
//								  );
//
// PURPOSE: Wrapper over GetDlgItemTextA that mimics GetDlgItemTextW
//
// NOTES: See Win32 GetDlgItemText for fFunctionality
//
///////////////////////////////////////////////////////////////////////////////////

UINT WINAPI	GetDlgItemTextAU(	HWND   hDlg,       // handle to dialog box
								int    nIDDlgItem, // control identifier
								LPWSTR lpString,   // pointer to buffer for text
								int    nMaxCount   // maximum size of string
							)
{
	if ( ISNT() )
	{
		return GetDlgItemTextW( hDlg, nIDDlgItem, lpString, nMaxCount );
	}

	//Allocate the string on the stack
	LPSTR  lpStringA = (LPSTR)alloca( BUFSIZE(nMaxCount) );

	//Make sure the string was allocated correctly
	if ( lpStringA == NULL )
	{
		_ASSERT( FALSE );
		return 0;
	}

	//Call the ansi version
	if ( GetDlgItemTextA( hDlg, nIDDlgItem, lpStringA, nMaxCount ) == 0 )
		return 0;

	//convert the string to Wide char
	return StandardAtoU( lpStringA, nMaxCount, lpString );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: BOOL SetDlgItemTextAU( LPOSVERSIONINFOW lpVersionInformation )
//
// PURPOSE:  Wrapper over SetDlgItemTextA that mimics SetDlgItemTextW
//
// NOTES:    See Win32 SetDlgItemText for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetDlgItemTextAU( HWND		hDlg,         
							  int		nIDDlgItem,    
							  LPCWSTR   lpString   
							)
{
	if ( ISNT() )
	{
		return SetDlgItemTextW( hDlg, nIDDlgItem, lpString );
	}


	USES_CONVERSION;

	//Convert the string
	LPCSTR lpStringA = W2A( lpString );

	//Make sure the string was converted correctly
	if ( lpStringA == NULL )
		return 0;

	//Call and return the asci func
	return SetDlgItemTextA( hDlg, nIDDlgItem, lpStringA );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: LONG SetWindowLongAU(  HWND hWnd,      // handle to window
//								  int nIndex,       // offset of value to set
//								  LONG dwNewLong    // new value
//								 )
//
// PURPOSE: Wrapper over SetWindowLong that mimics SetWindowLongAU
//
// NOTES: See Win32 SetWindowLong for Functionality
//        Be careful about what your doing here!, doesn't convert any strings.....
//        
//
///////////////////////////////////////////////////////////////////////////////////

LONG WINAPI	SetWindowLongAU(  HWND hWnd,       // handle to window
  							  int  nIndex,     // offset of value to set
							  LONG dwNewLong   // new value
						   )
{
	if ( ISNT() )
	{
		return SetWindowLongW( hWnd, nIndex, dwNewLong );
	}

	//Call call and return the ansi version
	return SetWindowLongA( hWnd, nIndex, dwNewLong );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: LONG GetWindowLongAU(  HWND hWnd,  // handle to window
//					   int nIndex  // offset of value to retrieve
//				    )
//
// PURPOSE: Wrapper over GetWindowLongA that mimics GetWindowLongW
//
// NOTES: See Win32 GetWindowLong for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

LONG WINAPI GetWindowLongAU(  HWND hWnd,  // handle to window
							  int nIndex  // offset of value to retrieve
						   )
{
	if ( ISNT() )
	{
		return GetWindowLongW( hWnd, nIndex );
	}

	//Call call and return the ansi version
	return GetWindowLongA( hWnd, nIndex );
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: HWND FindWindowAU( LPCWSTR lpClassName,  // pointer to class name
//				   LPCWSTR lpWindowName  // pointer to window name
//				 )
//
// PURPOSE: Wrapper over FindWindowA that mimics FindWindowW
//
// NOTES: See Win32 FindWindow for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindWindowAU( LPCWSTR lpClassName,  // pointer to class name
						  LPCWSTR lpWindowName  // pointer to window name
						)

{

	if ( ISNT() )
	{
		return FindWindowW( lpClassName, lpWindowName );
	}

	USES_CONVERSION;
	
	LPSTR lpClassNameA  = NULL;   //Ansi str to hold class
	LPSTR lpWindowNameA = NULL;   //Ansi str to hold window

	//Convert WindowName to Ansi
	if ( lpWindowName != NULL && (  lpWindowNameA = W2A( lpWindowName )  ) == NULL )
		return NULL;

	//Check if the high word of the data is zero or else assume its a string...
	if ( ISATOM(lpClassNameA) )
	{
		//We have a win atom
		lpClassNameA = (LPSTR) lpClassName;
	}
	else if ( (lpClassNameA = W2A(lpWindowName) ) == NULL ) //Convert to Ansi
	{	
			return NULL;
	}

	//Call and return ansi version
	return FindWindowA( (LPCSTR) lpClassNameA, lpClassNameA);
}


//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: int WINAPI DrawTextUA( HDC  hDC,				// handle to device context 
//						  LPCWSTR  lpStringW,	// pointer to string to draw 
//						  int  nCount,			// string length, in characters 
//						  LPRECT  lpRect,		// pointer to structure with formatting dimensions  
//						  UINT  uFormat 		// text-drawing flags 
//						)
//
// PURPOSE: Wrapper over DrawTextA that mimics DrawTextW
//
// NOTES: See Win32 DrawText for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

int WINAPI DrawTextAU( HDC		hDC,		// handle to device context 
					   LPCWSTR  lpStringW,	// pointer to string to draw 
					   int		nCount,		// string length, in characters 
					   LPRECT	lpRect,		// pointer to structure with formatting dimensions  
					   UINT		uFormat 	// text-drawing flags 
					  )
{
	if ( ISNT() )
	{
		return DrawTextW( hDC, lpStringW, nCount, lpRect, uFormat );
	}


	USES_CONVERSION;
	
	//Convert the string
	LPSTR lpTextA = NULL;
	
	if (nCount == -1)
		lpTextA = W2A( lpStringW );        //Characters to convert
	else
	{
		lpTextA = (LPSTR)alloca( BUFSIZE(nCount) );  //Allocate the approprate number of characters
		
		//copy them to a buffer
		StandardUtoA( lpStringW, BUFSIZE(nCount), lpTextA  ); 

	}
	_ASSERT( lpTextA != NULL );

	//Make sure it worked ok..
	if ( lpTextA == NULL )
		return 0;
	
	//Call and return the asci value
	return DrawTextA (hDC, lpTextA, lstrlenA(lpTextA), lpRect, uFormat);
}
  
//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: int WINAPI DrawTextExAU ( HDC hdc,	// handle to device context
//						  LPCWSTR pch,	// pointer to string to draw
//						  int cchText,	// length of string to draw
//						  LPRECT lprc,	// pointer to rectangle coordinates
//						  UINT dwDTFormat,	// formatting options
//						  LPDRAWTEXTPARAMS lpDTParams	// pointer to structure for more options 
 //						)
//
// PURPOSE: Wrapper over DrawTextExA that mimics DrawTextExW
//
// NOTES: See Win32 DrawTextEx for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

int WINAPI DrawTextExAU ( HDC				hdc,	// handle to device context
						  LPWSTR			pch,	// pointer to string to draw
						  int				cchText,	// length of string to draw
						  LPRECT			lprc,	// pointer to rectangle coordinates
						  UINT				dwDTFormat,	// formatting options
						  LPDRAWTEXTPARAMS  lpDTParams	// pointer to structure for more options 
  						)
{
	if ( ISNT() )
	{
		return DrawTextExW( hdc, pch, cchText, lprc, dwDTFormat, lpDTParams );
	}


	USES_CONVERSION;
	
	//Convert the string
	LPSTR lpTextA = W2A( pch );

	//Make sure it worked ok
	if ( lpTextA == NULL )
		return 0;
	
	//Call and return the asci value
	return DrawTextExA(hdc, lpTextA, lstrlenA(lpTextA), lprc, dwDTFormat, lpDTParams);
}

//////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: SendMessageAU 
//
//  PURPOSE:  Wrapper over SendMessageA that mimics SendMessageW
//
//  Comments: See Win32 SendMessageAU for Functionality
//			  Notes: Does not convert all Possible messages, 
//			  TODO: ASSERT if getting a message we should handle and don't
// 
///////////////////////////////////////////////////////////////////////////////////
LRESULT WINAPI SendMessageAU( HWND	 hWnd       ,
							  UINT	 Msg        ,
							  WPARAM wParam   ,
							  LPARAM lParam
							)
{

	if ( ISNT() )
	{
		return SendMessageW( hWnd, Msg, wParam, lParam);
	}

    LRESULT lResult      = 0;
    LPVOID  lpTempBuffer = NULL;
    int     nLength      = 0;
    CHAR    cCharA[3];
    WCHAR   cCharW[3];
	LONG	dwData = 0;

// Note: This function can send any of the hundreds of windows
// messages to window, and the behavior may be different for each
// one. I have tested those cases used in this sample application, 
// as well as WM_CHAR, WM_IME_CHAR, WM_GETTEXT, and WM_SETTEXT.
// You should test it with every message you intend to use it with.
//
#if 0
    switch (Msg) 
	{
    // Cases that require conversion, but are not handled by this sample.
    // NOTE: There are probably others. These are all I could find with
    // a quick examination of the help files

         // RichEdit Messages. Requires #include<richedit.h>
        case EM_GETSELTEXT:
        case EM_FINDTEXT:
        case EM_SETPUNCTUATION:
            
        // Video capture messages. Requires #include<vfw.h>
        case WM_CAP_FILE_SAVEAS:
        case WM_CAP_FILE_SAVEDIB:
        case WM_CAP_FILE_SET_CAPTURE_FILE:
        case WM_CAP_PAL_OPEN:
        case WM_CAP_PAL_SAVE:
        case WM_CAP_SET_MCI_DEVICE:

        // Other special cases
        case WM_MENUCHAR:        // LOWORD(wParam) is char, HIWORD(wParam) is menu flag,
                                 // lParam is hmenu (handle of menu sending message)
        case WM_CHARTOITEM:      // LOWORD(wParam) = nKey, HIWORD(wParam) = nCaretPos 
                                 // lParam is handle of list box sending message
        case WM_IME_COMPOSITION: // wParam is dbcs char, lParam is fFlags 

            return FALSE ;
    }
#endif


    // Preprocess messages that pass chars and strings via wParam
    // and lParam
    switch (Msg) 
	{
        // Single Unicode Character in wParam. Convert Unicode character
        // to ANSI and pass lParam as is.
        case EM_SETPASSWORDCHAR: // wParam is char, lParam = 0 

        case WM_CHAR:            //*wParam is char, lParam = key data
        case WM_SYSCHAR:         // wParam is char, lParam = key data
            // Note that we don't handle LeadByte and TrailBytes for
            // these two cases. An application should send WM_IME_CHAR
            // in these cases anyway

        case WM_DEADCHAR:        // wParam is char, lParam = key data
        case WM_SYSDEADCHAR:     // wParam is char, lParam = key data
        case WM_IME_CHAR:        //*

            cCharW[0] = (WCHAR) wParam ;
            cCharW[1] = L'\0' ;

            if(!WideCharToMultiByte(
                    CP_ACP , // ?? This is a guess
                    0      , 
                    cCharW ,
                    1      ,
                    cCharA ,
                    3      ,
                    NULL   , 
                    NULL) 
                ) 
			{

                return FALSE ;
            }

            if(Msg == WM_IME_CHAR) 
			{
                wParam = (cCharA[1] & 0x00FF) | (cCharA[0] << 8) ;
            } else 
			{
                wParam = cCharA[0] ;
            }

            wParam &= 0x0000FFFF;

            break ;

        // In the following cases, lParam is pointer to IN buffer containing
        // text to send to window.
        // Preprocess by converting from Unicode to ANSI
        case CB_ADDSTRING:       // wParam = 0, lParm = lpStr, buffer to add 
        case CB_DIR:             // wParam = file attributes, lParam = lpszFileSpec buffer
        case CB_FINDSTRING:      // wParam = start index, lParam = lpszFind  
        case CB_FINDSTRINGEXACT: // wParam = start index, lParam = lpszFind
        case CB_INSERTSTRING:    //*wParam = index, lParam = lpszString to insert
        case CB_SELECTSTRING:    // wParam = start index, lParam = lpszFind
			dwData = GetWindowLongA( hWnd, GWL_STYLE );
			
			_ASSERT( dwData != 0 );

			if ( ( (dwData & CBS_OWNERDRAWFIXED) || (dwData & CBS_OWNERDRAWVARIABLE) ) && !(dwData & CBS_HASSTRINGS) )
				break;

			
		case LB_ADDSTRING:       // wParam = 0, lParm = lpStr, buffer to add
        case LB_DIR:             // wParam = file attributes, lParam = lpszFileSpec buffer
        case LB_FINDSTRING:      // wParam = start index, lParam = lpszFind
        case LB_FINDSTRINGEXACT: // wParam = start index, lParam = lpszFind
        case LB_INSERTSTRING:    //*wParam = index, lParam = lpszString to insert
        case LB_SELECTSTRING:    // wParam = start index, lParam = lpszFind
			dwData = GetWindowLongA( hWnd, GWL_STYLE );
			
			_ASSERT( dwData != 0 );

			if ( ((dwData & LBS_OWNERDRAWVARIABLE) || (dwData & LBS_OWNERDRAWFIXED)) && !(dwData & CBS_HASSTRINGS) )
				break;
			
        case WM_SETTEXT:         //*wParam = 0, lParm = lpStr, buffer to set 
		case EM_REPLACESEL:		 // wParam = undo option, lParam = buffer to add 
        {
            if(NULL != (LPWSTR) lParam) 
			{

                nLength = 2*(wcslen((LPWSTR) lParam)+1) ; // Need double length for DBCS characters

                lpTempBuffer // This is time-consuming, but so is the conversion
                    = (LPVOID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nLength) ;
            }

            if(NULL == lpTempBuffer)
            {
                return FALSE ;
            }

            if(!StandardUtoA((LPWSTR) lParam, nLength, (LPSTR) lpTempBuffer) ) 
			{
                HeapFree(GetProcessHeap(), 0, lpTempBuffer) ;
                return FALSE ;
            }

            lParam = (LPARAM) lpTempBuffer ;

            break ;

        }


		/*Special Cases*/
		case EM_SETCHARFORMAT:
			CHARFORMATA  cfa;
			CHARFORMATW* pcfw = (CHARFORMATW*) lParam;
			cfa.bCharSet		= pcfw->bCharSet;
			cfa.bPitchAndFamily	= pcfw->bPitchAndFamily;
			cfa.cbSize			= pcfw->cbSize;
			cfa.crTextColor     = pcfw->crTextColor;
			cfa.dwEffects		= pcfw->dwEffects;
			cfa.dwMask			= pcfw->dwMask;
			cfa.yHeight			= pcfw->yHeight;
			cfa.yOffset			= pcfw->yOffset;
			if ( (cfa.dwMask & CFM_FACE) && !(StandardUtoA( pcfw->szFaceName, LF_FACESIZE, cfa.szFaceName )) )
				return 0;
			lParam = (LPARAM) &cfa;
			break;
    }

    // This is where the actual SendMessage takes place
    lResult = SendMessageA(hWnd, Msg, wParam, lParam) ;

    nLength = 0 ;
/*
    if(lResult > 0) 
	{
*/
        switch (Msg) 
		{
            // For these cases, lParam is pointer to OUT buffer that received text from
            // SendMessageA in ANSI. Convert to Unicode and send back.
            case WM_GETTEXT:         // wParam = numCharacters, lParam = lpBuff to RECEIVE string
            case WM_ASKCBFORMATNAME: // wParam = nBufferSize, lParam = lpBuff to RECEIVE string 

                nLength = (int) wParam ;

                if(!nLength) 
				{
					*((LPWSTR) lParam) = L'\0' ;
                    break ;
                }

            case CB_GETLBTEXT:       // wParam = index, lParam = lpBuff to RECEIVE string
            case EM_GETLINE:         // wParam = Line no, lParam = lpBuff to RECEIVE string

                if(!nLength) 
				{    
                    nLength = wcslen((LPWSTR) lParam) + 1 ;
                }

                lpTempBuffer
                    = (LPVOID) HeapAlloc(
                                GetProcessHeap(), 
                                HEAP_ZERO_MEMORY, 
                                nLength*sizeof(WCHAR)) ;
                if( lpTempBuffer == NULL )
                {
                    *((LPWSTR) lParam) = L'\0' ;
                	return FALSE;
                }

                if(!StandardAtoU((LPCSTR) lParam, nLength, (LPWSTR) lpTempBuffer) ) 
				{
                    *((LPWSTR) lParam) = L'\0' ;
                    HeapFree(GetProcessHeap(), 0, lpTempBuffer) ;
                    return FALSE ;
                }
				wcscpy((LPWSTR) lParam, (LPWSTR) lpTempBuffer) ;
        }
/*
    }
*/
    if(lpTempBuffer != NULL) 
	{
        HeapFree(GetProcessHeap(), 0, lpTempBuffer) ;
    }

    return lResult ;
}





///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: SendDlgItemMessage AU 
//
//  PURPOSE:  Wrapper over SendDlgItemMessageA that mimics SendDlgItemMessageW
//
//  Comments: See Win32 SendDlgItemMessageAU for Functionality
//     Rather than going through SendDlgItemMessageA, we just
//     do what the system does, i.e., go through 
//     SendMessage
// 
///////////////////////////////////////////////////////////////////////////////////
LONG WINAPI SendDlgItemMessageAU( HWND		hDlg,
								  int		nIDDlgItem,
								  UINT		Msg,
								  WPARAM	wParam,
								  LPARAM	lParam
								)
{

	if ( ISNT() )
	{
		return SendDlgItemMessageW( hDlg, nIDDlgItem, Msg, wParam, lParam );
	}

	//Get the dlg handle
    HWND hWnd = GetDlgItem(hDlg, nIDDlgItem) ;

	//Make sure we recevied it ok
    if(NULL == hWnd) 
	{
        return 0L;
    }

    // Rather than going through SendDlgItemMessageA, we just
    // do what the system does, i.e., go through 
    // SendMessage
    return SendMessageAU(hWnd, Msg, wParam, lParam) ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: SetWindowTextAU 
//
//  PURPOSE:  Wrapper over SetWindowTextA that mimics SetWindowTextW
//
//  Comments: 
//     Rather than going through SetWindowTextA, we just
//     do what the system does, i.e., go through 
//     SendMessage
// 
///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI SetWindowTextAU( HWND    hWnd,
							 LPCWSTR lpStringW
						   )
{

	if ( ISNT() )
	{
		return SetWindowTextW( hWnd, lpStringW );
	}

    return (BOOL) (0 < SendMessageAU(hWnd, WM_SETTEXT, 0, (LPARAM) lpStringW)) ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetWindowTextAU 
//
//  PURPOSE:  Wrapper over GetWindowTextA that mimics GetWindowTextW
//
//  Comments: 
//     Rather than going through GetWindowTextA, we just
//     do what the system does, i.e., go through 
//     SendMessage
//
///////////////////////////////////////////////////////////////////////////////////
int WINAPI GetWindowTextAU( HWND   hWnd,
							LPWSTR lpStringW,
							int	   nMaxChars)
{

	if ( ISNT() )
	{
		return GetWindowTextW( hWnd, lpStringW, nMaxChars );
	}

    return (int) SendMessageAU(hWnd, WM_GETTEXT, (WPARAM) nMaxChars, (LPARAM) lpStringW) ;
}

//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: int WINAPI GetWindowTextLength AU( HWND hWnd )
//
// PURPOSE: Wrapper over GetWindowTextLengthA that mimics GetWindowTextLengthW
//
// NOTES: See Win32 GetWindowTextLength for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

int WINAPI GetWindowTextLengthAU( HWND hWnd )
{
	if ( ISNT() )
	{
		return GetWindowTextLengthW( hWnd );
	}

	return GetWindowTextLengthA( hWnd );
}



//////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: int WINAPI LoadStringAU( HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax)
//
// PURPOSE: Wrapper over LoadStringA that mimics LoadStringW
//
// NOTES: See Win32 LoadString for Functionality
//
///////////////////////////////////////////////////////////////////////////////////

int WINAPI LoadStringAU( HINSTANCE hInstance,
						  UINT		uID,
						  LPWSTR	lpBuffer,
						  int		nBufferMax )
{

	if ( ISNT() )
	{
		return LoadStringW( hInstance, uID, lpBuffer, nBufferMax );
	}

    int iLoadString ;

	//Allocate a string of the right size on the stack
	LPSTR lpABuf = (LPSTR)alloca( (nBufferMax+1)*2);

	//Make sure it is allocated ok
	_ASSERT( lpABuf != NULL );
	if (lpABuf == NULL)
		return 0;

    // Get ANSI version of the string
    iLoadString = LoadStringA(hInstance, uID, lpABuf, (nBufferMax+1)*2 ) ;

	//Make sure loadstring succeeded
	if ( !iLoadString )
		return 0;
	

    return StandardAtoU( lpABuf, nBufferMax, lpBuffer );

}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL GetClassInfoExAU( HINSTANCE     hInstance,      // handle to application instance
//									 LPCWSTR       lpClassName,    // pointer to class name string
//									 LPWNDCLASSEXW lpWndClass      // pointer to structure for class data
//								   )
//
//  PURPOSE:  Wrapper over GetClassInfoEx A that mimics GetClassInfoW
//
//  Comments: 
// net 
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetClassInfoExAU(	HINSTANCE		hinst,    // handle to application instance
								LPCWSTR			lpszClass,  // pointer to class name string
								LPWNDCLASSEXW	lpWcw  // pointer to structure for class data
							)
{
	if ( ISNT() )
	{
		return GetClassInfoExW( hinst, lpszClass, lpWcw );
	}


	USES_CONVERSION;

	LPCSTR lpClassNameA  = NULL;	//Ansi str to hold class name
	WNDCLASSEXA			   wcxa;
	BOOL				   bRet;

	wcxa.cbSize		= sizeof( WNDCLASSEXA );

	//Check if the high word of the data is zero or else assume its a string...
	if ( ISATOM(lpszClass) )
	{
		//We have a win atom
		lpClassNameA = (LPCSTR) lpszClass;
	}
	else if ( (lpClassNameA = W2A( lpszClass ) ) == NULL ) //Convert to Ansi
	{	
		return NULL;
	}

	//Call and return the ansi version
	if ( !(bRet = GetClassInfoExA( hinst, lpClassNameA, &wcxa)) )
		return FALSE;

    // Set up Unicde version of class struct
	lpWcw->style         = wcxa.style		   ;    
    lpWcw->cbClsExtra    = wcxa.cbClsExtra	   ;
    lpWcw->cbWndExtra    = wcxa.cbWndExtra	   ;
	lpWcw->lpfnWndProc   = wcxa.lpfnWndProc    ;
    lpWcw->hInstance     = wcxa.hInstance      ;
	lpWcw->hIcon         = wcxa.hIcon          ;
	lpWcw->hbrBackground = wcxa.hbrBackground  ;
    lpWcw->hCursor       = wcxa.hCursor		   ;
	lpWcw->hIconSm		 = wcxa.hIconSm		   ;

    // Note: This doesn't work if the menu id is a string rather than a
    // constant
   lpWcw->lpszMenuName = (LPWSTR) wcxa.lpszMenuName;

	//Can't give a ptr to the ansi ver so just leave it.. If you make the call you have the
	//class name already anyway
	lpWcw->lpszClassName = NULL;

	return bRet;
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: BOOL GetClassInfoAU( HINSTANCE hInstance,    // handle to application instance
//				     LPCWSTR lpClassName,    // pointer to class name string
//				     LPWNDCLASS lpWndClass   // pointer to structure for class data
//				   )
//  PURPOSE:  Wrapper over GetClassInfo A that mimics GetClassInfoW
//
//  Comments: 
// 
///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetClassInfoAU( HINSTANCE   hInstance,    // handle to application instance
							LPCWSTR		lpClassName,    // pointer to class name string
							LPWNDCLASSW lpWcw   // pointer to structure for class data
						  )
{
	if ( ISNT() )
	{
		return GetClassInfoW( hInstance, lpClassName, lpWcw );
	}


	USES_CONVERSION;

	LPCSTR lpClassNameA  = NULL;	//Ansi str to hold class name
	WNDCLASSA			   wca;

//	wca.cbSize			 = sizeof( WNDCLASSA )  ;

	//Check if the high word of the data is zero or else assume its a string...
	if ( ISATOM(lpClassName) )
	{
		//We have a win atom
		lpClassNameA = (LPCSTR) lpClassName;
	}
	else if ( (lpClassNameA = W2A( lpClassName ) ) == NULL ) //Convert to Ansi
	{	
		return NULL;
	}

	//Call and return the ansi version
	if ( !GetClassInfoA( hInstance, lpClassNameA, &wca ) )
		return 0;

    // Set up Unicde version of class struct
	lpWcw->style         = wca.style		  ;    
    lpWcw->cbClsExtra    = wca.cbClsExtra	  ;
    lpWcw->cbWndExtra    = wca.cbWndExtra	  ;
	lpWcw->lpfnWndProc   = wca.lpfnWndProc    ;
    lpWcw->hInstance     = wca.hInstance      ;
	lpWcw->hIcon         = wca.hIcon          ;
	lpWcw->hbrBackground = wca.hbrBackground  ;
    lpWcw->hCursor       = wca.hCursor		  ;

	//Can't give a ptr to the ansi ver so just leave it.. If you make the call you have the
	//class name already anyway
	lpWcw->lpszClassName = NULL;

    // Note: This doesn't work if the menu id is a string rather than a
    // constant
	lpWcw->lpszMenuName = (LPWSTR)wca.lpszMenuName;

	return TRUE;
}




///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegisterClassEx AU(CONST WNDCLASS EXW *lpWcw) 
//
//  PURPOSE:  Wrapper over RegisterClassA that mimics RegisterClassW
//
//  Comments: 
//      This is an important wrapper function; if you call this function,
//      any window that you create with this class name will be an ANSI 
//      window, i.e., it will receive text from the system as ANSI. If 
//      your WndProc assumes Unicode you'll have to convert to/from Unicode
//      as appropriate.
//      You should not call this wrapper on Windows NT except when emulating
//      Windows 9x behavior for testing puposes.
//      See README.HTM for more on this.
// 
///////////////////////////////////////////////////////////////////////////////////
ATOM WINAPI RegisterClassExAU(CONST WNDCLASSEXW *lpWcw)
{
    
	if ( ISNT() )
	{
		return RegisterClassExW( lpWcw );
	}

	USES_CONVERSION;
	
	WNDCLASSEXA wca                  ;

    // Set up ANSI version of class struct
    wca.cbSize       = sizeof(WNDCLASSEXA)  ;
    wca.cbClsExtra   = lpWcw->cbClsExtra    ;
    wca.cbWndExtra   = lpWcw->cbWndExtra    ;
    wca.hbrBackground= lpWcw->hbrBackground ;
    wca.hCursor      = lpWcw->hCursor       ;
    wca.hIcon        = lpWcw->hIcon         ;
    wca.hIconSm      = lpWcw->hIconSm       ;
    wca.hInstance    = lpWcw->hInstance     ;
    wca.lpfnWndProc  = lpWcw->lpfnWndProc   ;
    wca.style        = lpWcw->style         ;

	// Make sure we have a class name
    if( NULL == lpWcw->lpszClassName ) 
	{
        return 0 ;
    }
	
	// Convert the class name to unicode or cast atom
	if ( ISATOM( lpWcw->lpszClassName ) )
	{
		wca.lpszClassName = ( LPSTR ) lpWcw->lpszClassName; //Simply cast it
	}
	else if ( (wca.lpszClassName = W2A( lpWcw->lpszClassName )) == NULL )
	{		
		return 0;
	}

    //Convert the menu name
	if ( ISATOM( lpWcw->lpszMenuName) )
	{
		wca.lpszMenuName = ( LPSTR ) lpWcw->lpszMenuName; //Simply cast it
	}
	else if ( (wca.lpszMenuName = W2A( lpWcw->lpszMenuName )) == NULL )
	{		
		return 0;
	}

    return RegisterClassExA(&wca) ; // Register class as ANSI
}


///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegisterClass Ex(CONST WNDCLASSW *lpWcw) 
//
//  PURPOSE:  Wrapper over RegisterClassA that mimics RegisterClassW
//
//  Comments: 
//      This is an important wrapper function; if you call this function,
//      any window that you create with this class name will be an ANSI 
//      window, i.e., it will receive text from the system as ANSI. If 
//      your WndProc assumes Unicode you'll have to convert to/from Unicode
//      as appropriate.
//      You should not call this wrapper on Windows NT except when emulating
//      Windows 9x behavior for testing puposes.
//      See README.HTM for more on this.
// 
///////////////////////////////////////////////////////////////////////////////////
ATOM WINAPI RegisterClassAU(CONST WNDCLASSW *lpWcw)
{
    
	if ( ISNT() )
	{
		return RegisterClassW( lpWcw );
	}

	USES_CONVERSION;

	WNDCLASSA wca                  ;


    // Set up ANSI version of class struct
    wca.cbClsExtra   = lpWcw->cbClsExtra    ;
    wca.cbWndExtra   = lpWcw->cbWndExtra    ;
    wca.hbrBackground= lpWcw->hbrBackground ;
    wca.hCursor      = lpWcw->hCursor       ;
    wca.hIcon        = lpWcw->hIcon         ;
    wca.hInstance    = lpWcw->hInstance     ;
    wca.lpfnWndProc  = lpWcw->lpfnWndProc   ;
    wca.style        = lpWcw->style         ;

	// Make sure we have a class name
    if( NULL == lpWcw->lpszClassName ) 
	{
        return 0 ;
    }
	
	// Convert the class name to unicode or cast atom
	if ( ISATOM( lpWcw->lpszClassName ) )
	{
		wca.lpszClassName = ( LPSTR ) lpWcw->lpszClassName; //Simply cast it
	}
	else if ( (wca.lpszClassName = W2A( lpWcw->lpszClassName )) == NULL )
	{		
		return 0;
	}
	
	//Convert the menu name
	if ( ISATOM( lpWcw->lpszMenuName) )
	{
		wca.lpszMenuName = ( LPSTR ) lpWcw->lpszMenuName; //Simply cast it
	}
	else if ( (wca.lpszMenuName = W2A( lpWcw->lpszMenuName )) == NULL )
	{		
		return 0;
	}
     

    return RegisterClassA(&wca) ; // Register class as ANSI
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CreateWindowExAU(DWORD, LPCWSTR, LPCWSTR, DWORD, int, int, 
//                  int, int, HWND, HMENU, HINSTANCE, LPVOID)
//
//  PURPOSE:  Wrapper over CreateWindowExA that mimics CreateWindowExW
//
//  Comments: See Win32 CreateWindowEx for Functionality
//			  TEST if windowname can be null 
///////////////////////////////////////////////////////////////////////////////////
HWND WINAPI CreateWindowExAU(  DWORD	 dwExStyle,      
							   LPCWSTR   lpClassNameW,  
							   LPCWSTR   lpWindowNameW, 
							   DWORD	 dwStyle,        
							   int		 x,                
							   int		 y,                
							   int		 nWidth,           
							   int		 nHeight,          
							   HWND		 hWndParent,      
							   HMENU	 hMenu,          
							   HINSTANCE hInstance,  
							   LPVOID	 lpParam)
{

	if ( ISNT() )
	{
		return CreateWindowExW( dwExStyle, lpClassNameW, lpWindowNameW, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam );
	}

	USES_CONVERSION;
    
	LPSTR szClassNameA  = NULL;					 //Convert to Ansi
    LPSTR szWindowNameA = NULL;					 //Convert to Ansi

	if ( !RW2A( szWindowNameA, lpWindowNameW) )
		return NULL;

	// Convert the class name to unicode or cast atom
	if ( ISATOM( lpClassNameW ) )
	{
		szClassNameA = ( LPSTR ) lpClassNameW; //Simply cast it
	}
	else if ( (szClassNameA = W2A( lpClassNameW )) == NULL )
	{		
		return 0;
	}

	//Call and return the ansi version
    return CreateWindowExA(dwExStyle, szClassNameA, szWindowNameA,
        dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: LoadAcceleratorsAU(HINSTANCE , LPCWSTR )
//
//  PURPOSE:  Wrapper over LoadAcceleratorsA that mimics LoadAcceleratorsW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//  
///////////////////////////////////////////////////////////////////////////////////
HACCEL WINAPI LoadAcceleratorsAU(HINSTANCE hInstance, LPCWSTR lpTableName)
{
	if ( ISNT() )
	{
		return LoadAcceleratorsW( hInstance, lpTableName );
	}

	//Cast and call ansi version
    return LoadAcceleratorsA(hInstance, (LPSTR) lpTableName) ;
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: LoadMenuAU 
//
//  PURPOSE:  Wrapper over LoadMenuA that mimics LoadMenuW
//
//  Comments: 20068719
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
// 
///////////////////////////////////////////////////////////////////////////////////
HMENU  WINAPI LoadMenuAU(HINSTANCE hInstance, LPCWSTR lpwMenuName)
{
	if ( ISNT() )
	{
		return LoadMenuW( hInstance, lpwMenuName );
	}

	//Cast to ansi and call ansi ver
    return LoadMenuA(hInstance, (LPSTR) lpwMenuName) ;
}



///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CreateDialogParam AU 
//
//  PURPOSE:  Wrapper over CreateDialogParamA that mimics CreateDialogParamW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//
///////////////////////////////////////////////////////////////////////////////////
HWND WINAPI CreateDialogParamAU(	HINSTANCE hInstance,     // handle to module
									LPCWSTR lpTemplateName,  // dialog box template
									HWND	hWndParent,         // handle to owner window
									DLGPROC lpDialogFunc,    // dialog box procedure
									LPARAM	dwInitParam       // initialization value
								)
{
	if ( ISNT() )
	{
		return CreateDialogParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
	}

	//Cast and call the ansi ver of the func
    return CreateDialogParamA(hInstance, (LPCSTR) lpTemplateName, 
        hWndParent, lpDialogFunc, dwInitParam);
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: DialogBoxParamAU 
//
//  PURPOSE:  Wrapper over DialogBoxParamA that mimics DialogBoxParamW
//
//  Comments: 
//          This simply casts the resource ID to LPSTR and calls the ANSI
//          version. There is an implicit assumption that the resource ID
//          is a constant integer < 64k, rather than the address of a string
//          constant. This DOES NOT WORK if this assumption is false.
//
///////////////////////////////////////////////////////////////////////////////////
int WINAPI DialogBoxParamAU( HINSTANCE	hInstance   ,
							 LPCWSTR	lpTemplateName,
							 HWND		hWndParent       ,
							 DLGPROC	lpDialogFunc  ,
							 LPARAM		dwInitParam
						    )
{

	if ( ISNT() )
	{
		return DialogBoxParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
	}
	
	//Cast and call the ansi ver of the func
    return DialogBoxParamA(hInstance, (LPCSTR) lpTemplateName, 
        hWndParent, lpDialogFunc, dwInitParam) ;
}




///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CharUpperAU
//
//  PURPOSE:  Wrapper over CharUpperA that mimics CharUpperW
//
//  Comments: 
//           This function converts a Unicode string to Uppercase in the dumbest way possible 
//           on Windows 9x. You could make this a lot more fancy, to handle multi-script text,
//           for example, but for our purposes it works fine.
//
///////////////////////////////////////////////////////////////////////////////////


LPWSTR WINAPI CharUpperAU(	LPWSTR lpsz   // single character or pointer to string
						 )
{

	if ( ISNT() )
	{
		return CharUpperW( lpsz );
	}

	USES_CONVERSION;
    
	if( !(0xFFFF0000 & (DWORD) lpsz) ) 
	{
        // Single character, not an address
        WCHAR wcCharOut[2] ;
        
		LPSTR lpChar;
		CHAR  cTemp ;
		
		//Create string
        wcCharOut[0] = (WCHAR) lpsz ;
        wcCharOut[1] = L'\0' ;

		//Convert the character to Ansi
        if( (lpChar = W2A(wcCharOut)) == NULL ) 
		{
            return NULL ;
        }

		//Convert to Upper case
        if(!(cTemp = (CHAR) CharUpperA((LPSTR)lpChar[0]))) 
		{
            return NULL ;
        }
		
		//Convert back to unicode
        if(!MultiByteToWideChar(CP_ACP, 0, &cTemp, 1, wcCharOut, 2)) 
		{    
            return NULL ;
        }
    
        return (LPWSTR) wcCharOut[0] ;
    }
    else 
	{    
		//Convert to Ansi
        LPSTR lpStrOut = W2A( lpsz );
		int nLength    = wcslen(lpsz)+1;
		if( nLength == 1 )
		{
			//Converting an empty string?  Nothing to do.
			return lpsz;
		}

		//Make sure it was successful
		if ( lpStrOut == NULL )
			return NULL;
		
		//Convert to Upper Case
        if(NULL == CharUpperA(lpStrOut)) 
		{
            return NULL ;
        }

		//Convert back to unicode
        if(!MultiByteToWideChar(CP_ACP, 0, lpStrOut, -1, lpsz, nLength)) 
		{    
            return NULL ;
        }

        return lpsz ;
    }
}

///////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CharLower AU
//
//  PURPOSE:  Wrapper over CharLowerA that mimics CharLowerW
//
//  Comments: 
//           This function converts a Unicode string to lowercase in the dumbest way possible 
//           on Windows 9x. You could make this a lot more fancy, to handle multi-script text,
//           for example, but for our purposes it works fine.
//
///////////////////////////////////////////////////////////////////////////////////
LPWSTR WINAPI CharLowerAU(LPWSTR lpsz)
{
	if ( ISNT() )
	{
		return CharLowerW( lpsz );
	}

	USES_CONVERSION;
    
	if( !(0xFFFF0000 & (DWORD) lpsz) ) 
	{
        // Single character, not an address
        WCHAR wcCharOut[2] ;
        
		LPSTR lpChar;
		CHAR  cTemp ;
		
		//Create string
        wcCharOut[0] = (WCHAR) lpsz ;
        wcCharOut[1] = L'\0' ;

		//Convert the character to Ansi
        if( (lpChar = W2A(wcCharOut)) == NULL ) 
		{
            return NULL ;
        }

		//Convert to lower case
        if(!(cTemp = (CHAR) CharLowerA((LPSTR)lpChar[0]))) 
		{
            return NULL ;
        }
		
		//Convert back to unicode
        if(!MultiByteToWideChar(CP_ACP, 0, &cTemp, 1, wcCharOut, 2)) 
		{    
            return NULL ;
        }
    
        return (LPWSTR) wcCharOut[0] ;
    }
    else 
	{    
		//Convert to Ansi
        LPSTR lpStrOut = W2A( lpsz );
		int nLength    = wcslen(lpsz)+1;

		//Make sure it was successful
		if ( lpStrOut == NULL )
			return NULL;
		
		//Convert to lower Case
        if(NULL == CharLowerA(lpStrOut)) 
		{
            return NULL ;
        }

		//Convert back to unicode
        if(!MultiByteToWideChar(CP_ACP, 0, lpStrOut, -1, lpsz, nLength)) 
		{    
            return NULL ;
        }

        return lpsz ;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetTempFileNameAU 
//
//  PURPOSE:  Wrapper over GetTempFileNameA that mimics GetTempFileNameW
//
//  NOTES:    SEE Win32 GetTempFileName for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

UINT WINAPI GetTempFileNameAU(	LPCWSTR lpPathName,      // pointer to directory name for temporary 
														 // file
								LPCWSTR lpPrefixString,  // pointer to file name prefix
								UINT	uUnique,         // number used to create temporary file name
								LPWSTR lpTempFileName    // pointer to buffer that receives the new 
														 // file name
							 )
{

	if ( ISNT() )
	{
		return GetTempFileNameW( lpPathName, lpPrefixString, uUnique, lpTempFileName );
	}

	USES_CONVERSION;

	//Allo string to hold the path
	LPSTR  lpTempFileNameA   = (LPSTR) alloca( MAX_PATH );
	LPSTR  lpPathNameA       = W2A( lpPathName );
	LPSTR  lpPrefixStringA   = W2A( lpPrefixString );

	//Prefix Warning:  Don't dereference possibly NULL pointers
	if( lpPathNameA == NULL || lpTempFileNameA == NULL || lpPrefixStringA == NULL )
	{
		return 0;
	}

	//Call the Ansi version
	UINT uRet = GetTempFileNameA( lpPathNameA, lpPrefixStringA, uUnique, lpTempFileNameA );

	//Convert it to unicode
	if ( uRet != 0 && !StandardAtoU(lpTempFileNameA, MAX_PATH, lpTempFileName ) )
	{
		return 0;
	}

	return uRet;
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: GetTempPathAU 
//
//  PURPOSE:  Wrapper over GetTempPathA that mimics GetTempPathW
//
//  NOTES:    SEE Win32 GetTempPath for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI GetTempPathAU( DWORD  nBufferLength,  // size, in characters, of the buffer
							LPWSTR lpBuffer       // pointer to buffer for temp. path
						  )
{

	if ( ISNT() )
	{
		return GetTempPathW( nBufferLength, lpBuffer );
	}

	//allocate an ansi buffer
	LPSTR lpBufferA = (LPSTR) alloca( BUFSIZE( nBufferLength ) );

	_ASSERT( !(nBufferLength && lpBufferA == NULL) );

	//Make sure everything was allocated ok
	if ( nBufferLength && lpBufferA == NULL )
		return 0;

	//Call the ansi ver
	int iRet = GetTempPathA( BUFSIZE(nBufferLength), lpBufferA );

	//Make sure it was copied successfully..
	//if iRet greater then the buffer size will return the required size
	if ( (DWORD)iRet < BUFSIZE(nBufferLength) )
	{
		//Convert the path to Unicode
		if ( !StandardAtoU( lpBufferA, nBufferLength, lpBuffer ) )
			return 0;
	}

	return iRet;
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: CompareStringAU 
//
//  PURPOSE:  Wrapper over CompareStringA that mimics CompareStringW
//
//  NOTES:    SEE Win32 CompareString for functionality, in addition to listed return codes,
//				can also return ERROR_NOT_ENOUGH_MEMORY.
// 
//////////////////////////////////////////////////////////////////////////////////

int WINAPI CompareStringAU(  LCID	  Locale,        // locale identifier
							 DWORD	  dwCmpFlags,    // comparison-style options
							 LPCWSTR  lpString1,     // pointer to first string
							 int	  cchCount1,     // size, in bytes or characters, of first string
							 LPCWSTR  lpString2,     // pointer to second string
							 int	  cchCount2      // size, in bytes or characters, of second string
						   )
{
	if ( ISNT() )
	{
		return CompareStringW( Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2 );
	}


	USES_CONVERSION;

	int   ncConvert1 = -1;
	int	  ncConvert2 = -1;
	LPSTR lpString1A = NULL; 
	LPSTR lpString2A = NULL; 
	BOOL  bDefault   = FALSE;

	//Convert string to ansi
	if (cchCount1 == -1)			//Check if null terminated, if it is then just do reg conversion
		lpString1A = W2A(lpString1); 
	else //Not null terminated, 
	{
		lpString1A = (LPSTR)alloca( BUFSIZE(cchCount1) );
		ncConvert1 = WideCharToMultiByte(CP_ACP, 0, lpString1, cchCount1, lpString1A, BUFSIZE( cchCount1 ), "?", &bDefault);
		*(lpString1A+ncConvert1)='\0';
	}

	//Convert string to ansi
	if (cchCount2 == -1)
	{
		lpString2A = W2A(lpString2);
	}
	else //Not null terminated
	{
		lpString2A = (LPSTR)alloca( BUFSIZE(cchCount2) );
		if( lpString2A != NULL )
		{
			ncConvert2 = WideCharToMultiByte(CP_ACP, 0, lpString2, cchCount2, lpString2A, BUFSIZE( cchCount2 ), "?", &bDefault);
			*(lpString2A+ncConvert2) = '\0';
		}
	}
	if( lpString1A == NULL || lpString2A == NULL )
	{
		SetLastError( ERROR_NOT_ENOUGH_MEMORY );
		return 0;
	}


	_ASSERT( lpString1A != NULL && lpString2A != NULL );
		
	//Return the ansi version
	return CompareStringA(Locale, dwCmpFlags, lpString1A, ncConvert1, lpString2A, ncConvert2 );
}


////////////////////////////////////
//
//
// ADVAPI32.DLL
//
//
////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegQueryInfoKeyAU 
//
//  PURPOSE:  Wrapper over RegQueryInfoKeyA that mimics RegQueryInfoKeyW
//
//  NOTES:    SEE Win32 RegQueryInfoKey for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegQueryInfoKeyAU(	HKEY    hKey,                // handle to key to query
								LPWSTR  lpClass,           // buffer for class string
								LPDWORD lpcbClass,        // size of class string buffer
								LPDWORD lpReserved,       // reserved
								LPDWORD lpcSubKeys,       // number of subkeys
								LPDWORD lpcbMaxSubKeyLen, // longest subkey name length
								LPDWORD lpcbMaxClassLen,  // longest class string length
								LPDWORD lpcValues,			  // number of value entries
								LPDWORD lpcbMaxValueNameLen,  // longest value name length
								LPDWORD lpcbMaxValueLen,      // longest value data length
								LPDWORD lpcbSecurityDescriptor, // descriptor length
								PFILETIME lpftLastWriteTime     // last write time
							  )
{


	if ( ISNT() )
	{
		return RegQueryInfoKeyW( hKey, lpClass, lpcbClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, 
								 lpcbSecurityDescriptor, lpftLastWriteTime );
	}

	_ASSERT( lpClass == NULL && lpcbClass == NULL ); //Not yet supported...

	return RegQueryInfoKeyA( hKey, NULL, NULL, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues,
							 lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);

}




////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegEnumValueAU 
//
//  PURPOSE:  Wrapper over RegEnumValueA that mimics RegEnumValueW
//
//  NOTES:    SEE Win32 RegEnumValue for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI	RegEnumValueAU(	HKEY	hKey,           // handle to key to query
				 			DWORD	dwIndex,        // index of value to query
							LPWSTR	lpValueName,    // buffer for value string
							LPDWORD lpcbValueName,  // size of value buffer
							LPDWORD lpReserved,     // reserved
							LPDWORD lpType,         // buffer for type code
							LPBYTE	lpData,         // buffer for value data
							LPDWORD lpcbData        // size of data buffer
						   )
{

	if ( ISNT() )
	{
		return RegEnumValueW( hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData );
	}

	USES_CONVERSION;


	_ASSERT( lpcbValueName != NULL && lpValueName != NULL );	

	LPSTR lpValueNameA    = (LPSTR)alloca( BUFSIZE( *lpcbValueName ) );
	DWORD lpcbValueNameA  = BUFSIZE( *lpcbValueName );
	LPSTR lpDataA         = NULL;
	DWORD dwOGBuffer      = lpcbData ? *lpcbData : 0 ;
		
	if ( dwOGBuffer )
	{
		lpDataA = (LPSTR)alloca( dwOGBuffer );

		if ( lpDataA == NULL )
			return UNICODE_ERROR;
	}
	
	//Make sure buffers allocated ok
	if ( lpValueNameA == NULL )
		return UNICODE_ERROR;

	/*
	//Convert the value name
	if ( !RW2A(lpValueNameA, lpValueName) )
		return UNICODE_ERROR;
	*/

	//Call the Ansi version
	LONG lRet = RegEnumValueA( hKey, dwIndex, lpValueNameA, &lpcbValueNameA, lpReserved, lpType, (LPBYTE)lpDataA, lpcbData );
	if ( lRet != ERROR_SUCCESS )
		return lRet;

	//Convert the ValueName
	if ( !(*lpcbValueName = StandardAtoU(lpValueNameA, *lpcbValueName, lpValueName )) )
		return UNICODE_ERROR;


	if ( lpcbData ) //Only go in if there's data to convert
	{

		switch ( *lpType ) //Take appropriate action as needed by the type
		{
			case REG_MULTI_SZ: //Array of null terminated strings
			
				//Simply call the multibyte function		
				if ( !MultiByteToWideChar(CP_ACP, 0, lpDataA, *lpcbData, (LPWSTR)lpData, dwOGBuffer) )
					return UNICODE_ERROR;
				break;
			case REG_SZ:
			case REG_EXPAND_SZ:
				//Convert the string to Unicode
				StandardAtoU( lpDataA, dwOGBuffer, (LPWSTR)lpData );
				break;
			default:
				//Simply copy the buffer not a string
				memcpy( lpData, lpDataA, *lpcbData );
		}
	}

	return lRet;
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegQueryValueExAU 
//
//  PURPOSE:  Wrapper over RegQueryValueExA that mimics RegQueryValueExW
//
//  NOTES:    SEE Win32 RegQueryValueEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegQueryValueExAU(	HKEY	hKey,            // handle to key to query
								LPCWSTR lpValueName,  // address of name of value to query
								LPDWORD lpReserved,   // reserved
								LPDWORD lpType,       // address of buffer for value type
								LPBYTE  lpData,        // address of data buffer
								LPDWORD lpcbData      // address of data buffer size
							  )
{

	if ( ISNT() )
	{
		return RegQueryValueExW( hKey, lpValueName, lpReserved, lpType, lpData, lpcbData );
	}


	USES_CONVERSION;


	LPSTR lpDataA		= NULL;				  
	LPSTR lpValueNameA  = W2A( lpValueName ); //Convert the valuename to Ansi
	DWORD dwOGBuffer    =  lpcbData ? *lpcbData : 0;

	//Make sure it converted correctly
	if ( lpValueNameA == NULL )
		return UNICODE_ERROR;

	//Allocate a buffer of the appropriate size
	if ( (dwOGBuffer != 0) && (lpDataA = (LPSTR) alloca( dwOGBuffer ) ) == NULL)	
	{
		return UNICODE_ERROR;
	}

	//Call the ansi version
	LONG lRet = RegQueryValueExA( hKey, lpValueNameA, lpReserved, lpType,(LPBYTE) lpDataA, lpcbData );

	if ( lRet != ERROR_SUCCESS )
		return UNICODE_ERROR;

	if ( dwOGBuffer != 0 ) //Only go in if there's data to convert
	{
		switch ( *lpType ) //Take appropriate action as needed by the type
		{
			case REG_MULTI_SZ: //Array of null terminated strings
			
				//Simply call the multibyte function		
				if ( !MultiByteToWideChar(CP_ACP, 0, lpDataA, *lpcbData, (LPWSTR)lpData, dwOGBuffer) )
					return UNICODE_ERROR;

				break;
			case REG_SZ:
			case REG_EXPAND_SZ:

				//Convert the string to Unicode
				StandardAtoU( lpDataA, dwOGBuffer, (LPWSTR)lpData );

				break;
			default:
				//Simply copy the buffer not a string
				memcpy( lpData, lpDataA, *lpcbData );

		}
	}
	return lRet;
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegEnumKeyExAU 
//
//  PURPOSE:  Wrapper over RegEnumKeyExA that mimics RegEnumKeyExW
//
//  NOTES:    SEE Win32 RegEnumKeyEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegEnumKeyExAU(	HKEY	  hKey,					// handle to key to enumerate
							DWORD	  dwIndex,				// index of subkey to enumerate
							LPWSTR	  lpName,				// address of buffer for subkey name
							LPDWORD   lpcbName,				// address for size of subkey buffer
							LPDWORD   lpReserved,			// reserved
							LPWSTR	  lpClass,				// address of buffer for class string
							LPDWORD	  lpcbClass,			// address for size of class buffer
							PFILETIME lpftLastWriteTime		// address for time key last written to
						   )
{
	if ( ISNT() )
	{
		return RegEnumKeyExW( hKey, dwIndex, lpName, lpcbName, lpReserved, lpClass, lpcbClass, lpftLastWriteTime );
	}


	LPSTR lpNameA = (LPSTR)alloca( BUFSIZE(*lpcbName) );

	_ASSERT( lpNameA != NULL );

	if ( lpNameA == NULL )
		return UNICODE_ERROR;

	_ASSERT( lpClass == NULL && lpcbClass == NULL ); //Not yet used, not converted

	//Call the ansi version
	LONG lRet = RegEnumKeyExA( hKey, dwIndex, lpNameA, lpcbName, lpReserved, NULL, NULL, lpftLastWriteTime );

	if (lRet != ERROR_SUCCESS)
		return lRet;
	
	//Convert the name to Unicode
	if (!StandardAtoU( lpNameA, *lpcbName+2, lpName ) )
		return UNICODE_ERROR;

	return lRet;
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegCreateKeyExAU 
//
//  PURPOSE:  Wrapper over RegCreateKeyExA that mimics RegCreateKeyExW
//
//  NOTES:    SEE Win32 RegCreateKeyEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegCreateKeyExAU(	HKEY	hKey,                // handle to open key
								LPCWSTR lpSubKey,         // subkey name
								DWORD	Reserved,           // reserved
								LPWSTR	lpClass,           // class string
								DWORD	dwOptions,          // special options flag
								REGSAM	samDesired,        // desired security access
								LPSECURITY_ATTRIBUTES lpSecurityAttributes,
								PHKEY	phkResult,          // receives opened handle
								LPDWORD lpdwDisposition   // disposition value buffer
							)
{

	if ( ISNT() )
	{
		return RegCreateKeyExW( hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition );
	}


	USES_CONVERSION;
	
	LPSTR lpSubKeyA = NULL;
	LPSTR lpClassA  = NULL;

	//Convert the subkey
	if ( !RW2A(lpSubKeyA, lpSubKey) || !RW2A(lpClassA, lpClass) ||
        !lpSubKeyA)
		return UNICODE_ERROR;

	//Call and return the ansi version
	return RegCreateKeyExA( hKey, lpSubKeyA, Reserved, lpClassA, dwOptions,
						    samDesired, lpSecurityAttributes, phkResult, 
						    lpdwDisposition);
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegSetValueExAU 
//
//  PURPOSE:  Wrapper over RegSetValueExA that mimics RegSetValueExW
//
//  NOTES:    SEE Win32 RegSetValueEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegSetValueExAU(	HKEY	hKey,        // handle to key to set value for
								LPCWSTR lpValueName, // name of the value to set
								DWORD	Reserved,    // reserved
								DWORD	dwType,      // flag for value type
								CONST	BYTE *lpData,  // address of value data
								DWORD	cbData         // size of value data
							)
{
	if ( ISNT() )
	{
		return RegSetValueExW( hKey, lpValueName, Reserved, dwType, lpData, cbData );
	}


	USES_CONVERSION;

	LPSTR lpValueNameA  = NULL;
	LPSTR lpDataA       = NULL;
	LPSTR szDefault     = "?";
	BOOL  bDefaultUsed  = FALSE;

	//Convert the value name
	if ( !RW2A(lpValueNameA, lpValueName) )
		return UNICODE_ERROR;

	switch ( dwType )	//Take appropriate action as needed by the type
	{
		case REG_MULTI_SZ: //Array of null terminated strings
			
			lpDataA = (LPSTR) alloca( cbData );

			//Simply call the multibyte function		
			if ( !WideCharToMultiByte(CP_ACP, 0, (LPWSTR)lpData, cbData, lpDataA, cbData, 
									 szDefault, &bDefaultUsed) )
				return UNICODE_ERROR;			

			break;
		case REG_SZ:
		case REG_EXPAND_SZ:

			//Convert the string to Ansi
			if ( !RW2A( lpDataA, (LPWSTR)lpData ) )
				return UNICODE_ERROR;
			break;
		default:

			lpDataA = (LPSTR) lpData ;
	}

	//Call and return the ansi version
	return RegSetValueExA( hKey, lpValueNameA, Reserved, dwType, (LPBYTE)lpDataA, cbData );
}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegOpenKeyExAU 
//
//  PURPOSE:  Wrapper over RegOpenKeyExA that mimics RegOpenKeyExW
//
//  NOTES:    SEE Win32 RegOpenKeyEx for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegOpenKeyExAU( HKEY	hKey,         // handle to open key
							LPCWSTR lpSubKey,  // address of name of subkey to open
							DWORD	ulOptions,   // reserved
							REGSAM	samDesired, // security access mask
							PHKEY	phkResult    // address of handle to open key
						  )
{
	if ( ISNT() )
	{
		return RegOpenKeyExW( hKey, lpSubKey, ulOptions, samDesired, phkResult );
	}

	USES_CONVERSION;
	
	LPSTR lpSubKeyA = NULL;

	//Convert the Subkey
	if ( !RW2A(lpSubKeyA, lpSubKey) )
		return UNICODE_ERROR;

	return RegOpenKeyExA( hKey, lpSubKeyA, ulOptions, samDesired, phkResult );

}

////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegDeleteKeyAU 
//
//  PURPOSE:  Wrapper over RegDeleteKeyA that mimics RegDeleteKeyW
//
//  NOTES:    SEE Win32 RegDeleteKey for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegDeleteKeyAU( HKEY	 hKey,         // handle to open key
							LPCWSTR lpSubKey   // name of subkey to delete
						  )
{	
	if ( ISNT() )
	{
		return RegDeleteKeyW( hKey, lpSubKey );
	}

	USES_CONVERSION;
	
	LPSTR lpSubKeyA = NULL;

	if ( !RW2A( lpSubKeyA, lpSubKey) )
		return UNICODE_ERROR;

	return RegDeleteKeyA( hKey, lpSubKeyA );
}


////////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: RegDeleteValueAU 
//
//  PURPOSE:  Wrapper over RegDeleteValueA that mimics RegDeleteValueW
//
//  NOTES:    SEE Win32 RegDeleteValue for functionality
// 
//////////////////////////////////////////////////////////////////////////////////

LONG WINAPI RegDeleteValueAU(	HKEY	hKey,         // handle to key
								LPCWSTR lpValueName   // address of value name
							)
{

	if ( ISNT() )
	{
		return RegDeleteValueW( hKey, lpValueName );
	}

	USES_CONVERSION;
	
	LPSTR lpValueNameA = NULL;

	if ( !RW2A(lpValueNameA, lpValueName) )
		return UNICODE_ERROR;

	return RegDeleteValueA( hKey, lpValueNameA );
}



//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
BOOL WINAPI UpdateUnicodeAPIAU(IN LANGID wCurrentUILang, IN UINT InputCodePage)
{
    SetUIPage	( LangToCodePage(wCurrentUILang)) ;
	SetInputPage( InputCodePage              	) ;
    return TRUE ;
}


//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
BOOL InitUniAnsi(PUAPIINIT pUAInit) 
{
	*(pUAInit->pGetTextFaceU)					= GetTextFaceAU;
	*(pUAInit->pCreateDCU)						= CreateDCAU;
	*(pUAInit->pGetTextMetricsU)				= GetTextMetricsAU;
	*(pUAInit->pCreateFontU)					= CreateFontAU;
	*(pUAInit->pCreateFontIndirectU)			= CreateFontIndirectAU;
	*(pUAInit->pEnumFontFamiliesU)				= EnumFontFamiliesAU;

	*(pUAInit->pPlaySoundU)						= PlaySoundAU;

	*(pUAInit->pShellExecuteU)					= ShellExecuteAU;
	
	*(pUAInit->pChooseFontU)					= ChooseFontAU;
	*(pUAInit->pGetPrivateProfileStringU)	    = GetPrivateProfileStringAU;
	*(pUAInit->pGetProfileStringU)				= GetProfileStringAU;
	*(pUAInit->pCreateFileMappingU)				= CreateFileMappingAU;
	*(pUAInit->pFindFirstChangeNotificationU)	= FindFirstChangeNotificationAU;
	*(pUAInit->pFormatMessageU)					= FormatMessageAU;
	*(pUAInit->plstrcmpU)						= lstrcmpAU;
	*(pUAInit->plstrcatU)						= lstrcatAU;
	*(pUAInit->plstrcpyU)						= lstrcpyAU;
	*(pUAInit->plstrcpynU)				        = lstrcpynAU;
	*(pUAInit->plstrlenU)					    = lstrlenAU;
	*(pUAInit->plstrcmpiU)						= lstrcmpiAU;

	*(pUAInit->pGetStringTypeExU)				= GetStringTypeExAU;
	*(pUAInit->pCreateMutexU)					= CreateMutexAU;
	*(pUAInit->pGetShortPathNameU)				= GetShortPathNameAU;
	*(pUAInit->pCreateFileU)					= CreateFileAU;
	*(pUAInit->pWriteConsoleU)					= WriteConsoleAU;
	*(pUAInit->pOutputDebugStringU)				= OutputDebugStringAU;
	*(pUAInit->pGetVersionExU)					= GetVersionExAU;
	*(pUAInit->pGetLocaleInfoU)					= GetLocaleInfoAU;
	*(pUAInit->pGetDateFormatU)					= GetDateFormatAU;
	*(pUAInit->pFindFirstFileU)					= FindFirstFileAU;
	*(pUAInit->pFindNextFileU)					= FindNextFileAU;
	*(pUAInit->pLoadLibraryExU)					= LoadLibraryExAU;
	*(pUAInit->pLoadLibraryU)					= LoadLibraryAU;
	*(pUAInit->pGetModuleFileNameU)				= GetModuleFileNameAU;
	*(pUAInit->pGetModuleHandleU)				= GetModuleHandleAU;
	*(pUAInit->pCreateEventU)					= CreateEventAU;
	*(pUAInit->pGetCurrentDirectoryU)			= GetCurrentDirectoryAU;
	*(pUAInit->pSetCurrentDirectoryU)			= SetCurrentDirectoryAU;

	*(pUAInit->pIsDialogMessageU)				= IsDialogMessageAU;
	*(pUAInit->pSystemParametersInfoU)			= SystemParametersInfoAU;
	*(pUAInit->pRegisterWindowMessageU)			= RegisterWindowMessageAU;
	*(pUAInit->pSetMenuItemInfoU)				= SetMenuItemInfoAU;
	*(pUAInit->pGetClassNameU)					= GetClassNameAU;
	*(pUAInit->pInsertMenuU)					= InsertMenuAU;
	*(pUAInit->pIsCharAlphaNumericU)			= IsCharAlphaNumericAU;
	*(pUAInit->pCharNextU)						= CharNextAU;
	*(pUAInit->pDeleteFileU)					= DeleteFileAU;
	*(pUAInit->pIsBadStringPtrU)				= IsBadStringPtrAU;
	*(pUAInit->pLoadBitmapU)					= LoadBitmapAU;
	*(pUAInit->pLoadCursorU)					= LoadCursorAU;
	*(pUAInit->pLoadIconU)						= LoadIconAU;
	*(pUAInit->pLoadImageU)						= LoadImageAU;
	*(pUAInit->pSetPropU)						= SetPropAU;
	*(pUAInit->pGetPropU)						= GetPropAU;
	*(pUAInit->pRemovePropU)					= RemovePropAU;
	*(pUAInit->pGetDlgItemTextU)				= GetDlgItemTextAU;
	*(pUAInit->pSetDlgItemTextU)				= SetDlgItemTextAU;
	*(pUAInit->pSetWindowLongU)					= SetWindowLongAU;
	*(pUAInit->pGetWindowLongU)					= GetWindowLongAU;
	*(pUAInit->pFindWindowU)					= FindWindowAU;
	*(pUAInit->pDrawTextU)						= DrawTextAU;
	*(pUAInit->pDrawTextExU)					= DrawTextExAU;
	*(pUAInit->pSendMessageU)					= SendMessageAU;
	*(pUAInit->pSendDlgItemMessageU)			= SendDlgItemMessageAU;
	*(pUAInit->pSetWindowTextU)					= SetWindowTextAU;
	*(pUAInit->pGetWindowTextU)					= GetWindowTextAU;
	*(pUAInit->pGetWindowTextLengthU)			= GetWindowTextLengthAU;
	*(pUAInit->pLoadStringU)					= LoadStringAU;
	*(pUAInit->pGetClassInfoExU)				= GetClassInfoExAU;
	*(pUAInit->pGetClassInfoU)					= GetClassInfoAU;
	*(pUAInit->pwvsprintfU)						= wvsprintfAU;
	*(pUAInit->pwsprintfU)						= wsprintfAU;
	*(pUAInit->pRegisterClassExU)				= RegisterClassExAU;
	*(pUAInit->pRegisterClassU)					= RegisterClassAU;
	*(pUAInit->pCreateWindowExU)				= CreateWindowExAU;
	*(pUAInit->pLoadAcceleratorsU)				= LoadAcceleratorsAU;
	*(pUAInit->pLoadMenuU)						= LoadMenuAU;
	*(pUAInit->pDialogBoxParamU)				= DialogBoxParamAU;
	*(pUAInit->pCharUpperU)						= CharUpperAU;
	*(pUAInit->pCharLowerU)						= CharLowerAU;
	*(pUAInit->pGetTempFileNameU)				= GetTempFileNameAU;
	*(pUAInit->pGetTempPathU)					= GetTempPathAU;
	*(pUAInit->pCompareStringU)					= CompareStringAU;

	*(pUAInit->pRegQueryInfoKeyU)				= RegQueryInfoKeyAU;
	*(pUAInit->pRegEnumValueU)					= RegEnumValueAU;
	*(pUAInit->pRegQueryValueExU)				= RegQueryValueExAU;
	*(pUAInit->pRegEnumKeyExU)					= RegEnumKeyExAU;
	*(pUAInit->pRegCreateKeyExU)				= RegCreateKeyExAU;
	*(pUAInit->pRegSetValueExU)					= RegSetValueExAU;
	*(pUAInit->pRegOpenKeyExU)					= RegOpenKeyExAU;
	*(pUAInit->pRegDeleteKeyU)					= RegDeleteKeyAU;
	*(pUAInit->pRegDeleteValueU)				= RegDeleteValueAU;

	*(pUAInit->pConvertMessage)					= ConvertMessageAU;
	*(pUAInit->pUpdateUnicodeAPI)				= UpdateUnicodeAPIAU;
	

    return TRUE ;
}



//  Utility functions taken from 1998 Microsoft Systems Journal
//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 

//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
int StandardUtoA( IN LPCWSTR lpwStrIn  , 
				  IN int nOutBufferSize, 
				  OUT LPSTR lpStrOut
				)
{
    int  nNumCharsConverted   ;
    CHAR szDefault[] = "?"    ;
    BOOL bDefaultUsed = FALSE ;

    nNumCharsConverted =
        WideCharToMultiByte(CP_ACP, 0, lpwStrIn, -1, lpStrOut, nOutBufferSize, 
            szDefault, &bDefaultUsed) ;

	_ASSERT( nNumCharsConverted );

    if(!nNumCharsConverted) 
	{
        return 0 ;
    }

    if(lpStrOut[nNumCharsConverted - 1])
        if(nNumCharsConverted < nOutBufferSize)
            lpStrOut[nNumCharsConverted] = '\0';
        else
            lpStrOut[nOutBufferSize - 1] = '\0';

    return (nNumCharsConverted) ; 
}



//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
int StandardAtoU( IN  LPCSTR lpInStrA    ,
				  IN  int    nBufferSize ,
				  OUT LPWSTR lpOutStrW
				)
{
	int  nNumCharsConverted  = 0;

	nNumCharsConverted = MultiByteToWideChar(CP_ACP, 0, lpInStrA, -1, lpOutStrW, nBufferSize) ;

	_ASSERT( nNumCharsConverted );

	if ( nNumCharsConverted )
		lpOutStrW[nNumCharsConverted-1] = L'\0' ; 

    return nNumCharsConverted;
}



// Utility functions

//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
BOOL CopyLfwToLfa(IN LPLOGFONTW lpLfw, OUT LPLOGFONTA lpLfa)
{
    lpLfa->lfCharSet       = lpLfw->lfCharSet       ;
    lpLfa->lfClipPrecision = lpLfw->lfClipPrecision ;
    lpLfa->lfEscapement    = lpLfw->lfEscapement    ;
    lpLfa->lfHeight        = lpLfw->lfHeight        ;
    lpLfa->lfItalic        = lpLfw->lfItalic        ;
    lpLfa->lfOrientation   = lpLfw->lfOrientation   ;
    lpLfa->lfOutPrecision  = lpLfw->lfOutPrecision  ;
    lpLfa->lfPitchAndFamily= lpLfw->lfPitchAndFamily;
    lpLfa->lfQuality       = lpLfw->lfQuality       ;
    lpLfa->lfStrikeOut     = lpLfw->lfStrikeOut     ;
    lpLfa->lfUnderline     = lpLfw->lfUnderline     ;
    lpLfa->lfWeight        = lpLfw->lfWeight        ;
    lpLfa->lfWidth         = lpLfw->lfWidth         ;

    if(NULL != lpLfw->lfFaceName) 
	{
        return (BOOL) StandardUtoA(lpLfw->lfFaceName, LF_FACESIZE, lpLfa->lfFaceName) ;
    }

    // Fail the call if lpLfw has no buffer for the facename. 
    return FALSE ;
}


//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
BOOL CopyLfaToLfw(IN LPLOGFONTA lpLfa, OUT LPLOGFONTW lpLfw)
{
    lpLfw->lfCharSet       = lpLfa->lfCharSet       ;
    lpLfw->lfClipPrecision = lpLfa->lfClipPrecision ;
    lpLfw->lfEscapement    = lpLfa->lfEscapement    ;
    lpLfw->lfHeight        = lpLfa->lfHeight        ;
    lpLfw->lfItalic        = lpLfa->lfItalic        ;
    lpLfw->lfOrientation   = lpLfa->lfOrientation   ;
    lpLfw->lfOutPrecision  = lpLfa->lfOutPrecision  ;
    lpLfw->lfPitchAndFamily= lpLfa->lfPitchAndFamily;
    lpLfw->lfQuality       = lpLfa->lfQuality       ;
    lpLfw->lfStrikeOut     = lpLfa->lfStrikeOut     ;
    lpLfw->lfUnderline     = lpLfa->lfUnderline     ;
    lpLfw->lfWeight        = lpLfa->lfWeight        ;
    lpLfw->lfWidth         = lpLfa->lfWidth         ;

    if(NULL != lpLfa->lfFaceName) {
        return StandardAtoU(lpLfa->lfFaceName, LF_FACESIZE, lpLfw->lfFaceName) ;
    }

    return TRUE ;
}


//
//  FUNCTION: 
//
//  PURPOSE:  
//
//  Comments: 
// 
UINT LangToCodePage(IN LANGID wLangID)
{
    CHAR szLocaleData[6] ;

    GetLocaleInfoA(wLangID , LOCALE_IDEFAULTANSICODEPAGE, szLocaleData, 6);

    return strtoul(szLocaleData, NULL, 10);
}



// Win32 entry points that have the same prototype for both the W and A versions.
// We don't use a typedef because we only have to declare the pointers here
HRESULT WINAPI DefWindowProcAU(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if ( ISNT() )
	{
		return DefWindowProcW( hwnd, uMsg, wParam, lParam );
	}

	return DefWindowProcA( hwnd, uMsg, wParam, lParam );
}			

LONG    WINAPI DispatchMessageAU(CONST MSG * Msg)										
{
	if ( ISNT() )
	{
		return DispatchMessageW( Msg );
	}
	return DispatchMessageA( Msg );
}			

BOOL    WINAPI GetMessageAU(LPMSG lpMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax)							
{
	if ( ISNT() )
	{
		return GetMessageW( lpMsg, hwnd, wMsgFilterMin, wMsgFilterMax );
	}
	return GetMessageA( lpMsg, hwnd, wMsgFilterMin, wMsgFilterMax );
}
			
INT     WINAPI TranslateAcceleratorAU(HWND hWnd, HACCEL hAccel, LPMSG lpMsg)								
{
	if ( ISNT() )
	{
		return TranslateAcceleratorW( hWnd, hAccel, lpMsg );
	}
	return TranslateAcceleratorA( hWnd, hAccel, lpMsg );
}			

INT	    WINAPI GetObjectAU(HGDIOBJ hgdiobj, INT cbBuffer, LPVOID lpvObject  )								
{
	if ( ISNT() )
	{
		return GetObjectW( hgdiobj, cbBuffer, lpvObject );
	}

	return GetObjectA( hgdiobj, cbBuffer, lpvObject );
}			

HACCEL  WINAPI CreateAcceleratorTableAU(LPACCEL lpaccl, INT cEntries)										
{
	if ( ISNT() )
	{
		return CreateAcceleratorTableW( lpaccl, cEntries );
	}
	return CreateAcceleratorTableA( lpaccl, cEntries );
}			

HHOOK   WINAPI SetWindowsHookExAU(INT idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId)					
{
	if ( ISNT() )
	{
		return SetWindowsHookExW( idHook, lpfn, hMod, dwThreadId );
	}
	return SetWindowsHookExA( idHook, lpfn, hMod, dwThreadId );
}			

HWND	WINAPI CreateDialogIndirectParamAU(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lParamInit)	
{
	if ( ISNT() )
	{
		return CreateDialogIndirectParamW( hInstance, lpTemplate, hWndParent, lpDialogFunc, lParamInit );
	}
	return CreateDialogIndirectParamA( hInstance, lpTemplate, hWndParent, lpDialogFunc, lParamInit );
}			

BOOL WINAPI PeekMessageAU(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)						
{
	if ( ISNT() )
	{
		return PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
	}
	return PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}			

BOOL	WINAPI PostThreadMessageAU(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)						
{
	if ( ISNT() )
	{
		return PostThreadMessageW(idThread, Msg, wParam, lParam);
	}
	return PostThreadMessageA(idThread, Msg, wParam, lParam);
}			

BOOL	WINAPI PostMessageAU(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam)								
{
	if ( ISNT() )
	{
		return PostMessageW( hwnd, Msg, wParam, lParam);
	}

	return PostMessageA( hwnd, Msg, wParam, lParam);
}			



int WINAPI DialogBoxAU(HINSTANCE hInstance, LPCWSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc)
{
	if ( ISNT() )
	{
		return DialogBoxW(hInstance, lpTemplate, hWndParent, lpDialogFunc);
	}

	return DialogBoxParamAU(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
}
   
HWND WINAPI CreateWindowAU( LPCWSTR lpClassName,  // pointer to registered class name
				   LPCWSTR lpWindowName, // pointer to window name
				   DWORD  dwStyle,        // window style
				   int    x,                // horizontal position of window
				   int	  y,                // vertical position of window
				   int    nWidth,           // window width
				   int    nHeight,          // window height
				   HWND   hWndParent,      // handle to parent or owner window
				   HMENU  hMenu,          // menu handle or child identifier
				   HINSTANCE hInstance,     // handle to application instance
				   LPVOID lpParam        // window-creation data
				 )
{
	if ( ISNT() )
	{
		return CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
	}
	return CreateWindowExAU(0L, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}


LRESULT WINAPI CallWindowProcAU(FARPROC wndProc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)				
{
	if ( ISNT() )
	{
		return CallWindowProcW(wndProc, hWnd, Msg, wParam, lParam);
	}

	return CallWindowProcA(wndProc, hWnd, Msg, wParam, lParam);
}			

ATOM AddAtomAU( LPCWSTR lpString )
{
    if ( ISNT() )
    {
        return AddAtomW(lpString);
    }

	USES_CONVERSION;

	LPSTR lpStringA = NULL;

	if ( !RW2A( lpStringA, lpString ) || !lpStringA )
	{
        SetLastError(ERROR_OUTOFMEMORY);
		return 0;
	}

	return AddAtomA( lpStringA );
}


#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\plugnplay.h ===
#ifndef __PLUGNPLAY_H
#define __PLUGNPLAY_H

#include <zDialogImpl.h>

#pragma once

#include "ClientIdl.h"
#include "LobbyDataStore.h"
#include "EventQueue.h"
#include "ZoneEvent.h"
#include "Timer.h"
#include "ZoneShell.h"
#include "ResourceManager.h"
#include "accessibilitymanager.h"

// IPaneManager ID_UNUSED_BY_RES instructions
enum
{
    PNP_COMFORT_OFF,
    PNP_COMFORT_ON
};

enum
{
    PaneSplashSplash,
    PaneSplashAbout
};

enum
{
    PaneGameOverSwap,
    PaneGameOverUserState
};

enum
{
    PaneConnectingConnecting,
    PaneConnectingLooking,
    PaneConnectingStop,
    PaneConnectingFrame
};

enum
{
    PaneIENavigate,
    PaneIEFocus,
    PaneIEUnfocus
};


interface IPaneManager;

// damn it, this is so messed up now, these needed to be made COM to begin with.  this whole thing needs to be seperated from WindowManager
interface IPane
{
	STDMETHOD(FirstCall)(IPaneManager * pMgr)=0;
    STDMETHOD(LastCall)()=0;
    STDMETHOD(Delete)()=0;

    STDMETHOD(CreatePane)(HWND hwnd,LPARAM dwInitParam)=0;
    STDMETHOD(DestroyPane)()=0;

	STDMETHOD(GetWindowPane)(HWND *phwnd)=0;

	STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)=0;

//    STDMETHOD(MovePane)(RECT &rect)=0;
//    STDMETHOD(ShowPane)(int nCmdShow)=0;
//    STDMETHOD(GetPaneRect)(RECT &rect)=0;

    STDMETHOD(GetSuggestedSize)(LPSIZE pze)=0;
};

interface IPaneManager
{
	STDMETHOD(Input)(IPane * pPane, LONG id, LONG value, TCHAR * szText)=0;

    STDMETHOD(RegisterHWND)(IPane *pPane, HWND hWnd)=0;
    STDMETHOD(UnregisterHWND)(IPane *pPane, HWND hWnd)=0;

    STDMETHOD_(IZoneShell*, GetZoneShell)() = 0;
	STDMETHOD_(IResourceManager*, GetResourceManager)() = 0;
	STDMETHOD_(ILobbyDataStore*, GetLobbyDataStore)() = 0;
	STDMETHOD_(ITimerManager*, GetTimerManager)() = 0;
	STDMETHOD_(IDataStoreManager*, GetDataStoreManager)() = 0;
	STDMETHOD_(IDataStore*, GetDataStoreConfig)() = 0;
	STDMETHOD_(IDataStore*, GetDataStoreUI)() = 0;
	STDMETHOD_(IDataStore*, GetDataStorePreferences)() = 0;
	STDMETHOD_(IEventQueue*, GetEventQueue)() = 0;

	//STDMETHOD(GetKey)() // used by panes to get settings for various values
};


template <class T>
class CPaneImpl :
    public IPane,
    public IAccessibleControl,
    public ZDialogImpl<T>,
    public CComObjectRootEx<CComSingleThreadModel>
{
protected:
    IPaneManager *m_pMgr;
    CSize m_ze;
    CComPtr<IAccessibility> m_pIAcc;
    bool m_fDestroyed;

public:
    CPaneImpl() : m_ze(0, 0), m_pMgr(NULL), m_fDestroyed(true) { }

BEGIN_MSG_MAP(CPaneImpl<T>)
    COMMAND_CODE_HANDLER(BN_SETFOCUS, OnButtonSetFocus)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
END_MSG_MAP()

BEGIN_COM_MAP(CPaneImpl<T>)
	COM_INTERFACE_ENTRY(IAccessibleControl)
END_COM_MAP()

DECLARE_WND_CLASS(_T("PlugNPlayPane"))

    LRESULT OnButtonSetFocus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if(!m_pIAcc)
            return 0;

        DWORD rgfWantNot = 0;

        if(wID == GetFirstItem())
            rgfWantNot |= ZACCESS_WantShiftTab;

        if(wID == GetLastItem())
            rgfWantNot |= ZACCESS_WantPlainTab;

        m_pIAcc->SetFocus(0);
        m_pIAcc->SetItemWantKeys(ZACCESS_WantAllKeys & ~rgfWantNot, 0);
        return 0;
    }


	LRESULT OnPaletteChanged(UINT nMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)
	{
        HWND hWnd = GetWindow(GW_CHILD);
		while(hWnd)
		{
		    ::SendMessage(hWnd, nMsg, wParam, lParam);
			hWnd = ::GetWindow(hWnd, GW_HWNDNEXT);
		}

        return 0;
    }


    STDMETHOD_(DWORD, GetFirstItem)() { return -1; }
    STDMETHOD_(DWORD, GetLastItem)() { return -1; }

	STDMETHOD(FirstCall)(IPaneManager *pMgr)
	{
	    m_pMgr = pMgr;

	    return S_OK;
	}


    STDMETHOD(CreatePane)(HWND hWndParent,LPARAM dwInitParam)
    {
        ATLASSERT(m_hWnd == NULL);
        ATLASSERT(m_fDestroyed);
        m_fDestroyed = false;
    	HWND hWnd ;
        hWnd = Create(hWndParent,dwInitParam);
        SetClassLong(hWnd, GCL_HBRBACKGROUND, (LONG) GetStockObject(NULL_BRUSH));

        LONG lStyle = GetWindowLong(GWL_STYLE);
        lStyle |= WS_CLIPCHILDREN;
        SetWindowLong(GWL_STYLE, lStyle);
        RECT dummy = { 0, 0, 0, 0 };
        SetWindowPos(HWND_NOTOPMOST, &dummy, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

    	if(hWnd)
    	    return S_OK;
    	else
    	    return E_FAIL;
	}


	STDMETHOD(GetWindowPane)(HWND *phwnd)
	{
	    *phwnd = m_hWnd;
	    return S_OK;
	}


    STDMETHOD(DestroyPane)()
    {
        if(m_fDestroyed)
            return S_FALSE;
        m_fDestroyed = true;

        m_pMgr->GetEventQueue()->PostEvent(PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) m_hWnd, 0);
	    return S_OK;
	}


    STDMETHOD(LastCall)()
    {
	    return S_OK;
	}


    STDMETHOD(Delete)()
    {
        T* pT = static_cast<T*>(this);
        delete pT;
        return S_OK;
    }


    STDMETHOD(StatusUpdate)(LONG code, LONG id, TCHAR *text)
    {
	    return S_OK;
	}


    STDMETHOD(GetSuggestedSize)(LPSIZE pze)
    {
        *pze = m_ze;
        return S_OK;
    }

private:
    static BOOL CALLBACK EnumChildrenProc(HWND hWnd, LPARAM lParam)
    {
        if(hWnd == (HWND) lParam)
            return true;

        LRESULT lr = ::SendMessage(hWnd, WM_GETDLGCODE, 0, NULL);
        if(lr & DLGC_DEFPUSHBUTTON)
            ::SendMessage(hWnd, BM_SETSTYLE, BS_PUSHBUTTON, TRUE);

        return true;
    }

// IAccessibleControl
public:
    STDMETHOD_(DWORD, Focus)(long nIndex, long nIndexPrev, DWORD rgfContext, void *pvCookie)
    {
        if(nIndex == ZACCESS_InvalidItem)
        {
            LRESULT lr = SendMessage(DM_GETDEFID, 0, 0);
            if(HIWORD(lr) == DC_HASDEFID)
            {
                EnumChildWindows(m_hWnd, (WNDENUMPROC) EnumChildrenProc, (LPARAM) GetDlgItem(LOWORD(lr)));
                SendDlgItemMessage(LOWORD(lr), BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);
            }
        }

        if(nIndex != 0)
            return 0;

        if(rgfContext & ZACCESS_ContextTabForward)
        {
            SuperGotoDlgControl(GetFirstItem());
            return 0;
        }

        if(rgfContext & ZACCESS_ContextTabBackward)
        {
            SuperGotoDlgControl(GetLastItem());
            return 0;
        }

        // if focus is already on something, let it stay
        HWND hWnd = ::GetFocus();
        if(hWnd && ::GetParent(hWnd) == m_hWnd)
            return 0;

        LRESULT lr = SendMessage(DM_GETDEFID, 0, 0);
        if(HIWORD(lr) == DC_HASDEFID) 
            SuperGotoDlgControl(LOWORD(lr));
        else
            SuperGotoDlgControl(GetFirstItem());

        return 0;
    }

    STDMETHOD_(DWORD, Select)(long nIndex, DWORD rgfContext, void *pvCookie)
    {
        return 0;
    }

    STDMETHOD_(DWORD, Activate)(long nIndex, DWORD rgfContext, void *pvCookie)
    {
        return 0;
    }

    STDMETHOD_(DWORD, Drag)(long nIndex, long nIndexOrig, DWORD rgfContext, void *pvCookie)
    {
        return 0;
    }


protected:
    void SuperGotoDlgControl(DWORD wID)
    {
        HWND hWnd = GetDlgItem(wID);
        if(::GetFocus() != hWnd)
            PostMessage(WM_NEXTDLGCTL, (WPARAM) hWnd, (WORD) TRUE);
    }

    void SetSugSizeFromCurSize()
    {
        CRect rcDialog;

        if(!m_hWnd)
            m_ze.cx = m_ze.cy = 0;
        else
        {
            GetWindowRect(&rcDialog);
            m_ze = rcDialog.Size();
        }
    }

    BOOL SuperScreenToClient(LPRECT lpRect)
    {
        BOOL ret;
        ret = ScreenToClient(lpRect);
        if(ret && lpRect->left > lpRect->right)
        {
            lpRect->left ^= lpRect->right;
            lpRect->right ^= lpRect->left;
            lpRect->left ^= lpRect->right;
        }
        return ret;
    }

    void Register()
    {
        if(m_pMgr && m_hWnd)
        {
            m_pMgr->RegisterHWND(this, m_hWnd);

            if(GetParent() && T::AccOrdinal != -1)
            {
                if(m_pIAcc)
                    m_pIAcc.Release();
                HRESULT hr = m_pMgr->GetZoneShell()->QueryService(SRVID_AccessibilityManager, IID_IAccessibility, (void **) &m_pIAcc);
                if(SUCCEEDED(hr))
                {
                    ACCITEM o;
                    CopyACC(o, ZACCESS_DefaultACCITEM);
                    o.rgfWantKeys = ZACCESS_WantAllKeys;

                    m_pIAcc->InitAcc(this, T::AccOrdinal, NULL);
                    m_pIAcc->PushItemlist(&o, 1);
                    m_pIAcc->SetFocus(0);
                }
            }
        }
    }

    void Unregister()
    {
        if(m_pIAcc)
        {
            m_pIAcc->CloseAcc();
            m_pIAcc.Release();
        }

        if(m_pMgr && m_hWnd)
            m_pMgr->UnregisterHWND(this, m_hWnd);
    }
};

class CPlugNPlayWindow;

class CPlugNPlay
{
public:
    CPlugNPlay() : m_pCurrentPlug(NULL), m_pCurrentPlay(NULL), m_pPNP(NULL), m_cyTopMargin(0), m_cyBottomMargin(0),
        m_nBlockCount(0), m_fPostponedShow(false), m_pPostPlug(NULL), m_pPostPlay(NULL), m_hIcon(NULL), m_hIconSm(NULL)
    {
        m_rcPlug.SetRectEmpty();
        m_rcPlay.SetRectEmpty();
        m_rcPNP.SetRectEmpty();
    }

    ~CPlugNPlay()
    {
        if(m_hIcon)
            DestroyIcon(m_hIcon);
        m_hIcon = NULL;

        if(m_hIconSm)
            DestroyIcon(m_hIconSm);
        m_hIconSm = NULL;
    }

	CRect m_rcPlug;	// location of plug window
	CRect m_rcPlay;	// location of play window
	CRect m_rcPNP;	// size of plug and play window

    // positioning guidelines
    long m_cyTopMargin;
    long m_cyBottomMargin;

	//Current active
	IPane *m_pCurrentPlug;
	IPane *m_pCurrentPlay;

    // ZoneShell
    CComPtr<IZoneShell> m_pZoneShell;

	CPlugNPlayWindow *m_pPNP;		// plug n play dialog

    HICON m_hIcon;
    HICON m_hIconSm;

    DWORD m_nBlockCount;
    bool m_fPostponedShow;
    IPane *m_pPostPlug;
    IPane *m_pPostPlay;

    HRESULT Init(IZoneShell *pZoneShell);
    HRESULT CreatePNP(HWND hWndParent, LPCTSTR szTitle = NULL, long cyTopMargin = 0, long cyBottomMargin = 0);
    HRESULT DestroyPNP();
    HRESULT SetPlugAndOrPlay(IPane *pPlug, IPane *pPlay);
    HRESULT Show(int cmd);
    HRESULT Close();
    LRESULT TransferMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);

    HRESULT RePosition();
    BOOL RecalcLayout();
    HRESULT ImplementLayout(BOOL fRepaint);

    void Block();
    void Unblock();

    HRESULT CreateSplashPane(IPane **ppPane);
    HRESULT CreateIEPane(IPane **ppPane);
    HRESULT CreateComfortPane(IPane **ppPane);
    HRESULT CreateConnectingPane(IPane **ppPane);
    HRESULT CreateGameOverPane(IPane **ppPane);
    HRESULT CreateErrorPane(IPane **ppPane);
    HRESULT CreateAboutPane(IPane **ppPane);
    HRESULT CreateCreditsPane(IPane **ppPane);
    HRESULT CreateLeftPane(IPane **ppPane);
};


HRESULT CreatePlugNPlayWindow(HWND hWndParent, HPALETTE hPal, HICON hIcon, HICON hIconSm, LPCTSTR szTitle, CPlugNPlayWindow **ppWindow);


inline BOOL MoveWindow(HWND hWnd,LPCRECT lpRect, BOOL bRepaint = TRUE)
{
	ATLASSERT(::IsWindow(hWnd));
	return ::MoveWindow(hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
}


#endif //PLUGNPLAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\shellm.h ===
#ifndef __SHELLM_H
#define __SHELLM_H

/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 *****************************************************************************/

#pragma once

#define MS_STATE1 	1
#define MS_STATE2 	2
#define MS_STATE3 	3




#endif __SHELLM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\windowmanager.cpp ===
// WindowManager.cpp : Implementation of CWindowManager


#include "stdafx.h"
#include "ClientIDL.h"
#include "WindowManager.h"


/////////////////////////////////////////////////////////////////////////////
// CWindowManager

LRESULT CWindowManager::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    AtlAxWinInit();

    //FYI here are the base unit calculations 
	LONG units = GetDialogBaseUnits();
	WORD vert= HIWORD(units);
	WORD horiz= LOWORD(units);

    // find out some important dimensions
	const TCHAR* arKeys[] = { key_WindowManager, key_GameSize };
    hr = DataStoreUI()->GetPOINT(arKeys, 2, &m_ptGameSize);
	if(FAILED(hr))
		return hr;

    arKeys[1] = key_ChatMinHeight;
    hr = DataStoreUI()->GetLong(arKeys, 2, &m_nChatMinHeight);
	if(FAILED(hr))
		return hr;

    // create plygnplay
    TCHAR szTitle[ZONE_MAXSTRING];
    TCHAR szFormat[ZONE_MAXSTRING];
    TCHAR szName[ZONE_MAXSTRING];

    // make window title
    if(!ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName)))
        lstrcpy(szName, TEXT("Zone"));
    if(!ResourceManager()->LoadString(IDS_WINDOW_TITLE, szFormat, NUMELEMENTS(szFormat)))
        lstrcpy(szFormat, TEXT("%1"));
    if(!ZoneFormatMessage(szFormat, szTitle, NUMELEMENTS(szTitle), szName))
        lstrcpy(szTitle, szName);
    hr = m_pnp.Init(ZoneShell());
    if(FAILED(hr))
    {
        return -1;
    }
    hr = m_pnp.CreatePNP(NULL, szTitle);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}


    // Create panes
    hr = m_pnp.CreateSplashPane(&m_pPlugSplash);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    // Create panes
    // IE created later
    m_pPlugIE = NULL;

    hr = m_pnp.CreateComfortPane(&m_pPlayComfort);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateConnectingPane(&m_pPlayConnecting);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateGameOverPane(&m_pPlayGameOver);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateErrorPane(&m_pPlayError);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateAboutPane(&m_pPlayAbout);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateCreditsPane(&m_pPlayCredits);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr = m_pnp.CreateLeftPane(&m_pPlayLeft);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}


    // Initialize panes
	hr = m_pPlugSplash->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    hr=	m_pPlayComfort->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

	hr = m_pPlayConnecting->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

	hr = m_pPlayGameOver->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

	hr = m_pPlayError->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

	hr = m_pPlayAbout->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    // can be disabled
    if(m_pPlayCredits)
    {
	    hr = m_pPlayCredits->FirstCall(this);
	    if (FAILED(hr))
	    {
	        //TODO: message box saying internal error
	        return -1;
	    }
    }

	hr = m_pPlayLeft->FirstCall(this);
	if (FAILED(hr))
	{
	    //TODO: message box saying internal error
	    return -1;
	}

    return 0;
}


HRESULT CWindowManager::CreateControls()
{
    m_fControlsCreated = true;

	CRect rcClient;
	GetClientRect(&rcClient);

	// create our control containers
	// Added clipsiblings because it was causing invalidate problems
	// with info child window on top of other windows - mdm
	m_rcGameContainer = rcClient;
	m_rcGameContainer.bottom = m_rcGameContainer.top + m_ptGameSize.y;
	m_rcChatContainer = rcClient;
	m_rcChatContainer.top = m_rcGameContainer.bottom;

 	m_wndGameContainer.Create( m_hWnd, m_rcGameContainer, _T(""), WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN);
	m_wndChatContainer.Create( m_hWnd, m_rcChatContainer, _T(""), WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN);

    // and create our controls
    CComPtr<IZoneShellClient> pControl;
	HRESULT hr = ZoneShell()->CreateService( SRVID_LobbyGameCtl, IID_IZoneShellClient, (void**) &pControl, GetGroupId());
	if ( SUCCEEDED(hr) )
	{
		ZoneShell()->Attach( SRVID_LobbyGameCtl, pControl );
		m_wndGameContainer.AttachControl(pControl, NULL);
	}
	pControl.Release();

	hr = ZoneShell()->CreateService( SRVID_LobbyChatCtl, IID_IZoneShellClient, (void**) &pControl, GetGroupId());
	if ( SUCCEEDED(hr) )
	{
		ZoneShell()->Attach( SRVID_LobbyChatCtl, pControl );
		m_wndChatContainer.AttachControl(pControl, NULL);
	}
	pControl.Release();

	return S_OK;
}


LRESULT CWindowManager::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // PNP should have been destroyed by EVENT_EXIT_APP
    ASSERT(!m_pnp.m_pPNP);

    // unInitialize panes
	if(m_pPlugSplash)
        m_pPlugSplash->LastCall();

    // can't destroy the IE pane here, happens on EXIT APP

	if(m_pPlayComfort)
        m_pPlayComfort->LastCall();

	if(m_pPlayConnecting)
        m_pPlayConnecting->LastCall();

	if(m_pPlayGameOver)
        m_pPlayGameOver->LastCall();

	if(m_pPlayError)
        m_pPlayError->LastCall();

	if(m_pPlayAbout)
        m_pPlayAbout->LastCall();

	if(m_pPlayCredits)
        m_pPlayCredits->LastCall();

	if(m_pPlayLeft)
        m_pPlayLeft->LastCall();

    m_pnp.Close();
    return false;
}


// IPaneManager
STDMETHODIMP CWindowManager::Input(IPane *pPane, LONG id, LONG value, TCHAR *szText)
{
    switch(id)
    {
        // yes button on comfort user; retry on connect error
        case IDOK:
            if(pPane == m_pPlayComfort || pPane == m_pPlayError)
            {
				EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LAUNCH_ICW, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
                m_pnp.SetPlugAndOrPlay( NULL, m_pPlayConnecting );
            }
            break;

        // quit button everywhere
        case IDCANCEL:
            m_pnp.Show(SW_HIDE);
			EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        // help button everywhere
        case IDHELP:
            EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LAUNCH_HELP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
            break;

        // play again button
        case IDYES:
            if(pPane == m_pPlayGameOver)
            {
                m_pPlayGameOver->StatusUpdate(PaneGameOverSwap, 0, NULL);
				EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_GAME_LOCAL_READY, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
            }
            break;

        // new opponents button
        case IDNO:
            if(pPane == m_pPlayGameOver || pPane == m_pPlayLeft)
            {
				EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );

                m_pnp.SetPlugAndOrPlay(NULL, m_pPlayConnecting);
                m_pPlayConnecting->StatusUpdate(PaneConnectingLooking, 0, NULL);
            }
            break;

        // ok button on about box
        case IDCLOSE:
            if(pPane == m_pPlayAbout || (pPane == m_pPlayCredits && m_pPlayCredits))
		        if(m_pnp.m_pPNP)
			        m_pnp.DestroyPNP();
            break;

        // special one for communicating events not directly from components
        case ID_UNUSED_BY_RES:
            if(pPane == m_pPlayComfort)
            {
                CComPtr<IDataStore> pIDS = DataStorePreferences();
                const TCHAR *rgszKey[] = { key_Lobby, key_SkipOpeningQuestion };

                pIDS->SetLong(rgszKey, 2, value == PNP_COMFORT_OFF ? 1 : 0);
                break;
            }

            // pass the frame number back and forth
            if(pPane == m_pPlayConnecting || pPane == m_pPlayError)
            {
                // tell the error pane what frame to show
                (pPane == m_pPlayError ? m_pPlayConnecting : m_pPlayError)->StatusUpdate(PaneConnectingFrame, value, NULL);
                break;
            }

            // start credits
            if(pPane == m_pPlayAbout)
            {
                m_pnp.SetPlugAndOrPlay(NULL, m_pPlayCredits);
            }
            break;
    }

    return S_OK;
}


STDMETHODIMP CWindowManager::RegisterHWND(IPane *pPane, HWND hWnd)
{
    return ZoneShell()->AddDialog(hWnd);
}


STDMETHODIMP CWindowManager::UnregisterHWND(IPane *pPane, HWND hWnd)
{
    return ZoneShell()->RemoveDialog(hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\windowmanager.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 *****************************************************************************/

#pragma once

#include <ZoneResource.h>       // main symbols
#include <atlctl.h>

#include <ClientImpl.h>
#include "Splitter.h"
#include "plugnplay.h"

//!! find a better home for this
#include <keyname.h>
#include <ZoneString.h>

#include <MillEngine.h>

/*////////////////////////////////////////////////////////////////////////////

The CWindowManager class. 

The Window Manager manages the client area of a Zone lobby. It handles creating the controls for each
"pane" and managing splitter bars between panes.

*/
class ATL_NO_VTABLE CWindowManager : 
    public IPaneManager,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComControl<CWindowManager>,
	public IPersistStreamInitImpl<CWindowManager>,
	public IOleControlImpl<CWindowManager>,
	public IOleObjectImpl<CWindowManager>,
	public IOleInPlaceActiveObjectImpl<CWindowManager>,
	public IViewObjectExImpl<CWindowManager>,
	public IOleInPlaceObjectWindowlessImpl<CWindowManager>,
	public CComCoClass<CWindowManager, &CLSID_WindowManager>,
	public IZoneShellClientImpl<CWindowManager>,
	public IEventClientImpl<CWindowManager>
{
public:

//!! fix these min, max, and initial values for the splitter bars
	CWindowManager() :
		m_rcGameContainer(0,0,0,0),
		m_rcChatContainer(0,0,0,0),
        m_nChatMinHeight(60),
        m_ptGameSize(0, 0),
        m_fControlsCreated(false)
	{
		m_bWindowOnly = TRUE;
		m_bFirstGameStart=TRUE;
	}

    ~CWindowManager()
    {
	    if(m_pPlugSplash)
            m_pPlugSplash->Delete();

        // better have already been destroyed, can't do it here (would need LastCall called on it)
	    ASSERT(!m_pPlugIE);

	    if(m_pPlayComfort)
            m_pPlayComfort->Delete();

	    if(m_pPlayConnecting)
            m_pPlayConnecting->Delete();

	    if(m_pPlayGameOver)
            m_pPlayGameOver->Delete();

	    if(m_pPlayError)
            m_pPlayError->Delete();

	    if(m_pPlayAbout)
            m_pPlayAbout->Delete();

	    if(m_pPlayCredits)
            m_pPlayCredits->Delete();

	    if(m_pPlayLeft)
            m_pPlayLeft->Delete();
    }

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_WND_CLASS( _T("WindowManager") )

BEGIN_COM_MAP(CWindowManager)
	COM_INTERFACE_ENTRY(IZoneShellClient)
	COM_INTERFACE_ENTRY(IEventClient)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

//!! don't need a prop map
BEGIN_PROP_MAP(CWindowManager)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_EVENT_MAP()
    EVENT_HANDLER( EVENT_ACCESSIBILITY_CTLTAB, OnCtlTab );
    EVENT_HANDLER( EVENT_LOBBY_COMFORT_USER, OnLobbyComfortUser );
    EVENT_HANDLER( EVENT_LOBBY_ABOUT, OnLobbyAbout );
    EVENT_HANDLER( EVENT_ZONE_CONNECT_FAIL, OnLobbyConnectFailed );
    EVENT_HANDLER( EVENT_ZONE_DO_CONNECT, OnLobbyBeginConnection );
    EVENT_HANDLER( EVENT_LOBBY_MATCHMAKE, OnMatchmake );
    EVENT_HANDLER_WITH_DATA( EVENT_LOBBY_DISCONNECT, OnDisconnect );
    EVENT_HANDLER( EVENT_GAME_LAUNCHING, OnStartGame);
    EVENT_HANDLER_WITH_DATA( EVENT_LOBBY_SERVER_STATUS, OnServerStatus);
    EVENT_HANDLER( EVENT_GAME_OVER, OnGameOver );
    EVENT_HANDLER( EVENT_GAME_BEGUN, OnGameBegun );
    EVENT_HANDLER( EVENT_GAME_PLAYER_READY, OnGamePlayerReady );
    EVENT_HANDLER( EVENT_UI_UPSELL_BLOCK, OnUiUpsellBlock );
    EVENT_HANDLER( EVENT_UI_UPSELL_UNBLOCK, OnUiUpsellUnblock );
    EVENT_HANDLER( EVENT_ZONE_CONNECT, OnZoneConnect );
    EVENT_HANDLER( EVENT_ZONE_DISCONNECT, OnZoneDisconnect );
    EVENT_HANDLER( EVENT_ZONE_UNAVAILABLE, OnStopConnecting );
    EVENT_HANDLER( EVENT_ZONE_VERSION_FAIL, OnStopConnecting );
    EVENT_HANDLER( EVENT_EXIT_APP, OnZoneDisconnect );  // need to do the same things here
END_EVENT_MAP()

    HRESULT CreateControls();

    // create IE pane, remaining main window elements when network connects
    void OnZoneConnect(DWORD eventId,DWORD groupId,DWORD userId)
    {
        // shouldn't happen
        ASSERT(!m_pPlugIE);
        if(m_pPlugIE)
            return;

        HRESULT hr;
        if(!m_fControlsCreated)
        {
            hr = CreateControls();
            if(FAILED(hr))
                return;
        }

        hr = m_pnp.CreateIEPane(&m_pPlugIE);
	    if (FAILED(hr))
	        return;

	    hr = m_pPlugIE->FirstCall(this);
	    if (FAILED(hr))
	    {
            m_pPlugIE->Delete();
            m_pPlugIE = NULL;
	        return;
	    }
    }

    void OnZoneDisconnect(DWORD eventId,DWORD groupId,DWORD userId)
    {
        // tell the IE pane not to navigate anymore
        if(m_pPlugIE)
            m_pPlugIE->StatusUpdate(PaneIENavigate, 0, NULL);

        // some things need to happen if pnp is up
        if(m_pnp.m_pPNP)
        {
            if(eventId == EVENT_EXIT_APP)
                m_pnp.DestroyPNP();
            else
            {
                if(m_pnp.m_pCurrentPlay == m_pPlayConnecting)
                    m_pPlayConnecting->StatusUpdate(PaneConnectingStop, 0, NULL);

                if(m_pPlugIE && m_pnp.m_pCurrentPlug == m_pPlugIE)
                    m_pnp.SetPlugAndOrPlay(m_pPlugSplash, NULL);
            }
        }

        // kill the IE control so that it doesn't try to do anything crazy
        if(m_pPlugIE)
        {
            m_pPlugIE->LastCall();
            m_pPlugIE->Delete();
            m_pPlugIE = NULL;
        }
    }

    // stop the connecting animation
    void OnStopConnecting(DWORD eventId,DWORD groupId,DWORD userId)
    {
        if(m_pnp.m_pPNP && m_pnp.m_pCurrentPlay == m_pPlayConnecting)
            m_pPlayConnecting->StatusUpdate(PaneConnectingStop, 0, NULL);
    }

    void OnLobbyComfortUser(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pnp.SetPlugAndOrPlay(m_pPlugSplash, m_pPlayComfort);
        m_pnp.Show(SW_SHOW);
    }

    // I believe this is always going to follow PaneConnecting so we'll keep it's Plug
    void OnLobbyConnectFailed(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pnp.SetPlugAndOrPlay(NULL, m_pPlayError);
    }

    void OnLobbyAbout(DWORD eventId, DWORD groupId, DWORD userId)
    {
        // only display if no PnP is up already
        if(!CreateChildPNP())
            return;

        m_pPlugSplash->StatusUpdate(PaneSplashAbout, 0, NULL);
        m_pnp.SetPlugAndOrPlay(m_pPlugSplash, m_pPlayAbout);
        m_pnp.Show(SW_SHOW);
    }

    void OnLobbyBeginConnection(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pnp.SetPlugAndOrPlay(m_pPlugSplash, m_pPlayConnecting);
        m_pPlayConnecting->StatusUpdate(PaneConnectingConnecting, 0, NULL);
        m_pnp.Show(SW_SHOW);
    }

    void OnMatchmake(DWORD eventId,DWORD groupId,DWORD userId)
    {
        if(CreateChildPNP() || m_pnp.m_pCurrentPlay == m_pPlayAbout || (m_pnp.m_pCurrentPlay == m_pPlayCredits && m_pPlayCredits))
            m_pnp.SetPlugAndOrPlay(m_pPlugIE ? m_pPlugIE : m_pPlugSplash, m_pPlayConnecting);
        else
            m_pnp.SetPlugAndOrPlay(NULL, m_pPlayConnecting);

        m_pPlayConnecting->StatusUpdate(PaneConnectingLooking, 0, NULL);
        m_pnp.Show(SW_SHOW);
    }

    void OnDisconnect(DWORD eventId,DWORD groupId,DWORD userId,DWORD dwData1, DWORD dwData2)
    {
        // only need this if it happened during a game
        if(dwData1 & 0x01)
            return;

        // set status first - when it gets made it will know
    	m_pPlayLeft->StatusUpdate(dwData1, 0, NULL);

        if(CreateChildPNP() || m_pnp.m_pCurrentPlay == m_pPlayAbout || (m_pnp.m_pCurrentPlay == m_pPlayCredits && m_pPlayCredits))
            m_pnp.SetPlugAndOrPlay(m_pPlugIE ? m_pPlugIE : m_pPlugSplash, m_pPlayLeft);
        else
            m_pnp.SetPlugAndOrPlay(NULL, m_pPlayLeft);
        m_pnp.Show(SW_SHOW);
    }

    void OnServerStatus(DWORD eventId,DWORD groupId,DWORD userId,DWORD dwData1, DWORD dwData2)
    {
        m_pnp.SetPlugAndOrPlay(NULL, m_pPlayConnecting);
    	m_pPlayConnecting->StatusUpdate(PaneConnectingLooking, dwData1 - 1, NULL);
    }

    void OnStartGame(DWORD eventId,DWORD groupId,DWORD userId)
    {
    	//Close splash dialog and bring up main window

		if (m_pnp.m_pPNP)
			m_pnp.DestroyPNP();
	
        if (m_bFirstGameStart)
		{
	        CComPtr<IZoneFrameWindow> pWindow;
			ZoneShell()->QueryService( SRVID_LobbyWindow, IID_IZoneFrameWindow, (void**) &pWindow );
			if(pWindow)
				pWindow->ZShowWindow(SW_SHOW);

            m_wndChatContainer.SetFocus();            

            CComPtr<IMillUtils> pIMU;
            ZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
            if(pIMU)
                pIMU->IncrementCounter(IMillUtils::M_CounterMainWindowOpened);

			m_bFirstGameStart=FALSE;
		}
    }

    void OnGameOver(DWORD eventId,DWORD groupId,DWORD userId)
    {
        CreateChildPNP();
        m_pnp.SetPlugAndOrPlay(m_pPlugIE ? m_pPlugIE : m_pPlugSplash, m_pPlayGameOver);
        m_pnp.Show(SW_SHOW);
    }

    void OnGameBegun(DWORD eventId,DWORD groupId,DWORD userId)
    {
		if(m_pnp.m_pPNP)
			m_pnp.DestroyPNP();
    }

    void OnGamePlayerReady(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pPlayGameOver->StatusUpdate(PaneGameOverUserState, (LONG) userId, NULL);
    }

    void OnUiUpsellBlock(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pnp.Block();
    }

    void OnUiUpsellUnblock(DWORD eventId,DWORD groupId,DWORD userId)
    {
        m_pnp.Unblock();
    }

    bool CreateChildPNP()
    {
        if(m_pnp.m_pPNP)
            return false;

        long cyTop = 0, cyBottom = 0;
        const TCHAR* arKeys[] = { key_WindowManager, key_Upsell, key_IdealFromTop };

        DataStoreUI()->GetLong( arKeys, 3, &cyTop );
        arKeys[2] = key_BottomThresh;
        DataStoreUI()->GetLong( arKeys, 3, &cyBottom );

        m_pnp.CreatePNP(m_hWnd, NULL, cyTop, cyBottom);
        return true;
    }


    // This is broken.  Have not been able to figure out a way to get the HTML control
    // to handle keyboard input.  Can get the focus in and out but it's useless.
    //
    // Even if this is put back in, there is more work to be done.  When the IE
    // control gets focus through other means (such as the mouse) it needs to
    // notify AccessibilityManager, and similarly, the IE control needs to take the
    // focus when AccessibilityManager calls its Focus().
    void OnCtlTab(DWORD eventId, DWORD groupId, DWORD userId)
    {
#if 0
        HWND hFocus = ::GetFocus();

        if(hFocus && m_pnp.m_pPNP && m_pnp.m_pCurrentPlug == m_pPlugIE && m_pPlugIE)
        {
            HWND hIE, hPlay;
            POINT oPoint = { 0, 0 };

            m_pPlugIE->GetWindowPane(&hIE);
            m_pnp.m_pCurrentPlay->GetWindowPane(&hPlay);

            for(; hFocus; hFocus = ::GetParent(hFocus))
                if(hFocus == hIE)
                    break;

            if(!hFocus)
                m_pPlugIE->StatusUpdate(PaneIEFocus, 0, NULL);
            else
            {
                m_pPlugIE->StatusUpdate(PaneIEUnfocus, 0, NULL);
                ::SetFocus(hPlay);
            }
        }
#endif
    }


BEGIN_MSG_MAP(CWindowManager)
	CHAIN_MSG_MAP(CComControl<CWindowManager>)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
	MESSAGE_HANDLER(WM_ACTIVATEAPP, OnTransmit)
	MESSAGE_HANDLER(WM_ACTIVATE, OnTransmit)
	MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnTransmit)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnTransmit)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUP)
	MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
	MESSAGE_HANDLER(WM_PALETTECHANGED, OnTransmit)
	MESSAGE_HANDLER(WM_COMMAND, OnTransmit)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_EXITSIZEMOVE, OnExitSizeMove)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// IViewObjectEx
//!! check if we can pull this
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IWindowManager
public:
	CZoneAxWindow m_wndGameContainer;		// container for a table list control
	CZoneAxWindow m_wndChatContainer;			// container for a chat control

	CRect m_rcGameContainer;
	CRect m_rcChatContainer;

    CPoint m_ptGameSize;
    long   m_nChatMinHeight;

	IPane* m_pPlugSplash;
    IPane* m_pPlugIE;
	IPane* m_pPlayComfort;
	IPane* m_pPlayConnecting;
	IPane* m_pPlayGameOver;
	IPane* m_pPlayError;
    IPane* m_pPlayAbout;
    IPane* m_pPlayCredits;
    IPane* m_pPlayLeft;

    bool m_fControlsCreated;

    CPlugNPlay m_pnp;
    
	BOOL m_bFirstGameStart;

	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
	LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        if(!m_fControlsCreated)
            return 0;

//!! should we be performing default processing to? Consider using OnTransmit() below
		// pass the message on to all children
		BOOL bUnused;			
		m_wndChatContainer.SendMessageToControl(uMsg, wParam, lParam, bUnused);
		m_wndGameContainer.SendMessageToControl(uMsg, wParam, lParam, bUnused);

		return 0;
	}

	LRESULT OnTransmit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        if(!m_fControlsCreated)
            return 0;

		// pass the message on to all children
		BOOL bUnused;			
		m_wndChatContainer.SendMessageToControl(uMsg, wParam, lParam, bUnused);
		m_wndGameContainer.SendMessageToControl(uMsg, wParam, lParam, bUnused);
        if(m_pnp.m_pPNP)
            m_pnp.TransferMessage(uMsg, wParam, lParam, bUnused);

        bHandled = FALSE;
		return 0;
	}

	LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        bHandled = true;
		return 1;		// we've handled the erase
	}

	void RecalcLayout()
	{
        if(!m_fControlsCreated)
            return;

		CRect rcClient;
		GetClientRect(&rcClient);
		
		// Game container size is not changed - so no need to move it
		// the room list
		/*m_rcGameContainer = rcClient;
		m_rcGameContainer.bottom = m_rcGameContainer.top + m_ptGameSize.y;
		m_wndGameContainer.MoveWindow(&m_rcGameContainer, false);
		
		rcClient.top = m_rcGameContainer.bottom;*/

		// and finally the chat container
		rcClient.top = m_rcGameContainer.bottom;
		m_rcChatContainer = rcClient;
		m_wndChatContainer.MoveWindow(&m_rcChatContainer, false);
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RecalcLayout();

		if(m_pnp.m_pPNP)
            if(m_pnp.RePosition() == S_OK)    // may be S_FALSE - don't want that
                m_pnp.ImplementLayout(true);

		return 0;
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        // just eat it.  AccessibilityManager should have something else happen to it.
		return 0;
	}

	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CPoint ptMouse(lParam);
		return 0;
	}

	LRESULT OnLButtonUP(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return 0;
	}

	LRESULT OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		LPMINMAXINFO pMinMax = (LPMINMAXINFO)lParam;

        pMinMax->ptMinTrackSize = CPoint(m_ptGameSize.x, m_ptGameSize.y + m_nChatMinHeight);
        pMinMax->ptMaxTrackSize.x = m_ptGameSize.x;

		return 0;
	}

	LRESULT OnExitSizeMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{// added for the chat control to handle this msg.
        if(!m_fControlsCreated)
            return 0;

		BOOL bUnused;			
		m_wndChatContainer.SendMessageToControl(uMsg, wParam, lParam, bUnused);

		bHandled = FALSE;
		return 0; 
	}


    // IPaneManager
	STDMETHOD(Input)(IPane * pPane, LONG id, LONG value, TCHAR * szText);

    STDMETHOD(RegisterHWND)(IPane *pPane, HWND hWnd);

    STDMETHOD(UnregisterHWND)(IPane *pPane, HWND hWnd);

    STDMETHOD_(IZoneShell*, GetZoneShell)() { return m_pIZoneShell; }
	STDMETHOD_(IResourceManager*, GetResourceManager)() { return m_pIResourceManager; }
	STDMETHOD_(ILobbyDataStore*, GetLobbyDataStore)() { return m_pILobbyDataStore; }
	STDMETHOD_(ITimerManager*, GetTimerManager)() { return m_pITimerManager; }
	STDMETHOD_(IDataStoreManager*, GetDataStoreManager)() { return m_pIDataStoreManager; }
	STDMETHOD_(IDataStore*, GetDataStoreConfig)() { return m_pIDSObjects; }
	STDMETHOD_(IDataStore*, GetDataStoreUI)() { return m_pIDSUI; }
	STDMETHOD_(IDataStore*, GetDataStorePreferences)() { return m_pIDSPreferences; }
	STDMETHOD_(IEventQueue*, GetEventQueue)() { return m_pIEventQueue; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\button.cpp ===
#include "buttonfrx.h"
#include "windowsx.h"
#include "rectfrx.h"

///////////////////////////////////////////////////////////////////////////////
// Class Globals
///////////////////////////////////////////////////////////////////////////////

CRolloverButton*	CRolloverButton::m_pHookObj = NULL;
HHOOK				CRolloverButton::m_hHook = NULL;


///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline void CRolloverButton::Reset( BOOL bDraw, BOOL bInactive )
{
	BOOL bFreeHook = TRUE;

	// Release spacebar
	m_bSpaceBar = FALSE;

	// Release capture
	if ( GetCapture() == m_hWnd )
		ReleaseCapture();

	// Set button state
	if ( !m_bLockedState )
	{
		if ( !IsWindowEnabled( m_hWnd ) )
			m_State = Disabled;
		else if ( GetActiveWindow() && !bInactive && IsCursorInWindow() )
		{
			m_State = Highlight;
			bFreeHook = FALSE;
			if ( !m_hHook )
			{
				m_pHookObj = this;
				m_hHook = SetWindowsHookEx( WH_MOUSE, (HOOKPROC) MouseHook, NULL, GetCurrentThreadId() );
			}
		}
		else if ( GetFocus() == m_hWnd )
			m_State = Focus;
		else
			m_State = Normal;
	}

	// Release hook
	if ( bFreeHook && m_hHook )
	{
		UnhookWindowsHookEx( m_hHook );
		m_hHook = NULL;
		m_pHookObj = NULL;
	}

	// Draw button
	if ( bDraw )
		m_pfnCallback( this, m_State, m_dwCookie );
}


inline BOOL CRolloverButton::IsCursorInWindow()
{
	POINT pt;
	GetCursorPos( &pt );
	ScreenToClient( m_hWnd, &pt );
	return ( (pt.x >= 0) && (pt.x <= m_Width) && (pt.y >= 0) && (pt.y <= m_Height) );
}


///////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CRolloverButton::MouseHook( int nCode, WPARAM wParam, LPARAM lParam )
{
	BOOL space;

	if ( (nCode == HC_ACTION) && (m_pHookObj) )
	{
		MOUSEHOOKSTRUCT* mouse = (MOUSEHOOKSTRUCT*) lParam;
		POINT pt = mouse->pt;
		ScreenToClient( m_pHookObj->m_hWnd, &pt );
		m_pHookObj->OnMouseMove( pt.x, pt.y, 0 );
	}
	return CallNextHookEx( m_hHook, nCode, wParam, lParam );
}


CRolloverButton::CRolloverButton()
{
	m_State = Normal;
	m_bSpaceBar = FALSE;
	m_bLockedState = FALSE;
	m_nChildId = 0;
	m_Height = 0;
	m_Width = 0;
	m_X = 0;
	m_Y = 0;
	m_pfnCallback = NULL;
	m_dwCookie = 0;
}


CRolloverButton::~CRolloverButton()
{
	if ( m_hHook )
	{
		UnhookWindowsHookEx( m_hHook );
		m_hHook = NULL;
		m_pHookObj = NULL;
	}
}


HRESULT CRolloverButton::Init( HINSTANCE hInstance, int nChildId, HWND hParent, RECT* rcPosition, PFBUTTONCALLBACK pfnCallback, DWORD cookie )
{
	// parameter paranoia
	if ( !rcPosition || !pfnCallback )
		return E_INVALIDARG;

	// Stash parameters
	m_X = rcPosition->left;
	m_Y = rcPosition->top;
	m_Width = rcPosition->right - rcPosition->left;
	m_Height = rcPosition->bottom - rcPosition->top;
	m_nChildId = nChildId;
	m_pfnCallback = pfnCallback;
	m_dwCookie = cookie;

	// Initialize state
	m_State = Normal;
	m_bSpaceBar = FALSE;
	m_bLockedState = FALSE;

	// Initialize parent window class
	HRESULT hr = CWindow2::Init( hInstance, NULL, hParent, rcPosition );
	if ( FAILED(hr) )
		return hr;

	// Draw the button
	m_pfnCallback( this, m_State, m_dwCookie );

	return NOERROR;
}

void CRolloverButton::OverrideClassParams( WNDCLASSEX& WndClass )
{
	WndClass.hCursor = NULL;
	WndClass.hbrBackground = NULL;
}


void CRolloverButton::OverrideWndParams( WNDPARAMS& WndParams )
{
	WndParams.dwExStyle = WS_EX_TRANSPARENT;
    WndParams.dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP;
	WndParams.hMenu = (HMENU) m_nChildId;
}


void CRolloverButton::OnDestroy()
{
	if ( m_hHook )
	{
		UnhookWindowsHookEx( m_hHook );
		m_hHook = NULL;
		m_pHookObj = NULL;
	}
}


void CRolloverButton::OnPaint()
{
	PAINTSTRUCT ps;
	HDC hdc;

	BeginPaint( m_hWnd, &ps );
	EndPaint( m_hWnd, &ps );
	m_pfnCallback( this, m_State, m_dwCookie );
}


void CRolloverButton::OnMouseMove( int x, int y, UINT keyFlags )
{
	ButtonState state = m_State;

	// Ignore message?
	if ( m_bLockedState || (Disabled == m_State) )
		return;
	if ( m_bSpaceBar )
		return;
	if ( m_pHookObj && (m_pHookObj != this) )
		return;

	// Mouse button down?
	if ( GetCapture() == m_hWnd )
	{
		if ( (x < 0) || (x > m_Width) || (y < 0) || (y > m_Height) )
			state = Highlight;
		else
			state = Pressed;
	}

	// Over window for the first time
	else if ( !m_hHook )
	{
		if ( GetActiveWindow() )
		{
			state = Highlight;
			m_pHookObj = this;
			m_hHook = SetWindowsHookEx( WH_MOUSE, (HOOKPROC) MouseHook, NULL, GetCurrentThreadId() );
		}
	}

	// Called by hook, outside window?
	else if ( (x < 0) || (x > m_Width) || (y < 0) || (y > m_Height) )
	{
		Reset( TRUE );
		return;
	}

	// Redraw button if state changed
	if ( state != m_State )
	{
		m_State = state;
		m_pfnCallback( this, m_State, m_dwCookie );
	}
}


void CRolloverButton::OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags )
{
	if ( m_bLockedState || (Disabled == m_State) )
		return;
	if ( m_bSpaceBar )
		return;

	SetCapture( m_hWnd );
	m_State = Pressed;
	m_pfnCallback( this, m_State, m_dwCookie );
}


void CRolloverButton::OnLButtonUp( int x, int y, UINT keyFlags )
{
	if ( m_bLockedState || (Disabled == m_State) )
		return;
	if ( m_bSpaceBar )
		return;
	if ( GetCapture() != m_hWnd )
		return;

	// notify parent of button press if cursor is over the button
	if ( (x >= 0) && (x <= m_Width) && (y >= 0) && (y <= m_Height) )
		FORWARD_WM_COMMAND( m_hParentWnd, m_nChildId, m_hWnd, 0, PostMessage );

	// reset button
	Reset( TRUE );
}


void CRolloverButton::OnEnable(BOOL fEnable)
{
	if ( m_bLockedState )
		return;
	Reset( TRUE );
}


void CRolloverButton::OnSetFocus( HWND hwndLoseFocus )
{
	if ( m_bLockedState )
		return;
	Reset( TRUE );
}


void CRolloverButton::OnKillFocus( HWND hwndGetFocus )
{
	if ( m_bLockedState )
		return;
	Reset( TRUE );
}


void CRolloverButton::OnActivate(UINT state, HWND hwndActDeact, BOOL fMinimized)
{
	Reset( TRUE, WA_INACTIVE == state );
}


void CRolloverButton::OnChar(TCHAR ch, int cRepeat)
{
	FORWARD_WM_CHAR( m_hParentWnd, ch, cRepeat, PostMessage );
}


void CRolloverButton::OnKey(UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
	if ( fDown )
	{
		if ( (VK_SPACE == vk) && !m_bLockedState )
		{
			m_bSpaceBar = TRUE;
			m_State = Pressed;
			if ( GetCapture() == m_hWnd )
				ReleaseCapture();
			m_pfnCallback( this, m_State, m_dwCookie );
		}
		else
		{
			FORWARD_WM_KEYDOWN( m_hParentWnd, vk, cRepeat, flags, PostMessage );
		}
	}
	else
	{
		if ( (VK_SPACE == vk) && !m_bLockedState )
		{
			if ( m_bSpaceBar )
			{
				Reset( TRUE );
				FORWARD_WM_COMMAND( m_hParentWnd, m_nChildId, m_hWnd, 0, PostMessage );
			}
		}
		else
		{
			FORWARD_WM_KEYUP( m_hParentWnd, vk, cRepeat, flags, PostMessage );
		}
	}
}


void CRolloverButton::LockState( ButtonState state )
{
	m_bLockedState = TRUE;
	Reset( FALSE );
	if ( state < Normal )
		m_State = Normal;
	else if ( state > Disabled )
		m_State = Disabled;
	else
		m_State = state;
	m_pfnCallback( this, m_State, m_dwCookie );
}


void CRolloverButton::ReleaseState()
{
	m_bLockedState = FALSE;
	Reset( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\buttonfrx.h ===
#ifndef __FRX_BUTTON_H__
#define __FRX_BUTTON_H__

#include <windows.h>
#include "dibfrx.h"
#include "palfrx.h"
#include "wndfrx.h"
#include "wndxfrx.h"

namespace FRX
{

class CRolloverButton : public CWindow2
{
public:
	// button helpers
	enum ButtonState
	{
		Normal = 0,
		Focus,
		Highlight,
		Pressed,
		Disabled,
		NumButtonStates
	};

	typedef void (*PFBUTTONCALLBACK)( CRolloverButton* pButton, ButtonState state, DWORD cookie );

public:
	// Constructor & destructor
	CRolloverButton();
	~CRolloverButton();

	// Initialization
	HRESULT Init( HINSTANCE hInstance, int nChildId, HWND hParent, RECT* rcPosition, PFBUTTONCALLBACK pfnCallback, DWORD cookie );
	virtual void OverrideClassParams( WNDCLASSEX& WndClass );
	virtual void OverrideWndParams( WNDPARAMS& WndParams );

	void LockState( ButtonState state );
	void ReleaseState();

	// Message handlers
	BEGIN_MESSAGE_MAP(CRolloverButton);
		ON_MESSAGE( WM_PAINT, OnPaint );
		ON_MESSAGE( WM_MOUSEMOVE, OnMouseMove );
		ON_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
		ON_MESSAGE( WM_LBUTTONUP, OnLButtonUp );
		ON_MESSAGE( WM_ACTIVATE, OnActivate );
		ON_MESSAGE( WM_ENABLE, OnEnable );
		ON_MESSAGE( WM_SETFOCUS, OnSetFocus );
		ON_MESSAGE( WM_KILLFOCUS, OnKillFocus );
		ON_MESSAGE( WM_KEYDOWN, OnKey );
		ON_MESSAGE( WM_KEYUP, OnKey );
		ON_MESSAGE( WM_CHAR, OnChar );
		ON_MESSAGE( WM_DESTROY, OnDestroy );
	END_MESSAGE_MAP();

	void OnPaint();
	void OnMouseMove( int x, int y, UINT keyFlags );
	void OnLButtonDown( BOOL fDoubleClick, int x, int y, UINT keyFlags );
	void OnLButtonUp( int x, int y, UINT keyFlags );
	void OnEnable(BOOL fEnable);
	void OnSetFocus( HWND hwndLoseFocus );
	void OnActivate(UINT state, HWND hwndActDeact, BOOL fMinimized);
	void OnKillFocus( HWND hwndGetFocus );
	void OnKey(UINT vk, BOOL fDown, int cRepeat, UINT flags);
	void OnChar(TCHAR ch, int cRepeat);
	void OnDestroy();

	// mouse hook
	static LRESULT CALLBACK MouseHook( int nCode, WPARAM wParam, LPARAM lParam );

	//state access function
	ButtonState CurrentState(void){return m_State;} 
	BOOL 		Locked(void){return m_bLockedState;}
	
protected:
	// helper functions
	void Reset( BOOL bDraw = TRUE, BOOL bInactive = FALSE );
	BOOL IsCursorInWindow();

	// button state
	ButtonState m_State;
	BOOL		m_bSpaceBar;
	BOOL		m_bLockedState;

	// button image data
	long		m_X;
	long		m_Y;
	long		m_Height;
	long		m_Width;

	// child window id
	int	m_nChildId;

	// state change callback
	PFBUTTONCALLBACK	m_pfnCallback;
	DWORD				m_dwCookie;

	// Rollover button to receive hook messages
	static CRolloverButton* m_pHookObj;
	static HHOOK			m_hHook;
};

}

using namespace FRX;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\windowmanager\thing.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Thing.h
 *
 * Contents:	Thing Engine interfaces
 *
 *****************************************************************************/

#ifndef _THING_H_
#define _THING_H_

#define WORLD_VERSION		1
#define WORLD_TIMER_PERIOD  100

class  CTState
{
	public:

};

class  CTClientState
{
	public:
	
	LONG 	x,y,z; //position

};

class  CTCommand
{
public:
	LONG id;
};

class CTClient
{
public:
	CTCommand 		cmd;
	CTClientState	state;
};

///////////////////////////////////////////////////////////////////////////////
// CThing
///////////////////////////////////////////////////////////////////////////////

class  CThing
{
public:
	bool		inuse;
	CTState 		state;
	CTClient     *pClient;
	CThing		*pOwner;

	CThing()
	{
		pClient = NULL;
		pOwner = NULL;
		inuse = 0;
	}
};


///////////////////////////////////////////////////////////////////////////////
// IWorldImports
///////////////////////////////////////////////////////////////////////////////

// {CE5E4D60-4E81-11d3-BA16-0080C7A5DDBB}
DEFINE_GUID(IID_IWorldImports, 
0xce5e4d60, 0x4e81, 0x11d3, 0xba, 0x16, 0x0, 0x80, 0xc7, 0xa5, 0xdd, 0xbb);

interface __declspec(uuid("{CE5E4D60-4E81-11d3-BA16-0080C7A5DDBB}")) 
IWorldImports {
	//
	// IWorldImports::LinkThing
	//
	// Setup callback to implement behaviour at location in interface	
	//
	// Parameters:
	//
	//	pThing
	//		Pointer to object that contains TPos and flags 
	//  

	STDMETHOD(LinkThing)(CThing* pThing)=0;

	//
	// IWorldImports::UpdateThing
	//
	// Change visual associated with thing
	//
	// Parameters:
	//
	//	pThing
	//		Pointer to object to update
	//  
	//	flags
	//		Declares what to do
	//  

	STDMETHOD(UpdateThing)(CThing* pThing,LONG flags)=0;
		
};

///////////////////////////////////////////////////////////////////////////////
// IWorldExports
///////////////////////////////////////////////////////////////////////////////

// {864B5BB3-1D57-4e22-BDF8-447AB3719A8C}
DEFINE_GUID(IID_IWorldExports, 
0x864b5bb3, 0x1d57, 0x4e22, 0xbd, 0xf8, 0x44, 0x7a, 0xb3, 0x71, 0x9a, 0x8c);

interface __declspec(uuid("{864B5BB3-1D57-4e22-BDF8-447AB3719A8C}")) 
IWorldExports 
{
	//first and last functions called
	STDMETHOD(Init)()=0;
	STDMETHOD(Shutdown)()=0;

	//execute
	STDMETHOD(ClientCreate)(CThing** ppThing)=0;
	STDMETHOD(ClientBegin)(CThing* pThing)=0;
	STDMETHOD(ClientCommand)(CThing* pThing)=0;
	STDMETHOD(ClientDisconnect)(CThing* pThing)=0;


	STDMETHOD(ClientThink)(CThing* pThing)=0;
	STDMETHOD(RunFrame)()=0;

	STDMETHOD(GetVersion)(LONG *pValue)=0;

};


STDMETHODIMP SetupWorld(IWorldImports *pWI,IWorldExports **ppWE);

///////////////////////////////////////////////////////////////////////////////
// Helper Functions and structures
///////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\chatfilter.cpp ===
/*******************************************************************************

	chatfilter.cpp

		Chat filtering routines.
	
	Copyright (c) Microsoft Corp. 1998. All rights reserved.
	Written by Hoon Im
	Created on 04/07/98
	 
*******************************************************************************/


#include <windows.h>
#include "chatfilter.h"
#include "zonestring.h"

#define kSubChar		_T('.')


/*
	FilterInputChatText()
	
	Filters the given text and returns the same pointer. Undesirable
	characters substituted with the replacement char.
*/
void FilterInputChatText(TCHAR* text, long len)
{
	if (text == NULL)
		return;

	while (--len >= 0)
	{
		if (*text == _T('>') || (unsigned TCHAR) *text == 0x9B)
			*text = kSubChar;
        else if ( ISSPACE(*text) )
            *text = _T(' ');

		text++;
	}
}


/*
	FilterOutputChatText()
	
	Filters the given text and returns the same pointer. Undesirable
	characters substituted with the replacement char.
*/
void FilterOutputChatText(TCHAR* text, long len)
{
	if (text == NULL)
		return;

	while (--len >= 0)
	{
		if ((unsigned TCHAR) *text == 0x9B)
            *text = kSubChar;
        else if ( ISSPACE(*text) )
            *text = _T(' ');

		text++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\chat.cpp ===
#include "chat.h"
#include "chatfilter.h"
#include "ztypes.h"


#define kMaxTalkOutputLen           16384


///////////////////////////////////////////////////////////////////////////////
// Utility functions
///////////////////////////////////////////////////////////////////////////////

static int CALLBACK EnumFontFamProc( ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam )
{
	*(int*) lParam = TRUE;
	return 0;
}


static BOOL FontExists( const TCHAR* szFontName )
{
	BOOL result = FALSE;
	HDC hdc = GetDC(NULL);
	EnumFontFamilies( hdc, szFontName, (FONTENUMPROC) EnumFontFamProc, (LPARAM) &result );
	ReleaseDC( NULL, hdc );
	return result;
}


///////////////////////////////////////////////////////////////////////////////
// Chat window class
///////////////////////////////////////////////////////////////////////////////

CChatWnd::CChatWnd()
{
	m_fDone = 0;
	m_hWndDisplay = NULL;
	m_hWndEnter = NULL;
	m_hWndParent = NULL;
	m_DefEnterProc = NULL;
	m_DefDisplayProc = NULL;
	m_pfHandleInput = NULL;
	m_hFont = NULL;
	m_dwCookie = 0;
	m_bEnabled = TRUE;
	m_bBackspaceWorks = FALSE;
}


CChatWnd::~CChatWnd()
{
	// ASSERT( m_fDone == 0x03 );
	if ( m_hFont )
		DeleteObject( m_hFont );

	/*if(::IsWindow(m_hWndDisplay))
		DestroyWindow(m_hWndDisplay);*/

}


HRESULT CChatWnd::Init( HINSTANCE hInstance, HWND hWndParent, CRect* pRect, PFHANDLEINPUT pfHandleInput, DWORD dwCookie )
{
	// Stash input callback
	m_dwCookie = dwCookie;
	m_pfHandleInput = pfHandleInput;
	if ( !m_pfHandleInput )
		return E_INVALIDARG;

	// Stash parent window;
	m_hWndParent = hWndParent;

	// Display window
	m_hWndDisplay = CreateWindow(
						_T("EDIT"),
						NULL,
						WS_CHILD | WS_BORDER | WS_VISIBLE | WS_VSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
						0, 0,
						0, 0,
						hWndParent,
						NULL,
						hInstance,
						NULL );
	if ( !m_hWndDisplay )
	{
		DWORD err = GetLastError();
		return E_FAIL;
	}

	CompareString
	SendMessage( m_hWndDisplay, EM_SETREADONLY, TRUE, 0 );
	SetWindowLong( m_hWndDisplay, GWL_USERDATA, (LONG) this );
	m_DefDisplayProc = (WNDPROC) SetWindowLong( m_hWndDisplay, GWL_WNDPROC, (LONG) DisplayWndProc );

	// Enter window
	m_hWndEnter = CreateWindow(
						_T("EDIT"),
						NULL,
						WS_CHILD | WS_BORDER | WS_VISIBLE | ES_LEFT | ES_AUTOHSCROLL | ES_WANTRETURN | ES_MULTILINE,
						0, 0,
						0, 0,
						hWndParent,
						NULL,
						hInstance,
						NULL );
	if ( !m_hWndEnter )
	{
		DWORD err = GetLastError();
		DestroyWindow( m_hWndDisplay );
		return E_FAIL;
	}
	SetWindowLong( m_hWndEnter, GWL_USERDATA, (LONG) this );
	m_DefEnterProc = (WNDPROC) SetWindowLong( m_hWndEnter, GWL_WNDPROC, (LONG) EnterWndProc );
	SendMessage( m_hWndEnter, EM_LIMITTEXT, 255, 0 );

	// Size and position window
	ResizeWindow( pRect );

	// Set display font
	if ( FontExists( _T("Verdana") ) )
	{
		LOGFONT font;
		ZeroMemory( &font, sizeof(font) );
		font.lfHeight = -11;
		font.lfWeight = FW_BOLD;
		font.lfCharSet = DEFAULT_CHARSET;
		font.lfOutPrecision = OUT_DEFAULT_PRECIS;
		font.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		font.lfQuality = DEFAULT_QUALITY;
		font.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
		lstrcpy( font.lfFaceName, _T("verdana") );
		m_hFont = CreateFontIndirect( &font );
		if ( m_hFont )
		{
			SendMessage( m_hWndEnter, WM_SETFONT, (WPARAM) m_hFont, 0 );
			SendMessage( m_hWndDisplay, WM_SETFONT, (WPARAM) m_hFont, 0 );
		}
	}
	

	return NOERROR;
}


void CChatWnd::ResizeWindow( CRect* pRect )
{
	CRect rcDisplay;
	CRect rcEnter;
	HDC hdc;
	TEXTMETRIC tm;
	long TextHeight;

	// Get size of text
	hdc = GetDC( m_hWndEnter );
	GetTextMetrics( hdc, &tm );
	ReleaseDC( m_hWndEnter , hdc );

	// Calculate window size
	TextHeight = (long) (1.2 * (tm.tmHeight + tm.tmExternalLeading));
	rcDisplay = *pRect;
	rcEnter = *pRect;
	rcDisplay.bottom -= TextHeight;
	rcEnter.top = rcDisplay.bottom + 1;
	if ( rcDisplay.IsEmpty() )
		rcDisplay.SetRect( 0, 0, 0, 0 );
	if ( rcEnter.IsEmpty() )
		rcEnter.SetRect( 0, 0, 0, 0 );

	// Size and position windows
	MoveWindow( m_hWndDisplay, rcDisplay.left, rcDisplay.top, rcDisplay.GetWidth(), rcDisplay.GetHeight(), TRUE );
	MoveWindow( m_hWndEnter, rcEnter.left, rcEnter.top, rcEnter.GetWidth(), rcEnter.GetHeight(), TRUE );
}


void CChatWnd::AddText( TCHAR* from, TCHAR* text )
{
	TCHAR buff[zMaxChatInput + 100], *str;
	int len;
    DWORD selStart, selEnd;

	
	if ( m_fDone )
		return;

	if ( !text )
		text = "";
	
	FilterOutputChatText( text, lstrlen(text) );
	wsprintf( buff,_T("\r\n%s> %s"), from, text );
	str = buff;

    // get the top visible line number.
    long firstLine = SendMessage( m_hWndDisplay, EM_GETFIRSTVISIBLELINE, 0, 0 );

    // get current selections
    SendMessage( m_hWndDisplay, EM_GETSEL, (WPARAM) &selStart, (LPARAM) &selEnd );

    /*
        get the bottom visible line number.

        Use the last characters position (which is in the last line) to determine whether
        it is still visible; ie, last line is visible.
    */
    RECT r;
    SendMessage( m_hWndDisplay, EM_GETRECT, 0, (LPARAM) &r );
    DWORD lastCharPos = SendMessage( m_hWndDisplay, EM_POSFROMCHAR, GetWindowTextLength( m_hWndDisplay ) - 1, 0 );
    POINTS pt = MAKEPOINTS( lastCharPos );

	// place text at end of output edit box....
	SendMessage( m_hWndDisplay, EM_SETSEL, (WPARAM)(INT)32767, (LPARAM)(INT)32767 );
	SendMessage( m_hWndDisplay, EM_REPLACESEL, 0, (LPARAM)(LPCSTR)str);

	/* clear top characters of the output box if edit box size > 4096 */
	len = GetWindowTextLength( m_hWndDisplay );
	if ( len > kMaxTalkOutputLen )
    {
        // Delete top lines.

        long cutChar = len - kMaxTalkOutputLen;
        long cutLine = SendMessage( m_hWndDisplay, EM_LINEFROMCHAR, cutChar, 0 );
        long cutLineIndex = SendMessage( m_hWndDisplay, EM_LINEINDEX, cutLine, 0 );

        // if cut off char is not beginning of line, then cut the whole line.
        // get char index to the next line.
        if ( cutLineIndex != cutChar )
        {
            // make sure current cut line is not the last line.
            if ( cutLine < SendMessage( m_hWndDisplay, EM_GETLINECOUNT, 0, 0 ) )
                cutLineIndex = SendMessage( m_hWndDisplay, EM_LINEINDEX, cutLine + 1, 0 );
        }

        /*
            NOTE: WM_CUT and WM_CLEAR doesn't seem to work with EM_SETSEL selected text.
            Had to use EM_REPLACESEL with a null char to cut the text out.
        */
        // select lines to cut and cut them out.
        TCHAR p = _T('\0');
        SendMessage( m_hWndDisplay, EM_SETSEL, 0, cutLineIndex );
        SendMessage( m_hWndDisplay, EM_REPLACESEL, 0, (LPARAM) &p );
	}

    /*
        if the last line was visible, then keep the last line visible.
        otherwise, remain at the same location w/o scrolling to show the last line.
    */
    if ( pt.y < r.bottom )
    {
        // keep the last line visible.
        SendMessage( m_hWndDisplay, EM_SETSEL, 32767, 32767 );
        SendMessage( m_hWndDisplay, EM_SCROLLCARET, 0, 0 );
    }
    else
    {
        SendMessage( m_hWndDisplay, EM_SETSEL, 0, 0 );
        SendMessage( m_hWndDisplay, EM_SCROLLCARET, 0, 0 );
        SendMessage( m_hWndDisplay, EM_LINESCROLL, 0, firstLine );
    }

    // restore selection
    SendMessage( m_hWndDisplay, EM_SETSEL, (WPARAM) selStart, (LPARAM) selEnd );
}


LRESULT CALLBACK CChatWnd::EnterWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CChatWnd* pObj;
	TCHAR buff[256];
	int c;
	int len;

	// get pointer to chat window
	pObj = (CChatWnd*) GetWindowLong( hwnd, GWL_USERDATA );
	if ( !pObj )
		return 0;

	// process character process
	if (uMsg == WM_CHAR )
	{
		if ( pObj->m_bEnabled == FALSE )
			return 0;

		c = (int) wParam;
		if ( c == _T('\r') )
		{
			len = GetWindowText( hwnd, buff, sizeof(buff) - 1);
			if ( len > 0 )
			{
				buff[ len ] = _T('\0');
				FilterInputChatText(buff, len);
                len++;
				pObj->m_pfHandleInput( buff, len, pObj->m_dwCookie );
				SetWindowText( hwnd, _T("") );
			}
			return 0;
		}
		if ( c == _T('\b') ) // Trap backspace - in case it was actually working ie302
		{
			pObj->m_bBackspaceWorks = TRUE;
		}

	}
	else if ( (uMsg == WM_KEYUP) && (VK_ESCAPE == (int) wParam) )
	{
		PostMessage( pObj->m_hWndParent, WM_KEYUP, wParam, lParam );
	}
	else if ( (uMsg == WM_KEYUP) && (VK_BACK == (int) wParam) && pObj->m_bBackspaceWorks == FALSE)
	{
		// emulate backspace
		DWORD startSel, endSel;
	    SendMessage(hwnd, EM_GETSEL, (WPARAM)&startSel, (LPARAM)&endSel) ;
		if ( startSel == endSel)
		{
			int len = GetWindowTextLength(hwnd);
			SendMessage(hwnd, EM_SETSEL, startSel - ((DWORD) lParam & 0x000000FF), endSel) ;
		}
		SendMessage(hwnd, WM_CLEAR, 0, 0) ;
		
		return 0;
	}
	else if ( uMsg == WM_DESTROY )
	{
		pObj->m_fDone |= 0x1;
		SetWindowLong( hwnd, GWL_WNDPROC, (LONG) pObj->m_DefEnterProc );
		if ( pObj->m_fDone == 0x03 )
			delete pObj;
		return 0;
	}
	else if (uMsg == WM_SETFOCUS )
	{
		if ( pObj->m_bEnabled == FALSE )
			return 0;
	}

	// chain to parent class
	return CallWindowProc( (FARPROC) pObj->m_DefEnterProc, hwnd, uMsg, wParam, lParam );
}


LRESULT CALLBACK CChatWnd::DisplayWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CChatWnd* pObj;

	// get pointer to chat window
	pObj = (CChatWnd*) GetWindowLong( hwnd, GWL_USERDATA );
	if ( !pObj )
		return 0;

	// process character process
	if ( uMsg == WM_KEYUP )
	{
		if ( VK_ESCAPE == (int) wParam )
		{
			PostMessage( pObj->m_hWndParent, WM_KEYUP, wParam, lParam );
			return 0;
		}
	}
	else if ( uMsg == WM_DESTROY )
	{
		pObj->m_fDone |= 0x2;
		SetWindowLong( hwnd, GWL_WNDPROC, (LONG) pObj->m_DefEnterProc );
		if ( pObj->m_fDone == 0x03 )
			delete pObj;
		return 0;
	}

	// chain to parent class
	return CallWindowProc( (FARPROC) pObj->m_DefDisplayProc, hwnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\debugfrx.h ===
#ifndef __FRX_DEBUG_H__
#define __FRX_DEBUG_H__

///////////////////////////////////////////////////////////////////////////////
// Debug macros
///////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

	#define WNDFRX_ASSERT(_X_)	\
		{	\
			if ( !(_X_)	&& ( MessageBox( NULL, (TCHAR*)(#_X_), _T("Wndfrx Assert (cancel = debug)"), MB_OKCANCEL ) == IDCANCEL ) )	\
			{	\
				__asm{ int 0x3 }	\
			}	\
		}

#else

	#define WNDFRX_ASSERT(_X_)	((void)0)

#endif //_DEBUG



#endif //!__FRX_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\chatfilter.h ===
/*******************************************************************************

	chatfilter.h

		Chat filtering routines.
	
	Copyright (c) Microsoft Corp. 1998. All rights reserved.
	Written by Hoon Im
	Created on 04/07/98
	 
*******************************************************************************/


#ifndef CHATFILTER_H
#define CHATFILTER_H


void FilterInputChatText(TCHAR* text, long len);
void FilterOutputChatText(TCHAR* text, long len);


#endif // CHATFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\dib.cpp ===
#include "dibfrx.h"


///////////////////////////////////////////////////////////////////////////////
// Shared Dib functions
///////////////////////////////////////////////////////////////////////////////

namespace FRX
{

void DibBlt(
		BYTE* pDstBits, long DstPitch, long DstHeight,
		BYTE* pSrcBits, long SrcPitch, long SrcHeight, long depth,
		long dx, long dy,
		long sx, long sy,
		long width, long height, BOOL bFilpRTL)
{
	BYTE* pDst;
	BYTE* pSrc;
	int iDstInc;
	int iSrcInc;
	int i, j;
    int bpp = ((depth + 7) / 8);

    width *= bpp;
    dx *= bpp;
    sx *= bpp;

	// clip to source bitmap
	if ( sx < 0)
	{
		width += sx;
		dx -= sx;
		sx = 0;
	}
	if ( sy < 0 )
	{
		height += sy;
		dy -= sy;
		sy = 0;
	}
	if ( sx + width > SrcPitch )
		width = SrcPitch - sx;
	if ( sy + height > SrcHeight )
		height = SrcHeight - sy;

	// clip to destination bitmap
	if ( dx < 0 )
	{
		width += dx;
		sx += -dx;
		dx = 0;
	}
	if ( dy < 0 )
	{
		height += dy;
		sy += -dy;
		dy = 0;
	}
	if ( dx + width > DstPitch )
		width = DstPitch - dx;
	if ( dy + height > DstHeight )
		height = DstHeight - dy;

	// check for silly arguments (asserts?)
	if (	(width <= 0)
		||	(height <= 0)
		||	(sx < 0)
		||	(sy < 0)
		||	((sx + width) > SrcPitch)
		||	((sy + height) > SrcHeight) )
	{
		return;
	}

if ( !bFilpRTL)
{

	// copy memory
	pDst = pDstBits + (((DstHeight - (dy + height)) * DstPitch) + dx);
	pSrc = pSrcBits + (((SrcHeight - (sy + height)) * SrcPitch) + sx);
	iDstInc = DstPitch - width;
	iSrcInc = SrcPitch - width;


#if defined( _M_IX86 )

	__asm {
		cld
		mov eax, height
		dec eax
		js blt_end
		mov esi, pSrc
		mov edi, pDst
line_loop:
		mov ecx, width
		rep movsb
		add esi, iSrcInc
		add edi, iDstInc
		dec eax
		jns line_loop
blt_end:
	};

#else

	i = height;
	while( --i >= 0 )
	{
		j = width;
		while( --j >= 0 )
		{
			*pDst++ = *pSrc++;
		}
		pDst += iDstInc;
		pSrc += iSrcInc;
	}

#endif
}
else
{
	// copy memory
	pDst = pDstBits + (((DstHeight - (dy + height)) * DstPitch) + dx);
	pSrc = pSrcBits + (((SrcHeight - (sy + height)) * SrcPitch) + sx);
	iDstInc = DstPitch - width;
	iSrcInc = SrcPitch - width;

	i = height;
	while( --i >= 0 )
	{
		j = width;
		while( --j >= 0 )
		{
			*pDst++ = *(pSrc+j);
		}
		pDst += iDstInc;
		pSrc += iSrcInc + width;
	}
}

}


void DibTBlt(
		BYTE* pDstBits, long DstPitch, long DstHeight,
		BYTE* pSrcBits, long SrcPitch, long SrcHeight, long depth,
		long dx, long dy,
		long sx, long sy,
		long width, long height,
		BYTE* TransIdx)
{
    if(!TransIdx)
    {
        DibBlt(pDstBits, DstPitch, DstHeight,
            pSrcBits, SrcPitch, SrcHeight, depth,
            dx, dy,
            sx, sy,
            width, height, false);
        return;
    }

	BYTE* pDst;
	BYTE* pSrc;
	int iDstInc;
	int iSrcInc;
	int i, j, k;
    int bpp = ((depth + 7) / 8);

    width *= bpp;
    dx *= bpp;
    sx *= bpp;

	// clip to destination bitmap
	if ( dx < 0 )
	{
		width += dx;
		sx += -dx;
		dx = 0;
	}
	if ( dy < 0 )
	{
		height += dy;
		sy += -dy;
		dy = 0;
	}
	if ( dx + width > DstPitch )
		width = DstPitch - dx;
	if ( dy + height > DstHeight )
		height = DstHeight - dy;

	// check for silly arguments (asserts?)
	if (	(width <= 0)
		||	(height <= 0)
		||	(sx < 0)
		||	(sy < 0)
		||	((sx + width) > SrcPitch)
		||	((sy + height) > SrcHeight) )
	{
		return;
	}

	// copy memory
	pDst = pDstBits + (((DstHeight - (dy + height)) * DstPitch) + dx);
	pSrc = pSrcBits + (((SrcHeight - (sy + height)) * SrcPitch) + sx);
	iDstInc = DstPitch - width;
	iSrcInc = SrcPitch - width;
	i = height;
	while( --i >= 0 )
	{
		j = width / bpp;
		while( --j >= 0 )
		{
            k = -1;
            while( ++k < bpp )
            {
                if(pSrc[k] != TransIdx[k])
                    break;
            }
			if ( k < bpp )
			{
                k = bpp;
                while( --k >= 0 )
				    *pDst++ = *pSrc++;
			}
			else
			{
				pDst += bpp;
				pSrc += bpp;
			}
		}
		pDst += iDstInc;
		pSrc += iSrcInc;
	}
}


void DibFill(
		BYTE* pDstBits, long DstPitch, long DstHeight, long depth,
		long dx, long dy,
		long width, long height,
		BYTE ColorIdx)
{
	BYTE* pDst;
	int iDstInc;
	int i, j;
    int bpp = ((depth + 7) / 8);

    width *= bpp;
    dx *= bpp;

	// clip to destination bitmap
	if ( dx < 0 )
	{
		width += dx;
		dx = 0;
	}
	if ( dy < 0 )
	{
		height += dy;
		dy = 0;
	}
	if ( dx + width > DstPitch )
		width = DstPitch - dx;
	if ( dy + height > DstHeight )
		height = DstHeight - dy;

	// check for silly arguments (asserts?)
	if ((width <= 0) ||	(height <= 0))
		return;

	// copy memory
	pDst = pDstBits + (((DstHeight - (dy + height)) * DstPitch) + dx);
	iDstInc = DstPitch - width;
	i = height + 1;
	while( --i )
	{
		j = width + 1;
		while( --j )
		{
			*pDst++ = ColorIdx;
		}
		pDst += iDstInc;
	}
}

}

///////////////////////////////////////////////////////////////////////////////
// CDib implementation
///////////////////////////////////////////////////////////////////////////////

CDib::CDib()
{
	m_RefCnt = 1;
	m_pBMI = NULL;
	m_pBits = NULL;
	m_iColorTableUsage = DIB_RGB_COLORS;
	m_lPitch = 0;
	m_fTransIdx = false;
}


CDib::~CDib()
{
	DeleteBitmap();
}


HRESULT CDib::Load( IResourceManager* pResourceManager, int nResourceId )
{
	HRESULT hr;
	HBITMAP hbm;

	hbm = pResourceManager->LoadImage( MAKEINTRESOURCE(nResourceId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	if ( !hbm )
		return E_FAIL;
	hr = Load( hbm);
	DeleteObject( hbm );
	return hr;
}

HRESULT CDib::Load( HINSTANCE hInstance, int nResourceId )
{
	HRESULT hr;
	HBITMAP hbm;

	hbm = LoadImage( hInstance, MAKEINTRESOURCE(nResourceId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	if ( !hbm )
		return E_FAIL;
	hr = Load( hbm);
	DeleteObject( hbm );
	return hr;
}

HRESULT CDib::Load( HINSTANCE hInstance, const TCHAR *szName)
{
	HRESULT hr;
	HBITMAP hbm;

	hbm = LoadImage( hInstance, szName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	if ( !hbm )
		return E_FAIL;
	hr = Load( hbm);
	DeleteObject( hbm );
	return hr;
}

HRESULT CDib::Load( const TCHAR* FileName )
{
	HRESULT hr;
	HBITMAP hbm;

	hbm = LoadImage( NULL, FileName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE );
	if ( !hbm )
		return E_FAIL;
	hr = Load( hbm);
	DeleteObject( hbm );
	return hr;
}


HRESULT CDib::RemapToPalette( CPalette& palette, BOOL bUseIndex )
{
	BYTE map[256];
	PALETTEENTRY* pe;
	BYTE* bits;
	RGBQUAD* dibColors;
	DWORD i;

    // only do this for 256 color bitmaps
    if(m_pBMI->bmiHeader.biBitCount != 8)
        return NOERROR;

	// Create dib to palette translation table
	dibColors = m_pBMI->bmiColors;
	for ( i = 0; i < 256; i++ )
	{
		map[i] = GetNearestPaletteIndex( palette, RGB( dibColors->rgbRed, dibColors->rgbGreen, dibColors->rgbBlue ) );
		dibColors++;
	}
	if ( m_fTransIdx )
	{
		map[ *m_arbTransIdx ] = palette.GetTransparencyIndex();
		*m_arbTransIdx = palette.GetTransparencyIndex();
	}

	// run bits through translation table
	bits = m_pBits;
	for ( i = 0; i < m_pBMI->bmiHeader.biSizeImage; i++ )
		*bits++ = map[ *bits ];

	// reset dib's color table to palette
	if ( bUseIndex )
	{
		m_iColorTableUsage = DIB_PAL_COLORS;
		dibColors = m_pBMI->bmiColors;
		for ( i = 0; i < 256; i++ )
		{
			*((WORD*) dibColors) = (WORD) i;
			dibColors++;
		}
	}
	else
	{
		m_iColorTableUsage = DIB_RGB_COLORS;
		pe = palette.GetLogPalette()->palPalEntry;
		dibColors = m_pBMI->bmiColors;
		for ( i = 0; i < 256; i++ )
		{
			dibColors->rgbRed = pe->peRed;
			dibColors->rgbGreen = pe->peGreen;
			dibColors->rgbBlue = pe->peBlue;
			dibColors->rgbReserved = 0;
			dibColors++;
			pe++;
		}
	}

	// we're done
	return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
// Helper functions
///////////////////////////////////////////////////////////////////////////////

void CDib::DeleteBitmap()
{
	m_lPitch = 0;
	m_fTransIdx = false;
	if ( m_pBMI )
	{
		delete m_pBMI;
		m_pBMI = NULL;
	}
	if ( m_pBits )
	{
		delete [] m_pBits;
		m_pBits = NULL;
	}
	m_iColorTableUsage = DIB_RGB_COLORS;
}


HRESULT CDib::Load( HBITMAP hbm )
{
	HDC hdc;
	DIBSECTION ds;

	// Get rid of previous bitmap
	DeleteBitmap();

	// Argument check
	if ( !hbm )
		return E_FAIL;

	// Get DIB Section information
	if ( !GetObject( hbm, sizeof(DIBSECTION), &ds ) )
		return E_FAIL;

	// Store header
	m_pBMI = new FULLBITMAPINFO;
	if ( !m_pBMI )
		return E_OUTOFMEMORY;
	ZeroMemory( m_pBMI, sizeof(FULLBITMAPINFO) );
	CopyMemory( m_pBMI, &ds.dsBmih, sizeof(BITMAPINFOHEADER) );
	m_lPitch = WidthBytes( ds.dsBmih.biBitCount * ds.dsBmih.biWidth );

	// Allocate mem for bits
	m_pBits = new BYTE [ m_pBMI->bmiHeader.biSizeImage ];
	if ( !m_pBits )
	{
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}

	// Store DIB's color table and bits
	hdc = CreateCompatibleDC( NULL );
	if ( !GetDIBits( hdc, hbm, 0, m_pBMI->bmiHeader.biHeight, m_pBits, (BITMAPINFO*) m_pBMI, DIB_RGB_COLORS ) )
	{
		DeleteBitmap();
		return E_FAIL;
	}
	DeleteDC( hdc );

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\diblite.cpp ===
#include "dibfrx.h"

CDibLite::CDibLite()
{
	m_RefCnt = 1;
	m_pBMH = NULL;
	m_pBits = NULL;
	m_lPitch = 0;
	m_fTransIdx = false;
}


CDibLite::~CDibLite()
{
	DeleteBitmap();
}


HRESULT CDibLite::Create( long width, long height, long depth /* = 8 */)
{
	DeleteBitmap();

	// Fill in bitmapinfoheader
	m_pBMH = new BITMAPINFOHEADER;
	if ( !m_pBMH )
		return E_OUTOFMEMORY;
	m_pBMH->biSize			= sizeof(BITMAPINFOHEADER);
	m_pBMH->biWidth			= width;
	m_pBMH->biHeight		= height;
    m_pBMH->biPlanes		= 1;
	m_pBMH->biBitCount		= (WORD) depth;
    m_pBMH->biCompression	= 0;
	m_pBMH->biSizeImage		= WidthBytes( width * m_pBMH->biBitCount ) * height;
	m_pBMH->biClrUsed		= (m_pBMH->biBitCount == 8 ? 255 : 0);
	m_pBMH->biClrImportant	= (m_pBMH->biBitCount == 8 ? 255 : 0);
    m_pBMH->biXPelsPerMeter	= 0;
    m_pBMH->biYPelsPerMeter	= 0;
	m_lPitch = WidthBytes( width * m_pBMH->biBitCount );

	// Allocate memory for bits
	m_pBits = new BYTE [ m_pBMH->biSizeImage ];
	if ( !m_pBits )
	{
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}



HRESULT CDibLite::Load( IResourceManager* pResourceManager, int nResourceId )
{
	HDC hdc = NULL;
	HBITMAP hbm = NULL;
	DIBSECTION ds;
	FULLBITMAPINFO bmi;

	// Get rid of previous bitmap
	DeleteBitmap();

	// Pull bitmap from resource file
	hbm = pResourceManager->LoadImage( MAKEINTRESOURCE(nResourceId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	
	if ( !hbm )
		return E_FAIL;
	if ( !GetObject( hbm, sizeof(DIBSECTION), &ds ) )
		return E_FAIL;
	
	// Store header	
	m_pBMH = new BITMAPINFOHEADER;
	if ( !m_pBMH )
	{
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}
	CopyMemory( m_pBMH, &ds.dsBmih, sizeof(BITMAPINFOHEADER) );
	m_lPitch = WidthBytes( ds.dsBmih.biBitCount * ds.dsBmih.biWidth );

	// Allocate memory for bits
	m_pBits = new BYTE [ m_pBMH->biSizeImage ];
	if ( !m_pBits )
	{
		DeleteDC( hdc );
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}

	// Get the bits
	hdc = CreateCompatibleDC( NULL );
	CopyMemory( &bmi.bmiHeader, m_pBMH, sizeof(BITMAPINFOHEADER) );
	if ( !GetDIBits( hdc, hbm, 0, m_pBMH->biHeight, m_pBits, (BITMAPINFO*) &bmi, DIB_RGB_COLORS ) )
	{
		DeleteDC( hdc );
		DeleteBitmap();
		return E_FAIL;
	}
	DeleteDC( hdc );
	
	// We don't need the section anymore
	DeleteObject( hbm );
	return NOERROR;
}


HRESULT CDibLite::Load( HINSTANCE hInstance, int nResourceId )
{
	HDC hdc = NULL;
	HBITMAP hbm = NULL;
	DIBSECTION ds;
	FULLBITMAPINFO bmi;

	// Get rid of previous bitmap
	DeleteBitmap();

	// Pull bitmap from resource file
	hbm = LoadImage( hInstance, MAKEINTRESOURCE(nResourceId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	if ( !hbm )
		return E_FAIL;
	if ( !GetObject( hbm, sizeof(DIBSECTION), &ds ) )
		return E_FAIL;
	
	// Store header	
	m_pBMH = new BITMAPINFOHEADER;
	if ( !m_pBMH )
	{
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}
	CopyMemory( m_pBMH, &ds.dsBmih, sizeof(BITMAPINFOHEADER) );
	m_lPitch = WidthBytes( ds.dsBmih.biBitCount * ds.dsBmih.biWidth );

	// Allocate memory for bits
	m_pBits = new BYTE [ m_pBMH->biSizeImage ];
	if ( !m_pBits )
	{
		DeleteDC( hdc );
		DeleteBitmap();
		return E_OUTOFMEMORY;
	}

	// Get the bits
	hdc = CreateCompatibleDC( NULL );
	CopyMemory( &bmi.bmiHeader, m_pBMH, sizeof(BITMAPINFOHEADER) );
	if ( !GetDIBits( hdc, hbm, 0, m_pBMH->biHeight, m_pBits, (BITMAPINFO*) &bmi, DIB_RGB_COLORS ) )
	{
		DeleteDC( hdc );
		DeleteBitmap();
		return E_FAIL;
	}
	DeleteDC( hdc );
	
	// We don't need the section anymore
	DeleteObject( hbm );
	return NOERROR;
}


HRESULT CDibLite::RemapToPalette( CPalette& palette, RGBQUAD* dibColors )
{
	BYTE map[256];
	BYTE* bits;
	DWORD i;

    // only do this for 256 color bitmaps
    if(m_pBMH->biBitCount != 8)
        return NOERROR;

	// Create dib to palette translation table
	for ( i = 0; i < 256; i++ )
	{
		map[i] = GetNearestPaletteIndex( palette, RGB( dibColors->rgbRed, dibColors->rgbGreen, dibColors->rgbBlue ) );
		dibColors++;
	}
	if ( m_fTransIdx )
	{
		map[ *m_arbTransIdx ] = palette.GetTransparencyIndex();
		*m_arbTransIdx = palette.GetTransparencyIndex();
	}

	// run bits through translation table
	bits = m_pBits;
	for ( i = 0; i < m_pBMH->biSizeImage; i++ )
		*bits++ = map[ *bits ];

	// we're done
	return NOERROR;
}


void CDibLite::DeleteBitmap()
{
	m_lPitch = 0;
	m_fTransIdx = false;
	if ( m_pBMH )
	{
		delete m_pBMH;
		m_pBMH = NULL;
	}
	if ( m_pBits )
	{
		delete [] m_pBits;
		m_pBits = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\dirtyfrx.h ===
#ifndef __DIRTY_RECTANGLE_LIST_H__
#define __DIRTY_RECTANGLE_LIST_H__

#include "rectfrx.h"
#include "dibfrx.h"



class CDirtyList
{
public:
	CDirtyList();
	~CDirtyList();

	// initialization
	HRESULT Init( int nSize = 128 );

	// Add rectangle to dirty list
	void AddRect( FRX::CRect* rc );
	void AddRect( long x, long y, long width, long height );
	
	// Draws list of rectangles from dib into hwnd
	void Draw( HDC hdc, CDibSection& dib );

	// Clears list
	void Reset();

public:
	int			m_nRects;
	int			m_nRectSize;
	FRX::CRect*	m_Rects;
};


///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline CDirtyList::CDirtyList()
{
	m_nRects = 0;
	m_nRectSize = 0;
	m_Rects = NULL;
}


inline HRESULT CDirtyList::Init( int nSize )
{
	m_Rects = new FRX::CRect[ m_nRectSize = nSize ];
	if ( !m_Rects )
		return E_OUTOFMEMORY;
	return NOERROR;
}


inline CDirtyList::~CDirtyList()
{
	if ( m_Rects )
		delete [] m_Rects;
}


inline void CDirtyList::Reset()
{
	m_nRects = 0;
}


inline void CDirtyList::AddRect( FRX::CRect* rc )
{
	// grow array?
	if ( m_nRects >= m_nRectSize )
	{
		FRX::CRect* oldArray = m_Rects;
		m_Rects = new FRX::CRect[ m_nRectSize * 2 ];
		CopyMemory( m_Rects, oldArray, sizeof(FRX::CRect) * m_nRectSize );
		m_nRectSize *= 2;
		delete [] oldArray;
	}

	// add rectangle
	if ( !m_nRects )
		m_Rects[m_nRects++] = *rc;
	else if ( m_Rects[m_nRects - 1].Intersects( *rc ) )
		m_Rects[m_nRects - 1].UnionRect( *rc );
	else
		m_Rects[m_nRects++] = *rc;
}


inline void CDirtyList::AddRect( long x, long y, long width, long height )
{
	FRX::CRect rc( x, y, x + width - 1, y + height - 1 );
	AddRect( &rc );		
}


inline void CDirtyList::Draw( HDC hdc, CDibSection& dib )
{
	int i;
	FRX::CRect* rc;

	for( rc = &m_Rects[ i = 0 ]; i < m_nRects; i++, rc++ )
		dib.Draw( hdc, rc->left, rc->top, rc );
}

using namespace FRX;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\dibfrx.h ===
#ifndef __FRX_DIB_H__
#define __FRX_DIB_H__


#include <windows.h>
#include "ResourceManager.h"
#include "tchar.h"
#include "palfrx.h"
#include "debugfrx.h"

namespace FRX
{
// WARNING: since Dib Sections are not true devices, Windows does not know
// when to flush the GDI buffer of actions taken against the Section's DC.  So
// if you do call GDI functions on a Dib Section, you must call GdiFlush()
// before blitting to the Section.  Otherwise the operations may be performed
// in the wrong order.


// Copy source dib into destination dib while clipping to destination.
void DibBlt(
		BYTE* pDstBits, long DstPitch, long DstHeight,
		BYTE* pSrcBits, long SrcPitch, long SrcHeight, long depth,
		long dx, long dy,
		long sx, long sy,
		long width, long height, BOOL bFlipRTL = FALSE);


// Copy source dib into destination dib with transparency while clipping
// to destination.
void DibTBlt(
		BYTE* pDstBits, long DstPitch, long DstHeight,
		BYTE* pSrcBits, long SrcPitch, long SrcHeight, long depth,
		long dx, long dy,
		long sx, long sy,
		long width, long height,
		BYTE* TransIdx );

// Rectangle fill of destination dib
void DibFill(
		BYTE* pDstBits, long DstPitch, long DstHeight, long depth,
		long dx, long dy,
		long width, long height,
		BYTE ColorIdx );


// WIDTHBYTES performs DWORD-aligning of DIB scanlines.  The "bits"
// parameter is the bit count for the scanline (biWidth * biBitCount),
// and this function returns the number of DWORD-aligned bytes needed 
// to hold those bits.
inline long WidthBytes( long bits )
{
	return (((bits + 31) & ~31) >> 3);
}


///////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////

// Draw prototypes only differ by class types, so this macro simplifies
// the declaring the function protoypes.
#define DrawFunctionPrototypes( DstClass ) \
	void Draw( DstClass& dest, long x, long y, BOOL bFlipRTL = FALSE );													\
	void Draw( DstClass& dest, long dx, long dy, long sx, long sy, long width, long height );		\
	void Draw( DstClass& dest, long dx, long dy, const RECT* rc );									\
	void DrawT( DstClass& dest, long x, long y );													\
	void DrawT( DstClass& dest, long dx, long dy, long sx, long sy, long width, long height );		\
	void DrawT( DstClass& dest, long dx, long dy, const RECT* rc );


// Draw implementations only differ by class types, so this macro simplifies
// the defining the inline functions.
#define DrawFunctionImpl(SrcClass, DstClass) \
	inline void SrcClass::Draw( DstClass& dest, long x, long y, BOOL bFlipRTL )	\
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibBlt(														\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			x, y,													\
			0, 0,													\
			GetWidth(), GetHeight(), bFlipRTL );					\
	}																\
	inline void SrcClass::Draw( DstClass& dest, long dx, long dy, long sx, long sy, long width, long height ) \
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibBlt(														\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			dx, dy,													\
			sx, sy,													\
			width, height );										\
	}																\
	inline void SrcClass::Draw( DstClass& dest, long dx, long dy, const RECT* rc )	\
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibBlt(														\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			dx, dy,													\
			rc->left, rc->top,										\
			rc->right - rc->left + 1, rc->bottom - rc->top + 1 );	\
	}																\
	inline void SrcClass::DrawT( DstClass& dest, long x, long y )	\
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibTBlt(													\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			x, y,													\
			0, 0,													\
			GetWidth(), GetHeight(),								\
			m_arbTransIdx );										\
	}																\
	inline void SrcClass::DrawT( DstClass& dest, long dx, long dy, long sx, long sy, long width, long height ) \
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibTBlt(													\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			dx, dy,													\
			sx, sy,													\
			width, height,											\
			m_arbTransIdx );										\
	}																\
	inline void SrcClass::DrawT( DstClass& dest, long dx, long dy, const RECT* rc )	\
	{																\
        if(GetDepth() != dest.GetDepth())                           \
            return;                                                 \
		DibTBlt(													\
			dest.GetBits(), dest.GetPitch(), dest.GetHeight(),		\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),			\
			dx, dy,													\
			rc->left, rc->top,										\
			rc->right - rc->left + 1, rc->bottom - rc->top + 1,		\
			m_arbTransIdx );										\
	}


// Fill prototypes only differ by class types, so this macro simplifies
// the declaring the function protoypes.
#define FillFunctionPrototypes(DstClass) \
	void Fill( BYTE idx );												\
	void Fill( long dx, long dy, long width, long height, BYTE idx );	\
	void Fill( const RECT* rc, BYTE idx );


// Fill implementations only differ by class types, so this macro simplifies
// the defining the inline functions.
#define FillFunctionImpl(DstClass) \
	inline void DstClass::Fill( BYTE idx )								\
	{																	\
		FillMemory( GetBits(), (DWORD) GetPitch() * GetHeight(), idx );	\
	}																	\
	inline void DstClass::Fill( long dx, long dy, long width, long height, BYTE idx ) \
	{																	\
		DibFill(														\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),				\
			dx, dy,														\
			width, height,												\
			idx );														\
	}																	\
	inline void DstClass::Fill( const RECT* rc, BYTE idx )				\
	{																	\
		DibFill(														\
			GetBits(), GetPitch(), GetHeight(),	GetDepth(),             \
			rc->left, rc->top,											\
			rc->right - rc->left + 1, rc->bottom - rc->top + 1,			\
			idx );														\
	}

// Reference count implementation only differs by class type, so this macro
// simplifies defining the inline functions.
#define DibRefCntFunctionImpl(DstClass) \
	inline ULONG DstClass::AddRef()		\
	{									\
		return ++m_RefCnt;				\
	}									\
	inline ULONG DstClass::Release()	\
	{									\
		WNDFRX_ASSERT( m_RefCnt > 0 );	\
		if ( --m_RefCnt <= 0 )			\
		{								\
			delete this;				\
			return 0;					\
		}								\
		return m_RefCnt;				\
	}


///////////////////////////////////////////////////////////////////////////////
// Dib related structures
///////////////////////////////////////////////////////////////////////////////

struct FULLBITMAPINFO
{
	BITMAPINFOHEADER	bmiHeader; 
	RGBQUAD				bmiColors[256];
};


///////////////////////////////////////////////////////////////////////////////
// Forward references
///////////////////////////////////////////////////////////////////////////////

class CDibLite;
class CDibSection;


///////////////////////////////////////////////////////////////////////////////
// Dib classes
///////////////////////////////////////////////////////////////////////////////

class CDib
{
public:
	// Constructor and destructor
	CDib();
	~CDib();

	// Reference count
	ULONG AddRef();
	ULONG Release();

	HRESULT Load( IResourceManager* pResourceManager, int nResourceId );
	// Load bitmap from resource
	HRESULT Load( HINSTANCE hInstance, int nResourceId );

    // Load bitmap from resource
	HRESULT Load( HINSTANCE hInstance, const TCHAR* szName );

	// Load bitmap from file
	HRESULT Load( const TCHAR* FileName );

	// Remap to palette
	HRESULT RemapToPalette( CPalette& palette, BOOL bUseIndex = FALSE );

	// Get dimensions
	long GetWidth()		{ return m_pBMI->bmiHeader.biWidth; }
	long GetHeight()	{ return m_pBMI->bmiHeader.biHeight; }

	// Transparency
	void SetTransparencyIndex( const BYTE* idx )	{ if(idx){ CopyMemory(m_arbTransIdx, idx, (GetDepth() + 7) / 8); m_fTransIdx = true; }else m_fTransIdx = false; }
	BYTE* GetTransparencyIndex()			{ return m_fTransIdx ? m_arbTransIdx : NULL; }
	
	// Get raw data
	BITMAPINFO* GetBitmapInfo()	{ return (BITMAPINFO*) m_pBMI; }
	BYTE*		GetBits()		{ return m_pBits; }
	long		GetPitch()		{ return m_lPitch; }
    long        GetDepth()      { return m_pBMI->bmiHeader.biBitCount; }

	// Display functions
	void Draw( HDC dc, long x, long y );
	void Draw( HDC dc, long dx, long dy, long sx, long sy, long width, long height );
	void Draw( HDC dc, long dx, long dy, const RECT* rc );
	FillFunctionPrototypes( CDib );
	DrawFunctionPrototypes( CDib );
	DrawFunctionPrototypes( CDibLite );
	DrawFunctionPrototypes( CDibSection );

protected:
	// member variables
	FULLBITMAPINFO*	m_pBMI;
	BYTE*			m_pBits;
	UINT			m_iColorTableUsage;
	long			m_lPitch;
	BYTE			m_arbTransIdx[16];  // only (GetDepth() + 7) / 8 bytes are used
    bool            m_fTransIdx;

	// reference count
	ULONG m_RefCnt;

	// helper functions
	void DeleteBitmap();
	HRESULT Load( HBITMAP hbm );
};


class CDibSection
{
public:
	// Constructor and destructor
	CDibSection();
	~CDibSection();
	
	// Reference count
	ULONG AddRef();
	ULONG Release();

	// Create bitmap
	HRESULT Create( long width, long height, CPalette& palette, long depth = 8 );
	HRESULT Create( const RECT* rc, CPalette& palette, long depth = 8 );

	// Load bitmap from resource (results in read only dib)
	HRESULT Load( HINSTANCE hInstance, int nResourceId );

	// Set ColorTable to the palette
	HRESULT SetColorTable( CPalette& palette );

	// Get dimensions
	long GetWidth()		{ return m_DS.dsBmih.biWidth; }
	long GetHeight()	{ return m_DS.dsBmih.biHeight; }

	// Transparency
	void SetTransparencyIndex( const BYTE* idx )	{ if(idx){ CopyMemory(m_arbTransIdx, idx, (GetDepth() + 7) / 8); m_fTransIdx = true; }else m_fTransIdx = false; }
	BYTE* GetTransparencyIndex()			{ return m_fTransIdx ? m_arbTransIdx : NULL; }

	// Get raw data
	HBITMAP	GetHandle()		{ return m_hBmp; }
	BYTE*	GetBits()		{ return m_pBits; }
	HDC		GetDC()			{ return m_hDC; }
	long	GetPitch()		{ return m_lPitch; }
    long    GetDepth()      { return m_DS.dsBmih.biBitCount; }

	// Display functions
	void Draw( HDC dc, long x, long y );
	void Draw( HDC dc, long dx, long dy, long sx, long sy, long width, long height );
	void Draw( HDC dc, long dx, long dy, const RECT* rc );
	FillFunctionPrototypes( CDibSection );
	DrawFunctionPrototypes( CDib );
	DrawFunctionPrototypes( CDibLite );
	DrawFunctionPrototypes( CDibSection );

protected:	
	// bitmap information
	BYTE*			m_pBits;
	HBITMAP			m_hBmp;
	DIBSECTION		m_DS;
	long			m_lPitch;
	BYTE			m_arbTransIdx[16];  // only (GetDepth() + 7) / 8 bytes are used
    bool            m_fTransIdx;

	// reference coun
	ULONG m_RefCnt;

	// DC information
	HDC				m_hDC;
	HBITMAP			m_hOldBmp;
	HPALETTE		m_hOldPalette;

	// helper functions
	void DeleteBitmap();
};


class CDibLite
{
public:
	// Constructor and destructor
	CDibLite();
	~CDibLite();

	// Reference count
	ULONG AddRef();
	ULONG Release();

	// Create bitmap
	HRESULT Create( long width, long height, long depth = 8 );
	HRESULT Create( const RECT* rc, long depth = 8 );

	HRESULT Load( IResourceManager* m_pResourceManager, int nResourceId );

	// Load bitmap from resource
	HRESULT Load( HINSTANCE hInstance, int nResourceId );

	// Remap to palette
	HRESULT RemapToPalette( CPalette& palette, RGBQUAD* dibColors );

	// Get dimensions
	long GetWidth()		{ return m_pBMH->biWidth; }
	long GetHeight()	{ return m_pBMH->biHeight; }

	// Transparency
	void SetTransparencyIndex( const BYTE* idx )	{ if(idx){ CopyMemory(m_arbTransIdx, idx, (GetDepth() + 7) / 8); m_fTransIdx = true; }else m_fTransIdx = false; }
	BYTE* GetTransparencyIndex()			{ return m_fTransIdx ? m_arbTransIdx : NULL; }

	// Get raw data
	BITMAPINFOHEADER*	GetBitmapInfoHeader()	{ return m_pBMH; }
	BYTE*				GetBits()				{ return m_pBits; }
	long				GetPitch()				{ return m_lPitch; }
    long                GetDepth()              { return m_pBMH->biBitCount; }

	// Display functions
	FillFunctionPrototypes( CDibLite );
	DrawFunctionPrototypes( CDib );
	DrawFunctionPrototypes( CDibLite );
	DrawFunctionPrototypes( CDibSection );

protected:
	// member variables
	BITMAPINFOHEADER*	m_pBMH;
	BYTE*				m_pBits;
	long				m_lPitch;
	BYTE		    	m_arbTransIdx[16];  // only (GetDepth() + 7) / 8 bytes are used
    bool            m_fTransIdx;

	// reference count
	ULONG m_RefCnt;

	// helper functions
	void DeleteBitmap();
};


///////////////////////////////////////////////////////////////////////////////
// CDib Inline Functions 
///////////////////////////////////////////////////////////////////////////////

inline void CDib::Draw( HDC dc, long x, long y )
{
	long width = GetWidth();
	long height = GetHeight();

	StretchDIBits(
		dc,
		x, y,
		width, height,
		0, 0,
		width, height,
		GetBits(),
		GetBitmapInfo(),
		m_iColorTableUsage,
		SRCCOPY );
}


inline void CDib::Draw( HDC dc, long dx, long dy, long sx, long sy, long width, long height )
{
	StretchDIBits(
		dc,
		dx, dy,
		width, height,
		sx, GetHeight() - (sy + height),
		width, height,
		GetBits(),
		GetBitmapInfo(),
		m_iColorTableUsage,
		SRCCOPY );
}


inline void CDib::Draw( HDC dc, long dx, long dy, const RECT* rc )
{
	long width = rc->right - rc->left + 1;
	long height = rc->bottom - rc->top + 1;

	StretchDIBits(
		dc,
		dx, dy,
		width, height,
		rc->left, GetHeight() - (rc->top + height),
		width, height,
		GetBits(),
		GetBitmapInfo(),
		m_iColorTableUsage,
		SRCCOPY );
}

DibRefCntFunctionImpl( CDib );
FillFunctionImpl( CDib );
DrawFunctionImpl( CDib, CDib );
DrawFunctionImpl( CDib, CDibLite );
DrawFunctionImpl( CDib, CDibSection );

#define NOMIRRORBITMAP                     0x80000000
///////////////////////////////////////////////////////////////////////////////
// CDibSection Inline Functions 
///////////////////////////////////////////////////////////////////////////////

inline HRESULT CDibSection::Create( const RECT* rc, CPalette& palette, long depth )
{
	return Create( rc->right - rc->left + 1, rc->bottom - rc->top + 1, palette, depth );
}

inline void CDibSection::Draw( HDC dc, long x, long y )
{
	BitBlt( dc, x, y, GetWidth(), GetHeight(), m_hDC, 0, 0, SRCCOPY );
}

inline void CDibSection::Draw( HDC dc, long dx, long dy, long sx, long sy, long width, long height )
{
	BitBlt( dc, dx, dy, width, height, m_hDC, sx, sy, SRCCOPY );
}

inline void CDibSection::Draw( HDC dc, long dx, long dy, const RECT* rc )
{
	BitBlt( dc, dx, dy, rc->right - rc->left + 1, rc->bottom - rc->top + 1, m_hDC, rc->left, rc->top, SRCCOPY );
}

DibRefCntFunctionImpl( CDibSection );
FillFunctionImpl( CDibSection );
DrawFunctionImpl( CDibSection, CDib );
DrawFunctionImpl( CDibSection, CDibLite );
DrawFunctionImpl( CDibSection, CDibSection );


///////////////////////////////////////////////////////////////////////////////
// CDibLite Inline Functions 
///////////////////////////////////////////////////////////////////////////////

inline HRESULT CDibLite::Create( const RECT* rc, long depth )
{
	return Create( rc->right - rc->left + 1, rc->bottom - rc->top + 1, depth );
}

DibRefCntFunctionImpl( CDibLite );
FillFunctionImpl( CDibLite );
DrawFunctionImpl( CDibLite, CDib );
DrawFunctionImpl( CDibLite, CDibLite );
DrawFunctionImpl( CDibLite, CDibSection );

}

using namespace FRX;

#endif //!__FRX_DIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\palette.cpp ===
#include "palfrx.h"
#include "debugfrx.h"


CPalette::CPalette()
{
	m_RefCnt = 1;
	m_iTransIdx = -1;
	m_hPalette = NULL;
	m_Palette.palVersion = 0x0300;
	m_Palette.palNumEntries = 256;
}


CPalette::~CPalette()
{
	DeletePalette();
}


ULONG CPalette::AddRef()
{
	return ++m_RefCnt;
}


ULONG CPalette::Release()
{
	WNDFRX_ASSERT( m_RefCnt > 0 );
	if ( --m_RefCnt <= 0 )
	{
		delete this;
		return 0;
	}
	return m_RefCnt;
}


HRESULT CPalette::Init( const CPalette& Palette )
{
	// Get rid of previous palette
	DeletePalette();

	// Logical palette
	CopyMemory( &m_Palette, &Palette.m_Palette, sizeof(FULLLOGPALETTE) );

	// Transparency index
	m_iTransIdx = Palette.m_iTransIdx;

	// Create palette
	m_hPalette = CreatePalette( (LOGPALETTE*) &m_Palette );
	if ( !m_hPalette )
		return E_FAIL;

	return NOERROR;
}


HRESULT CPalette::Init( RGBQUAD* rgb, BOOL bReserveTransparency, int iTransIdx )
{
	// Get rid of previous palette
	DeletePalette();
	
	// Create palette
	m_Palette.palVersion = 0x0300;
	m_Palette.palNumEntries = 256;
	for ( int i = 0; i < 256; i++ )
	{
		m_Palette.palPalEntry[i].peRed		= rgb[i].rgbRed;
	    m_Palette.palPalEntry[i].peGreen	= rgb[i].rgbGreen;
	    m_Palette.palPalEntry[i].peBlue		= rgb[i].rgbBlue;
	    m_Palette.palPalEntry[i].peFlags	= 0;
	}
	if ( bReserveTransparency )
	{
		m_iTransIdx = iTransIdx;
		m_Palette.palPalEntry[m_iTransIdx].peRed   = 0;
		m_Palette.palPalEntry[m_iTransIdx].peGreen = 0;
		m_Palette.palPalEntry[m_iTransIdx].peBlue  = 0;
		m_Palette.palPalEntry[m_iTransIdx].peFlags = PC_NOCOLLAPSE;
	}
	else
	{
		m_iTransIdx = -1;
	}
	m_hPalette = CreatePalette( (LOGPALETTE*) &m_Palette );
	if ( !m_hPalette )
		return E_FAIL;

	return NOERROR;
}


HRESULT CPalette::Init( HBITMAP hbmp, BOOL bReserveTransparency )
{
	HDC hdc;
	RGBQUAD rgb[256];
	
	hdc = CreateCompatibleDC( NULL );
	SelectObject( hdc, hbmp );
	GetDIBColorTable( hdc,	0, 256, rgb );
	DeleteDC( hdc );
	return Init( rgb, bReserveTransparency );
}


BOOL CPalette::IsPalettizedDevice( HDC hdc )
{ 
	return (GetDeviceCaps( hdc, RASTERCAPS ) & RC_PALETTE);
}


int CPalette::GetNumSystemColors( HDC hdc )
{
	return GetDeviceCaps( hdc, NUMRESERVED );
}


BOOL CPalette::IsIdentity()
{
	HDC hdc;
	HPALETTE hPalOld;
	PALETTEENTRY pe[256];
	int i;

	// Get physical palette
	hdc = GetDC( NULL );
	if ( !IsPalettizedDevice( hdc ) )
	{
		ReleaseDC( NULL, hdc );
		return TRUE;
	}
	hPalOld = SelectPalette( hdc, m_hPalette, FALSE );
	RealizePalette( hdc );
	GetSystemPaletteEntries( hdc, 0, 256, (PALETTEENTRY*) &pe );
	SelectPalette( hdc, hPalOld, FALSE );
	ReleaseDC( NULL, hdc );

	// Compare with our logical palette
	for ( i = 0; i < 256; i++ )
	{
		if (	(pe[i].peRed   != m_Palette.palPalEntry[i].peRed)
			||	(pe[i].peGreen != m_Palette.palPalEntry[i].peGreen)
			||	(pe[i].peBlue  != m_Palette.palPalEntry[i].peBlue) )
		{
			break;
		}
	}
	if ( i == 256 )
		return TRUE;
	else
		return FALSE;
}


BOOL CPalette::IsIdentity1()
{
    BOOL fIdentityPalette;
    HDC hdcS;

    hdcS = GetDC(NULL);
    if (	(GetDeviceCaps(hdcS, RASTERCAPS) & RC_PALETTE)
		&&	(GetDeviceCaps(hdcS, BITSPIXEL) * GetDeviceCaps(hdcS, PLANES) == 8) )
    {
        int n=0;
        int i;
        BYTE xlat[256];
        HBITMAP hbm;
        HDC hdcM;

        GetObject(m_hPalette, sizeof(n), &n);

        hdcM = CreateCompatibleDC(hdcS);
        hbm = CreateCompatibleBitmap(hdcS, 256, 1);
        SelectObject(hdcM, hbm);

        SelectPalette(hdcM, m_hPalette, TRUE);
        RealizePalette(hdcM);
        for (i=0; i<n; i++)
        {
            SetPixel(hdcM, i, 0, PALETTEINDEX(i));
        }
        SelectPalette(hdcM, GetStockObject(DEFAULT_PALETTE), TRUE);
        GetBitmapBits(hbm, sizeof(xlat), xlat);

        DeleteDC(hdcM);
        DeleteObject(hbm);

        fIdentityPalette = TRUE;
        for (i=0; i<n; i++)
        {
            if (xlat[i] != i)
            {
                fIdentityPalette = FALSE;
            }
        }
    }
    else
    {
        //
        // not a palette device, not realy a issue
        //
        fIdentityPalette = TRUE;
    }

    ReleaseDC(NULL, hdcS);

    return fIdentityPalette;
}


HRESULT CPalette::RemapToIdentity( BOOL bReserveTransparency )
{
	HDC hdc;
	HPALETTE hOldPal;
	int i, iSysCols;

	// Get screen's DC
	hdc = GetDC( NULL );
	if ( !hdc )
		return E_FAIL;

	// If we're not on a palettized device then punt
	if ( !IsPalettizedDevice( hdc ) )
	{
		ReleaseDC( NULL, hdc );
		return NOERROR;
	}

	// Force reset of system palette tables
//	SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC );
//	SetSystemPaletteUse( hdc, SYSPAL_STATIC );

	// Map our logical palette to the physical palette
	hOldPal = SelectPalette( hdc, m_hPalette, FALSE );
	RealizePalette( hdc );

	// Fill logical palette with physical palette
	iSysCols = GetNumSystemColors( hdc );
	GetSystemPaletteEntries( hdc, 0, 256, (PALETTEENTRY*) &m_Palette.palPalEntry );
	for ( i = 0; i < iSysCols; i++ ) 
		m_Palette.palPalEntry[i].peFlags = 0;
	for ( ; i < 256 ; i++ )
		m_Palette.palPalEntry[i].peFlags = PC_NOCOLLAPSE;

	
	/*
	for ( i = 0; i < iSysCols; i++ )
		m_Palette.palPalEntry[i].peFlags = 0;
	for ( ; i < (256 - iSysCols); i++ )
		m_Palette.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
	for ( ; i < 256; i++ )
		m_Palette.palPalEntry[i].peFlags = 0;
	if ( bReserveTransparency )
		m_iTransIdx = 256 - iSysCols - 1;
	else
		m_iTransIdx = -1;
	*/
	SetPaletteEntries( m_hPalette, 0, 256, (PALETTEENTRY*) &m_Palette.palPalEntry );

	// we're done
	SelectPalette( hdc, hOldPal, FALSE );
	ReleaseDC( NULL, hdc );
	return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
// Private helpers
///////////////////////////////////////////////////////////////////////////////

void CPalette::DeletePalette()
{
	m_iTransIdx = -1;
	if ( m_hPalette )
	{
		DeleteObject( m_hPalette );
		m_hPalette = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\palfrx.h ===
#ifndef __FRX_PAL_H__
#define __FRX_PAL_H__

#include <windows.h>

#include "tchar.h"

namespace FRX
{

struct FULLLOGPALETTE
{
	WORD				palVersion;
	WORD				palNumEntries;
	PALETTEENTRY		palPalEntry[256];
};


class CPalette
{
public:
	// Constructor and destructor
	CPalette();
	~CPalette();

	// Reference count
	ULONG AddRef();
	ULONG Release();

	// Note: If bReserveTransparency is TRUE, then the highest non-system
	// color index is set to black.  This index can be retrieved through
	// GetTransparencyIndex.

	// Initialize from DIB's colors
	HRESULT Init( const CPalette& Palette );
	HRESULT Init( RGBQUAD* rgb, BOOL bReserveTransparency = TRUE, int iTransIdx = 255 );
	HRESULT Init( HBITMAP hbmp, BOOL bReserveTransparency = TRUE );

	// Remap existing palette to an identity palette.  
	HRESULT RemapToIdentity( BOOL bReserveTransparency = TRUE );

	// Returns index that was reserved for transparency while creating the
	// identity palette.  A value less than 0 means no index was reserved.
	int GetTransparencyIndex()	{ return m_iTransIdx; }

	// Raw information
	HPALETTE	GetHandle()		{ return m_hPalette; }
	LOGPALETTE* GetLogPalette()	{ return (LOGPALETTE*) &m_Palette; }

	// Typecasts
	operator HPALETTE()			{ return GetHandle(); }
	operator LOGPALETTE*()		{ return GetLogPalette(); }
	
	// Palette info
	BOOL IsPalettizedDevice( HDC hdc );
	int GetNumSystemColors( HDC hdc );
	
	// Check for identity palette
	BOOL IsIdentity();
	BOOL IsIdentity1();

protected:
	HPALETTE		m_hPalette;
	FULLLOGPALETTE	m_Palette;
	int				m_iTransIdx;

	// reference count
	ULONG m_RefCnt;

	// helper functions
	void DeletePalette();
};

}

using namespace FRX;

#endif //!__FRX_PAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\dibsec.cpp ===
#include "dibfrx.h"

#ifndef LAYOUT_RTL
#define LAYOUT_LTR                         0x00000000
#define LAYOUT_RTL                         0x00000001
#define NOMIRRORBITMAP                     0x80000000
#endif

CDibSection::CDibSection()
{
	m_RefCnt = 1;
	m_hBmp = NULL;
	m_pBits = NULL;
	m_hDC = NULL;
	m_hOldBmp = NULL;
	m_hOldPalette = NULL;
	m_lPitch = 0;
	m_fTransIdx = false;
}


CDibSection::~CDibSection()
{
	DeleteBitmap();
}


HRESULT CDibSection::Load( HINSTANCE hInstance, int nResourceId )
{
	// Get rid of previous bitmap
	DeleteBitmap();

	// Pull bitmap from resource file
	m_hBmp = LoadImage( hInstance, MAKEINTRESOURCE(nResourceId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
	if ( !m_hBmp )
		return E_FAIL;
	if ( !GetObject( m_hBmp, sizeof(DIBSECTION), &m_DS ) )
	{
		DeleteBitmap();
		return E_FAIL;
	}
	m_lPitch = WidthBytes( m_DS.dsBmih.biBitCount * m_DS.dsBmih.biWidth );

	// Create device context
	m_hDC = CreateCompatibleDC( NULL );

	if ( !m_hDC )
	{
		DeleteBitmap();
		return E_FAIL;
	}
	m_hOldBmp = SelectObject( m_hDC, m_hBmp );
	
	return NOERROR;
}


HRESULT CDibSection::Create( long width, long height, CPalette& palette, long depth /* = 8 */)
{
	WORD* pIdx;
	FULLBITMAPINFO bmi;

	// Get rid of previous bitmap
	DeleteBitmap();

	// Create device context
	m_hDC = CreateCompatibleDC( NULL );
	if ( !m_hDC )
		return E_FAIL;
	m_hOldPalette = SelectPalette( m_hDC, palette, FALSE );

	// fill in bitmapinfoheader
	bmi.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth			= width;
	bmi.bmiHeader.biHeight			= height;
    bmi.bmiHeader.biPlanes			= 1;
	bmi.bmiHeader.biBitCount		= (WORD) depth;
    bmi.bmiHeader.biCompression		= 0;
	bmi.bmiHeader.biSizeImage		= WidthBytes( width * bmi.bmiHeader.biBitCount ) * height;
	bmi.bmiHeader.biClrUsed			= 0;
	bmi.bmiHeader.biClrImportant	= 0;
    bmi.bmiHeader.biXPelsPerMeter	= 0;
    bmi.bmiHeader.biYPelsPerMeter	= 0;

	// fill in palette
    if(bmi.bmiHeader.biBitCount == 8)
    {
	    pIdx = (WORD*) bmi.bmiColors;
	    for ( int i = 0; i < 256; i++ )
	    {
		    *pIdx++ = (WORD) i;
	    }
	    
	    // create section
	    m_hBmp = CreateDIBSection( m_hDC, (BITMAPINFO*) &bmi, DIB_PAL_COLORS, (void**) &m_pBits, NULL, 0 );
    }
    else
	    m_hBmp = CreateDIBSection( m_hDC, (BITMAPINFO*) &bmi, DIB_RGB_COLORS, (void**) &m_pBits, NULL, 0 );

	if ( !m_hBmp )
	{
		DeleteBitmap();
		return E_FAIL;
	}
	if ( !GetObject( m_hBmp, sizeof(DIBSECTION), &m_DS ) )
	{
		DeleteBitmap();
		return E_FAIL;
	}
	m_lPitch = WidthBytes( m_DS.dsBmih.biBitCount * m_DS.dsBmih.biWidth );
	m_hOldBmp = SelectObject( m_hDC, m_hBmp );
			
    return NOERROR;
}


HRESULT CDibSection::SetColorTable( CPalette& palette )
{
	PALETTEENTRY* palColors;
	RGBQUAD dibColors[256], *pDibColors;
	int i;

    if(GetDepth() != 8)
        return S_FALSE;
	
	// Convert palette entries to dib color table
	palColors = palette.GetLogPalette()->palPalEntry;
	pDibColors = dibColors;
	for ( i = 0; i < 256; i++ )
	{
		pDibColors->rgbRed		= palColors->peRed;
		pDibColors->rgbGreen	= palColors->peGreen;
		pDibColors->rgbBlue		= palColors->peBlue;
		pDibColors->rgbReserved = 0;
		pDibColors++;
		palColors++;
	}

	// Attach color table to dib section
	if (  m_hOldPalette )
		SelectPalette( m_hDC, m_hOldPalette, FALSE );
	m_hOldPalette = SelectPalette( m_hDC, palette, FALSE );
	if (SetDIBColorTable( m_hDC, 0, 256, dibColors ) != 256)
		return E_FAIL;

	return NOERROR;
}


void CDibSection::DeleteBitmap()
{
	m_lPitch = 0;
	m_fTransIdx = false;
	if ( m_hBmp )
	{
		DeleteObject( m_hBmp );
		m_hBmp = NULL;
	}
	if ( m_hDC )
	{
		if ( m_hOldBmp )
		{
			SelectObject( m_hDC, m_hOldBmp );
			m_hOldBmp = NULL;
		}
		if ( m_hOldPalette )
		{
			SelectPalette( m_hDC, m_hOldPalette, FALSE );
			m_hOldPalette = NULL;
		}
		DeleteDC( m_hDC );
		m_hDC = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\sprite.cpp ===
#include "spritefrx.h"

///////////////////////////////////////////////////////////////////////////////
// CSpriteWorld
///////////////////////////////////////////////////////////////////////////////

inline CSpriteWorld::SpriteDibInfo::SpriteDibInfo()
{
	pDib = NULL;
	nResourceId = -1;
}


inline CSpriteWorld::SpriteDibInfo::~SpriteDibInfo()
{
	if ( pDib )
	{
		pDib->Release();
		pDib = NULL;
	}
}


CSpriteWorld::CSpriteWorld()
{
	m_pResourceManager = NULL;
	m_pBackbuffer = NULL;
	m_pBackground = NULL;
	m_Layers = NULL;
	m_nLayers = 0;
	m_RefCnt = 1;
}


CSpriteWorld::~CSpriteWorld()
{
	SpriteDibInfo* info;
	CSprite* sprite;

	// Empty dib list
	while ( info = m_Dibs.PopHead() )
		delete info;

	// Empty modified list
	while ( sprite = m_ModifiedSprites.PopHead() )
		sprite->Release();

	// Delete layers
	if ( m_Layers )
	{
		delete [] m_Layers;
		m_Layers = NULL;
		m_nLayers = 0;
	}

	// Release backbuffer
	if ( m_pBackbuffer )
	{
		m_pBackbuffer->Release();
		m_pBackbuffer = NULL;
	}

	// Release background
	if ( m_pBackground )
	{
		m_pBackground->Release();
		m_pBackground = NULL;
	}
}


HRESULT CSpriteWorld::Init( IResourceManager* pResourceManager, CDibSection* pBackbuffer, CSpriteWorldBackground* pBackground, int nLayers )
{
	HRESULT hr;

	// parameter paranoia
	if ( !pResourceManager || !pBackbuffer || !pBackground || (nLayers <= 0) )
		return E_INVALIDARG;

	// stash instance handle
	m_pResourceManager = pResourceManager;

	// stash pointers
	m_pBackbuffer = pBackbuffer;
	m_pBackbuffer->AddRef();
	m_pBackground = pBackground;
	m_pBackground->AddRef();

	// initialize dirty rectangle list
	hr = m_Dirty.Init();
	if ( FAILED(hr) )
		return hr;

	// initialize layers
	m_nLayers = nLayers + 1;
	m_Layers = new CSpriteLayer[ m_nLayers ];
	if ( !m_Layers )
		return E_OUTOFMEMORY;
	for ( int i = 0; i < m_nLayers; i++ )
		m_Layers[i].SetLayer( i );

	return NOERROR;
}


CSprite* CSpriteWorld::Hit( long x, long y )
{
	CSpriteLayer *layer;
	CSprite* sprite;
	int i;

	for ( layer = &m_Layers[ i = m_nLayers - 1 ]; i >= 1; i--, layer-- )
	{
		if ( sprite = layer->Hit( x, y ) )
			return sprite;
	}
	return NULL;
}


CSprite* CSpriteWorld::Hit( long x, long y, int topLayer, int botLayer )
{
	CSpriteLayer* layer;
	CSprite* sprite;
	int i;

	// clip layers
	if ( topLayer >= m_nLayers )
		topLayer = m_nLayers - 1;
	if ( botLayer < 1 )
		botLayer = 1;

	// search for hits
	for ( layer = &m_Layers[ i = topLayer ]; i >= botLayer; i--, layer-- )
	{
		if ( sprite = layer->Hit( x, y ) )
			return sprite;
	}
	return NULL;
}


HRESULT CSpriteWorld::AddSprite( CSprite* pSprite, int nLayer )
{
	HRESULT hr;
	CSprite* sprite;

	// parameter paranoia
	if ( !pSprite || (pSprite->m_pWorld != NULL) || (nLayer < 0) || (nLayer >= m_nLayers) )
		return E_INVALIDARG;

	// add sprite to layer
	hr = m_Layers[ nLayer ].AddSprite( pSprite );
	if ( FAILED(hr) )
		return hr;

	// add world to sprite
	pSprite->m_pWorld = this;
	AddRef();

	return NOERROR;
}


HRESULT CSpriteWorld::DelSprite( CSprite* pSprite )
{
	int layer;
	HRESULT hr;

	// parameter paranoia
	if ( !pSprite || (pSprite->m_pWorld != this) )
		return E_INVALIDARG;

	// remove sprite from layer
	if ( (layer = pSprite->GetLayer()) >= 0 )
		hr = m_Layers[ layer ].DelSprite( pSprite );
	else
		hr = NOERROR;

	// remove sprite from world
	pSprite->m_pWorld = NULL;
	Release();
		
	return hr;
}


CDibLite* CSpriteWorld::GetDib( int nResourceId )
{
	SpriteDibInfo* info;
	ListNodeHandle pos;

	// do we already have the resource?
	for ( pos = m_Dibs.GetHeadPosition(); pos; pos = m_Dibs.GetNextPosition( pos ) )
	{
		info = m_Dibs.GetObjectFromHandle( pos );
		if ( info->nResourceId == nResourceId )
			return info->pDib;
	}

	// initialize dib resource and add it to list
	if ( !(info = new SpriteDibInfo) )
		return NULL;
	if ( !(info->pDib = new CDibLite) )
		goto abort;
	if ( FAILED( info->pDib->Load( m_pResourceManager, nResourceId ) ) )
		goto abort;
	info->nResourceId = nResourceId;
	if ( !m_Dibs.AddHead( info ) )
		goto abort;
	return info->pDib;

abort:
	if ( info->pDib )
		delete info->pDib;
	delete info;
	return NULL;
}


HRESULT CSpriteWorld::Modified( CSprite* pSprite )
{
	// parameter paranoia
	if ( !pSprite || (pSprite->m_pWorld != this) )
		return E_INVALIDARG;
	
	// set redraw flag
	if ( pSprite->Enabled() )
		pSprite->m_bRedraw = TRUE;
	else
		pSprite->m_bRedraw = FALSE;

	// already in list?
	if ( pSprite->m_bModified )
		return NOERROR;

	// add to modified list
	if ( !m_ModifiedSprites.AddHead( pSprite ) )
		return E_OUTOFMEMORY;
	pSprite->m_bModified = TRUE;
	pSprite->AddRef();
	return NOERROR;
}


void CSpriteWorld::FullDraw( HDC hdc )
{
	CSprite* sprite;

	// replace background
	m_pBackground->Draw( *m_pBackbuffer );

	// redraw layers
	for ( int i = 1; i < m_nLayers; i++ )
		m_Layers[i].FullDraw( m_pBackbuffer );

	// flush modified list
	while ( sprite = m_ModifiedSprites.PopHead() )
	{
		sprite->m_bModified = FALSE;
		sprite->Release();
	}

	// copy backbuffer to hdc
	if ( hdc )
		m_pBackbuffer->Draw( hdc, 0, 0 );
	m_Dirty.Reset();
}


void CSpriteWorld::Draw( HDC hdc )
{

	CSprite* sprite;
	CRect* rc;
	ListNodeHandle pos;
	CSpriteLayer* layer;
	int i, j;

	// Redraw background
	for ( pos = m_ModifiedSprites.GetHeadPosition(); pos; pos = m_ModifiedSprites.GetNextPosition( pos ) )
	{
		sprite = m_ModifiedSprites.GetObjectFromHandle( pos );
		if ( sprite->m_bOldScreenValid )
		{
			rc = &sprite->m_rcScreenOld;
			m_pBackground->Draw( *m_pBackbuffer, rc->left, rc->top, rc );
			m_Dirty.AddRect( rc );
		}
	}

	// Mark sprites for redraw
	MarkSpritesForRedraw();

	// redraw sprites
	for ( i = 1; i < m_nLayers; i++ )
		m_Layers[i].Draw( &m_Dirty, m_pBackbuffer );

	// clean up modified list
	while ( sprite = m_ModifiedSprites.PopHead() )
	{
		sprite->m_bModified = FALSE;
		sprite->Release();
	}

	// draw dirty list
	if ( hdc )
		m_Dirty.Draw( hdc, *m_pBackbuffer );
	m_Dirty.Reset();
}


void CSpriteWorld::MarkSpritesForRedraw()
{
	CSpriteLayer* layer;
	CSpriteLayer* layer2;
	CSprite* sprite;
	CSprite* sprite2;
	CRect* rc;
	int i, j;

	// mark sprites that intersect rectangles in the dirty list
	for ( rc = &m_Dirty.m_Rects[ i = 0]; i < m_Dirty.m_nRects; i++, rc++ )
	{
		for ( layer = &m_Layers[ j = 1]; j < m_nLayers; j++, layer++ )
		{
			for ( sprite = layer->GetFirst(); sprite; sprite = layer->GetNext() )
			{
				if ( sprite->m_bEnabled && !sprite->m_bRedraw && sprite->Intersects( rc ) )
					sprite->m_bRedraw = TRUE;
			}
		}
	}

	// mark sprites that need to be redrawn due to lower layers being redrawn
	for ( layer = &m_Layers[ i = 2 ]; i < m_nLayers; i++, layer++ )
	{
		for ( sprite = layer->GetFirst(); sprite; sprite = layer->GetNext() )
		{
			if ( !sprite->m_bEnabled || sprite->m_bRedraw )
				continue;
			for ( layer2 = &m_Layers[ j = 1]; j < i; j++, layer2++ )
			{
				for ( sprite2 = layer2->GetFirst(); sprite2; sprite2 = layer2->GetNext() )
				{
					if ( !sprite2->m_bEnabled || !sprite2->m_bRedraw || !sprite->Intersects( &sprite2->m_rcScreen ))
						continue;
					sprite->m_bRedraw = TRUE;
					goto outer_loop;
				}
			}
outer_loop:
			;
		}
	}
}


HRESULT CSpriteWorld::RemapToPalette( CPalette& palette )
{
	HRESULT hr;
	ListNodeHandle pos;
	SpriteDibInfo* info;

	// remap sprites
	for ( pos = m_Dibs.GetHeadPosition(); pos; pos = m_Dibs.GetNextPosition(pos) )
	{
		info = m_Dibs.GetObjectFromHandle( pos );
		hr = info->pDib->RemapToPalette( palette, m_pBackground->GetPalette() );
		if ( FAILED(hr) )
			return hr;
	}

	// remap backbuffer
	m_pBackbuffer->SetColorTable( palette );

	// remap background
	m_pBackground->RemapToPalette( palette );

	// recreate backbuffer
	FullDraw( NULL );
	
	return NOERROR;
}


void CSpriteWorld::SetTransparencyIndex( const BYTE* idx )
{
	HRESULT hr;
	ListNodeHandle pos;
	SpriteDibInfo* info;

	for ( pos = m_Dibs.GetHeadPosition(); pos; pos = m_Dibs.GetNextPosition(pos) )
	{
		info = m_Dibs.GetObjectFromHandle( pos );
		info->pDib->SetTransparencyIndex( idx );
	}
}


///////////////////////////////////////////////////////////////////////////////
// CSpriteLayer
///////////////////////////////////////////////////////////////////////////////

CSpriteLayer::CSpriteLayer()
{
	m_Idx = -1;
	m_Iterator = NULL;
}


CSpriteLayer::~CSpriteLayer()
{
	CSprite* sprite;

	// Empty sprite list
	while( sprite = m_Sprites.PopHead() )
	{
		// remove sprite from world
		sprite->m_pWorld->Release();
		sprite->m_pWorld = NULL;

		// remove sprite from layer
		sprite->m_nLayer = -1;
		sprite->Release();
	}
}


CSprite* CSpriteLayer::Hit( long x, long y )
{
	CSprite* sprite;
	ListNodeHandle pos;

	for( pos = m_Sprites.GetHeadPosition(); pos; pos = m_Sprites.GetNextPosition( pos ) )
	{
		sprite = m_Sprites.GetObjectFromHandle( pos );
		if ( sprite->Hit( x, y ) )
			return sprite;
	}
	return NULL;
}


HRESULT CSpriteLayer::AddSprite( CSprite* pSprite )
{
	// add sprite
	if ( !m_Sprites.AddHead( pSprite ) )
		return E_OUTOFMEMORY;
	pSprite->m_nLayer = m_Idx;
	pSprite->AddRef();
	
	return NOERROR;
}


HRESULT CSpriteLayer::DelSprite( CSprite* pSprite )
{
	ListNodeHandle pos;

	// search for sprite
	for( pos = m_Sprites.GetHeadPosition(); pos; pos = m_Sprites.GetNextPosition( pos ) )
	{
		if ( m_Sprites.GetObjectFromHandle( pos ) == pSprite )
		{
			// remove sprite
			m_Sprites.DeleteNode( pos );
			pSprite->m_nLayer = -1;
			pSprite->Release();
			break;
		}
	}

	return NOERROR;
}


void CSpriteLayer::FullDraw( CDibSection* pBackbuffer )
{
	CSprite* sprite;
	ListNodeHandle pos;

	for( pos = m_Sprites.GetHeadPosition(); pos; pos = m_Sprites.GetNextPosition( pos ) )
	{
		sprite = m_Sprites.GetObjectFromHandle( pos);
		if ( sprite->m_bEnabled )
		{
			sprite->Draw();
			sprite->m_bRedraw = FALSE;
			sprite->m_bOldScreenValid = TRUE;
			sprite->m_rcScreenOld = sprite->m_rcScreen;
		}
	}
}


void CSpriteLayer::Draw( CDirtyList* pDirty, CDibSection* pBackbuffer )
{
	CSprite* sprite;
	ListNodeHandle pos;

	for( pos = m_Sprites.GetHeadPosition(); pos; pos = m_Sprites.GetNextPosition( pos ) )
	{
		sprite = m_Sprites.GetObjectFromHandle( pos);
		if ( sprite->m_bRedraw && sprite->m_bEnabled )
		{
			sprite->Draw();
			pDirty->AddRect( &sprite->m_rcScreen );
			sprite->m_bRedraw = FALSE;
			sprite->m_bOldScreenValid = TRUE;
			sprite->m_rcScreenOld = sprite->m_rcScreen;
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// CDibSprite 
///////////////////////////////////////////////////////////////////////////////

CSprite::CSprite()
	: m_rcScreen( -1, -1, -1, -1 ),
	  m_rcScreenOld( -1, -1, -1, -1 )
{
	
	m_pWorld = NULL;
	m_bEnabled = FALSE;
	m_bModified = FALSE;
	m_bRedraw = FALSE;
	m_bOldScreenValid = FALSE;
	m_X = -1;
	m_Y = -1;
	m_Width = -1;
	m_Height = -1;
	m_Cookie = -1;
	m_nLayer = -1;
	m_RefCnt = 1;
}


CSprite::~CSprite()
{
	if ( m_pWorld )
	{
		m_pWorld->DelSprite( this );
		m_pWorld = NULL;
	}
}


HRESULT CSprite::Init( CSpriteWorld* pWorld, int nLayer, DWORD dwCookie, long width, long height )
{
	// parameter paranoia
	if ( !pWorld || (nLayer < 0) )
		return E_INVALIDARG;
	m_Cookie = dwCookie;
	SetImageDimensions( width, height );
	pWorld->AddSprite( this, nLayer );
	return NOERROR;
}


void CSprite::SetImageDimensions( long width, long height )
{
	m_Width = width;
	m_Height = height;
	m_rcScreen.SetRect( m_X, m_Y, m_X + width - 1, m_Y + height - 1 );
}


void CSprite::SetEnable( BOOL bEnable )
{
	if ( bEnable == m_bEnabled )
		return;
	m_bEnabled = bEnable;
	m_pWorld->Modified( this );
}


void CSprite::SetLayer( int nLayer )
{
	if ( nLayer == m_nLayer )
		return;
	if ( m_nLayer >= 0 )
		m_pWorld->m_Layers[ m_nLayer ].DelSprite( this );
	m_pWorld->m_Layers[ nLayer ].AddSprite( this );
	m_pWorld->Modified( this );
}


void CSprite::SetXY( long x, long y )
{
	if ( (x == m_X) && (y == m_Y))
		return;
	m_X = x;
	m_Y = y;
	m_rcScreen.SetRect( x, y, x + m_Width - 1, y + m_Height - 1);
	m_pWorld->Modified( this );
}


///////////////////////////////////////////////////////////////////////////////
// CDibSprite
///////////////////////////////////////////////////////////////////////////////

CDibSprite::SpriteState::SpriteState()
{
	pDib = NULL;
	RectId = -1;

}


CDibSprite::SpriteState::~SpriteState()
{
	if ( pDib )
	{
		pDib->Release();
		pDib = NULL;
	}
}


CDibSprite::CDibSprite()
	: m_rcImage( -1, -1, -1, -1 )
{
	m_pDib = NULL;
	m_pRects = NULL;
	m_States = NULL;
	m_nStates = 0;
	m_State = -1;
	m_RectId = -1;
}


CDibSprite::~CDibSprite()
{
	if ( m_States )
	{
		delete [] m_States;
		m_States = NULL;
	}
}


HRESULT CDibSprite::Init(
			CSpriteWorld* pWorld,
			CRectList* pRects,
			HINSTANCE hInstance,
			int nLayer,
			DWORD dwCookie,
			int nInitState,
			SpriteInfo* pSpriteInfo,
			int nStates )
{
	HRESULT status = NOERROR;
	int i;

	// parameter paranoia
	if ( !pWorld || !pSpriteInfo || (nStates <= 0) || (nInitState < 0) || (nInitState >= nStates) )
		return E_INVALIDARG;

	// stash rectangle list
	m_pRects = pRects;

	// initialize states
	m_States = new SpriteState[ m_nStates = nStates ];
	if ( !m_States )
	{
		status = E_OUTOFMEMORY;
		goto abort;
	}
	for ( i = 0; i < m_nStates; i++ )
	{
		m_States[i].RectId = pSpriteInfo[i].nRectId;
		m_States[i].pDib = pWorld->GetDib( pSpriteInfo[i].nResourceId );
		if ( m_States[i].pDib )
			m_States[i].pDib->AddRef();
		else
		{
			status = E_OUTOFMEMORY;
			goto abort;
		}
			
		if ( m_States[i].RectId == -1 )
		{
			m_States[i].Width = m_States[i].pDib->GetWidth();
			m_States[i].Height = m_States[i].pDib->GetHeight();
		}
		else
		{
			m_States[i].Width = (*pRects)[ m_States[i].RectId ].GetWidth();
			m_States[i].Height = (*pRects)[ m_States[i].RectId ].GetHeight();
		}
	}

	// parent initialization
	status = CSprite::Init( pWorld, nLayer, dwCookie, m_States[nInitState].Width, m_States[nInitState].Height );
	if ( FAILED(status) )
		goto abort;

	// set state
	SetState( nInitState );

	// parent initialization
	status = CSprite::Init( pWorld, nLayer, dwCookie, m_Width, m_Height );
	if ( FAILED(status) )
		goto abort;

	// we're done
	return NOERROR;

abort:
	// clean up and exit
	if ( m_States )
	{
		delete [] m_States;
		m_States = NULL;
	}
	return status;
}


void CDibSprite::SetState( int idx )
{
	if ( (idx < 0) || (idx >= m_nStates) || (idx == m_State) )
		return;
	m_State = idx;
	m_pDib = m_States[idx].pDib;
	m_RectId = m_States[idx].RectId;
	if ( m_RectId > -1 )
		m_rcImage = (*m_pRects)[ m_RectId ];
	SetImageDimensions( m_States[idx].Width, m_States[idx].Height );
	m_pWorld->Modified( this );
}


void CDibSprite::Draw()
{
	if ( m_RectId > -1 )
	{
		if ( !m_pDib->GetTransparencyIndex() )
			m_pDib->Draw( *m_pWorld->GetBackbuffer(), m_X, m_Y, &m_rcImage);
		else
			m_pDib->DrawT( *m_pWorld->GetBackbuffer(), m_X, m_Y, &m_rcImage );
	}
	else
	{
		if ( !m_pDib->GetTransparencyIndex() )
			m_pDib->Draw( *m_pWorld->GetBackbuffer(), m_X, m_Y);
		else
			m_pDib->DrawT( *m_pWorld->GetBackbuffer(), m_X, m_Y );
	}
}

void CDibSprite::DrawRTL()
{
	if ( m_RectId > -1 )
	{
		ASSERT(!"NOT IMPLEMENTED");
	}
	else
	{
		if ( !m_pDib->GetTransparencyIndex() )
			m_pDib->Draw( *m_pWorld->GetBackbuffer(), m_X, m_Y, TRUE );
		else
			ASSERT(!"NOT IMPLEMENTED");
			/*m_pDib->DrawT( *m_pWorld->GetBackbuffer(), m_X, m_Y );*/
	}
}

///////////////////////////////////////////////////////////////////////////////
// CSpriteWorldBackgroundDib
///////////////////////////////////////////////////////////////////////////////


CSpriteWorldBackgroundDib::CSpriteWorldBackgroundDib()
{
	m_pDib = NULL;
}

CSpriteWorldBackgroundDib::~CSpriteWorldBackgroundDib()
{
	if ( m_pDib )
		m_pDib->Release();
}

HRESULT CSpriteWorldBackgroundDib::Init( CDib* pDib )
{
	m_pDib = pDib;
	m_pDib->AddRef();
	return NOERROR;
}

void CSpriteWorldBackgroundDib::Draw( CDibSection& dest )
{
	m_pDib->Draw( dest, 0, 0 );
}

void CSpriteWorldBackgroundDib::Draw( CDibSection& dest, long dx, long dy, const RECT* rc )
{
	m_pDib->Draw( dest, dx, dy, rc );
}

HRESULT CSpriteWorldBackgroundDib::RemapToPalette( CPalette& palette, BOOL bUseIndex )
{
	return m_pDib->RemapToPalette( palette, bUseIndex );
}

RGBQUAD* CSpriteWorldBackgroundDib::GetPalette()
{
	return m_pDib->GetBitmapInfo()->bmiColors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\spritefrx.h ===
#ifndef __SPRITE_H__
#define __SPRITE_H__

#include "queue.h"
#include "dibfrx.h"
#include "palfrx.h"
#include "dirtyfrx.h"
#include "debugfrx.h"

namespace FRX
{

// forward references
class CSpriteWorld;

class CSprite
{
	friend class CSpriteWorld;
	friend class CSpriteLayer;

public:
	// constructor and destructor
			CSprite();
	virtual ~CSprite();

	// reference count
	ULONG AddRef();
	ULONG Release();

	// initializier
	HRESULT Init( CSpriteWorld* pWorld, int nLayer, DWORD dwCookie, long width, long height );

	// hit tests
	BOOL Hit( long x, long y );
	BOOL Intersects( const RECT* rc );

	// draw into world
	virtual void Draw() = 0;
	virtual void DrawRTL() { ASSERT(!"RTL NOT IMPLEMENTED"); }

	// set properties
	void SetEnable( BOOL bEnable );
	void SetLayer( int nLayer );
	void SetXY( long x, long y );
	void SetCookie( DWORD cookie );
	
	// query properties
	BOOL	Enabled();
	DWORD	GetCookie();
	int		GetLayer();
	void	GetXY( long* px, long* py );
	long	GetHeight();
	long	GetWidth();

	void SetImageDimensions( long width, long height );

protected:
	// helpers
	
	// position data
	long	m_X;
	long	m_Y;
	long	m_Width;
	long	m_Height;
	CRect	m_rcScreen;
	CRect	m_rcScreenOld;
	
	// world pointer
	CSpriteWorld* m_pWorld;

	// layer index
	int m_nLayer;

	// flags
	BOOL m_bEnabled;
	BOOL m_bModified;
	BOOL m_bRedraw;
	BOOL m_bOldScreenValid;

	// reference count
	ULONG m_RefCnt;

	// cookie
	DWORD m_Cookie;
};


struct SpriteInfo
{
	int nResourceId;		// bitmap in resource file
	int nRectId;			// cut-out rectangle in pRects, -1 implies whole image
};

class CDibSprite : public CSprite
{
public:
	// constructor and destructor
	CDibSprite();
	~CDibSprite();

	// initializier
	HRESULT Init( CSpriteWorld* pWorld, CRectList* pRects, HINSTANCE hInstance, int nLayer, DWORD dwCookie, int nInitState, SpriteInfo* pSpriteInfo, int nStates );

	// draw function
	void Draw();
	void DrawRTL();

	// set properties
	void	SetState( int idx );
	int		GetState();

	// get properties
	long	GetStateWidth( int idx );
	long	GetStateHeight( int idx );
	
	
protected:
	
	struct SpriteState
	{
		SpriteState();
		~SpriteState();

		CDibLite*	pDib;
		int			RectId;
		long		Width;
		long		Height;
	};
	
	// state info
	int				m_nStates;
	int				m_State;
	int				m_RectId;
	CRect			m_rcImage;
	CDibLite*		m_pDib;
	SpriteState*	m_States;
	
	// rectangle list
	CRectList* m_pRects;
};

///////////////////////////////////////////////////////////////////////////////

class CSpriteWorldBackground
{
public:
	// constructor
			CSpriteWorldBackground()	{ m_RefCnt = 1;}
	virtual	~CSpriteWorldBackground()	{ ; }

	// reference counting
	ULONG AddRef();
	ULONG Release();

	// draw functions
	virtual void Draw( CDibSection& dest ) = 0;
	virtual void Draw( CDibSection& dest, long dx, long dy, const RECT* rc ) = 0;

	// palette functions
	virtual HRESULT		RemapToPalette( CPalette& palette, BOOL bUseIndex = FALSE ) = 0;
	virtual RGBQUAD*	GetPalette() = 0;

protected:

	// Reference count
	ULONG	m_RefCnt;
};


class CSpriteWorldBackgroundDib : public CSpriteWorldBackground
{
public:
	// constructor and destructor
	CSpriteWorldBackgroundDib();
	~CSpriteWorldBackgroundDib();

	// initialize
	HRESULT Init( CDib* pDib );

	// draw functions
	void Draw( CDibSection& dest );
	void Draw( CDibSection& dest, long dx, long dy, const RECT* rc );

	// palette functions
	HRESULT		RemapToPalette( CPalette& palette, BOOL bUseIndex = FALSE );
	RGBQUAD*	GetPalette();

protected:
	CDib*	m_pDib;
};

///////////////////////////////////////////////////////////////////////////////

class CSpriteWorld
{
	friend class CSprite;
	friend class CSpriteLayer;

public:
	// constructor and destructors
	CSpriteWorld();
	~CSpriteWorld();

	// reference counting
	ULONG AddRef();
	ULONG Release();

	// initializer
	HRESULT Init( IResourceManager* pResourceManager, CDibSection* pBackbuffer, CSpriteWorldBackground* pBackground, int nLayers );

	// hit test
	CSprite* Hit( long x, long y );
	CSprite* Hit( long x, long y, int topLayer, int botLayer );

	// manage sprites
	HRESULT AddSprite( CSprite* pSprite, int nLayer );
	HRESULT DelSprite( CSprite* pSprite );
	HRESULT Modified( CSprite* pSprite );

	// manage dibs
	CDibLite*		GetDib( int nResourceId );
	CDibSection*	GetBackbuffer();

	// palette stuff
	HRESULT RemapToPalette( CPalette& palette );
	void SetTransparencyIndex( const BYTE* idx );

	// draw world
	void Draw( HDC hdc );
	void FullDraw( HDC hdc );

protected:
	// helper functions
	void MarkSpritesForRedraw();

	// private structures
	struct SpriteDibInfo
	{
		SpriteDibInfo();
		~SpriteDibInfo();
		CDibLite*	pDib;				// dib pointer
		int			nResourceId;		// resource id
	};

	// Instance handle
	IResourceManager* m_pResourceManager;

	// Reference count
	ULONG m_RefCnt;

	// Pointer to DIB section backbuffer
	CDibSection* m_pBackbuffer;

	// Pointer to the background sprite
	CSpriteWorldBackground* m_pBackground;

	// Layer list
	CSpriteLayer* m_Layers;
	int			  m_nLayers;

	// Dirty rectangles
	CDirtyList	m_Dirty;

	// Modified sprite list
	CList<CSprite> m_ModifiedSprites;

	// Dib list
	CList<SpriteDibInfo> m_Dibs;
};

///////////////////////////////////////////////////////////////////////////////

class CSpriteLayer
{
	friend class CSpriteWorld;

public:
	// constructor and destructor
	CSpriteLayer();
	~CSpriteLayer();

	// hit test
	CSprite* Hit( long x, long y );

	// sprite management
	HRESULT AddSprite( CSprite* pSprite );
	HRESULT DelSprite( CSprite* pSprite );

	// iteratoration
	CSprite* GetFirst();
	CSprite* GetNext();

	// draw sprites
	void Draw( CDirtyList* pDirty, CDibSection* pBackbuffer );
	void FullDraw( CDibSection* pBackbuffer );

protected:
	// set layer's index
	void SetLayer( int Idx );
	
	// list of layer's sprites
	CList<CSprite> m_Sprites;

	// linked list node handle for iterator
	ListNodeHandle m_Iterator;

	// layers index
	int m_Idx;
};


///////////////////////////////////////////////////////////////////////////////
// CSprite Inlines
///////////////////////////////////////////////////////////////////////////////

inline ULONG CSprite::AddRef()
{
	return ++m_RefCnt;
}


inline ULONG CSprite::Release()
{
	WNDFRX_ASSERT( m_RefCnt > 0 );
	if ( --m_RefCnt <= 0 )
	{
		delete this;
		return 0;
	}
	return m_RefCnt;
}


inline BOOL CSprite::Enabled()
{
	return m_bEnabled;
}


inline void CSprite::SetCookie( DWORD cookie )
{
	m_Cookie = cookie;
}


inline DWORD CSprite::GetCookie()
{
	return m_Cookie;
}


inline void CSprite::GetXY( long* px, long* py )
{
	*px = m_X;
	*py = m_Y;
}


inline long	CSprite::GetHeight()
{
	return m_Height;
}


inline long CSprite::GetWidth()
{
	return m_Width;
}


inline int CSprite::GetLayer()
{
	return m_nLayer;
}

inline BOOL CSprite::Hit( long x, long y )
{
	if ( !m_bEnabled )
		return FALSE;
	return m_rcScreen.PtInRect( x, y );
}


inline BOOL CSprite::Intersects( const RECT* rc )
{
	if ( !m_bEnabled )
		return FALSE;
	return m_rcScreen.Intersects( rc );
}


///////////////////////////////////////////////////////////////////////////////
// CDibSprite Inlines
///////////////////////////////////////////////////////////////////////////////

inline int CDibSprite::GetState()
{
	return m_State;
}


inline long	CDibSprite::GetStateWidth( int idx )
{
	return m_States[idx].Width;
}


inline long	CDibSprite::GetStateHeight( int idx )
{
	return m_States[idx].Height;
}


///////////////////////////////////////////////////////////////////////////////
// CSpriteWorldBackground Inlines
///////////////////////////////////////////////////////////////////////////////

inline ULONG CSpriteWorldBackground::AddRef()
{
	return ++m_RefCnt;
}


inline ULONG CSpriteWorldBackground::Release()
{
	WNDFRX_ASSERT( m_RefCnt > 0 );
	if ( --m_RefCnt <= 0 )
	{
		delete this;
		return 0;
	}
	return m_RefCnt;
}

///////////////////////////////////////////////////////////////////////////////
// CSpriteWorld Inlines
///////////////////////////////////////////////////////////////////////////////

inline ULONG CSpriteWorld::AddRef()
{
	return ++m_RefCnt;
}


inline ULONG CSpriteWorld::Release()
{
	WNDFRX_ASSERT( m_RefCnt > 0 );
	if ( --m_RefCnt <= 0 )
	{
		delete this;
		return 0;
	}
	return m_RefCnt;
}


inline CDibSection*	CSpriteWorld::GetBackbuffer()
{
	return m_pBackbuffer;
}


///////////////////////////////////////////////////////////////////////////////
// CSpriteLayer Inlines
///////////////////////////////////////////////////////////////////////////////

inline void CSpriteLayer::SetLayer( int Idx )
{
	m_Idx = Idx;
}


inline CSprite* CSpriteLayer::GetFirst()
{
	m_Iterator = m_Sprites.GetHeadPosition();
	return m_Iterator ? m_Sprites.GetObjectFromHandle( m_Iterator ) : NULL;
}


inline CSprite* CSpriteLayer::GetNext()
{
	m_Iterator = m_Sprites.GetNextPosition( m_Iterator );
	return m_Iterator ? m_Sprites.GetObjectFromHandle( m_Iterator ) : NULL;
}

}

using namespace FRX;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\wnd.cpp ===
#include "wndfrx.h"
#include "lobbymsg.h"

CWindow2::CWindow2()
{
	m_hWnd = NULL;
	m_hInstance = NULL;
	m_hParentWnd = NULL;
	m_fDestroyed = FALSE;
	m_nRefCnt = 1;
}


CWindow2::~CWindow2()
{
	if (m_hWnd && !m_fDestroyed && IsWindow(m_hWnd) )
	{
		DestroyWindow( m_hWnd );
		m_hWnd = NULL;
	}
}


HRESULT CWindow2::Init( HINSTANCE hInstance, const TCHAR* szTitle, HWND hParent, RECT* pRect, int nShow )
{
	WNDCLASSEX	WndClass, WndClass2;
	WNDPARAMS	WndParams;

	// Stash parameters
	m_hInstance = hInstance;
	m_hParentWnd = hParent;

	// Setup window class parameters
	WndClass.cbSize			= sizeof(WndClass);
	WndClass.style			= CS_BYTEALIGNWINDOW | CS_OWNDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
	WndClass.lpfnWndProc	= GetWndProc();
	WndClass.lpszClassName	= GetClassName();
	WndClass.cbClsExtra		= 0;
	WndClass.cbWndExtra		= DLGWINDOWEXTRA;
    WndClass.hInstance		= m_hInstance;
    WndClass.hIcon			= LoadIcon( NULL, IDI_APPLICATION );
	WndClass.hIconSm		= LoadIcon( NULL, IDI_APPLICATION );
	WndClass.hCursor		= LoadCursor( NULL, IDC_ARROW );
    WndClass.hbrBackground	= GetStockObject( WHITE_BRUSH );
    WndClass.lpszMenuName	= NULL;
	OverrideClassParams( WndClass );

	WndClass2.cbSize		= sizeof(WndClass2);

	// Register window class
	if (GetClassInfoEx( m_hInstance, WndClass.lpszClassName, &WndClass2 ))
	{
		// Does a class with the same name already exists
		if (	(WndClass2.style != WndClass.style)
			||	(WndClass2.lpfnWndProc != WndClass.lpfnWndProc)
			||	(WndClass2.cbClsExtra != WndClass.cbClsExtra)
			||	(WndClass2.cbWndExtra != WndClass.cbWndExtra)
			||	(WndClass2.hIcon != WndClass.hIcon)
			||	(WndClass2.hCursor != WndClass.hCursor)
			||	(WndClass2.hbrBackground != WndClass.hbrBackground)
			||	(WndClass2.lpszMenuName != WndClass.lpszMenuName) )
		{
			// Class has different properties --> Name conflict
			return E_FAIL;
		}
	}
	else
	{
		if (!RegisterClassEx( &WndClass ))
			return E_FAIL;
	}

	// Create window
	WndParams.dwExStyle = 0;
	WndParams.dwStyle = WS_OVERLAPPEDWINDOW | WS_VISIBLE;
	WndParams.hMenu = NULL;
	if (pRect)
	{
		WndParams.x = pRect->left;
		WndParams.y = pRect->top;
		WndParams.nWidth = pRect->right - pRect->left;
		WndParams.nHeight = pRect->bottom - pRect->top;
	}
	else
	{
		WndParams.x = CW_USEDEFAULT;
		WndParams.y = CW_USEDEFAULT;
		WndParams.nWidth = CW_USEDEFAULT;
		WndParams.nHeight = CW_USEDEFAULT;
	}
	OverrideWndParams( WndParams );

	m_hWnd = CreateWindowEx(
				WndParams.dwExStyle,
				WndClass.lpszClassName,
				(szTitle) ? szTitle : _T(""),
				WndParams.dwStyle,
				WndParams.x,
				WndParams.y,
				WndParams.nWidth,
				WndParams.nHeight,
				m_hParentWnd,
			    WndParams.hMenu,
				m_hInstance,
				(LPVOID) this );
	if (!m_hWnd)
	{
		m_fDestroyed = TRUE;
		return E_FAIL;
	}
	else
		m_fDestroyed = FALSE;

	// Display window
	ShowWindow( m_hWnd, nShow );
	if (nShow != SW_HIDE)
		UpdateWindow( m_hWnd );

	return NOERROR;
}


void CWindow2::OverrideClassParams( WNDCLASSEX& WndClass )
{
}


void CWindow2::OverrideWndParams( WNDPARAMS& WndParams )
{
}


BOOL CWindow2::CenterWindow( HWND hParent )
{
	RECT rcChild, rcParent;
	int x, y;

	GetWindowRect( m_hWnd, &rcChild );
	if ( hParent )
	{
		GetWindowRect( hParent, &rcParent );
	}
	else
	{
		rcParent.left	= 0;
		rcParent.top	= 0;
		rcParent.right	= GetSystemMetrics(SM_CXSCREEN);
		rcParent.bottom	= GetSystemMetrics(SM_CYSCREEN);
	}
	x = rcParent.left + ((rcParent.right - rcParent.left) - (rcChild.right - rcChild.left)) / 2;
	y = rcParent.top + ((rcParent.bottom - rcParent.top) - (rcChild.bottom - rcChild.top)) / 2;

	return SetWindowPos( m_hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER );
}


///////////////////////////////////////////////////////////////////////////////

CDialog::CDialog()
{
	m_nResult = 0;
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	m_nResourceId = -1;
	m_hInstance = NULL;
	m_hWnd = NULL;
	m_hParent = NULL;
	m_fRegistered = FALSE;
	m_uStartMsg = WM_NULL;
	m_uEndMsg = WM_NULL;
    m_fMoving = FALSE;
}


CDialog::~CDialog()
{
	if ( m_hWnd )
	{
		Unregister();
		Close( 0 );
        if(m_hWnd)
		    SetWindowLong(m_hWnd, GWL_USERDATA, NULL);
		m_hWnd = NULL;
	}
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
}

HRESULT CDialog::Init( IZoneShell *pZoneShell, int nResourceId )
{
	// save params
	m_nResourceId = nResourceId;

    m_pZoneShell.Release();
	m_pZoneShell = pZoneShell;

	m_hInstance = NULL;

	// shutdown old instance
	if ( m_hWnd )
	{
		Unregister();
		Close( 0 );
        if(m_hWnd)
		    SetWindowLong(m_hWnd, GWL_USERDATA, NULL);
		m_hWnd = NULL;
	}

	// reset everything else
	m_nResult = 0;
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	m_hWnd = NULL;
	m_hParent = NULL;
	m_uStartMsg = WM_NULL;
	m_uEndMsg = WM_NULL;
    m_fMoving = FALSE;

	// gee, no errors
	return NOERROR;
}

HRESULT CDialog::Init( HINSTANCE hInstance, int nResourceId )
{
	// save params
	m_nResourceId = nResourceId;
	m_hInstance = hInstance;

    m_pZoneShell.Release();

	// shutdown old instance
	if ( m_hWnd )
	{
		Unregister();
		Close( 0 );
        if(m_hWnd)
		    SetWindowLong(m_hWnd, GWL_USERDATA, NULL);
		m_hWnd = NULL;
	}

	// reset everything else
	m_nResult = 0;
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	m_hWnd = NULL;
	m_hParent = NULL;
	m_uStartMsg = WM_NULL;
	m_uEndMsg = WM_NULL;
    m_fMoving = FALSE;

	// gee, no errors
	return NOERROR;
}


void CDialog::Close( int nResult )
{
	m_nResult = nResult;
	switch( m_nLaunchMethod )
	{
	case NotActive:
		break;
	case ModalLaunch:
		EndDialog( m_hWnd, nResult );
        m_hWnd = NULL;
		break;
	case ModelessLaunch:
		if(m_fThreadLaunch)
		{
            // this is because Windows seems to ignore WM_DESTROY if the user has grabbed a window and is moving or sizing it.
            // the faked ESCAPE keypress causes the Window to drop, and then WM_DESTROY can get through.
            // m_fMoving is maintained in the MESSAGE_MAP macros
            if(m_fMoving)
                PostMessage( m_hWnd, WM_KEYDOWN, VK_ESCAPE, 0x01 );

			PostMessage( m_hWnd, WM_DESTROY, 0, 0 );
			PostMessage( m_hWnd, WM_NCDESTROY, 0, 0 );
			PostMessage( m_hWnd, WM_QUIT, 0, 0 );
		}
		else
        {
            if(m_fMoving)
                SendMessage( m_hWnd, WM_KEYDOWN, VK_ESCAPE, 0x01 );

			DestroyWindow(m_hWnd);
            m_hWnd = NULL;
        }
		break;
	}
}


int CDialog::Modal( HWND hParent )
{
	m_nLaunchMethod = ModalLaunch;
	
	if (m_hInstance )
		m_nResult = DialogBoxParam(m_hInstance, MAKEINTRESOURCE(m_nResourceId), hParent, GetDlgProc(), (long) this );

	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	return m_nResult;
}


HRESULT CDialog::Modeless( HWND hParent )
{
	m_nLaunchMethod = ModelessLaunch;
    m_fMoving = FALSE;
    m_hWnd = NULL;

	if ( m_pZoneShell )
    {
        CComPtr<IResourceManager> pRes;
	    HRESULT hr = m_pZoneShell->QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &pRes );
        if(SUCCEEDED(hr))
		    m_hWnd = pRes->CreateDialogParam(m_hInstance, MAKEINTRESOURCE(m_nResourceId), hParent, GetDlgProc(), (long) this );
    }
	else if ( m_hInstance )
		m_hWnd = CreateDialogParam(m_hInstance, MAKEINTRESOURCE(m_nResourceId), hParent, GetDlgProc(), (long) this );

	if ( m_hWnd )
	{
		ShowWindow( m_hWnd, SW_SHOW );
		return NOERROR;
	}
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	return E_FAIL;
}


HRESULT CDialog::ModalViaThread( HWND hParent, UINT uStartMsg, UINT uEndMsg )
{
	HANDLE hThread;
	DWORD threadId;

	// Stash params
	m_hParent = hParent;
	m_uStartMsg = uStartMsg;
	m_uEndMsg = uEndMsg;

	// Create modal dialog box in it's own thread
	m_fThreadLaunch = TRUE;
	if ( hThread = CreateThread( NULL, 0, ModalThread, this, 0, &threadId ) )
	{
		m_nLaunchMethod = ModalLaunch;
		CloseHandle( hThread );
		return NOERROR;
	}

	// Thread creation failed
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	return E_FAIL;
}


HRESULT CDialog::ModelessViaThread( HWND hParent, UINT uStartMsg, UINT uEndMsg )
{
	HANDLE hThread;
	DWORD threadId;

	// Stash params
	m_hParent = hParent;
	m_uStartMsg = uStartMsg;
	m_uEndMsg = uEndMsg;

	// Create modal dialog box in it's own thread
	m_fThreadLaunch = TRUE;
	if ( hThread = CreateThread( NULL, 0, ModelessThread, this, 0, &threadId ) )
	{
		m_nLaunchMethod = ModelessLaunch;
		CloseHandle( hThread );
		return NOERROR;
	}

	// Thread creation failed
	m_nLaunchMethod = NotActive;
	m_fThreadLaunch = FALSE;
	return E_FAIL;
}


HRESULT CDialog::ModelessViaRegistration( HWND hParent )
{
	HRESULT res;

	res = Modeless(hParent);

	if(res == NOERROR)
	{
		SetWindowLong(m_hWnd, GWL_USERDATA, (long) this);

        if(m_pZoneShell)
        {
            res = m_pZoneShell->AddDialog(m_hWnd, true);
            if(SUCCEEDED(res))
                m_fRegistered = TRUE;
        }
        else
        {
		    if(!PostMessage(NULL, TM_REGISTER_DIALOG, (WPARAM) m_hWnd, (LPARAM) RegistrationCallback))
			    res = E_FAIL;
		    else
			    m_fRegistered = TRUE;
        }
	}

	return res;
}


// this only gets called for non-Z6-shell registration
void CALLBACK CDialog::RegistrationCallback(HWND hWnd, DWORD dwReason)
{
	CDialog *pThis;

	pThis = (CDialog *) GetWindowLong(hWnd, GWL_USERDATA);
	if(dwReason != REGISTER_DIALOG_SUCCESS)
	{
		pThis->m_fRegistered = FALSE;
		pThis->Close(dwReason);
	}
	pThis->ReceiveRegistrationStatus(dwReason);
}


void CDialog::ReceiveRegistrationStatus(DWORD dwReason)
{
	if(dwReason != REGISTER_DIALOG_SUCCESS)
		MessageBox(NULL, _T("Unable to create a dialog box.\r\nPlease close some others and try again."), _T("Zone"), MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
}


void CDialog::Unregister()
{
	if(m_fRegistered)
    {
        if(m_pZoneShell)
            m_pZoneShell->RemoveDialog(m_hWnd, true);
        else
		    PostMessage(NULL, TM_UNREGISTER_DIALOG, (WPARAM) m_hWnd, NULL);
    }
	m_fRegistered = FALSE;
}


DWORD WINAPI CDialog::ModalThread( VOID* cookie )
{
	CDialog* pObj;

	if ( !(pObj = (CDialog*) cookie) )
		return 0;

	SendMessage( pObj->m_hParent, pObj->m_uStartMsg, 0, 0 );
	pObj->Modal( pObj->m_hParent );
	SendMessage( pObj->m_hParent, pObj->m_uEndMsg, 0, 0 );
	return 0;
}


DWORD WINAPI CDialog::ModelessThread( VOID* cookie )
{
	MSG msg;
	CDialog* pObj;

	if ( !(pObj = (CDialog*) cookie) )
		return 0;
	if ( FAILED(pObj->Modeless( pObj->m_hParent )) )
		return 0;

	// private message loop for dialog
	SendMessage( pObj->m_hParent, pObj->m_uStartMsg, 0, 0 );
	while ( GetMessage( &msg, pObj->m_hWnd, 0, 0 ) )
 	{
		if ( !IsDialogMessage( pObj->m_hWnd, &msg ) )
		{
			TranslateMessage( &msg );
			DispatchMessage( &msg );
		}
	}
	pObj->m_nLaunchMethod = NotActive;
	pObj->m_fThreadLaunch = FALSE;
	SendMessage( pObj->m_hParent, pObj->m_uEndMsg, 0, 0 );
	return 0;
}


BOOL CDialog::CenterWindow( HWND hParent )
{
	RECT rcChild, rcParent;
	int x, y;

	GetWindowRect( m_hWnd, &rcChild );
	if ( hParent )
	{
		GetWindowRect( hParent, &rcParent );
	}
	else
	{
		rcParent.left	= 0;
		rcParent.top	= 0;
		rcParent.right	= GetSystemMetrics(SM_CXSCREEN);
		rcParent.bottom	= GetSystemMetrics(SM_CYSCREEN);
	}
	x = rcParent.left + ((rcParent.right - rcParent.left) - (rcChild.right - rcChild.left)) / 2;
	y = rcParent.top + ((rcParent.bottom - rcParent.top) - (rcChild.bottom - rcChild.top)) / 2;

	return SetWindowPos( m_hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\wndfrx.h ===
#ifndef __FRX_WND_H__
#define __FRX_WND_H__

#include <windows.h>
#include "basicatl.h"
#include "wndxfrx.h"
#include "debugfrx.h"
#include "serviceid.h"
#include "ResourceManager.h"
#include "zoneevent.h"
#include "zoneshell.h"
#include "uapi.h"

namespace FRX
{

///////////////////////////////////////////////////////////////////////////////
// Message map macros
///////////////////////////////////////////////////////////////////////////////

#define BEGIN_MESSAGE_MAP(theClass)	\
public:																					\
	virtual WNDPROC		GetWndProc()	{ return (WNDPROC) WndProc; }					\
	virtual const TCHAR* GetClassName()	{ return (TCHAR*) _T("Zone ")_T(#theClass)_T("Wnd Class"); }		\
	static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)	\
	{																					\
		if ( !ConvertMessage( hwnd, uMsg, &wParam, &lParam ) )							\
		{																				\
			return 0;																	\
		}																				\
																						\
		theClass* pImpl = NULL;															\
		if(uMsg == WM_NCCREATE)															\
		{																				\
			pImpl = (theClass*)((CREATESTRUCT*)lParam)->lpCreateParams;					\
			pImpl->m_hWnd = hwnd;														\
			SetWindowLong(hwnd, GWL_USERDATA, (long)pImpl);							\
		}																				\
		else																			\
			pImpl = (theClass*) GetWindowLong(hwnd, GWL_USERDATA);					\
		if ( !pImpl )																	\
			return DefWindowProc( hwnd, uMsg, wParam, lParam );							\
		if ( (uMsg == WM_DESTROY) || (uMsg == WM_NCDESTROY) )							\
			pImpl->m_fDestroyed = TRUE;													\
		switch( uMsg )																	\
		{


#define ON_MESSAGE(message, fn) \
		case (message): return PROCESS_##message((wParam), (lParam), (pImpl->fn))


#define END_MESSAGE_MAP() \
		}																				\
		return DefWindowProc( hwnd, uMsg, wParam, lParam );								\
	}


#define CHAIN_END_MESSAGE_MAP(wndProc) \
		}																				\
		return wndProc( hwnd, uMsg, wParam, lParam );									\
	}


#define BEGIN_DIALOG_MESSAGE_MAP(theClass)	\
public:																					\
	virtual DLGPROC	GetDlgProc() { return DlgProc; }        							\
	static DLBPROC BOOL CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)	\
	{																					\
		theClass* pImpl = NULL;															\
		if(uMsg == WM_INITDIALOG)														\
		{																				\
			pImpl = (theClass*)lParam;													\
			pImpl->m_hWnd = hwnd;														\
			SetWindowLong(hwnd, GWL_USERDATA, (long) pImpl);							\
		}																				\
		else																			\
			pImpl = (theClass*) GetWindowLong(hwnd, GWL_USERDATA);					\
		if ( !pImpl )																	\
			return 0;																	\
        if ( uMsg == WM_ENTERSIZEMOVE )                                                 \
            pImpl->m_fMoving = TRUE;                                                    \
        if ( uMsg == WM_EXITSIZEMOVE  || uMsg == WM_INITDIALOG )                        \
            pImpl->m_fMoving = FALSE;                                                   \
		if ( uMsg == WM_NCDESTROY )														\
		{																				\
			pImpl->Unregister();														\
			if(!pImpl->m_fThreadLaunch && pImpl->m_nLaunchMethod == ModelessLaunch )	\
				pImpl->m_nLaunchMethod = NotActive;										\
		}																				\
		switch( uMsg )																	\
		{


#define ON_DLG_MESSAGE(message, fn) \
		case (message):																	\
			PROCESS_##message((wParam), (lParam), (pImpl->fn));							\
			return TRUE;


#define END_DIALOG_MESSAGE_MAP()	\
		}																				\
		return FALSE;																	\
	}


///////////////////////////////////////////////////////////////////////////////
// Class definition
///////////////////////////////////////////////////////////////////////////////

struct WNDPARAMS
{
	DWORD	dwExStyle;		// extended window style
    DWORD	dwStyle;		// window style
    int		x;				// horizontal position of window
    int		y;				// vertical position of window
    int		nWidth;			// window width
    int		nHeight;		// window height
	HMENU	hMenu;			// handle to menu, or child-window identifier
};


class CWindow2
{
public:
	// Constructor & destructor
	CWindow2();
	~CWindow2();

	// Initialization routines
	HRESULT Init( HINSTANCE hInstance, const TCHAR* szTitle = NULL, HWND hParent = NULL, RECT* pRect = NULL, int nShow = SW_SHOW );
	virtual void OverrideClassParams( WNDCLASSEX& WndClass );
	virtual void OverrideWndParams( WNDPARAMS& WndParams );

	// reference count
	ULONG AddRef();
	ULONG Release();

	// Typecast
	operator HWND()		{ return m_hWnd; }
	HWND GetHWND()		{ return m_hWnd; }
	
	// Utilities
	BOOL CenterWindow( HWND hParent = NULL );

	// Base message map
	virtual const TCHAR* GetClassName()	{ return (TCHAR*) _T("Zone Window Class"); }
	virtual WNDPROC		GetWndProc()	{ return (WNDPROC) DefWindowProc; }

protected:
	HWND		m_hWnd;
	HWND		m_hParentWnd;
	HINSTANCE	m_hInstance;
	BOOL		m_fDestroyed;
	ULONG		m_nRefCnt;
public:

	HWND GetSafeHwnd(void){return m_hWnd;}

};


// Turn off warning 4060 (switch statement contains no 'case' or 'default')
#pragma warning ( disable : 4060 )

class CDialog
{
public:
	// Constructor
	CDialog();
	~CDialog();

	// Initialization routines
	HRESULT Init( IZoneShell *pZoneShell, int nResourceId );
	HRESULT Init( HINSTANCE hInstance, int nResourceId );

	// Instantiate dialog
	int		Modal( HWND hParent );
	HRESULT Modeless( HWND hParent );
	HRESULT ModalViaThread( HWND hParent, UINT uStartMsg, UINT uEndMsg );
	HRESULT ModelessViaThread( HWND hParent, UINT uStartMsg, UINT uEndMsg );

	// Only call this one from a thread who's message loop handles TM_REGISTER_DIALOG messages.
	// Right now, this is only the lobby.exe main thread.
	HRESULT ModelessViaRegistration( HWND hParent );

	HWND GetSafeHwnd(void){return m_hWnd;}
	// Close dialog
	void Close( int nResult );
	
	// Is the dialog instantiated?
	BOOL IsAlive()		{ return (m_nLaunchMethod != NotActive); }

	// Retrieve EndDialog result
	int GetResult()		{ return m_nResult; }

	// Typecast
	operator HWND()		{ return m_hWnd; }

	// Utilities
	BOOL CenterWindow( HWND hParent = NULL );

	// Base message map
	BEGIN_DIALOG_MESSAGE_MAP( CDialog );
	END_DIALOG_MESSAGE_MAP();

protected:

	// Thread functions
	static DWORD WINAPI ModalThread( VOID* cookie );
	static DWORD WINAPI ModelessThread( VOID* cookie );

	// Registration callback (indirect)
	virtual void ReceiveRegistrationStatus(DWORD dwReason);

	void Unregister();

	HWND		m_hWnd;
	HINSTANCE	m_hInstance;
	int			m_nResourceId;
	int			m_nResult;
	UINT		m_uStartMsg;
	UINT		m_uEndMsg;
	HWND		m_hParent;
	BOOL		m_fRegistered;
    BOOL        m_fMoving;
	CComPtr<IZoneShell> m_pZoneShell;

	enum LaunchMethod
	{
		NotActive = 0,
		ModalLaunch,
		ModelessLaunch
	};

	LaunchMethod m_nLaunchMethod;
	BOOL         m_fThreadLaunch;

private:
	static void CALLBACK RegistrationCallback(HWND hWnd, DWORD dwReason);
};

// Turn warning 4060 back on
#pragma warning ( default : 4060 )


///////////////////////////////////////////////////////////////////////////////
//  Inline implementations
///////////////////////////////////////////////////////////////////////////////

inline ULONG CWindow2::AddRef()
{
	return ++m_nRefCnt;
}


inline ULONG CWindow2::Release()
{
	WNDFRX_ASSERT( m_nRefCnt > 0 );
	if ( --m_nRefCnt <= 0 )
	{
		delete this;
		return 0;
	}
	return m_nRefCnt;
}

}

using namespace FRX;

#endif //!__FRX_WND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\wndrectfrx.h ===
#ifndef WNDRECTFRX_H
#define WNDRECTFRX_H

#include "spritefrx.h"

enum RECTSTYLE { RECT_SOLID = 1,
				 RECT_DOT
				};

class CRectSprite : public CSprite
{
	protected:
		
		BYTE		 m_Color[16];		
		RECTSTYLE	 m_eRectStyle;
		RECT		 m_Rect;
		long		 m_height;
		long		 m_width;

	public:

		void    Draw();
		void	SetStyle(RECTSTYLE eRectStyle);
		void    SetRECT( RECT rc );
		void	SetColor(BYTE* color, int cb);
		void	SetColor(COLORREF crColor);
		void	SetColor(CPalette& palette, COLORREF crColor);

	public:

		CRectSprite(RECTSTYLE eRectStyle = RECT_SOLID);
		virtual ~CRectSprite();
};


#endif WNDRECTFRX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\znet\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\wndrectfrx.cpp ===
#include "WndRectFrx.h"

using namespace FRX;

CRectSprite::CRectSprite(RECTSTYLE eRectStyle)
{
	m_eRectStyle = eRectStyle;	
	ZeroMemory(m_Color, sizeof(m_Color));
}

CRectSprite::~CRectSprite()
{

}

void CRectSprite::SetRECT( RECT rc ) 
{ 
	m_Rect = rc; 
	m_height = m_Rect.bottom - m_Rect.top;
	m_width  = m_Rect.right  - m_Rect.left;
}

void CRectSprite::SetStyle(RECTSTYLE eRectStyle)
{	
	m_eRectStyle = eRectStyle;		
}

void CRectSprite::SetColor(BYTE* color, int cb)
{
	CopyMemory(m_Color, color, cb);
}

void CRectSprite::SetColor(COLORREF crColor)
{
	m_Color[0] = GetRValue(crColor);
    m_Color[1] = GetGValue(crColor);
    m_Color[2] = GetBValue(crColor);
}

void CRectSprite::SetColor(CPalette& palette, COLORREF crColor)
{
	*m_Color = GetNearestPaletteIndex( palette, crColor );	
}

void CRectSprite::Draw()
{

	BYTE* pDstBits = m_pWorld->GetBackbuffer()->GetBits();
	BYTE* pDst;

	long DstPitch  = m_pWorld->GetBackbuffer()->GetPitch();
	long DstHeight = m_pWorld->GetBackbuffer()->GetHeight();
    long DstDepth  = m_pWorld->GetBackbuffer()->GetDepth();

    long bpp = (DstDepth + 7) / 8;
    long bytewidth = m_width * bpp;

	RECT rcFinal;
	int i, j;

	pDst = pDstBits + (((DstHeight - m_Rect.bottom) * DstPitch ) + (m_Rect.left * bpp));
	
	if ( m_eRectStyle == RECT_DOT )
	{
		//Top Line
		for(i = 0; i <= m_width; i++ )
		{
			if ( i % 2 == 0 )
                for(j = 0; j < bpp; j++)
				    pDst[(i * bpp) + j] = m_Color[j];
		}

		//Go to the next line
		pDst += DstPitch;

		//Sides. Start at 2 as never want to draw the next line..
		//should cut loop in half and add by 2
		for ( i = 2; i < m_height - 1 ; i++ )
		{
			//Go to the next line
			pDst += DstPitch;

			if ( i % 2 == 0 )
			{
                for(j = 0; j < bpp; j++)
                {
				    pDst[j] = m_Color[j];
				    pDst[bytewidth + j] = m_Color[j];
                }
			}
		}
		//Go to the next line
		pDst += DstPitch;

		//Bottom Line
		for(i = 0; i <= m_width; i++ )
		{
			if ( i % 2 == 0 )
                for(j = 0; j < bpp; j++)
				    pDst[(i * bpp) + j] = m_Color[j];
		}
	}
	else
	{
		//Top Line
		for(i = 0; i <= m_width; i++ )
		{
            for(j = 0; j < bpp; j++)
		        pDst[(i * bpp) + j] = m_Color[j];
		}

		//sides
		for ( i = 1; i < m_height - 1; i++ )
		{
			//Go to the next line
			pDst += DstPitch;

            for(j = 0; j < bpp; j++)
            {
                pDst[j] = m_Color[j];
                pDst[bytewidth + j] = m_Color[j];
            }
		}

		//Go to the next line
		pDst += DstPitch;

		//Bottom Line
		for(i = 0; i <= m_width; i++ )
		{			
            for(j = 0; j < bpp; j++)
		        pDst[(i * bpp) + j] = m_Color[j];
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\winfrx\wndxfrx.h ===
#ifndef __FRX_WNDX_H__
#define __FRX_WNDX_H__

#include "tchar.h"

///////////////////////////////////////////////////////////////////////////////
// Message crackers without hwnd parameter
///////////////////////////////////////////////////////////////////////////////

/* void OnCaptureChanged( HWND hwndCapture ) */
#define PROCESS_WM_CAPTURECHANGED(wParam, lParam, fn ) \
	((fn)((HWND)(wParam)), 0L)

/* void OnCompacting(UINT compactRatio) */
#define PROCESS_WM_COMPACTING(wParam, lParam, fn) \
    ((fn)((UINT)(wParam)), 0L)

/* void OnWinIniChange(LPCTSTR lpszSectionName) */
#define PROCESS_WM_WININICHANGE(wParam, lParam, fn) \
    ((fn)((LPCTSTR)(lParam)), 0L)

/* void OnSysColorChange() */
#define PROCESS_WM_SYSCOLORCHANGE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* BOOL OnQueryNewPalette() */
#define PROCESS_WM_QUERYNEWPALETTE(wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(), 0L)

/* void OnPaletteChanged(HWND hwndPaletteChange) */
#define PROCESS_WM_PALETTECHANGED(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* void OnFontChange() */
#define PROCESS_WM_FONTCHANGE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnDevModeChange(LPCTSTR lpszDeviceName) */
#define PROCESS_WM_DEVMODECHANGE(wParam, lParam, fn) \
    ((fn)((LPCTSTR)(lParam)), 0L)

/* BOOL OnQueryEndSession() */
#define PROCESS_WM_QUERYENDSESSION(wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(), 0L)

/* void OnEndSession(BOOL fEnding) */
#define PROCESS_WM_ENDSESSION(wParam, lParam, fn) \
    ((fn)((BOOL)(wParam)), 0L)

/* void OnQuit(int exitCode) */
#define PROCESS_WM_QUIT(wParam, lParam, fn) \
    ((fn)((int)(wParam)), 0L)

/* BOOL OnCreate(LPCREATESTRUCT lpCreateStruct) */
#define PROCESS_WM_CREATE(wParam, lParam, fn) \
    ((fn)((LPCREATESTRUCT)(lParam)) ? 0L : (LRESULT)-1L)

/* BOOL OnNCCreate(LPCREATESTRUCT lpCreateStruct) */
#define PROCESS_WM_NCCREATE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((LPCREATESTRUCT)(lParam))

/* void OnDestroy() */
#define PROCESS_WM_DESTROY(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnNCDestroy() */
#define PROCESS_WM_NCDESTROY(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnShowWindow(BOOL fShow, UINT status) */
#define PROCESS_WM_SHOWWINDOW(wParam, lParam, fn) \
    ((fn)((), (BOOL)(wParam), (UINT)(lParam)), 0L)

/* void OnSetRedraw(BOOL fRedraw) */
#define PROCESS_WM_SETREDRAW(wParam, lParam, fn) \
    ((fn)((BOOL)(wParam)), 0L)

/* void OnEnable(BOOL fEnable) */
#define PROCESS_WM_ENABLE(wParam, lParam, fn) \
    ((fn)((BOOL)(wParam)), 0L)

/* void OnSetText(LPCTSTR lpszText) */
#define PROCESS_WM_SETTEXT(wParam, lParam, fn) \
    ((fn)((LPCTSTR)(lParam)), 0L)

/* INT OnGetText(int cchTextMax, LPTSTR lpszText) */
#define PROCESS_WM_GETTEXT(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((int)(wParam), (LPTSTR)(lParam))

/* INT OnGetTextLength() */
#define PROCESS_WM_GETTEXTLENGTH(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)()

/* BOOL OnWindowPosChanging(LPWINDOWPOS lpwpos) */
#define PROCESS_WM_WINDOWPOSCHANGING(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((LPWINDOWPOS)(lParam))

/* void OnWindowPosChanged(const LPWINDOWPOS lpwpos) */
#define PROCESS_WM_WINDOWPOSCHANGED(wParam, lParam, fn) \
    ((fn)((const LPWINDOWPOS)(lParam)), 0L)

/* void OnMove(int x, int y) */
#define PROCESS_WM_MOVE(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)

/* void OnSize(UINT state, int cx, int cy) */
#define PROCESS_WM_SIZE(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)

/* BOOL OnSizing(UINT side, LPRECT rect) */
#define PROCESS_WM_SIZING(wParam, lParam, fn) \
	(LRESULT)(DWORD)(BOOL)((fn)((UINT)(wParam), (LPRECT)lParam))

/* void OnClose() */
#define PROCESS_WM_CLOSE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* BOOL OnQueryOpen() */
#define PROCESS_WM_QUERYOPEN(wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(), 0L)

/* void OnGetMinMaxInfo(LPMINMAXINFO lpMinMaxInfo) */
#define PROCESS_WM_GETMINMAXINFO(wParam, lParam, fn) \
    ((fn)((LPMINMAXINFO)(lParam)), 0L)

/* void OnPaint() */
#define PROCESS_WM_PAINT(wParam, lParam, fn) \
    ((fn)(), 0L)

/* BOOL OnEraseBkgnd(HDC hdc) */
#define PROCESS_WM_ERASEBKGND(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((HDC)(wParam))

/* BOOL OnIconEraseBkgnd(HDC hdc) */
#define PROCESS_WM_ICONERASEBKGND(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((HDC)(wParam))

/* void OnNCPaint(HRGN hrgn) */
#define PROCESS_WM_NCPAINT(wParam, lParam, fn) \
    ((fn)((HRGN)(wParam)), 0L)

/* UINT OnNCCalcSize(BOOL fCalcValidRects, NCCALCSIZE_PARAMS * lpcsp) */
#define PROCESS_WM_NCCALCSIZE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((BOOL)(0), (NCCALCSIZE_PARAMS *)(lParam))

/* UINT OnNCHitTest(int x, int y) */
#define PROCESS_WM_NCHITTEST(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam))

/* HICON OnQueryDragIcon() */
#define PROCESS_WM_QUERYDRAGICON(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)()

/* void OnDropFiles(HDROP hdrop) */
#define PROCESS_WM_DROPFILES(wParam, lParam, fn) \
    ((fn)((HDROP)(wParam)), 0L)

/* void OnActivate(UINT state, HWND hwndActDeact, BOOL fMinimized) */
#define PROCESS_WM_ACTIVATE(wParam, lParam, fn) \
    ((fn)((UINT)LOWORD(wParam), (HWND)(lParam), (BOOL)HIWORD(wParam)), 0L)

/* void OnActivateApp(BOOL fActivate, DWORD dwThreadId) */
#define PROCESS_WM_ACTIVATEAPP(wParam, lParam, fn) \
    ((fn)((BOOL)(wParam), (DWORD)(lParam)), 0L)

/* BOOL OnNCActivate(BOOL fActive, HWND hwndActDeact, BOOL fMinimized) */
#define PROCESS_WM_NCACTIVATE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((BOOL)(wParam), 0L, 0L)

/* void OnSetFocus(HWND hwndOldFocus) */
#define PROCESS_WM_SETFOCUS(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* void OnKillFocus(HWND hwndNewFocus) */
#define PROCESS_WM_KILLFOCUS(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* void OnKey(UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define PROCESS_WM_KEYDOWN(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), TRUE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)

/* void OnKey(UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define PROCESS_WM_KEYUP(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), FALSE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)

/* void OnChar(TCHAR ch, int cRepeat) */
#define PROCESS_WM_CHAR(wParam, lParam, fn) \
    ((fn)((TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)

/* void OnDeadChar(TCHAR ch, int cRepeat) */
#define PROCESS_WM_DEADCHAR(wParam, lParam, fn) \
    ((fn)((TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)

/* void OnSysKey(UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define PROCESS_WM_SYSKEYDOWN(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), TRUE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)

/* void OnSysKey(UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define PROCESS_WM_SYSKEYUP(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), FALSE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)

/* void OnSysChar(TCHAR ch, int cRepeat) */
#define PROCESS_WM_SYSCHAR(wParam, lParam, fn) \
    ((fn)((TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)

/* void OnSysDeadChar(TCHAR ch, int cRepeat) */
#define PROCESS_WM_SYSDEADCHAR(wParam, lParam, fn) \
    ((fn)((TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)

/* void OnMouseMove(int x, int y, UINT keyFlags) */
#define PROCESS_WM_MOUSEMOVE(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnLButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_LBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnLButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_LBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnLButtonUp(int x, int y, UINT keyFlags) */
#define PROCESS_WM_LBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnRButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_RBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnRButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_RBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnRButtonUp(int x, int y, UINT flags) */
#define PROCESS_WM_RBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnMButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_MBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnMButtonDown(BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define PROCESS_WM_MBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnMButtonUp(int x, int y, UINT flags) */
#define PROCESS_WM_MBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCMouseMove(int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCMOUSEMOVE(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCLButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCLBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCLButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCLBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCLButtonUp(int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCLBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCRButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCRBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCRButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCRBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCRButtonUp(int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCRBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCMButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCMBUTTONDOWN(wParam, lParam, fn) \
    ((fn)(FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCMButtonDown(BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCMBUTTONDBLCLK(wParam, lParam, fn) \
    ((fn)(TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void OnNCMButtonUp(int x, int y, UINT codeHitTest) */
#define PROCESS_WM_NCMBUTTONUP(wParam, lParam, fn) \
    ((fn)((int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* int OnMouseActivate(HWND hwndTopLevel, UINT codeHitTest, UINT msg) */
#define PROCESS_WM_MOUSEACTIVATE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))

/* void OnCancelMode() */
#define PROCESS_WM_CANCELMODE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnTimer(UINT id) */
#define PROCESS_WM_TIMER(wParam, lParam, fn) \
    ((fn)((UINT)(wParam)), 0L)

/* void OnInitMenu(HMENU hMenu) */
#define PROCESS_WM_INITMENU(wParam, lParam, fn) \
    ((fn)((HMENU)(wParam)), 0L)

/* void OnInitMenuPopup(HMENU hMenu, UINT item, BOOL fSystemMenu) */
#define PROCESS_WM_INITMENUPOPUP(wParam, lParam, fn) \
    ((fn)((HMENU)(wParam), (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)

/* void OnMenuSelect(HMENU hmenu, int item, HMENU hmenuPopup, UINT flags) */
#define PROCESS_WM_MENUSELECT(wParam, lParam, fn)                  \
    ((fn)(((HMENU)(lParam),				\
		(int)(LOWORD(wParam)),          \
		(HIWORD(wParam) & MF_POPUP) ? GetSubMenu((HMENU)lParam, LOWORD(wParam)) : 0L, \
		(UINT)(((short)HIWORD(wParam) == -1) ? 0xFFFFFFFF : HIWORD(wParam))), 0L)

/* DWORD OnMenuChar(UINT ch, UINT flags, HMENU hmenu) */
#define PROCESS_WM_MENUCHAR(wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((UINT)(LOWORD(wParam)), (UINT)HIWORD(wParam), (HMENU)(lParam))

/* void OnCommand(int id, HWND hwndCtl, UINT codeNotify) */
#define PROCESS_WM_COMMAND(wParam, lParam, fn) \
    ((fn)((int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)

/* void OnHScroll(HWND hwndCtl, UINT code, int pos) */
#define PROCESS_WM_HSCROLL(wParam, lParam, fn) \
    ((fn)((HWND)(lParam), (UINT)(LOWORD(wParam)), (int)(short)HIWORD(wParam)), 0L)

/* void OnVScroll(HWND hwndCtl, UINT code, int pos) */
#define PROCESS_WM_VSCROLL(wParam, lParam, fn) \
    ((fn)((HWND)(lParam), (UINT)(LOWORD(wParam)),  (int)(short)HIWORD(wParam)), 0L)

/* void OnCut() */
#define PROCESS_WM_CUT(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnCopy() */
#define PROCESS_WM_COPY(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnPaste() */
#define PROCESS_WM_PASTE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnClear() */
#define PROCESS_WM_CLEAR(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnUndo() */
#define PROCESS_WM_UNDO(wParam, lParam, fn) \
    ((fn)(), 0L)

/* HANDLE OnRenderFormat(UINT fmt) */
#define PROCESS_WM_RENDERFORMAT(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((UINT)(wParam))

/* void OnRenderAllFormats() */
#define PROCESS_WM_RENDERALLFORMATS(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnDestroyClipboard() */
#define PROCESS_WM_DESTROYCLIPBOARD(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnDrawClipboard() */
#define PROCESS_WM_DRAWCLIPBOARD(wParam, lParam, fn) \
    ((fn)(), 0L)

/* void OnPaintClipboard(HWND hwndCBViewer, const LPPAINTSTRUCT lpPaintStruct) */
#define PROCESS_WM_PAINTCLIPBOARD(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (const LPPAINTSTRUCT)GlobalLock((HGLOBAL)(lParam))), GlobalUnlock((HGLOBAL)(lParam)), 0L)

/* void OnSizeClipboard(HWND hwndCBViewer, const LPRECT lprc) */
#define PROCESS_WM_SIZECLIPBOARD(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (const LPRECT)GlobalLock((HGLOBAL)(lParam))), GlobalUnlock((HGLOBAL)(lParam)), 0L)

/* void OnVScrollClipboard(HWND hwndCBViewer, UINT code, int pos) */
#define PROCESS_WM_VSCROLLCLIPBOARD(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (UINT)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)

/* void OnHScrollClipboard(HWND hwndCBViewer, UINT code, int pos) */
#define PROCESS_WM_HSCROLLCLIPBOARD(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (UINT)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)

/* void OnAskCBFormatName(int cchMax, LPTSTR rgchName) */
#define PROCESS_WM_ASKCBFORMATNAME(wParam, lParam, fn) \
    ((fn)((int)(wParam), (LPTSTR)(lParam)), 0L)

/* void OnChangeCBChain(HWND hwndRemove, HWND hwndNext) */
#define PROCESS_WM_CHANGECBCHAIN(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (HWND)(lParam)), 0L)

/* BOOL OnSetCursor(HWND hwndCursor, UINT codeHitTest, UINT msg) */
#define PROCESS_WM_SETCURSOR(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))

/* void OnSysCommand(UINT cmd, int x, int y) */
#define PROCESS_WM_SYSCOMMAND(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)

/* HWND MDICreate(const LPMDICREATESTRUCT lpmcs) */
#define PROCESS_WM_MDICREATE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((LPMDICREATESTRUCT)(lParam))

/* void MDIDestroy(HWND hwndDestroy) */
#define PROCESS_WM_MDIDESTROY(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* NOTE: Usable only by MDI client windows */
/* void MDIActivate(BOOL fActive, HWND hwndActivate, HWND hwndDeactivate) */
#define PROCESS_WM_MDIACTIVATE(wParam, lParam, fn) \
    ((fn)((BOOL)(lParam == (LPARAM)hwnd), (HWND)(lParam), (HWND)(wParam)), 0L)

/* void MDIRestore(HWND hwndRestore) */
#define PROCESS_WM_MDIRESTORE(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* HWND MDINext(HWND hwndCur, BOOL fPrev) */
#define PROCESS_WM_MDINEXT(wParam, lParam, fn) \
    (LRESULT)(HWND)(fn)((HWND)(wParam), (BOOL)lParam)

/* void MDIMaximize(HWND hwndMaximize) */
#define PROCESS_WM_MDIMAXIMIZE(wParam, lParam, fn) \
    ((fn)((HWND)(wParam)), 0L)

/* BOOL MDITile(UINT cmd) */
#define PROCESS_WM_MDITILE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((UINT)(wParam))

/* BOOL MDICascade(UINT cmd) */
#define PROCESS_WM_MDICASCADE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((UINT)(wParam))

/* void MDIIconArrange() */
#define PROCESS_WM_MDIICONARRANGE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* HWND MDIGetActive() */
#define PROCESS_WM_MDIGETACTIVE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)()

/* HMENU MDISetMenu(BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow) */
#define PROCESS_WM_MDISETMENU(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((BOOL)(wParam), (HMENU)(wParam), (HMENU)(lParam))

/* void OnChildActivate() */
#define PROCESS_WM_CHILDACTIVATE(wParam, lParam, fn) \
    ((fn)(), 0L)

/* BOOL OnInitDialog(HWND hwndFocus) */
#define PROCESS_WM_INITDIALOG(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((HWND)(wParam))

/* HWND OnNextDlgCtl(HWND hwndSetFocus, BOOL fNext) */
#define PROCESS_WM_NEXTDLGCTL(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((HWND)(wParam), (BOOL)(lParam))

/* void OnParentNotify(UINT msg, HWND hwndChild, int idChild) */
#define PROCESS_WM_PARENTNOTIFY(wParam, lParam, fn) \
    ((fn)((UINT)LOWORD(wParam), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)

/* void OnEnterIdle(UINT source, HWND hwndSource) */
#define PROCESS_WM_ENTERIDLE(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), (HWND)(lParam)), 0L)

/* UINT OnGetDlgCode(LPMSG lpmsg) */
#define PROCESS_WM_GETDLGCODE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((LPMSG)(lParam))

/* HBRUSH OnCtlColor(HDC hdc, HWND hwndChild, int type) */
#define PROCESS_WM_CTLCOLORMSGBOX(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_MSGBOX)

#define PROCESS_WM_CTLCOLOREDIT(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_EDIT)

#define PROCESS_WM_CTLCOLORLISTBOX(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_LISTBOX)

#define PROCESS_WM_CTLCOLORBTN(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_BTN)

#define PROCESS_WM_CTLCOLORDLG(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_DLG)

#define PROCESS_WM_CTLCOLORSCROLLBAR(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_SCROLLBAR)

#define PROCESS_WM_CTLCOLORSTATIC(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((HDC)(wParam), (HWND)(lParam), CTLCOLOR_STATIC)

/* void OnSetFont(HFONT hfont, BOOL fRedraw) */
#define PROCESS_WM_SETFONT(wParam, lParam, fn) \
    ((fn)((HFONT)(wParam), (BOOL)(lParam)), 0L)

/* HFONT OnGetFont() */
#define PROCESS_WM_GETFONT(wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)()

/* void OnDrawItem(const DRAWITEMSTRUCT * lpDrawItem) */
#define PROCESS_WM_DRAWITEM(wParam, lParam, fn) \
    ((fn)((const DRAWITEMSTRUCT *)(lParam)), 0L)

/* void OnMeasureItem(MEASUREITEMSTRUCT * lpMeasureItem) */
#define PROCESS_WM_MEASUREITEM(wParam, lParam, fn) \
    ((fn)((MEASUREITEMSTRUCT *)(lParam)), 0L)

/* void OnDeleteItem(const DELETEITEMSTRUCT * lpDeleteItem) */
#define PROCESS_WM_DELETEITEM(wParam, lParam, fn) \
    ((fn)((const DELETEITEMSTRUCT *)(lParam)), 0L)

/* int OnCompareItem(const COMPAREITEMSTRUCT * lpCompareItem) */
#define PROCESS_WM_COMPAREITEM(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((const COMPAREITEMSTRUCT *)(lParam))

/* int OnVkeyToItem(UINT vk, HWND hwndListbox, int iCaret) */
#define PROCESS_WM_VKEYTOITEM(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((UINT)LOWORD(wParam), (HWND)(lParam), (int)(short)HIWORD(wParam))

/* int OnCharToItem(UINT ch, HWND hwndListbox, int iCaret) */
#define PROCESS_WM_CHARTOITEM(wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((UINT)LOWORD(wParam), (HWND)(lParam), (int)(short)HIWORD(wParam))

/* void OnDisplayChange(UINT bitsPerPixel, UINT cxScreen, UINT cyScreen) */
#define PROCESS_WM_DISPLAYCHANGE(wParam, lParam, fn) \
    ((fn)((UINT)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(wParam)), 0L)

/* BOOL OnDeviceChange(UINT uEvent, DWORD dwEventData) */
#define PROCESS_WM_DEVICECHANGE(wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((UINT)(wParam), (DWORD)(wParam))

/* void OnContextMenu(HWND hwndContext, UINT xPos, UINT yPos) */
#define PROCESS_WM_CONTEXTMENU(wParam, lParam, fn) \
    ((fn)((HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)

#endif //!__FRX_WNDX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zeeverm\main.cpp ===
#include <windows.h>
#include <basicatl.h>
#include <zeeverm.h>


static DWORD g_tlsInstance = 0xffffffff;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:            

            g_tlsInstance = TlsAlloc();

            if(g_tlsInstance == 0xFFFFFFFF)
                 return FALSE;
        case DLL_THREAD_ATTACH:
            TlsSetValue(g_tlsInstance, hInstance);
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            TlsFree(g_tlsInstance);
            break;
    }

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Discover information about the product version.
/////////////////////////////////////////////////////////////////////////////

STDAPI GetVersionPack(char *szSetupToken, ZeeVerPack *pVersion)
{
    USES_CONVERSION;

    lstrcpynA(pVersion->szSetupToken, szSetupToken, NUMELEMENTS(pVersion->szSetupToken));

/* zverp.h based
    lstrcpynA(pVersion->szVersionStr, PRODUCT_VERSION_STR, NUMELEMENTS(pVersion->szVersionStr));
    lstrcpynA(pVersion->szVersionName, VER_PRODUCTBETA_STR, NUMELEMENTS(pVersion->szVersionName));
    pVersion->dwVersion = VER_DWORD;
*/

    // resource based
	char szFile[_MAX_PATH];
    DWORD dwZero = 0;
    UINT cbBufLen;
	char *pData;

	HMODULE hmodule = TlsGetValue(g_tlsInstance);
	GetModuleFileNameA(hmodule, szFile, NUMELEMENTS(szFile));
	cbBufLen = GetFileVersionInfoSizeA(szFile, &dwZero);
	pData = (char*) _alloca(cbBufLen);
	GetFileVersionInfoA(szFile, 0, cbBufLen, pData);

    VS_FIXEDFILEINFO *pvs;
	if(!VerQueryValueA(pData, "\\", (void **) &pvs, &cbBufLen) || !pvs || !cbBufLen)
        return E_FAIL;

    DWORD parts[4];
    parts[0] = HIWORD(pvs->dwFileVersionMS) & 0x00ff;
    parts[1] = LOWORD(pvs->dwFileVersionMS) & 0x003f;
    parts[2] = HIWORD(pvs->dwFileVersionLS) & 0x3fff;
    parts[3] = LOWORD(pvs->dwFileVersionLS) & 0x000f;

    pVersion->dwVersion = (parts[0] << 24) | (parts[1] << 18) | (parts[2] << 4) | parts[3];
    wsprintfA(pVersion->szVersionStr, "%d.%02d.%d.%d", parts[0], parts[1], parts[2], parts[3]);

    // get the list of languages
    struct
    {
        WORD wLanguage;
        WORD wCodePage;
    } *pTranslate;

    if(!VerQueryValueA(pData, "\\VarFileInfo\\Translation", (void **) &pTranslate, &cbBufLen) || !pTranslate || !cbBufLen)
        return E_FAIL;

    // Read the build description for the first language and code page.
    char szSubBlock[50];
    char *szLang;
    wsprintfA(szSubBlock, "\\StringFileInfo\\%04x%04x\\SpecialBuild", pTranslate->wLanguage, pTranslate->wCodePage);
    if(!VerQueryValueA(pData, szSubBlock, (void **) &szLang, &cbBufLen) || !szLang || !cbBufLen)
        return E_FAIL;

    lstrcpynA(pVersion->szVersionName, szLang, NUMELEMENTS(pVersion->szVersionName));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Start an update, like launch ZSetup or something.  App should exit immediately after calling this.
/////////////////////////////////////////////////////////////////////////////

STDAPI StartUpdate(char *szSetupToken, DWORD dwTargetVersion, char *szLocation)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\znet\cnetwork.cpp ===
#include "stdafx.h"
#include "ztypes.h"
#include "network.h"
#include "ZNet.h"
#include "cnetwork.h"


CNetwork::CNetwork() :
	m_pNet( NULL )
{
}


CNetwork::~CNetwork()
{
    ShutDown();
}


STDMETHODIMP CNetwork::Init( BOOL bEnablePools, BOOL EnableIOCompletionPorts )
{
	// allocate network object
	m_pNet = new ZNetwork;
	if ( !m_pNet )
		return E_OUTOFMEMORY;

	// initialize library
	if ( m_pNet->InitLibraryClientOnly( bEnablePools ) )
	{
		delete m_pNet;
		m_pNet = NULL;
		return E_FAIL;
	}

	// initialize instance
	if ( m_pNet->InitInst( EnableIOCompletionPorts ) )
	{
		m_pNet->CleanUpLibrary();
		delete m_pNet;
		m_pNet = NULL;
		return E_FAIL;
	}

	return S_OK;
}


STDMETHODIMP CNetwork::CloseConnection(IConnection* connection)
{
	ZNetCon* con = (ZNetCon*) connection->GetZCon();
	m_pNet->CloseConnection( con );
	return S_OK;
}


STDMETHODIMP CNetwork::DeleteConnection(IConnection* connection)
{
	ZNetCon* con = (ZNetCon*) connection->GetZCon();
	m_pNet->DeleteConnection( con );
	connection->SetMessageFunc( NULL );
	connection->SetUserData( NULL );
	connection->SetZCon( NULL );
	connection->Release();
	return S_OK;
}


STDMETHODIMP CNetwork::Exit()
{
	m_pNet->Exit();
	return S_OK;
}


STDMETHODIMP CNetwork::ShutDown()
{
	if(m_pNet)
	{
		m_pNet->CleanUpInst();
		m_pNet->CleanUpLibrary();
		delete m_pNet;
		m_pNet = NULL;
	}

    return S_OK;
}


STDMETHODIMP_(void) CNetwork::SetOptions( ZNETWORK_OPTIONS* opt )
{
	m_pNet->SetOptions( opt );
}


STDMETHODIMP_(void) CNetwork::GetOptions( ZNETWORK_OPTIONS* opt )
{
	m_pNet->GetOptions( opt );
}


void __stdcall CNetwork::InternalMessageFunc( ZSConnection connection, DWORD event,void* userData )
{
	CConnection* pCon = (CConnection*) userData;
	if ( pCon && pCon->m_pfMessageFunc )
		pCon->m_pfMessageFunc( pCon, event, pCon->m_pUserData );
}


STDMETHODIMP_(IConnection*) CNetwork::CreateClient(
		char* hostname,
		long *ports,
		IConnectionMessageFunc func,
		void* serverClass,
		void* userData )
{
	// create CConection to wrap ZNetCon
	CComObject<CConnection>* p = NULL;
	HRESULT hr = CComObject<CConnection>::CreateInstance( &p );
	if ( FAILED(hr) )
		return NULL;
	p->AddRef();

	// save mappings
	p->m_pfMessageFunc = func;
	p->m_pUserData = userData;
	p->m_pCon = m_pNet->CreateClient( hostname, ports, InternalMessageFunc, serverClass, p );
	if ( !p->m_pCon )
	{
		p->Release();
		return NULL;
	}

	return p;
}


STDMETHODIMP_(IConnection*) CNetwork::CreateSecureClient(
		char* hostname,
		long *ports,
		IConnectionMessageFunc func,
		void* conClass,
		void* userData,
		char* User,
		char* Password,
		char* Domain,
		int Flags)
{
	// create CConection to wrap ZNetCon
	CComObject<CConnection>* p = NULL;
	HRESULT hr = CComObject<CConnection>::CreateInstance( &p );
	if ( FAILED(hr) )
		return NULL;
	p->AddRef();

	// establish connection
	p->m_pfMessageFunc = func;
	p->m_pUserData = userData;
	p->m_pCon = m_pNet->CreateSecureClient(	hostname, ports, InternalMessageFunc, conClass, p, User, Password, Domain, Flags );
	if ( !p->m_pCon )
	{
		p->Release();
		return NULL;
	}
	
	return p;
}


STDMETHODIMP_(void) CNetwork::Wait( INetworkWaitFunc func, void* data, DWORD dwWakeMask )
{
	m_pNet->Wait( func, data, dwWakeMask );
}


STDMETHODIMP_(BOOL) CNetwork::QueueAPCResult( ZSConnectionAPCFunc func, void* data )
{
	return m_pNet->QueueAPCResult( func, data );
}


STDMETHODIMP_(HWND) CNetwork::FindLoginDialog()
{
	return ::FindLoginDialog();
}


///////////////////////////////////////////////////////////////////////////////
// CConnection implementation
///////////////////////////////////////////////////////////////////////////////

CConnection::CConnection()
{
	m_pCon = NULL;
	m_pUserData = NULL;
	m_pfMessageFunc = NULL;
}


CConnection::~CConnection()
{
	m_pUserData = NULL;
	m_pCon = NULL;
	m_pfMessageFunc = NULL;
}

STDMETHODIMP_(DWORD) CConnection::Send(DWORD messageType, void* buffer, long len, DWORD dwSignature, DWORD dwChannel /* = 0 */)
{
	return m_pCon->Send(messageType, buffer, len, dwSignature, dwChannel);
}

STDMETHODIMP_(void*) CConnection::Receive(DWORD *messageType, long* len, DWORD *pdwSignature, DWORD *pdwChannel /* = NULL */)
{
	return m_pCon->Receive(messageType, len, pdwSignature, pdwChannel);
}

STDMETHODIMP_(BOOL) CConnection::IsDisabled()
{
	return m_pCon->IsDisabled();
}

STDMETHODIMP_(BOOL) CConnection::IsServer()
{
	return m_pCon->IsServer();
}

STDMETHODIMP_(BOOL) CConnection::IsClosing()
{
	return m_pCon->IsClosing();
}

STDMETHODIMP_(DWORD) CConnection::GetLocalAddress()
{
    return m_pCon->GetLocalAddress();
}

STDMETHODIMP_(char*) CConnection::GetLocalName()
{
    return m_pCon->GetLocalName();
}

STDMETHODIMP_(DWORD) CConnection::GetRemoteAddress()
{
    return m_pCon->GetRemoteAddress();
}

STDMETHODIMP_(char*) CConnection::GetRemoteName()
{
    return m_pCon->GetRemoteName();
}

STDMETHODIMP_(GUID*) CConnection::GetUserGUID()
{
	return m_pCon->GetUserGUID();
}

STDMETHODIMP_(BOOL) CConnection::GetUserName(char* name)
{
	return m_pCon->GetUserName( name );
}

STDMETHODIMP_(BOOL) CConnection::SetUserName(char* name)
{
	return m_pCon->SetUserName( name );
}

STDMETHODIMP_(DWORD) CConnection::GetUserId()
{
	return m_pCon->GetUserId();
}

STDMETHODIMP_(BOOL) CConnection::GetContextString(char* buf, DWORD len)
{
	return m_pCon->GetContextString( buf, len );
}

STDMETHODIMP_(BOOL) CConnection::HasToken(char* token)
{
	return m_pCon->HasToken( token );
}

STDMETHODIMP_(int) CConnection::GetAccessError()
{
	return m_pCon->GetAccessError();
}

STDMETHODIMP_(void) CConnection::SetUserData( void* UserData )
{
	m_pUserData = UserData;
}

STDMETHODIMP_(void*) CConnection::GetUserData()
{
	return m_pUserData;
}

STDMETHODIMP_(void) CConnection::SetClass( void* conClass )
{
	m_pCon->SetClass( conClass );
}

STDMETHODIMP_(void*) CConnection::GetClass()
{
	return m_pCon->GetClass();
}

STDMETHODIMP_(DWORD) CConnection::GetLatency()
{
	return m_pCon->GetLatency();
}

STDMETHODIMP_(DWORD) CConnection::GetAcceptTick()
{
	return m_pCon->GetAcceptTick();
}

STDMETHODIMP_(void) CConnection::SetTimeout(DWORD timeout)
{
	m_pCon->SetTimeout( timeout );
}

STDMETHODIMP_(void) CConnection::ClearTimeout()
{
	m_pCon->ClearTimeout();
}

STDMETHODIMP_(DWORD) CConnection::GetTimeoutRemaining()
{
	return m_pCon->GetTimeoutRemaining();
}


///////////////////////////////////////////////////////////////////////////////
// Internal hack
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(void*) CConnection::GetZCon()
{
	return m_pCon;
}

STDMETHODIMP_(void) CConnection::SetZCon(void* con)
{
	m_pCon = (ZNetCon*) con;
}

STDMETHODIMP_(void) CConnection::SetMessageFunc(void* func)
{
	m_pfMessageFunc = (IConnectionMessageFunc) func;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\znet\main.cpp ===
#include "stdafx.h"
#include "ztypes.h"
#include <initguid.h>
#include "network.h"
#include "ZNet.h"
#include "CNetwork.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Network, CNetwork)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        // DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\znet\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#define _STPUID_NETWORK_HACK

#include <Windows.h>
#include "zonedebug.h"

// Turn off unused options
#define _ATL_NO_CONNECTION_POINTS
#define _ATL_STATIC_REGISTRY

// Eliminate CRT dependencies
#define _ATL_MIN_CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(X)	ASSERT(X)

	
//!! WIN95GOLD
#define VarUI4FromStr	ulVal = 0;	// used in statreg.h

// Define ATL global variables
#include <atlbase.h>

//!! WIN95GOLD
#define OleCreateFontIndirect		// used in atlhost
#define OleCreatePropertyFrame		// used in atlctl.h


extern CComModule _Module;

#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\debug.cpp ===
#include "zui.h"
#ifdef _DEBUG
#undef CreatePen
#undef CreateSolidBrush

HPEN MyCreatePen(int fnPenStyle, int nWidth, COLORREF crColor)
{
	HPEN hPen = CreatePen(fnPenStyle, nWidth, crColor);
	if (!hPen) {
		_asm {int 3};
	}

	return hPen;
}

HBRUSH MyCreateSolidBrush(COLORREF crColor)
{
	HBRUSH hBr = CreateSolidBrush(crColor);
	if (!hBr) {
		_asm {int 3};
	}

	return hBr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\znet\cnetwork.h ===
#include "stdafx.h"


class ATL_NO_VTABLE CNetwork:
	public INetwork,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNetwork,&CLSID_Network>
{
public:
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CNetwork)
		COM_INTERFACE_ENTRY(INetwork)
	END_COM_MAP()

public:
	CNetwork();
	~CNetwork();

public:
	STDMETHOD(Init)( BOOL bEnablePools = TRUE, BOOL EnableIOCompletionPorts = TRUE );

	STDMETHOD(CloseConnection)(IConnection* connection);

	STDMETHOD(DeleteConnection)(IConnection* connection);

	STDMETHOD(Exit)();

    STDMETHOD(ShutDown)();

	STDMETHOD_(void,SetOptions)( ZNETWORK_OPTIONS* opt );

    STDMETHOD_(void,GetOptions)( ZNETWORK_OPTIONS* opt );

	
	STDMETHOD_(IConnection*,CreateClient)(
							char* hostname,
							long *ports,
							IConnectionMessageFunc func,
							void* serverClass,
							void* userData );

	STDMETHOD_(IConnection*,CreateSecureClient)(
							char* hostname,
							long *ports,
							IConnectionMessageFunc func,
							void* conClass,
							void* userData,
							char* User,
							char* Password,
							char* Domain,
							int Flags = ZNET_PROMPT_IF_NEEDED);

	STDMETHOD_(void,Wait)(
							INetworkWaitFunc func = NULL,
							void* data = NULL,
							DWORD dwWakeMask = QS_ALLINPUT );

	STDMETHOD_(BOOL,QueueAPCResult)( ZSConnectionAPCFunc func, void* data );

	STDMETHOD_(HWND,FindLoginDialog)();

private:
	static void __stdcall InternalMessageFunc( ZSConnection connection, DWORD event,void* userData ); 

private:
	ZNetwork*				m_pNet;
};


class ATL_NO_VTABLE CConnection :
	public IConnection,
	public CComObjectRootEx<CComMultiThreadModel>
{
public:
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CConnection)
		COM_INTERFACE_ENTRY(IConnection)
	END_COM_MAP()

public:
	STDMETHOD_(DWORD,Send)(DWORD messageType, void* buffer, long len, DWORD dwSignature, DWORD dwChannel = 0);

	STDMETHOD_(void*,Receive)(DWORD *messageType, long* len, DWORD *pdwSignature, DWORD *pdwChannel = NULL);

    STDMETHOD_(BOOL,IsDisabled)();

	STDMETHOD_(BOOL,IsServer)(); 

	STDMETHOD_(BOOL,IsClosing)();

    STDMETHOD_(DWORD,GetLocalAddress)();

    STDMETHOD_(char*,GetLocalName)();

    STDMETHOD_(DWORD,GetRemoteAddress)();

    STDMETHOD_(char*,GetRemoteName)();

    STDMETHOD_(GUID*,GetUserGUID)();

    STDMETHOD_(BOOL,GetUserName)(char* name);

    STDMETHOD_(BOOL,SetUserName)(char* name);

    STDMETHOD_(DWORD,GetUserId)();

    STDMETHOD_(BOOL,GetContextString)(char* buf, DWORD len);

    STDMETHOD_(BOOL,HasToken)(char* token);

    STDMETHOD_(int,GetAccessError)();

    STDMETHOD_(void,SetUserData)( void* UserData );

    STDMETHOD_(void*,GetUserData)();

    STDMETHOD_(void,SetClass)( void* conClass );

	STDMETHOD_(void*,GetClass)();

    STDMETHOD_(DWORD,GetLatency)();

    STDMETHOD_(DWORD,GetAcceptTick)();

	STDMETHOD_(void,SetTimeout)(DWORD timeout);

    STDMETHOD_(void,ClearTimeout)();

    STDMETHOD_(DWORD,GetTimeoutRemaining)();

	// hack
	STDMETHOD_(void,SetZCon)(void* con);
	STDMETHOD_(void*,GetZCon)();
	STDMETHOD_(void,SetMessageFunc)(void* func);

public:
	CConnection();
	~CConnection();

	void*					m_pUserData;
	IConnectionMessageFunc	m_pfMessageFunc;
	ZNetCon*				m_pCon;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\gamecontrol.cpp ===
//#include "stdafx.h"
#include "ClientIDL.h"
#include "zonecli.h"
#include "GameControl.h"
#include "OpName.h"
#include "commonmsg.h"
#include "zcliroom.h"
#include "zcliroomimp.h"
#include "KeyName.h"
#include "MillEngine.h"
#include "zoneutil.h"

#define gTables (pGlobals->m_gTables)


inline DECLARE_MAYBE_FUNCTION_1(BOOL, FlashWindowEx, PFLASHWINFO);


struct GamePromptContext
{
    DWORD dwInstanceId;
    DWORD dwCookie;
};


LRESULT CGameControl::OnNcCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetWindowLong(GWL_EXSTYLE, GetWindowLong(GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL);
    return 1;
}


LRESULT CGameControl::OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(m_pIGG)
        return OnTransmit(uMsg, wParam, lParam, bHandled);

    if((HWND) wParam != m_hWnd)            // Responding to own message.
    {
        HDC hDC = GetDC();
        HPALETTE hOldPal = SelectPalette(hDC, ZoneShell()->GetPalette(), TRUE);
        RealizePalette(hDC);

        InvalidateRect(NULL, TRUE);

        if(hOldPal)
            SelectPalette(hDC, hOldPal, TRUE);

        ReleaseDC(hDC);
    }

    return TRUE;
}



LRESULT CGameControl::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HRESULT hr;

	hr=InitGameDLL();
	if ( FAILED(hr) )
		return 1;

	return 0;
}


STDMETHODIMP CGameControl::Init( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey )
{
	// first call the base class
	HRESULT hr = IZoneShellClientImpl<CGameControl>::Init( pIZoneShell, dwGroupId, szKey );
	if ( FAILED(hr) )
		return hr;

    if(!m_bitmap.LoadBitmap(IDB_BACKGROUND, ResourceManager()))
        return E_FAIL;

	return S_OK;
}


STDMETHODIMP CGameControl::Close()
{
    EndGame(IMillUtils::M_CounterGamesQuit);
	RoomExit();
    UserMainStop();

	// release ZoneShell objects
    return IZoneShellClientImpl<CGameControl>::Close();
}


bool CGameControl::EndGame(long eCounter)
{
	if(!m_pIGG)
        return false;

    DeleteGameOnTable(0);
    m_pIGG.Release();
    ZoneShell()->ClearAlerts(m_hWnd);

    if(m_fGameInProgress)
    {
        CComPtr<IMillUtils> pIMU;
        ZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
        if(pIMU)
        {
            pIMU->IncrementCounter(eCounter);

            if(eCounter == IMillUtils::M_CounterGamesQuit || eCounter == IMillUtils::M_CounterGamesFNO)
                pIMU->IncrementCounter(IMillUtils::M_CounterGamesAbandonedRunning);
        }

        m_fGameInProgress = false;
    }

    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_GAME_TERMINATED, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return true;
}


STDMETHODIMP CGameControl::InitGameDLL()
{
	HRESULT hr = S_OK;
	DWORD cb = zGameNameLen;
    GameInfoType gameInfo;

	CComPtr<IDataStore> pIDS;
	LobbyDataStore()->GetDataStore( ZONE_NOGROUP, ZONE_NOUSER, &pIDS );
	
	//Need to get config information
	//game name,  
	cb = zGameNameLen;
	hr = DataStoreConfig()->GetString( GetDataStoreKey() + key_GameDll, m_szGameDll, &cb);
	if ( FAILED(hr) )
	{
		return hr;
	}

	const TCHAR* arKeys[] = { key_WindowManager, key_GameSize };
    POINT ptSize;
    hr = DataStoreUI()->GetPOINT(arKeys, 2, &ptSize);
	if(FAILED(hr))
		return hr;

	cb = zGameNameLen;
	pIDS->GetString( key_StartData, m_szCommandLine,&cb );

	//cb = zGameNameLen;
	//pIDS->GetString( key_Language, gszLanguage ,&cb);

	cb = zGameNameLen;
	pIDS->GetString( key_FriendlyName, m_szGameName,&cb );

	//cb = zGameNameLen;
	//pIDS->GetString( key_FamilyName, gszFamilyName );

	cb = zGameNameLen;
	pIDS->GetString( key_InternalName, m_szGameID,&cb );

	//cb = zGameNameLen;
	//pIDS->SetString( key_Server, gszServerName ,&cb);
	
	//pIDS->SetLong( key_Port, (long) gdwServerPort );
	//pIDS->SetLong( key_Store, lStore );


    gameInfo.gameID = m_szGameID;
	gameInfo.game = m_szGameName;
	gameInfo.gameName = m_szGameName;
	gameInfo.gameDll = m_szGameDll;

    m_szGameDataFile[0] = '\0';
	gameInfo.gameDataFile = m_szGameDataFile;

	m_szServerName[0]='\0';
	gameInfo.gameServerName = m_szServerName;
	gameInfo.gameServerPort = 0;
	gameInfo.screenWidth = ptSize.x;
	gameInfo.screenHeight = ptSize.y;
	gameInfo.chatOnly = FALSE;

		
	if (UserMainInit(_Module.GetModuleInstance(), m_hWnd, this, &gameInfo))
	{
		m_bClientRunning = TRUE;
	    HandleAccessedMessage();
	}
	else
	{
		UserMainStop();
		m_bClientRunning = FALSE;
        hr = E_FAIL;

        // UserMainInit may have already popped up a message, so this one may not be seen
        ZoneShell()->AlertMessage(NULL, MAKEINTRESOURCE(IDS_INTERR_CANNOT_START), NULL, NULL, NULL, AlertButtonQuit, 2, EVENT_EXIT_APP);
	}

	return hr;
}


HRESULT CGameControl::OnDraw(ATL_DRAWINFO& di)
{
    if(m_pIGG)
        return S_OK;

	CRect& rcBounds = *(CRect*)di.prcBounds;
	CDrawDC dc = di.hdcDraw;

	if(m_bitmap)
	{
		CRect rcBitmap( CPoint(0,0), m_bitmap.GetSize());
		// draw the bitmap
		m_bitmap.Draw(dc, NULL, &rcBitmap);
		// erase the other crap
		dc.ExcludeClipRect(rcBitmap);
	}
	dc.PatBlt( rcBounds.left, rcBounds.top, rcBounds.Width(), rcBounds.Height(), BLACKNESS);
	return S_OK; 
}


LRESULT CGameControl::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = true;
    return true;
}


void CGameControl::OnChatSend(DWORD eventId, DWORD groupId, DWORD userId, void* pData, DWORD dataLen)
{
    TCHAR *szChat = (TCHAR *) pData;

    if(m_pIGG)
        m_pIGG->SendChat(szChat, dataLen / sizeof(TCHAR));
}


void CGameControl::OnGameLocalReady(DWORD eventId, DWORD groupId, DWORD userId)
{
    if(!m_bClientRunning || !m_bUpsellUp || !m_pIGG)
        return;

    m_pIGG->GameOverReady();
}


void CGameControl::OnGameLaunching(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
{
    if(!m_bClientRunning)
        return;

    ASSERT(!m_fGameInProgress);
    if(m_pIGG)  // this would be pretty bad - how could this happen
	{
	    DeleteGameOnTable(0);
	    m_pIGG.Release();
        ZoneShell()->ClearAlerts(m_hWnd);
    }

    m_dwInstanceId++;
    m_pIGG = StartNewGame(0, (ZSGame) dwData1, LobbyDataStore()->GetUserId(NULL), (int16) dwData2, zGamePlayer);
    if(!m_pIGG)
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_GAME_TERMINATED, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
// TODO(JWS,"something else should happen too")
    else
        m_fGameInProgress = true;
}


void CGameControl::OnMatchmake(DWORD eventId, DWORD groupId, DWORD userId)
{
    EndGame(IMillUtils::M_CounterGamesFNO);
    for(; m_nUpsellBlocks; m_nUpsellBlocks--)
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_UPSELL_UNBLOCK, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}


void CGameControl::OnDisconnect(DWORD eventId, DWORD groupId, DWORD userId)
{
    EndGame(IMillUtils::M_CounterGamesDisconnected);
}


void CGameControl::OnUpsellUp(DWORD eventId, DWORD groupId, DWORD userId)
{
    EnableWindow(FALSE);
}


void CGameControl::OnUpsellDown(DWORD eventId, DWORD groupId, DWORD userId)
{
    EnableWindow(TRUE);
}


void CGameControl::OnShowScore(DWORD eventId, DWORD groupId, DWORD userId)
{
    if(!m_pIGG)
        return;

    m_pIGG->ShowScore();
}


void CGameControl::OnFrameActivate(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
{
    FLASHWINFO oFWI;
    bool fActive = false;

    if(dwData1)
    {
        if(dwData2)
            fActive = true;
    }
    else
    {
        if(LOWORD(dwData2) == WA_ACTIVE || LOWORD(dwData2) == WA_CLICKACTIVE)
            fActive = true;
    }

    if(fActive)
    {
        oFWI.cbSize = sizeof(oFWI);
        oFWI.hwnd = ZoneShell()->GetFrameWindow();
        oFWI.dwFlags = FLASHW_STOP;
        oFWI.uCount = 0;
        oFWI.dwTimeout = 0;
        CALL_MAYBE(FlashWindowEx)(&oFWI);
    }
}


void CGameControl::OnPrompt(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
{
    GamePromptContext *pCtxt = (GamePromptContext *) dwData2;

    if(m_pIGG && pCtxt->dwInstanceId == m_dwInstanceId)
        m_pIGG->GamePromptResult(dwData1, pCtxt->dwCookie);

    delete pCtxt;
}


void CGameControl::OnFatalPrompt(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2)
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, dwData1 == IDNO ? EVENT_EXIT_APP : EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
}


void CGameControl::ProcessMessage( EventNetwork* pEvent, DWORD dwLength )
{
    if(!m_pIGG)
        return;

	DWORD dwType = pEvent->dwType;
	DWORD dwLen = pEvent->dwLength;
	BYTE* pBuffer = pEvent->pData;

	switch ( dwType )
	{
	    case zRoomMsgGameMessage: 
	        HandleGameMessage((ZRoomMsgGameMessage*) pBuffer);
	        break;
    }
}


STDMETHODIMP CGameControl::SendGameMessage(int16 table, uint32 messageType, void* message, int32 messageLen)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZRoomMsgGameMessage*		msg;
	int32						msgLen;
	
	
	msgLen = sizeof(ZRoomMsgGameMessage) + messageLen;
    msg = (ZRoomMsgGameMessage *) ZMalloc( msgLen );
	if(!msg)
        return E_OUTOFMEMORY;

    if(table == zInvalTable)
		msg->gameID = NULL;   // not table-specific game messages use NULL gameID
	else
		msg->gameID = (uint32) gTables[table].gameID;
	msg->messageType = messageType;
	msg->messageLen = (uint16) messageLen;
	CopyMemory((char*) msg + sizeof(ZRoomMsgGameMessage), message, messageLen);

	EventQueue()->PostEventWithBuffer(
	    PRIORITY_NORMAL, EVENT_GAME_SEND_MESSAGE,
		ZONE_NOGROUP, ZONE_NOUSER, msg, msgLen );

	ZFree(msg);

    return S_OK;
}


struct ChatContext
{
    CGameControl *pThis;
    int           cOtherUsers;
    bool          fAnyOn;
};


STDMETHODIMP CGameControl::ReceiveChat(ZCGame pGame, ZUserID userID, TCHAR *szText, DWORD cchChars)
{
    // check whether you have chat on or not to determine whether you get game messages.
    // IMPORTANT: this must use key_ChatStatus under your own user's data store, NOT
    // key_LocalChatStatus under ZONE_NOUSER, in order to make sure that your chat status is correctly reflected
    // in the chat history to yourself and all other clients.  that is, if another user sees that you have turned chat off,
    // they can see exactly which messages you saw and which you missed based on the order of the messages along with the "chat off"
    // message in the chat history window.
    CComPtr<IDataStore> pIDS;
    HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, LobbyDataStore()->GetUserId(NULL), &pIDS);
    if(FAILED(hr))
        return hr;

    long fChat = 0;
    pIDS->GetLong(key_ChatStatus, &fChat);
    if(!fChat)
        return S_FALSE;

    // show chat message
    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_USERID, ZONE_NOGROUP, userID, szText, cchChars * sizeof(TCHAR));

    // if it was yours, follow it with an explanation that no one else saw it if they didn't
    ChatContext o;
    o.pThis = this;
    o.cOtherUsers = 0;
    o.fAnyOn = false;
    hr = LobbyDataStore()->EnumUsers(ZONE_NOGROUP, CheckForChatEnum, (LPVOID) &o);
    if(FAILED(hr))
        return S_FALSE;

    if(!o.fAnyOn)
    {
        TCHAR sz[ZONE_MAXSTRING];
        if(ResourceManager()->LoadString(o.cOtherUsers == 1 ? IDS_SYSCHAT_NOTON2 : IDS_SYSCHAT_NOTON4, sz, NUMELEMENTS(sz)))
            EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
    }

    return S_OK;
}


HRESULT ZONECALL CGameControl::CheckForChatEnum(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext)
{
    ChatContext *p = (ChatContext *) pContext;

    if(p->pThis->LobbyDataStore()->GetUserId(NULL) == dwUserId)
        return S_OK;

    p->cOtherUsers++;

    CComPtr<IDataStore> pIDS;
    HRESULT hr = p->pThis->LobbyDataStore()->GetDataStore(ZONE_NOGROUP, dwUserId, &pIDS);
    if(FAILED(hr))
        return S_FALSE;

    long fChat = 0;
    pIDS->GetLong(key_ChatStatus, &fChat);
    if(!fChat)
        return S_OK;

    if(fChat)
        p->fAnyOn = true;

    return S_OK;
}


STDMETHODIMP CGameControl::GetUserName(ZUserID userID, TCHAR *szName, DWORD cchChars)
{
    if(!userID)
        userID = LobbyDataStore()->GetUserId(NULL);

	CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, userID, &pIDS );
	if ( FAILED(hr) )
		return hr;

	DWORD dwLen = cchChars * sizeof(TCHAR);
	hr = pIDS->GetString( key_Name, szName, &dwLen ); 
	if ( FAILED(hr) )
		return hr;

    return S_OK;
}


STDMETHODIMP CGameControl::GameOver(ZCGame)
{
    if(m_bUpsellUp)
        return S_FALSE;

    m_bUpsellUp = true;
    
    ASSERT(m_fGameInProgress);
    CComPtr<IMillUtils> pIMU;
    ZoneShell()->QueryService(SRVID_MillEngine, IID_IMillUtils, (void **) &pIMU);
    if(pIMU)
    {
        pIMU->IncrementCounter(IMillUtils::M_CounterGamesCompleted);
        pIMU->ResetCounter(IMillUtils::M_CounterGamesAbandonedRunning);
    }
    m_fGameInProgress = false;

	return EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_GAME_OVER, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
}


STDMETHODIMP CGameControl::GameOverPlayerReady(ZCGame, ZUserID userID)
{
	CComPtr<IDataStore> pIDS;
	HRESULT hr = LobbyDataStore()->GetDataStore( ZONE_NOGROUP, userID, &pIDS );
	if ( FAILED(hr) )
		return hr;

    pIDS->SetLong( key_PlayerReady, KeyPlayerReady );

    return EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_GAME_PLAYER_READY, ZONE_NOGROUP, userID, 0, 0 );
}


STDMETHODIMP CGameControl::GameOverGameBegun(ZCGame)
{
    HRESULT hr = LobbyDataStore()->EnumUsers(ZONE_NOGROUP, ResetPlayerReadyEnum, this);
    if(FAILED(hr))
        return hr;

    if(!m_bUpsellUp)
        return S_FALSE;

    m_bUpsellUp = false;
    m_fGameInProgress = true;

	return EventQueue()->PostEvent( PRIORITY_NORMAL, EVENT_GAME_BEGUN, ZONE_NOGROUP, ZONE_NOUSER, 0, 0 );
}


HRESULT ZONECALL CGameControl::MyTurn()
{
    FLASHWINFO oFWI;

    if(GetForegroundWindow() != ZoneShell()->GetFrameWindow())
    {
        oFWI.cbSize = sizeof(oFWI);
        oFWI.hwnd = ZoneShell()->GetFrameWindow();
        oFWI.dwFlags = FLASHW_ALL;
        oFWI.uCount = 5;
        oFWI.dwTimeout = 0;
        CALL_MAYBE(FlashWindowEx)(&oFWI);
    }

    return S_OK;
}


HRESULT ZONECALL CGameControl::ResetPlayerReadyEnum(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext)
{
    CGameControl *pThis = (CGameControl *) pContext;

	CComPtr<IDataStore> pIDS;
	HRESULT hr = pThis->LobbyDataStore()->GetDataStore( ZONE_NOGROUP, dwUserId, &pIDS );
	if ( FAILED(hr) )
		return hr;

    pIDS->SetLong( key_PlayerReady, KeyPlayerDeciding );
    return S_OK;
}


STDMETHODIMP CGameControl::ZoneAlert(LPCTSTR szText, LPCTSTR szTitle, LPCTSTR szButton, bool fGameFatal, bool fZoneFatal)
{
    ZoneShell()->AlertMessage((fZoneFatal || fGameFatal) ? NULL : m_hWnd, szText, szTitle,
        szButton ? szButton : fZoneFatal ? AlertButtonQuit : fGameFatal ? AlertButtonNewOpp : AlertButtonOK,
        (fGameFatal && !fZoneFatal) ? AlertButtonQuit : NULL, NULL, 0, fZoneFatal ? EVENT_EXIT_APP : fGameFatal ? EVENT_GAME_FATAL_PROMPT : 0);
    if(fGameFatal || fZoneFatal)
    {
        ZCRoomDeleteBlockedMessages(0);  // must stop processing NOW!  this should be done better, esp the hardcoded tableID - this func really isn't supposed to be exposed here
        EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_GAME_CLIENT_ABORT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_UI_UPSELL_BLOCK, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
        m_nUpsellBlocks++;
    }
    return S_OK;
}


STDMETHODIMP CGameControl::GamePrompt(ZCGame pGame, LPCTSTR szText, LPCTSTR szTitle,
    LPCTSTR szButtonYes, LPCTSTR szButtonNo, LPCTSTR szButtonCancel,
    DWORD nDefault, DWORD dwCookie)
{
    // assume m_pIGG->GetGame() == pGame
    if(!m_pIGG)
        return S_FALSE;

    if(!szButtonYes && !szButtonNo && !szButtonCancel)
        szButtonYes = (LPCTSTR) AlertButtonOK;

    GamePromptContext *pCtxt = new GamePromptContext;
    if(!pCtxt)
        return E_FAIL;

    pCtxt->dwInstanceId = m_dwInstanceId;
    pCtxt->dwCookie = dwCookie;

    return ZoneShell()->AlertMessage(m_hWnd, szText, szTitle, szButtonYes, szButtonNo, szButtonCancel, nDefault,
        EVENT_GAME_PROMPT, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) (LPVOID) pCtxt);
}


STDMETHODIMP CGameControl::GameCannotContinue(ZCGame pGame)
{
    EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_GAME_CLIENT_ABORT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LOBBY_MATCHMAKE, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return S_OK;
}


STDMETHODIMP CGameControl::ZoneExit()
{
    EventQueue()->PostEvent(PRIORITY_HIGH, EVENT_GAME_CLIENT_ABORT, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_EXIT_APP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return S_OK;
}


STDMETHODIMP CGameControl::ZoneLaunchHelp(LPCTSTR szTopic)
{
    EventQueue()->PostEvent(PRIORITY_NORMAL, EVENT_LAUNCH_HELP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
    return S_OK;
}


STDMETHODIMP_(void) CGameControl::ZoneDebugChat(LPTSTR szText)
{
#ifdef DEBUG
    EventQueue()->PostEventWithBuffer(PRIORITY_NORMAL, EVENT_CHAT_RECV_SYSTEM, ZONE_NOGROUP, ZONE_NOUSER, szText, (lstrlen(szText) + 1) * sizeof(TCHAR));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#include <BasicATL.h>


#include "windows.h"
#include "zui.h"


#if 0
//!! do we want any of this?
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\init.cpp ===
/*******************************************************************************

	init.cpp
	
		Zone(tm) Client DLL main file.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Craig Link
	Created on Thursday, November 7, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		11/07/96  craigli	Created.
	 
*******************************************************************************/
#include "BasicATL.h"

#include <ZoneShell.h>

#include "gamecontrol.h"


CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_GameCtl, CGameControl)
END_OBJECT_MAP()




/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/* Globals */
static DWORD g_tlsClient = 0xFFFFFFFF;
static DWORD g_tlsGame = 0xFFFFFFFF;


extern "C"
{

void* ZGetClientGlobalPointer(void)
{
	return ((void*) TlsGetValue(g_tlsClient));
}


void ZSetClientGlobalPointer(void* globalPointer)
{
	TlsSetValue(g_tlsClient, (LPVOID) globalPointer);
}


void* ZGetGameGlobalPointer(void)
{
	return ((void*) TlsGetValue(g_tlsGame));
}


void ZSetGameGlobalPointer(void* globalPointer)
{
	TlsSetValue(g_tlsGame, (LPVOID) globalPointer);
}

}


/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:            

            g_tlsClient = TlsAlloc();
            g_tlsGame = TlsAlloc();

            if ( ( g_tlsClient == 0xFFFFFFFF ) ||
                 ( g_tlsGame == 0xFFFFFFFF ) )
                 return FALSE;

            
		    _Module.Init(ObjectMap, hMod);
		    //DisableThreadLibraryCalls(hInstance);
            // fall thru, b/c this is the first thread attach as well
        case DLL_THREAD_ATTACH:
            // allocate memory and use TlsSetValue
            break;

        case DLL_THREAD_DETACH:
            // free memory retrieved by TlsGetValue
            break;

        case DLL_PROCESS_DETACH:
        	_Module.Term();
            TlsFree(g_tlsGame);
            TlsFree(g_tlsClient);
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\gamecontrol.h ===
// BitmapControl.h : Declaration of the CBitmapControl

// A simple control that takes a bitmap resource name from the config datastore, loads the
// bitmap from the resource manager, and displays it top/left, filling everything else to black.

#pragma once

#include <ZoneResource.h>       // main symbols
#include <BasicATL.h>
#include <atlctl.h>
#include <ClientImpl.h>
//#include <atlgdi.h>
//#include <atlctrls.h>

#include <zGDI.h>
#include <clientimpl.h>

#include <GameShell.h>

/////////////////////////////////////////////////////////////////////////////
// CGameControl
class ATL_NO_VTABLE CGameControl : 
    public IGameShell,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComControl<CGameControl>,
	public IOleControlImpl<CGameControl>,
	public IOleObjectImpl<CGameControl>,
	public IOleInPlaceActiveObjectImpl<CGameControl>,
	public IViewObjectExImpl<CGameControl>,
	public IOleInPlaceObjectWindowlessImpl<CGameControl>,
	public CComCoClass<CGameControl, &CLSID_GameCtl>,
	public IEventClientImpl<CGameControl>,
	public IZoneShellClientImpl<CGameControl>
{
public:
	CGameControl() : m_bClientRunning(FALSE), m_bUpsellUp(false), m_dwInstanceId(0), m_nUpsellBlocks(0), m_fGameInProgress(false)
	{
		m_bWindowOnly = TRUE;
	}


DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_WND_CLASS( _T("GameControl") )

BEGIN_COM_MAP(CGameControl)
	COM_INTERFACE_ENTRY(IEventClient)
    COM_INTERFACE_ENTRY(IGameShell)
	COM_INTERFACE_ENTRY(IZoneShellClient)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
END_COM_MAP()


BEGIN_MSG_MAP(CGameControl)
	MESSAGE_HANDLER(WM_ACTIVATE, OnTransmit)
	MESSAGE_HANDLER(WM_ACTIVATEAPP, OnTransmit)
    MESSAGE_HANDLER(WM_ENABLE, OnTransmit)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnTransmit)
    MESSAGE_HANDLER(WM_NCCREATE, OnNcCreate)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
	CHAIN_MSG_MAP(CComControl<CGameControl>)
END_MSG_MAP()

BEGIN_EVENT_MAP()
    EVENT_HANDLER_WITH_BUFFER(EVENT_NETWORK_RECEIVE, OnNetworkReceive)
    EVENT_HANDLER_WITH_BUFFER(EVENT_CHAT_SEND, OnChatSend)
    EVENT_HANDLER(EVENT_GAME_LOCAL_READY, OnGameLocalReady)
    EVENT_HANDLER_WITH_DATA(EVENT_GAME_LAUNCHING, OnGameLaunching)
    EVENT_HANDLER(EVENT_LOBBY_MATCHMAKE, OnMatchmake)
    EVENT_HANDLER(EVENT_LOBBY_DISCONNECT, OnDisconnect)
    EVENT_HANDLER(EVENT_GAME_CLIENT_ABORT, OnDisconnect)
    EVENT_HANDLER_WITH_DATA(EVENT_GAME_PROMPT, OnPrompt)
    EVENT_HANDLER(EVENT_UI_UPSELL_UP, OnUpsellUp)
    EVENT_HANDLER(EVENT_UI_UPSELL_DOWN, OnUpsellDown)
    EVENT_HANDLER(EVENT_UI_MENU_SHOWSCORE, OnShowScore)
    EVENT_HANDLER_WITH_DATA(EVENT_UI_FRAME_ACTIVATE, OnFrameActivate)
    EVENT_HANDLER_WITH_DATA(EVENT_GAME_FATAL_PROMPT, OnFatalPrompt)
END_EVENT_MAP()

// Event Handlers
private:
    void OnNetworkReceive(DWORD eventId, DWORD groupId, DWORD userId, void* pData, DWORD dataLen)
        { ProcessMessage((EventNetwork *) pData, dataLen); }
    void OnChatSend(DWORD eventId, DWORD groupId, DWORD userId, void* pData, DWORD dataLen);
    void OnGameLocalReady(DWORD eventId, DWORD groupId, DWORD userId);
    void OnGameLaunching(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2);
    void OnMatchmake(DWORD eventId, DWORD groupId, DWORD userId);
    void OnDisconnect(DWORD eventId, DWORD groupId, DWORD userId);
    void OnFrameActivate(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2);
    void OnPrompt(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2);
    void OnUpsellUp(DWORD eventId, DWORD groupId, DWORD userId);
    void OnUpsellDown(DWORD eventId, DWORD groupId, DWORD userId);
    void OnShowScore(DWORD eventId, DWORD groupId, DWORD userId);
    void OnFatalPrompt(DWORD eventId, DWORD groupId, DWORD userId, DWORD dwData1, DWORD dwData2);

    static HRESULT ZONECALL ResetPlayerReadyEnum(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext);

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// IViewObjectEx
public:
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IZoneShellClient
public:
	STDMETHOD(Init)( IZoneShell* pIZoneShell, DWORD dwGroupId, const TCHAR* szKey );
	STDMETHOD(Close)();

// CGameControl
public:
	LRESULT OnNcCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnDraw(ATL_DRAWINFO &di);
    LRESULT OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:	
	CDib m_bitmap;

    TCHAR m_szGameDll[zGameNameLen +1];
	TCHAR m_szGameID[zGameNameLen  + 1];
	TCHAR m_szGameName[zGameNameLen +1];
	TCHAR m_szCommandLine[zGameNameLen + 1];
	TCHAR m_szGameDataFile[zGameNameLen + 1];
	TCHAR m_szServerName[zGameNameLen + 1];

	STDMETHOD(InitGameDLL)();
    bool EndGame(long eCounter);
	
	BOOL m_bClientRunning;
    DWORD m_dwInstanceId;    // count game instances so callback can verify itself
    BOOL m_bUpsellUp;
    DWORD m_nUpsellBlocks;
    bool m_fGameInProgress;  // if a 'game' is running for the purpose of the usage counters in IMillUtils
    CComPtr<IGameGame> m_pIGG;

	void ProcessMessage( EventNetwork* pEvent, DWORD dwLength );

    static HRESULT ZONECALL CheckForChatEnum(DWORD dwGroupId, DWORD dwUserId, LPVOID pContext);


// IGameShell
public:
    STDMETHOD_(IZoneShell*, GetZoneShell)() { return m_pIZoneShell; }
	STDMETHOD_(IResourceManager*, GetResourceManager)() { return m_pIResourceManager; }
	STDMETHOD_(ILobbyDataStore*, GetLobbyDataStore)() { return m_pILobbyDataStore; }
	STDMETHOD_(ITimerManager*, GetTimerManager)() { return m_pITimerManager; }
	STDMETHOD_(IDataStoreManager*, GetDataStoreManager)() { return m_pIDataStoreManager; }
	STDMETHOD_(IDataStore*, GetDataStoreConfig)() { return m_pIDSObjects; }
	STDMETHOD_(IDataStore*, GetDataStoreUI)() { return m_pIDSUI; }
	STDMETHOD_(IDataStore*, GetDataStorePreferences)() { return m_pIDSPreferences; }

    STDMETHOD(SendGameMessage)(int16 table, uint32 messageType, void* message, int32 messageLen);
    STDMETHOD(ReceiveChat)(ZCGame pGame, ZUserID userID, TCHAR *szText, DWORD cchChars);
    STDMETHOD(GetUserName)(ZUserID userID, TCHAR *szName, DWORD cchChars);

    STDMETHOD(GameOver)(ZCGame pGame);
    STDMETHOD(GameOverPlayerReady)(ZCGame pGame, ZUserID userID);
    STDMETHOD(GameOverGameBegun)(ZCGame pGame);

    STDMETHOD(MyTurn)();

    STDMETHOD(ZoneAlert)(LPCTSTR szText, LPCTSTR szTitle = NULL, LPCTSTR szButton = NULL, bool fGameFatal = false, bool fZoneFatal = false);
    STDMETHOD(GamePrompt)(ZCGame pGame, LPCTSTR szText, LPCTSTR szTitle = NULL,
        LPCTSTR szButtonYes = NULL, LPCTSTR szButtonNo = NULL, LPCTSTR szButtonCancel = NULL,
        DWORD nDefault = 0, DWORD dwCookie = 0);

    STDMETHOD(GameCannotContinue)(ZCGame pGame);
    STDMETHOD(ZoneExit)();

    STDMETHOD(ZoneLaunchHelp)(LPCTSTR szTopic = NULL);

    // should not do anything in Release builds
    STDMETHOD_(void, ZoneDebugChat)(LPTSTR szText);

	LRESULT OnTransmit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (!m_pIGG)
			return 0;
		HWND hWnd = m_pIGG->GetWindowHandle();
		if (hWnd)
			SendMessage(hWnd, uMsg, wParam, lParam);
		bHandled = TRUE;

		return 1;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zanim.cpp ===
/*******************************************************************************

	ZAnim.c
	
		Zone(tm) ZAnimation object methods.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, November 12, 1994 03:51:47 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		12/16/96	HI		Changed ZMemCpy() to memcpy().
	1		12/12/96	HI		Remove MSVCRT.DLL dependency.
	0		11/12/94	HI		Created.
	 
*******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "zone.h"
#include "zoneint.h"
#include "zonemem.h"


#define I(n)			((IAnimation) (n))
#define Z(n)			((ZAnimation) (n))


typedef struct
{
	ZGrafPort			grafPort;		/* Parent port to draw in. */
	ZBool				play;			/* Animation play state. */
	ZBool				visible;
	int16				curFrame;		/* Current frame number. */
	uint16				numFrames;		/* Number of frames in the animation. */
	uint16				frameDuration;	/* Duration per frame. */
	uint16				numImages;		/* Number of images. */
	uint16				numSounds;		/* Number of sounds. */
	int16				rfu;
	ZOffscreenPort		offscreen;
	ZRect				bounds;			/* Animation bounds. */
	ZAnimFrame*			frames;			/* Pointer to frame sequence list. */
	ZImage				commonMask;		/* Common mask image. */
	ZImage*				images;			/* Pointer to list of images. */
	ZSound*				sounds;			/* Pointer to list of sounds. */
	ZAnimationCheckFunc	checkFunc;
	ZAnimationDrawFunc	drawFunc;		/* Func pointer to draw the background. */
	ZTimer				timer;
	void*				userData;
} IAnimationType, *IAnimation;


/* -------- Internal Routines -------- */
static void ZAnimationAdvanceFrame(ZAnimation animation);
static void AnimationTimerFunc(ZTimer timer, void* userData);
static void AnimationBaseInit(IAnimation anim, ZAnimationDescriptor* animDesc);


/*
	Creates a new IAnimation object. Allocates the buffer and initializes
	pointer fields to NULL.
*/
ZAnimation ZAnimationNew(void)
{
	IAnimation			anim;
	
	
	anim = (IAnimation) ZMalloc(sizeof(IAnimationType));
	anim->grafPort = NULL;
	anim->frames = NULL;
	anim->images = NULL;
	anim->sounds = NULL;
	anim->checkFunc = NULL;
	anim->drawFunc = NULL;
	anim->timer = NULL;
	anim->offscreen = NULL;
	anim->userData = NULL;
	anim->commonMask = NULL;
	
	return (Z(anim));
}


/*
	Initializes an animation object by setting internal fields according
	to the specified animation descriptor and allocating all the internal
	buffers.
*/
ZError ZAnimationInit(ZAnimation animation,
		ZGrafPort grafPort, ZRect* bounds, ZBool visible,
		ZAnimationDescriptor* animationDescriptor,
		ZAnimationCheckFunc checkFunc,
		ZAnimationDrawFunc backgroundDrawFunc, void* userData)
{
	IAnimation				anim = I(animation);
	ZError					err = zErrNone;
	uint16					i;
	uint32*					offsets;
	

	AnimationBaseInit(anim, animationDescriptor);
	ZAnimationSetParams(anim, grafPort, bounds, visible,
			checkFunc, backgroundDrawFunc, userData);
	
	/* Allocate frame sequence list buffer and copy it. */
	anim->frames = (ZAnimFrame*) ZMalloc(anim->numFrames * sizeof(ZAnimFrame));
	if (anim->frames != NULL)
	{
		memcpy(anim->frames, (BYTE*) animationDescriptor + animationDescriptor->sequenceOffset,
				anim->numFrames * sizeof(ZAnimFrame));
	}
	else
	{
		err = zErrOutOfMemory;
		goto Exit;
	}
	
	/* Create ZImage objects for each image and add it to the image list. */
	if (anim->numImages > 0)
	{
		anim->images = (ZImage*) ZCalloc(sizeof(ZImage), anim->numImages);
		if (anim->images != NULL)
		{
			if (animationDescriptor->maskDataOffset > 0)
			{
				if ((anim->commonMask = ZImageNew()) == NULL)
				{
					err = zErrOutOfMemory;
					goto Exit;
				}
				if (ZImageInit(anim->commonMask, NULL,
						(ZImageDescriptor*) ((BYTE*) animationDescriptor +
						animationDescriptor->maskDataOffset)) != zErrNone)
				{
					err = zErrOutOfMemory;
					goto Exit;
				}
			}
			
			offsets = (uint32*) ((BYTE*) animationDescriptor +
					animationDescriptor->imageArrayOffset);
			for (i = 0; i < anim->numImages; i++)
			{
				if ((anim->images[i] = ZImageNew()) == NULL)
				{
					err = zErrOutOfMemory;
					break;
				}
				if (ZImageInit(anim->images[i],
						(ZImageDescriptor*) ((BYTE*) animationDescriptor + offsets[i]),
						NULL) != zErrNone)
				{
					err = zErrOutOfMemory;
					break;
				}
			}
			
			/* If we're out of memory, then delete all image objects. */
			if (err == zErrOutOfMemory)
			{
				for (i = 0; i < anim->numImages; i++)
					if (anim->images[i] != NULL)
						ZImageDelete(anim->images[i]);
			}
		}
		else
		{
			err = zErrOutOfMemory;
			goto Exit;
		}
	}
	
	/* Create all sounds objects. */
	if (anim->numSounds > 0)
	{
		anim->sounds = (ZImage*) ZCalloc(sizeof(ZSound), anim->numSounds);
		if (anim->sounds != NULL)
		{
			offsets = (uint32*) ((BYTE*) animationDescriptor +
					animationDescriptor->soundArrayOffset);
			for (i = 0; i < anim->numSounds; i++)
			{
				if ((anim->sounds[i] = ZSoundNew()) == NULL)
				{
					err = zErrOutOfMemory;
					break;
				}
				if (ZSoundInit(anim->sounds[i],
						(ZSoundDescriptor*) ((BYTE*) animationDescriptor + offsets[i])) != zErrNone)
				{
					err = zErrOutOfMemory;
					break;
				}
			}
			
			/* If we're out of memory, then delete all image objects. */
			if (err == zErrOutOfMemory)
			{
				for (i = 0; i < anim->numSounds; i++)
					if (anim->sounds[i] != NULL)
						ZSoundDelete(anim->sounds[i]);
			}
		}
		else
		{
			err = zErrOutOfMemory;
			goto Exit;
		}
	}
	
	/* Create the timer object. */
	if ((anim->timer = ZTimerNew()) != NULL)
	{
		if (ZTimerInit(anim->timer, 0, AnimationTimerFunc, (void*) anim) != zErrNone)
			err = zErrOutOfMemory;
	}
	else
	{
		err = zErrOutOfMemory;
	}
	
Exit:

	return (err);
}


/*
	Destroys the IAnimation object by freeing all the internal buffers
	and the object itself.
*/
void ZAnimationDelete(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	uint16			i;
	
	
	if (anim != NULL)
	{
		if (anim->frames != NULL)
			ZFree(anim->frames);
		
		if (anim->commonMask != NULL)
			ZImageDelete(anim->commonMask);
		
		if (anim->images != NULL)
		{
			for (i = 0; i < anim->numImages; i++)
				if (anim->images[i] != NULL)
					ZImageDelete(anim->images[i]);
			ZFree(anim->images);
		}
		
		if (anim->sounds != NULL)
		{
			for (i = 0; i < anim->numSounds; i++)
				if (anim->sounds[i] != NULL)
					ZSoundDelete(anim->sounds[i]);
			ZFree(anim->sounds);
		}
		
		if (anim->timer != NULL)
			ZTimerDelete(anim->timer);
		
		if (anim->offscreen != NULL)
			ZOffscreenPortDelete(anim->offscreen);
		
		ZFree(anim);
	}
}


/*
	Returns the number of frames in the animation.
*/
int16 ZAnimationGetNumFrames(ZAnimation animation)
{
	return (I(animation)->numFrames);
}


/*
	Sets current frame to the specified frame number. If the new frame
	number is greater than the number of frames, then current frame is
	set to the last frame.
*/
void ZAnimationSetCurFrame(ZAnimation animation, uint16 frame)
{
	IAnimation		anim = I(animation);
	
	
	if (frame >= anim->numFrames)
		frame = anim->numFrames;
	anim->curFrame = frame;
}


/*
	Returns the current frame number.
*/
uint16 ZAnimationGetCurFrame(ZAnimation animation)
{
	return (I(animation)->curFrame);
}


/*
 *	Draws the current animation frame.
 */
void ZAnimationDraw(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	if (anim->visible)
	{
		ZBeginDrawing(anim->offscreen);
		if( anim->offscreen != NULL )
		{
			ZSetClipRect(anim->offscreen, &anim->bounds);
			ZRectErase(anim->offscreen, &anim->bounds);
		
			/* Sounds */

			/* Draw background */
			if (anim->drawFunc != NULL)
				(anim->drawFunc)(anim, anim->offscreen, &anim->bounds, anim->userData);
			
			/* Draw current frame image. */
			ZImageDraw(anim->images[anim->frames[anim->curFrame - 1].imageIndex - 1],
					anim->offscreen, &anim->bounds, anim->commonMask, zDrawCopy);
			
			ZEndDrawing(anim->offscreen);
			
			/* Copy to user port. */
			ZCopyImage(anim->offscreen, anim->grafPort, &anim->bounds, &anim->bounds, NULL, zDrawCopy);
		}
	}
}


/*
	Starts the animation by starting the timer.
*/
void ZAnimationStart(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	anim->play = TRUE;
	anim->curFrame = 1;
	
	ZAnimationDraw(animation);
	
	/* Start the timer. */
	ZTimerSetTimeout(anim->timer, anim->frameDuration);
}


/*
	Stops the animation by stopping the timer.
*/
void ZAnimationStop(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	anim->play = FALSE;
	
	/* Stop the timer. */
	ZTimerSetTimeout(anim->timer, 0);
}


void ZAnimationContinue(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	anim->play = TRUE;
	
	/* Start the timer. */
	ZTimerSetTimeout(anim->timer, anim->frameDuration);
}


/*
	Returns TRUE if the animation is still playing; otherwise, it returns
	FALSE.
*/
ZBool ZAnimationStillPlaying(ZAnimation animation)
{
	return (I(animation)->play);
}


void ZAnimationShow(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	anim->visible = TRUE;
	ZAnimationDraw(animation);
}


void ZAnimationHide(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	
	
	/* If currently visible, erase animation by drawing background. */
	if (anim->visible)
	{
		ZBeginDrawing(anim->offscreen);
		if( anim->offscreen != NULL )
		{
			ZSetClipRect(anim->offscreen, &anim->bounds);
		}
		if (anim->drawFunc != NULL)
			(anim->drawFunc)(anim, anim->offscreen, &anim->bounds, anim->userData);
		ZEndDrawing(anim->offscreen);
		ZCopyImage(anim->offscreen, anim->grafPort, &anim->bounds, &anim->bounds, NULL, zDrawCopy);
	}
	anim->visible = FALSE;
}


ZBool ZAnimationIsVisible(ZAnimation animation)
{
	return (I(animation)->visible);
}


/*
	Modified to load 'ANIM' resource from the 'fileName' DLL.
	Parameter fileOffset indicates the resource ID of 'ANIM' resource
	to load for animation descriptor.
*/
ZAnimation ZAnimationCreateFromFile(TCHAR* fileName, int32 fileOffset)
{
	ZAnimationDescriptor*	animDesc;
	uint32					size;
	IAnimation				anim = NULL;
	int16					i;
	HINSTANCE				hFile = NULL;
	HRSRC					hRsrc = NULL;
	HGLOBAL					hData = NULL;
	int32*					imageList = NULL;


	hFile = LoadLibrary( fileName );
	if ( hFile == NULL )
		goto Error;

	hRsrc = FindResource( hFile, MAKEINTRESOURCE( fileOffset ), _T("ANIM") );
	if ( hRsrc == NULL )
		goto Error;

	hData = LoadResource( hFile, hRsrc );
	if ( hData == NULL )
		goto Error;

	animDesc = (ZAnimationDescriptor*) LockResource( hData );
	if ( animDesc == NULL )
		goto Error;

	if ((anim = (IAnimation)ZAnimationNew()) == NULL)
		goto Error;
	
	AnimationBaseInit(anim, animDesc);

	/* Allocate frame sequence list buffer and read it. */
	size = anim->numFrames * sizeof( ZAnimFrame );
	if ( ( anim->frames = (ZAnimFrame*) ZMalloc( size ) ) == NULL )
		goto Error;
	CopyMemory( anim->frames, (BYTE*) animDesc + animDesc->sequenceOffset, size );

	/*
		Create ZImage objects for each image and add it to the image list.
		Each Image is a bitmap resource from the DLL.
	*/
	if (anim->numImages > 0)
	{
		/* Allocate image list array. */
		if ( ( anim->images = (ZImage*) ZCalloc( sizeof( ZImage ), anim->numImages ) ) == NULL )
			goto Error;
		
		imageList = (int32*) ( (BYTE*) animDesc + animDesc->imageArrayOffset );
		for ( i = 0; i < anim->numImages; i++ )
		{
			anim->images[ i ] = ZImageCreateFromBMPRes( hFile, (WORD) imageList[ i ], RGB( 0xFF, 0x00, 0xFF ) );
			if ( anim->images[ i ] == NULL )
				goto Error;
		}
	}

	/* Create the timer object. */
	if ((anim->timer = ZTimerNew()) == NULL)
		goto Error;
	if (ZTimerInit(anim->timer, 0, AnimationTimerFunc, (void*) anim) != zErrNone)
		goto Error;

	FreeLibrary( hFile );
	hFile = NULL;

	goto Exit;

Error:
	if ( hFile != NULL )
		FreeLibrary( hFile );
	if ( anim != NULL )
		ZAnimationDelete( anim );
	anim = NULL;

Exit:
	
	return anim;
}


ZError ZAnimationSetParams(ZAnimation animation, ZGrafPort grafPort,
		ZRect* bounds, ZBool visible, ZAnimationCheckFunc checkFunc,
		ZAnimationDrawFunc backgroundDrawFunc, void* userData)
{
	IAnimation			anim = I(animation);
	ZError				err = zErrNone;
	
	
	if (animation == NULL)
		return (zErrNilObject);
	
	anim->grafPort = grafPort;
	anim->visible = visible;
	anim->bounds = *bounds;
	anim->checkFunc = checkFunc;
	anim->drawFunc = backgroundDrawFunc;
	anim->userData = userData;

	/* Create the offscreen port object. */
	if ((anim->offscreen = ZOffscreenPortNew()) != NULL)
	{
		if (ZOffscreenPortInit(anim->offscreen, bounds) != zErrNone)
			err = zErrOutOfMemory;
	}
	else
	{
		err = zErrOutOfMemory;
	}
	
	return (err);
}


ZBool ZAnimationPointInside(ZAnimation animation, ZPoint* point)
{
	IAnimation			anim = I(animation);
	ZBool				inside = FALSE;
	ZPoint				localPoint = *point;
	
	
	if (animation == NULL)
		return (FALSE);
		
	if (ZPointInRect(&localPoint, &anim->bounds))
	{
		localPoint.x -= anim->bounds.left;
		localPoint.y -= anim->bounds.top;
		if (anim->commonMask != NULL)
			inside = ZImagePointInside(anim->commonMask, &localPoint);
		else
			inside = ZImagePointInside(anim->images[anim->frames[anim->curFrame - 1].imageIndex - 1], &localPoint);
	}
	
	return (inside);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

/*
	Advances the animation to the next frame.
*/
static void ZAnimationAdvanceFrame(ZAnimation animation)
{
	IAnimation		anim = I(animation);
	int16			next;
	
	
	next = anim->frames[anim->curFrame - 1].nextFrameIndex;
	if (next == 0)
		anim->curFrame++;
	else
		anim->curFrame = next;
	if (anim->curFrame <= 0 || anim->curFrame > anim->numFrames)
	{
		anim->curFrame = 0;
		anim->play = FALSE;
	}
	
	if (anim->checkFunc != NULL)
		anim->checkFunc(animation, anim->curFrame, anim->userData);
}


/*
	Timer procedure for the animation object.
	
	This routine gets called periodically by the Timer object and it
	advances the animation to the next frame and draws the image.
*/
static void AnimationTimerFunc(ZTimer timer, void* userData)
{
	IAnimation			anim = I(userData);
	
	
	if (anim->play != FALSE)
	{
		ZAnimationAdvanceFrame(anim);
		
		if (anim->play != FALSE)
			ZAnimationDraw(anim);
	}
}


static void AnimationBaseInit(IAnimation anim, ZAnimationDescriptor* animDesc)
{
	anim->grafPort = NULL;
	anim->play = FALSE;
	anim->visible = FALSE;
	anim->curFrame = 1;
	anim->numFrames = animDesc->numFrames;
	anim->numImages = animDesc->numImages;
	anim->numSounds = animDesc->numSounds;
	anim->frameDuration = (uint16)(animDesc->totalTime * 10) / (uint16)(anim->numFrames);
	anim->checkFunc = NULL;
	anim->drawFunc = NULL;
	anim->userData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zbrush.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZBrush.cpp
/*******************************************************************************
		ZBrush
*******************************************************************************/

#include "zui.h"
#include "zonemem.h"



class ZBrushI {
public:
	ZObjectType nType;
	HBRUSH hBrush;
};

ZBool MybrushWindowProc(ZWindow window, ZMessage *message);

ZBrush ZLIBPUBLIC ZBrushNew(void)
{
	ZBrushI* pBrush = new ZBrushI;
	pBrush->hBrush = NULL;
	return (ZBrush)pBrush;
}


ZError ZBrushInit(ZBrush brush, ZImage image)
{
	ZBrushI* pBrush = (ZBrushI*) brush;

	LOGBRUSH lb;
	lb.lbStyle = BS_PATTERN;
	lb.lbColor = 0;
	lb.lbHatch = (long)ZImageGetHBitmapImage(image);
	pBrush->hBrush = CreateBrushIndirect(&lb);
	
	return zErrNone;
}

void ZLIBPUBLIC ZBrushDelete(ZBrush brush)
{
	ZBrushI* pBrush = (ZBrushI*) brush;

	if (pBrush->hBrush) DeleteObject(pBrush->hBrush);
	delete pBrush;
}

HBRUSH ZBrushGetHBrush(ZBrush brush)
{
	ZBrushI* pBrush = (ZBrushI*) brush;
	return pBrush->hBrush;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zbutton.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZButton.cpp

#include "zui.h"
#include "zonecli.h"

class ZButtonI : public ZObjectHeader {
public:
	ZButtonFunc buttonFunc;
	HWND hWnd;
	void *userData;
	WNDPROC defaultWndProc;
};

////////////////////////////////////////////////////////////////////////
// ZButton

ZButton ZLIBPUBLIC ZButtonNew(void)
{
	ZButtonI* pButton = new ZButtonI;
	pButton->nType = zTypeButton;
	return (ZButton)pButton;
}

LRESULT CALLBACK MyButtonWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ZButtonI* pButton = (ZButtonI*)MyGetProp32(hWnd, _T("pWindow"));

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
        // PCWTODO: Need to call convert message?
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
	}
	default:
		break;
	}

	return CallWindowProc((ZONECLICALLWNDPROC)pButton->defaultWndProc,hWnd,msg,wParam,lParam);
}

ZError ZLIBPUBLIC ZButtonInit(ZButton button, ZWindow parentWindow,
		ZRect* buttonRect, TCHAR* title, ZBool visible, ZBool enabled,
		ZButtonFunc buttonProc, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZButtonI* pButton = (ZButtonI*)button;
	pButton->buttonFunc = buttonProc;
	pButton->userData = userData;			


	{
		DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_TABSTOP;
		if (visible) dwStyle |= WS_VISIBLE;
		if (!enabled) dwStyle |= WS_DISABLED;
		dwStyle |=  BS_PUSHBUTTON;
		pButton->hWnd = CreateWindow(_T("BUTTON"),title,dwStyle,
			buttonRect->left,buttonRect->top,buttonRect->right-buttonRect->left,
			buttonRect->bottom - buttonRect->top, 
			ZWindowWinGetWnd(parentWindow), (HMENU)ZWindowWinGetNextControlID(parentWindow),
			g_hInstanceLocal, pButton);

		if (!pButton->hWnd) return zErrWindowSystemGeneric;
	 	// buttons can't use the extra data, they will use the set prop feature
		MySetProp32(pButton->hWnd,_T("pWindow"),(void*)pButton);

		pButton->defaultWndProc = (WNDPROC)SetWindowLong(pButton->hWnd,GWL_WNDPROC,(LONG)MyButtonWndProc);
	}
	return zErrNone;
}

void    ZLIBPUBLIC ZButtonDelete(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;                                                      
	if (pButton->hWnd) {
		SetWindowLong(pButton->hWnd,GWL_WNDPROC,(LONG)pButton->defaultWndProc);
		MyRemoveProp32(pButton->hWnd, _T("pWindow"));
		DestroyWindow(pButton->hWnd);
	}
	delete pButton;
}

void    ZLIBPUBLIC ZButtonGetRect(ZButton button, ZRect *buttonRect)
{
	ZButtonI* pButton = (ZButtonI*)button;
	RECT rect;
	GetClientRect(pButton->hWnd,&rect);
	WRectToZRect(buttonRect,&rect);
}

ZError  ZLIBPUBLIC ZButtonSetRect(ZButton button, ZRect *buttonRect)
{
	ZButtonI* pButton = (ZButtonI*)button;
	BOOL bOk = SetWindowPos(pButton->hWnd, NULL,buttonRect->left,
		buttonRect->top, buttonRect->right - buttonRect->left,
		buttonRect->bottom - buttonRect->top,
		SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZButtonMove(ZButton button, int16 left, int16 top)
{
	ZButtonI* pButton = (ZButtonI*)button;
	BOOL bOk = SetWindowPos(pButton->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZButtonSize(ZButton button, int16 width, int16 height)
{
	ZButtonI* pButton = (ZButtonI*)button;

	BOOL bOk = SetWindowPos(pButton->hWnd, NULL,0,0,
		width,height,SWP_NOMOVE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZBool ZLIBPUBLIC ZButtonIsVisible(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	return IsWindowVisible(pButton->hWnd);
}

ZError  ZLIBPUBLIC ZButtonShow(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	ShowWindow(pButton->hWnd, SW_SHOWNORMAL);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZButtonHide(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	ShowWindow(pButton->hWnd, SW_HIDE);
	return zErrNone;
}

ZBool ZLIBPUBLIC ZButtonIsEnabled(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	return IsWindowEnabled(pButton->hWnd);
}

ZError  ZLIBPUBLIC ZButtonEnable(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	EnableWindow(pButton->hWnd, TRUE);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZButtonDisable(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;

	// Added check for NULL pointer - mdm 9/9/97
	if (!pButton)
		return zErrNone;

	EnableWindow(pButton->hWnd, FALSE);
	/* on being disabled, set focus to parent */
	if (GetFocus()==NULL) {
		SetFocus(GetParent(pButton->hWnd));
	}
	return zErrNone;
}

void    ZLIBPUBLIC ZButtonGetTitle(ZButton button, TCHAR *title, uint16 len)
{
	ZButtonI* pButton = (ZButtonI*)button;
	GetWindowText(pButton->hWnd,title,len);
}

ZError  ZLIBPUBLIC ZButtonSetTitle(ZButton button, TCHAR *title)
{
	ZButtonI* pButton = (ZButtonI*)button;
	SetWindowText(pButton->hWnd,title);
	return zErrNone;
}

LRESULT ZButtonDispatchProc(ZButton button, WORD wNotifyCode)
{
	ZButtonI* pButton = (ZButtonI*)button;
	switch (wNotifyCode) {
	case BN_CLICKED:
		pButton->buttonFunc(pButton, pButton->userData);
	}
	return 0L;
}

void ZButtonSetDefaultButton(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	SendMessage(pButton->hWnd,BM_SETSTYLE,BS_DEFPUSHBUTTON,MAKELONG(TRUE,0));
}

void ZButtonClickButton(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;
	SendMessage(GetParent(pButton->hWnd), WM_COMMAND, MAKEWPARAM(0,BN_CLICKED), (LPARAM)pButton->hWnd);
}

ZButtonFunc ZLIBPUBLIC ZButtonGetFunc(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;

	return pButton->buttonFunc;
}	
	
void ZLIBPUBLIC ZButtonSetFunc(ZButton button, ZButtonFunc buttonFunc)
{
	ZButtonI* pButton = (ZButtonI*)button;

	pButton->buttonFunc = buttonFunc;
}	

void* ZLIBPUBLIC ZButtonGetUserData(ZButton button)
{
	ZButtonI* pButton = (ZButtonI*)button;

	return pButton->userData;
}	
	
void ZLIBPUBLIC ZButtonSetUserData(ZButton button, void* userData)
{
	ZButtonI* pButton = (ZButtonI*)button;

	pButton->userData = userData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcliroomimp.h ===
/* -------- Local Routines -------- */
void HandleAccessedMessage();
void HandleGameMessage(ZRoomMsgGameMessage* msg);
IGameGame* StartNewGame(int16 tableID, ZSGame gameID, ZUserID userID, int16 seat, int16 playerType);

void RoomExit(void);
void DeleteGameOnTable(int16 table);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcards.cpp ===
/*******************************************************************************

	ZCards.c
	
		Zone(tm) ZCards object methods.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Monday, October 9, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	4		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
	3		11/15/96	HI		More changes related to ZONECLI_DLL.
	2		11/09/96	HI		Conditionalized changes for ZONECLI_DLL.
								Moved definition of zNumSmallCardTypes to
								zcards.h.
    1       10/13/96    HI      Fixed compiler warnings.
	0		10/09/95	HI		Created.
	 
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zonecli.h"
#include "zcards.h"
#include "zoneresource.h"


#define I(n)			((ICards) (n))
#define Z(n)			((ZCards) (n))


enum
{
	zCardsImage = 0,
	zCardsMask
};

/* -------- Small Cards 2 Image Index -------- */
enum
{
	zCardsSmallUpSide = 0,
	zCardsSmallDownSide,
	zCardsSmallLeftSide,
	zCardsSmallRightSide,
	zCardsSmallVerticalMask,
	zCardsSmallHorizontalMask,
	zCardsSmallSelectVerticalMask,
	zCardsSmallSelectHorizontalMask
};


typedef struct
{
	ZPoint			origin;
	ZPoint			rankOffset;
	ZPoint			suitOffset;
	ZPoint			size;
} ZCardsSmallInfoType, *ZCardsSmallInfo;


/* -------- Globals -------- */
#ifdef ZONECLI_DLL

#define gCardsImage					(pGlobals->m_gCardsImage)
#define gCardMask					(pGlobals->m_gCardMask)
#define gSmallCards					(pGlobals->m_gSmallCards)
#define gSmallCardMasks				(pGlobals->m_gSmallCardMasks)

#else

static ZOffscreenPort				gCardsImage;
static ZMask						gCardMask;
static ZOffscreenPort				gSmallCards[zNumSmallCardTypes];
static ZMask						gSmallCardMasks[zNumSmallCardTypes];

#endif

static int16						gSmallCardMaskID[zNumSmallCardTypes] =
											{
												zCardsSmallVerticalMask,
												zCardsSmallVerticalMask,
												zCardsSmallHorizontalMask,
												zCardsSmallHorizontalMask
											};
static ZCardsSmallInfoType			gCardsSmallInfo[] =
										{
											{
												{0, 0},
												{zCardsSmallSizeWidth, 0},
												{0, zCardsSmallSizeHeight},
												{zCardsSmallSizeWidth, zCardsSmallSizeHeight}
											},
											{
												{351 - zCardsSmallSizeWidth, 144 - zCardsSmallSizeHeight},
												{-zCardsSmallSizeWidth, 0},
												{0, -zCardsSmallSizeHeight},
												{zCardsSmallSizeWidth, zCardsSmallSizeHeight}
											},
											{
												{0, 351 - zCardsSmallSizeWidth},
												{0, -zCardsSmallSizeWidth},
												{zCardsSmallSizeHeight, 0},
												{zCardsSmallSizeHeight, zCardsSmallSizeWidth}
											},
											{
												{144 - zCardsSmallSizeHeight, 0},
												{0, zCardsSmallSizeWidth},
												{-zCardsSmallSizeHeight, 0},
												{zCardsSmallSizeHeight, zCardsSmallSizeWidth}
											}
										};


/* -------- Internal Routines -------- */
static ZError LoadCardImages(void);
static void DrawCard(int16 cardIndex, ZGrafPort grafPort, ZRect* rect);
static LoadSmallCards(int16 orientation);
static void DrawSmallCard(int16 orientation, int16 cardIndex, ZGrafPort grafPort, ZRect* rect);
static void GetSmallCardImageRect(int16 orientation, int16 suit, int16 rank, ZRect* rect);


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZError ZCardsInit(int16 cardType)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZError				err = zErrNone;
	
	
	switch (cardType)
	{
		case zCardsNormal:
			if (gCardsImage == NULL)
				err = LoadCardImages();
			break;
		case zCardsSmallUp:
			if (gSmallCards[zCardsSmallUpSide] == NULL)
				err = LoadSmallCards(zCardsSmallUpSide);
			break;
		case zCardsSmallDown:
			if (gSmallCards[zCardsSmallDownSide] == NULL)
				err = LoadSmallCards(zCardsSmallDownSide);
			break;
		case zCardsSmallLeft:
			if (gSmallCards[zCardsSmallLeftSide] == NULL)
				err = LoadSmallCards(zCardsSmallLeftSide);
			break;
		case zCardsSmallRight:
			if (gSmallCards[zCardsSmallRightSide] == NULL)
				err = LoadSmallCards(zCardsSmallRightSide);
			break;
	}
	
	return (err);
}


void ZCardsDelete(int16 cardType)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	switch (cardType)
	{
		case zCardsNormal:
			if (gCardsImage != NULL)
			{
				ZOffscreenPortDelete(gCardsImage);
				ZImageDelete(gCardMask);
				
				gCardsImage = NULL;
				gCardMask = NULL;
			}
			break;
		case zCardsSmallUp:
			if (gSmallCards[zCardsSmallUpSide] != NULL)
			{
				ZOffscreenPortDelete(gSmallCards[zCardsSmallUpSide]);
				gSmallCards[zCardsSmallUpSide] = NULL;
				
				ZImageDelete(gSmallCardMasks[zCardsSmallUpSide]);
				gSmallCardMasks[zCardsSmallUpSide] = NULL;
			}
			break;
		case zCardsSmallDown:
			if (gSmallCards[zCardsSmallDownSide] != NULL)
			{
				ZOffscreenPortDelete(gSmallCards[zCardsSmallDownSide]);
				gSmallCards[zCardsSmallDownSide] = NULL;
				
				ZImageDelete(gSmallCardMasks[zCardsSmallDownSide]);
				gSmallCardMasks[zCardsSmallDownSide] = NULL;
			}
			break;
		case zCardsSmallLeft:
			if (gSmallCards[zCardsSmallLeftSide] != NULL)
			{
				ZOffscreenPortDelete(gSmallCards[zCardsSmallLeftSide]);
				gSmallCards[zCardsSmallLeftSide] = NULL;
				
				ZImageDelete(gSmallCardMasks[zCardsSmallLeftSide]);
				gSmallCardMasks[zCardsSmallLeftSide] = NULL;
			}
			break;
		case zCardsSmallRight:
			if (gSmallCards[zCardsSmallRightSide] != NULL)
			{
				ZOffscreenPortDelete(gSmallCards[zCardsSmallRightSide]);
				gSmallCards[zCardsSmallRightSide] = NULL;
				
				ZImageDelete(gSmallCardMasks[zCardsSmallRightSide]);
				gSmallCardMasks[zCardsSmallRightSide] = NULL;
			}
			break;
	}
}


void ZCardsDrawCard(int16 cardType, int16 cardIndex, ZGrafPort grafPort, ZRect* rect)
{
	switch (cardType)
	{
		case zCardsNormal:
			DrawCard(cardIndex, grafPort, rect);
			break;
		case zCardsSmallUp:
			DrawSmallCard(zCardsSmallUpSide, cardIndex, grafPort, rect);
			break;
		case zCardsSmallDown:
			DrawSmallCard(zCardsSmallDownSide, cardIndex, grafPort, rect);
			break;
		case zCardsSmallLeft:
			DrawSmallCard(zCardsSmallLeftSide, cardIndex, grafPort, rect);
			break;
		case zCardsSmallRight:
			DrawSmallCard(zCardsSmallRightSide, cardIndex, grafPort, rect);
			break;
	}
}


/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

static ZError LoadCardImages(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZError				err = zErrNone;
	ZImage				tempImage;
	HBITMAP hBitmapCards = NULL;
    HBITMAP hBitmapMask = NULL;

    hBitmapCards = (HBITMAP)ZShellResourceManager()->LoadImage(MAKEINTRESOURCE(IDB_CARDS),IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    //hBitmapCards = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCEA(IDB_CARDS));
    if(!hBitmapCards)
        goto NoResource;

    hBitmapMask = (HBITMAP)ZShellResourceManager()->LoadImage(MAKEINTRESOURCE(IDB_CARD_MASK),IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    //hBitmapMask = ZShellResourceManager()->LoadBitmap(MAKEINTRESOURCEA(IDB_CARD_MASK));
    if(!hBitmapMask)
        goto NoResource;

	if ((tempImage = ZImageCreateFromBMP(hBitmapCards, RGB(255, 0, 255))) == NULL)
		goto OutOfMemory;
	gCardsImage = ZConvertImageToOffscreenPort(tempImage);

	if ((gCardMask = ZImageCreateFromBMP(hBitmapMask, RGB(255, 0, 255))) == NULL)
		goto OutOfMemory;

	goto Exit;

NoResource:
    err = zErrResourceNotFound;
    // PCWTODO: String
    ZShellGameShell()->ZoneAlert(ErrorTextResourceNotFound, NULL, NULL, false, true);
    //ZAlert(_T("Could not find card resource."), NULL);

	goto Exit;

OutOfMemory:
	err = zErrOutOfMemory;
    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
	//ZAlert(_T("Out of memory while loading card images."), NULL);
	

Exit:
    /*
    if(hBitmapCards)
        DeleteObject(hBitmapCards);
    

    if(hBitmapMask)
        DeleteObject(hBitmapMask);
	*/
	return (err);
}


static void DrawCard(int16 cardIndex, ZGrafPort grafPort, ZRect* rect)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZRect		srcRect;
	int16		suit, rank;
	
	
	if (gCardsImage != NULL)
	{
		suit = ZCardsSuit(cardIndex);
		rank = ZCardsRank(cardIndex);
		
		ZSetRect(&srcRect, 0, 0, zCardsSizeWidth, zCardsSizeHeight);
		ZRectOffset(&srcRect, (int16) (zCardsSizeWidth * rank), (int16) (zCardsSizeHeight * suit));
		ZCopyImage(gCardsImage, grafPort, &srcRect, rect, gCardMask, zDrawCopy);
	}
}


static LoadSmallCards(int16 orientation)
{
	return zErrNotImplemented;
}


static void DrawSmallCard(int16 orientation, int16 cardIndex, ZGrafPort grafPort, ZRect* rect)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZRect		srcRect;
	int16		suit, rank;
	
	
	if (gSmallCards[orientation] != NULL)
	{
		suit = ZCardsSuit(cardIndex);
		rank = ZCardsRank(cardIndex);
		
		GetSmallCardImageRect(orientation, suit, rank, &srcRect);
		ZCopyImage(gSmallCards[orientation], grafPort, &srcRect, rect,
				gSmallCardMasks[orientation], zDrawCopy);
	}
}


static void GetSmallCardImageRect(int16 orientation, int16 suit, int16 rank, ZRect* rect)
{
	rect->left = gCardsSmallInfo[orientation].origin.x;
	rect->top = gCardsSmallInfo[orientation].origin.y;
	rect->right = rect->left + gCardsSmallInfo[orientation].size.x;
	rect->bottom = rect->top + gCardsSmallInfo[orientation].size.y;
	
	ZRectOffset(rect, (int16)(gCardsSmallInfo[orientation].rankOffset.x * rank),
			(int16) (gCardsSmallInfo[orientation].rankOffset.y * rank));
	ZRectOffset(rect, (int16)(gCardsSmallInfo[orientation].suitOffset.x * suit),
			(int16) (gCardsSmallInfo[orientation].suitOffset.y * suit));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcursor.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZCursor.cpp

#include "zui.h"
#include "zonemem.h"

class ZCursorI {
public:
	ZObjectType nType;
	HCURSOR hCursor;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//	ZCursor

ZCursor ZLIBPUBLIC ZCursorNew(void)
{
	ZCursorI* pCursor = new ZCursorI;
	pCursor->nType = zTypeCursor;
	return (ZCursor)pCursor;
}

ZError ZLIBPUBLIC ZCursorInit(ZCursor cursor, uchar* image, uchar* mask,
		ZPoint hotSpot)
{
	ZCursorI* pCursor = (ZCursorI*)cursor;
//	TRACE0("ZCursorInit: Not implemented yet...");
	return zErrNone;
}

void ZLIBPUBLIC ZCursorDelete(ZCursor cursor)
{
	ZCursorI* pCursor = (ZCursorI*)cursor;
	DeleteObject(pCursor->hCursor);
	delete pCursor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcommlib.cpp ===
/*******************************************************************************

	ZCommLib.c
	
		Zone(tm) common library system routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Tuesday, July 11, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	3		11/21/96	HI		Calls InitializeStockObjects() and
								DeleteStockObjects() to initialize and delete
								stock objects (fonts).
	2		11/15/96	HI		More changes related to ZONECLI_DLL.
	1		11/08/96	HI		Conditionalized for ZONECLI_DLL.
	0		07/11/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zoneint.h"
#include "zonecli.h"


#define zPeriodicTime