
                    _WildCardExpansionFailed = TRUE;
                    _LexemeThatFailed.Initialize( pwcArg );

                } else {

                    //
                    //  Now that we have done the wildcard expansion, extract
                    //  all the paths and put them in our array
                    //
                    while ( Node = (PFSNODE)Iterator->GetNext() ) {

                        Path = NULL;

                        DELETE( TmpName );

                        if ( (Path = NEW PATH)                                          &&
                             Path->Initialize( PATH_ARGUMENT::_Path )                   &&
                             Path->TruncateBase()                                       &&
                             (TmpName = ((PPATH) Node->GetPath())->QueryName())                   &&
                             Path->AppendBase( TmpName )                                &&
                             _PathArray->Put( Path )
                           ) {

                            DELETE( TmpName );

                            _PathCount++;

                        } else {

                            DELETE( Path );
                            Ok = FALSE;
                            break;

                        }
                    }
                }

                DELETE( TmpName  );
                DELETE( FullPath );
                DELETE( Directory );
                DELETE( Iterator );
                if ( NodeArray ) {
                    NodeArray->DeleteAllMembers();
                }
                DELETE( NodeArray );
                DELETE( FullPath );
            }


        } else {

                        if (_PathArray->Put(PATH_ARGUMENT::_Path)) {

                                _PathCount++;

                Ok = TRUE;

                        }
        }

        //
        //  We reset the _fValueSet flag, because we can
        //  always take another path.
        //
        ARGUMENT::_fValueSet = FALSE;
    }

    return Ok;
}


#endif //   _AUTOCHECK_



//
//      Macro for handling case-sensitivity
//
#define CASESENS(c)     ( CaseSensitive ? (c) : towupper((c)) )

STATIC
BOOLEAN
Match(
        OUT PARGUMENT                   Argument,
        OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
        IN      BOOLEAN                         CaseSensitive
        )
/*++

Routine Description:

    Tries to match a pattern, and if there is a match it
        sets the value of the corresponding argument.

Arguments:

        Argument                        -       Supplies pointer to argument
        ArgumentLexemizer       -       Supplies pointer to lexed string list
        CaseSensitive           -       Supplies case sensitivity flag

Return Value:

    TRUE  - argument recognized and value set.
    FALSE - argument not recognized and/or value not set.

--*/
{

    BOOLEAN         fFound;
        CHNUM                   chnCurrent = 0;
        CHNUM                   chnEnd = 0;
        PWSTRING                Lexeme;
        PWSTRING                Pattern;
        CHNUM                   chn;


        if (!(Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount()))) {
                return FALSE;
        }

        Pattern = Argument->GetPattern();

        fFound = FALSE;

        //
        //      If first character in the pattern is a switch, see if the
        //      first character in the Lexeme is also a switch.
        //
        if ( Pattern->QueryChCount() > 0 &&
                 Lexeme->QueryChCount() > 0 &&
                 ArgumentLexemizer->GetSwitches()->Strchr( Pattern->QueryChAt(0)) != INVALID_CHNUM ) {

                if ( ArgumentLexemizer->GetSwitches()->Strchr( Lexeme->QueryChAt(0)) != INVALID_CHNUM ) {
                        //
                        //      Switch, advance pointer
                        //
                        chn = 1;

                } else {
                        //
                        //      No switch, no match
                        //
                        return FALSE;
                }

        } else {
                //
                //      This is not a switch pattern, match from the beginning
                //
                chn = 0;
        }

        for ( ; ; chn++ ) {

                switch( Pattern->QueryChAt( chn ) ) {

                case (WCHAR)'#':

                        //
                        //  Optional space between flag and argument
                        //
                        if ( Lexeme->QueryChAt( chn ) == INVALID_CHAR ) {

                                //
                                // At the end of the Argument string.  Must get the next.
                                //
                                ArgumentLexemizer->IncrementConsumedCount();
                                Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount() );

                                if (!Lexeme) {
                                        goto FAIL;
                                }

                                chn = 0;

                        }

                        chnCurrent = chn;
                        chnEnd     = Lexeme->QueryChCount();
                        fFound     = TRUE;
                        break;


                case (WCHAR)'*':

                        //
                        //  No space allowed between flag and argument
                        //
                        if ( !(Lexeme->QueryChAt( chn )) ||
                                 !(TailMatch( Pattern, Lexeme, chn, &chnEnd, CaseSensitive ))) {

                                goto FAIL;
                        }

                        chnCurrent = chn;
                        fFound     = TRUE;
                        break;


                case INVALID_CHAR:

                        //
                        //  Space required beteen flag and argument
                        //
                        if( Lexeme->QueryChAt( chn ) != INVALID_CHAR) {
                                goto FAIL;

                        }

                        Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount() );
                        ArgumentLexemizer->IncrementConsumedCount();
                        fFound = TRUE;
                        chnEnd++;
                        break;



                default:

                        if ( CASESENS(Lexeme->QueryChAt( chn )) != CASESENS(Pattern->QueryChAt( chn )) ) {
                                goto FAIL;
                        }
                        chnEnd++;
                }

                if (fFound) {
                        break;
                }

        }

        //
        // The patterns matched, see if the argument is recognized.
        //
        if (Argument->SetValue( Lexeme, chnCurrent, chnEnd, ArgumentLexemizer ) == FALSE ) {
                goto FAIL;
        }

        //DELETE( Lexeme );

        return TRUE;

FAIL:
        //DELETE( Lexeme );
        return FALSE;
}


STATIC
BOOLEAN
TailMatch(
    IN  PWSTRING Pattern,
    IN  PWSTRING String,
        IN      CHNUM                   chn,
        OUT PCHNUM                      chnEnd,
        IN      BOOLEAN                 CaseSensitive
        )
/*++

Routine Description:

    Performs tailmatching of a pattern and a string

Arguments:

        Pattern                 -       Supplies pointer to pattern
        String                  -       Supplies pointer to string
        chn                     -       Supplies index of current char
        chnEnd                  -       Supplies pointer to index of first character to
                                                match in tail;
        CaseSensitive   -       Supplies case sensitivity flag

Return Value:

    TRUE  if match
    FALSE otherwise

--*/
{
    CHNUM PatternIndex;
    CHNUM StringIndex;

        PatternIndex = Pattern->QueryChCount() - 1;
        StringIndex  = String->QueryChCount() - 1;


    if (chn == PatternIndex) {

        //
        // wild card is the last thing in the format, it matches.
        //
                *chnEnd = StringIndex + 1 ;
                return TRUE;
    }

    //
    //  Check characters walking towards front
    //
        while( CASESENS(Pattern->QueryChAt(PatternIndex)) == CASESENS(String->QueryChAt(StringIndex)) ) {

        if ( chn == PatternIndex ) {
            break;
        }

        PatternIndex--;
        StringIndex--;

    }

    //
    // If we're back at the beginning of the Pattern and the string is
    // either at the beginning or somewhere inside then we have a match.
        //
        *chnEnd = StringIndex + 1;

        return( (PatternIndex == chn ) && ( StringIndex != INVALID_CHNUM ) );
}


#if !defined( _AUTOCHECK_ )


DEFINE_EXPORTED_CONSTRUCTOR( REST_OF_LINE_ARGUMENT, ARGUMENT, ULIB_EXPORT );

ULIB_EXPORT
BOOLEAN
REST_OF_LINE_ARGUMENT::Initialize(
    )
{
    return ARGUMENT::Initialize("*");
}

BOOLEAN
REST_OF_LINE_ARGUMENT::SetIfMatch(
    IN OUT  PARGUMENT_LEXEMIZER    ArgumentLexemizer,
    IN      BOOLEAN                CaseSensitive
    )
/*++

Routine Description:

    This routine computes whether or not the current state of the argument lexemizer
    lends itself to a MACRO argument as described by DOS 5's DOSKEY function.  If the
    current state of the argument lexemizer is indeed in such a state then this routine
    will grab all of the remaining tokens on the line and copy the contents of the
    command line from the current token to the end of the line in this class's argument.

Arguments:

    ArgumentLexemizer   - Supplies the argument lexemizer.
    CaseSensitive       - Supplies whether or not to distinguish letters based solely on case.

Return Value:

    FALSE   - argument not recognized and/or value not set.
    TRUE    - argument recognized and value set.

--*/
{
    CHNUM   char_pos;
    ULONG   consumed_count;

    consumed_count = ArgumentLexemizer->QueryConsumedCount();
    char_pos = ArgumentLexemizer->QueryCharPos(consumed_count);

    if (!_RestOfLine.Initialize(ArgumentLexemizer->GetCmdLine(), char_pos)) {
        _fValueSet = FALSE;
        return FALSE;
    }


    // Consume all of the remaining tokens.

    ArgumentLexemizer->IncrementConsumedCount(
            ArgumentLexemizer->QueryLexemeCount() - consumed_count);

    _fValueSet = TRUE;

    return TRUE;
}


#endif // _AUTOCHECK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\memtrace\memtrace.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	memtrace.h

Abstract:

	This function contains an extension to NTSD that allows tracing of
	memory usage when ULIB objects are compiled with the MEMLEAK flag
	defined.

Author:

	Barry Gilhuly (W-Barry) 25-July-91

Revision History:

--*/

//
// The following was ripped off from ULIBDEF.HXX and NEWDELP.HXX
//
#define CONST		const
typedef ULONG		MEM_BLOCKSIG;

//
// MEM_BLOCK header signature type and value.
//
CONST MEM_BLOCKSIG		Signature		= 0xDEADDEAD;

//
// Maximum length of caller's file name.
//

#define	MaxFileLength	20

//
// Maximum size of call stack recorded.
//

#define	MaxCallStack	20

//
// MEM_BLOCK is the header attached to all allocated memory blocks.
// Do not change the order of these fields without fixing the initialization
// of the dummy MEM_BLOCK in newdel.cxx.
//

typedef struct _MEM_BLOCK {
	struct _MEM_BLOCK*		pmemNext;
	struct _MEM_BLOCK*		pmemPrev;
	MEM_BLOCKSIG			memsig;
	ULONG					line;
	ULONG					size;
	char					file[ MaxFileLength ];
	DWORD					call[ MaxCallStack ];
} MEM_BLOCK, *PMEM_BLOCK;

//
// File handle for data destination...
//
HANDLE		hFile;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\array.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        array.cxx

Abstract:

        This module contains the definition for the ARRAY class. ARRAY is a
        concrete implementation of a SORTABLE_CONTAINER. It extends the interface
        to allow for easy access uswing a simple ULONG as an index. It is
        dynamically growable and supports bases other than zero.

Author:

        David J. Gilman (davegi) 02-Nov-1990

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( ARRAY, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( ARRAY );

VOID
ARRAY::Construct (
        )

/*++

Routine Description:

        Construct an ARRAY by setting the initial value of of the OBJECT array
        pointer to NULL.

Arguments:

        None.

Return Value:

        None.

--*/

{
        _ObjectArray    = NULL;
}





ULIB_EXPORT
ARRAY::~ARRAY (
        )

/*++

Routine Description:

        Destroy an ARRAY by freeing it's internal storage. Note that this
    deletes the array, not the objects themselves.

Arguments:

        None.

Return Value:

        None.

--*/

{
        if ( _ObjectArray ) {
                FREE( _ObjectArray );
        }
}



ULIB_EXPORT
BOOLEAN
ARRAY::Initialize (
        IN ULONG        Capacity,
        IN ULONG        CapacityIncrement
        )

/*++

Routine Description:

        Initialize an ARRAY object by setting it's internal state to supplied
        or default values. In addition allocate an initial chunk of memory for
        the actual storage of POBJECTs.

Arguments:

        Capacity                        - Supplies the total number of OBJECTs the ARRAY
                                                  can contain
        CapacityIncrement       - Supplies the number of OBJECTs to make room for
                                                  when growing the ARRAY

Return Value:

        BOOLEAN - TRUE if the ARRAY is successfully initialized.

--*/

{
        DebugAssert( Capacity != 0 );

    //
    //  If re-initializing, se reuse the current array
    //
    if ( _ObjectArray ) {
        _Capacity = SetArrayCapacity( Capacity );
    } else {
        _ObjectArray = (PPOBJECT)CALLOC( (UINT)Capacity,
                                         sizeof( POBJECT ) );
        _Capacity    = Capacity;
    }

        _CapacityIncrement      = CapacityIncrement;
    _PutIndex           = 0;

#if DBG==1
    _IteratorCount      = 0;
#endif

    if ( _ObjectArray ) {
        DebugCheckHeap();
        return TRUE;
    } else {
        return FALSE;
    }
}

ULIB_EXPORT
BOOLEAN
ARRAY::DeleteAllMembers (
        )

/*++

Routine Description:

    Deletes all the members of the array

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    PPOBJECT    PObject;

    if ( _PutIndex > 0 ) {

#if 0   // Bogus assert due to compiler error.  Put it back in when compiler fixed
#if DBG==1
        DebugAssert( _IteratorCount == 0 );
#endif
#endif

        PObject = &_ObjectArray[ _PutIndex - 1 ];

        while ( PObject >= _ObjectArray ) {
            DELETE( *PObject );
            PObject--;
        }

        _PutIndex = 0;
    }

    return TRUE;
}




POBJECT
ARRAY::GetAt (
        IN ULONG                Index
        ) CONST

/*++

Routine Description:

        Retrieves the OBJECT at the specified Index.

Arguments:

        Index - Supplies the index of the OBJECT in question.

Return Value:

        POBJECT - A constant pointer to the requested OBJECT.

--*/

{
        DebugPtrAssert( _ObjectArray );

    if ( (_PutIndex > 0) && (Index < _PutIndex) ) {
        return _ObjectArray[ Index ];
    } else {
        return NULL;
    }
}



ULONG
ARRAY::GetMemberIndex (
    IN POBJECT      Object
    ) CONST

/*++

Routine Description:

    Returns the position (index) of an object in the array.

Arguments:

    POBJECT - Pointer to the OBJECT in question.

Return Value:

    ULONG - The position of the OBJECT in the array. If the OBJECT is not
            in the array, returns INVALID_INDEX.

--*/

{
    ULONG   Index;

    DebugPtrAssert( _ObjectArray );
    DebugPtrAssert( Object );

    if( Object == NULL ) {
        return( INVALID_INDEX );
    }

    Index = 0;
    while( ( Index < QueryMemberCount() ) &&
           ( _ObjectArray[ Index ] != Object ) ) {
        Index++;
    }
    return( ( Index < QueryMemberCount() )? Index : INVALID_INDEX );
}



ULIB_EXPORT
BOOLEAN
ARRAY::Put (
        IN OUT  POBJECT Member
        )

/*++

Routine Description:

        Puts an OBJECT at the next available location in the array.

Arguments:

        Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( _PutIndex <= _Capacity );

    //
    //  Grow the array if necessary
    //
    if ( _PutIndex >= _Capacity ) {
        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //

            return FALSE;
        }
    }

    _ObjectArray[ _PutIndex++ ] = Member;

    return TRUE;

}



BOOLEAN
ARRAY::PutAt (
        IN OUT  POBJECT Member,
    IN      ULONG   Index
        )

/*++

Routine Description:

    Puts an OBJECT at a particular location in the ARRAY.
    The new object has to replace an existing object, i.e. the
    index has to be smaller than the member count.

Arguments:

        Member  - Supplies the OBJECT to place in the ARRAY
    Index   - Supplies the index where the member is to be put

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index < _PutIndex );

    if ( Index < _PutIndex ) {
        _ObjectArray[ Index ] = Member;
        return TRUE;
    }

    return FALSE;
}


ULIB_EXPORT
PITERATOR
ARRAY::QueryIterator (
        ) CONST

/*++

Routine Description:

        Create an ARRAY_ITERATOR object for this ARRAY.

Arguments:

        None.

Return Value:

        PITERATOR - Pointer to an ITERATOR object.

--*/

{
    PARRAY_ITERATOR   Iterator;

    //
    //  Create new iterator
    //
    if ( Iterator = NEW ARRAY_ITERATOR ) {

        //
        //  Initialize the iterator
        //
        if ( !Iterator->Initialize( (PARRAY)this ) ) {
            DELETE( Iterator );
        }
    }

    return Iterator;
}



ULONG
ARRAY::QueryMemberCount (
        ) CONST

/*++

Routine Description:

    Obtains the number of elements in the array

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the array


--*/

{
    return _PutIndex;
}


ULIB_EXPORT
POBJECT
ARRAY::Remove (
        IN OUT  PITERATOR   Position
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    PARRAY_ITERATOR Iterator;

    DebugPtrAssert( Position );
    DebugPtrAssert( ARRAY_ITERATOR::Cast( Position ));

    Iterator = (PARRAY_ITERATOR)Position;

    return RemoveAt( Iterator->QueryCurrentIndex() );
}


POBJECT
ARRAY::RemoveAt (
    IN  ULONG   Index
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Index   -   Supplies the index of the member to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    POBJECT    Object = NULL;

    if ( Index < _PutIndex ) {

        // DebugAssert( _IteratorCount <= 1 );

        //
        //  Get the object
        //
        Object = (POBJECT)_ObjectArray[ Index ];

        //
        //  Shift the rest of the array
        //
        memmove ( &_ObjectArray[ Index ],
                  &_ObjectArray[ Index + 1 ],
                  (UINT)(_PutIndex - Index - 1) * sizeof( POBJECT ) );

       //
       //   Update the _PutIndex
       //
       _PutIndex--;

    }

    return Object;
}



ULONG
ARRAY::SetCapacity (
    IN  ULONG   Capacity
        )

/*++

Routine Description:

    Sets the capacity of the array. Will not shrink the array if the
    capacity indicated is less than the number of members in the array.

Arguments:

    Capacity -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    if ( Capacity >= _PutIndex ) {

        SetArrayCapacity( Capacity );

    }

    return _Capacity;
}


BOOLEAN
ARRAY::Sort (
    IN  BOOLEAN Ascending
        )

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
        int (__cdecl *CompareFunction)(const void *, const void*);

        CompareFunction = Ascending ?
                      &ARRAY::CompareAscending :
                      &ARRAY::CompareDescending;

        qsort( _ObjectArray,
                  (size_t)_PutIndex,
                  sizeof(POBJECT),
                  CompareFunction );

        return TRUE;
}


BOOLEAN
ARRAY::Insert(
    IN OUT  POBJECT     Member,
    IN      ULONG       Index
    )
/*++

Routine Description:

    Inserts an element in the array at the specified position, shifting
    elements to the right if necessary.

Arguments:

    Member  -   Supplies pointer to object to be inserted in the array

    Index   -   Supplies the index where the element is to be put

Return Value:

    BOOLEAN -   TRUE if new element inserted, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index <= _PutIndex );

    //
    //  Make sure that there will be enough space in the array for the
    //  new element
    //
    if ( _PutIndex >= _Capacity ) {

        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //
            return FALSE;
        }
    }

    //
    //  If required, shift the array to the right to make space for the
    //  new element.
    //
    if ( Index < _PutIndex ) {

        memmove ( &_ObjectArray[ Index + 1 ],
                  &_ObjectArray[ Index ],
                  (UINT)( _PutIndex - Index ) * sizeof( POBJECT ) );
    }

    //
    //  Insert the element
    //
    _ObjectArray[ Index ] = Member;

    //
    //  Increment the number of elements in the array
    //
    _PutIndex++;

    return TRUE;
}



ULONG
ARRAY::SetArrayCapacity (
    IN  ULONG   NumberOfElements
        )

/*++

Routine Description:

    Sets the capacity of the array. Allways reallocs the array.

Arguments:

    NewSize -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    PPOBJECT   Tmp;

    Tmp = (PPOBJECT)REALLOC( _ObjectArray,
                             (UINT)NumberOfElements * sizeof(POBJECT) );

    if ( Tmp ) {
        _ObjectArray = Tmp;
        _Capacity    = NumberOfElements;
    }

    return _Capacity;
}


int __cdecl
ARRAY::CompareAscending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects.

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                    <0  if Object1 is less that    Object2
                         0      if Object1 is equal to     Object2
                        >0      if Object1 is greater than Object2


--*/

{
    return  (*(POBJECT *)Object1)->Compare( *(POBJECT *)Object2 );
}



int __cdecl
ARRAY::CompareDescending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                        <0      if Object2 is less that    Object1
                         0      if Object2 is equal to     Object1
                        >0      if Object2 is greater than Object1

--*/

{
    return  (*(POBJECT *)Object2)->Compare( *(POBJECT *)Object1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\arrayit.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	arrayit.cxx

Abstract:

	This file contains the definitions for the ARRAY_ITERATOR class. 
	ARRAY_ITERATOR is a concrete implementation of the abstract ITERATOR
	class.

Author:

	David J. Gilman (davegi) 03-Dec-1990

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( ARRAY_ITERATOR );

DEFINE_CONSTRUCTOR( ARRAY_ITERATOR, ITERATOR );


VOID
ARRAY_ITERATOR::Construct (
	)

/*++

Routine Description:

	Construct an ARRAY_ITERATOR by setting it's current index to 0 and it's
	associated ARRAY to NULL.

Arguments:

	None.

Return Value:

	None.

--*/

{
	_Array = NULL;
}



ARRAY_ITERATOR::~ARRAY_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the ARRAY_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
#endif
}




VOID
ARRAY_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}



POBJECT
ARRAY_ITERATOR::GetCurrent(
	)
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _Array->GetAt( _CurrentIndex );
    }
}




POBJECT
ARRAY_ITERATOR::GetNext(
	)
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _Array->QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}


POBJECT
ARRAY_ITERATOR::GetPrevious(
	)
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _Array->QueryMemberCount() - 1;
    } else {
        _CurrentIndex--;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}




BOOLEAN
ARRAY_ITERATOR::Initialize (
	IN PARRAY	Array
	)

/*++

Routine Description:

	Associate an ARRAY with this ARRAY_ITERATOR and reset the current index

Arguments:

    Array   -   Supplies pointer to the array object

Return Value:

	BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
	DebugPtrAssert( Array );

#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
    Array->_IteratorCount++;
#endif
    _Array          = Array;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\achkmsg.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    achkmsg.ccxx

Abstract:

    This is the message class for autochk.

Author:

    Norbert P. Kusters (norbertk) 3-Jun-91

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "achkmsg.hxx"
#include "basesys.hxx"
#include "rtmsg.h"

extern "C" {
#include <ntddkbd.h>
#include <stdio.h>
}

DEFINE_CONSTRUCTOR(AUTOCHECK_MESSAGE, MESSAGE);

#define KEYBOARD_DEVICE_OBJECT_INCREMENTS   5
#define KEYBOARD_READ_BUFFER_SIZE           (3*sizeof(ULONG)/sizeof(UCHAR))

AUTOCHECK_MESSAGE::~AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
AUTOCHECK_MESSAGE::Initialize(
    IN BOOLEAN  DotsOnly
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - Autochk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _dots_only = DotsOnly;
    return MESSAGE::Initialize();
}


BOOLEAN
AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;
    UNICODE_STRING  unicode_string;
    PWSTR           dis_str;
    UNICODE_STRING  uDot;

    RtlInitUnicodeString(&uDot, L".");

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

   if (!(dis_str = display_string.QueryWSTR())) {
        return FALSE;
    }

    unicode_string.Length = (USHORT)display_string.QueryChCount()*sizeof(WCHAR);
    unicode_string.MaximumLength = unicode_string.Length;
    unicode_string.Buffer = dis_str;

    if (!_dots_only && MSG_HIDDEN_STATUS != GetMessageId()) {
        NtDisplayString(&unicode_string);
    }

    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    // If we're printing dots only, we print a dot for each interesting
    // message.  The interesting messages are those that aren't suppressed
    // except VOLUME_CLEAN and FILE_SYSTEM_TYPE, which we want to print a
    // dot for regardless.

    if (_dots_only && (!IsSuppressedMessage() ||
                       MSG_CHK_VOLUME_CLEAN == GetMessageId() ||
                       MSG_FILE_SYSTEM_TYPE == GetMessageId())) {
        NtDisplayString(&uDot);
    }

    // Send the output to the debug port, too.
    //
    if (MSG_HIDDEN_STATUS != GetMessageId() &&
        display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {

        DebugPrint( buffer );
    }

    DELETE(dis_str);

    return TRUE;
}

BOOLEAN
AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    PWSTR           dis_str;
    UNICODE_STRING  unicode_string;
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    if (!(dis_str = string.QueryWSTR())) {
        return Default;
    }

    unicode_string.Length = (USHORT)string.QueryChCount()*sizeof(WCHAR);
    unicode_string.MaximumLength = unicode_string.Length;
    unicode_string.Buffer = dis_str;

    NtDisplayString(&unicode_string);

    if (!IsSuppressedMessage()) {
        LogMessage(&string);
    }

    DELETE(dis_str);

    return Default;
}


PMESSAGE
AUTOCHECK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PAUTOCHECK_MESSAGE  p;

    if (!(p = NEW AUTOCHECK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize()) {
        DELETE(p);
        return NULL;
    }

    return p;
}

BOOLEAN
AUTOCHECK_MESSAGE::SetDotsOnly(
    IN  BOOLEAN         DotsOnlyState
    )
/*++

Routine Description:

    This routine modifies the output mode, changing whether full
    output is printed, or just dots.

Arguments:

    DotsOnlyState   - TRUE if only dots should be printed.

Return Value:

    The previous state.

--*/
{
    BOOLEAN b;

    b = _dots_only;

    _dots_only = DotsOnlyState;

    if (b && !_dots_only) {
        //
        // Going from dots-only to full output, want to reset to the
        // beginning of the next output line.
        //

        DisplayMsg(MSG_BLANK_LINE);
    }
    return b;
}

BOOLEAN
AUTOCHECK_MESSAGE::IsInAutoChk(
    )
/*++

Routine Description:

    This routine returns TRUE if it is in the regular autochk and not related
    to setup.  This relys on setup using the /s or /t option all the time.

Arguments:

    None.

Return Value:

    TRUE    - if in regular autochk

--*/
{
    return TRUE;
}

VOID
STATIC
CloseNHandles(
    IN     ULONG    Count,
    IN     PHANDLE  Handles
    )
{
    if (Handles == NULL)
        return;

    while (Count > 0) {
        NtClose(Handles[--Count]);
    }
}

BOOLEAN
AUTOCHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
    )
/*++

Routine Description:

    Check to see if the user has hit any key within the timeout period.

Arguments:

    MsgId            - Supplies the message Id to be displayed
    TimeOutInSeconds - Supplies the count down time in seconds

Return Value:

    TRUE    - A key is pressed within the timeout period.
    FALSE   - No key has been pressed or there is an error

--*/
{
    PHANDLE             e = NULL;
    PHANDLE             h = NULL;
    PIO_STATUS_BLOCK    Iosb = NULL;
    PUCHAR              buf = NULL;
    PHANDLE             e1;
    PHANDLE             h1;
    PIO_STATUS_BLOCK    Iosb1;
    ULONG               i, j;
    NTSTATUS            status;
    LARGE_INTEGER       one_second;
    LARGE_INTEGER       dummy;
    ULONG               timeRemaining;
    BOOLEAN             keyPressed = FALSE;
    BOOLEAN             logging_state;
    WCHAR               dev_name[MAX_PATH];
    BOOLEAN             error = FALSE;

    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   ObjAttr;

#if !defined(RUN_ON_NT4)
    EXECUTION_STATE     prev_state, dummy_state;
    NTSTATUS            es_status;
#endif

    dummy.QuadPart = 0;

    for (i=0; i<100; i++) {

        if ((i % KEYBOARD_DEVICE_OBJECT_INCREMENTS) == 0) {

            // allocate additional elements each time

            if (i == 0) {

                // first time

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: IsKeyPressed: Allocating memory the first time\n"));

                h1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                e1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(IO_STATUS_BLOCK));

            } else {

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: IsKeyPressed: Allocating additional memory\n"));

                h1 = (PHANDLE)REALLOC(h, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                e1 = (PHANDLE)REALLOC(e, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)REALLOC(Iosb, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(IO_STATUS_BLOCK));
            }

            if (h1 == NULL || Iosb1 == NULL || e1 == NULL) {
                DebugPrintTrace(("ULIB: IsKeyPressed: Out of memory\n"));
                error = TRUE;

				// Free any allocation that may have succeeded

			    FREE(h1);
			    FREE(e1);
			    FREE(Iosb1);

                break;
            }

            memset(&(h1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(e1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(Iosb1[i]), 0, sizeof(IO_STATUS_BLOCK)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);

            h = h1;
            e = e1;
            Iosb = Iosb1;
        }

        swprintf(dev_name, DD_KEYBOARD_DEVICE_NAME_U L"%d", i);
        RtlInitUnicodeString(&u, dev_name);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Opening device %ls\n", dev_name));

        InitializeObjectAttributes(&ObjAttr,
                                   &u,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Initializing handle %d\n", i));

        status = NtCreateFile(&h[i],
                              GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                              &ObjAttr,
                              &Iosb[i],
                              NULL,                                 /* AllocationSize */
                              FILE_ATTRIBUTE_NORMAL,                /* FileAttributes */
                              0,                                    /* ShareAccess */
                              FILE_OPEN,                            /* CreateDisposition */
                              // the directory bit is to tell the keyboard driver to let
                              // this user mode process to open the keyboard
                              FILE_DIRECTORY_FILE,                  /* CreateOptions */
                              NULL,                                 /* EaBuffer */
                              0);                                   /* EaLength */

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
                break;  // found all keyboards and exit this loop

            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to open keyboard device %d (%x)\n", i, status));
            h[i] = NULL;
            error = TRUE;
            break;
        }

        InitializeObjectAttributes(&ObjAttr,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Initializing event %d\n", i));

        status = NtCreateEvent(&e[i],
                               FILE_ALL_ACCESS,
                               &ObjAttr,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to create event %d (%x)\n", i, status));
            error = TRUE;
            e[i] = NULL;
            break;
        }
    }

    if (!error) {
        buf = (PUCHAR)CALLOC(i, KEYBOARD_READ_BUFFER_SIZE);

        if (buf == NULL) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Out of memory\n"));
            error = TRUE;
        }
    }

    if (!error) {

        one_second.QuadPart = -10000000;

        timeRemaining = TimeOutInSeconds;

        logging_state = IsLoggingEnabled();
        SetLoggingEnabled(FALSE);

#if !defined(RUN_ON_NT4)
        es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                              ES_DISPLAY_REQUIRED|
                                              ES_SYSTEM_REQUIRED,
                                              &prev_state);
        if (!NT_SUCCESS(es_status)) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to set thread execution state (%x)\n", es_status));
        }
#endif

        DisplayMsg(MsgId, "%d", timeRemaining);

        for (j=0; j<i; j++) {
            status = NtReadFile(h[j], e[j], NULL, NULL,
                                &(Iosb[j]), &(buf[j]), KEYBOARD_READ_BUFFER_SIZE,
                                &dummy, NULL);

            if (!NT_SUCCESS(status)) {
                DebugPrintTrace(("\nULIB: IsKeyPressed: Read failure from keyboard %d (%x)\n", j, status));
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            do {
                status = NtWaitForMultipleObjects(i, e, WaitAny, TRUE, &one_second);

                if (status == STATUS_TIMEOUT) {

                    timeRemaining--;
                    DisplayMsg(MsgId, "%d", timeRemaining);

                } else if (NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                               "ULIB: IsKeyPressed: NtWaitForMultipleObjects index %d\n", status));

                    DebugAssert(status < i);

                    if (Iosb[status].Information) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                                   "\nULIB: IsKeyPressed: KeyPressed\n"));
                        keyPressed = TRUE;
                        break;
                    }

                } else {
                    DebugPrintTrace(("ULIB: IsKeyPressed: unknown status %x\n", status));
                    break;
                }
            } while (timeRemaining != 0);
        }

#if !defined(RUN_ON_NT4)
        if (NT_SUCCESS(es_status)) {

            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                       "ULIB: IsKeyPressed: Restoring power management status\n"));

            es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("ULIB: IsKeyPressed: Unable to reset thread execution state (%x)\n", es_status));
            }
        }
#endif

        SetLoggingEnabled(logging_state);

    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "\nULIB: IsKeyPressed: Cleaning up\n"));

    CloseNHandles(i, h);
    CloseNHandles(i, e);
    FREE(h);
    FREE(e);
    FREE(Iosb);
    FREE(buf);

    return keyPressed;
}

BOOLEAN
AUTOCHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    Open the keyboard directly and wait to read something.

Arguments:

    None:

Return Value:

    TRUE    - Something was successfully read.
    FALSE   - An error occured while attempting to open or read.

--*/
{
    PHANDLE             e = NULL;
    PHANDLE             h = NULL;
    PIO_STATUS_BLOCK    Iosb = NULL;
    PUCHAR              buf = NULL;
    PHANDLE             e1;
    PHANDLE             h1;
    PIO_STATUS_BLOCK    Iosb1;
    ULONG               i, j;
    NTSTATUS            status;
    LARGE_INTEGER       dummy;
    WCHAR               dev_name[MAX_PATH];
    BOOLEAN             error = FALSE;

    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   ObjAttr;

    dummy.QuadPart = 0;

    for (i=0; i<100; i++) {

        if ((i % KEYBOARD_DEVICE_OBJECT_INCREMENTS) == 0) {

            // allocate additional elements each time

            if (i == 0) {

                // first time

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: WaitForUserSignal: Allocating memory the first time\n"));

                h1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                e1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(IO_STATUS_BLOCK));

            } else {

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: WaitForUserSignal: Allocating additional memory\n"));

                h1 = (PHANDLE)REALLOC(h, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                e1 = (PHANDLE)REALLOC(e, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)REALLOC(Iosb, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(IO_STATUS_BLOCK));
            }

            if (h1 == NULL || Iosb1 == NULL || e1 == NULL) {
                DebugPrintTrace(("ULIB: WaitForUserSignal: Out of memory\n"));
                error = TRUE;
                break;
            }

            memset(&(h1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(e1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(Iosb1[i]), 0, sizeof(IO_STATUS_BLOCK)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);

            h = h1;
            e = e1;
            Iosb = Iosb1;
        }

        swprintf(dev_name, DD_KEYBOARD_DEVICE_NAME_U L"%d", i);
        RtlInitUnicodeString(&u, dev_name);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Opening device %ls\n", dev_name));

        InitializeObjectAttributes(&ObjAttr,
                                   &u,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Initializing handle %d\n", i));

        status = NtCreateFile(&h[i],
                              GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                              &ObjAttr,
                              &Iosb[i],
                              NULL,                                 /* AllocationSize */
                              FILE_ATTRIBUTE_NORMAL,                /* FileAttributes */
                              0,                                    /* ShareAccess */
                              FILE_OPEN,                            /* CreateDisposition */
                              // the directory bit is to tell the keyboard driver to let
                              // this user mode process to open the keyboard
                              FILE_DIRECTORY_FILE,                  /* CreateOptions */
                              NULL,                                 /* EaBuffer */
                              0);                                   /* EaLength */

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
                break;  // found all keyboards and exit this loop

            DebugPrintTrace(("ULIB: WaitForUserSignal: Unable to open keyboard device %d (%x)\n", i, status));
            h[i] = NULL;
            error = TRUE;
            break;
        }

        InitializeObjectAttributes(&ObjAttr,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Initializing event %d\n", i));

        status = NtCreateEvent(&e[i],
                               FILE_ALL_ACCESS,
                               &ObjAttr,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("ULIB: WaitForUserSignal: Unable to create event %d (%x)\n", i, status));
            error = TRUE;
            e[i] = NULL;
            break;
        }
    }

    if (!error) {
        buf = (PUCHAR)CALLOC(i, KEYBOARD_READ_BUFFER_SIZE);

        if (buf == NULL) {
            DebugPrintTrace(("ULIB: WaitForUserSignal: Out of memory\n"));
            error = TRUE;
        }
    }

    if (!error) {

        for (j=0; j<i; j++) {
            status = NtReadFile(h[j], e[j], NULL, NULL,
                                &(Iosb[j]), &(buf[j]), KEYBOARD_READ_BUFFER_SIZE,
                                &dummy, NULL);

            if (!NT_SUCCESS(status)) {
                DebugPrintTrace(("\nULIB: WaitForUserSignal: Read failure from keyboard %d (%x)\n", j, status));
                error = TRUE;
                break;
            }
        }

        if (NT_SUCCESS(status)) {

            status = NtWaitForMultipleObjects(i, e, WaitAny, TRUE, NULL);
            error = !NT_SUCCESS(status);

        }
    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "\nULIB: WaitForUserSignal: Cleaning up\n"));

    CloseNHandles(i, h);
    CloseNHandles(i, e);
    FREE(h);
    FREE(e);
    FREE(Iosb);
    FREE(buf);

    return !error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\bitvect.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	bitvect.cxx

Abstract:

	This module contains the definition for thje BITVECTOR class.

Author:

	David J. Gilman (davegi) 01-Feb-1991
	Barry Gilhuly (w-barry)
	Norbert P. Kusters (norbertk)

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include    "ulib.hxx"
#include    "bitvect.hxx"
#include    <limits.h>

//
// Invalid bit count
//

CONST PT	InvalidBitCount = (PT)(-1);

//
// Static member data.
//

//
// Bits per byte value table e.g. 27->4 bits
//
// Algorithm:
//
//	_BitsSetLookUp[0] = 0;
//
// 		For the ranges [1,1],[2,3],[4,7],[8,15],...,[128,255].
//
//		for (n = (( PT ) 1 ); n <= 8; n++) {
//
//
//			Compute range for loop.
//
//			r = (( PT ) 1 ) << (n - (( PT ) 1 ));
//
//
// 			[r, 2*r - 1 ] = [0, r - 1] + 1;
//
//			for (i = 0; i < r; i++) {
//				_BitsSetLookUp[i + r] = _BitsSetLookUp[i] + (( PT ) 1 );
//			}
//		}
//    }
//

CONST BYTE	BITVECTOR::_BitsSetLookUp[ 256 ] = {

	0, 1, 1, 2, 1, 2, 2, 3,
	1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7,
	5, 6, 6, 7, 6, 7, 7, 8
};


DEFINE_EXPORTED_CONSTRUCTOR( BITVECTOR, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( BITVECTOR );

VOID
BITVECTOR::Construct (
	)

/*++

Routine Description:

	Construct a BITVECTOR.

Arguments:

	None.

Return Value:

	None.

--*/

{
	REGISTER PT	pt;

	//
	//  Find the number of bits per PTs
	//

	_BitsPerPT	 = sizeof( PT ) * CHAR_BIT;

	//
	// Set the smallest number of PTs needed
	//

	_PTCount	 = (( PT ) 1 );

	//
	//  Create the mask used to separate the array index from the bit index
	//

	_BitPositionMask = _BitsPerPT - (( PT ) 1 );

	//
	//  Count the number of bits required to make the shift count for
	//  accessing the Primitive Type.
	//

	for( _IndexShiftCount = 0, pt = _BitPositionMask; pt;
	pt >>= (( PT ) 1 ), _IndexShiftCount++ );

	//
	// Initialize BITVECTOR state.
	//

	_BitVector		= NULL;
	_PTCount		= 0;
	_FreeBitVector	= FALSE;
}

ULIB_EXPORT
BOOLEAN
BITVECTOR::Initialize (
	IN PT	Size,
	IN BIT	InitialValue,
	IN PPT 	Memory
	)

/*++

Routine Description:

	Construct a BITVECTOR with at least the size specified and
	initialize all bits to SET or RESET.

Arguments:

	Size			- Supplies the number of bits in the vector
	InitialValue	- Supplies the initial value for the bits
	Memory			- Supplies a memory buffer to use for the vector

Return Value:

	BOOLEAN - Returns TRUE if the BITVECTOR was succesfully initialized.

Notes:

	Minimum and default BITVECTOR size is the number of bits in
	one PT.  Default initializer is RESET.	The size of a BITVECTOR
	is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

	If the client supplies the buffer it is the client's responsibility
	to ensure that Size and the size of the buffer are in sync.
	Also SetSize will not change the size of a client supplied
	buffer.

--*/

{
	//
	// Destroy the internals of a previous BITVECTOR.
	//

	Destroy( );

	//
	//  Find the number of PTs that will be required for this BITVECTOR
	//  (handles smallest size case (Size = 0) ).
	//

	_PTCount	 = Size ? (( Size + _BitsPerPT - (( PT ) 1 )) / _BitsPerPT ) : (( PT ) 1 );

	//
	//  If Memory was supplied use that for the vector else allocate
	// the vector.
	//

	if( Memory ) {

		_BitVector = Memory;

    } else {
		_FreeBitVector = TRUE;
		if( !( _BitVector = ( PT* ) MALLOC(( size_t ) ( _PTCount * sizeof( PT ))))) {

			return FALSE;
		}
    }

	//
	//  Set the bitvector to the supplied value ( SET | RESET )
	//

	( InitialValue == SET ) ? SetAll( ) : ResetAll( );

    return TRUE;
}

ULIB_EXPORT
BITVECTOR::~BITVECTOR (
	)

/*++

Routine Description:

	Destroy a BITVECTOR by calling it's Destroy function.

Arguments:

	None.

Return Value:

	None.

--*/

{
	Destroy( );
}

VOID
BITVECTOR::Destroy (
	)

/*++

Routine Description:

	Destroy a BITVECTOR by possibly freeing it's internal storage.

Arguments:

	None.

Return Value:

	None.

--*/
{
	if( _FreeBitVector ) {

		DebugAssert( _BitVector != NULL );
		FREE( _BitVector );
	}
}

ULIB_EXPORT
PT
BITVECTOR::SetSize (
	IN PT	Size,
	IN BIT	InitialValue
	)

/*++

Routine Description:

	Set the number of bits in the vector

Arguments:

	Size 		- Supplies the number of bits to set the vector size to
	InitialValue- Supplies the initial value for the bits

Return Value:

	PT - Returns the new size of this BITVECTOR in bits.

Notes:

	SetSize will merrily truncate the vector with no warning.

	Minimum and default BITVECTOR size is the number of bits in
	one PT. Default initializer is RESET.  The size of a BITVECTOR
	is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

	If the client supplied the buffer refuse to change it's size

--*/

{
	REGISTER	PT	PTCountNew;
				PT	cbitsNew;
				PT	cbitsOld;

	//
	//  Check that the bitvector was created...
	//

	DebugPtrAssert( _BitVector );
	if( _BitVector == NULL ) {
		return( 0 );
    }

	//
	//	If the client supplied the buffer, refuse to change it's size.
	//

	if( ! _FreeBitVector ) {
		return( _PTCount * _BitsPerPT );
    }


	//
	//  Compute the number of PTs and bits required for the new size
	//

	PTCountNew = Size ? (( Size + _BitsPerPT - (( PT ) 1 ) ) / _BitsPerPT ) : (( PT ) 1 );
	cbitsNew = PTCountNew * _BitsPerPT;

	if( PTCountNew != _PTCount ) {

		//
		//	The new size requires a different number of PTs then the old
		//

		if( !( _BitVector = ( PT* ) REALLOC(( VOID* ) _BitVector,
		( size_t ) ( PTCountNew * sizeof( PT ))))) {

			return( 0 );
		}
    }

	//
	//  If the new size contains more bits, initialize them to the supplied
	//  value
	//

	cbitsOld = _PTCount * _BitsPerPT;
	_PTCount = PTCountNew;

	if( cbitsNew > cbitsOld ) {
		if( InitialValue == SET ) {
			SetBit( cbitsOld, cbitsNew - cbitsOld );
		} else {
			ResetBit( cbitsOld, cbitsNew - cbitsOld );
		}
    }

	return( _PTCount * _BitsPerPT );
}

ULIB_EXPORT
VOID
BITVECTOR::SetBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	SET the supplied range of bits

Arguments:

	Index - Supplies the index at which to start setting bits.
	Count - Supplies the number of bits to set.

Return Value:

    None.

Notes:

	It may be faster to compute masks for setting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0xffffffff;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }
}

ULIB_EXPORT
VOID
BITVECTOR::ResetBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	RESET the supplied range of bits

Arguments:

	Index - Supplies the index at which to start resetting bits.
	Count - Supplies the number of bits to reset.

Return Value:

    None.

Notes:

	It may be faster to compute masks for resetting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }
}

VOID
BITVECTOR::ToggleBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	Toggle the supplied range of bits.

Arguments:

	Index - Supplies the index at which to start toggling bits.
	Count - Supplies the number of bits to toggle.

Return Value:

	None.

--*/

{
	REGISTER	PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert( Index + Count <= _PTCount * _BitsPerPT);

	while( Count-- ) {
		ptCurBit = Index + Count;
		if( IsBitSet( ptCurBit )) {
			ResetBit( ptCurBit );
		} else {
			SetBit( ptCurBit );
		}
	}
}

ULIB_EXPORT
PT
BITVECTOR::ComputeCountSet(
	) CONST

/*++

Routine Description:

	Compute the number of bits that are set in the bitvector using a table
	look up.

Arguments:

	None.

Return Value:

	PT - Returns the number of set bits.

--*/

{
	REGISTER PCBYTE 	pbBV;
	REGISTER PT		 	i;
	REGISTER PT         BitsSet;

	//
	// Cast the bitvector into a string of bytes.
	//

	pbBV = ( PCBYTE ) _BitVector;

	//
	// Initialize the count to zero.
	//

	BitsSet = 0;

	//
	// For all of the bytes in the bitvector.
	//

	for (i = 0; i < _PTCount * sizeof( PT ); i++) {

		//
		// Add the number of bits set in this byte to the total.
		//

		BitsSet += _BitsSetLookUp[pbBV[ i ]];
	}

	return( BitsSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\bstring.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    bstring.cxx

Author:

    Norbert P. Kusters (norbertk) 6-Aug-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "bstring.hxx"

#include <stdio.h>


INLINE
VOID
BSTRING::Construct(
    )
{
    _s = NULL;
    _l = 0;
}



DEFINE_CONSTRUCTOR( BSTRING, OBJECT );


BOOLEAN
BSTRING::Initialize(
    IN  PCSTR   InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (StringLength == TO_END) {
        StringLength = MBSTR::Strlen((PSTR)InitialString);
    }

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    memcpy(_s, InitialString, (UINT) StringLength*sizeof(CHAR));

    return TRUE;
}


VOID
BSTRING::DeleteChAt(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine removes the character at the given position.

Arguments:

    Position    - Supplies the position of the character to remove.
    Length      - Supplies the number of characters to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    memmove(_s + Position, _s + Position + Length,
            (UINT) (_l - Position - Length)*sizeof(CHAR));

    Resize(_l - Length);
}



NONVIRTUAL
BOOLEAN
BSTRING::ReplaceWithChars(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN CHAR         Character,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    AtPosition of AtLength with the string formed by Character
    of FromLength.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    Character       - Supplies the character to replace with.
    FromLength      - Supplies the total number of new characters to replace the old one with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;
    PSTR    currptr, endptr;

    DebugAssert(AtPosition <= _l);

    AtLength = min(AtLength, _l - AtPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    old_length = _l;

    if (!Resize(_l + FromLength)) {
        DebugPrint("This should not fail\n");
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(CHAR));

    for (currptr = _s + AtPosition, endptr = currptr + FromLength;
         currptr < endptr;
         currptr++) {
        *currptr = Character;
    }

    return TRUE;
}


PSTR
BSTRING::QuerySTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PSTR    Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine makes a copy of this string into the provided
    buffer.  If this string is not provided then a buffer is
    allocated on the heap.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to convert into.
    BufferLength    - Supplies the number of characters in this buffer.
    ForceNull       - Specifies whether or not to force a NULL even
                        when the buffer is too small for the string.

Return Value:

    A pointer to a NULL terminated multi byte string.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    if (!Buffer) {
        BufferLength = Length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength*sizeof(CHAR)))) {
            return NULL;
        }
    }

    if (BufferLength > Length) {
        memcpy(Buffer, _s + Position, (UINT) Length*sizeof(CHAR));
        Buffer[Length] = 0;
    } else {
        memcpy(Buffer, _s + Position, (UINT) BufferLength*sizeof(CHAR));
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}



INLINE
VOID
BDSTRING::Construct(
    )
/*++

Routine Description:

    This routine initializes the string to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _length = 0;
}



#define     DUMMY_ULIB_EXPORT

DEFINE_EXPORTED_CONSTRUCTOR( BDSTRING, BSTRING, DUMMY_ULIB_EXPORT );


BDSTRING::~BDSTRING(
    )
/*++

Routine Description:

    Destructor for BDSTRING.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_buf);
}


BOOLEAN
BDSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTR   new_buf;

    if (NewStringLength >= _length) {

        if (_buf) {
            if (!(new_buf = (PSTR)
                  REALLOC(_buf, (NewStringLength + 1)*sizeof(CHAR)))) {

                return FALSE;
            }
        } else {
            if (!(new_buf = (PSTR)
                  MALLOC((NewStringLength + 1)*sizeof(CHAR)))) {

                return FALSE;
            }
        }

        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}


BOOLEAN
BDSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTR   new_buf;

    if (NewStringLength >= _length) {

        if (!(new_buf = (PSTR)
              MALLOC((NewStringLength + 1)*sizeof(CHAR)))) {

            return FALSE;
        }

        if (_buf) {
            FREE(_buf);
        }
        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\bufstrm.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bufstrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of BUFFER_STREAM class.

Author:

    Jaime Sasson (jaimes) 14-Apr-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "bufstrm.hxx"
#include "mbstr.hxx"
#include "system.hxx"
#include "wstring.hxx"

extern "C" {
    #include <ctype.h>
}

DEFINE_CONSTRUCTOR ( BUFFER_STREAM, STREAM );



BUFFER_STREAM::~BUFFER_STREAM (
    )

/*++

Routine Description:

    Destroy a BUFFER_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    FREE( _Buffer );
}



VOID
BUFFER_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a BUFFER_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Buffer = NULL;
    _BufferSize = 0;
    _CurrentByte = NULL;
    _BytesInBuffer = 0;
    _BufferStreamType = -1;
}


BOOLEAN
BUFFER_STREAM::Initialize (
    ULONG   BufferSize
    )

/*++

Routine Description:

    Initialize an object of type BUFFER_STREAM.
    A BUFFER_STREAM object cannot be reinitialized.

Arguments:

    BufferSize - Size of the buffer to be allocated.
                 The size of the buffer can be zero, but in this case no
                 memory will be allocated. This initialization should be used
                 only by FILE_STREAM when it is mapping a file in memory. In
                 this case, all methods that read from the buffer or test
                 the end of the file will be overloaded by methods defined
                 in FILE_STREAM.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeed.

--*/

{
    BOOLEAN Result;

    Result = FALSE;
    if( BufferSize != 0 ) {
        //
        //      The +2 is needed becase the buffer needs to be
        //      double NUL terminated
        //
        _Buffer = ( PBYTE ) MALLOC( ( size_t )( BufferSize + 2 ) );
        if( _Buffer != NULL ) {
            *( _Buffer + BufferSize ) = 0;
            *( _Buffer + BufferSize + 1 ) = 0;
            _BufferSize = BufferSize;
            _CurrentByte = NULL;
            _BytesInBuffer = 0;
            Result = TRUE;
        }
    } else {
        _Buffer = NULL;
        _BufferSize = 0;
        _CurrentByte = NULL;
        _BytesInBuffer = 0;
        Result = TRUE;
    }
    return( ( STREAM::Initialize() ) && Result );
}



ULONG
BUFFER_STREAM::FlushBuffer (
    )

/*++

Routine Description:

    Empty the buffer. The contents of the buffer is lost, and the
    buffer is reinitialized.

Arguments:

    None.

Return Value:

    ULONG - Returns the number of bytes lost in the buffer.

--*/

{
    ULONG   BytesLost;

    BytesLost = _BytesInBuffer;
    _CurrentByte = NULL;
    _BytesInBuffer = 0;
    return( BytesLost );
}



BOOLEAN
BUFFER_STREAM::IsAtEnd(
    ) CONST

/*++

Routine Description:

    Informs the caller if all bytes were read (the buffer is empty and
    end of file has occurred.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE indicates that there is no more byte to read.


--*/

{
    return( ( _BytesInBuffer == 0 ) && EndOfFile() );
}

VOID
BUFFER_STREAM::SetStreamTypeANSI()
{
     _BufferStreamType = 0;
}

BOOLEAN
BUFFER_STREAM::DetermineStreamType(
     IN OUT PBYTE        *Buffer,
     IN ULONG        BufferSize
     )
/*++
Routine Description:
    Sets _BufferStreamType for memory mapped files, called from
    file_stream.

Arguments:
    Pointer to data & byte count.

Return Value:
    True always.
--*/
{
    BOOL bUnicode;

    if (_BufferStreamType < 0) {
#ifdef FE_SB
        //
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        //
        INT     iResult = ~0x0;

        __try {
            bUnicode = IsTextUnicode((LPTSTR)*Buffer, (INT)BufferSize, &iResult);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return FALSE;
        }

        _BufferStreamType = 0;

        //
        // if the text contains ByteOrderMark. It is unicode text.
        //
        if ((iResult & IS_TEXT_UNICODE_SIGNATURE) != 0) {

            _BufferStreamType = 1;
            *Buffer+=2;

        } else if (bUnicode &&
                   (((iResult & IS_TEXT_UNICODE_UNICODE_MASK) != 0) ||
                    ((iResult & IS_TEXT_UNICODE_REVERSE_MASK) != 0)) &&
                   !(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK)) {
            //
            // If the result depends only upon statistics, check
            // to see if there is a possibility of DBCS.
            //
            LPSTR pch = (LPSTR)*Buffer;
            UINT   cb = BufferSize;

            while (cb > 0) {
                __try {
                    if (IsDBCSLeadByte(*pch)) {
                        bUnicode = FALSE;
                        break;
                    }
                } __except ( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                    _BufferStreamType = -1;
                    return FALSE;
                }
                cb--;
                pch++;
            }

            if (bUnicode)
                _BufferStreamType = 1;
        }
#else
        __try {
            bUnicode = IsTextUnicode((LPTSTR)*Buffer, (INT)BufferSize, NULL);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return FALSE;
        }

        if (bUnicode) {
           _BufferStreamType = 1;
           if (*((LPWCH)*Buffer) == (WCHAR)0xfeff)
               *Buffer+= 2 ; // eat the Byte Order Mark
        } else
           _BufferStreamType = 0;
#endif // FE_SB
    }
    return TRUE;
}


BOOLEAN
BUFFER_STREAM::Read(
    OUT PBYTE       Buffer,
    IN  ULONG       BytesToRead,
    OUT PULONG      BytesRead
    )

/*++

Routine Description:

    Reads data from the buffer.

Arguments:

    Buffer - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read.

    BytesRead - Points to the variable that will contain the number of
                bytes read.


Return Value:

    BOOLEAN - Returns TRUE if the read operation succeeded. If there was no
              data to be read, the return value will be TRUE (to indicate
              success), but BytesRead will be zero.


--*/

{
    ULONG   BytesReadSoFar;

    DebugPtrAssert( Buffer );

    if( BytesToRead <= _BytesInBuffer ) {
        //
        //  If the buffer contains more bytes than requested, then
        //  just transfer bytes from one buffer to the other
        //
        memmove( Buffer, _CurrentByte, ( size_t )BytesToRead );
        _BytesInBuffer -= BytesToRead;
        if( _BytesInBuffer != 0 ) {
            _CurrentByte += BytesToRead;
        } else {
            _CurrentByte = NULL;
        }
        *BytesRead = BytesToRead;
        return( TRUE );
    }

    //
    //  Buffer contains less bytes than the total number requested.
    //  Transfer all bytes in the buffer to the caller's buffer
    //
    memmove( Buffer, _CurrentByte, ( size_t )_BytesInBuffer );
    Buffer += _BytesInBuffer;
    BytesReadSoFar = _BytesInBuffer;
    _CurrentByte = _Buffer;
    BytesToRead -= _BytesInBuffer;
    _BytesInBuffer = 0;
    //
    //  Refill the buffer and transfer bytes to the caller's buffer
    //  until all bytes are read or end of file occurs.
    //
    while( ( BytesToRead > 0 ) && !EndOfFile() ) {
        if( !FillBuffer( _Buffer, _BufferSize, &_BytesInBuffer ) ) {
            _BytesInBuffer = 0;
            _CurrentByte = NULL;
            return( FALSE );
        }
        if( BytesToRead >= _BytesInBuffer ) {
            memmove( Buffer, _Buffer, ( size_t )_BytesInBuffer );
            Buffer += _BytesInBuffer;
            BytesReadSoFar += _BytesInBuffer;
            BytesToRead -= _BytesInBuffer;
            _BytesInBuffer = 0;
        } else {
            memmove( Buffer, _Buffer, ( size_t )BytesToRead );
            BytesReadSoFar += BytesToRead;
            _CurrentByte += BytesToRead;
            _BytesInBuffer -= BytesToRead;
            BytesToRead = 0;
        }
    }
    *BytesRead = BytesReadSoFar;
    if( _BytesInBuffer == 0 ) {
        _CurrentByte = NULL;
    }
    return( TRUE );
}


BOOLEAN
BUFFER_STREAM::AdvanceBufferPointer(
    IN  ULONG   Offset
    )

/*++

Routine Description:

    Adds an offset to the pointer to the current byte.
    (It has the effect of removing the first 'offset' bytes from the
    buffer.)

Arguments:

    Offset  - Number of bytes to remove from the buffer.

Return Value:

    BOOLEAN - Returns TRUE if the pointer was advanced, or FALSE if the
              offset was greater than the number of bytes in the buffer.


--*/

{
    BOOLEAN Result;

    if( Offset <= _BytesInBuffer ) {
        _BytesInBuffer -= Offset;
        _CurrentByte = ( _BytesInBuffer == 0 ) ? NULL : _CurrentByte + Offset;
        Result = TRUE;
    } else {
        Result = FALSE;
    }
    return( Result );
}



PCBYTE
BUFFER_STREAM::GetBuffer(
    PULONG  BytesInBuffer
    )

/*++

Routine Description:

    Returns to the caller the pointer to the buffer. If the buffer
    is empty, then it fills the buffer.

Arguments:

    BytesInBuffer - Points to the variable that will contain the number
                    of bytes added to the buffer.


Return Value:

    PCBYTE - Pointer to the buffer.

--*/

{
    BOOL    bUnicode;

    if( _BytesInBuffer == 0 ) {
        if( !EndOfFile() && 
	        	FillBuffer( _Buffer, _BufferSize, &_BytesInBuffer )) {
            _CurrentByte = _Buffer;
        } else {
            _CurrentByte = NULL;
        }
    } else if (_BufferStreamType == 1 && _BytesInBuffer == 1) {
        if ( !EndOfFile() &&
	        	FillBuffer( _Buffer + 1, _BufferSize - 1, &_BytesInBuffer )) {
            _BytesInBuffer++;
            _CurrentByte = _Buffer;
        } else {
            _BytesInBuffer = 0;
            _CurrentByte = NULL;
        }
    }

    if (_BufferStreamType < 0) {
#ifdef FE_SB
        //
        // Set default as ANSI text.
        //
        _BufferStreamType = 0;

        if (_BufferSize > 1) {
            //
            // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
            //
            INT     iResult = ~0x0;

            __try {
                bUnicode = IsTextUnicode((LPTSTR)_CurrentByte, (INT)_BytesInBuffer, &iResult);
            } __except ( EXCEPTION_EXECUTE_HANDLER ) {
                DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
                return NULL;
            }
            //
            // if the text contains ByteOrderMark. It is unicode text.
            //
            if ((iResult & IS_TEXT_UNICODE_SIGNATURE) != 0) {

            _BufferStreamType = 1;
            _CurrentByte += 2;

            } else if (bUnicode                                          &&
                       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
                       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    ) {
                //
            // If the result depends only upon statistics, check
            // to see if there is a possibility of DBCS.
            //
                LPSTR pch = (LPSTR)_CurrentByte;
                UINT   cb = (UINT)_BytesInBuffer;

                while (cb > 0) {
                    if (IsDBCSLeadByte(*pch)) {
                        bUnicode = FALSE;
                        break;
                    }
                    cb--;
                    pch++;
                }

                if (bUnicode)
                    _BufferStreamType = 1;
            }
        }
#else
        __try {
            bUnicode = IsTextUnicode((LPTSTR)_CurrentByte, (INT)_BytesInBuffer, NULL);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return NULL;
        }

        if (bUnicode && (_BufferSize > 1) ) {

            _BufferStreamType = 1;

            if (*((LPWCH)_CurrentByte)==0xfeff) {
                _CurrentByte+=2; // eat the Byte Order Mark
            }
        } else {
            _BufferStreamType = 0;
        }
#endif // FE_SB

        DebugPrintTrace(("The stream type is: %s.\n", ((_BufferStreamType==1)?"UNICODE":"NON UNICODE") ));

    }
    *BytesInBuffer = _BytesInBuffer;
    return( _CurrentByte );
}


BOOLEAN
BUFFER_STREAM::ReadChar(
    OUT PWCHAR      Char,
    IN BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a character off the stream

Arguments:

    Char - Supplies pointer to wide character.

Return Value:

    TRUE if a character was read,
    FALSE otherwise

Notes:

    We always read the character from the stream as a multibyte character
    and do the multibyte to wide character conversion.

--*/

{

    PBYTE   Buffer;
    ULONG   BytesInBuffer;
    USHORT  BytesInChar;

    if (!Char || ((Buffer = (PBYTE)GetBuffer( &BytesInBuffer)) == NULL )) {
        return FALSE;
    }
    //
    //  Buffer may be a pointer to a file mapped in memory. For this
    //  reason we have to be aware of exception while accessing it.
    //
    DebugAssert( _BufferStreamType >= 0 );
    if (_BufferStreamType == 0 && !Unicode) {
       __try {
           if( !( *Buffer ) ) {
               //
               // The first character in the buffer is a NULL. Return ZERO
               // as the character read.
               //
               BytesInChar = 1;
               Char = 0;
           } else {
               BytesInChar = (USHORT)mbtowc( (wchar_t *)Char, (char *)Buffer, (size_t)BytesInBuffer );
           }
       }
       __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
           return( FALSE );
       }
    } else {
       __try {
           if( !( *((wchar_t *)Buffer) ) ) {
               //
               // The first character in the buffer is a NULL. Return ZERO
               // as the character read.
               //
               BytesInChar = 2;
               Char = 0;
           } else {
               BytesInChar = 2;
               Char = (wchar_t *)Buffer;
           }
       }
       __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
           return( FALSE );
       }
    }

    if ( BytesInChar == 0 ) {
        return FALSE;
    }

    AdvanceBufferPointer( BytesInChar );

    return TRUE;

}

//disable C4509 warning about nonstandard ext: SEH + destructor
#pragma warning(disable:4509)


BOOLEAN
BUFFER_STREAM::ReadString(
    OUT PWSTRING    String,
    IN  PWSTRING    Delimiters,
    IN BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a string off the stream

Arguments:

    String      -   Supplies pointer to string. The string must have been
                    previously initialized.
    Delimiter   -   Supplies the set of characters that constitute a
                    string delimiter.

Return Value:

    TRUE if a string was read,
    FALSE otherwise

--*/

{
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    BOOLEAN EndOfString;
    PSTR    delim;
    PWSTR   delim_U;
    BOOLEAN r;
    FSTRING fstring;
    CHNUM   old_string_length;

    DebugPtrAssert( String );

    String->Truncate();

    EndOfString = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        DebugAssert( _BufferStreamType >= 0 );
        if ( _BufferStreamType == 0 && !Unicode) {
          __try {
            if (delim = Delimiters->QuerySTR()) {
                //
                //  If pBuffer points to a file mapped in memory, and the
                //  end of the file is in a page boundary, and the last
                //  byte in the file is neither NUL nor one of the delimiters,
                //  we get an access violation.
                //  For this reason we call strcspn inside a try-except, and
                //  if an access violation occurs we consume all bytes in
                //  the buffer.
                //  The access violation will not occur if the end of the file
                //  is not in a page boundary. In this case, it is guaranteed that
                //  the remaining bytes on the last page will be 0s.
                //
                //  The access violation will not occur if pBuffer points to the
                //  buffer defined in this class. In this case, it is guaranteed
                //  that the byte immediately after the end of the buffer is NUL
                //  (see the initialization of this object).
                //

                __try {
                    BytesConsumed = strcspn((PCSTR) pBuffer, delim);
                }
                __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                    BytesConsumed = BytesInBuffer;
                }

                // 
                // Just incase crossing the page boundary for memoory mapped files
                // does not cause an access violation
                //
                if (BytesConsumed > BytesInBuffer) {
                    BytesConsumed = BytesInBuffer;
                }

                DELETE(delim);
                old_string_length = String->QueryChCount();
                if (r = String->Resize(old_string_length + BytesConsumed)) {
                    fstring.Initialize((PWSTR) String->GetWSTR() +
                                       old_string_length, BytesConsumed + 1);
                    r = fstring.WSTRING::Initialize((PCSTR) pBuffer,
                                                    BytesConsumed);
                    String->SyncLength();
                }
            } else {
                r = FALSE;
            }
          }
          __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
          }

          EndOfString = (BytesConsumed < BytesInBuffer);

        } else {
           __try {
               if (delim_U = Delimiters->QueryWSTR()) {
                   __try {
                       BytesConsumed = wcscspn((wchar_t *) pBuffer, delim_U)*sizeof(WCHAR);
                   }
                   __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                       BytesConsumed = BytesInBuffer;
                   }

                    // 
                    // Just incase crossing the page boundary for memoory mapped files
                    // does not cause an access violation
                    //
                    if (BytesConsumed > BytesInBuffer) {
                       BytesConsumed = BytesInBuffer;
                    }
                 
                   if((BytesInBuffer & 0xfffe) != BytesInBuffer){
                      BytesInBuffer++;
                   }

                   DELETE(delim_U);
                   old_string_length = String->QueryChCount();
                   if (r = String->Resize(old_string_length + BytesConsumed/sizeof(WCHAR))) {
                       fstring.Initialize((PWSTR)String->GetWSTR() +
                                       old_string_length, BytesConsumed/sizeof(WCHAR) + 1);
                       r = fstring.WSTRING::Initialize((PCWSTR) pBuffer,
                                                       BytesConsumed/sizeof(WCHAR));
                       String->SyncLength();
                   }
               } else {
                   r = FALSE;
               }
           }
           __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
               return( FALSE );
              }
           EndOfString = (BytesConsumed < BytesInBuffer);
        }

        //EndOfString = (BytesConsumed < BytesInBuffer);

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if (r) {
            if (!AdvanceBufferPointer( BytesConsumed )) {
                break;
            }
        }
    }

    return TRUE;

}




BOOLEAN
BUFFER_STREAM::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:


Return Value:

--*/

{

    DWORD   StrSize;
    BOOLEAN EndOfString;
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    BYTE    Byte;
    DWORD   NumBytes;
    DWORD   ChunkSize;
    DWORD   Spaces;
    PBYTE   pBuf;

    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( Delimiters );

    *String         = '\0';
    StrSize         = 0;
    EndOfString     = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        __try {
            //
            //  If pBuffer points to a file mapped in memory, and the
            //  end of the file is in a page boundary, and the last
            //  byte in the file is neither NUL nor one of the delimiters,
            //  we get an access violation.
            //  For this reason we call strcspn inside a try-except, and
            //  if an access violation occurs we consume all bytes in
            //  the buffer.
            //  The access violation will not occur if the end of the file
            //  is not in a page boundary. In this case, it is guaranteed that
            //  the remaining bytes on the last page will be 0s.
            //
            //  The access violation will not occur if pBuffer points to the
            //  buffer defined in this class. In this case, it is guaranteed
            //  that the byte immediately after the end of the buffer is NUL
            //  (see the initialization of this object).
            //
            __try {
                BytesConsumed = MBSTR::Strcspn( (PSTR)pBuffer, Delimiters );
            }
            __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                BytesConsumed = BytesInBuffer;
            }

            // 
            // Just incase crossing the page boundary for memoory mapped files
            // does not cause an access violation
            //
            if (BytesConsumed > BytesInBuffer) {
                BytesConsumed = BytesInBuffer;
            }

            if ( BytesConsumed < BytesInBuffer ) {
                EndOfString = TRUE;
            }

            if ( ExpandTabs ) {

                //
                //  Expand tabs
                //
                ChunkSize = BytesConsumed;
                NumBytes  = BufferSize - StrSize - 1;

                pBuf     = (PBYTE)pBuffer;

                while ( ChunkSize-- && NumBytes ) {

                    Byte = *pBuf++;

                    if ( Byte != '\t' ) {

                        String[StrSize++] = Byte;
                        NumBytes--;

                    } else {

                        Spaces = min (TabExp - (StrSize % TabExp), NumBytes);
                        MBSTR::Memset( &String[StrSize], ' ', Spaces );
                        StrSize  += Spaces;
                        NumBytes -= Spaces;
                    }
                }
                ChunkSize++;

                if ( ChunkSize > 0 ) {
                    EndOfString     = TRUE;
                    BytesConsumed  -= ChunkSize;
                }

            } else {

                //
                //  Just copy string
                //
                if ( BytesConsumed >= (BufferSize-StrSize) ) {
                    BytesConsumed = BufferSize - StrSize - 1;
                    EndOfString   = TRUE;
                }

                MBSTR::Memcpy( &String[StrSize], (PVOID) pBuffer, BytesConsumed );
                StrSize += BytesConsumed;
            }

        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if( BytesConsumed < BytesInBuffer ) {
            //
            //  Get rid of the delimiter
            //  This is to improve the performance of FC, who calls
            //  STREAM::ReadMbLine several times
            //
            BytesConsumed++;
        }
        AdvanceBufferPointer( BytesConsumed );

    }

    String[StrSize] = '\0';

    *StringSize = StrSize;

    return TRUE;
}


BOOLEAN
BUFFER_STREAM::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize, // char count
    INOUT   PDWORD  StringSize, // char count
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:


Return Value:

--*/

{

    DWORD   StrSize;
    BOOLEAN EndOfString;
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    WCHAR    Byte;
    DWORD   NumBytes;
    DWORD   ChunkSize;
    DWORD   Spaces;
    PWCHAR   pBuf;

    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( Delimiters );

    *String         = L'\0';
    StrSize         = 0;
    EndOfString     = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        __try {
            //
            //  If pBuffer points to a file mapped in memory, and the
            //  end of the file is in a page boundary, and the last
            //  byte in the file is neither NUL nor one of the delimiters,
            //  we get an access violation.
            //  For this reason we call strcspn inside a try-except, and
            //  if an access violation occurs we consume all bytes in
            //  the buffer.
            //  The access violation will not occur if the end of the file
            //  is not in a page boundary. In this case, it is guaranteed that
            //  the remaining bytes on the last page will be 0s.
            //
            //  The access violation will not occur if pBuffer points to the
            //  buffer defined in this class. In this case, it is guaranteed
            //  that the byte immediately after the end of the buffer is NUL
            //  (see the initialization of this object).
            //
            __try {
                BytesConsumed = wcscspn( (PWSTR)pBuffer, Delimiters )*sizeof(WCHAR);
            }
            __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                BytesConsumed = BytesInBuffer&0xFFFE;
            }

            // 
            // Just incase crossing the page boundary for memoory mapped files
            // does not cause an access violation
            //
            if (BytesConsumed > BytesInBuffer) {
                BytesConsumed = BytesInBuffer;
            }

            if ( BytesConsumed < BytesInBuffer ) {
                EndOfString = TRUE;
            }

            if ( ExpandTabs ) {

                //
                //  Expand tabs
                //
                ChunkSize = BytesConsumed/sizeof(WCHAR);
                NumBytes  = BufferSize - StrSize - 1;

                pBuf     = (PWCHAR)pBuffer;

                while ( (ChunkSize--) && NumBytes ) {

                    Byte = *pBuf++;

                    if ( Byte != L'\t' ) {

                        String[StrSize++] = Byte;
                        NumBytes--;

                    } else {

                        Spaces = min (TabExp - (StrSize % TabExp), NumBytes);
                     //  wcsnset( (wchar_t *)&String[StrSize], L' ', Spaces );
                        for (DWORD ii=0;ii<Spaces;ii++) {
                           String[StrSize+ii] = L' ';
                        }
                        StrSize  += Spaces;
                        NumBytes -= Spaces;
                    }
                }
                ChunkSize++;

                if ( ChunkSize > 0 ) {
                    EndOfString     = TRUE;
                    BytesConsumed  = BytesConsumed - sizeof(WCHAR)*ChunkSize;
                }

            } else {

                //
                //  Just copy string
                //
                if ( BytesConsumed >= (BufferSize-StrSize)*sizeof(WCHAR) ) {
                    BytesConsumed = (BufferSize - StrSize - 1)*sizeof(WCHAR);
                    EndOfString   = TRUE;
                }

                MBSTR::Memcpy( &String[StrSize], (PVOID) pBuffer, BytesConsumed );
                StrSize += BytesConsumed/sizeof(WCHAR);
            }

        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if( BytesConsumed < BytesInBuffer ) {
            //
            //  Get rid of the delimiter
            //  This is to improve the performance of FC, who calls
            //  STREAM::ReadWLine several times
            //
            BytesConsumed+=2;
        }
        AdvanceBufferPointer( BytesConsumed );

    }

    String[StrSize] = 0;

    *StringSize = StrSize;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\bytestrm.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

    bytestrm.cxx

Abstract:

	This module contains the definitions of the member functions
    of BYTE_STREAM class.

Author:

    Ramon J. San Andres (ramonsa) 28-Feb-1992

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bytestrm.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( BYTE_STREAM, OBJECT, ULIB_EXPORT );

VOID
BYTE_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a BYTE_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Stream         = NULL;
    _Buffer         = NULL;
    _NextByte       = NULL;
    _BufferSize     = 0;
    _BytesInBuffer  = 0;
}



ULIB_EXPORT
BYTE_STREAM::~BYTE_STREAM (
	)

/*++

Routine Description:

    Destroy a BYTE_STREAM.

Arguments:

	None.

Return Value:

	None.

--*/

{
    FREE( _Buffer );
}






ULIB_EXPORT
BOOLEAN
BYTE_STREAM::Initialize (
    IN  PSTREAM Stream,
    IN  DWORD   BufferSize
    )

/*++

Routine Description:

    Initializes a BYTE_STREAM

Arguments:

    Stream      -   Supplies the stream to be used
    BufferSize  -   Supplies the size of the buffer to use

Return Value:

    BOOLEAN -   TRUE if successful.

--*/

{
    STREAMACCESS    Access;

    DebugPtrAssert( Stream );
    DebugAssert( BufferSize > 0 );

    FREE( _Buffer );

    Access = Stream->QueryAccess();

    if ( (Access == READ_ACCESS) || (Access == READ_AND_WRITE_ACCESS)) {

        if ( _Buffer = (PBYTE)MALLOC( BufferSize ) ) {

            _Stream         = Stream;
            _NextByte       = _Buffer;
            _BufferSize     = BufferSize;
            _BytesInBuffer  = 0;

            return TRUE;

        }
    }

    return FALSE;
}



ULIB_EXPORT
BOOLEAN
BYTE_STREAM::FillAndReadByte(
    IN  PBYTE   Byte
    )
/*++


Routine Description:

    Fills the buffer and reads next byte

Arguments:

    Byte    -   Supplies pointer to where to put the byte

Return Value:

    BOOLEAN -   TRUE if byte read.

--*/

{
    ULONG   BytesRead;

    DebugAssert( _BytesInBuffer == 0 );

    if ( _Stream->Read( _Buffer, _BufferSize, &BytesRead ) &&
         (BytesRead > 0) ) {

        _NextByte       = _Buffer;
        _BytesInBuffer  = (DWORD)BytesRead;

        *Byte = *_NextByte++;
        _BytesInBuffer--;

        return TRUE;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\basesys.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    basesys.cxx

Abstract:

    This is the implementation of BASE_SYSTEM class.

Author:

    David J. Gilman (davegi) 13-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "basesys.hxx"

extern "C" {
    #include <stdio.h>
#if defined( _AUTOCHECK_ )

    #include "ntos.h"
//
// This stuff is lifted from winuser.h, because with _AUTOCHECK_ we
// shouldn't include windows header files.
//

#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((USHORT)(i)))
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)

#endif // _AUTOCHECK_

};

ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

#define NUMBER_OF_ARGS      20
    STATIC LONG     InitializingHandle = 0;
    STATIC HANDLE   lib_handle = 0;

    PWSTR           args[NUMBER_OF_ARGS];
    WSTR            fmt[20];
    INT             i, j;
    PWSTR           p;
    PWSTRING        gstring;
    DSTRING         UnicodeFormat;
    WSTR            display_buffer[4096];
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingHandle, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

#if !defined( _AUTOCHECK_ )
    if (!lib_handle) {
        lib_handle = GetModuleHandle((LPWSTR)L"ulib.dll");
        DebugAssert(lib_handle);
        if (!lib_handle) {
            status = InterlockedDecrement(&InitializingHandle);
            DebugAssert(status == 0);
            return FALSE;
        }
    }
#else
    NTSTATUS        Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PWSTR           MessageFormat;
    ULONG           Result;
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;

    if (!lib_handle) {
        lib_handle = (PVOID)NtCurrentPeb()->ImageBaseAddress;
        DebugAssert(lib_handle);
        if (!lib_handle) {
            status = InterlockedDecrement(&InitializingHandle);
            DebugAssert(status == 0);
            return FALSE;
        }
    }
#endif

    status = InterlockedDecrement(&InitializingHandle);
    DebugAssert(status == 0);

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        args[i] = NULL;
    }

    if (!UnicodeFormat.Initialize(Format)) {
        return FALSE;
    }

    i = 0;
    for (p = (PWSTR) UnicodeFormat.GetWSTR(); *p; p++) {
        if (*p == '%') {
            if (*(p + 1) == 'W') {
                p++;
                gstring = va_arg(VarPointer, PWSTRING);
                gstring->QueryWSTR(0, TO_END, display_buffer, 4096);
            } else {
                j = 0;
                fmt[j++] = *p++;
                while (*p && *p != '%') {
                    if ((*p == 's' || *p == 'c') && *(p - 1) != 'w') {
                        fmt[j++] = 'h';
                    }
                    fmt[j++] = *p++;
                }
                p--;
                fmt[j] = 0;
                if (wcsncmp(fmt, L"%I64", 4) == 0)
                    swprintf(display_buffer, fmt, va_arg(VarPointer, LARGE_INTEGER));
                else
                    swprintf(display_buffer, fmt, va_arg(VarPointer, PVOID));
            }
            args[i] = (PWSTR)MALLOC(wcslen(display_buffer) * sizeof(WCHAR) +
                sizeof(WCHAR));
            if (NULL == args[i]) {
                return FALSE;
            }
            wcscpy( args[i++], display_buffer);
        }
    }

#if !defined( _AUTOCHECK_ )
    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  (LPVOID)lib_handle,
                  (ULONG)MsgId,
                  0L,
                  display_buffer,
                  4096,
                  (va_list *)args);

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    return ResourceString->Initialize(display_buffer);

#else
    Status = RtlFindMessage( lib_handle,
                             (ULONG_PTR)RT_MESSAGETABLE,

#if defined JAPAN   // v-junm - 08/03/93
// The default TEB's value for NT-J is set to 0x411(JP) in the hives.  Since
// we do not want Japanese messages to come out in the boot screen, we have to
// force autochk.exe to pick up the English text rather than the Japanese.
//
// NOTE:  This has to be done because the current version of autochk.exe has
//      bilingual messages.  It's more efficient to make a US version rather
//      than a bilingual version to save space.
                             0x409,
#else
                             0,
#endif
                             (ULONG)MsgId,
                             &MessageEntry
                           );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        RtlInitAnsiString( &AnsiString, (PCSZ)&MessageEntry->Text[ 0 ] );
        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
        }

        MessageFormat = UnicodeString.Buffer;
    } else {
        MessageFormat = (PWSTR)MessageEntry->Text;
        UnicodeString.Buffer = NULL;
    }

    Status = RtlFormatMessage( MessageFormat,
                               0,
                               FALSE,
                               FALSE,
                               TRUE,
                               (va_list *)args,
                               (PWSTR)display_buffer,
                               sizeof( display_buffer ),
                               &Result
                             );

    if (UnicodeString.Buffer != NULL) {
        RtlFreeUnicodeString( &UnicodeString );
    }

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    return ResourceString->Initialize(display_buffer);

#endif // _AUTOCHECK_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\chkmsg.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "chkmsg.hxx"
#include "array.hxx"
#include "arg.hxx"
#include "iterator.hxx"
#include "system.hxx"
#include "stream.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR(CHKDSK_MESSAGE, MESSAGE, ULIB_EXPORT)

VOID
CHKDSK_MESSAGE::Construct(
    )
/*++

Routine Description:

    Constructor for CHKDSK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


ULIB_EXPORT
CHKDSK_MESSAGE::~CHKDSK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for CHKDSK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::Initialize(
    IN OUT  PSTREAM OutputStream,
    IN OUT  PSTREAM InputStream,
    IN OUT  PSTREAM ErrorStream
    )
/*++

Routine Description:

    This routine initializes the CHKDSK_MESSAGE object to the specified stream.

Arguments:

    OutputStream    - Supplies the output stream for the object.
    InputStream     - Supplies the input stream for the object.
    ErrorStream     - Supplies the error stream for the object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (OutputStream == NULL ||
        InputStream == NULL) {
        return FALSE;
    }

    _out_stream = OutputStream;
    _in_stream = InputStream;
    _err_stream = ErrorStream;
    _copy_input = SCREEN::Cast(OutputStream) ? FALSE : TRUE;


#ifdef FE_SB
    LANGID LangId;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

    return MESSAGE::Initialize();
}

ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::Set(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual
    )
/*++

Routine Description:

    This routine sets up the class to display the message with the
    'MsgId' resource identifier.

Arguments:

    MsgId       - Supplies the resource id of the message.
    MessageType - Supplies the type of the message.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SetMessageId(MsgId);
    _msgtype = MessageType;
    _msgvisual = MessageVisual;
    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style list format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (!SYSTEM::QueryResourceStringV(&_display_string,
                                      GetMessageId(),
                                      Format,
                                      VarPointer)) {
        return FALSE;
    }

    return DisplayString();
}


ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries either a "yes" or "no" from the input stream.

Arguments:

    Default - Supplies the default answer if neither "yes" nor "no" is the
                recognized input.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DSTRING     input;
    DSTRING     yes_message;
    DSTRING     no_message;
    WCHAR       w;

    Flush();

    if (!SYSTEM::QueryResourceString(&yes_message, MSG_YES, "")) {
        return Default;
    }

    if (!SYSTEM::QueryResourceString(&no_message, MSG_NO, "")) {
        return Default;
    }

    for (;;) {
        if (!ReadLine(&input)) {
            return Default;
        }

        if (!input.Strupr()) {
            return Default;
        }

        w = input.QueryChAt(0);

        if (w == no_message.QueryChAt(0) || w == '0') {
            return FALSE;
        }

        if (w == yes_message.QueryChAt(0) || w == '1') {
            return TRUE;
        }

        DisplayString();
    }
}


BOOLEAN
CHKDSK_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return ReadLine(String);
}


BOOLEAN
CHKDSK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING string;

    return (BOOLEAN) (Flush() && ReadLine(&string));
}


MSGID
CHKDSK_MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Description:

    This routine queries input from the user in order to determine which
    message was entered.  It then returns the message id of the message
    entered.

Arguments:

    NumberOfSelections  - Supplies the number of message ids.
    ...                 - Supplies the message ids.

Return Value:

    The message id of the message entered, or the first message id.

--*/
{
    va_list             ap;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PFLAG_ARGUMENT      flag_arg;
    ARGUMENT_LEXEMIZER  arg;
    DSTRING             input_string;
    MSGID               first;
    PITERATOR           arg_it;
    ULONG               i;
    DSTRING             match_string;
    DSTRING             del;

    va_start(ap, NumberOfSelections);
    first = va_arg(ap, MSGID);
    va_end(ap);

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return first;
    }

    if (!arg.Initialize(&lex_array)) {
        return first;
    }

    arg.SetCaseSensitive(_case_sensitive);

    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        SYSTEM::QueryResourceString(&match_string, va_arg(ap, MSGID), "");

        if (!(flag_arg = NEW FLAG_ARGUMENT) ||
            !flag_arg->Initialize(&match_string) ||
            !arg_array.Put(flag_arg)) {
            va_end(ap);
            return first;
        }
    }
    va_end(ap);

    Flush();

    if (!ReadLine(&input_string)) {
        return first;
    }

    if (!arg.PrepareToParse(&input_string)) {
        return first;
    }

    if (!arg.DoParsing(&arg_array)) {
        return first;
    }

    arg_it = arg_array.QueryIterator();
    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        flag_arg = (PFLAG_ARGUMENT) arg_it->GetNext();
        if (flag_arg->QueryFlag()) {
            first = va_arg(ap, MSGID);
        } else {
            va_arg(ap, MSGID) ? 1 : 0;
        }
        DELETE(flag_arg);
    }
    va_end(ap);

    DELETE(arg_it);

    return first;
}


PMESSAGE
CHKDSK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MSG object.

--*/
{
    PCHKDSK_MESSAGE   p;

    if (!(p = NEW CHKDSK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_out_stream, _in_stream)) {
        DELETE(p);
        return NULL;
    }

    return p;
}


VOID
CHKDSK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns an CHKDSK_MESSAGE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


BOOLEAN
CHKDSK_MESSAGE::ReadLine(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine reads a line from the input stream.

Arguments:

    String  - Returns the read in string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING del;
    WCHAR   w;

    if (!del.Initialize("\r\n")) {
        return FALSE;
    }

    if (_in_stream->IsAtEnd()) {
        return FALSE;
    }

    String->Initialize( "" );

    if (!_in_stream->ReadString(String, &del)) {
        return FALSE;
    }

    // Line feed is the last character on the line.

    for (;;) {
        if (_in_stream->IsAtEnd()) {
            return TRUE;
        }

        if (!_in_stream->ReadChar(&w)) {
            return FALSE;
        }

        if (w == '\n') {
            break;
        }
    }

    if (_copy_input) {
        _out_stream->WriteString(String, 0, String->QueryChCount());
        _out_stream->WriteString(&del, 0, del.QueryChCount());
        if (IsLoggingEnabled()) {
            LogMessage(String);
            LogMessage(&del);
        }
    }

    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::Flush(
    )
/*++

Routine Description:

    This routine flushes the input stream of all previously typed input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PKEYBOARD   key;

    if (key = KEYBOARD::Cast(_in_stream)) {
        return key->Flush();
    }

    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::DisplayString(
    )
/*++

Routine Description:

    This routine prints this objects current string to the
    appropriate output.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTREAM stream;

    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (_msgtype == ERROR_MESSAGE && _err_stream) {
        stream = _err_stream;
    } else {
        stream = _out_stream;
    }

    if (!stream->WriteString(&_display_string, 0, TO_END, 40)) {
        return FALSE;
    }

    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&_display_string);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\clasdesc.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	clasdesc.cxx

Abstract:

	This module contains the definition for the CLASS_DESCRIPTOR class. 
	CLASS_DESCRIPTOR classes are special concrete classes derived from 
	OBJECT. They are special in that a single staic object of this class
	exists for every other concrete class in the Ulib hierarchy. 
	CLASS_DESCRIPTORs allocate and maintain information that can be used
	at run-time to determine the actual type of an object.

Author:

	David J. Gilman (davegi) 30-Oct-1990

Environment:

	ULIB, User Mode

Notes:

	The definitions for all concrete class' CLASS_DESCRIPTORs can be found
	in the file ulib.cxx.

	See the Cast member function in ulibdef.hxx to see how dynamic casting
	and CLASS_DESCRIPTORs work.

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"


ULIB_EXPORT
CLASS_DESCRIPTOR::CLASS_DESCRIPTOR (
	)
{
}

#if DBG==1

//
// For debugging purposes CLASS_DESCRIPTORs maintain the name of the class
// that they describe.
//

#include <string.h>
 
ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
	IN PCCLASS_NAME 	ClassName
	)

/*++

Routine Description:

	Initialize a CLASS_DESCRIPTOR object by initializing the classname
	and class ids.

Arguments:

	ClassName - Supplies the name of the class being described.

Return Value:

    None.

--*/

{
	DebugPtrAssert( ClassName );
	strncpy(( PCCHAR ) _ClassName,
		( PCCCHAR ) ClassName,
		( INT ) _MaxClassNameLength );

	//
	// Note that this guarantees that the CLASS_ID is unique for all classes
	// at the expense of not being able to recognize a class based on it's
	// CLASS_ID. The benefit is that IDs are guaranteed to be unique and
	// do not have to be cleared or registered.
	//

	_ClassID = ( ULONG_PTR ) &_ClassID;
	return( TRUE );
}

#else  // DBG==0

ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
	)

/*++

Routine Description:

	Initialize a CLASS_DESCRIPTOR object by initializing the class id.

Arguments:

Return Value:

    None.

--*/

{
	_ClassID = ( ULONG_PTR ) &_ClassID;
	return( TRUE );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\buffer.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    This contains all buffer class definition.
    Buffers do not have implicit terminations. Sizes on construction
    should include any termination bytes.

Author:

    steve rowe	    stever	27-Nov-90

Environment:

    ULIB, User Mode

Notes:



Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "buffer.hxx"

#if defined( __BCPLUSPLUS__ )

	#include <mem.h>
#else
	
	extern "C" {
		#include <memory.h>
	}; 

#endif // __BCPLUSPLUS__

//
// _ThresHold is the constant used by ReAllocate to determine when
// to actually call realloc to shrink the buffer.
//

ULONG BUFFER::_ThresHold = 129;

DEFINE_CONSTRUCTOR( BUFFER, OBJECT );

VOID
BUFFER::Construct (
	)

/*++

Routine Description:

	Construct a BUFFER by initializing it's internal state.

Arguments:

	None.

Return Value:

	None.

--*/

{
	cb			= 0;
	_BufSize	= 0;
	pBuffer 	= NULL;
}

BUFFER::~BUFFER (
	)

/*++

Routine Description:

    Destructor for general buffer class

Arguments:

    None

Return Value:

    None.

--*/

{
	if( pBuffer ) {
		FREE(pBuffer);
	}
}

BOOLEAN
BUFFER::BuffCat (
	IN PCBUFFER  Buffer2
	)

/*++

Routine Description:

    Concatenates a buffer with this buffer.

Arguments:

	Buffer2 - Buffer to add to current buffer.

Return Value:

	TRUE - success
	FALSE - failed to reallocate memory.

--*/

{
	REGISTER ULONG	cbT;
	PCHAR			pTmp;

    // Note W-Barry   11-JUN-91   Needed to add a variable to hold the
	//	current value of cb since the reallocate routine has been changed
	//	to update 'cb' when called...
	//
	ULONG			CurrentCount;

	cbT = cb + Buffer2->QueryBytesInBuffer();
	CurrentCount = cb;
	if ((pTmp = (char *)ReAllocate( cbT )) != NULL) {
		memcpy( pTmp + CurrentCount, Buffer2->GetBufferPtr(), (size_t)(cbT - CurrentCount) );
		pBuffer = pTmp;
		cb = cbT;
		return( TRUE );
	}
	return( FALSE );
}

BOOLEAN
BUFFER::BufferCopyAt (
	IN	PCVOID	BufferToCopy,
	IN	ULONG	cbToCopy,
	IN	ULONG	oStart
	)

/*++

Routine Description:

    Copies a number of bytes from a buffer to a particular location.
    Note that the total buffer size my increase, it will not decrease.
    This way replaces can be done. StartingByte can be past end of
    current buffer. What would lie between end of buffer and
	startingbyte would be undefined.

	WARNING: BufferToCopy cannot point into this buffer.

Arguments:

    BufferToCopy  - Supplies the buffer to copy
    SizeOfBuffer  - Supplies the number of bytes to copy

Return Value:

    ULONG - number of bytes copied.
	0 - if error. check error stack.

--*/

{


	ULONG 	cbT;
	PCHAR   pBufferNew;

	//
	// Enforce warning
	//

/*** Note davegi What does warning mean?

	DebugAssert(((( PCHAR ) pBuffer + cb ) <= BufferToCopy ) &&
		( BufferToCopy < (PCHAR ) pBuffer ));

***/
	/*
	Copies to yourself are rare and will fall through the code so
	no special action is taken.

	Copes of a null will fall through since realloc will free the
	buffer for a size of 0.

	If the new buffer will fit in the old the size is not reduced to
	the end of the new buffer. This is to support sub-string replacement.
	The caller then must be aware of how the copy effects buffer size.
	*/

	cbT = oStart + cbToCopy;
	pBufferNew = (PCHAR) pBuffer;
	// will it fit in current buffer
	if (cb < cbT) {
		if ((pBufferNew = (char *)ReAllocate( cbT )) != NULL) {
			cb = cbT;
		} else {
			return( FALSE );
		}
	}

	memcpy (pBufferNew + oStart, BufferToCopy, (size_t)cbToCopy);
	pBuffer = pBufferNew;
	return( TRUE );
}

BOOLEAN
BUFFER::DeleteAt(
	IN ULONG cbToDelete,
	IN ULONG oStartDelete
	)

/*++

Routine Description:

	Deletes the specificied section of the current buffer

Arguments:

	cbToDelete      - Supplies the number of bytes to delete
	oStartDelete    - Supplies the offset for the delete

Return Value:

	TRUE  - insert success
	FALSE - This can happen when cbToDelete is larger then
			the size of the buffer, oStartDelete is past the
			end of the buffer.
--*/


{
	if (oStartDelete < cb) {
		if (cbToDelete <= cb) {
			cb = cb - cbToDelete;
			pBuffer = ( PCCHAR )ReAllocate( cb );
			DebugPtrAssert( pBuffer );
			memmove(( PCCHAR )pBuffer + oStartDelete ,
					 ( PCCHAR )pBuffer + (oStartDelete + cbToDelete),
					 (size_t)(cb - oStartDelete) );
			return( TRUE );
		}
	}
	return( FALSE );
}

BOOLEAN
BUFFER::InsertAt (
	IN PCVOID	BufferToCopy,
	IN ULONG	cbToCopy,
	IN ULONG    oStartCopy
	)

/*++

Routine Description:

	Inserts the specificied buffer of bytes at the specified
	location.

Arguments:

	BufferToCopy  - Supplies the buffer to insert
	cbToCopy      - Supplies the number of bytes to insert
	oStartCopy	  - Supplies the offset for the insertion

Return Value:

	TRUE  - insert success
	FALSE - This can happen for memory allocation failure
			or oStartCopy is past end of buffer.
--*/

{
	ULONG	cbT;

    // Note W-Barry   11-JUN-91   Necessary to add since cb is currently
	// being updated by ReAllocate().
	size_t	CountToMove;
	PCHAR	pTmp;

	CountToMove = (size_t)( cb - oStartCopy );
	if (oStartCopy < cb ) {
		cbT = cb + cbToCopy;
		if ((pTmp = (char *)ReAllocate( cbT )) != NULL) {
			memmove( pTmp + (oStartCopy + cbToCopy),
					 pTmp + oStartCopy,
					 CountToMove );
			memcpy( pTmp + oStartCopy, BufferToCopy, (size_t)cbToCopy );
			pBuffer = pTmp;
			cb = cbT;
			return( TRUE );
		}
	}
	return( FALSE );
}

BOOLEAN
BUFFER::PutBuffer (
	IN PCBUFFER		BufferToCopy
	)

/*++

Routine Description:

    Constructor for Buffer object. The buffer held in BufferToCopy
    is not moved but copied to this object. If failed to init orginal
    buffer state retained.

Arguments:

	BufferToCopy - pointer to BUFFER object to copy

Return Value:

	BOOLEAN - Returns TRUE if supplied buffer was succesfully copied

--*/

{

    ULONG   cbNew;
	PVOID   pBufferNew, pBufferCopy;

	cbNew = BufferToCopy->QueryBytesInBuffer ();

	if (( pBufferNew = MALLOC( (size_t)cbNew )) != NULL) {
		if( SetBuffer( pBufferNew, cbNew) ) {
            // Note the buffer is not shortened on this?
			pBufferCopy = BufferToCopy->GetBufferPtr();
			BufferCopyAt( pBufferCopy, cbNew );
			return( TRUE );
		}
    }

    return( FALSE );
}

BOOLEAN
BUFFER::SetBuffer (
	IN PVOID InitialBuffer,
	IN ULONG SizeOfBuffer
	)

/*++

Routine Description:

    Constructor for Buffer object. The buffer passed in should not be
    freed by the caller. BUFFER will free in upon deletion.

Arguments:

    InitialBuffer - pointer to buffer
    SizeOfBuffer  - size of buffer in bytes.

Return Value:

    None.

--*/

{
	if (cb) {
		FREE (pBuffer);
	}

	pBuffer = InitialBuffer;
	cb = SizeOfBuffer;
	_BufSize = SizeOfBuffer;

    return( TRUE );
}

PVOID
BUFFER::ReAllocate (
	IN ULONG	NewCount
	)

/*++

Routine Description:

	Reallocates the private data member pBuffer if required. ReAllocate
	supports the concept that BUFFER's internal buffer can be larger
	than the number of bytes actually in use.


Arguments:

	NewCount - Supplies the new size of pBuffer in bytes.


Return Value:

	PVOID - Returns a pointer to the 'newly allocated' pBuffer.

--*/

{
	REGISTER PVOID	pv;

	//
	// If the new buffer size is greater than what we currently have
	// in reserve, or it is smaller than the threshold, realloc the
	// buffer.
	//

	if( ( NewCount > _BufSize )			||
		( ( _BufSize - NewCount ) >= _ThresHold )
	  ) {

		//
		// If the realloc of the buffer succeeds, record it's actual size.
		//

		if(( pv = REALLOC( pBuffer, (size_t)NewCount )) != NULL ) {

			pBuffer  = pv;
			_BufSize = cb = NewCount;

		}
	} else {

		//
		// Enough storage is available in reserve, just return the
		// existing pointer.
		//

		_BufSize = cb = NewCount;
		pv = pBuffer;
	}

	return( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\cmem.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    cmem.cxx

Abstract:

    Implementation of class CMEM.

Author:

    Norbert P. Kusters (norbertk) 26-Nov-90

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "cmem.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( CONT_MEM, MEM, ULIB_EXPORT );

VOID
CONT_MEM::Construct (
    )
/*++

Routine Description:

    Constructor for CONT_MEM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _size = 0;
}


ULIB_EXPORT
BOOLEAN
CONT_MEM::Initialize(
    IN  PVOID   Buffer,
    IN  ULONG   Size
    )
/*++

Routine Description:

    This routine supplies the object with a store of memory from which to
    work with.

Arguments:

    Buffer  - Supplies a pointer to memory.
    Size    - Supplies the number of bytes of memory addressable through
                the pointer.

Return Value:

    None.

--*/
{
    _buf = Buffer;
    _size = Size;

    return TRUE;
}


ULIB_EXPORT
PVOID
CONT_MEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine takes size bytes of memory from the current memory
    pool and returns it to the user.  If size bytes of memory are not
    available then this routine return NULL.  After a call to this routine
    the local pool of memory is decreased by Size bytes.  Successive requests
    will be granted as long as there is sufficient memory to grant them.

    This method will fail if the memory is not at the alignment requested.

Arguments:

    Size        - Supplies the number of bytes of memory requested.
    Alignment   - Supplies the necessary alignment for the memory.

Return Value:

    A pointer to size bytes of memory or NULL.

--*/
{
    PVOID   rv;

    if (Size > _size ||
        ((ULONG_PTR) _buf)&AlignmentMask) {
        return NULL;
    }

    _size -= Size;
    rv = _buf;
    _buf = (PCHAR) _buf + Size;
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\comm.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    COMM_DEVICE

Abstract:

    This module contains the implementation for the COMM_DEVICE class.

Author:

    Ramon J. San Andres (ramonsa)   08-Jul-1991


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "comm.hxx"
#include "file.hxx"


//
//  Default timeout is one minute
//
#define DEFAULT_TIMEOUT 60000



DEFINE_EXPORTED_CONSTRUCTOR( COMM_DEVICE, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( COMM_DEVICE );

ULIB_EXPORT
COMM_DEVICE::~COMM_DEVICE(
    )
{
    Destroy();
}

VOID
COMM_DEVICE::Construct (
    )

/*++

Routine Description:

    Constructs a COMM_DEVICE object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Handle = NULL;

#if DBG==1

    _Initialized = FALSE;

#endif

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::Initialize (
    IN  PCPATH      PortName,
    OUT PBOOLEAN    OpenError
    )

/*++

Routine Description:

    Phase 2 of construction for a COMM_DEVICE.

Arguments:

    Port        -   Supplies pointer to the FSN_FILE object of the port.
    OpenError   -   Supplies pointer to flag which if TRUE means that
                    the port could not be openend.

Return Value:

    BOOLEAN -   TRUE if the serial port was successfully initialized,
                FALSE otherwise.

--*/

{
    DSTRING     QualifiedName;
    BOOLEAN     InitOk = FALSE;

    DebugPtrAssert( PortName );

    Destroy();

    if( !QualifiedName.Initialize( L"\\\\.\\" ) ||
        !QualifiedName.Strcat( PortName->GetPathString() ) ) {

        if( OpenError ) {
            *OpenError = FALSE;
        }
        return FALSE;
    }

    //
    //  Open the Port and get a handle to it.
    //
    _Handle = CreateFile(   QualifiedName.GetWSTR(),
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                            NULL );


    if ( _Handle != INVALID_HANDLE_VALUE ) {

        if ( OpenError ) {
            *OpenError = FALSE;
        }

        //
        //  Get the current port state
        //
        InitOk = GetCommState( _Handle, &_Dcb ) != FALSE;

#if DBG==1
        GetLastError();
#endif

#if DBG==1

        _Initialized = InitOk;

#endif

    } else if ( OpenError ) {
        *OpenError = TRUE;
    }

    return InitOk;
}

VOID
COMM_DEVICE::Destroy (
    )

/*++

Routine Description:

    Brings the object to a point at which it can be initialized.

Arguments:

    none

Return Value:

    none

--*/

{

    if ( _Handle != INVALID_HANDLE_VALUE ) {

        CloseHandle( _Handle );

        _Handle = INVALID_HANDLE_VALUE;

    }

#if DBG==1

    _Initialized = FALSE;

#endif

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::CommitState (
    )

/*++

Routine Description:

    Sets the port state.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if state set
                FALSE otherwise.

--*/

{

    DebugAssert( _Initialized );

    return SetCommState( _Handle, &_Dcb ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::QueryTimeOut (
    ) CONST

/*++

Routine Description:

    Queries whether infinite timeouts are enabled or not.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if infinite timeouts are enabled
                FALSE otherwise.

--*/

{
    COMMTIMEOUTS    TimeOut;

    DebugAssert( _Initialized );

    GetCommTimeouts( _Handle, &TimeOut );

    return ( (TimeOut.ReadTotalTimeoutConstant == 0) &&
             (TimeOut.WriteTotalTimeoutConstant == 0) );

}

BOOLEAN
COMM_DEVICE::ReadState (
    )

/*++

Routine Description:

    Gets the current port state.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if state read
                FALSE otherwise.

--*/

{

    DebugAssert( _Initialized );

    return GetCommState( _Handle, &_Dcb ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetBaudRate (
    IN  ULONG   BaudRate
    )

/*++

Routine Description:

    Sets the baud rate. Note that all changes take effect only after the
    CommitState() method is called.

Arguments:

    BaudRate    -   Supplies the baud rate

Return Value:

    BOOLEAN -   TRUE if valid baud rate
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    _Dcb.BaudRate = BaudRate;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetDataBits (
    IN  ULONG   DataBits
    )

/*++

Routine Description:

    Sets the number of data bits. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    DataBits    -   Supplies the number of data bits

Return Value:

    BOOLEAN -   TRUE if valid number of data bits
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    _Dcb.ByteSize = (BYTE)DataBits;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetDtrControl (
    IN  DTR_CONTROL     DtrControl
    )

/*++

Routine Description:

    Sets the DTR control. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    DtrControl  -   Supplies the DTR control value

Return Value:

    BOOLEAN -   TRUE if valid DTR control
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    if ( (DtrControl == DTR_ENABLE)     ||
         (DtrControl == DTR_DISABLE)    ||
         (DtrControl == DTR_HANDSHAKE) ) {

        _Dcb.fDtrControl = (DWORD)DtrControl;
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetIdsr (
    IN  BOOLEAN     Idsr
    )

/*++

Routine Description:

    Enables/disables DSR sensitivity

Arguments:

    Odsr    -   Supplies a flag which if TRUE, enables DSR  sensitivity
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if DSR sensitivity enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Idsr ) {
        _Dcb.fDsrSensitivity = TRUE;
    } else {
        _Dcb.fDsrSensitivity = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetOcts (
    IN  BOOLEAN     Octs
    )

/*++

Routine Description:

    Sets/resets CTS handshaking

Arguments:

    Octs    -   Supplies a flag which if TRUE, enables CTS handshaking,
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if handshaking enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Octs ) {
        _Dcb.fOutxCtsFlow = TRUE;
    } else {
        _Dcb.fOutxCtsFlow = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetOdsr (
    IN  BOOLEAN     Odsr
    )

/*++

Routine Description:

    Sets/resets DSR handshaking

Arguments:

    Odsr    -   Supplies a flag which if TRUE, enables DSR  handshaking,
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if handshaking enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Odsr ) {
        _Dcb.fOutxDsrFlow = TRUE;
    } else {
        _Dcb.fOutxDsrFlow = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetParity (
    IN  PARITY  Parity
    )

/*++

Routine Description:

    Sets the parity. Note that all changes take effect only after the
    CommitState() method is called.

Arguments:

    Parity  -   Supplies the parity value

Return Value:

    BOOLEAN -   TRUE if valid parity
                FALSE otherwise

--*/

{


    DebugAssert( _Initialized );

    DebugAssert( (Parity == COMM_PARITY_NONE)     ||  (Parity == COMM_PARITY_ODD) ||
               (Parity == COMM_PARITY_EVEN)     ||  (Parity == COMM_PARITY_MARK)    ||
               (Parity == COMM_PARITY_SPACE));

    _Dcb.Parity = (BYTE)Parity;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetRtsControl (
    IN  RTS_CONTROL     RtsControl
    )

/*++

Routine Description:

    Sets the RTS control. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    RtsControl  -   Supplies the RTS control value

Return Value:

    BOOLEAN -   TRUE if valid RTS control
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    if ( (RtsControl == RTS_ENABLE)     ||
         (RtsControl == RTS_DISABLE)    ||
         (RtsControl == RTS_HANDSHAKE)  ||
         (RtsControl == RTS_TOGGLE )
       ) {

        _Dcb.fRtsControl = (DWORD)RtsControl;
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetStopBits (
    IN  STOPBITS StopBits
    )

/*++

Routine Description:

    Sets the number of stop bits. Note that all changes take effect
    only after the CommitState() method is called.

Arguments:

    StopBits    -   Supplies the number of stop bits

Return Value:

    BOOLEAN -   TRUE if valid number of stop bits
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    DebugAssert( (StopBits == COMM_STOPBITS_1) || (StopBits == COMM_STOPBITS_15) ||
               (StopBits == COMM_STOPBITS_2) );

    _Dcb.StopBits = (BYTE)StopBits;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetTimeOut (
    IN  BOOLEAN     TimeOut
    )

/*++

Routine Description:

    Sets/resets infinite timeouts.

Arguments:

    TimeOut -   Supplies a flag which if TRUE means that infinite timeout
                is to be set. if FALSE, a 1-minute timeout is set for
                both reading and writting.

Return Value:

    BOOLEAN =   TRUE if timeout set, FALSE otherwise

--*/

{
    COMMTIMEOUTS    Time;

    DebugAssert( _Initialized );

    GetCommTimeouts( _Handle, &Time );

    if ( TimeOut ) {
        Time.ReadTotalTimeoutConstant  = 0;
        Time.WriteTotalTimeoutConstant = 0;
    } else {
        Time.ReadTotalTimeoutConstant  = DEFAULT_TIMEOUT;
        Time.WriteTotalTimeoutConstant = DEFAULT_TIMEOUT;
    }

    return SetCommTimeouts( _Handle, &Time ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetXon (
    IN  BOOLEAN     Xon
    )

/*++

Routine Description:

    Sets/resets XON/XOFF data-flow protocol.

Arguments:

    Xon -   Supplies flag which if TRUE, enables XON/XOFF protocol,
            if FALSE, disables it.

Return Value:

    BOOLEAN =   TRUE if protocol set/reset, FALSE otherwise

--*/

{
    DebugAssert( _Initialized );

    if ( Xon ) {
        _Dcb.fInX   = TRUE;
        _Dcb.fOutX  = TRUE;
    } else {
        _Dcb.fInX   = FALSE;
        _Dcb.fOutX  = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\filter.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    filter.cxx

Abstract:

    This module contains the definition for the FSN_FILTER class.
    FSN_FILTER essentially maintains the state information needed to
    establish the criteria by which other 'file' or FSNODE objects are
    compared against.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filter.hxx"
#include "wstring.hxx"

extern "C" {
    #include <string.h>
    #include <ctype.h>
}




//
//  Pattern that matches all files
//
#define MATCH_ALL_FILES     "*.*"



DEFINE_EXPORTED_CONSTRUCTOR( FSN_FILTER, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( FSN_FILTER );




ULIB_EXPORT
FSN_FILTER::~FSN_FILTER (
    )
/*++

Routine Description:

    Destructs an FSN_FILTER objtect

Arguments:

    None.

Return Value:

    None.

--*/
{
}



VOID
FSN_FILTER::Construct (
    )

/*++

Routine Description:

    Construct a FSN_FILTER by setting it's internal data to a known state.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _AttributesSet  =   FALSE;
    _FileNameSet    =   FALSE;

    //
    //  Note that even though _FileNameSet is false, we initialize
    //  the _FileName criteria with a match-all pattern. having the
    //  _FileNameSet flag set to FALSE saves us time because we don't
    //  have to do pattern-matching, since we know that everything will
    //  match anyway.
    //
    _FileName.Initialize( MATCH_ALL_FILES );
    _TimeInfoSet[FSN_TIME_MODIFIED] = FALSE;
    _TimeInfoSet[FSN_TIME_CREATED]  = FALSE;
    _TimeInfoSet[FSN_TIME_ACCESSED] = FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::Initialize (
    )

/*++

Routine Description:

    Initializes the FSN_FILTER

Arguments:

    none

Return Value:

    TRUE if the filter was succesfully initialized.

--*/

{

    return  _TimeInfo[FSN_TIME_MODIFIED].Initialize()   &&
            _TimeInfo[FSN_TIME_CREATED].Initialize()    &&
            _TimeInfo[FSN_TIME_ACCESSED].Initialize();

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::DoesNodeMatch (
    IN  PFSNODE FsNode
    )
/*++

Routine Description:

    Determine if the supplied node matches the criteria established
    in this FSN_FILTER.

Arguments:

    Node    -   Node to match

Return Value:

    TRUE if match, FALSE otherwise

--*/

{
    FSTRING  FileName;

    if (!FsNode) {
        return FALSE;
    }

    if (FilterFileName(FileName.Initialize(FsNode->_FileData.cFileName)) ||
        (FsNode->_FileData.cAlternateFileName[0] &&
         FilterFileName(FileName.Initialize(FsNode->_FileData.cAlternateFileName)))) {

        if (FilterAttributes(FsNode->QueryAttributes()) &&
            FilterTimeInfo( FsNode->GetCreationTime(),
                            FsNode->GetLastAccessTime(),
                            FsNode->GetLastWriteTime())) {

            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
FSN_FILTER::FilterAttributes (
    IN FSN_ATTRIBUTE    Attributes
    )

/*++

Routine Description:

    Determines if the supplied data matches the attribute criteria.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches attribute criteria.
    FALSE otherwise

--*/

{
    if ( _AttributesSet ) {
        return  ( ((Attributes & _AttributesAll) == _AttributesAll)         &&
                  ((_AttributesAny == 0) || (Attributes & _AttributesAny))  &&
                  !(Attributes & _AttributesNone) );
    }

    return TRUE;

}

BOOLEAN
FSN_FILTER::FilterFileName (
    IN PCWSTRING     FileName
    )

/*++

Routine Description:

    Determines if the supplied data matches the path criteria. We never
    return "." or ".." entries.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches the path criteria.
    FALSE otherwise

--*/

{
    CHNUM   ChCount;
    WCHAR   c;

    ChCount = FileName->QueryChCount();

    //
    //  We never return the "." or ".." entries
    //
    if  ( ( FileName->QueryChAt(0) == (WCHAR)'.') &&
          (     (ChCount == 1) ||
                ((FileName->QueryChAt(1) == (WCHAR)'.') && (ChCount == 2))) ) {

        return FALSE;
    }


    if ( _FileNameSet ) {
        //
        //  We only match the base portion of the name
        //
        ChCount = FileName->QueryChCount()-1;
        while (ChCount < ~0 ) {
            c = FileName->QueryChAt( ChCount );

            if ( c == (WCHAR)':' || c == (WCHAR)'\\' ) {
                break;
            }
            ChCount--;
        }
        ChCount++;

        return PatternMatch( &_FileName, 0, FileName, ChCount );
    }

    return TRUE;

}

BOOLEAN
FSN_FILTER::FilterTimeInfo (
    IN PFILETIME    CreationTime,
    IN PFILETIME    LastAccessTime,
    IN PFILETIME    LastWriteTime
    )

/*++

Routine Description:

    Determines if the supplied data matches the TimeInfo criteria.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches TimeInfo criteria.
    FALSE otherwise

--*/

{

    BOOLEAN Match = TRUE;

    if ( _TimeInfoSet[FSN_TIME_MODIFIED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_MODIFIED],
                               LastWriteTime,
                               _TimeInfoMatch[FSN_TIME_MODIFIED] );
    }

    if ( Match && _TimeInfoSet[FSN_TIME_CREATED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_CREATED],
                               CreationTime,
                               _TimeInfoMatch[FSN_TIME_CREATED] );
    }

    if ( Match && _TimeInfoSet[FSN_TIME_ACCESSED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_ACCESSED],
                               LastAccessTime,
                               _TimeInfoMatch[FSN_TIME_ACCESSED] );
    }

    return Match;

}

BOOLEAN
IsThereADot(
    IN  PCWSTRING   String
    )
{
    PATH        path;
    PWSTRING    p;
    BOOLEAN     r;

    if (!path.Initialize(String) ||
        !(p = path.QueryName())) {

        return FALSE;
    }

    r = (p->Strchr('.') != INVALID_CHNUM);

    DELETE(p);

    return r;
}


BOOLEAN
FSN_FILTER::PatternMatch (
    IN  PCWSTRING    Pattern,
    IN  CHNUM       PatternPosition,
    IN  PCWSTRING    FileName,
    IN  CHNUM       FileNamePosition
    )

/*++

Routine Description:

    Determines if a file name matches a pattern.

Arguments:

    Pattern             -   Supplies the pattern to compare against.
    PatternPosition     -   Supplies first position within pattern.
    FileName            -   Supplies the name to match. Cannot contain
                            wildcards.
    FileNamePosition    -   Supplies first position within FileName.


Return Value:

    TRUE if name matches

--*/

{
    if ( PatternPosition == Pattern->QueryChCount() ) {

        return (FileNamePosition == FileName->QueryChCount());

    }

    switch( Pattern->QueryChAt( PatternPosition )) {

    case (WCHAR)'?':
        if ((FileNamePosition == FileName->QueryChCount()) ||
            (FileName->QueryChAt( FileNamePosition ) == (WCHAR)'.' )) {
            return PatternMatch( Pattern, PatternPosition + 1,
                                 FileName, FileNamePosition );
        } else {
            return PatternMatch( Pattern, PatternPosition + 1,
                                 FileName, FileNamePosition + 1 );
        }

    case (WCHAR) '*':
        do {
            if (PatternMatch( Pattern, PatternPosition+1,
                              FileName, FileNamePosition )) {
                return TRUE;
            }
            FileNamePosition++;
        } while (FileNamePosition <= FileName->QueryChCount());

        return FALSE;

    case (WCHAR)'.':
        if (FileNamePosition == FileName->QueryChCount() &&
            !IsThereADot(FileName) &&
            Pattern->Strchr('.') == PatternPosition) {

            return PatternMatch( Pattern, PatternPosition+1,
                                 FileName, FileNamePosition );
        }

    default:
        return ( (WCHAR)CharUpper((LPTSTR)Pattern->QueryChAt( PatternPosition )) ==
                 (WCHAR)CharUpper((LPTSTR)FileName->QueryChAt( FileNamePosition ))) &&
                 PatternMatch( Pattern, PatternPosition + 1,
                               FileName, FileNamePosition + 1 );

    }
}

PFSNODE
FSN_FILTER::QueryFilteredFsnode (
    IN PCFSN_DIRECTORY  ParentDirectory,
    IN PWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Determine if the supplied system data matches the criteria established
    in this FSN_FILTER. If it is create the appropriate FSNODE (i.e. FSN_FILE
    or FSN_DIRECTORY) and return it to the caller.

Arguments:

    ParentDirectory -   Supplies pointer to the parent directory object
    FindData        -   Supplies the system data which represents a found file.

Return Value:

    Pointer to an FSNODE if the criteria was met. NULL otherwise.

--*/

{
    PFSNODE     FsNode = NULL;
    FSTRING     FileName;


    if ( (FindData != NULL)                                             &&
         ((FileName.Initialize( FindData->cFileName )          &&
           FilterFileName( &FileName ))                          ||
          (FindData->cAlternateFileName[0]                     &&
           FileName.Initialize( FindData->cAlternateFileName ) &&
           FilterFileName( &FileName )))                                &&
         FilterAttributes( (FSN_ATTRIBUTE)FindData->dwFileAttributes )  &&
         FilterTimeInfo( &FindData->ftCreationTime,
                         &FindData->ftLastAccessTime,
                         &FindData->ftLastWriteTime )
       ) {

        //
        //  The data matches the filter criteria.
        //
        if ( FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            //  We have to create a directory object
            //
            FsNode = NEW FSN_DIRECTORY;

        } else {

            //
            //  We have to create a file object
            //
            FsNode = NEW FSN_FILE;
        }

        if ( FsNode ) {

            if ( !(FsNode->Initialize( (LPWSTR)FindData->cFileName,   ParentDirectory, FindData )) ) {

                DELETE( FsNode );

            }
        }
    }

    return FsNode;
}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetAttributes (
    IN FSN_ATTRIBUTE    All,
    IN FSN_ATTRIBUTE    Any,
    IN FSN_ATTRIBUTE    None
    )

/*++

Routine Description:

    Sets the attributes criteria

Arguments:

    All     -   Supplies the mask for the ALL attributes
    Any     -   Supplies the mask for the ANY attributes
    None    -   Supplies the mask for the NONE attributes

Return Value:

    TRUE if the Attributes criteria was set.

--*/

{

    //
    //  Verify that no attribute is set in more than one mask
    //
    if ((All | Any | None) != ( All ^ Any ^ None )) {
        return FALSE;
    }

    _AttributesAll  =   All;
    _AttributesAny  =   Any;
    _AttributesNone =   None;

    return (_AttributesSet  = TRUE);

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetFileName (
    IN  PCSTR   FileName
    )

/*++

Routine Description:

    Sets the FileName criteria

Arguments:

    FileName    -   Supplies the filename to match against

Return Value:

    TRUE if the filename criteria was set.

--*/

{

    if ( _FileName.Initialize( FileName ) ) {

        return ( _FileNameSet = TRUE );

    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetFileName (
    IN  PCWSTRING    FileName
    )

/*++

Routine Description:

    Sets the FileName criteria

Arguments:

    FileName    -   Supplies the filename to match against

Return Value:

    TRUE if the filename criteria was set.

--*/

{

    if ( _FileName.Initialize( FileName ) ) {

        return ( _FileNameSet = TRUE );

    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetTimeInfo (
        IN PCTIMEINFO       TimeInfo,
        IN FSN_TIME         TimeInfoType,
        IN USHORT           TimeInfoMatch
    )

/*++

Routine Description:

    Sets a TimeInfo criteria

Arguments:

    TimeInfo        -   Supplies the timeinfo
    TimeinfoType    -   Supplies the type of timeinfo to set
    TimeInfoMatch   -   Supplies the match criteria

Return Value:

    TRUE if the timeinfo criteria was set.

--*/

{

    //
    //  Verify the parameters
    //
    if ((TimeInfoType < FSN_TIME_MODIFIED)                              ||
        (TimeInfoType > FSN_TIME_ACCESSED)                              ||
        (TimeInfoMatch == 0)                                            ||
        (TimeInfoMatch &  ~(TIME_BEFORE | TIME_AT | TIME_AFTER))        ||
        ((TimeInfoMatch & TIME_BEFORE) && (TimeInfoMatch & TIME_AFTER))
        ) {

        return FALSE;
    }

    _TimeInfo[TimeInfoType].Initialize( (TIMEINFO *)TimeInfo );

    _TimeInfoMatch[TimeInfoType]    = TimeInfoMatch;

    return (_TimeInfoSet[TimeInfoType] = TRUE);

}

BOOLEAN
FSN_FILTER::TimeInfoMatch (
    IN  PTIMEINFO       TimeInfo,
    IN  PFILETIME       FileTime,
    IN  USHORT          Criteria
    )

/*++

Routine Description:

    Determines if the supplied file time matches the criteria for a certain
    time

Arguments:

    TimeInfo    -   Supplies pointer to Timeinfo object to match against
    FileTime    -   Supplies the file time to match
    Criteria    -   Supplies the match criteria

Return Value:

    TRUE if criteria met
    FALSE otherwise

--*/

{
    USHORT Compare;

    UNREFERENCED_PARAMETER( (void)this );

    //
    //  Compare and set in range 0 - 2
    //
    Compare = (USHORT)(-TimeInfo->CompareTimeInfo( FileTime ) + 1);

    //
    //  Our crietria is a bit mask, so we transform the result of the
    //  comparison to something that we can compare our mask against.
    //
    //  i.e. {0,1,2} to {1,2,4}
    //
    Compare = (USHORT)((Compare * 2) + ( (Compare == 0) ? 1 : 0));

    return BOOLEAN( (USHORT)Compare & Criteria );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\contain.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	contain.cxx

Abstract:

	This module contains the definition for the CONTAINER class, the most
	primitive, abstract class in the container sub-hierarchy. Given it's
	abstract, prmitive nature there is minimal implementation at this point
	in the hierarchy.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "contain.hxx"


DEFINE_CONSTRUCTOR( CONTAINER, OBJECT );

CONTAINER::~CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\file.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    file.cxx

Abstract:

    This module contains the definition for the FSN_FILE class.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "system.hxx"
#include "file.hxx"
#include "timeinfo.hxx"

extern "C" {
   #include "winbasep.h"
}


DEFINE_CONSTRUCTOR( FSN_FILE, FSNODE );

DEFINE_CAST_MEMBER_FUNCTION( FSN_FILE );



ULIB_EXPORT
BOOLEAN
FSN_FILE::Copy (
    IN OUT  PPATH               NewFile,
    OUT     PCOPY_ERROR         CopyError,
    IN      ULONG               CopyFlags,
    IN      LPPROGRESS_ROUTINE  CallBack,
    IN      VOID *              Data,
    IN      PBOOL               Cancel
    ) CONST

/*++

Routine Description:

    Copies this file to another path.  If appropriate the NewFile
    will be altered to its "short" (FAT) form before the copy.

Arguments:

    NewFile         -   Supplies path of new file. All the subdirectories must
                        exist.

    CopyError       -   Supplies pointer to variable that receives the
                        error code.

    CopyFlags       -   Supplies the following flags:
                        FSN_FILE_COPY_OVERWRITE_READ_ONLY
                            - read-only files should be overwritten.
                        FSN_FILE_COPY_RESET_READ_ONLY
                            - readonly flag in the target to be reset.
                        FSN_FILE_COPY_RESTARTABLE
                            - copy is restartable.
                        FSN_FILE_COPY_COPY_OWNER
                            - copy the ownership of the file.
                        FSN_FILE_COPY_COPY_ACL
                            - copy the security information of the file

    Callback        -   Pointer to callback routine passed to CopyFileEx.

    Data            -   Pointer to opaque data passed to CopyFileEx.

    Cancel          -   Pointer to cancel flag passed to CopyFileEx.

Return Value:

    BOOLEAN -   TRUE if the file was successfully copied,
                FALSE otherwise.

--*/

{

    PCWSTR          Source;
    PCWSTR          Destination;
    BOOLEAN         CopiedOk = FALSE;
    FSN_FILE        File;
    DWORD           Attr;
    WIN32_FIND_DATA FindData;
    FSTRING         AlternateFileName;


    Source      = GetPath()->GetPathString()->GetWSTR();
    DebugPtrAssert( Source );

    if ( Source ) {

        Destination = NewFile->GetPathString()->GetWSTR();
        DebugPtrAssert( Destination );

        if ( Destination ) {

            CopiedOk = TRUE;

            //
            //  If we must overwrite read-only files, we must
            //  get the file attributes and change to writeable.
            //
            //  What we should do here is do
            //  a SYSTEM::QueryFile of the destination file and
            //  use the FILE methods for resetting the read-only
            //  attribute. However this is faster!
            //
            if ( CopyFlags & FSN_FILE_COPY_OVERWRITE_READ_ONLY ) {

                Attr = GetFileAttributes( (LPWSTR) Destination );

                if (Attr != -1 &&
                    (Attr & (FILE_ATTRIBUTE_READONLY |
                             FILE_ATTRIBUTE_HIDDEN |
                             FILE_ATTRIBUTE_SYSTEM))) {

                    Attr &= ~( FILE_ATTRIBUTE_READONLY |
                               FILE_ATTRIBUTE_HIDDEN |
                               FILE_ATTRIBUTE_SYSTEM );

                    if ( !SetFileAttributes( (LPWSTR) Destination, Attr ) ) {
                        CopiedOk = FALSE;
                    }
                }
            }

            //
            //  Copy the file
            //
            if ( CopiedOk ) {

                ULONG   flags;

                flags = (FSN_FILE_COPY_RESTARTABLE & CopyFlags) ? COPY_FILE_RESTARTABLE : 0;
                flags |= (FSN_FILE_COPY_COPY_OWNER & CopyFlags) ? PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_METADATA : 0;
                flags |= (FSN_FILE_COPY_COPY_ACL & CopyFlags) ? PRIVCOPY_FILE_SACL : 0;
                flags |= (FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION & CopyFlags) ? COPY_FILE_ALLOW_DECRYPTED_DESTINATION : 0;

#if !defined(RUN_ON_NT4)

                CopiedOk = PrivCopyFileExW(  (LPWSTR) Source,
                                             (LPWSTR) Destination,
                                             CallBack,
                                             Data,
                                             (LPBOOL) Cancel,
                                             flags) != FALSE;
#else
                CopiedOk = FALSE;
                SetLastError(ERROR_NOT_SUPPORTED);
#endif
            }

            if ( CopiedOk && (CopyFlags & FSN_FILE_COPY_RESET_READ_ONLY ) ) {

                FindData = _FileData;

                NewFile->GetPathString()->QueryWSTR( 0,
                                                     TO_END,
                                                     FindData.cFileName,
                                                     MAX_PATH );
                FindData.cAlternateFileName[ 0 ] = ( WCHAR )'\0';
                //
                // Ok, the right thing to do here is to actually query the
                // attributes of the NewFile (coz they might not exactly the
                // same as the source file, even though the Copy function
                // seems to think so) and then do a SetAttributes on the new file
                // using these. Currently the only attribute I'm concerned about
                // is FILE_ATTRIBUTE_OFFLINE which should be turned off on the
                // destination, but there might be others in the future.
                //
                Attr = GetFileAttributes((LPWSTR) FindData.cFileName);

                if (Attr != 0xFFFFFFFF) {

                    FindData.dwFileAttributes = Attr;

                } else {
                    //
                    // For some reason, couldn't get the attributes.
                    // Turn off OFFLINE bit in any case
                    //
                    FindData.dwFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
                }

                if( File.Initialize( NewFile->GetPathString(),
                                     &FindData ) ) {

                    File.ResetReadOnlyAttribute();

                } else {

                    //
                    //  The file is no longer there, we fail the copy
                    //
                    CopiedOk   = FALSE;
                    *CopyError = (COPY_ERROR) ERROR_FILE_NOT_FOUND;
                }



            } else if ( !CopiedOk && CopyError ) {

                *CopyError = (COPY_ERROR)GetLastError();

            }
        }
    }

    return CopiedOk;

}


BOOLEAN
FSN_FILE::DeleteFromDisk(
    IN BOOLEAN      Force
    )
{
    PCWSTR      FileName;
    PWSTRING    FullPath;

    UNREFERENCED_PARAMETER( Force );

    FullPath = _Path.QueryFullPathString();
    if (FullPath == NULL)
        return FALSE;

    if ( FileName = FullPath->GetWSTR() ) {

        if ( FileName[0] != (WCHAR)'\0' ) {
            return DeleteFile( (LPWSTR) FileName ) != FALSE;
        }
    }

    return FALSE;
}




ULIB_EXPORT
PFILE_STREAM
FSN_FILE::QueryStream (
    STREAMACCESS    Access,
    DWORD        Attributes
    )

/*++

Routine Description:

    Creates a FILE_STREAM object associated with the file described
    by FSN_FILE, and returns the pointer to the FILE_STREAM.


Arguments:

    Access      - Desired access to the stream

    Attributes  - Desired attributes for the stream. 0 means no special attributes.

Return Value:

    PFILE_STREAM - Returns a pointer to a FILE_STREAM, or NULL
                   if the FILE_STREAM couldn't be created.

--*/

{
    PFILE_STREAM    FileStream;

    if( IsReadOnly() && ( Access != READ_ACCESS ) ) {
        return( NULL );
    }
    FileStream = NEW( FILE_STREAM );
    DebugPtrAssert( FileStream );
    if( FileStream && !FileStream->Initialize( this, Access, Attributes ) ) {
        DELETE( FileStream );
        return( NULL );
    }
    return( FileStream );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\fsnode.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    fsnode.cxx

Abstract:

    This module contains the definition for the FSNODE class, the most
    primitive, abstract class in the file system sub-hierarchy. Given it's
    abstract, prmitive nature it contains very minimal implementation. It's
    primary intent is to support a polymorphic base class for file system
    objects.

Author:

    David J. Gilman (davegi) 02-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "dir.hxx"
#include "fsnode.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "timeinfo.hxx"
#include "system.hxx"

DEFINE_CONSTRUCTOR( FSNODE, OBJECT );

FSNODE::~FSNODE (
    )

/*++

Routine Description:

    Destroy an FSNODE.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

BOOLEAN
FSNODE::Initialize (
    IN PCWSTR           PathName,
    IN PCFSN_DIRECTORY  ParentDirectory,
    IN PWIN32_FIND_DATA FileData
    )

/*++

Routine Description:

    Initialize an FSNODE by constructing and initializing it's contained
    PATH object.

Arguments:

    PathName - Supplies a name used to initialize the contained PATH

    FileData - Points to the structure that contains all file information.

Return Value:

    BOOLEAN - TRUE if the contained PATH was succesfully constructed and
        initialized.

--*/

{

    FSTRING     wcs;

    DebugPtrAssert( PathName );
    DebugPtrAssert( ParentDirectory );
    if( ( PathName != NULL )                    &&
        ( ParentDirectory != NULL )                 &&
        _Path.Initialize((( PFSN_DIRECTORY )
        ParentDirectory )->GetPath( ), FALSE)               &&
        wcs.Initialize( (PWSTR) PathName )                      &&
        _Path.AppendBase( &wcs ) ) {
        memcpy( &_FileData, FileData, sizeof( WIN32_FIND_DATA ) );
        _Path.GetPathString( )->QueryWSTR( 0, TO_END,
                                           ( LPWSTR )_FileData.cFileName,
                                           sizeof( _FileData.cFileName )/sizeof(WCHAR));
        return( TRUE );

    } else {

        DebugAbort( "Could not construct/initialize PATH" );
        return( FALSE );

    }
}

BOOLEAN
FSNODE::Initialize (
    IN PCWSTRING        PathName,
    IN PWIN32_FIND_DATA FileData
    )

/*++

Routine Description:

    Initialize an FSNODE by constructing and initializing it's contained
    PATH object.

Arguments:

    PathName - Supplies a name used to initialize the contained PATH

    FileData - Points to the structure that contains all file information.

Return Value:

    BOOLEAN - TRUE if the contained PATH was succesfully constructed and
        initialized.

--*/

{

    DebugPtrAssert( PathName );
    if( ( PathName != NULL )            &&
        _Path.Initialize( PathName, FALSE ) ) {
        memcpy( &_FileData, FileData, sizeof( WIN32_FIND_DATA ) );
        PathName->QueryWSTR( 0, TO_END,
                            ( LPWSTR )_FileData.cFileName,
                            sizeof( _FileData.cFileName )/sizeof(WCHAR));
        return( TRUE );

    } else {

        DebugAbort( "Could not construct/initialize PATH" );
        return( FALSE );

    }
}

PFSN_DIRECTORY
FSNODE::QueryParentDirectory (
    ) CONST

/*++

Routine Description:

    Construct and return the FSN_DIRECTORY object which represents this
    FSNODE's parent.

Arguments:

    None.

Return Value:

    PFSN_DIRECTORY - Returns a pointer the the parent FSN_DIRECTORY.

--*/

{
    REGISTER PFSN_DIRECTORY pfsnDir;
    PATH                    path;
    PWSTRING                pstr;

    pstr = ((PFSNODE)this)->_Path.QueryPrefix();

    if( pstr &&
        path.Initialize( pstr ) &&
        (( pfsnDir = SYSTEM::QueryDirectory( &path )) != NULL )) {

        DELETE(pstr);
        return( pfsnDir );
    } else {

        DELETE(pstr);
        DebugAbort( "Can't construct parent directory" );
        return( NULL );
    }
}

PTIMEINFO
FSNODE::QueryTimeInfo (
    IN FSN_TIME FsnTime
    ) CONST

/*++

Routine Description:

    Query the time imformation pertaining to this FSNODE.

Arguments:

    None.

Return Value:

    PTIMEINFO - Returns a pointer to the TIMEINFO object.

--*/

{
    PTIMEINFO   TimeInfo;
    PFILETIME   DesiredFileTime;

    TimeInfo = NEW TIMEINFO;
    if (TimeInfo == NULL)
        return NULL;

    switch( FsnTime ) {

    case FSN_TIME_MODIFIED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftLastWriteTime );
        break;

    case FSN_TIME_CREATED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftCreationTime );
        break;

    case FSN_TIME_ACCESSED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftLastAccessTime );
        break;

    default:
        DebugAbort( "Invalid value of FsnTime \n" );
        return( NULL );
    }

    if( !TimeInfo->Initialize( DesiredFileTime ) ) {
        DebugAbort( "TimeInfo->Initialize() failed \n" );
        return( NULL );
    }
    return( TimeInfo );
}

BOOLEAN
FSNODE::SetTimeInfo (
    IN PCTIMEINFO       TimeInfo,
    IN FSN_TIME         TimeInfoType
    )

/*++

Routine Description:

    Change the time information of an FSNODE.

Arguments:

    TimeInfo - Pointer to a TIMEINFO object that contains the new time.

    TimeInfoType - Indicates the time to be modified (creation time,
                   last access time, or last modified time )


Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds. FALSE otherwise.


--*/

{
    PFILETIME   DesiredFileTime;
    HANDLE      FileHandle;
    BOOLEAN     TimeSet;

    DebugPtrAssert( TimeInfo );

    switch( TimeInfoType ) {

    case FSN_TIME_MODIFIED:
        DesiredFileTime = &( _FileData.ftLastWriteTime );
        break;

    case FSN_TIME_CREATED:
        DesiredFileTime = &( _FileData.ftCreationTime );
        break;

    case FSN_TIME_ACCESSED:
        DesiredFileTime = &( _FileData.ftLastAccessTime );
        break;

    default:
        DebugAbort( "Invalid value of FsnTime \n" );
        return( NULL );
    }

    *DesiredFileTime = *( TimeInfo->GetFileTime() );
    if( DesiredFileTime == NULL ) {
        return( FALSE );
    }

    FileHandle = CreateFile( &_FileData.cFileName[0],
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    TimeSet = SetFileTime( FileHandle,
                           &( _FileData.ftCreationTime ),
                           &( _FileData.ftLastAccessTime ),
                           &( _FileData.ftLastWriteTime ) ) != FALSE;

    CloseHandle( FileHandle );
    return( TimeSet );
}



BOOLEAN
FSNODE::Rename(
    IN PCPATH       NewName
    )
/*++

Routine Description:

    Renames a file and updates its FSNODE

Arguments:

    NewName - New name for the file.

Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds. FALSE otherwise.

--*/

{

    PCWSTRING   NewNameWstring;
    PCWSTR      NewNameString;


    DebugPtrAssert( NewName );
    NewNameWstring = NewName->GetPathString();
    if( NewNameWstring == NULL ) {
        return( FALSE );
    }
    NewNameString = NewNameWstring->GetWSTR();
    if( NewNameString == NULL ) {
        return( FALSE );
    }
    if( !MoveFile( _FileData.cFileName,
                   (LPWSTR) NewNameString ) ) {
        return( FALSE );
    }
    memmove( _FileData.cFileName,
             NewNameString,
             (NewNameWstring->QueryChCount() + 1) * sizeof( WCHAR ) );
    if( !_Path.Initialize( NewName ) ) {
        return( FALSE );
    }
    return( TRUE );
}


BOOLEAN
FSNODE::DeleteFromDisk(
    IN BOOLEAN      Force
    )
{
    UNREFERENCED_PARAMETER( Force );
    return( FALSE );
}



BOOLEAN
FSNODE::UpdateFsNode (
    )

/*++

Routine Description:

    Update the file attributes in this FSNODE object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the attributes were updated.

--*/

{
    HANDLE          Handle;
    WIN32_FIND_DATA Data;

    if( ( Handle = FindFirstFile( &_Path, &Data ) ) == INVALID_HANDLE_VALUE ) {
        DebugPrint( "FindFirstFile() failed \n" );
        return( FALSE );
    }
    _FileData = Data;
    FindClose( Handle );
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
FSNODE::UseAlternateName(
    )
/*++

Routine Description:

    This routine set the last component of the path for this object to
    the alternate name if it is available.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FSTRING f;

    // If there is no alternate then we are already DOS compatible.

    if (!_FileData.cAlternateFileName[0]) {
        return TRUE;
    }

    return _Path.SetName(f.Initialize(_FileData.cAlternateFileName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\filestrm.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    filestrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of FILE_STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define BUFFER_SIZE 256
#define BIG_BUFFER_SIZE (64 * 1024)

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "file.hxx"
#include "wstring.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "filestrm.hxx"


DEFINE_CONSTRUCTOR ( FILE_STREAM, BUFFER_STREAM );

DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( FILE_STREAM , ULIB_EXPORT );


FILE_STREAM::~FILE_STREAM (
    )

/*++

Routine Description:

    Destroy a FILE_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( ( _MemoryMappedFile ) && !_EmptyFile ) {
        if( _FileBaseAddress != 0 ) {
            UnmapViewOfFile( _FileBaseAddress );
        }
        if( _FileMappingHandle != NULL ) {
            CloseHandle( _FileMappingHandle );
            _FileMappingHandle = NULL;
        }
    }
    if( _ShouldCloseHandle ) {
        if( _FileHandle != NULL ) {
            CloseHandle( _FileHandle );
            _FileHandle = NULL;
        }
    }
}



VOID
FILE_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a FILE_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = FALSE;
    _FileBaseAddress = 0;
    _MemoryMappedFile = FALSE;
    _EmptyFile = FALSE;
}







BOOLEAN
FILE_STREAM::Initialize(
    IN PCFSN_FILE   File,
    IN STREAMACCESS Access,
    IN DWORD        Attributes
    )

/*++

Routine Description:

    Initializes an object of type FILE_STREAM.

Arguments:

    PCFSN_FILE - Pointer to a FSN_FILE object (will provide the filename).

    STREAMACCESS - Access allowed in the stream.


Return Value:

    None.


--*/


{
    ULONG       CreationAttributes;
    ULONG       DesiredAccess;
    ULONG       CreationDisposition;
    ULONG       ShareMode;
    PCPATH      Path;
    PCWSTRING   String;
//  PCWC_STRING String;
    PCWSTR      FileName;
    BOOLEAN     MappingFailed = FALSE;

    DebugPtrAssert( File );

    if (0 == Attributes) {
        CreationAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        CreationAttributes = Attributes;
    }

    _Access = Access;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = TRUE;
    _EmptyFile = FALSE;
    if (_Access == READ_ACCESS) {
        _MemoryMappedFile = TRUE;
    } else {
        _MemoryMappedFile = FALSE;
    }

    Path = File->GetPath();
    String = Path->GetPathString();
    FileName = String->GetWSTR();

    if( Access == READ_ACCESS ) {
        DesiredAccess = GENERIC_READ;
        CreationDisposition = OPEN_EXISTING;
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    } else if( Access == WRITE_ACCESS ) {
        DesiredAccess = GENERIC_WRITE;
        CreationDisposition = OPEN_ALWAYS;
        ShareMode = FILE_SHARE_READ;
    } else {
        DesiredAccess = GENERIC_READ | GENERIC_WRITE;
        CreationDisposition = OPEN_EXISTING;
        ShareMode = FILE_SHARE_READ;
    }

    _FileHandle = CreateFile( (LPWSTR) FileName,
                              DesiredAccess,
                              ShareMode,
                              NULL,                 // Security attributes
                              CreationDisposition,
                              CreationAttributes,
                              NULL );
    if( _FileHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    //
    //  If stream is to be created with READ_ACCESS, then map file
    //  in memory
    //

    if( _MemoryMappedFile ) {
        if( ( _FileSize = File->QuerySize() ) == 0 ) {
            //
            //  Empty file that is also read-only, cannot be mapped in
            //  memory, but we pretend we do it
            //
            _FileBaseAddress = NULL;
            _EmptyFile = TRUE;
            _EndOfFile = TRUE;
        } else {
            _FileMappingHandle = CreateFileMapping( _FileHandle,
                                                    NULL,
                                                    PAGE_READONLY,
                                                    0,
                                                    0,NULL );
            if( _FileMappingHandle == NULL ) {
                DebugPrintTrace(( "Create file mapping failed with %d\n", GetLastError() ));
                _MemoryMappedFile = FALSE;
                MappingFailed = TRUE;
            }

            if (_FileMappingHandle) {
                _FileBaseAddress = ( PBYTE )MapViewOfFile( _FileMappingHandle,
                                                           FILE_MAP_READ,
                                                           0,
                                                           0,
                                                           0 );

                if( _FileBaseAddress == NULL ) {
                    DebugPrintTrace(("map view of file failed with %d\n", GetLastError()));
                    CloseHandle( _FileMappingHandle );
                    _FileMappingHandle = NULL;
                    _MemoryMappedFile = FALSE;
                    MappingFailed = TRUE;
                }
            }
        }

        if (_MemoryMappedFile) {
            _CurrentByte = _FileBaseAddress;
            //
            // If the file is maped in memory then we don't need
            // a buffer. For this reason BUFFER_STREAM is initialized
            // with zero
            //
            return( BUFFER_STREAM::Initialize( 0 ) );
        }
    }

    if (!_MemoryMappedFile) {

        //
        // If the stream is to be created with WRITE or READ_AND_WRITE
        // access, then allocate a buffer.  If we attempted to map
        // the file and failed, it must be very large--use a big
        // buffer.
        //
        return( BUFFER_STREAM::Initialize( MappingFailed ?
                                               BIG_BUFFER_SIZE :
                                               BUFFER_SIZE ) );
    }

    return FALSE;  // Keep compiler happy.
}




BOOLEAN
FILE_STREAM::Initialize(
    IN HANDLE       FileHandle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Initializes an object of type FILE_STREAM.

Arguments:

    FileHandle - File handle.

    Access - Access allowed in the stream.


Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeded.


--*/


{
    BOOLEAN MappingFailed = FALSE;

    _Access = Access;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = FALSE;
    _FileHandle = FileHandle;

    if (_Access == READ_ACCESS) {
        _MemoryMappedFile = TRUE;
    } else {
        _MemoryMappedFile = FALSE;
    }

    //
    // If stream is to be creadted with READ access, then map file in
    // memory
    //
    if( _MemoryMappedFile ) {

        LARGE_INTEGER   x = {0,0};

        if (!SetFilePointerEx( _FileHandle, x, (PLARGE_INTEGER)&_FileSize, FILE_END )) {
            return( FALSE );
        }
        if( _FileSize == 0 ) {
            //
            //  Empty file that is also read only cannot be mapped in
            //  memory, but we pretend we do it.
            //
            _FileBaseAddress = NULL;
            _EmptyFile = TRUE;
            _EndOfFile = TRUE;
        } else {
            _FileMappingHandle = CreateFileMapping( _FileHandle,
                                                    NULL,
                                                    PAGE_READONLY,
                                                    0,
                                                    0,NULL );
            if( _FileMappingHandle == NULL ) {
                return( FALSE );
            }
            _FileBaseAddress = ( PBYTE )MapViewOfFile( _FileMappingHandle,
                                                       FILE_MAP_READ,
                                                       0,
                                                       0,
                                                       0 );

            if( _FileBaseAddress == NULL ) {
                CloseHandle( _FileMappingHandle );
                _FileMappingHandle = NULL;
                MappingFailed = TRUE;
                _MemoryMappedFile = FALSE;
            }
        }

        if (_MemoryMappedFile) {
            _CurrentByte = _FileBaseAddress;
            return( BUFFER_STREAM::Initialize( 0 ) );
        }
    }
    //
    // If stream is to be created with WRITE and READ_AND_WRITE access,
    // then allocate a buffer.  Or the file was so big that it couldn't
    // be mapped into memory.  If the mapping failed, use a big buffer.

    return( BUFFER_STREAM::Initialize( MappingFailed ?
                                           BIG_BUFFER_SIZE :
                                           BUFFER_SIZE ) );
}



BOOLEAN
FILE_STREAM::AdvanceBufferPointer(
    IN  ULONG   Offset
    )

/*++

Routine Description:

    Advance the buffer pointer by an offset. (Removes bytes from
    the buffer)

Arguments:

    Offset  - Number of bytes to remove from the buffer.

Return Value:

    BOOLEAN - Returns TRUE if the pointer was advanced, or FALSE if the
              offset was greater than the number of bytes in the buffer.


--*/

{
    if( _MemoryMappedFile ) {
        return( MovePointerPosition( (LONGLONG)Offset, STREAM_CURRENT ));
    } else {
        return( BUFFER_STREAM::AdvanceBufferPointer( Offset ) );
    }
}



BOOLEAN
FILE_STREAM::FillBuffer(
    IN  PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with bytes read from a file.
    This function will fill the buffer only if the stream has
    READ_AND_WRITE access.
    It won't do anything if the stream has READ access. (In this case
    the file was mapped in memory and the buffer was not defined).


Arguments:

    Buffer - Buffer where the bytes are to be stored.

    BufferSize - Size of the buffer.

    BytesRead - Pointer to the variable that will contain the number of bytes
                put in the buffer.


Return Value:

    BOOLEAN - Returns TRUE if the buffer was filled. FALSE otherwise.


--*/

{
    BOOLEAN Result;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesRead );

    Result = FALSE;
    if( _Access != WRITE_ACCESS ) {
        Result = ReadFile( _FileHandle,
                           Buffer,
                           BufferSize,
                           BytesRead,
                           NULL ) != FALSE;
        if( Result && ( *BytesRead == 0 ) ) {
            _EndOfFile = TRUE;
        }
    }
    return( Result );
}



PCBYTE
FILE_STREAM::GetBuffer(
    PULONG  BytesInBuffer
    )

/*++

Routine Description:

    Returns the pointer to the buffer, and the number of bytes in
    the buffer.

Arguments:

    BytesInBuffer - Points to the variable that will contain the number
                    of bytes in the buffer being returned.


Return Value:

    PCBYTE - Pointer to the buffer.

--*/


{
    if( _MemoryMappedFile ) {
        *BytesInBuffer = (ULONG)(_FileSize - ( _CurrentByte - _FileBaseAddress ));
        if (!BUFFER_STREAM::DetermineStreamType(&_CurrentByte,*BytesInBuffer))
            return NULL;
        else
            return( _CurrentByte );
    } else {
        return( BUFFER_STREAM::GetBuffer( BytesInBuffer ));
    }
}


BOOLEAN
FILE_STREAM::MovePointerPosition(
    IN LONGLONG     Position,
    IN SEEKORIGIN   Origin
    )

/*++

Routine Description:

    Sets the file pointer to a particular position.

Arguments:

    Position    - Indicates the displacement in relation to the Origin
                  where the file pointer is to be moved.

    Origin  - Defines the origin of the stream.


Return Value:

    BOOLEAN - Indicates if the seek operation succeeded.


--*/


{
    LARGE_INTEGER   NewPosition;
    ULONG           MoveMethod;
    PBYTE           Pointer;

    if( _MemoryMappedFile ) {
        //
        // The file IS mapped on memory
        //
        if( Origin == STREAM_BEGINNING ) {
            Pointer = _FileBaseAddress;
        } else if( Origin == STREAM_CURRENT ) {
            Pointer = _CurrentByte;
        } else {
            Pointer = _FileBaseAddress + _FileSize - 1;
        }
        Pointer += Position;
        if( ( Pointer < _FileBaseAddress ) ||
            ( Pointer > _FileBaseAddress + _FileSize ) ) {
            _CurrentByte = Pointer;
            _EndOfFile = ( BOOLEAN )( Pointer >= _FileBaseAddress + _FileSize );
            return( FALSE );
        }
        _CurrentByte = Pointer;
        _EndOfFile = ( BOOLEAN )( Pointer == _FileBaseAddress + _FileSize );

    } else {
        //
        // The file IS NOT mapped in memory, so access to the file
        // must be through APIs.
        //
        if( Origin == STREAM_BEGINNING ) {
            MoveMethod = FILE_BEGIN;
        } else if( Origin == STREAM_CURRENT ) {
            MoveMethod = FILE_CURRENT;
        } else {
            MoveMethod = FILE_END;
        }
        if (0 == SetFilePointerEx( _FileHandle,
                                   *(PLARGE_INTEGER)&Position,
                                   &NewPosition,
                                   MoveMethod )) {
            return( FALSE );
        }
        //
        // Since the file is buffered, we have to flush the buffer.
        // The return value of FlushBuffer can be ignored because
        // the file pointer was already moved to the right position.
        //
        BUFFER_STREAM::FlushBuffer();
        _EndOfFile = FALSE;
    }
    return( TRUE );
}



BOOLEAN
FILE_STREAM::QueryPointerPosition(
    OUT PULONGLONG      Position
    )

/*++

Routine Description:

    Returns the position of the file pointer in relation to the beginning of
    the stream.

Arguments:

    Position - Address of the variable that will contain the position of the
               file pointer.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    ULONG   BytesInBuffer;
    LARGE_INTEGER   zero = {0, 0};

    if( _MemoryMappedFile ) {
        *Position = (ULONGLONG)( _CurrentByte - _FileBaseAddress );
    } else {
        if (0 == SetFilePointerEx( _FileHandle,
                                   zero,
                                   (PLARGE_INTEGER)Position,
                                   FILE_CURRENT )) {
            return( FALSE );
        }
        //
        //  Needs to subtract the number of bytes in the buffer
        //  to obtain the position where the client thinks that
        //  the pointer is.
        //
        if (BUFFER_STREAM::GetBuffer( &BytesInBuffer ) == NULL) {
            return FALSE;
        }
        *Position -= BytesInBuffer;
    }
    return( TRUE );
}



BOOLEAN
FILE_STREAM::Read(
    OUT PBYTE   Buffer,
    IN  ULONG   BytesToRead,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Reads data from the file.

Arguments:

    Buffer  - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read from the stream.

    BytesRead   - Points to the variable that will contain the number of
                  bytes read.

Return Value:

    BOOLEAN - Indicates if the read operation succeeded. If there was no
              data to be read (end of stream), the return value will be
              TRUE (to indicate success), but NumberOfBytesRead will be
              zero.


--*/

{
    if( _MemoryMappedFile ) {
        if( ( _CurrentByte + BytesToRead ) > _FileBaseAddress + _FileSize ) {
            BytesToRead = (ULONG)(_FileBaseAddress + _FileSize - _CurrentByte);
        }
        __try {
            memcpy( Buffer, _CurrentByte, ( size_t )BytesToRead );
        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }
        *BytesRead = BytesToRead;
        _CurrentByte += BytesToRead;
        if( _CurrentByte >= _FileBaseAddress + _FileSize ) {
            _EndOfFile = TRUE;
        }
        return( TRUE );
    } else {
        return( BUFFER_STREAM::Read( Buffer, BytesToRead, BytesRead ) );
    }
}



ULIB_EXPORT
BOOLEAN
FILE_STREAM::ReadAt(
    OUT PBYTE       Buffer,
    IN  ULONG       BytesToRead,
    IN  LONGLONG    Position,
    IN  SEEKORIGIN  Origin,
    OUT PULONG      BytesRead
    )

/*++

Routine Description:

    Reads data from the file stream at a specified position.

Arguments:

    Buffer - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read from the stream.

    Position - Position in the stream where data is to be read from,
               relative to the origin of the stream.

    Origin - Indicates what position in the stream should be used
                 as origin.

    BytesRead - Points to the variable that will contain the number of
                bytes read.


Return Value:

    BOOLEAN - Indicates if the read operation succeeded. If there was no
              data to be read (end of stream), the return value will be
              TRUE (to indicate success), but BytesRead will be zero.


--*/

{
    BOOLEAN     Result;
    ULONGLONG   SavedPosition;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesRead );

    Result = FALSE;
    if( QueryPointerPosition( &SavedPosition ) &&
        MovePointerPosition( Position, Origin ) &&
        Read( Buffer, BytesToRead, BytesRead ) ) {
            DebugAssert(SavedPosition <= MAXLONGLONG);
            Result = MovePointerPosition( SavedPosition, STREAM_BEGINNING );
    }
    return( Result );
}



BOOLEAN
FILE_STREAM::Write(
    IN  PCBYTE      Buffer,
    IN  ULONG       BytesToWrite,
    OUT PULONG      BytesWritten
    )

/*++

Routine Description:

    Writes data a file stream with WRITE_ACCESS or READ_AND_WRITE_ACCESS.

Arguments:

    Buffer - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write to the stream.

    BytesWritten - Points to the variable that will contain the number of
                   bytes written.

Return Value:

    BOOLEAN - Indicates if the write operation succeeded.


--*/

{
    LONG    Offset;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    //
    // If the stream have READ_AND_WRITE_ACCESS, we have to flush the
    // buffer before we write to the file, and move the file pointer
    // to the right place.
    //
    if( _Access == READ_AND_WRITE_ACCESS ) {
        Offset = FlushBuffer();
        if( !MovePointerPosition( -Offset, STREAM_CURRENT ) ) {
            return( FALSE );
        }
    }
    return( STREAM::Write( Buffer, BytesToWrite, BytesWritten ) );
}



BOOLEAN
FILE_STREAM::WriteAt(
    IN  PBYTE       Buffer,
    IN  ULONG       BytesToWrite,
    IN  LONGLONG    Position,
    IN  SEEKORIGIN  Origin,
    OUT PULONG      BytesWritten
    )

/*++

Routine Description:

    Writes data to the stream at a specified position.

Arguments:

    Buffer - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write to the stream.

    Position - Position in the stream where data is to be written to,
               relative to the origin of the stream.

    Origin - Indicates what position in the stream should be used
                 as origin.

    BytesWritten - Points to the variable that will contain the number of
                   bytes written.

Return Value:

    BOOLEAN - Returns TRUE to indicate that the operation succeeded.
              Returns FALSE otherwise.


--*/

{
    BOOLEAN     Result;
    ULONGLONG   SavedPosition;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    Result = FALSE;
    if( QueryPointerPosition( &SavedPosition ) &&
        MovePointerPosition( Position, Origin ) &&
        Write( Buffer, BytesToWrite, BytesWritten ) ) {
            Result = MovePointerPosition( SavedPosition, STREAM_BEGINNING );
    }
    return( Result );
}


BOOLEAN
FILE_STREAM::EndOfFile(
    ) CONST

/*++

Routine Description:

    Informs the caller if end of file has occurred. End of file happens
    when all bytes from the file were read, and there is no more bytes
    to read (the API returns zero bytes read).

Arguments:

    None.

Return Value:

    A boolean value that indicates if end of file was detected.


--*/


{
    return( _EndOfFile );
}



STREAMACCESS
FILE_STREAM::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the type of access of the file stream

Arguments:

    None.

Return Value:

    The stream access.


--*/


{
    return( _Access );
}



HANDLE
FILE_STREAM::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the file handle

Arguments:

    None.

Return Value:

    The file handle.


--*/


{
    return( _FileHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\dir.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    dir.cxx

Abstract:

    This module contains the defintion for the FSN_DIRECTORY class.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "system.hxx"

BOOLEAN
IsDot (
    IN WCHAR *p
    );

INLINE
BOOLEAN
IsDot (
    IN WCHAR *p
    )
/*++

Routine Description:

    Determines if a name is a '.' or '..' entry in a directory.

    It is only intended to be used when processing a WIN32_FIND_DATA
    structure.

Arguments:

    p   -   Supplies pointer to char array

Return Value:

    BOOLEAN - Returns TRUE if the name is a '.' or '..' entry.

--*/
{


    return ( (p[0] == '.' && p[1] == '\0') ||
             (p[0] == '.' && p[1] == '.' && p[2] == '\0' ) );
}




DEFINE_CONSTRUCTOR( FSN_DIRECTORY, FSNODE );

DEFINE_CAST_MEMBER_FUNCTION( FSN_DIRECTORY );

BOOLEAN
FSN_DIRECTORY::Copy (
    IN  PFSN_FILTER             FsnFilter,
    IN  PCFSN_DIRECTORY         DestinationDir,
    IN  BOOLEAN                 Recurse,
    IN  BOOLEAN                 OverWrite
    ) CONST

/*++

Routine Description:

    Copies a set of FSNODEs to a destination directory.

Arguments:

    FsnFilter       - Supplies a pointer top a constant FSN_FILTER, which
        describes the set of FSNODEs to be copied.

    DestinationDir  - Supplies a pointer to a constant FSN_DIRECTORY which is
        the destination of the copy.

    Recurse         - Supplies a flag which if TRUE causes Copy to perform
        a recursive copy if it encounters a FSN_DIRECTORY.

    OverWrite       - Supplies a flag which if TRUE, allows Copy to over
        write an existing destination file.

Return Value:

    BOOLEAN - Returns TRUE if the entire Copy operation was succesful.

--*/


{

    ULONG               Files       = 0;
    DWORD               ErrorStatus = 0;
    PARRAY              SrcFiles;
    PARRAY_ITERATOR     Iterator;
    PPATH               SourcePath              = NULL;
    LPWSTR              SourcePathString        = NULL;
    ULONG               SourceBufferSize        = 0;
    PPATH               DestinationPath         = NULL;
    LPWSTR              DestinationPathString   = NULL;
    ULONG               DestinationBufferSize   = 0;
    ULONG               BufferSize;
    PFSNODE             FsNode;
    PWSTRING            Name;
    BOOLEAN             ReturnValue = TRUE;
    PFSN_DIRECTORY      SourceDirectory         = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;

    DebugPtrAssert( FsnFilter );
    DebugPtrAssert( DestinationDir );
    if ( //
         // Verify arguments
         //
         ( FsnFilter != NULL )                                                  &&
         ( DestinationDir != NULL )                                             &&
         //
         // Get array of nodes for files in the directory
         //
         (( SrcFiles = QueryFsnodeArray( FsnFilter )) != NULL )                     &&
         //
         // Get an iterator for processing the nodes
         //
         (( Iterator = ( PARRAY_ITERATOR ) SrcFiles->QueryIterator( )) != NULL )    &&
         //
         // Get paths
         //
         ((SourcePath = NEW PATH) != NULL)                                          &&
         ((DestinationPath = DestinationDir->GetPath( )->QueryFullPath( )) != NULL) ) {

        //
        // For each FSNODE in the ARRAY either:
        //
        //  - set up and call Copy on the sub directory (based on Recurse)
        //  - or copy the file
        //
        while (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL ) {

            //
            //  Append the name portion of the source to the
            //  destination path.
            //
            if ( ((Name = FsNode->QueryName()) == NULL) ||
                 !DestinationPath->AppendBase( Name ) ) {
                break;
            }


            //
            //  Get paths and strings
            //
            SourcePath->Initialize( FsNode->GetPath() );

            BufferSize = (SourcePath->GetPathString()->QueryChCount() + 1) * 2;
            if ( BufferSize > SourceBufferSize ) {
                if (SourceBufferSize == 0) {
                    SourcePathString = (LPWSTR)MALLOC((size_t)BufferSize);
                } else {
                    SourcePathString = (LPWSTR)REALLOC( SourcePathString, (size_t)BufferSize);
                }
                SourceBufferSize = BufferSize;
            }

            BufferSize = (DestinationPath->GetPathString()->QueryChCount() + 1) * 2;
            if ( BufferSize > DestinationBufferSize ) {
                if (DestinationBufferSize == 0) {
                    DestinationPathString = (LPWSTR)MALLOC((size_t)BufferSize);
                } else {
                    DestinationPathString = (LPWSTR)REALLOC( DestinationPathString, (size_t)BufferSize);
                }
                DestinationBufferSize = BufferSize;
            }

            if ( (SourcePathString == NULL) || (DestinationPathString == NULL)) {
                break;
            }

            SourcePath->GetPathString()->QueryWSTR(0,
                                                   TO_END,
                                                   SourcePathString,
                                                   SourceBufferSize/sizeof(WCHAR));
            DestinationPath->GetPathString()->QueryWSTR(0,
                                                        TO_END,
                                                        DestinationPathString,
                                                        DestinationBufferSize/sizeof(WCHAR));

            if ( FsNode->IsDirectory() ) {

                //
                //  Copy directory
                //

                CreateDirectoryEx( SourcePathString, DestinationPathString, NULL );

                if ( Recurse ) {

                    if ( ((SourceDirectory = SYSTEM::QueryDirectory( SourcePath )) != NULL)  &&
                         ((DestinationDirectory = SYSTEM::QueryDirectory( DestinationPath )) != NULL)) {

                        if ( SourceDirectory->Copy( FsnFilter,
                                                    DestinationDirectory,
                                                    Recurse,
                                                    OverWrite )) {

                            DELETE( SourceDirectory );
                            DELETE( DestinationDirectory );

                            SourceDirectory         =   NULL;
                            DestinationDirectory    =   NULL;

                        } else {

                            break;

                        }

                    } else {

                        break;

                    }

                }

            } else {

                //
                //  Copy file
                //
                if (!CopyFile( SourcePathString, DestinationPathString, !OverWrite)) {

                    ReturnValue = FALSE;
                    break;
                }

            }

            DELETE( Name );

            DestinationPath->TruncateBase();

        }


        if (SourcePathString != NULL) {
            FREE( SourcePathString );
        }

        if (DestinationPathString != NULL) {
            FREE( DestinationPathString );
        }

        if (SourceDirectory != NULL ) {
            DELETE( SourceDirectory );
        }

        if (DestinationDirectory != NULL) {
            DELETE( DestinationDirectory );
        }

        DELETE( DestinationPath );
        DELETE( SourcePath );
        DELETE( Iterator );
        DELETE( SrcFiles );

    }

    return ReturnValue;

}

ULIB_EXPORT
PFSN_DIRECTORY
FSN_DIRECTORY::CreateDirectoryPath (
    IN  PCPATH  Path
    ) CONST

/*++

Routine Description:

    Creates all the directories along a path and returns the directory
    of the deepest one.

Arguments:

    Path    -   Supplies pointer to the path

Return Value:

    PFSN_DIRECTORY  -   Returns pointer to the directory object of the
                        deepest directory created.

--*/

{

    PARRAY          DesiredComponentArray;
    PARRAY          ExistingComponentArray;
    PITERATOR       IteratorDesired;
    PITERATOR       IteratorExisting;
    PPATH           PathToCreate;
    PWSTRING        DesiredComponent;
    PWSTRING        ExistingComponent;
    BOOLEAN         OkSoFar     = TRUE;
    PFSN_DIRECTORY  Directory   = NULL;
    LPWSTR          Buffer      = NULL;
    ULONG           BufferSize  = 0;
    ULONG           Size;


    DebugPtrAssert( Path );

    //
    //  Split both paths in their component parts
    //
    DesiredComponentArray  = Path->QueryComponentArray();
    ExistingComponentArray = GetPath()->QueryComponentArray();

    DebugPtrAssert( DesiredComponentArray );
    DebugPtrAssert( ExistingComponentArray );

    if ( DesiredComponentArray && ExistingComponentArray ) {

        IteratorDesired  = DesiredComponentArray->QueryIterator();
        IteratorExisting = ExistingComponentArray->QueryIterator();

        DebugPtrAssert( IteratorDesired );
        DebugPtrAssert( IteratorExisting );

        if ( IteratorDesired && IteratorExisting ) {

            //
            //  Make sure that the existing components are a subset of the
            //  desired components.
            //
            while (TRUE) {

                if (!(ExistingComponent = (PWSTRING)(IteratorExisting->GetNext()))) {
                    break;
                }

                DesiredComponent  = (PWSTRING)(IteratorDesired->GetNext());

                DebugPtrAssert( DesiredComponent );

                if ( !DesiredComponent ||  ( *DesiredComponent != *ExistingComponent )) {

                    DebugAssert( FALSE );
                    OkSoFar = FALSE;
                    break;

                }
            }

            if ( OkSoFar ) {

                //
                //  Now we can start creating directories
                //
                // PathToCreate = GetPath()->QueryFullPath();
                PathToCreate = GetPath()->QueryPath();

                if (PathToCreate) {
                    while ( DesiredComponent = (PWSTRING)(IteratorDesired->GetNext()) ) {

                        //
                        //  One directory to create
                        //
                        PathToCreate->AppendBase( DesiredComponent, TRUE );

                        Size = (PathToCreate->GetPathString()->QueryChCount() + 1) * 2;
                        if ( Size > BufferSize ) {
                            if ( Buffer ) {
                                Buffer = (LPWSTR)REALLOC( Buffer, (unsigned int)Size );
                            } else {
                                Buffer = (LPWSTR)MALLOC( (unsigned int)Size );
                            }
                            if (Buffer == NULL) {
                                OkSoFar = FALSE;
                                break;
                            }
                            DebugPtrAssert( Buffer );
                            BufferSize = Size;
                        }
                        PathToCreate->GetPathString()->QueryWSTR( 0,
                                                                  TO_END,
                                                                  (LPWSTR)Buffer,
                                                                  BufferSize/sizeof(WCHAR) );

                        OkSoFar = CreateDirectory( (LPWSTR)Buffer, NULL ) != FALSE;

                        // DebugAssert( OkSoFar );

                    }

                    if ( OkSoFar ) {

                        //
                        //  Create directory object
                        //
                        Directory = SYSTEM::QueryDirectory( Path );
                    }

                    DELETE( PathToCreate );
                }
            }
        }

        DELETE( IteratorDesired );
        DELETE( IteratorExisting );

    }

    DesiredComponentArray->DeleteAllMembers();
    ExistingComponentArray->DeleteAllMembers();

    DELETE( DesiredComponentArray );
    DELETE( ExistingComponentArray );

    return Directory;

}

ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::DeleteDirectory (
    )

/*++

Routine Description:

    Deltes this directory and everything underneath it.

    Note that after this, the directory object must be deleted!

Arguments:

    none

Return Value:

    BOOLEAN -   Return TRUE if everything was deleted

--*/

{

    FSN_FILTER  Filter;
    PARRAY      Array;
    ULONG       Size;
    LPWSTR      Buffer      = NULL;
    ULONG       BufferSize  = 0;
    BOOLEAN     Ok          = TRUE;
    PITERATOR   Iterator;
    PFSNODE     FsNode;

    Filter.Initialize();
    Filter.SetFileName( "*.*" );

    Array = QueryFsnodeArray( &Filter );

    if ( Array ) {

        Iterator = ( PARRAY_ITERATOR ) Array->QueryIterator( );
        DebugPtrAssert( Iterator );

        //
        //  Delete everything underneath us.
        //
        while ( Ok && (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL )) {

            if ( FsNode->IsDirectory() ) {

                //
                //  Directory, just recurse.
                //
                Ok = ((PFSN_DIRECTORY)FsNode)->DeleteDirectory();

            } else {

                //
                //  File, delete it.
                //
                Size = (FsNode->GetPath()->GetPathString()->QueryChCount() + 1) * 2;
                if (Size > BufferSize) {
                    if (Buffer == NULL) {
                        Buffer = (LPWSTR)MALLOC((unsigned int)Size );
                    } else {
                        Buffer = (LPWSTR)REALLOC(Buffer, (unsigned int)Size );
                    }
                    if (Buffer == NULL) {
                        DebugPtrAssert(Buffer);
                        DELETE(Array);
                        return FALSE;
                    }
                    BufferSize = Size;
                }

                FsNode->GetPath()->GetPathString()->QueryWSTR( 0,
                                                               TO_END,
                                                               Buffer,
                                                               BufferSize/sizeof(WCHAR) );

                Ok = DeleteFile( (LPWSTR)Buffer ) != FALSE;

            }
        }

        DELETE( Array );

    }

    if ( Ok ) {
        //
        //  Commit suicide
        //
        Size = (GetPath()->GetPathString()->QueryChCount() + 1) * 2;
        if (Size > BufferSize) {
            if (Buffer == NULL) {
                Buffer = (LPWSTR)MALLOC( (unsigned int)Size );
            } else {
                Buffer = (LPWSTR)REALLOC(Buffer, (unsigned int)Size );
            }
            if (Buffer == NULL) {
                DebugPtrAssert(Buffer);
                return FALSE;
            }
            BufferSize = Size;
        }

        GetPath()->GetPathString()->QueryWSTR( 0,
                                               TO_END,
                                               Buffer,
                                               BufferSize/sizeof(WCHAR) );

        Ok = RemoveDirectory( (LPWSTR)Buffer ) != FALSE;

        FREE( Buffer );

    }

    return Ok;

}

ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::IsEmpty (
    ) CONST

/*++

Routine Description:

    Determines if a directory is empty (A directory is empty if has
    no entries other than "." and ".."

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if directory is empty
                FALSE otherwise

--*/

{


    PATH            Path;
    FSTRING         Base;
    WIN32_FIND_DATA FindData;
    HANDLE          Handle;
    BOOLEAN         IsEmpty;
    PFSN_DIRECTORY  SubDirectory;
    PATH            SubPath;
    DSTRING         SubBase;
    BOOLEAN         SubEmpty;


    IsEmpty = FALSE;

    if ( Path.Initialize( GetPath() )       &&
         Base.Initialize((PWSTR) L"*.*")    &&
         Path.AppendBase( &Base ) ) {

        //
        //  Get the first entry
        //
        Handle = FindFirstFile( &Path, &FindData );

        if ( Handle == INVALID_HANDLE_VALUE ) {

            //
            //  If we fail we assume that the directory
            //  is empty.
            //
            IsEmpty = TRUE;

        } else {

            if ( IsDot(FindData.cFileName) ) {

                while ( TRUE ) {

                    if ( !FindNextFile( Handle, &FindData ) ) {
                        IsEmpty = TRUE;
                        break;
                    }

                    if ( !IsDot( FindData.cFileName ) ) {

                        // If this file is a sub-directory check to
                        // see whether or not it is empty.  If it is
                        // empty then we still do not know whether or
                        // not this directory is empty.

                        if (FindData.dwFileAttributes &
                            FILE_ATTRIBUTE_DIRECTORY) {

                            if (!SubPath.Initialize(GetPath()) ||
                                !SubBase.Initialize(FindData.cFileName) ||
                                !SubPath.AppendBase(&SubBase) ||
                                !(SubDirectory =
                                  SYSTEM::QueryDirectory(&SubPath))) {

                                break;
                            }

                            SubEmpty = SubDirectory->IsEmpty();
                            DELETE(SubDirectory);

                            if (!SubEmpty) {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            }

            FindClose( Handle );
        }
    } else {

        DebugAssert( FALSE );

    }

    return IsEmpty;

}


ULIB_EXPORT
PARRAY
FSN_DIRECTORY::QueryFsnodeArray (
    IN PFSN_FILTER  FsnFilter
    ) CONST

/*++

Routine Description:

    Construct and fill an ARRAY object with FSNODE object that meet the
    criteria maintained by the supplied FSN_FILTER.

Arguments:

    FsnFilter - Supplies a constant pointer to an FS_FILTER which will be
        used to determine if a found 'file' should be constructed and
        included in the ARRAY.

Return Value:

    PARRAY - Returns a pointer to an ARRAY of FSNODEs. If no 'file' meets
        the FSN_FILTER criteria returns a pointer to an empy array.
        Returns NULL if the array couldn't be constructed or initialized.

--*/

{
    REGISTER PARRAY             parr;
    REGISTER PFSNODE            pfsn;
    WIN32_FIND_DATA             ffd;
    PATH                        Path;
    HANDLE                      hndl;
    PFSN_FILTER                 Filter;
    BOOLEAN                     DeleteFilter;
    DWORD                       FindNextError;
    BOOLEAN                     CheckError = TRUE;


    //
    //  If a filter was not provided, we use a default match-all
    //  filter.
    //
    if ( FsnFilter ) {

        Filter       = FsnFilter;
        DeleteFilter = FALSE;

    } else {

        Filter = NEW FSN_FILTER;
        DebugPtrAssert( Filter );
        if (!Filter) {
            return NULL;
        }
        Filter->Initialize();
        DeleteFilter = TRUE;
    }

    //
    // Initialize the ARRAY pointer
    //

    parr = NULL;

    //
    // Append the filter name to this DIRECTORY's name
    //

    Path.Initialize( (PCPATH)&_Path, TRUE);
    Path.AppendBase( Filter->GetFileName() );

    //
    // If there are found files and the ARRAY is succesfully
    // constructed and initialized...
    //

    if((( parr = NEW ARRAY ) != NULL )                                      &&
    ( parr->Initialize( ))) {

        if( ( hndl = FindFirstFile( &Path, &ffd )) != INVALID_HANDLE_VALUE ) {
            //
            // if there is at least one file that meetes the filter
            // criteria, put the fsnodes in the array. Otherwise, leave
            // the array empty
            //
            do {

                //
                // If the found 'file' meets the filter criteria, put the
                // returned FSNODE in the ARRAY
                //

                if(( pfsn = Filter->QueryFilteredFsnode( this, &ffd )) != NULL ) {

                    //
                    // If the FSNODE can not be put in the ARRAY
                    // delete it and exit the loop.
                    //

                    if( ! ( parr->Put( pfsn ))) {
                        DELETE( pfsn );
                        CheckError = FALSE;
                        break;
                    }
                }

            //
            // Loop while there are still more files to find.
            //

            } while( FindNextFile( hndl, &ffd ));

            if (CheckError)  {
            
                FindNextError = GetLastError();

                if ((ERROR_NO_MORE_FILES != FindNextError) && (ERROR_SUCCESS != FindNextError))  {

                    //
                    //  We can't exit here,   because we don't know who's calling
                    //  us,  etc.  Without major changes to percolate an error back
                    //  up,  the best we can do is display an error.
                    //
                    
                    SYSTEM::DisplaySystemError( FindNextError, FALSE);
                }
            }

            //
            // Close the search.
            //

            FindClose( hndl );

        }
        //
        // There is no file that meets the filter criteria.
        // Return pointer to an empty array
        //

    } else {

        //
        // There were no found files or the construction or
        // initialization of the ARRAY failed, delete the ARRAY in case
        // it was constructed and setup to return a NULL pointer i.e. no ARRAY
        //

        if( parr != NULL ) {
            DELETE( parr );
        }
        parr = NULL;
    }

    //
    // Return the pointer to the ARRAY (which may be NULL)
    //

    if ( DeleteFilter ) {
        DELETE( Filter );
    }

    return( parr );
}



ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::Traverse (
    IN      PVOID                   Object,
    IN      PFSN_FILTER             FsnFilter,
    IN  OUT PPATH                   DestinationPath,
    IN      CALLBACK_FUNCTION       CallBackFunction
    ) CONST

/*++

Routine Description:

    Traverses a directory, calling the callback function for each node
    (directory of file) visited.  The traversal may be finished
    prematurely when the callback function returnes FALSE.

    The destination path is modified to reflect the directory structure
    being traversed.

Arguments:

    Object          - Supplies pointer to the object

    FsnFilter       - Supplies a pointer to the filter that determines the
                      nodes to be visited.

    DestinationPath - Supplies pointer to path to be used with the callback
                      function.

    CallBackFunction- Supplies pointer to the function to be called back
                      with the node to be visited.

Return Value:

    BOOLEAN - Returns TRUE if the entire traversal was successful.

--*/


{

    PARRAY              SrcFiles;
    PARRAY_ITERATOR     Iterator;
    PFSNODE             FsNode;
    PPATH               SubDirectoryPath    = NULL;
    PFSN_DIRECTORY      SubDirectory        = NULL;
    BOOLEAN             StatusOk            = TRUE;
    PWSTRING Name;


    DebugPtrAssert( FsnFilter );
    DebugPtrAssert( CallBackFunction );

    //
    // Get array of nodes for files in the directory
    //
    SrcFiles = QueryFsnodeArray( FsnFilter );
    DebugPtrAssert( SrcFiles );

    //
    // Get an iterator for processing the nodes
    //
    Iterator = ( PARRAY_ITERATOR ) SrcFiles->QueryIterator( );
    DebugPtrAssert( Iterator );

    //
    // Get path
    //
    SubDirectoryPath = NEW PATH;
    DebugPtrAssert( SubDirectoryPath );


    //
    //  Visit all the nodes in the array. We recurse if the node is
    //  a directory.
    //
    while ( StatusOk && (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL )) {


        if ( DestinationPath ) {

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = FsNode->QueryName();
            DebugPtrAssert( Name );

            StatusOk = DestinationPath->AppendBase( Name );
            DebugAssert( StatusOk );

            DELETE( Name );
        }

        //
        //  Visit the node
        //
        if ( StatusOk = CallBackFunction( Object, FsNode, DestinationPath )) {

            if ( FsNode->IsDirectory() ) {

                //
                //  Recurse
                //
                SubDirectoryPath->Initialize( FsNode->GetPath() );

                SubDirectory = SYSTEM::QueryDirectory( SubDirectoryPath );

                DebugPtrAssert( SubDirectory );

                StatusOk = SubDirectory->Traverse( Object,
                                                   FsnFilter,
                                                   DestinationPath,
                                                   CallBackFunction );
                DELETE( SubDirectory );

            }

        }

        if ( DestinationPath ) {

            //
            //  Restore the destination path
            //
            DestinationPath->TruncateBase();
        }
    }

    DELETE( SrcFiles );
    DELETE( Iterator );
    DELETE( SubDirectoryPath );

    return StatusOk;
}


ULIB_EXPORT
PFSNODE
FSN_DIRECTORY::GetNext (
    IN OUT HANDLE       *hndl,
    OUT PDWORD          error
    )

/*++

Routine Description:

    This routine returns the files and directories found within the
    directory object.

Arguments:

    hndl - Supplies & receives a handle of the directory object.
           Initialize to NULL to start with.

    error - if result is NULL,  receives win32 error code (for
            end of directory will be ERROR_NO_MORE_FILES)

Return Value:

    NULL if error or end of directory

--*/

{
    REGISTER PFSNODE            pfsn;
    WIN32_FIND_DATA             ffd;
    PATH                        Path;
    FSN_FILTER                  Filter;

    if (!Filter.Initialize()) {
        return NULL;
    }

    //
    // Append the filter name to this DIRECTORY's name
    //

    Path.Initialize((PCPATH)&_Path, TRUE);
    Path.AppendBase(Filter.GetFileName());

    *error = ERROR_SUCCESS;
    
    if (*hndl == NULL) {
        if (INVALID_HANDLE_VALUE ==
            (*hndl = FindFirstFile(&Path, &ffd))) {
            *error = GetLastError();
            return NULL;
        }
    } else {
        if (!FindNextFile(*hndl, &ffd)) {
            *error = GetLastError();
            FindClose(*hndl);
            return NULL;
        }
    }

    do {
        if((pfsn = Filter.QueryFilteredFsnode(this, &ffd)) != NULL) {
            return pfsn;
        }
    } while (FindNextFile(*hndl, &ffd));

    *error = GetLastError();

    FindClose(*hndl);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\hmem.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    hmem.cxx

Abstract:

    Implementation of HMEM class.
    
Author:

    Norbert P. Kusters (norbertk) 26-Nov-90

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "hmem.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( HMEM, MEM, ULIB_EXPORT );

VOID
HMEM::Construct (
    )
/*++

Routine Description:

    The is the contructor of HMEM.  It initializes the private data
    to reasonable default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    _real_buf = NULL;
    _buf = NULL;
}


ULIB_EXPORT
HMEM::~HMEM(
    )
/*++

Routine Description:

    Destructor for HMEM.  Frees up any memory used.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
HMEM::Initialize(
    )
/*++

Routine Description:

    This routine initializes HMEM to an initial state.  All pointers or
    information previously aquired from this object will become invalid.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    return TRUE;
}


ULIB_EXPORT
PVOID
HMEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine acquires the memory resources of this object for
    the client to use.  'Size' bytes of data are guaranteed by
    this routine or this routine will return NULL.  After one call
    of 'Acquire' has succeeded, all subsequent calls will return the
    same memory, provided that the Size requested is within bounds
    specified in the first successful call.  The first successful call
    will dictate the size and location of the memory which will be
    available by calls to 'QuerySize' and 'GetBuf' respectively.

    A call to Initialize will invalidate all memory previously granted
    by this object and enable the next call to Acquire to specify
    any size.

Arguments:

    Size            - The number of bytes of memory expected.
    AlignmentMask   - Supplies the alignment required on the memory.

Return Value:

    A valid pointer to 'Size' bytes of memory or NULL.

--*/
{
    if (_buf) {
        if (Size <= _size && !(((ULONG_PTR) _buf)&AlignmentMask)) {
            return _buf;
        } else {
            return NULL;
        }
    }

    _size = Size;

    if (!(_real_buf = MALLOC((UINT) (_size + AlignmentMask)))) {
        return NULL;
    }

    _buf = (PVOID) ((ULONG_PTR) ((PCHAR) _real_buf + AlignmentMask) &
                            (~(ULONG_PTR)AlignmentMask));

    return _buf;
}


ULIB_EXPORT
BOOLEAN
HMEM::Resize(
    IN  ULONG   NewSize,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This method reallocates the object's buffer to a larger
    chunk of memory.

Arguments:

    NewSize         -- supplies the new size of the buffer.
    AlignmentMask   -- supplies the alignment requirements on the memory.

Return Value:

    TRUE upon successful completion.

Notes:

    This method allocates a new buffer, copies the appropriate
    amount of data to it, and then frees the old buffer.  Clients
    who use Resize must avoid caching pointers to the memory, but
    must use GetBuf to find out where the memory is.

    If NewSize is smaller than the current buffer size, we keep
    the current buffer.

    If this method fails, the object is left unchanged.

--*/
{
    PVOID NewBuffer;
    PVOID NewRealBuffer;

    // First, check to see if our current buffer is big enough
    // and has the correct alignment
    // to satisfy the client.

    if( _buf &&
        NewSize <= _size &&
        !(((ULONG_PTR) _buf)&AlignmentMask)) {

            return TRUE;
    }

    // We need to allocate a new chunk of memory.

    if( (NewRealBuffer = MALLOC((UINT) (NewSize + AlignmentMask))) == NULL ) {

        return FALSE;
    }

    NewBuffer = (PVOID) ((ULONG_PTR) ((PCHAR) NewRealBuffer + AlignmentMask) &
                                 (~(ULONG_PTR)AlignmentMask));

    // Copy data from the old buffer to the new.  Since we know
    // that NewSize is greater than _size, we copy _size bytes.

    memset( NewBuffer, 0, (UINT) NewSize );
    memcpy( NewBuffer, _buf, (UINT) min(_size, NewSize) );

    // Free the old buffer and set the object's private variables.

    FREE( _real_buf );
    _real_buf = NewRealBuffer;
    _buf = NewBuffer;
    _size = NewSize;

    return TRUE;
}


VOID
HMEM::Destroy(
    )
/*++

Routine Description:

    This routine frees the memory of a previous call to Acquire thus
    invalidating all pointers to that memory and enabling future
    Acquires to succeed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    if (_real_buf) {
        FREE(_real_buf);
        _real_buf = NULL;
    }
    _buf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\iterator.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	iterator.cxx

Abstract:

	This contains the definitions for the non-inline member functions
	for the abstract ITERATOR class. The only interesting aspect of this
	implementation is that the destructor decrements the iterator count in
	it's associated CONTAINER. This count, increment by the CONTAINER when
	the ITERATOR is constructed, allows the associated CONTAINER to watch
	for outstanding ITERATORs when it is destroyed - a situation which is
	dangerous and surely a bug.

Author:

	David J. Gilman (davegi) 03-Dec-1990

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( ITERATOR, OBJECT );

ITERATOR::~ITERATOR(
    )
{
}


POBJECT
ITERATOR::FindNext(
    IN      PCOBJECT    Key
    )
{
    POBJECT p;

    for (p = GetNext(); p; p = GetNext()) {
        if (!Key->Compare(p)) {
            break;
        }
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\list.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "list.hxx"
#include "listit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( LIST, SEQUENTIAL_CONTAINER, ULIB_EXPORT );

VOID
LIST::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


VOID
LIST::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


ULIB_EXPORT
LIST::~LIST(
    )
/*++

Routine Description:

    Destructor for LIST.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
LIST::Initialize(
    )
/*++

Routine Description:

    This routine initializes the object to a valid initial state.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_mem_block_mgr.Initialize(sizeof(OBJECT_LIST_NODE))) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULONG
LIST::QueryMemberCount(
    ) CONST
/*++

Routine Description:

    This routine computes the number of members in the list.

Arguments:

    None.

Return Value:

    The number of members in the list.

--*/
{
    return _count;
}


ULIB_EXPORT
BOOLEAN
LIST::Put(
	IN  POBJECT	Member
	)
/*++

Routine Description:

    This routine adds a new member to the end of the list.

Arguments:

    Member  - Supplies the element to add to the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_tail) {

        if (!(_head = _tail = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
            return FALSE;
        }

        _head->next = _head->prev = NULL;
        _head->data = Member;

        _count++;
        return TRUE;
    }

    if (!(_tail->next = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _tail->next->prev = _tail;
    _tail = _tail->next;

    _tail->next = NULL;
    _tail->data = Member;

    _count++;
    return TRUE;
}


POBJECT
LIST::Remove(
	IN OUT  PITERATOR   Position
	)
/*++

Routine Description:

    This routine removes the element at the specified position from the
    list.  The iterator is left pointing at the following element in
    the list.

Arguments:

    Position    - Supplies a pointer to the element to remove.

Return Value:

    A pointer to the element removed.

--*/
{
    POBJECT_LIST_NODE   p;
    PLIST_ITERATOR      piter;
    POBJECT             pobj;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    if (!(piter = (PLIST_ITERATOR) Position) || !(p = piter->_current)) {
        return NULL;
    }

    if (p->next) {
        p->next->prev = p->prev;
    }

    if (p->prev) {
        p->prev->next = p->next;
    }

    if (_head == p) {
        _head = p->next;
    }

    if (_tail == p) {
        _tail = p->prev;
    }

    piter->_current = p->next;

    pobj = p->data;

    _mem_block_mgr.Free(p);

    _count--;

    return pobj;
}


ULIB_EXPORT
PITERATOR
LIST::QueryIterator(
	) CONST
/*++

Routine Description:

    This routine returns an iterator for this list.

Arguments:

    None.

Return Value:

    A valid iterator.

--*/
{
    PLIST_ITERATOR  p;

    if (!(p = NEW LIST_ITERATOR)) {
        return NULL;
    }

    p->Initialize(this);

    return p;
}


ULIB_EXPORT
BOOLEAN
LIST::Insert(
    IN OUT  POBJECT     Member,
    IN OUT  PITERATOR   Position
    )
/*++

Routine Description:

    This routine inserts a new element before the specified position.
    The 'Position' continues to point to the same element.

Arguments:

    Member      - Supplies the element to insert.
    Position    - Supplies the point at which to insert this member.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    POBJECT_LIST_NODE   p, current;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    current = ((PLIST_ITERATOR) Position)->_current;

    if (!current) {
        return Put(Member);
    }

    if (!(p = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _count++;
    p->data = Member;

    if (current == _head) {
        _head = p;
    }

    p->next = current;
    p->prev = current->prev;
    current->prev = p;

    if (p->prev) {
        p->prev->next = p;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\makefile.inc ===
..\..\inc\rtmsg.h msg00001.bin rtmsg.rc: ..\rtmsg.mc ..\ulib.rc
    mc -v -h ..\..\inc\ ..\rtmsg.mc
    copy rtmsg.rc + ..\ulib.rc rtmsg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\keyboard.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    keyboard.cxx

Abstract:

    This module contains the definitions of the member functions
    of KEYBOARD class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "keyboard.hxx"


BOOL KEYBOARD::_FlagBreak;


#define     CTRL_Z      0x1a

DEFINE_EXPORTED_CONSTRUCTOR ( KEYBOARD, BUFFER_STREAM, ULIB_EXPORT );


DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( KEYBOARD, ULIB_EXPORT );


VOID
KEYBOARD::Construct (
    )
/*++

Routine Description:

    This routine initializes the keyboard to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DoNotRestoreConsoleMode = FALSE;
}


KEYBOARD::~KEYBOARD (
    )

/*++

Routine Description:

    Destroy a KEYBOARD (close a keyboard handle).

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (!_DoNotRestoreConsoleMode)
        SetConsoleMode( _KeyboardHandle, _PreviousMode );
    CloseHandle( _KeyboardHandle );
}



ULIB_EXPORT
VOID
KEYBOARD::DoNotRestoreConsoleMode(
    )
/*++

Routine Description:

    Set the flag such that on destruction of the keyboard class,
    the console mode will not be restored.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    _DoNotRestoreConsoleMode = TRUE;
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::Initialize(
    BOOLEAN LineMode,
    BOOLEAN EchoMode
    )

/*++

Routine Description:

    Initializes a KEYBOARD class.

Arguments:

    LineMode - Indicates if the keyboard is to be set in line mode.

    EchoMode - Indicates if the keyboard is to be set in the echo mode
               (characters are echoed to the current active screen)

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.

--*/

{
    ULONG   KeyboardMode;

    _KeyboardHandle = CreateFile( (LPWSTR)L"CONIN$",
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL );
    if( _KeyboardHandle ==INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    if( !GetConsoleMode( _KeyboardHandle, &_PreviousMode ) ) {
        return( FALSE );
    }
    KeyboardMode = _PreviousMode;
    if( LineMode ) {
        KeyboardMode |= ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT;
    } else {
        KeyboardMode &= ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT);
    }
    if( EchoMode ) {
        KeyboardMode |= ENABLE_ECHO_INPUT;
    } else {
        KeyboardMode &= ~ENABLE_ECHO_INPUT;
    }
    if( !SetConsoleMode( _KeyboardHandle, KeyboardMode ) ) {
        return( FALSE );
    }
    _FlagCtrlZ = FALSE;
    return( BUFFER_STREAM::Initialize( 256 ) );
}


BOOL
KEYBOARD::BreakHandler (
    IN  ULONG   CtrlType
    )

/*++

Routine Description:

    Handles Break events. Sets up the static data so that it can be
    queried later on.

Arguments:

    CtrlType    -   Supplies the type of Ctrl

Return Value:

    none

--*/

{
    UNREFERENCED_PARAMETER( CtrlType );

    _FlagBreak  =   TRUE;
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::GotABreak (
    )

/*++

Routine Description:

    Determines if a Break event (e.g Ctrl-C) was caught and handled.

    The static data that contains the Break information is set to a
    "FALSE" state.  Note that this means that if there is no Break
    between two consecutive calls to this method, then the second
    one will always return FALSE.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if a Break event happened, FALSE otherwise.

--*/

{
    BOOLEAN GotBreak = _FlagBreak != FALSE;

    _FlagBreak = FALSE;

    return GotBreak;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::EnableBreakHandling(
    )

/*++

Routine Description:

    Enables Break events handling (E.g. Ctrl-C).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    _FlagBreak = FALSE;

    return SetConsoleCtrlHandler( KEYBOARD::BreakHandler, TRUE ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::EnableLineMode(
    )

/*++

Routine Description:

    Set the keyboard in line mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }

    Mode |= ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE);
}



ULIB_EXPORT
BOOLEAN
KEYBOARD::DisableBreakHandling(
    )

/*++

Routine Description:

    Disables Break event handling (E.g. Ctrl-C).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    _FlagBreak = FALSE;

    return SetConsoleCtrlHandler( KEYBOARD::BreakHandler, FALSE ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::DisableLineMode(
    )

/*++

Routine Description:

    Set the keyboard in character mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    // unreferenced parameters
    (void)(this);

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode &= ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT);
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}




BOOLEAN
KEYBOARD::IsLineModeEnabled(
    OUT PBOOLEAN    LineMode
    ) CONST

/*++

Routine Description:

    Finds out if the keyboard is in line mode.

Arguments:

    LineMode - Returns TRUE if in LineMode; otherwise, FALSE.

Return Value:

    Returns TRUE if successful

--*/

{
    ULONG   Mode;

    if (GetConsoleMode( _KeyboardHandle, &Mode )) {
        *LineMode = (( Mode & ENABLE_LINE_INPUT ) ? TRUE : FALSE );
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOLEAN
KEYBOARD::EnableEchoMode(
    )

/*++

Routine Description:

    Set the keyboard in echo mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode |= ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}



BOOLEAN
KEYBOARD::DisableEchoMode(
    )

/*++

Routine Description:

    Does not echo characters read from keyboard.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode &= ~ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}



BOOLEAN
KEYBOARD::IsEchoModeEnabled(
    OUT PBOOLEAN    EchoInput
    ) CONST

/*++

Routine Description:

    Finds out if characters read from keyboard echoed to the screen.

Arguments:

    EchoInput - Returns TRUE if Echo Input is enabled; otherwise, FALSE.

Return Value:

    Returns TRUE if successful; otherwise, FALSE.

--*/

{
    ULONG   Mode;

    if (GetConsoleMode( _KeyboardHandle, &Mode )) {
        *EchoInput = (( Mode | ENABLE_ECHO_INPUT ) ? TRUE : FALSE);
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOLEAN
KEYBOARD::CheckForAsciiKey(
    IN PINPUT_RECORD    InputRecord,
    IN ULONG            NumberOfInputRecords
    ) CONST

/*++

Routine Description:

    Examines an array of input records in order to find out if at least
    one ascii key was pressed.

Arguments:

    InputRecord - Pointer to an array of INPUT_RECORDS.

    NumberOfInputRecords - Number of elements in the array


Return Value:

    BOOLEAN - Indicates if the input buffer contains at least one
              ASCII key.


--*/

{
    BOOLEAN Result;

    // unreferenced parameters
    (void)(this);

    Result = FALSE;
    while( !Result && NumberOfInputRecords ) {
        if( ( InputRecord->EventType == KEY_EVENT ) &&
            ( InputRecord->Event ).KeyEvent.bKeyDown &&

#if defined(FE_SB)
            ( ( InputRecord->Event ).KeyEvent.uChar.UnicodeChar > 0 ) &&
            ( ( InputRecord->Event ).KeyEvent.uChar.UnicodeChar <= 0x7e ) ) {
#else
            ( ( InputRecord->Event ).KeyEvent.uChar.AsciiChar > 0 ) &&
            ( ( InputRecord->Event ).KeyEvent.uChar.AsciiChar <= 0x7e ) ) {
#endif

            Result = TRUE;
        } else {
            NumberOfInputRecords--;
            InputRecord++;
        }
    }
    return( Result );
}



ULIB_EXPORT
BOOLEAN
KEYBOARD::IsKeyAvailable(
    OUT PBOOLEAN    Available
    ) CONST

/*++

Routine Description:

    Determines if there is at least one key to be read.

Arguments:

    Available - Pointer to the variable that will contain the result of
                the query (if there is a key in the keyboard buffer).

Return Value:

    BOOLEAN - A boolean value that indicates if the operation succeeded
              If this value is FALSE, the contets of 'Available' has no
              meaning (the calls to the APIs failed).


--*/


{
    BOOLEAN         Result;
    ULONG           NumberOfInputEvents;
    PINPUT_RECORD   Event;
    ULONG           NumberOfEventsRead;

    //
    // Keys read, but not yet consumed, are kept are in a buffer.
    // So, we have to check first if there is at least one key
    // in this buffer.
    //
    if( BUFFER_STREAM::QueryBytesInBuffer() != 0 ) {
        *Available = TRUE;
        return( TRUE );
    }
    //
    // If there was no key previously read, we have to check the
    // keyboard buffer for key events.
    //
    Result = FALSE;
    if ( GetNumberOfConsoleInputEvents( _KeyboardHandle,
                                        &NumberOfInputEvents ) ) {

        if( NumberOfInputEvents == 0 ) {
            *Available = FALSE;
            Result = TRUE;
        } else {
            Event = ( PINPUT_RECORD ) MALLOC( ( size_t )( sizeof( INPUT_RECORD ) * NumberOfInputEvents ) );
            if (Event == NULL) {
                DebugPrint("ULIB: Out of memory\n");
                return FALSE;
            }
            if( PeekConsoleInput( _KeyboardHandle,
                                  Event,
                                  NumberOfInputEvents,
                                  &NumberOfEventsRead ) &&
                NumberOfEventsRead != 0 ) {

                *Available = CheckForAsciiKey( Event, NumberOfInputEvents );
                Result = TRUE;
            }
            FREE( Event );
        }

    }
    return( Result );
}




BOOLEAN
KEYBOARD::FillBuffer(
    OUT PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with data read from the keyboard.

Arguments:

    Buffer  - Points to the buffer where the data will be put.

    BufferSize  - Indicates total number of bytes to read from the stream.

    BytesRead   - Points to the variable that will contain the number of
                  bytes read.

Return Value:

    BOOLEAN - Indicates if the read operation succeeded.


--*/


{
    BOOLEAN     Result;
    ULONG       Count;
    BOOLEAN     LineMode;


    Result = ReadFile( _KeyboardHandle,
                       Buffer,
                       BufferSize,
                       BytesRead,
                       NULL ) != FALSE;
    if( !Result ) {
        return( Result );
    }
    if (*BytesRead == 0) {
        _FlagCtrlZ = TRUE;
    } else {
        if (!IsLineModeEnabled(&LineMode))
            return FALSE;

        if (LineMode) {
            Count = *BytesRead;
            while( Count > 0 ) {
                if( *Buffer != CTRL_Z ) {
                    Count--;
                    Buffer++;
                } else {
                    *Buffer = 0;
                    *BytesRead -= Count;
                    _FlagCtrlZ = TRUE;
                    Count = 0;          // To get out of while() loop
                }
            }
        }
    }
    BUFFER_STREAM::SetStreamTypeANSI();
    return( Result );
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::Flush(
    )

/*++

Routine Description:

    Discards all keys in the buffer in BUFFER_STREAM, and flushes the
    console input buffer.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    BUFFER_STREAM::FlushBuffer();
    return( FlushConsoleInputBuffer( _KeyboardHandle ) != FALSE );
}



BOOLEAN
KEYBOARD::EndOfFile(
    ) CONST

/*++

Routine Description:

    Indicates if end-of-file has occurred when the keyboard was read.
    End-of-file for a keyboard means that the keyboard was in line
    mode and a Ctrl-Z was read from the keyboard.

Arguments:

    None.

Return Value:

    BOOLEAN - returns TRUE if the keyboard is in the line mode and a
              CTRL-Z was read. Returns FALSE otherwise.

--*/

{
    BOOLEAN     CtrlZ;
    BOOLEAN     MoreKeys;
    PBOOLEAN    Pointer;

    CtrlZ = _FlagCtrlZ;
    if( CtrlZ ) {
        if( IsKeyAvailable( &MoreKeys ) ) {
            //
            // Enables client to read again from the keyboard
            //
            // This method is CONST and shouldn't modify
            // _FlagCtrlZ, but here is the place to do it.
            // I cannot define the method as non-const because it was
            // defined as CONST in the base class
            //
            Pointer = &(((PKEYBOARD) this)->_FlagCtrlZ);
            *Pointer = !MoreKeys;
        }
    }
    return( CtrlZ );
}

STREAMACCESS
KEYBOARD::QueryAccess(
    ) CONST

/*++

Routine Description:

    Informs the caller about the access to the keyboard.

Arguments:

    None.

Return Value:

    STREAMACCESS - Returns READ_ACCESS always.

--*/

{
    // unreferenced parameters
    (void)(this);

    return( READ_ACCESS );
}




ULONG
KEYBOARD::QueryDelay(
    ) CONST

/*++

Routine Description:

    Obtains the delay value of the keyboard.

Arguments:

    None.

Return Value:

    ULONG   -   The delay value.

--*/

{
    INT Delay;

    SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, &Delay, 0 );

    return Delay;
}

HANDLE
KEYBOARD::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns to the caller the keyboard handle.

Arguments:

    None.

Return Value:

    HANDLE - Returns the keyboard handle.

--*/

{
    return( _KeyboardHandle );
}


ULONG
KEYBOARD::QuerySpeed(
    ) CONST

/*++

Routine Description:

    Obtains the speed rate of the keyboard.

Arguments:

    None.

Return Value:

    ULONG   -   The speed value.

--*/

{
    WORD    Speed;

    SystemParametersInfo( SPI_GETKEYBOARDSPEED, 0, &Speed, 0 );

    return Speed;

}


BOOLEAN
KEYBOARD::SetDelay(
    IN ULONG    Delay
    ) CONST

/*++

Routine Description:

    Sets the delay value of the keyboard.

Arguments:

    Delay   -   Supplies the delay value

Return Value:

    BOOLEAN -   TRUE if delay set, FALSE otherwise

--*/

{

    // return SystemParametersInfo( SPI_SETKEYBOARDDELAY, (UINT)Delay, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
    return TRUE;

}


BOOLEAN
KEYBOARD::SetSpeed (
    IN ULONG    Speed
    ) CONST

/*++

Routine Description:

    Sets the speed  rate of the keyboard.

Arguments:

    Speed   -   Supplies the speed value

Return Value:

    BOOLEAN -   TRUE if speed set, FALSE otherwise

--*/

{

    // return SystemParametersInfo( SPI_SETKEYBOARDSPEED, (UINT)Speed, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
    return TRUE;

}

ULIB_EXPORT
CONST
PBOOL
KEYBOARD::GetPFlagBreak (
    VOID
    ) CONST

/*++

Routine Description:

    Returns pointer to _FlagBreak.  Used by xcopy to pass pointer to _FlagBreak
    as the lpCancel flag to CopyFileEx.  When the user hits a Ctrl-C, this flag
    becomes TRUE and CopyFileEx will stop copying the current file.

Arguments:

    none

Return Value:

    Pointer to _Flagbreak
--*/

{
    return (&_FlagBreak);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\listit.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "listit.hxx"


DEFINE_CONSTRUCTOR( LIST_ITERATOR, ITERATOR );


DEFINE_CAST_MEMBER_FUNCTION( LIST_ITERATOR );


VOID
LIST_ITERATOR::Reset(
    )
{
    _current = NULL;
}


POBJECT
LIST_ITERATOR::GetCurrent(
	)
{
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetNext(
	)
{
    _current = _current ? _current->next : _list->_head;
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetPrevious(
	)
{
    _current = _current ? _current->prev : _list->_tail;
    return _current ? _current->data : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\mbstr.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    mbstr.cxx

Abstract:

    This module contains the implementation of the MBSTR class. The MBSTR
    class is a module that provides static methods for operating on
    multibyte strings.


Author:

    Ramon J. San Andres (ramonsa) 21-Feb-1992

Environment:

    ULIB, User Mode

Notes:



--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "mbstr.hxx"

extern "C" {
    #include <string.h>
    #include <ctype.h>
}

#ifdef FE_SB

STATIC WORD wDBCSFullSpace  = 0xFFFF;
STATIC BOOL bIsDBCSCodePage = FALSE;

BOOL IsDBCSCodePage()
{
    STATIC WCHAR wFullSpace= 0x3000;
    STATIC LONG  InitializingDBCS = 0;

    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingDBCS, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if (wDBCSFullSpace == 0xFFFF) {

        if (WideCharToMultiByte(
                CP_ACP,
                0,
                &wFullSpace,
                1,
                (LPSTR) &wDBCSFullSpace,
                sizeof(wDBCSFullSpace),
                NULL,
                NULL) == 2) { // only FE code page can return 2 bytes for 0x3000
            bIsDBCSCodePage = TRUE;
        }
        else {
            wDBCSFullSpace = 0x0000;
        }
    }

    status = InterlockedDecrement(&InitializingDBCS);
    DebugAssert(status == 0);

    return bIsDBCSCodePage;
}
#endif


PSTR*
MBSTR::MakeLineArray (
    INOUT   PSTR*   Buffer,
    INOUT   PDWORD  BufferSize,
    INOUT   PDWORD  NumberOfLines
    )
/*++

Routine Description:

    Constructs an array of strings into a buffer, one string per line.
    Adds nulls in the buffer.

Arguments:

    Buffer          -   Supplies the buffer.
                        Receives pointer remaining buffer

    BufferSize      -   Supplies the size of the buffer.
                        Receives the size of the remaining buffer

    NumberOfLines   -   Supplies number of lines wanted.
                        Receives number of lines obtained. If BufferSize is
                        0 on output, the last line is partial (i.e. equal
                        to Buffer).

Return Value:

    Pointer to array of string pointers.


--*/
{

#if 0
    PSTR   *Array = NULL;
    DWORD   NextElement;
    DWORD   ArraySize;
    DWORD   ArrayLeft;
    DWORD   Lines = 0;
    DWORD   LinesLeft;
    DWORD   Size, Size1;
    PSTR    Buf, Buf1;
    PSTR    p;
    DWORD   Idx;

    if ( Buffer && BufferSize && NumberOfLines ) {

        Buf         = *Buffer;
        Size        = *BufferSize;
        Linesleft   = *NumberOfLines;

        if ( Buf && (Array = (PSTR *)MALLOC( CHUNK_SIZE * sizeof( PSTR *)) ) ) {

            ArrayLeft   = CHUNK_SIZE;
            ArraySize   = CHUNK_SIZE;

            //
            //  Linearize the buffer and get pointers to all the lines
            //
            while ( Size && LinesLeft ) {

                //
                //  If Array is full, reallocate it.
                //
                if ( ArrayLeft == 0 ) {

                    if ( !(Array = (PSTR *)REALLOC( Array, (ArraySize+CHUNK_SIZE) * sizeof( PSTR * ) ) )) {

                        Buf     = *Buffer;
                        Size    = *BufferSize;
                        Lines   = 0;
                        break;
                    }

                    ArraySize += CHUNK_SIZE;
                    ArrayLeft += CHUNK_SIZE;

                }


                //
                //  Get one line and add it to the array
                //
                Buf1    = Buf;
                Size1   = Size;

                while ( TRUE ) {

                    //
                    //  Look for end of line
                    //
                    Idx = Strcspn( Buf1, "\r\n" );


                    //
                    //  If end of line not found, we add the last chunk to the list and
                    //  increment the line count, but to not update the size.
                    //
                    if ( Idx > Size1 ) {
                        //
                        //  End of line not found, we add the last chunk
                        //  to the list and stop looking for strings, but
                        //  we do not update the size.
                        //
                        LinesLeft = 0;
                        Size1     = Size;
                        Buf1      = Buf;
                        break;

                    } else {
                        //
                        //  If this is really the end of a line we stop.
                        //
                        Buf1    += Idx;
                        Size1   -= Idx;

                        //
                        //  If '\r', see if this is really the end of a line.
                        //
                        if ( *Buf1 == '\r' ) {

                            if ( Size1 == 0 ) {

                                //
                                //  Cannot determine if end of line because
                                //  ran out of buffer
                                //
                                LinesLeft   = 0;
                                Size1       = Size;
                                Buf1        = Buf;
                                break;

                            } else if ( *(Buf+1) == '\n' ) {

                                //
                                //  End of line is \r\n
                                //
                                *Buf1++ = '\0';
                                *Buf1++ = '\0';
                                Size1--;
                                break;

                            } else {

                                //
                                //  Not end of line
                                //
                                Buf1++;
                                Size1--;

                            }

                        } else {

                            //
                            //  End of line is \n
                            //
                            Buf1++;
                            Size1--;
                            break;
                        }

                    }
                }

                //
                //  Add line to array
                //
                Array[Lines++] = Buf;

                Buf     = Buf1;
                Size    = Size1;

            }
        }

        *Buffer         = Buf;
        *BufferSize     = Size;
        *NumberOfLines  = Lines;
    }

    return Array;
#endif

    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( BufferSize );
    UNREFERENCED_PARAMETER( NumberOfLines );

    return NULL;
}



DWORD
MBSTR::Hash(
    IN      PSTR    String,
    IN      DWORD   Buckets,
    IN      DWORD   BytesToSum
    )
{

    DWORD   HashValue = 0;
    DWORD   Bytes;

    if ( !String ) {

        HashValue = (DWORD)-1;

    } else {

        if ( (Bytes = (DWORD)Strlen( String )) > BytesToSum ) {
            Bytes = BytesToSum;
        }

        while ( Bytes > 0 ) {
            HashValue += *(String + --Bytes);
        }

        HashValue = HashValue % Buckets;
    }

    return HashValue;
}



PSTR
MBSTR::SkipWhite(
    IN  PSTR    p
    )
{

#ifdef FE_SB
    if (bIsDBCSCodePage) {
        while (*p) {

            if (*p == LOBYTE(wDBCSFullSpace) && *(p+1) == HIBYTE(wDBCSFullSpace)) {
                *p++ = ' ';
                *p++ = ' ';
            } else if (!IsDBCSLeadByte(*p) && isspace(*(BYTE*)p)) {
                p++;
            } else {
                break;
            }
        }
    }
    else { // according to original logic
        while (isspace(*(BYTE*)p)) {
            p++;
        }
    }
#else
    while (isspace(*(BYTE*)p)) {
        p++;
    }
#endif


    return p;

}



/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
ULIB_EXPORT
INT
MBSTR::Strcmps (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
  char *q;
#ifdef FE_SB
  IsDBCSCodePage();
#endif

  p1 = MBSTR::SkipWhite(p1);                /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef FE_SB
      if (CheckSpace(p1))
#else
      if (isspace(*(BYTE*)p1))           /* compress multiple spaces */
#endif
      {
        q = MBSTR::SkipWhite(p1);
        p1 = (*q == 0) ? q : q - 1;
      }

#ifdef FE_SB
      if (CheckSpace(p2))
#else
      if (isspace(*(BYTE*)p2))
#endif
      {
        q = MBSTR::SkipWhite(p2);
        p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}





/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
ULIB_EXPORT
INT
MBSTR::Strcmpis (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
#ifndef FE_SB
  char *q;

  p1 = MBSTR::SkipWhite(p1);                  /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
      if (toupper(*(BYTE *)p1) == toupper(*(BYTE *)p2))
      {
          if (*p1++ == 0)                /* quit if at the end */
              return (0);
          else
              p2++;

          if (isspace(*(BYTE*)p1))              /* compress multiple spaces */
          {
              q = SkipWhite(p1);
              p1 = (*q == 0) ? q : q - 1;
          }

          if (isspace(*(BYTE *)p2))
          {
              q = MBSTR::SkipWhite(p2);
              p2 = (*q == 0) ? q : q - 1;
          }
      }
      else
          return *p1-*p2;
  }
#else   // FE_SB
// MSKK KazuM Jan.28.1993
// Unicode DBCS support
  PSTR q;

  IsDBCSCodePage();

  p1 = MBSTR::SkipWhite(p1);                  /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
      if (toupper(*(BYTE*)p1) == toupper(*(BYTE*)p2))
      {
        if (*p1++ == 0)                /* quit if at the end */
          return (0);
        else
          p2++;

        if (CheckSpace(p1))
        {
          q = SkipWhite(p1);
          p1 = (*q == 0) ? q : q - 1;
        }

        if (CheckSpace(p2))
        {
          q = MBSTR::SkipWhite(p2);
          p2 = (*q == 0) ? q : q - 1;
        }
      }
      else
        return *p1-*p2;
  }
#endif // FE_SB
}

#ifdef FE_SB

/**************************************************************************/
/* Routine:  CheckSpace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/
INT
MBSTR::CheckSpace(
    IN  PSTR    s
    )
{
    if (bIsDBCSCodePage) {
        if (isspace(*(BYTE*)s) || (*s == LOBYTE(wDBCSFullSpace) && *(s+1) == HIBYTE(wDBCSFullSpace)))
            return (TRUE);
        else
            return (FALSE);
    }
    else {
        return isspace(*(BYTE*)s);
    }
}

#endif





#if 0
/**************************************************************************/
/*        strcmpi will compare two string lexically and return one of     */
/*  the following:                                                        */
/*    - 0    if the strings are equal                                     */
/*    - 1    if first > the second                                        */
/*    - (-1) if first < the second                                        */
/*                                                                        */
/*      This was written to replace the run time library version of       */
/*  strcmpi which does not correctly compare the european character set.  */
/*  This version relies on a version of toupper which uses IToupper.      */
/**************************************************************************/

int FC::_strcmpi(unsigned char *str1, unsigned char *str2)
{
  unsigned char c1, c2;

#ifdef FE_SB
  IsDBCSCodePage();

  if (bIsDBCSCodePage) {
      while (TRUE)
      {
        c1 = *str1++;
        c2 = *str2++;
        if (c1 == '\0' || c2 == '\0')
            break;
        if (IsDBCSLeadBYTE(c1) && IsDBCSLeadBYTE(c2))
        {
          if (c1 == c2)
          {
              c1 = *str1++;
              c2 = *str2++;
              if (c1 != c2)
                  break;
          }
          else
            break;
        }
        else if (IsDBCSLeadBYTE(c1) || IsDBCSLeadBYTE(c2))
            return (IsDBCSLeadBYTE(c1) ? 1 : -1);
        else
            if ((c1 = toupper(c1)) != (c2 = toupper(c2)))
                break;
      }
      return (c1 == c2 ? 0 : (c1 > c2 ? 1 : -1));
  }
  else {
      while ((c1 = toupper(*str1++)) == (c2 = toupper(*str2++)))
      {
        if (c1 == '\0')
          return (0);
      }

      if (c1 > c2)
        return (1);
      else
        return (-1);
  }
#else
  while ((c1 = toupper(*str1++)) == (c2 = toupper(*str2++)))
  {
    if (c1 == '\0')
      return (0);
  }

  if (c1 > c2)
    return (1);
  else
    return (-1);
#endif // FE_SB
}
#endif // if 0

#ifdef FE_SB
//fix kksuzuka: #930
//Enabling strcmpi disregarding the case of DBCS letters.

ULIB_EXPORT
INT
MBSTR::Stricmp (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
  BYTE c1,c2;

    while (TRUE)
    {
        c1 = *p1++;
        c2 = *p2++;

        if (c1=='\0' || c2 == '\0')
            break;

        if (IsDBCSLeadByte(c1) && IsDBCSLeadByte(c2) && c1 == c2)
        {
            if (c1==c2)
            {
                c1 = *p1++;
                c2 = *p2++;
                if (c1 != c2)
                    break;
            }
            else
                break;
        }

        else if (IsDBCSLeadByte(c1) || IsDBCSLeadByte(c2))
            return (IsDBCSLeadByte(c1) ? 1: -1);

        else
            if ((c1 = (char)toupper(c1)) != (c2 = (char)toupper(c2)))
                break;

    }
    return (c1 == c2 ? 0 : (c1 > c2 ? 1: -1));
}

//fix kksuzuka: #926
//Enabling strstr disregarding the case of DBCS letters.
ULIB_EXPORT
PSTR
MBSTR::Strstr (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
    DWORD   dLen;
    PSTR    pEnd;

    dLen = Strlen(p2);
    pEnd = p1+ Strlen(p1);

    while ((p1+dLen)<=pEnd) {
        if ( !memcmp(p1,p2,dLen) ) {
            return(p1);
        }
        if ( IsDBCSLeadByte(*p1) ) {
            p1 += 2;
        } else {
            p1++;
        }
    }

    return( NULL );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\machine.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#if defined(_AUTOCHECK_)
extern "C" {
    #include "nt.h"
    #include "ntrtl.h"
    #include "nturtl.h"
}
#endif // defined(_AUTOCHECK_)

#include "ulib.hxx"
#include "machine.hxx"

extern "C" {
    #include "windows.h"
}

#if defined(FE_SB) && defined(_X86_)

extern "C" {

#ifndef _MACHINEP_ID_
#define _MACHINEP_ID_

//
// Registry Key
//

//
// UNICODE
//

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_W      \
        L"Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   \
        L"Identifier"

#define FUJITSU_FMR_NAME_W    L"FUJITSU FMR-"
#define NEC_PC98_NAME_W       L"NEC PC-98"

//
// ANSI
//

#define REGISTRY_HARDWARE_DESCRIPTION_A \
        "\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_A      \
        "Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_A   \
        "Identifier"

#define FUJITSU_FMR_NAME_A    "FUJITSU FMR-"
#define NEC_PC98_NAME_A       "NEC PC-98"

//
// Automatic
//

#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_HARDWARE_SYSTEM      \
        TEXT("Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")

//
// These definition are only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

#endif // _MACHINE_ID_

}

#if defined( _AUTOCHECK_ )

DWORD _dwMachineId = MACHINEID_MICROSOFT;

//
//  Local Support routine
//

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 64)


InitializeMachineId(
    VOID
)
/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Return Value:

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING ValueName;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    STATIC BOOLEAN bInitialized = FALSE;

    if( bInitialized ) {
        return TRUE;
    } else {
        bInitialized = TRUE;
    }

    //
    //  Read the registry to determine of machine type.
    //

    ValueName.Buffer = REGISTRY_MACHINE_IDENTIFIER;
    ValueName.Length = sizeof(REGISTRY_MACHINE_IDENTIFIER) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(REGISTRY_MACHINE_IDENTIFIER);

    KeyName.Buffer = REGISTRY_HARDWARE_DESCRIPTION;
    KeyName.Length = sizeof(REGISTRY_HARDWARE_DESCRIPTION) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(REGISTRY_HARDWARE_DESCRIPTION);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return FALSE;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    Status = NtQueryValueKey(Handle,
                             &ValueName,
                             KeyValueFullInformation,
                             KeyValueInformation,
                             RequestLength,
                             &ResultLength);

    ASSERT( Status != STATUS_BUFFER_OVERFLOW );

    if (Status == STATUS_BUFFER_OVERFLOW) {

        return FALSE;

    }

    NtClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PWCHAR DataPtr;
            UNICODE_STRING DetectedString, TargetString1, TargetString2;

            //
            // Return contents to the caller.
            //

            DataPtr = (PWCHAR)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);

            //
            // Initialize strings.
            //

            RtlInitUnicodeString( &DetectedString, DataPtr );
            RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME_W );
            RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME_W );

            //
            // Check the hardware platform
            //

            if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

                //
                // Fujitsu FMR Series.
                //

                _dwMachineId = MACHINEID_FUJITSU_FMR;

#if 0
            } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {
#else
            } else if (IsNEC_98) {
#endif
                //
                // NEC PC-9800 Seriss
                //

                _dwMachineId = MACHINEID_NEC_PC98;

            } else {

                //
                // Standard PC/AT comapatibles
                //

                _dwMachineId = MACHINEID_MS_PCAT;

            }

            return TRUE;

        } else {

            //
            // Treat as if no value was found
            //

            return FALSE;

        }
    }

    return FALSE;
}

#else // _AUTOCHECK_

DEFINE_EXPORTED_CONSTRUCTOR( MACHINE, OBJECT, ULIB_EXPORT );

DWORD MACHINE::_dwMachineId = MACHINEID_MICROSOFT;

ULIB_EXPORT MACHINE MachinePlatform;

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::Initialize(
    VOID
    )
{
    HKEY           hkeyMap;
    int            ret;
    DWORD          cb;
    WCHAR          szBuff[80];
    UNICODE_STRING DetectedString,
                   TargetString1,
                   TargetString2;

    STATIC LONG InitializingMachine = 0;
    STATIC BOOLEAN bInitialized = FALSE;
    LONG           status;
    LARGE_INTEGER  timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingMachine, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if( bInitialized ) {
        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return TRUE;
    } else {
        bInitialized = TRUE;    // not sure why it is set to TRUE so soon
    }

    if ( RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                       REGISTRY_HARDWARE_SYSTEM,
                       0,
                       KEY_READ,
                       &hkeyMap) !=  ERROR_SUCCESS ) {

        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return( FALSE );
    }

    //
    // Reg functions deal with bytes, not chars
    //

    cb = sizeof(szBuff);

    ret = RegQueryValueExW(hkeyMap,
                           REGISTRY_MACHINE_IDENTIFIER,
                           NULL, NULL, (LPBYTE)szBuff, &cb);

    RegCloseKey(hkeyMap);

    if (ret != ERROR_SUCCESS) {
        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return( FALSE );
    }

    //
    // Initialize strings.
    //

    RtlInitUnicodeString( &DetectedString, szBuff );
    RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME_W );
    RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME_W );

    //
    // Check the hardware platform
    //

    if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

        //
        // Fujitsu FMR Series.
        //

        _dwMachineId = MACHINEID_FUJITSU_FMR;

#if 0
    } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {
#else
    } else if (IsNEC_98) {
#endif

        //
        // NEC PC-9800 Seriss
        //

        _dwMachineId = MACHINEID_NEC_PC98;

    } else {

        //
        // Standard PC/AT comapatibles
        //

        _dwMachineId = MACHINEID_MS_PCAT;

    }

    status = InterlockedDecrement(&InitializingMachine);
    DebugAssert(status == 0);

    return( TRUE );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsFMR(
    VOID
)
{
    return( ISFUJITSUFMR( _dwMachineId ) );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsPC98(
    VOID
)
{
    return( ISNECPC98( _dwMachineId ) );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsPCAT(
    VOID
)
{
    return( ISMICROSOFT( _dwMachineId ) );
}

#endif // defined( _AUTOCHECK_ )
#endif // defined(FE_SB) && defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\membmgr.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    membmgr.cxx

Author:

    Norbert P. Kusters (norbertk) 29-May-92

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "membmgr.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( STATIC_MEM_BLOCK_MGR, OBJECT );


STATIC_MEM_BLOCK_MGR::~STATIC_MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for STATIC_MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
STATIC_MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _heap = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


VOID
STATIC_MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_heap);
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   NumBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a usable initial state.

Arguments:

    MemBlockSize    - Supplies the number of bytes per mem block.
    NumBlocks       - Supplies the number of mem blocks to be
                        contained by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(MemBlockSize);

    if (!(_heap = (PCHAR) MALLOC(NumBlocks*MemBlockSize)) ||
        !_bitvector.Initialize(NumBlocks)) {

        Destroy();
        return FALSE;
    }

    _num_blocks = NumBlocks;
    _block_size = MemBlockSize;

    return TRUE;
}


PVOID
STATIC_MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a single memory block and returns its
    pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    if (_num_allocated == _num_blocks) {
        return NULL;
    }

    for (;;) {

        if (!_bitvector.IsBitSet(_next_alloc)) {

            _bitvector.SetBit(_next_alloc);
            _num_allocated++;
            return &_heap[_next_alloc*_block_size];
        }

        _next_alloc = (_next_alloc + 1) % _num_blocks;
    }
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Free(
    OUT PVOID   MemBlock
    )
/*++

Routine Description:

    This routine frees the given mem block for use by other clients.

Arguments:

    MemBlock    - Supplies a pointer to the mem block to free.

Return Value:

    FALSE   - The mem block was not freed.
    TRUE    - Success.

--*/
{
    ULONG   i;

    if (!MemBlock) {
        return TRUE;
    }

    i = (ULONG)((PCHAR) MemBlock - _heap)/_block_size;
    if (i >= _num_blocks) {
        return FALSE;
    }

    DebugAssert(((PCHAR) MemBlock - _heap)%_block_size == 0);

    _bitvector.ResetBit(i);
    _num_allocated--;
    _next_alloc = i;
    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( MEM_BLOCK_MGR, OBJECT, ULIB_EXPORT );


VOID
MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(_static_mem_list, 0, 32*sizeof(PVOID));
}


VOID
MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        DELETE(_static_mem_list[i]);
    }
}


ULIB_EXPORT
MEM_BLOCK_MGR::~MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   InitialNumBlocks
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    MemBlockSize        - Specifies the size of the memory blocks to
                            be allocated from this object.
    InitialNumBlocks    - Specifies the initial number of blocks
                            to be allocated by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!(_static_mem_list[0] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[0]->Initialize(MemBlockSize, InitialNumBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULIB_EXPORT
PVOID
MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a mem blocks and returns its pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    ULONG   i;
    PVOID   r;

    for (i = 0; _static_mem_list[i]; i++) {
        if (r = _static_mem_list[i]->Alloc()) {
            return r;
        }
    }

    // At this point all of the current buffers are full so
    // start another one.

    if (!(_static_mem_list[i] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[i]->Initialize(
                _static_mem_list[i - 1]->QueryBlockSize(),
                2*_static_mem_list[i - 1]->QueryNumBlocks())) {

        DELETE(_static_mem_list[i]);
        return NULL;
    }

    return _static_mem_list[i]->Alloc();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Free(
    IN OUT  PVOID   MemPtr
    )
/*++

Routine Description:

    This routine frees the given memory block.

Arguments:

    MemPtr  - Supplies a pointer to the buffer to free.

Return Value:

    This function returns TRUE if the memory was successfully
    freed.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        if (_static_mem_list[i]->Free(MemPtr)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\mem.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "mem.hxx"


DEFINE_CONSTRUCTOR( MEM, OBJECT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\message.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "message.hxx"
#include "hmem.hxx"

extern "C" {
#include "stdio.h"
#if defined(_AUTOCHECK_)
#include "ntos.h"
#endif
}

DEFINE_EXPORTED_CONSTRUCTOR(MESSAGE, OBJECT, ULIB_EXPORT);


MESSAGE::~MESSAGE(
    )
/*++

Routine Description:

    Destructor for MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Initialize(
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - Autochk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _timeout.QuadPart = -10000;
    return _log_buffer.Initialize();
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsSuppressedMessage(
    )
/*++

Routine Description:

    This function determines whether the specified message ID
    should be suppressed, i.e. not recorded in the message log.

Arguments:

    MessageId   --  Supplies the Message ID in question.

Return Value:

    TRUE if this message ID is in the set which is not recorded
    in the message log.

--*/
{
    BOOLEAN result;

    switch( _msgid ) {

    case MSG_HIDDEN_STATUS:
    case MSG_PERCENT_COMPLETE:
    case MSG_PERCENT_COMPLETE2:
    case MSG_CHK_NTFS_CHECKING_FILES:
    case MSG_CHK_NTFS_CHECKING_INDICES:
    case MSG_CHK_NTFS_INDEX_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_FILE_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_CHECKING_SECURITY:
    case MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED:
    case MSG_CHK_VOLUME_CLEAN:
    case MSG_CHK_CHECKING_FILES:
    case MSG_CHK_DONE_CHECKING:

        result = TRUE;
        break;

    default:
        result = FALSE;
        break;
    }

    return result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Display(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual,
    IN  PCSTR           Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId, MessageType, MessageVisual);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::Log(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::DumpDataToLog(
    IN  PVOID   Data,
    IN  ULONG   Length
    )
/*++

Routine Description:

    This routine dumps the binary data to the log.

Arguments:

    Data       - Supplies a pointer to the data to be dumped
    Length     - Supplies the number of bytes to dump

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PUCHAR  pdata = (PUCHAR)Data;
    ULONG   block;
    BOOLEAN rst = TRUE;
    WCHAR    buffer[50], buffer2[20];
    USHORT  i;

    block = ((Length + 0xf) >> 4) + 1;
    Set(MSG_CHKLOG_DUMP_DATA);

    while (rst && block--) {

        for (i=0; i<16; i++) {
            __try {
                swprintf(buffer+i*3, L"%02x ", pdata[i]);
                if (isprint(pdata[i]))
                    swprintf(buffer2+i, L"%c", pdata[i]);
                else
                    buffer2[i] = '.';
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                buffer[i*3] = '?';
                buffer[i*3+1] = '?';
                buffer[i*3+2] = ' ';
                buffer2[i] = '.';
            }
        }
        buffer[48] = ' ';
        buffer[49] = 0;
        buffer2[16] = 0;

        pdata += 0x10;
        rst = rst && Log("%ws%ws", buffer, buffer2);
    }

    return rst;
}

BOOLEAN
MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);
    (void)(Format);
    (void)(VarPointer);

    return TRUE;
}


BOOLEAN
MESSAGE::LogV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING         display_string;
    CHAR            buffer[512];

    if (IsLoggingEnabled()) {

        if (!BASE_SYSTEM::QueryResourceStringV(&display_string, _msgid, Format,
                                               VarPointer)) {
            return FALSE;
        }

        if (display_string.QuerySTR(0, TO_END, buffer, 512, TRUE)) {
            DebugPrintTrace(("%s", buffer));
        }

        return LogMessage(&display_string);
    }

    return TRUE;
}


PMESSAGE
MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    // unreferenced parameters
    (void)(this);

    return NEW MESSAGE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries to see if the response to a message is either
    yes or no.

Arguments:

    Default - Supplies a default answer to the question.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    // unreferenced parameters
    (void)(this);

    return Default;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return String->Initialize("");
}



ULIB_EXPORT
MSGID
MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Descriptions:

    This routine queries a response from the user.  It returns the
    message id of the response inputted.

Arguments:

    NumberOfSelections  - Supplies the number of possible message
                            responses.

    ... - Supplies 'NumberOfSelections' message identifiers.

Return Value:

    The first message id on the list.

--*/
{
    va_list ap;
    MSGID   msg;

    // unreferenced parameters
    (void)(this);

    va_start(ap, NumberOfSelections);
    msg = va_arg(ap, MSGID);
    va_end(ap);
    return msg;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate no
    key has been pressed.

Arguments:

    None.

Return Value:

    FALSE   - No key is pressed within the time out period.

--*/
{
    // unreferenced parameters
    (void)(this);
    UNREFERENCED_PARAMETER( MsgId );
    UNREFERENCED_PARAMETER( TimeOutInSeconds );

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::SetDotsOnly(
    IN  BOOLEAN DotsState
    )
{
    // unreferenced parameters
    (void)this;
    (void)DotsState;

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::QueryPackedLog(
    IN OUT  PHMEM   Mem,
    OUT     PULONG  PackedDataLength
    )
/*++

Routine Description:

Arguments:

    Mem                 --  Supplies a container for the packed log.
    PackedDataLength    --  Receives the number of bytes written to Mem.

Return Value:

    TRUE upon successful completion.

--*/
{
    FSTRING CurrentString;
    PWCHAR  Buffer;
    ULONG   NewBufferSize, CurrentOffset;

    if( !IsLoggingEnabled() ) {

        return FALSE;
    }

    ResetLoggingIterator();
    CurrentOffset = 0;

    while( QueryNextLoggedMessage( &CurrentString ) ) {

        NewBufferSize = (CurrentOffset + CurrentString.QueryChCount()) * sizeof(WCHAR);
        if( NewBufferSize > Mem->QuerySize() &&
            !Mem->Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {

            return FALSE;
        }

        Buffer = (PWCHAR)Mem->GetBuf();
        memcpy( Buffer + CurrentOffset,
                CurrentString.GetWSTR(),
                CurrentString.QueryChCount() * sizeof(WCHAR) );

        CurrentOffset += CurrentString.QueryChCount();
    }

    *PackedDataLength = CurrentOffset * sizeof(WCHAR);
    return TRUE;
}

BOOLEAN
MESSAGE::QueryNextLoggedMessage(
    OUT PFSTRING    MessageText
    )
{
    PWCHAR Buffer = (PWCHAR)_log_buffer.GetBuf();
    BOOLEAN Result;

    if( _next_message_offset >= _logged_chars ) {

        // No more logged messages.
        //
        return FALSE;
    }

    Result = (MessageText->Initialize( Buffer + _next_message_offset ) != NULL) ?
             TRUE : FALSE;

    // Push _next_message_offset to the next message.  Note
    // that _next_message_offset is also incremented if this
    // loop terminates because a zero was found, so that it
    // will be one character past the next NULL character.
    //
    while( _next_message_offset < _logged_chars &&
           Buffer[_next_message_offset++] );

    return Result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMessage(
    PCWSTRING   Message
    )
{
    ULONG NewBufferSize;
    PWCHAR Buffer;

    // The buffer must be large enough to accept this message plus
    // a trailing null.  To cut down the number of memory allocation
    // calls, grow the buffer by 1K chunks.
    //
    NewBufferSize = (_logged_chars + Message->QueryChCount() + 1) * sizeof(WCHAR);

    // Don't allow the buffer to grow more than 0.5MB
    // otherwise we may use up all the pages.

    if (NewBufferSize > 512000)
        return FALSE;

    if( _log_buffer.QuerySize() < NewBufferSize &&
        !_log_buffer.Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {
        return FALSE;
    }

    Buffer = (PWCHAR)_log_buffer.GetBuf();

    // QueryWSTR will append a trailing NULL.
    //
    Message->QueryWSTR( 0, TO_END,
                        Buffer + _logged_chars,
                        _log_buffer.QuerySize()/sizeof(WCHAR) - _logged_chars );

    _logged_chars += Message->QueryChCount() + 1;

    return TRUE;
}

ULIB_EXPORT
VOID
MESSAGE::Lock(
    )
{
    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }
}

ULIB_EXPORT
VOID
MESSAGE::Unlock(
    )
{
    InterlockedDecrement(&_inuse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\membmgr2.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    membmgr2.cxx

Author:

    Daniel Chan (danielch) Oct 18, 1999

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "membmgr2.hxx"


DEFINE_CONSTRUCTOR( MEM_ALLOCATOR, OBJECT );

VOID
MEM_ALLOCATOR::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _head_ptr = _next_free_ptr = NULL;
    _incremental_size = _free_space_in_current_block = 0;
    _max_mem_use = 0;
    _mem_use = 0;
}

VOID
MEM_ALLOCATOR::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    PVOID      p;

    if (_head_ptr) {
        DebugAssert(_incremental_size != 0);
    }

    // free up the entire linked memory block

    while (_head_ptr) {
        p = ((PUCHAR)_head_ptr) + _incremental_size - sizeof(PVOID *);
        p = (*(PVOID *)p);
        FREE(_head_ptr);
        _head_ptr = p;
    }

    _next_free_ptr = NULL;
    _incremental_size = _free_space_in_current_block = 0;
    _max_mem_use = 0;
    _mem_use = 0;
}

MEM_ALLOCATOR::~MEM_ALLOCATOR(
    )
/*++

Routine Description:

    This method un-initialize the class object.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    Destroy();
}

BOOLEAN
MEM_ALLOCATOR::Initialize(
    IN     ULONG64      MaximumMemoryToUse,
    IN     ULONG        IncrementalBlockSize
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    IncrementalBlockSize
                --  Supplies the block size to allocate
                    whenever there is a need to grow the memory.

Returns:

    TRUE if successful; otherwise, FALSE.

--*/
{
    Destroy();

    if (IncrementalBlockSize && MaximumMemoryToUse > 0) {
        if (MaximumMemoryToUse >= (((ULONG64)-1)-sizeof(PVOID*)))
            _incremental_size = IncrementalBlockSize;
        else if (IncrementalBlockSize > (MaximumMemoryToUse+sizeof(PVOID*)))
            _incremental_size = (ULONG)(MaximumMemoryToUse+sizeof(PVOID*));
        else
            _incremental_size = IncrementalBlockSize;
        _max_mem_use = MaximumMemoryToUse;
        return TRUE;
    } else {
        return FALSE;
    }
}

PVOID
MEM_ALLOCATOR::Allocate(
    IN     ULONG        SizeInBytes
    )
/*++

Routine Description:

    This method allocates a chunk of memory from the memory block.

Arguments:

    Size        -- Supplies the size of the buffer needed

Returns:

    Pointer to the block if successful
    NULL if failure

--*/
{
    PVOID      p;

    //
    // make sure request buffer is smaller than the max block size possible
    //

    if ((SizeInBytes + sizeof(PVOID *)) > _incremental_size)
        return NULL;

    if (_head_ptr == NULL) {

        DebugAssert(_mem_use == 0);

        //
        // first time, so allocate a buffer and initializes all class variables
        //
        _head_ptr = MALLOC(_incremental_size);
        if (_head_ptr == NULL)
            return NULL;
        _mem_use = _incremental_size;
        _free_space_in_current_block = _incremental_size - sizeof(PVOID *);
        *(PVOID *)(((PUCHAR)_head_ptr) + _free_space_in_current_block) = NULL;
        _free_space_in_current_block -= SizeInBytes;
        _next_free_ptr = ((PUCHAR)_head_ptr + SizeInBytes);
        return _head_ptr;

    } else {
        //
        // Check to see if there is enough space left
        //
        if (SizeInBytes <= _free_space_in_current_block) {
            //
            // Enough space from current block
            //
            p = _next_free_ptr;
            _free_space_in_current_block -= SizeInBytes;
            _next_free_ptr = ((PUCHAR)_next_free_ptr) + SizeInBytes;
            return p;
        } else {

            if (_mem_use >= _max_mem_use)
                return NULL;    // reached the limit

            p = MALLOC(_incremental_size);
            if (p == NULL)
                return NULL;

            _mem_use = _mem_use - _free_space_in_current_block + _incremental_size;
            _next_free_ptr = ((PUCHAR)_next_free_ptr) + _free_space_in_current_block;
            *(PVOID *)_next_free_ptr = p;
            _free_space_in_current_block = _incremental_size - sizeof(PVOID *);
            *(PVOID *)(((PUCHAR)_head_ptr) + _free_space_in_current_block) = NULL;
            _free_space_in_current_block -= SizeInBytes;
            _next_free_ptr = ((PUCHAR)p + SizeInBytes);
            return p;
        }
    }
    DebugAssert(FALSE);
    return NULL;    // should never get here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\newdel.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    newdel.cxx

Abstract:

    This module implements the C++ new and delete operators for
    the Setup-Loader environment.  In other environments, the utilities
    use the standard C++ new and delete.

Author:

    David J. Gilman (davegi) 07-Dec-1990

Environment:

    ULIB, User Mode

--*/


#include <pch.cxx>

#define _ULIB_MEMBER_

#if defined( _AUTOCHECK_ )
extern "C" {
    #include "ntos.h"
    #include <windows.h>
}
#endif

#include "ulib.hxx"



extern "C"
int _cdecl
_purecall( );

int _cdecl
_purecall( )
{

    DebugAbort( "Pure virtual function called.\n" );

    return 0;
}




#if defined( _AUTOCHECK_ )

STATIC ULONG64 HeapLeft = -1;
STATIC LONG  InUse = 0;

ULIB_EXPORT
ULONG64
AutoChkFreeSpaceLeft(
    )
{
    ULONG64         heap_left;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    heap_left = HeapLeft;

    status = InterlockedDecrement(&InUse);
    DebugAssert(status == 0);

    return heap_left;
}

ULIB_EXPORT
PVOID
AutoChkMalloc(
    ULONG bytes
    )
{
    PVOID           p;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    if (HeapLeft == -1) {

        SYSTEM_PERFORMANCE_INFORMATION  PerfInfo;
        SYSTEM_BASIC_INFORMATION        BasicInfo;
        ULONG64                         dwi;
        ULONG64                         user_addr_space;

        status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &(BasicInfo),
                    sizeof(BasicInfo),
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            InterlockedDecrement(&InUse);
            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                       "AutoChkMalloc: NtQuerySystemInformation(SystemBasicInfo) failed %x\n", status));
            return NULL;
        }

        status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &(PerfInfo),
                    sizeof(PerfInfo),
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            InterlockedDecrement(&InUse);
            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                       "AutoChkMalloc: NtQuerySystemInformation(SystemPerformanceInfo) failed %x\n", status));
            return NULL;
        }

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Pagesize %x\n", BasicInfo.PageSize));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Min User Addr %Ix\n", (ULONG64)BasicInfo.MinimumUserModeAddress));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Max User Addr %Ix\n", (ULONG64)BasicInfo.MaximumUserModeAddress));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: AvailablePages %x\n", PerfInfo.AvailablePages));

        user_addr_space = BasicInfo.MaximumUserModeAddress - BasicInfo.MinimumUserModeAddress;

        dwi = BasicInfo.PageSize;

        dwi *= PerfInfo.AvailablePages;

        if (user_addr_space < dwi)
            dwi = user_addr_space;  // can't go beyond available user address space

        if (dwi == -1) {
            dwi -= 1;
        }

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL, "AutoChkMalloc: DWI %I64x\n", dwi));

        //
        // The following magic number is simply a reserve subtracted off
        // the heap total to give the system some head room during the
        // AUTOCHK phase
        //
        if (dwi <= (100ul * 1024ul)) {
            HeapLeft = 0;
        } else {
            HeapLeft = dwi - dwi/10;
        }
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: HeapLeft %I64x\n", HeapLeft));
    }
    if (bytes > HeapLeft) {

        ULONG64   heapLeft = HeapLeft;

        status = InterlockedDecrement(&InUse);
        DebugAssert(status == 0);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                   "AutoChkMalloc: Out of memory: Avail %I64x, Asked %x\n",
                   heapLeft, bytes));
        return (NULL);
    }

    p = RtlAllocateHeap(RtlProcessHeap(), 0, bytes);

    if (p) {
        HeapLeft -= bytes;
        status = InterlockedDecrement(&InUse);
    } else {

        ULONG64   heapLeft = HeapLeft;

        status = InterlockedDecrement(&InUse);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                   "AutoChkMalloc: Out of memory possibly due to fragmentation: Avail %I64x, Asked %x\n",
                   heapLeft, bytes));
    }
    DebugAssert(status == 0);
    return p;
}

ULIB_EXPORT
VOID
AutoChkMFree(
    PVOID pmem
    )
{
    ULONG           size;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    size = (ULONG)RtlSizeHeap(RtlProcessHeap(), 0, pmem);

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    if (HeapLeft != -1) {
        HeapLeft += size;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, pmem);

    status = InterlockedDecrement(&InUse);
    DebugAssert(status == 0);

    return;
}
#endif // _AUTOCHECK_


#if defined( _SETUP_LOADER_ ) || defined( _AUTOCHECK_ )

// When the utilities are running the Setup Loader
// or Autocheck environments, they can't use the C-Run-
// Time new and delete; instead, these functions are
// provided.
//
PVOID _cdecl
operator new (
    IN size_t   bytes
    )
/*++

Routine Description:

    This routine allocates 'bytes' bytes of memory.

Arguments:

    bytes   - Supplies the number of bytes requested.

Return Value:

    A pointer to 'bytes' bytes or NULL.

--*/
{
    #if defined( _AUTOCHECK_ )

    return AutoChkMalloc(bytes);

    #elif defined( _SETUP_LOADER_ )

        return SpMalloc( bytes );

    #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

        return (PVOID) LocalAlloc(0, bytes);

    #endif // _AUTOCHECK_
}


VOID _cdecl
operator delete (
    IN  PVOID   pointer
    )
/*++

Routine Description:

    This routine frees the memory pointed to by 'pointer'.

Arguments:

    pointer - Supplies a pointer to the memoery to be freed.

Return Value:

    None.

--*/
{
    if (pointer) {

        #if defined( _AUTOCHECK_ )

        AutoChkMFree(pointer);

        #elif defined( _SETUP_LOADER_ )

            SpFree( pointer );

        #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

            LocalFree( pointer );

        #endif // _AUTOCHECK_

    }
}


typedef void (*PF)(PVOID);
typedef void (*PFI)(PVOID, int);
PVOID
__vec_new(
    IN OUT PVOID    op,
    IN int          number,
    IN int          size,
    IN PVOID        f)
/*
     allocate a vector of "number" elements of size "size"
     and initialize each by a call of "f"
*/
{
    if (op == 0) {

        #if defined( _AUTOCHECK_ )

        op = AutoChkMalloc(number * size);

        #elif defined( _SETUP_LOADER_ )

            op = SpMalloc( number*size );

        #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

            op = (PVOID) LocalAlloc(0, number*size);

        #endif // _AUTOCHECK_

    }

    if (op && f) {

        register char* p = (char*) op;
        register char* lim = p + number*size;
        register PF fp = PF(f);
        while (p < lim) {
            (*fp) (PVOID(p));
            p += size;
        }
    }

    return op;
}


void
__vec_delete(
    PVOID op,
    int n,
    int sz,
    PVOID f,
    int del,
    int x)

/*
     destroy a vector of "n" elements of size "sz"
*/
{
    // unreferenced parameters
    // I wonder what it does--billmc
    (void)(x);

    if (op) {
        if (f) {
            register char* cp = (char*) op;
            register char* p = cp;
            register PFI fp = PFI(f);
            p += n*sz;
            while (p > cp) {
                p -= sz;
                (*fp)(PVOID(p), 2);  // destroy VBC, don't delete
            }
        }
        if (del) {

            #if defined( _AUTOCHECK_ )

        AutoChkMFree(op);

            #elif defined( _SETUP_LOADER_ )

                SpFree( op );

            #else // _AUTOCHECK_ not defined

                LocalFree(op);

            #endif // _AUTOCHECK_

        }
    }
}

#endif // _SETUP_LOADER_

ULIB_EXPORT
PVOID
UlibRealloc(
    PVOID x,
    ULONG size
    )
{
#if defined( _SETUP_LOADER_ )

    return SpRealloc(x, size);

#else // _SETUP_LOADER_

    PVOID p;
    SIZE_T l;


    if (size <= (l = RtlSizeHeap(RtlProcessHeap(), 0, x))) {
        return x;
    }

    if (!(p = MALLOC(size))) {
        return NULL;
    }

    memcpy(p, x, (UINT) l);

    FREE(x);

    return p;

#endif // _SETUP_LOADER_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\object.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    object.cxx

Abstract:

    This module contains the definitions for the non-inline member functions
    for the class OBJECT, the root of the Ulib hierarchy. OBJECT's
    constructor merely initializes it's internal CLASS_DESCRIPTOR to point
    to the static descriptor for the class at the beginning of this
    construction chain.

Author:

    David J. Gilman (davegi) 30-Oct-1990

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

OBJECT::OBJECT(
    )
{
}

OBJECT::~OBJECT(
    )
{
}


LONG
OBJECT::Compare (
    IN PCOBJECT Object
    ) CONST

/*++

Routine Description:

    Compare two objects based on their CLASS_ID's

Arguments:
    
    Object - Supplies the object to compare with.

Return Value:

    LONG     < 0    - supplied OBJECT has a higher CLASS_ID
            == 0    - supplied object has same CLASS_ID
             > 0    - supplied OBJECT has a lower CLASS_ID

Notes:

    It is expected that derived classes will overload this method and supply
    an implementation that is more meaningful (i.e. class specific). This
    implementation is ofeered as a default but is fairly meaningless as
    CLASS_IDs are allocated randomly (but uniquely) at run-time by
    CLASS_DESCRIPTORs. Therefore comparing two CLASS_IDs is not very
    interesting (e.g. it will help if an ORDERED_CONTAINER of homogenous
    objects is sorted).

--*/

{
    LONG    r;

    DebugPtrAssert( Object );

    r = (LONG)(QueryClassId() - Object->QueryClassId());

    return r ? r : (LONG)(this - Object);
}


DEFINE_OBJECT_DBG_FUNCTIONS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    This module implements pre-compiled headers for ulib.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _ULIB_MEMBER_

//
// Include all ulib headers, except a couple of troublemakers.
//

#include "ulib.hxx"
#include "smsg.hxx"
#include "array.hxx"
#include "basesys.hxx"
#include "bitvect.hxx"
#include "buffer.hxx"
#include "bufstrm.hxx"
#include "bytestrm.hxx"
#include "contain.hxx"
#include "wstring.hxx"
#include "system.hxx"
#include "achkmsg.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "chkmsg.hxx"
#include "comm.hxx"
#include "dir.hxx"
#include "error.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "fsnode.hxx"
#include "ifsentry.hxx"
#include "ifsserv.hxx"
#include "iterator.hxx"
#include "keyboard.hxx"
#include "list.hxx"
#include "listit.hxx"
#include "mbstr.hxx"
#include "membmgr.hxx"
#include "membmgr2.hxx"
#include "message.hxx"
#include "newdelp.hxx"
#include "path.hxx"
#include "pipe.hxx"
#include "pipestrm.hxx"
#include "program.hxx"
#include "prtstrm.hxx"
#include "rtmsg.h"
#include "screen.hxx"
#include "seqcnt.hxx"
#include "sortcnt.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "stream.hxx"
#include "string.hxx"
#include "stringar.hxx"
#include "substrng.hxx"
#include "ulibcl.hxx"
#include "timeinfo.hxx"
#include "object.hxx"
#include "clasdesc.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\pipestrm.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    pipestrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of PIPE_STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "pipestrm.hxx"

#define BUFFER_SIZE 4*1024


DEFINE_CONSTRUCTOR ( PIPE_STREAM, BUFFER_STREAM );


DEFINE_CAST_MEMBER_FUNCTION( PIPE_STREAM );


PIPE_STREAM::~PIPE_STREAM (
    )

/*++

Routine Description:

    Destroy a PIPE_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
}


BOOLEAN
PIPE_STREAM::Initialize(
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Initializes a PIPE_STREAM object.

Arguments:

    Handle - Handle to the anonymous pipe.

    Access - Access allowed to the stream.


Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    if( ( Access == READ_ACCESS ) || ( Access == WRITE_ACCESS ) ) {
        _PipeHandle = Handle;
        _Access = Access;
        _EndOfFile = FALSE;
        return( BUFFER_STREAM::Initialize( BUFFER_SIZE ) );
    } else {
        return( FALSE );
    }
}


BOOLEAN
PIPE_STREAM::EndOfFile(
    ) CONST

/*++

Routine Description:

    Informs the caller if end of file has occurred. End of file happens
    when all bytes were read from the pipe (in the case of anonymous
    pipe, "end of file" happens when ReadFile returns STATUS_END_OF_FILE).

Arguments:

    None.

Return Value:

    A boolean value that indicates if end of file was detected.


--*/


{
    return( _EndOfFile );
}

#ifdef FE_SB  // v-junm - 10/15/93

BOOLEAN
PIPE_STREAM::CheckIfLeadByte(
    IN PUCHAR   text,
    IN ULONG   offset
    )

/*++

Routine Description:

    Checks to see if the character at an given offset in a MBCS string is a
    leadbyte of a DBCS character.

Arguments:

    text - MBCS string.

Return Value:

    TRUE - if char is leadbyte.
    FALSE - otherwise.

--*/

{
    ULONG   i = offset;

    for ( ; i; i-- )
        if ( !IsDBCSLeadByte ( text[i] ) )
            break;

    return( (BOOLEAN)(( offset - i ) % 2) );
}

#endif



BOOLEAN
PIPE_STREAM::FillBuffer(
    IN  PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with bytes read from the pipe, if the pipe has
    READ_ACCESS.
    Returns FALSE if the pipe has WRITE_ACCESS.

Arguments:

    Buffer - Buffer where the bytes are to be stored.

    BufferSize - Size of the buffer.

    BytesRead - Pointer to the variable that will contain the number of bytes
                put in the buffer.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    BOOL    Result;
    PBYTE   p;

#ifdef FE_SB  // v-junm - 10/15/93

    //
    // This define keeps the remaining leadbyte that was read from the
    // pipe stream and concatanates it to the next set of strings read.
    // The remaining byte means that if there is a leadbyte at the end
    // of a string without a cooresponding tail byte.
    //
    // NOTE: The following code assumes that the pipe stream is always
    // constant and is continuously reading from the same pipe for the
    // same caller.
    //

    static BYTE   LeadByte = 0;


    //
    // If there was a leadbyte, put it in buffer and decrement buffer size.
    //

    if ( LeadByte != 0 )  {
        *Buffer++ = LeadByte;
        BufferSize--;
    }

#endif

    Result = FALSE;
    if( _Access == READ_ACCESS ) {
        Result = ReadFile( _PipeHandle,
                           Buffer,
                           BufferSize,
                           BytesRead,
                           NULL );

        // Treat broken pipe as end of file rather than a read error
        // _EndOfFile will be set to TRUE if *BytesRead = 0
        Result = Result || (GetLastError() == ERROR_BROKEN_PIPE);

#ifdef FE_SB  // v-junm - 10/15/93

        //
        // If there was a leadbyte placed earlier,
        // re-adjust buffer and buffercount.
        //

        if ( LeadByte != 0 ) {
            *BytesRead = *BytesRead + 1;
            Buffer--;
        }

        //
        // If bytes were read, check if string ends with a leadbyte.
        // If so, save it for next time.
        //

        if ( (*BytesRead != 0) && CheckIfLeadByte( Buffer, *BytesRead-1 ) )  {

            //
            // Check if buffer contains only the leadbyte that was placed
            // from the previous call to this function.
            //

            if ( (LeadByte != 0) && (*BytesRead == 1) )
                LeadByte = 0;
            else  {

                //
                // Leadbyte is at end of string. save it for next time
                // and adjust buffer size so a null will be replaced
                // for the leadbyte.
                //

                LeadByte = *(Buffer + *BytesRead - 1);
                *BytesRead = *BytesRead - 1;
            }

        }
        else
            LeadByte = 0;

#endif

        // no bytes read means end of file

        if( *BytesRead ) {
            p = (PBYTE)Buffer + *BytesRead;
            *p++ = '\0';
            *p   = '\0';
        } else {
            _EndOfFile = TRUE;
        }

    }
    return( Result != FALSE );
}



STREAMACCESS
PIPE_STREAM::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the type of access of the pipe stream

Arguments:

    None.

Return Value:

    The stream access.


--*/


{
    return( _Access );
}



HANDLE
PIPE_STREAM::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the file handle

Arguments:

    None.

Return Value:

    The file handle.


--*/


{
    return( _PipeHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\path.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    path.cxx

Abstract:

    This contains the implementation for all methods handling file
    path names. These are needed for use with an file i/o or the
    FILE and DIR objects.

Author:

    bruce wilson    w-wilson    21-Mar-90
    steve rowe      stever      27-Dec-90

Environment:

    ULIB, user mode

Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

extern "C" {
    #include <string.h>
}
#include "ulib.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "system.hxx"

#if DBG==1
    #define PATH_SIGNATURE  0xADDBEEAD
#endif


typedef enum _SPECIAL_DEVICES {
    LPT,
    COM,
    CON,
    PRN,
    AUX,
    LAST_SPECIAL_DEVICE
} SPECIAL_DEVICES;


//
// Static member data.
//

STATIC PWSTRING    _SlashString;
STATIC PWSTRING    _SpecialDevices[ LAST_SPECIAL_DEVICE ];

#define     DELIMITER_STRING    "\\"
#define     DELIMITER_CHAR      ((WCHAR)'\\')


BOOLEAN
PATH::Initialize (
    )

/*++

Routine Description:

    Perform global initialization of the PATH class.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if global initialization was succesful

Notes:

    Global initialization should be interpreted as class (rather than object)
    initialization. This routine should be called by ALL other
    PATH::Initialize member functions.

    Current this routine:

        - constructs and initializes _SlashString, a WSTRING that
          contains a '\'

--*/

{
    STATIC LONG     InitializingPathConstants = 0;
    STATIC BOOLEAN  fInit = FALSE;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingPathConstants, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if (!fInit) {

        if ( (( _SlashString = NEW DSTRING) != NULL)        &&
             ((_SpecialDevices[LPT] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[COM] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[CON] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[PRN] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[AUX] = NEW DSTRING) != NULL) &&
             _SlashString->Initialize( DELIMITER_STRING )   &&
             _SpecialDevices[LPT]->Initialize( "LPT" )      &&
             _SpecialDevices[COM]->Initialize( "COM" )      &&
             _SpecialDevices[CON]->Initialize( "CON" )      &&
             _SpecialDevices[PRN]->Initialize( "PRN" )      &&
             _SpecialDevices[AUX]->Initialize( "AUX" )
           ) {

            status = InterlockedDecrement(&InitializingPathConstants);
            DebugAssert(status == 0);
            return fInit = TRUE;

        }
    }

    status = InterlockedDecrement(&InitializingPathConstants);
    DebugAssert(status == 0);
    return fInit;
}

ULIB_EXPORT
BOOLEAN
PATH::EndsWithDelimiter (
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path ends with slash

Arguments:

    None.

Return Value:

    BOOLEAN -   Returns TRUE if the path ends with a slash

--*/
{

    return ( _PathString.QueryChAt( _PathString.QueryChCount() - 1 ) == DELIMITER_CHAR );

}

ULIB_EXPORT
PARRAY
PATH::QueryComponentArray (
    OUT PARRAY  Array
    ) CONST

/*++

Routine Description:

    Obtain an array of strings containing all the components in the path.
    Each string will have an element in the path delimited by '\\'

Arguments:

    Array   -   Supplies an optional pointer to the array to fill.

Return Value:

    Pointer to the array

--*/

{

    CHNUM           Index;
    CHNUM           DelimiterPosition;
    CHNUM           StringSize;
    PWSTRING        Component;

    if (!Array) {
        Array = NEW ARRAY;
    }

    if (Array == NULL) {
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }

    DebugAssert( _Initialized == TRUE );

    Array->Initialize();

    Index = 0;
    StringSize = _PathString.QueryChCount();

    while ( ( Index < StringSize) &&
            ( _PathString.QueryChAt( Index ) == DELIMITER_CHAR ) ) {
        Index++;
    }

    while ( Index < StringSize ) {

        DelimiterPosition = _PathString.Strchr( DELIMITER_CHAR, Index );

        Component = _PathString.QueryString( Index,
            (DelimiterPosition == INVALID_CHNUM) ? TO_END : DelimiterPosition - Index );

        DebugPtrAssert( Component );

        if ( !Component ) {
            break;
        }

        Array->Put( Component );

        if ( DelimiterPosition == INVALID_CHNUM ) {
            Index = StringSize;
        } else {
            Index = DelimiterPosition + 1;
        }
    }

    return Array;
}

CHNUM
PATH::QueryDeviceLen(
    IN  PWSTRING pString
    ) CONST

/*++

Routine Description:

    Find length in character of drive section

Arguments:

    pString - Supplies the string to determine drive size.

Return Value:

    CHNUM - Number of characters making up drive section. If no
            drive section then the length is 0.

--*/
{
    CHNUM           Position = 0;
    CHNUM           Position1;
    SPECIAL_DEVICES Index;
    ULONG           tmp;
    INT             Pos;
    LONG            Number;


    UNREFERENCED_PARAMETER( (void)this );

    DebugPtrAssert( pString );

    if ( pString->QueryChCount() > 0 ) {

        //
        //  Check for special device
        //
        Pos = (INT)pString->QueryChCount() - 1;

        while ( (Pos >= 0) && (pString->QueryChAt( (CHNUM)Pos ) != DELIMITER_CHAR) ) {
            Pos --;
        }

        Pos++;

        for (Index = LPT; Index < LAST_SPECIAL_DEVICE;
             (tmp = (ULONG) Index, tmp++, Index = (SPECIAL_DEVICES) tmp) ) {

            if ( !pString->Stricmp( _SpecialDevices[Index],
                                    (CHNUM)Pos ) ) {

                Position = (CHNUM)Pos + _SpecialDevices[Index]->QueryChCount();

                //
                //  LPT && COM must be followed by a number;
                //
                if ( (Index == LPT) || (Index == COM) ) {
                    if ( Position >= pString->QueryChCount()) {
                        continue;
                    }
                    while ( (Position < pString->QueryChCount()) &&
                            pString->QueryNumber( &Number, Position, 1 ) ) {

                        Position++;
                    }
                }

                if (Position >= pString->QueryChCount()) {
                     return Position;
                } else if (pString->QueryChAt( Position ) == (WCHAR)':') {
                    return Position+1;
                }
            }
        }
        //
        //  Look for ':'
        //
        if ((Position = pString->Strchr((WCHAR)':')) != INVALID_CHNUM) {
            return Position + 1;
        }

        //
        // check for leading "\\"
        //
        if  ( pString->QueryChCount() > 1           &&
              pString->QueryChAt(0) == DELIMITER_CHAR &&
              pString->QueryChAt(1) == DELIMITER_CHAR) {

            //
            // the device is a machine name - find the second backslash
            // (start search after first double backsl). Note that this
            //  means that the device names if formed by the machine name
            //  and the sharepoint.
            //
            if ( ((Position  = pString->Strchr( DELIMITER_CHAR, 2 )) != INVALID_CHNUM )) {

                 Position1 = pString->Strchr( DELIMITER_CHAR, Position+1 );
                 if ( Position1 == INVALID_CHNUM ) {
                    return pString->QueryChCount();
                 }
                 return Position1;

            }

            //
            //  No backslash found, this is an invalid device
            //
            DebugAbort( "Invalid Device name" );

        }


    }

    return 0;
}

VOID
PATH::SetPathState(
    )

/*++

Routine Description:

    Sets the state information for the Path

Arguments:

    None.

Return Value:

    None.

--*/

{

    CHNUM chnLastSlash;
    CHNUM chnLastDot;
    CHNUM chnAcum;
    CHNUM FirstSeparator;

    //
    // Find the number of characters in the device name
    //
    chnAcum = _PathState.DeviceLen = QueryDeviceLen( &_PathString );

    //
    // Find the number of characters in the dirs portion of the path
    // by searching for the last '\'
    //
    if ( _PathString.QueryChAt( chnAcum ) == DELIMITER_CHAR ) {
        //
        //  Skip over the slash after the device name
        //
        FirstSeparator = 1;
        chnAcum++;

    } else {

        FirstSeparator = 0;
    }

    if ( chnAcum < _PathString.QueryChCount() ) {

        if (( chnLastSlash = _PathString.Strrchr( DELIMITER_CHAR, chnAcum )) != INVALID_CHNUM ) {

            //
            //  The dirs length is that character position less the length
            //  of the device
            //
            _PathState.DirsLen = chnLastSlash - _PathState.DeviceLen;
            _PathState.SeparatorLen = 1;

            chnAcum += _PathState.DirsLen;
            if ( FirstSeparator ==  0 ) {
                chnAcum++;
            }
        } else {
            //
            // There is no dirs portion of this path, but there is a name.
            //
            _PathState.DirsLen      = FirstSeparator;
            _PathState.SeparatorLen = 0;

        }
    } else {

        //
        //  There is no name portion in this path, and the dirs portion
        //  might be empty (or consist solely of the delimiter ).
        //
        _PathState.DirsLen      = FirstSeparator;
        _PathState.SeparatorLen = 0;
    }

    if ( chnAcum < _PathString.QueryChCount() ) {

        //
        // Find the number of characters in the name portion of the path
        // by searching for the last '.'
        //
        if (( chnLastDot = _PathString.Strrchr( ( WCHAR )'.',
                                                chnAcum )) != INVALID_CHNUM ) {

            _PathState.BaseLen = chnLastDot - chnAcum;

            chnAcum += _PathState.BaseLen + 1;

            _PathState.ExtLen   = _PathString.QueryChCount() - chnAcum;

            _PathState.NameLen  = _PathState.BaseLen + _PathState.ExtLen + 1;


        } else {

            //
            // There is no last '.' so the name length is the length of the
            // component from the last '\' to the end of the path (adjusted
            // for zero base) and there is no extension.
            //

            _PathState.NameLen = _PathString.QueryChCount() - chnAcum;
            _PathState.BaseLen = _PathState.NameLen;
            _PathState.ExtLen  = 0;

        }
    } else {

        //
        //  There is no name part
        //
        _PathState.NameLen = 0;
        _PathState.BaseLen = 0;
        _PathState.ExtLen  = 0;

    }


    //
    // The prefix length is the sum of the device and dirs
    //
    _PathState.PrefixLen = _PathState.DeviceLen + _PathState.DirsLen;

    //
    //  If The device refers to a drive, uppercase it. (Done for
    //  compatibility with some DOS apps ).
    //
    if ( _PathState.DeviceLen == 2 ) {
        _PathString.Strupr( 0,  1 );
    }

}

DEFINE_EXPORTED_CONSTRUCTOR( PATH, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( PATH );

VOID
PATH::Construct (
    )

{
    _PathState.BaseLen  = 0;
    _PathState.DeviceLen= 0;
    _PathState.DirsLen  = 0;
    _PathState.ExtLen   = 0;
    _PathState.NameLen  = 0;
    _PathState.PrefixLen= 0;

    _PathBuffer[0] = 0;
    _PathString.Initialize(_PathBuffer, MAX_PATH);

#if DBG==1
    _Signature  =   PATH_SIGNATURE;
#endif

}

ULIB_EXPORT
BOOLEAN
PATH::Initialize(
    IN PCWSTR   InitialPath,
    IN BOOLEAN  Canonicalize
    )

/*++

Routine Description:

    Initialize a PATH object with the supplied string.  No validation
    on the given path is performed unless 'Canonicalize' is set to TRUE.

Arguments:

    InitialPath - Supplies a zero terminated string
    Canonicalize- Supplies a flag, which if TRUE indicates that the PATH
        should be canoicalized at initialization time (i.e. now)

Return Value:

    BOOLEAN - Returns TRUE if the PATH was succesfully initialized.

--*/

{
    PWSTR       filepart;
    DWORD       CharsInPath;


    DebugPtrAssert( InitialPath );

    //
    // Perform global (class) initialization
    //
    if (!Initialize()) {
        DebugAbort( "Class initialization failed" );
        return FALSE;
    }

    // Avoid copies during Strcat by making this a reasonable size.
    if (!_PathString.NewBuf(MAX_PATH - 1)) {
        return FALSE;
    }

    if ( Canonicalize ) {

        if (!_PathString.NewBuf(MAX_PATH - 1) ||
            !(CharsInPath = GetFullPathName((LPWSTR) InitialPath,
                                            MAX_PATH,
                                            (LPWSTR) _PathString.GetWSTR(),
                                            &filepart)) ||
            CharsInPath > MAX_PATH) {

            return FALSE;
        }

        _PathString.SyncLength();

        SetPathState( );
#if DBG==1
        _Initialized = TRUE;
#endif
        return TRUE;

    } else if( ((PWSTRING) &_PathString)->Initialize( InitialPath )) {

        SetPathState( );
#if DBG==1
        _Initialized = TRUE;
#endif
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PATH::Initialize(
    IN PCWSTRING    InitialPath,
    IN BOOLEAN      Canonicalize

    )
{
    DebugPtrAssert( InitialPath );

    return Initialize( InitialPath->GetWSTR(), Canonicalize );
}

ULIB_EXPORT
BOOLEAN
PATH::Initialize (
    IN PCPATH       InitialPath,
    IN BOOLEAN      Canonicalize
    )

{
    DebugPtrAssert( InitialPath );

    return Initialize( InitialPath->GetPathString()->GetWSTR(), Canonicalize );
}

ULIB_EXPORT
PATH::~PATH (
    )

{
}

ULIB_EXPORT
BOOLEAN
PATH::AppendBase (
    IN PCWSTRING Base,
    IN BOOLEAN          Absolute
    )

/*++

Routine Description:

    Append the supplied name to the end of this PATH.

Arguments:

    Base        - Supplies the string to be appended.
    Absolute    - Supplies a flag which if TRUE means that the path must
                  be absolute.

Return Value:

    BOOLEAN - Returns TRUE if the '\' and the supplied string was succesfully
        appended.

--*/

{
    BOOLEAN     AppendedSlash = FALSE;

    DebugPtrAssert( Base );
    DebugAssert( _Initialized );

    //
    //  If the path does not consist of only a drive letter followed by a
    //  colon, we might need to add a '\'
    //
    if ( _PathString.QueryChCount() > 0 ) {
        if ( !(( _PathState.DeviceLen == _PathString.QueryChCount()) &&
              ( _PathString.QueryChAt( _PathState.DeviceLen - 1) == (WCHAR)':')) ||
              Absolute ) {


            if ( _PathString.QueryChAt( _PathString.QueryChCount() - 1 ) != (WCHAR)'\\' ) {

                if ( !_PathString.Strcat( _SlashString )) {
                    return FALSE;
                }

                AppendedSlash = TRUE;
            }
        }
    }

    //
    //  Append the base
    //
    if ( _PathString.Strcat( Base )) {
        SetPathState();
        return TRUE;
    }

    //
    //  Could not append base, remove the slash if we appended it
    //
    if ( AppendedSlash ) {
        TruncateBase();
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PATH::HasWildCard (
    ) CONST

/*++

Routine Description:

    Determines if the name portion of the path contains wild cards

Arguments:

    None.

Return Value:

    TRUE if the name portion of the path has wild cards
    FALSE otherwise

--*/

{

    FSTRING WildCards;

    DebugAssert( _Initialized );

    if ( _PathString.QueryChCount() > 0 ) {

        WildCards.Initialize( (PWSTR) L"*?" );

        if (_PathString.Strcspn( &WildCards, _PathState.PrefixLen ) != INVALID_CHNUM ) {
            return TRUE;
        }
    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
PATH::IsDrive(
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path refers to a device name

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if the path is a device name.
                FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    return ( _PathState.DeviceLen > 0 ) &&
           ( (_PathString.QueryChCount() == _PathState.DeviceLen) );

}

BOOLEAN
PATH::IsRoot(
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path refers to a root directory

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if the path is a root directory.
                FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    return( ( (_PathString.QueryChCount() == 1 ) &&
          (_PathString.QueryChAt( 0 ) == DELIMITER_CHAR ) ) ||
        ( ( _PathState.DeviceLen > 0 ) &&
          ( _PathString.QueryChCount() == _PathState.DeviceLen + 1 ) &&
          ( _PathString.QueryChAt( _PathState.DeviceLen ) == DELIMITER_CHAR ) )
          );
}

ULIB_EXPORT
PPATH
PATH::QueryFullPath(
    ) CONST

/*++

Routine Description:

Arguments:

    None.

Return Value:

    PPATH

--*/

{


    REGISTER PPATH      pFullPath;
    REGISTER PWSTRING   pFullPathString;

    DebugAssert( _Initialized );

    //
    // If the full path name string for this PATH can not be queried
    // or a new PATH, representing the full path, can not be constructed
    // return NULL.
    //

    if ((( pFullPathString = QueryFullPathString( )) == NULL )  ||
        (( pFullPath = NEW PATH ) == NULL )) {

        return NULL;
    }

    //
    // If the new, full path, can not be initialized, delete it.
    //

    if( ! ( pFullPath->Initialize( pFullPathString ))) {

        DELETE( pFullPath );
    }

    //
    // Delete the full path string and return a pointer to the new, full path
    // (note that the pointer may be NULL).
    //

    DELETE( pFullPathString );

    return pFullPath ;
}

ULIB_EXPORT
PWSTRING
PATH::QueryFullPathString (
    ) CONST
{

    LPWSTR      pszName;

    PWSTRING    pwcFullPathString;
    WSTR         szBufferSrc[ MAX_PATH ];
    WSTR         szBufferTrg[ MAX_PATH ];

    DebugAssert( _Initialized );

    if( (pwcFullPathString = NEW DSTRING ()) != NULL ) {

        if ( _PathString.QueryWSTR( 0, TO_END, szBufferSrc, MAX_PATH ) ) {

            if (GetFullPathName( szBufferSrc,MAX_PATH,szBufferTrg,&pszName)) {

                if (pwcFullPathString->Initialize(szBufferTrg)) {

                    return pwcFullPathString;

                }
            }
        }
    }

    DELETE( pwcFullPathString );

    return NULL;

}

ULIB_EXPORT
BOOLEAN
PATH::SetDevice (
    IN PCWSTRING NewDevice
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewDevice );

    if (_PathState.DeviceLen) {
        if (!_PathString.Replace(QueryDeviceStart(), _PathState.DeviceLen,
                                 NewDevice)) {

            return FALSE;
        }
    } else {
        if (!_PathString.Strcat(NewDevice)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetPrefix (
    IN PCWSTRING NewPrefix
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewPrefix );

    if (_PathState.PrefixLen) {

        if (!_PathString.Replace(QueryPrefixStart(), _PathState.PrefixLen,
                                 NewPrefix)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewPrefix)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
PATH::SetName (
    IN PCWSTRING NewName
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewName );

    if (_PathState.NameLen) {

        if (!_PathString.Replace(QueryNameStart(), _PathState.NameLen,
                                 NewName)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewName)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetBase (
    IN PCWSTRING NewBase
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewBase );

    if (_PathState.BaseLen) {

        if (!_PathString.Replace(QueryBaseStart(), _PathState.BaseLen,
                                 NewBase)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewBase)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetExt (
    IN PCWSTRING NewExt
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewExt );

    if (_PathState.ExtLen) {

        if (!_PathString.Replace(QueryExtStart(), _PathState.ExtLen,
                                 NewExt)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewExt)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
PATH::TruncateBase (
    )

/*++

Routine Description:

    This routine truncates the path after the prefix portion.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the base existed and was succesfully removed.

--*/

{
    DebugAssert( _Initialized );

    // If this is the root then the prefix len will include the \.
    // If not, then it won't.  Either way.  Truncate this string to
    // the prefix length.

    _PathString.Truncate( _PathState.PrefixLen );

    SetPathState();

    return TRUE;
}



ULIB_EXPORT
PPATH
PATH::QueryPath(
    ) CONST

/*++

Routine Description:

Arguments:

    None.

Return Value:

    PPATH

--*/

{


    REGISTER PPATH      pPath;

    DebugAssert( _Initialized );

    if (( pPath = NEW PATH ) == NULL ) {
        return NULL;
    }

    //
    // If the new path can not be initialized, delete it.
    //
    if( ! ( pPath->Initialize( GetPathString()->GetWSTR(), FALSE ))) {

        DELETE( pPath );
    }

    return pPath ;
}

ULIB_EXPORT
PPATH
PATH::QueryWCExpansion(
    IN  PPATH   BasePath
    )
/*++

Routine Description:

    Expands any wildcards in path to match the equivalent characters in
    the base path.

Arguments:

    PCPATH BasePath - The base path from which the equivalent characters are
                    retrieved.

Return Value:

    Pointer to the generated path.


--*/
{
    PPATH               pGeneratedPath;
    PWSTRING            pBasePathStr;
    PWSTRING            pGeneratedPathStr;
    PWSTRING pTmp;
    FSTRING             fstring;
    DSTRING             new_string;

    //
    // Initialize the path to be generated with the current path (this)
    //
    pGeneratedPath = NEW PATH;
    if( pGeneratedPath == NULL ) {
        DebugAbort( "Failed to create a new path.\n" );
        return( NULL );
    }

    // Does the Base have '*' while the ext is not there?  If so then
    // make the extension '*'.

    if (_PathState.ExtLen == 0 &&
        _PathString.Strchr('*', _PathState.PrefixLen) != INVALID_CHNUM &&
        _PathString.QueryChAt(_PathString.QueryChCount() - 1) != '.') {

        if (!new_string.Initialize(GetPathString()) ||
            !new_string.Strcat(fstring.Initialize((PWSTR) L".*")) ||
            !pGeneratedPath->Initialize(&new_string)) {

            return NULL;
        }
    } else {
        if (!pGeneratedPath->Initialize(GetPathString())) {
            return NULL;
        }
    }

    if( ( pTmp = pGeneratedPath->QueryBase() ) != NULL ) {
        pGeneratedPathStr = pTmp->QueryString();
        DebugPtrAssert( pGeneratedPathStr );
        DELETE( pTmp );

        //
        // If the base path doesn't have a findable base, return an error...
        // (filenames must have a base - in Dos anyways...)
        //
        if( ( pTmp = BasePath->QueryBase() ) == NULL ) {
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pBasePathStr = pTmp->QueryString();
        DebugPtrAssert( pBasePathStr );
        DELETE( pTmp );

        if( !ExpandWildCards( pBasePathStr, pGeneratedPathStr ) ) {
            DELETE( pBasePathStr );
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pGeneratedPath->SetBase( pGeneratedPathStr );
        DELETE( pBasePathStr );
        DELETE( pGeneratedPathStr );
    }

    if( ( pTmp = pGeneratedPath->QueryExt() ) != NULL ) {
        pGeneratedPathStr = pTmp->QueryString();
        DebugPtrAssert( pGeneratedPathStr );

        DELETE( pTmp );

        //
        // If no extension is found, create an empty string to pass to
        // the wildcard expansion routine - this is to allow 'tmp.*' to
        // match 'tmp.'...
        //
        if( ( pTmp = BasePath->QueryExt() ) == NULL ) {
            pBasePathStr = NEW DSTRING;
            pBasePathStr->Initialize();
        } else {
            pBasePathStr = pTmp->QueryString();
            DebugPtrAssert( pBasePathStr );
            DELETE( pTmp );
        }

        if( !ExpandWildCards( pBasePathStr, pGeneratedPathStr ) ) {
            DELETE( pBasePathStr );
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pGeneratedPath->SetExt( pGeneratedPathStr );
        DELETE( pBasePathStr );
        DELETE( pGeneratedPathStr );
    }
    return( pGeneratedPath );
}

BOOLEAN
PATH::ExpandWildCards(
    IN  OUT PWSTRING    pStr1,
    IN  OUT PWSTRING    pStr2
    )
/*++

Routine Description:

    Expands any wildcards in string 2 to match the equivalent characters in
    string 1.  Used by QueryWildCardExpansion().

Arguments:

    Str1    - A pointer to the 'base' string
    Str2    - A pointer to the string to be expanded

Return Value:

    TRUE if expansion was successful.

--*/
{
    CHNUM       idx;


    UNREFERENCED_PARAMETER( (void)this);

    // Deal with the * wild card first...
    //
    // Note: This method will ignore, even remove, any characters after the
    //       '*' in string 2.  This is to comform with the behavior of Dos...
    //
    if( ( idx = pStr2->Strchr( '*' ) ) != INVALID_CHNUM ) {
        if( idx > pStr1->QueryChCount() ) {
            return( FALSE );
        }
        if( idx == pStr1->QueryChCount() ) {
            pStr2->Truncate( idx );
        } else {
            pStr2->Replace( idx, TO_END, pStr1, idx, TO_END );
        }
    }

    // Now convert any '?' in the base
    while( ( idx = pStr2->Strchr( '?' ) ) != INVALID_CHNUM ) {
        // Make sure that the wild card is within the limits of the
        // base string...
        if( idx >= pStr1->QueryChCount() ) {
            return( FALSE );
        }
        pStr2->SetChAt( pStr1->QueryChAt( idx ), idx );
    }
    return( TRUE );
}

ULIB_EXPORT
BOOLEAN
PATH::ModifyName (
    IN  PCWSTRING Pattern
    )

/*++

Routine Description:

    Modifies the file name of the path according to a pattern. The pattern
    may contain wildcards.

Arguments:

    Pattern     -   Supplies pointer to string with the pattern

Return Value:

    none

--*/

{
    PATH        PatternPath;
    PPATH       TargetPath;
    PWSTRING    NewName;


    // If the pattern is trivial then just bail out since there's
    // nothing to change.

    if (Pattern->QueryChCount() == 1 &&
        Pattern->QueryChAt(0) == '*') {

        return TRUE;
    }

    if (Pattern->QueryChCount() == 3 &&
        Pattern->QueryChAt(0) == '*' &&
        Pattern->QueryChAt(1) == '.' &&
        Pattern->QueryChAt(2) == '*') {

        return TRUE;
    }

    if (!PatternPath.Initialize(Pattern)) {
        return FALSE;
    }

    TargetPath = PatternPath.QueryWCExpansion(this);
    if (!TargetPath) {
        return FALSE;
    }

    NewName = TargetPath->QueryName();

    DELETE(TargetPath);

    if (!NewName) {
        return FALSE;
    }

    TruncateBase();
    AppendBase( NewName );

    DELETE( NewName );

    return TRUE;
}

ULIB_EXPORT
VOID
PATH::TruncateNameAtColon (
    )

/*++

Routine Description:

    This is an awful hack to keep XCopy compatibility.

    If the last segment of the path contains a colon, we truncate the
    path at that point.

Arguments:

    none

Return Value:

    none

--*/

{

    CHNUM   IndexColon;
    CHNUM   IndexDelimiter;


    IndexColon     = _PathString.Strrchr( (WCHAR)':', 0 );

    if ( IndexColon != INVALID_CHNUM ) {

        IndexDelimiter = _PathString.Strrchr( DELIMITER_CHAR, 0 );

        if ( ( IndexDelimiter == INVALID_CHNUM ) ||
             ( IndexColon > IndexDelimiter ) ) {

            if (IndexColon > 1) {

                //
                //  Truncate the path
                //
                _PathString.Truncate( IndexColon );
                SetPathState();
            }
        }
    }
}




ULIB_EXPORT
PWSTRING
PATH::QueryRoot (
    )

/*++

Routine Description:

    Returns a string that contains the canonicalized name of the root
    directory (device name followed by "\").

    QueryRoot returns NULL if there is no device component part of
    this path.  In other words it may be necessary to canonicalize
    the path before having access to the Root.

Arguments:

    none

Return Value:

    Pointer to a WSTRING that contains the root directory in its
    canonicalized form.

--*/

{
    PWSTRING    Root;

    if( _PathState.DeviceLen == 0 ) {
        return( NULL );
    }
    Root = NEW( DSTRING );

    if (Root == NULL) {
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }

    if( !Root->Initialize( &_PathString, 0, _PathState.DeviceLen ) ) {
        DELETE( Root );
        return( NULL );
    }

    Root->Strcat( _SlashString );
    return( Root );
}

ULIB_EXPORT
VOID
PATH::TruncateDelimiter (
        )
/*++

Routine Description:

    This routine truncates a delimiter character from the end
    of the path and recomputes the state of the path.

Arguments:

    none

Return Value:

    none

--*/
{
    if (EndsWithDelimiter()) {
        _PathString.DeleteChAt(_PathString.QueryChCount()-1);
        SetPathState();
    }
}


ULIB_EXPORT
BOOLEAN
PATH::AppendDelimiter (
        )
/*++

Routine Description:

    This routine adds a delimiter character to the end of the
    path and recomputes the state of the path.

Arguments:

    none

Return Value:

    TRUE    - success
    FALSE   - failure

--*/
{
    if (!_PathString.Strcat(_SlashString)) {
        return FALSE;
    }
    SetPathState();
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
PATH::AppendString (
    IN PCWSTRING    String
        )
/*++

Routine Description:

    This routine adds a string to the existing path and
    recompute the state of the path.

Arguments:

    String  - Supplies the string to be appended to the end
              of the path.

Return Value:

    TRUE    - success
    FALSE   - failure

--*/
{
    if (!_PathString.Strcat(String)) {
        return FALSE;
    }
    SetPathState();
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
PATH::IsGuidVolName(
    )
/*++

Routine Description:

    This routine checks to see if the given path is a guid volume name.

Arguments:

    none

Return Value:

    TRUE if the path starts with a guid volume name.

--*/
{
    DSTRING     guid_vol_name_header;

    if (_PathState.DeviceLen == 0)
        return FALSE;

    if (!guid_vol_name_header.Initialize(DOS_GUIDNAME_PREFIX GUID_VOLNAME_PREFIX)) {
        DebugPrint("Out of memory.\n");
        return FALSE;
    }

    return _PathString.Stricmp(&guid_vol_name_header,
                               0,
                               guid_vol_name_header.QueryChCount()) == 0;
}

ULIB_EXPORT
PPATH
PATH::QueryMountPointPath(
    )
/*++

Routine Description:

    This routine substitute the guid volume name with a mount point name.

Arguments:

    none

Return Value:

    Returns a mount point path which is the equivalent of the guid volume
    name path.
    Returns NULL if path already has a drive letter, or non-guid path, or
    no mount point path.

--*/
{
#if !defined(RUN_ON_NT4)
    PWSTRING    vol_name;
    FSTRING     mount_point;
    WCHAR       vol_mount_point[MAX_PATH];
    PPATH       p;
    WCHAR       c, name[5];

    //
    // no need to translate if already a path
    //
    if (!IsGuidVolName() ||
        (GetPathString()->QueryChAt(1) == (WCHAR)':'))
        return NULL;

    vol_name = QueryDevice();

    if (vol_name == NULL)
        return NULL;

    vol_name->Strcat(_SlashString);

    name[1] = ':';
    name[2] = '\\';
    name[3] = 0;

    for (c='A'; c <= 'Z'; c++) {
        name[0] = c;
        if (!GetVolumeNameForVolumeMountPoint(name, vol_mount_point, MAX_PATH))
            continue;
        if (_wcsicmp(vol_mount_point, vol_name->GetWSTR()) == 0) {
            name[2] = 0;    // no backslash
            p = NEW PATH;
            if (!p ||
                !vol_name->Initialize(name) ||
                !p->Initialize(this) ||
                !p->SetDevice(vol_name)) {
                DELETE(vol_name);
                DELETE(p);
                return NULL;
            }
            DELETE(vol_name);
            return p;
        }
    }

    for (c='A'; c <= 'Z'; c++) {
        name[0] = c;
        if (BuildMountPoint(name, vol_name->GetWSTR(), vol_mount_point)) {
            p = NEW PATH;
            if (!p ||
                !vol_name->Initialize(vol_mount_point) ||
                !p->Initialize(this) ||
                !p->SetDevice(vol_name)) {
                DELETE(vol_name);
                DELETE(p);
                return NULL;
            }
            DELETE(vol_name);
            return p;
        }
    }
    DELETE(vol_name);
    return NULL;
#else
    return NULL;
#endif
}

ULIB_EXPORT
PWSTRING
PATH::QueryGuidString(
        OUT PWSTRING    LongestMountPointPath,
        OUT PBOOLEAN    IsLongestMountPointADriveLetter,
        OUT PWSTRING    DrivePath
    )
/*++

Routine Description:

    This routine translates the longest valid mount point path into a guid volume
    name.  If the given path starts with a guid volume name, NULL will be returned.
    If it is just a root drive, null will be returned.

Arguments:

    LongestMountPointPath   - gets the longest valid mount point path or the
                              given guid volume name.
    DrivePath               - gets the mount point path that is not part of
                              the mount point.

Return Value:

    Returns a mount point path which is the equivalent of the guid volume name path.

--*/
{
#if !defined(RUN_ON_NT4)
    PATH        vol_name;
    WCHAR       vol_mount_point[MAX_PATH];
    PWSTRING    s;
    FSTRING     null_string;
    PWSTRING    name;
    BOOLEAN     found = FALSE;
    BOOLEAN     has_delimiter;

    if (IsGuidVolName()) {
        return NULL;
    }

    has_delimiter = EndsWithDelimiter();

    s = QueryFullPathString();

    if (!s ||
        !vol_name.Initialize(s) ||
        !null_string.Initialize(L"") ||
        !DrivePath->Initialize(&null_string)) {
        DebugPrint("Out of memory.\n");
        DELETE(s);
        return NULL;
    }

    DELETE(s);

    if (!vol_name.EndsWithDelimiter()) {
        if (!vol_name.AppendDelimiter()) {
            DebugPrint("Out of memory.\n");
            return NULL;
        }
    }

    *IsLongestMountPointADriveLetter = FALSE;

    while (!vol_name.IsDrive()) {
        if (GetVolumeNameForVolumeMountPoint(vol_name.GetPathString()->GetWSTR(),
                                             vol_mount_point,
                                             MAX_PATH)) {
            vol_name.TruncateDelimiter();
            if (vol_name.IsDrive()) {
                *IsLongestMountPointADriveLetter = TRUE;
            }
            if (!LongestMountPointPath->Initialize(vol_name.GetPathString()))
                return NULL;
            found = TRUE;
            break;
        }
        vol_name.TruncateDelimiter();   // remove backslash

        if (vol_name.IsDrive())
            break;

        name = vol_name.QueryName();
        if (name == NULL ||
            !DrivePath->InsertString(0, name) ||
            !DrivePath->InsertString(0, _SlashString)) {
            DebugPrint("Internal Error\n");
            DELETE(name);
            return NULL;
        }

        DELETE(name);

        if (!vol_name.SetName(&null_string)) {
            DebugPrint("SetName failed\n");
            return NULL;
        }
    }

    if (!found) {
        return NULL;
    }

    // remove backslash
    if (has_delimiter) {
        if (!DrivePath->Strcat(_SlashString)) {
            DebugPrint("Out of memory.\n");
            return NULL;
        }
    }

    vol_mount_point[wcslen(vol_mount_point)-1] = 0;

    s = NEW DSTRING;

    if (!s || !s->Initialize(vol_mount_point)) {
        DELETE(s);
        return NULL;
    }

    return s;
#else
    return NULL;
#endif
}


BOOLEAN
PATH::BuildMountPoint(
    IN     PWSTR        Name,
    IN     PCWSTR       GuidNameToMatch,
       OUT PWSTR        MountPointPath
    )
{
#if !defined(RUN_ON_NT4)
    WCHAR       vol_name[MAX_PATH];
    WCHAR       vol_mount_point[MAX_PATH];
    WCHAR       mount_point_path[MAX_PATH];
    HANDLE      h;
    DWORD       oldErrorMode;

    if (!GetVolumeNameForVolumeMountPoint(Name, vol_name, MAX_PATH))
        return FALSE;

    if (_wcsicmp(vol_name, GuidNameToMatch) == 0) {
        wcscpy(MountPointPath, Name);
        MountPointPath[wcslen(MountPointPath)-1] = 0;   // no backslash
        return TRUE;
    }

    oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    h = FindFirstVolumeMountPoint(vol_name, vol_mount_point, MAX_PATH);
    SetErrorMode(oldErrorMode);

    if (h == INVALID_HANDLE_VALUE)
        return FALSE;

    for (;;) {
        if (wcslen(Name) + wcslen(vol_mount_point) >= MAX_PATH) {
            FindVolumeMountPointClose(h);
            return FALSE;
        }

        wcscpy(mount_point_path, Name);
        wcscat(mount_point_path, vol_mount_point);

        if (BuildMountPoint(mount_point_path, GuidNameToMatch, MountPointPath)) {
            FindVolumeMountPointClose(h);
            return TRUE;
        }

        if (!FindNextVolumeMountPoint(h, vol_mount_point, MAX_PATH))
            break;
    }

    FindVolumeMountPointClose(h);

    return FALSE;
#else
    return FALSE;
#endif
}


PATH_ANALYZE_CODE
PATH::AnalyzePath(
       OUT PWSTRING     VolumeName,
       OUT PPATH        VolumePath,
       OUT PWSTRING     RemainingPath
    )
/*++

Routine Description:

    This routine translates the given path into three components.  The first component
    is the ultimate guid volume name.  The second component is the volume path.  It
    can either be a drive letter or a mount point path corresponding to the volume name.
    The third component is the remaining path starting from the ultimate volume.

Arguments:

    VolumeName    - Receives the ultimate guid volume name that the path is pointing to.
                    If the return code is PATH_COULD_BE_FLOPPY, then this variable gets
                    the floppy drive letter.
    VolumePath    - Receives the corresponding drive letter or mount point path to the
                    ultimate guid volume name
    RemainingPath - Receives the path starting from the ultimate guid volume name

Return Value:

    Returns the following status:
        PATH_COULD_BE_FLOPPY
        PATH_OUT_OF_MEMORY
        PATH_INVALID_DRIVE_SPEC
        PATH_OK
--*/
{
#if !defined(RUN_ON_NT4)
    DSTRING     volume_path;
    BOOLEAN     is_volume_path_a_drive;
    PPATH       ppath, qpath;
    PWSTRING    p;

    if (!VolumeName->Initialize() ||
        !VolumePath->Initialize(VolumeName) ||
        !RemainingPath->Initialize()) {
        return PATH_OUT_OF_MEMORY;
    }

    if (IsGuidVolName()) {
        if (!IsDrive()) {
            // there is something besides the guid volume name
            // translate the guid name path to a mount point path
            if (!(ppath = QueryMountPointPath())) {
                // If this guid volume path does not translate into a
                // mount point path, the user must be specifying a
                // directory/file path of a drive letterless drive

                // we don't support that for now

                return PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH;

            } else {
                // see if the mount point path has other mount points in it
                p = ppath->QueryGuidString(&volume_path,
                                           &is_volume_path_a_drive,
                                           RemainingPath);
                DebugAssert(p != NULL);
                if (!p ||
                    !ppath->Initialize(p)) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    DELETE(ppath);
                    return PATH_OUT_OF_MEMORY;
                }

                qpath = ppath->QueryMountPointPath();

                DELETE(ppath);

                if (!qpath) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    return PATH_OUT_OF_MEMORY;
                }

                if (qpath->GetPathString()->QueryChCount() == 2 &&
                    qpath->GetPathString()->QueryChAt(1) == (WCHAR)':' &&
                    volume_path.Stricmp(qpath->GetPathString()) != 0) {
                    if (!volume_path.Initialize(qpath->GetPathString())) {
                        DebugPrint("Out of memory.\n");
                        DELETE(p);
                        DELETE(qpath);
                        return PATH_OUT_OF_MEMORY;
                    }
                }

                DELETE(qpath);

                if (!VolumeName->Initialize(p) ||
                    !VolumePath->Initialize(&volume_path)) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    return PATH_OUT_OF_MEMORY;
                }

                DELETE(p);
            }
        } else {
            // just a drive specification
            ppath = QueryMountPointPath();
            if (!VolumeName->Initialize(&_PathString)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            if (ppath) {
                if (!VolumePath->Initialize(ppath)) {
                    DebugPrint("Out of memory.\n");
                    return PATH_OUT_OF_MEMORY;
                }
                DELETE(ppath);
            }
        }
    } else if (!IsDrive()) {

        CHNUM   offset;

        // a path (not necessary full) with drive letter

        p = QueryDevice();

        if (p) {
            if (!isalpha(p->QueryChAt(0)) ||
                p->QueryChAt(1) != (WCHAR)':' ||
                p->QueryChCount() != 2) {
                DELETE(p);
                return PATH_INVALID_DRIVE_SPEC;
            }
            DELETE(p);
        }

        p = QueryGuidString(&volume_path,
                            &is_volume_path_a_drive,
                            RemainingPath);

        if (p == NULL) {
            // something is not right as there should be
            // a guid volume name for each drive letter
            // unless the drive letter is a floppy, invalid,
            // or we are out of memory
            p = QueryDevice();
            if (!p) {
                return PATH_INVALID_DRIVE_SPEC;
            }

            if (!VolumeName->Initialize(p) ||
                !VolumePath->Initialize(p)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            offset = p->QueryChCount();
            DELETE(p);

            p = _PathString.QueryString(offset);
            if (!p) {
                return PATH_INVALID_DRIVE_SPEC;
            }
            if (!RemainingPath->Initialize(p)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            DELETE(p);

            return PATH_COULD_BE_FLOPPY;
        }

        if ((ppath = NEW PATH) == NULL ||
            !ppath->Initialize(p)) {
            DebugPrint("Out of memory.\n");
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        qpath = ppath->QueryMountPointPath();

        DELETE(ppath);

        if (!qpath) {
            DebugPrint("Out of memory.\n");
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        if (qpath->GetPathString()->QueryChCount() == 2 &&
            qpath->GetPathString()->QueryChAt(1) == (WCHAR)':' &&
            volume_path.Stricmp(qpath->GetPathString()) != 0) {
            if (!volume_path.Initialize(qpath->GetPathString())) {
                DebugPrint("Out of memory.\n");
                DELETE(p);
                DELETE(qpath);
                return PATH_OUT_OF_MEMORY;
            }
        }

        DELETE(qpath);

        if (!VolumeName->Initialize(p) ||
            !VolumePath->Initialize(&volume_path)) {
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        DELETE(p);
    } else {
        // just a drive letter

        if (!isalpha(_PathString.QueryChAt(0)) ||
            _PathString.QueryChAt(1) != (WCHAR)':' ||
            _PathString.QueryChCount() != 2) {
            return PATH_INVALID_DRIVE_SPEC;
        }

        if (!AppendDelimiter()) {
            return PATH_OUT_OF_MEMORY;
        }
        p = QueryGuidString(&volume_path,
                            &is_volume_path_a_drive,
                            RemainingPath);
        TruncateDelimiter();
        if (p == NULL) {
            // something is not right as there should be
            // a guid volume name for each drive letter
            // unless the drive letter is a floppy, invalid,
            // or we are out of memory
            if (!VolumeName->Initialize(&_PathString) ||
                !VolumePath->Initialize(&_PathString)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            return PATH_COULD_BE_FLOPPY;
        }
        DebugAssert(is_volume_path_a_drive);
        if (!VolumeName->Initialize(p) ||
            !VolumePath->Initialize(&volume_path) ||
            !RemainingPath->Initialize()) {
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }
        DELETE(p);
    }
    return PATH_OK;
#else
    return PATH_INVALID_DRIVE_SPEC;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\prnthack.cxx ===
// Because the name of the function to be used is
// DbgPrint, we can't include "ulib.hxx"

void
DbgPrint (
    char* String
    );


void
AutoCheckDisplayString (
    char* String
    )
{
    DbgPrint(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\pipe.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	pipe.cxx

Abstract:

	This module contains the implementation of the PIPE class.

Author:

	Barry J. Gilhuly	(W-Barry)		June 27, 1991

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "pipestrm.hxx"
#include "pipe.hxx"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( PIPE, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( PIPE );


VOID
PIPE::Destroy(
	)
/*++

Routine Description:

	Close the handles which were opened by the initialize method.

Arguments:

	None.

Return Value:

	None.

--*/
{
	if( !_fInitialized ) {
		return;
	}

	//
	// Close the pipe...
	//
	CloseHandle( _hReadPipe );
	CloseHandle( _hWritePipe );
	_fInitialized = FALSE;

	return;
}

BOOLEAN
PIPE::Initialize(
	IN	LPSECURITY_ATTRIBUTES	PipeAttributes,
	IN	ULONG					PipeSize,
	IN	PWSTRING				PipeName
	)
/*++

Routine Description:

	Create a PIPE by making a call to the system API.  If the PIPE object
	has been previously initialized, destroy it first.

Arguments:

	PipeAttributes - A pointer to a structure which defines the attributes
				of the pipe to be created.

	PipeSize	   - A suggested buffer size for the pipe.

	PipeName	   - The name of the pipe.	Currently, this option is
				unimplemented, it should ALWAYS be NULL.

Return Value:

	TRUE if the PIPE was created successfully.

--*/
{
	BOOL PipeStatus = FALSE;

	Destroy();

	if( PipeName == NULL ) {
		//
		// Create an anonomous pipe...
		//
		if( !( PipeStatus = CreatePipe( &_hReadPipe,
						&_hWritePipe,
						PipeAttributes,
						PipeSize ) ) ) {
			DebugPrint( "Unable to create the pipe - returning failure!\n" );
			_fInitialized = FALSE;
		} else {
			_fInitialized = TRUE;
		}
	} else {
		DebugPrint( "Named Pipes are not currently implemented!\n" );
	}
	return( PipeStatus != FALSE );
}

PPIPE_STREAM
PIPE::QueryPipeStream(
	IN	HANDLE			hPipe,
	IN	STREAMACCESS	Access
	)
/*++

Routine Description:

	Create and initialize a stream to the PIPE object.

Arguments:

	hPipe	- A handle to use in the initialization of the stream.

	Access	- The desired access on this stream.

Return Value:

	Returns a pointer to the created PIPE STREAM if successful.  Otherwise,
	it returns NULL.

--*/
{
	PPIPE_STREAM	NewStream;

	if( !_fInitialized ) {
		DebugPrint( "Pipe object is uninitialized!\n" );
		NewStream = NULL;
	} else {
		if( ( NewStream = NEW PIPE_STREAM ) == NULL ) {
			DebugPrint( "Unable to create a new copy of the Read Stream!\n" );
		} else {
			if( !NewStream->Initialize( hPipe, Access ) ) {
				DebugPrint( "Unable to initialize the new stream!\n" );
				DELETE( NewStream );
				NewStream = NULL;
			}
		}
	}
	return( NewStream );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\program.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

	program.cxx

Abstract:

Author:

	David J. Gilman (davegi) 02-Mar-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "path.hxx"
#include "program.hxx"
#include "system.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( PROGRAM, OBJECT, ULIB_EXPORT );

ULIB_EXPORT
PROGRAM::~PROGRAM (
	)
{

}

ULIB_EXPORT
BOOLEAN
PROGRAM::Initialize (
	IN	MSGID	UsageMsg,
	IN	MSGID	FatalMsg,
	IN	ULONG	FatalLevel
	)

/*++

Routine Description:

	Initializes a PROGRAM object.

Arguments:

	UsageMsg	-	Supplies usage (help) message id.
	FatalMsg	-	Supplies default fatal message id.
	FatalLevel	-	Supplies default fatal exit level.

Return Value:

	BOOLEAN -	Returns TRUE if object initialized,
				FALSE otherwise.


--*/

{

	//
	//	Get standard streams.
	//
	_Standard_Input 	= Standard_Input_Stream;
	_Standard_Output	= Standard_Output_Stream;
	_Standard_Error 	= Standard_Error_Stream;

	//
	//	Initialize the message object
	//
    if ( _Standard_Output &&
           _Standard_Input &&
           _Message.Initialize( _Standard_Output, _Standard_Input, _Standard_Error ) ) {

		//
		//	Initialize message ids and error levels

		_UsageMsg	=	UsageMsg;
		_FatalMsg	=	FatalMsg;
		_FatalLevel =	FatalLevel;

		return TRUE;

	}

    _Standard_Input     = NULL;
    _Standard_Output    = NULL;
    _Standard_Error     = NULL;
    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PROGRAM::DisplayMessage (
	IN	MSGID			Message,
	IN	MESSAGE_TYPE	Type
	) CONST

/*++

Routine Description:

	Displays a message

Arguments:

	Message -	Supplies the message id of the message to display
	Type	-	Supplies the type of message

Return Value:

	BOOLEAN -	Returns TRUE if message displayed,
				FALSE otherwise.


--*/

{
	return DisplayMessage( Message, Type, NULL );
}

ULIB_EXPORT
BOOLEAN
PROGRAM::DisplayMessage (
	IN	MSGID		 Message,
	IN	MESSAGE_TYPE Type,
	IN	PSTR		 Format,
	IN	...
	) CONST

/*++

Routine Description:

	Displays a message with arguments


Arguments:

	Message -	Supplies the message id of the message to display
	Type	-	Supplies the message type
	Format	-	Supplies a format string
	... 	-	Supplies list of arguments

Return Value:

	BOOLEAN -	Returns TRUE if message displayed,
				FALSE otherwise.

--*/

{

	va_list Arguments;
	BOOLEAN Status;

    if ( ((PPROGRAM) this)->_Message.Set( Message, Type ) ) {

		if ( !Format ) {

            return ((PPROGRAM) this)->_Message.Display( "" );

		} else {

			va_start( Arguments, Format );
            Status  = ((PPROGRAM) this)->_Message.DisplayV( Format, Arguments );
			va_end( Arguments );
			return Status;
		}
	}

	return FALSE;

}

ULIB_EXPORT
VOID
PROGRAM::ExitProgram (
	ULONG	Level
	)
{
	ExitProcess( Level );
}

ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardInput (
	)

/*++

Routine Description

	Obtains the standard input stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard input stream

--*/

{

	return _Standard_Input;

}

ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardOutput (
	)

/*++

Routine Description

	Obtains the standard output stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard output stream

--*/

{

	return _Standard_Output;

}


ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardError (
	)

/*++

Routine Description

	Obtains the standard error stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard error stream

--*/

{

	return _Standard_Error;

}


ULIB_EXPORT
VOID
PROGRAM::Fatal (
	) CONST

/*++

Routine Description

	Displays the default fatal message and exits with the default
	fatal error level.

Arguments:

	None

Return Value:

	None

--*/

{

	Fatal( _FatalLevel, _FatalMsg, NULL	);

}

ULIB_EXPORT
VOID
PROGRAM::Fatal (
	IN	ULONG	ErrorLevel,
	IN	MSGID	Message,
	IN	PSTR	Format,
	IN	...
	) CONST

/*++

Routine Description:

	Displays a message (with arguments) and exits with the specified
	error level.

Arguments:

	ErrorLevel	-	Supplies the error level to exit with.
	Message 	-	Supplies the id of the message to display
	Format		-	Supplies the format string
	... 		-	Supply pointers to the arguments

Return Value:

	None

--*/

{
	va_list Arguments;

    if ( ((PPROGRAM) this)->_Message.Set( Message, ERROR_MESSAGE ) ) {

		if ( !Format ) {

            ((PPROGRAM) this)->_Message.Display( "" );

		} else {

			va_start( Arguments, Format );
            ((PPROGRAM) this)->_Message.DisplayV( Format, Arguments );

		}
	}

	ExitProcess( ErrorLevel );
}

ULIB_EXPORT
VOID
PROGRAM::Usage (
	) CONST

/*++

Routine Description:

	Displays the usage (help) message and exits with an error level of
	zero.

Arguments:

	None

Return Value:

	None

--*/

{
    ((PPROGRAM) this)->_Message.Set( _UsageMsg, NORMAL_MESSAGE );
    ((PPROGRAM) this)->_Message.Display();

	ExitProcess( 0 );
}

PPATH
PROGRAM::QueryImagePath (
    )

/*++

Routine Description:

	Queries the path to the program image (executable file)

Arguments:

	None

Return Value:

	PPATH	-	Returns a canonicalized path to the program image.

--*/

{
    WSTR     PathName[ MAX_PATH ];
	PPATH	Path;

	if (( GetModuleFileName( NULL, PathName, MAX_PATH ) != 0 )	&&
		(( Path = NEW PATH ) != NULL )							&&
		 Path->Initialize( PathName, TRUE )) {

		return Path;

	}

	return NULL;
}


ULIB_EXPORT
VOID
PROGRAM::ValidateVersion (
	IN	MSGID	InvalidVersionMsg,
	IN	ULONG	ErrorLevel
	) CONST

/*++

Routine Description:

	Validates the version, and if the version is invalid, exits the
	program.

Arguments:

	InvalidVersionMsg	-	Supplies id of message to display if the
							version number is incorrect.

	ErrorLevel			-	Supplies the error level with which to exit
							if the version number is incorrect.

Return Value:

	None (Only returns if is correct version).


--*/

{
	if ( !SYSTEM::IsCorrectVersion() ) {

		Fatal( ErrorLevel, InvalidVersionMsg, "" );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\prtstrm.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	prtstrm.cxx

Abstract:

	This module contains the definitions of the member functions
	of PRINT_STREAM class.

Author:

	Jaime Sasson (jaimes) 12-Jun-1991

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "stream.hxx"
#include "prtstrm.hxx"


DEFINE_EXPORTED_CONSTRUCTOR ( PRINT_STREAM, STREAM, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( PRINT_STREAM );


VOID
PRINT_STREAM::Construct(
    )
{
    _Handle = INVALID_HANDLE_VALUE;
}


ULIB_EXPORT
PRINT_STREAM::~PRINT_STREAM (
	)

/*++

Routine Description:

	Destroy a PRINT_STREAM.

Arguments:

	None.

Return Value:

	None.

--*/

{
	if (INVALID_HANDLE_VALUE != _Handle) {

	    CloseHandle( _Handle );
    }
}



ULIB_EXPORT
BOOLEAN
PRINT_STREAM::Initialize(
    IN PCPATH   DeviceName
    )

/*++

Routine Description:

    Initializes an object of type PRINT_STREAM.

Arguments:

    DevicName   - A path to the device associated with the printer.


Return Value:

    BOOLEAN - TRUE if the initialization succeeded. FALSE otherwise.


--*/


{
    ULONG       FileType;
    PCWSTRING   String;

    String = DeviceName->GetPathString();


    _Handle = CreateFile( String->GetWSTR(),
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,                 // Security attributes
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if( _Handle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    return( STREAM::Initialize() );
}


BOOLEAN
PRINT_STREAM::IsAtEnd(
	) CONST

/*++

Routine Description:

	Informs the caller if end of file has occurred. The concept of
	end of file for a PRINT_STREAM does not have any meaning, so this
	method will always return FALSE.

Arguments:

	None.

Return Value:

	Returns FALSE.


--*/


{
	(void)(this);
	return( FALSE );
}


STREAMACCESS
PRINT_STREAM::QueryAccess(
	) CONST

/*++

Routine Description:

	Returns the type of access of the print stream

Arguments:

	None.

Return Value:

	Returns always WRITE_ACCESS.


--*/


{
	(void)(this);
	return( WRITE_ACCESS );
}



HANDLE
PRINT_STREAM::QueryHandle(
	) CONST

/*++

Routine Description:

	Returns the handle to the stream.

Arguments:

	None.

Return Value:

	Returns a handle.


--*/


{
	return( _Handle );
}


BOOLEAN
PRINT_STREAM::Read(
	OUT PBYTE	Buffer,
	IN	ULONG	BytesToRead,
	OUT PULONG	BytesRead
	)

/*++

Routine Description:

	Reads bytes from the print stream.

Arguments:

	PBYTE - Points that will receive the bytes read.

	ULONG - Number of bytes to read (buffer size)

	PULONG - Points to the variable that will contain the total
			 number of bytes read.

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(Buffer);
	(void)(BytesToRead);
	(void)(BytesRead);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadChar(
	OUT PWCHAR			Char,
        IN      BOOLEAN    Unicode
	)

/*++

Routine Description:

	Reads a character from the print stream.

Arguments:

	Char	-	Supplies poinbter to wide character

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(Char);
	(void)(Unicode);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadString(
	OUT PWSTRING		String,
	IN	PWSTRING		Delimiter,
        IN      BOOLEAN    Unicode
	)

/*++

Routine Description:

	Reads a STRING from the print stream.

Arguments:

	Pointer to the variable that will contain the pointer to the STRING
	object.

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(String);
	(void)(Delimiter);
	(void)(Unicode);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/


{
	// unreferenced parameters
	(void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

	return( FALSE );
}


BOOLEAN
PRINT_STREAM::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/


{
	// unreferenced parameters
	(void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

	return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\smsg.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "smsg.hxx"
#include "array.hxx"
#include "arg.hxx"
#include "iterator.hxx"
#include "system.hxx"
#include "stream.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR(STREAM_MESSAGE, MESSAGE, ULIB_EXPORT)


VOID
STREAM_MESSAGE::Construct(
    )
/*++

Routine Description:

    Constructor for STREAM_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


ULIB_EXPORT
STREAM_MESSAGE::~STREAM_MESSAGE(
    )
/*++

Routine Description:

    Destructor for STREAM_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::Initialize(
    IN OUT  PSTREAM OutputStream,
    IN OUT  PSTREAM InputStream,
    IN OUT  PSTREAM ErrorStream
    )
/*++

Routine Description:

    This routine initializes the STREAM_MESSAGE object to the specified stream.

Arguments:

    OutputStream    - Supplies the output stream for the object.
    InputStream     - Supplies the input stream for the object.
    ErrorStream     - Supplies the error stream for the object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(OutputStream);
    DebugAssert(InputStream);

    _out_stream = OutputStream;
    _in_stream = InputStream;
    _err_stream = ErrorStream;
    _copy_input = SCREEN::Cast(OutputStream) ? FALSE : TRUE;


#ifdef FE_SB
    LANGID LangId;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

    return MESSAGE::Initialize();
}

ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::Set(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual
    )
/*++

Routine Description:

    This routine sets up the class to display the message with the
    'MsgId' resource identifier.

Arguments:

    MsgId       - Supplies the resource id of the message.
    MessageType - Supplies the type of the message.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SetMessageId(MsgId);
    _msgtype = MessageType;
    _msgvisual = MessageVisual;
    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style list format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (!SYSTEM::QueryResourceStringV(&_display_string,
                                      GetMessageId(),
                                      Format,
                                      VarPointer)) {
        return FALSE;
    }

    return DisplayString();
}


ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries either a "yes" or "no" from the input stream.

Arguments:

    Default - Supplies the default answer if neither "yes" nor "no" is the
                recognized input.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DSTRING     input;
    DSTRING     yes_message;
    DSTRING     no_message;
    WCHAR       w;

    Flush();

    if (!SYSTEM::QueryResourceString(&yes_message, MSG_YES, "")) {
        return Default;
    }

    if (!SYSTEM::QueryResourceString(&no_message, MSG_NO, "")) {
        return Default;
    }

    for (;;) {
        if (!ReadLine(&input)) {
            return Default;
        }

        if (!input.Strupr()) {
            return Default;
        }

        w = input.QueryChAt(0);

        if (w == no_message.QueryChAt(0) || w == '0') {
            return FALSE;
        }

        if (w == yes_message.QueryChAt(0) || w == '1') {
            return TRUE;
        }

        DisplayString();
    }
}


BOOLEAN
STREAM_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return ReadLine(String);
}


BOOLEAN
STREAM_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING string;

    return (BOOLEAN) (Flush() && ReadLine(&string));
}


MSGID
STREAM_MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Description:

    This routine queries input from the user in order to determine which
    message was entered.  It then returns the message id of the message
    entered.

Arguments:

    NumberOfSelections  - Supplies the number of message ids.
    ...                 - Supplies the message ids.

Return Value:

    The message id of the message entered, or the first message id.

--*/
{
    va_list             ap;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PFLAG_ARGUMENT      flag_arg;
    ARGUMENT_LEXEMIZER  arg;
    DSTRING             input_string;
    MSGID               first;
    PITERATOR           arg_it;
    ULONG               i;
    DSTRING             match_string;
    DSTRING             del;

    va_start(ap, NumberOfSelections);
    first = va_arg(ap, MSGID);
    va_end(ap);

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return first;
    }

    if (!arg.Initialize(&lex_array)) {
        return first;
    }

    arg.SetCaseSensitive(_case_sensitive);

    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        SYSTEM::QueryResourceString(&match_string, va_arg(ap, MSGID), "");

        if (!(flag_arg = NEW FLAG_ARGUMENT) ||
            !flag_arg->Initialize(&match_string) ||
            !arg_array.Put(flag_arg)) {
            va_end(ap);
            return first;
        }
    }
    va_end(ap);

    Flush();

    if (!ReadLine(&input_string)) {
        return first;
    }

    if (!arg.PrepareToParse(&input_string)) {
        return first;
    }

    if (!arg.DoParsing(&arg_array)) {
        return first;
    }

    arg_it = arg_array.QueryIterator();
    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        flag_arg = (PFLAG_ARGUMENT) arg_it->GetNext();
        if (flag_arg->QueryFlag()) {
            first = va_arg(ap, MSGID);
        } else {
            va_arg(ap, MSGID) ? 1 : 0;
        }
        DELETE(flag_arg);
    }
    va_end(ap);

    DELETE(arg_it);

    return first;
}


PMESSAGE
STREAM_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MSG object.

--*/
{
    PSTREAM_MESSAGE   p;

    if (!(p = NEW STREAM_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_out_stream, _in_stream)) {
        DELETE(p);
        return NULL;
    }

    return p;
}


VOID
STREAM_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns an STREAM_MESSAGE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


BOOLEAN
STREAM_MESSAGE::ReadLine(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine reads a line from the input stream.

Arguments:

    String  - Returns the read in string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING del;
    WCHAR   w;

    if (!del.Initialize("\r\n")) {
        return FALSE;
    }

    if (_in_stream->IsAtEnd()) {
        return FALSE;
    }

    String->Initialize( "" );

    if (!_in_stream->ReadString(String, &del)) {
        return FALSE;
    }

    // Line feed is the last character on the line.

    for (;;) {
        if (_in_stream->IsAtEnd()) {
            return TRUE;
        }

        if (!_in_stream->ReadChar(&w)) {
            return FALSE;
        }

        if (w == '\n') {
            break;
        }
    }

    if (_copy_input) {
        _out_stream->WriteString(String, 0, String->QueryChCount());
        _out_stream->WriteString(&del, 0, del.QueryChCount());
    }

    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::Flush(
    )
/*++

Routine Description:

    This routine flushes the input stream of all previously typed input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PKEYBOARD   key;

    if (key = KEYBOARD::Cast(_in_stream)) {
        return key->Flush();
    }

    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::DisplayString(
    )
/*++

Routine Description:

    This routine prints this objects current string to the
    appropriate output.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTREAM stream;

    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (_msgtype == ERROR_MESSAGE && _err_stream) {
        stream = _err_stream;
    } else {
        stream = _out_stream;
    }

    if (!stream->WriteString(&_display_string, 0, TO_END, 40)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ulib
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib    \
           $(SDK_LIB_PATH)\user32.lib      \
           $(SDK_LIB_PATH)\advapi32.lib

DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\rtmsg.rc        \
        ..\arg.cxx         \
        ..\array.cxx       \
        ..\arrayit.cxx     \
        ..\basesys.cxx     \
        ..\bitvect.cxx     \
        ..\bstring.cxx     \
        ..\bytestrm.cxx    \
        ..\bufstrm.cxx     \
        ..\chkmsg.cxx      \
        ..\clasdesc.cxx    \
        ..\cmem.cxx        \
        ..\comm.cxx        \
        ..\contain.cxx     \
        ..\dir.cxx         \
        ..\file.cxx        \
        ..\filestrm.cxx    \
        ..\filter.cxx      \
        ..\fsnode.cxx      \
        ..\hmem.cxx        \
        ..\iterator.cxx    \
        ..\keyboard.cxx    \
        ..\list.cxx        \
        ..\listit.cxx      \
        ..\machine.cxx     \
        ..\mbstr.cxx       \
        ..\mem.cxx         \
        ..\membmgr.cxx     \
        ..\membmgr2.cxx     \
        ..\message.cxx     \
        ..\newdel.cxx      \
        ..\object.cxx      \
        ..\path.cxx        \
        ..\pipe.cxx        \
        ..\pipestrm.cxx    \
        ..\program.cxx     \
        ..\prtstrm.cxx     \
        ..\screen.cxx      \
        ..\seqcnt.cxx      \
        ..\smsg.cxx        \
        ..\sortcnt.cxx     \
        ..\sortlist.cxx    \
        ..\sortlit.cxx     \
        ..\stream.cxx      \
        ..\stringar.cxx    \
        ..\system.cxx      \
        ..\timeinfo.cxx    \
        ..\ulib.cxx        \
        ..\wstring.cxx

i386_SOURCES=..\i386\dosttr.c

INCLUDES=..\.;..\..\inc;

PRECOMPILED_INCLUDE= ..\pch.cxx

C_DEFINES=-DUNICODE=1 -DSTRICT=1 -DNO_COMMDLGH -DNO_LZEXPANDH -DNO_MMSYSTEMH -DNO_NB30H

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console

NTTARGETFILE0=..\..\inc\rtmsg.h
DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\seqcnt.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	seqcnt.cxx

Abstract:

	This module contains the definition for the SEQUENTIAL_CONTAINER class.
	There exists no implementation, merely a constructor that acts as a link
	between derived classes as SEQUENTIAL_CONTAINERs base class CONTAINER.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "seqcnt.hxx"


DEFINE_CONSTRUCTOR( SEQUENTIAL_CONTAINER, CONTAINER );

SEQUENTIAL_CONTAINER::~SEQUENTIAL_CONTAINER(
    )
{
}

ULIB_EXPORT
BOOLEAN
SEQUENTIAL_CONTAINER::DeleteAllMembers(
    )
/*++

Routine Description:

    This routine not only removes all members from the container
    class, but also deletes all the objects themselves.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PITERATOR   iter;
    POBJECT     pobj;

    if (!(iter = QueryIterator())) {
        return FALSE;
    }

    iter->GetNext();
    while (iter->GetCurrent()) {
        pobj = Remove(iter);
        DELETE(pobj);
    }
    DELETE(iter);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\sortcnt.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sortcnt.cxx

Abstract:

	This module contains the definition for the SORTABLE_CONTAINER class.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "sortcnt.hxx"


DEFINE_CONSTRUCTOR( SORTABLE_CONTAINER, SEQUENTIAL_CONTAINER );

SORTABLE_CONTAINER::~SORTABLE_CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\screen.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    screen.cxx

Abstract:

    This module contains the definitions of the member functions
    of SCREEN class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR ( SCREEN, STREAM, ULIB_EXPORT );

DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( SCREEN, ULIB_EXPORT );


ULIB_EXPORT
SCREEN::~SCREEN (
    )

/*++

Routine Description:

    Destroy a SCREEN (closes the screen handle).

Arguments:

    None.

Return Value:

    None.

--*/

{
    CloseHandle( _ScreenHandle );
}



BOOLEAN
SCREEN::Initialize(
    IN BOOLEAN  CurrentActiveScreen,
    IN USHORT   NumberOfRows,
    IN USHORT   NumberOfColumns,
    IN USHORT   TextAttribute,
    IN BOOLEAN  ExpandAsciiControlSequence,
    IN BOOLEAN  WrapAtEndOfLine
    )

/*++

Routine Description:

    Initializes an object of type SCREEN.

Arguments:

    CurrentActiveScreen - Indicates if the client wants to use the screen
                          currently displayed (TRUE), or if a new screen
                          buffer is to be created (FALSE).

    NumberOfRows - Number of rows in the screen.

    NumberOfColumns - Number of columns in the screen.

    TextAttribute - Indicates the default text attribute.

    ExpandAsciiControlSequence - Indicates if expansion of ASCII control
                                 sequences is allowed.

    WrapAtEndOfLine - Indicates if wrap at the end of a line is allowed.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{


    if( CurrentActiveScreen ) {
            _ScreenHandle = CreateFile( (LPWSTR)L"CONOUT$",
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL );
    } else {
                _ScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
                                            0,
                                            NULL,
                                            CONSOLE_TEXTMODE_BUFFER,
                                            NULL );
    }


    if( _ScreenHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    if( !GetConsoleMode( _ScreenHandle, (LPDWORD)&_ScreenMode ) ) {
        return( FALSE );
    }
    if( ExpandAsciiControlSequence ) {
        _ScreenMode |= ENABLE_PROCESSED_OUTPUT;
        } else {
                _ScreenMode &= ~ENABLE_PROCESSED_OUTPUT;
        }
    if( WrapAtEndOfLine ) {
        _ScreenMode |= ENABLE_WRAP_AT_EOL_OUTPUT;
        } else {
                _ScreenMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;
        }
    if( !ChangeScreenSize( NumberOfRows, NumberOfColumns ) ) {
        return( FALSE );
    }
    if( !ChangeTextAttribute( TextAttribute ) ) {
        return( FALSE );
    }
    if( !SetConsoleMode( _ScreenHandle, _ScreenMode ) ) {
        return( FALSE );
    }
    return( STREAM::Initialize() );
}



ULIB_EXPORT
BOOLEAN
SCREEN::Initialize(
    )

/*++

Routine Description:

    Initializes an object of type SCREEN with default values.
    This object will access the screen currently active, and all
    values such as number of rows, columns, attributes, and mode
    will be the ones defined in the currently active screen.


Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

        _ScreenHandle = CreateFile( (LPWSTR)L"CONOUT$",
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );
    if( _ScreenHandle == (HANDLE)-1 ) {
        return( FALSE );
    }

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    if( !GetConsoleMode( _ScreenHandle, (LPDWORD)&_ScreenMode ) ) {
        return( FALSE );
    }
    _TextAttribute = ScreenBufferInfo.wAttributes;
    return( STREAM::Initialize() );
}




ULIB_EXPORT
BOOLEAN
SCREEN::ChangeScreenSize(
    IN  USHORT   NumberOfRows,
    IN  USHORT   NumberOfColumns,
    OUT PBOOLEAN IsFullScreen
    )

/*++

Routine Description:

    Changes the screen buffer size to the specified number of rows and
    columns. And sets the window size accordingly.

Arguments:

    NumberOfRows - Number of rows in the screen.

    NumberOfColumns - Number of columns in the screen.

    IsFullScreen    - TRUE if in full screen mode.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    SMALL_RECT                  ScreenRect;
    COORD                       ScreenSize;
    COORD                       LargestScreenSize;
    USHORT                      MaxRows;
    USHORT                      MaxCols;
    BOOLEAN                     WindowSet = FALSE;

    //
    //  Clear the screen
    //
    MoveCursorTo(0, 0);
    EraseScreen();

    if ( IsFullScreen ) {
        *IsFullScreen = FALSE;
    }

    //
    //  We obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {

        //
        //  Set the Window Size. The new size is the minimum of the
        //  buffer size or the screen size.
        //
        LargestScreenSize = GetLargestConsoleWindowSize( _ScreenHandle );

        if ( (LargestScreenSize.X == 0) && (LargestScreenSize.Y == 0) ) {

            if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                *IsFullScreen = TRUE;
            }
            return FALSE;
        }

        //
        //  If the desired window size is smaller than the current window
        //  size, we have to resize the current window first. (The buffer
        //  size cannot be smaller than the window size)
        //
        if ( ( NumberOfRows < (USHORT)
                              (ScreenBufferInfo.srWindow.Bottom -
                               ScreenBufferInfo.srWindow.Top + 1) ) ||
             ( NumberOfColumns < (USHORT)
                                 (ScreenBufferInfo.srWindow.Right -
                                  ScreenBufferInfo.srWindow.Left + 1) ) ) {


            //
            //  Set the window to a size that will fit in the current
            //  screen buffer and that is no bigger than the size to
            //  which we want to grow the screen buffer or the largest window
            //  size.
            //
            MaxRows = (USHORT)min( (int)NumberOfRows, (int)(ScreenBufferInfo.dwSize.Y) );
            MaxRows = (USHORT)min( (int)MaxRows, (int)LargestScreenSize.Y );
            MaxCols = (USHORT)min( (int)NumberOfColumns, (int)(ScreenBufferInfo.dwSize.X) );
            MaxCols = (USHORT)min( (int)MaxCols, (int)LargestScreenSize.X );

            ScreenRect.Top      = 0;
            ScreenRect.Left     = 0;
            ScreenRect.Right    = MaxCols - (SHORT)1;
            ScreenRect.Bottom   = MaxRows - (SHORT)1;

            WindowSet = (BOOLEAN)SetConsoleWindowInfo( _ScreenHandle, TRUE, &ScreenRect );

            if ( !WindowSet ) {

                DebugPrintTrace(( "MODE: SetConsoleWindowInfo failed. Error %d\n", GetLastError() ));
                if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                    *IsFullScreen = TRUE;
                }
                return FALSE;
            }
        }

        //
        //  Set the screen buffer size to the desired size.
        //
        ScreenSize.X = NumberOfColumns;
        ScreenSize.Y = NumberOfRows;

        if ( !SetConsoleScreenBufferSize( _ScreenHandle, ScreenSize ) ) {

            DebugPrintTrace(( "MODE: SetConsoleScreenBufferSize failed (Y:%d X:%d ) Error: %d\n",
                        ScreenSize.Y, ScreenSize.X, GetLastError() ));

            if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                *IsFullScreen = TRUE;
            }

            //
            //  Return the window to its original size. We ignore the return
            //  code because there is nothing we can do about it.
            //
            if ( !SetConsoleWindowInfo( _ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) )) {
                DebugPrintTrace(( "MODE: SetConsoleWindowInfo (2) failed. Error %d\n", GetLastError() ));

            }

            return FALSE;
        }

        MaxRows = (USHORT)min( (int)NumberOfRows, (int)(LargestScreenSize.Y) );
        MaxCols = (USHORT)min( (int)NumberOfColumns, (int)(LargestScreenSize.X) );

        ScreenRect.Top      = 0;
        ScreenRect.Left     = 0;
        ScreenRect.Right    = MaxCols - (SHORT)1;
        ScreenRect.Bottom   = MaxRows - (SHORT)1;

        WindowSet = (BOOLEAN)SetConsoleWindowInfo( _ScreenHandle, TRUE, &ScreenRect );

        if ( !WindowSet ) {
            //
            //  We could not resize the window. We will leave the
            //  resized screen buffer.
            //
            DebugPrintTrace(( "MODE: SetConsoleWindowInfo (3) failed. Error %d\n", GetLastError() ));
            return FALSE;
        }

        return TRUE;

    } else {

        DebugPrintTrace(( "ULIB: Cannot get console screen buffer info, Error = %X\n", GetLastError() ));
    }

    return FALSE;
}




BOOLEAN
SCREEN::ChangeTextAttribute(
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Set the attribute to be used when text is written using WriteFile()
    (ie, when the stream API is used ).

Arguments:

    Attribute - Attribute to be used

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/

{
    _TextAttribute = Attribute;
    return( SetConsoleTextAttribute( _ScreenHandle, Attribute ) != FALSE );
}



BOOLEAN
SCREEN::EnableAsciiControlSequence(
    )

/*++

Routine Description:

    Set the screen in the line mode (allows expansion of control ASCII
    sequences);

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( _ScreenMode & ENABLE_PROCESSED_OUTPUT ) {
        return( TRUE );
    }
    _ScreenMode |= ENABLE_PROCESSED_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::DisableAsciiControlSequence(
    )

/*++

Routine Description:

    Set the screen in the character mode (does not expansion of control
    ASCII sequences);

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( !( _ScreenMode & ENABLE_PROCESSED_OUTPUT ) ) {
        return( TRUE );
    }
    _ScreenMode &= ~(ENABLE_PROCESSED_OUTPUT);
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::EnableWrapMode(
    )

/*++

Routine Description:

    Sets the screen in the wrap mode (characters are written in the next
    line when cursor reaches the end of a line).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( _ScreenMode & ENABLE_WRAP_AT_EOL_OUTPUT ) {
        return( TRUE );
    }
    _ScreenMode |= ENABLE_WRAP_AT_EOL_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::DisableWrapMode(
    )

/*++

Routine Description:

    Disables the wrap mode (cursor does not move to the beginning of
    the next line when it reaches the eand of a line).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( !( _ScreenMode & ENABLE_WRAP_AT_EOL_OUTPUT ) ) {
        return( TRUE );
    }
    _ScreenMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::IsAtEnd(
    ) CONST

/*++

Routine Description:

    Determines if the cursor is at the end of the screen.

Arguments:

    None.


Return Value:

    BOOLEAN - Indicates if the cursor is at the end of the screen.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    return( ( ScreenBufferInfo.dwCursorPosition.X ==
              ScreenBufferInfo.dwSize.X ) &&
            ( ScreenBufferInfo.dwCursorPosition.Y ==
              ScreenBufferInfo.dwSize.Y ) );
}



BOOLEAN
SCREEN::SetScreenActive(
    )

/*++

Routine Description:

    Makes the screen buffer defined in this class active.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    return( SetConsoleActiveScreenBuffer( _ScreenHandle ) != FALSE );
}




ULIB_EXPORT
BOOLEAN
SCREEN::MoveCursorTo(
    IN USHORT   Row,
    IN USHORT   Column
    )

/*++

Routine Description:

    Moves the cursor to a particular position in the screen

Arguments:

    USHORT - Row where the cursor is to be moved to.

    USHORT - Column where the cursor is to be moved to.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   CursorPosition;

    CursorPosition.Y = Row;
    CursorPosition.X = Column;
    return( SetConsoleCursorPosition( _ScreenHandle, CursorPosition ) != FALSE );
}



BOOLEAN
SCREEN::MoveCursorDown(
    IN USHORT   Rows
    )

/*++

Routine Description:

    Moves the cursor down by a number of lines, keeping it in the same
    column.

Arguments:

    Rows - Number of lines to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y + Rows,
                          ScreenBufferInfo.dwCursorPosition.X ) );
}



BOOLEAN
SCREEN::MoveCursorUp(
    IN USHORT   Rows
    )

/*++

Routine Description:

    Moves the cursor up by a number of lines, keeping it in the same
    column.

Arguments:

    Rows - Number of lines to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y - Rows,
                          ScreenBufferInfo.dwCursorPosition.X ) );
}



BOOLEAN
SCREEN::MoveCursorRight(
    IN USHORT   Columns
    )

/*++

Routine Description:

    Moves the cursor right by a number of columns, keeping it in the same
    line.

Arguments:

    Columns - Number of columns to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y,
                          ScreenBufferInfo.dwCursorPosition.X + Columns ) );
}



BOOLEAN
SCREEN::MoveCursorLeft(
    IN USHORT   Columns
    )

/*++

Routine Description:

    Moves the cursor left by a number of columns, keeping it in the same
    line.

Arguments:

    Columns - Number of columns to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y,
                          ScreenBufferInfo.dwCursorPosition.X - Columns ) );
}




ULIB_EXPORT
DWORD
SCREEN::QueryCodePage(
    )

/*++

Routine Description:

    Obtains the current console code page.

Arguments:

    None


Return Value:

    The current console code page.


--*/


{
    return GetConsoleCP( );
}


DWORD
SCREEN::QueryOutputCodePage(
    )

/*++

Routine Description:

    Obtains the current console code page.

Arguments:

    None


Return Value:

    The current console code page.


--*/


{
    return GetConsoleOutputCP( );
}


BOOLEAN
SCREEN::QueryCursorPosition(
    OUT PUSHORT Row,
    OUT PUSHORT Column
    )

/*++

Routine Description:

    Returns to the caller the current position of the cursor.

Arguments:

    Row - Address of the variable that will contain the row.

    Column - Address of the variable that will contain the column.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }

    *Row = ScreenBufferInfo.dwCursorPosition.Y;
    *Column = ScreenBufferInfo.dwCursorPosition.X;
    return( TRUE );
}



ULIB_EXPORT
BOOLEAN
SCREEN::SetCodePage(
    IN DWORD    CodePage
    )

/*++

Routine Description:

    Sets the console codepage.

Arguments:


    CodePage    -   New codepage


Return Value:

    BOOLEAN - TRUE if codepage set, FALSE otherwise (most probably the
              codepage is invalid).


--*/


{
    return SetConsoleCP( CodePage ) != FALSE;
}


ULIB_EXPORT
BOOLEAN
SCREEN::SetOutputCodePage(
    IN DWORD    CodePage
    )

/*++

Routine Description:

    Sets the console output codepage.

Arguments:


    CodePage    -   New codepage


Return Value:

    BOOLEAN - TRUE if codepage set, FALSE otherwise (most probably the
              codepage is invalid).


--*/


{
    return SetConsoleOutputCP( CodePage ) != FALSE;
}


BOOLEAN
SCREEN::SetCursorSize(
    IN ULONG    Size
    )

/*++

Routine Description:

    Sets the size of the cursor.

Arguments:

    Size - A number in the range 1-100 that indicates the percentage of
            character cell to be filled.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.dwSize = Size;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::SetCursorOff(
    )

/*++

Routine Description:

    Turns off the cursor.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.bVisible = FALSE;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::SetCursorOn(
    )

/*++

Routine Description:

    Turns on the cursor.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.bVisible = TRUE;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::FillRegionCharacter(
    IN USHORT   StartRow,
    IN USHORT   StartColumn,
    IN USHORT   EndRow,
    IN USHORT   EndColumn,
    IN CHAR     Character
    )

/*++

Routine Description:

    Fills a region in the screen with a particular character. Attributes
    in this region are not changed.

Arguments:

    StartRow - Row where the region starts.

    StartColumn - Column where the region starts.

    EndRow - Row where the region ends.

    EndColumn - Column where the region ends.

    Character - Character to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    ULONG   Columns;
    ULONG   NumberOfCharsWritten;


    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    Columns = ScreenBufferInfo.dwSize.X;

    if( EndRow == StartRow ) {
        Length = EndColumn - StartColumn + 1;
    } else {
        Length = Columns - StartColumn +
                 Columns*( EndRow - StartRow - 1 ) +
                 EndColumn + 1;
    }
    Origin.Y = StartRow;
    Origin.X = StartColumn;
    if( !FillConsoleOutputCharacter( _ScreenHandle,
                                     Character,
                                     Length,
                                     Origin,
                                     &NumberOfCharsWritten ) ||
        NumberOfCharsWritten != Length) {
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRectangularRegionCharacter(
    IN USHORT   TopLeftRow,
    IN USHORT   TopLeftColumn,
    IN USHORT   BottomRightRow,
    IN USHORT   BottomRightColumn,
    IN CHAR     Character
    )

/*++

Routine Description:

    Fills a rectangular region in the screen with a particular character.
    Attributes in this region are not changed.

Arguments:

    TopLeftRow - Row where the region starts.

    TopLeftColumn - Column where the region starts.

    BottomRightRow - Row where the region ends.

    BottomeRightColumn - Column where the region ends.

    Character - Character to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    ULONG   NumberOfRows;
    ULONG   NumberOfCharsWritten;

    NumberOfRows = BottomRightRow - TopLeftRow + 1;
    Length = BottomRightColumn - TopLeftColumn + 1;
    Origin.X = TopLeftColumn;
    Origin.Y = TopLeftRow;
    while( NumberOfRows-- ) {
        if( !FillConsoleOutputCharacter( _ScreenHandle,
                                         Character,
                                         Length,
                                         Origin,
                                         &NumberOfCharsWritten ) ||
            NumberOfCharsWritten != Length ) {
            return( FALSE );
        }
        Origin.Y++;
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRegionAttribute(
    IN USHORT   StartRow,
    IN USHORT   StartColumn,
    IN USHORT   EndRow,
    IN USHORT   EndColumn,
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Fills a region in the screen with a particular attribute. Characters
    in this region are not changed.

Arguments:

    StartRow - Row where the region starts.

    StartColumn - Column where the region starts.

    EndRow - Row where the region ends.

    EndColumn - Column where the region ends.

    Attribute - Attribute to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    ULONG   Columns;
    ULONG   NumberOfAttrsWritten;


    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    Columns = ScreenBufferInfo.dwSize.X;

    if( EndRow == StartRow ) {
        Length = EndColumn - StartColumn + 1;
    } else {
        Length = Columns - StartColumn +
                 Columns*( EndRow - StartRow - 1 ) +
                 EndColumn + 1;
    }
    Origin.Y = StartRow;
    Origin.X = StartColumn;
    if( !FillConsoleOutputAttribute( _ScreenHandle,
                                     Attribute,
                                     Length,
                                     Origin,
                                     &NumberOfAttrsWritten ) ||
        NumberOfAttrsWritten != Length ) {
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRectangularRegionAttribute(
    IN USHORT   TopLeftRow,
    IN USHORT   TopLeftColumn,
    IN USHORT   BottomRightRow,
    IN USHORT   BottomRightColumn,
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Fills a rectangular region in the screen with a particular attribute.
    Characters in this region are not changed.

Arguments:

    TopLeftRow - Row where the region starts.

    TopLeftColumn - Column where the region starts.

    BottomRighhtRow - Row where the region ends.

    BottomRightColumn - Column where the region ends.

    Attribute - Attribute used to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    ULONG   NumberOfRows;
    ULONG   NumberOfAttrsWritten;

    NumberOfRows = BottomRightRow - TopLeftRow + 1;
    Length = BottomRightColumn - TopLeftColumn + 1;
    Origin.X = TopLeftColumn;
    Origin.Y = TopLeftRow;
    while( NumberOfRows-- ) {
        if( !FillConsoleOutputAttribute( _ScreenHandle,
                                         Attribute,
                                         Length,
                                         Origin,
                                         &NumberOfAttrsWritten ) ||
            NumberOfAttrsWritten != Length ) {
            return( FALSE );
        }
        Origin.Y++;
    }
    return( TRUE );
}



BOOLEAN
SCREEN::EraseLine(
    IN USHORT   LineNumber
    )

/*++

Routine Description:

    Erases a line in the screen.

Arguments:

    LineNumber - Line number.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( FillRegionCharacter( LineNumber,
                                 0,
                                 LineNumber,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



BOOLEAN
SCREEN::EraseToEndOfLine(
    )

/*++

Routine Description:

    Erases the current line from the cursor position to the end of line.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( FillRegionCharacter( ScreenBufferInfo.dwCursorPosition.Y,
                                 ScreenBufferInfo.dwCursorPosition.X,
                                 ScreenBufferInfo.dwCursorPosition.Y,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



ULIB_EXPORT
BOOLEAN
SCREEN::EraseScreen(
    )

/*++

Routine Description:

    Erases all characters in the screen. Attributes are not changed.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    return( FillRegionCharacter( 0,
                                 0,
                                 ScreenBufferInfo.dwSize.Y - 1,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



ULIB_EXPORT
VOID
SCREEN::QueryScreenSize(
    OUT PUSHORT NumberOfRows,
    OUT PUSHORT NumberOfColumns,
    OUT PUSHORT WindowRows,
    OUT PUSHORT WindowColumns
    ) CONST

/*++

Routine Description:

    Returns to the caller the screen size, and optionally the window
    size.

Arguments:

    NumberOfRows    - Points to the variable that will contain the
                      number of rows

    NumberOfColumns - Points to the variable that will contain the
                      number of columns

    WindowRows      - Points to the variable that will contain the number
                      of rows in the window

    WindowColumns   - Points to the variable that will contain the number
                      of columns in the window

Return Value:

    None.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );

    //
    //  Get screen buffer size
    //
    *NumberOfRows = ScreenBufferInfo.dwSize.Y;
    *NumberOfColumns = ScreenBufferInfo.dwSize.X;

    //
    //  Get window size
    //
    if ( WindowRows && WindowColumns ) {
        *WindowColumns  = ScreenBufferInfo.srWindow.Right - ScreenBufferInfo.srWindow.Left + 1;
        *WindowRows     = ScreenBufferInfo.srWindow.Bottom - ScreenBufferInfo.srWindow.Top + 1;
    }
}




BOOLEAN
SCREEN::ScrollScreen(
    IN  USHORT              Amount,
    IN  SCROLL_DIRECTION    Direction
    )

/*++

Routine Description:

    Scrolls the screen.

Arguments:

    Amount - Number of rows or columns to scroll.

    Direction - Indicates if up, down, left or right.

Return Value:

    BOOLEAN - Returns TRUE if the screen was scrolled. FALSE otherwise.


--*/


{
    UNREFERENCED_PARAMETER( Amount );
    UNREFERENCED_PARAMETER( Direction );

/*
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    CONSOLE_SCROLL_INFO         ConsoleScrollInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    switch( Direction ) {

    case SCROLL_UP:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = Amount;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;


    case SCROLL_DOWN:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - Amount - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = Amount;
        break;


    case SCROLL_LEFT:

        ConsoleScrollInfo.ScrollRectangle.Left = Amount;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;


    case SCROLL_RIGHT:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - Amount - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = Amount;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;

    }

    ConsoleScrollInfo.Fill.Char.AsciiChar = 0x20;
    ConsoleScrollInfo.Fill.Attributes = ScreenBufferInfo.wAttributes;
    return( ScrollConsoleScreenBuffer( _ScreenHandle,
                                       &ConsoleScrollInfo ) );
*/
//
//  jaimes - 07/08/91
//  ScrollConsoleScreenBuffer has chaged
//
return TRUE;
}



BOOLEAN
SCREEN::Read(
            OUT PBYTE   Buffer,
            IN  ULONG   BytesToRead,
            OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Reads bytes from the screen stream.

Arguments:

    Buffer - Points that will receive the bytes read.

    BytesToRead - Number of bytes to read (buffer size)

    BytesRead - Points to the variable that will contain the total
                number of bytes read.

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(Buffer);
    (void)(BytesToRead);
    (void)(BytesRead);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadChar(
    OUT PWCHAR          Char,
        IN  BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a character from the screen stream.

Arguments:

    Char    -   Supplies poinbter to wide character

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(Char);
    (void)(Unicode);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:


Arguments:


Return Value:



--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:


Arguments:


Return Value:



--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadString(
    OUT PWSTRING        String,
    IN  PWSTRING        Delimiter,
        IN  BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a STRING from the screen stream.

Arguments:

    String - Pointer to a WSTRING object that will contain the string read.

    Delimiter - Pointer to a WSTRING object that contains the delimiters
                of a string

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(Delimiter);
    (void)(Unicode);

    return( FALSE );
}



STREAMACCESS
SCREEN::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the access to the screen stream.

Arguments:

    None.

Return Value:

    Returns always WRITE_ACCESS.


--*/


{
    (void)(this);
    return( WRITE_ACCESS );
}



HANDLE
SCREEN::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the handle to the screen.

Arguments:

    None.

Return Value:

    Returns a handle.


--*/


{
    return( _ScreenHandle );
}


#if 0
// TMPTMP just for debug.

#include <stdio.h>
#endif




BOOLEAN
SCREEN::WriteString(
    IN PCWSTRING    String,
    IN CHNUM        Position,
    IN CHNUM        Length,
    IN CHNUM        Granularity
    )

/*++

Routine Description:

    Writes a string to the screen.

Arguments:

    String      - Pointer to a STRING object.
    Position    - Starting character within the string
    Length      - Number of characters to write
    Granularity - The maximum number of bytes to write at one time.
                    A value of 0 indicates to write it all at once.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   i, n, written, to_write;
    PCWSTR  p;
    BOOLEAN r;
    HANDLE  h;

    DebugAssert(Position <= String->QueryChCount());

    n = min(String->QueryChCount() - Position, Length);
    p = String->GetWSTR() + Position;
    h = QueryHandle();

    if (!Granularity) {
        Granularity = n;
    }

    r = TRUE;
    for (i = 0; r && i < n; i += Granularity) {

        to_write = min(Granularity, n - i);

        r = WriteConsole(h, p + i, to_write,
                         &written, NULL) &&
            to_write == written;
    }

    return r;
}


BOOLEAN
SCREEN::WriteChar(
    IN  WCHAR   Char
    )
/*++

Routine Description:

    This routine writes a character to the output.  This routine
    uses WriteConsoleW to avoid having to make the translation
    from wide to narrow characters.

Arguments:

    Char    - Supplies the character to write.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    ULONG   written;

    if (!WriteConsole(QueryHandle(), &Char, 1, &written, NULL) ||
        written != 1) {

        return FALSE;
    }

    return TRUE;
}

#ifdef FE_SB

BOOLEAN
SCREEN::EraseScreenAndResetAttribute(
    )

/*++

Routine Description:

    Erases all characters in the screen. Attributes are also reset.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );

    return (
        FillRegionCharacter(
                0,
                0,
                ScreenBufferInfo.dwSize.Y - 1,
                ScreenBufferInfo.dwSize.X - 1,
                0x20
                )
        &&
        FillRegionAttribute(
                0,
                0,
                ScreenBufferInfo.dwSize.Y - 1,
                ScreenBufferInfo.dwSize.X - 1,
                ScreenBufferInfo.wAttributes
                )
        );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\sortlist.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sortlist.cxx

Abstract:

	This module contains the definition for the SORTED_LIST class.
    SORTED_LIST is a concrete implementation of a SORTABLE_CONTAINER, where
    all the elements are maintained in sorted order.

Author:

    Ramon J. San Andres (ramonsa) 29-Oct-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SORTED_LIST, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST );

VOID
SORTED_LIST::Construct (
	)

/*++

Routine Description:

	Constructor for SORTED_LIST

Arguments:

	None.

Return Value:

	None.

--*/

{
}





ULIB_EXPORT
SORTED_LIST::~SORTED_LIST (
	)

/*++

Routine Description:

    Destructor for SORTED_LIST

Arguments:

	None.

Return Value:

	None.

--*/

{
}



ULIB_EXPORT
BOOLEAN
SORTED_LIST::Initialize (
    IN BOOLEAN  Ascending
	)

/*++

Routine Description:

    Initializes a SORTED_LIST object.

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

	BOOLEAN - TRUE if the SORTED_LIST is successfully initialized.

--*/

{
    _Ascending = Ascending;

#if DBG==1
    _IteratorCount      = 0;
#endif

    return _Array.Initialize();
}




ULIB_EXPORT
BOOLEAN
SORTED_LIST::DeleteAllMembers (
	)

/*++

Routine Description:

    Deletes all the members of the sorted list

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    return _Array.DeleteAllMembers();
}





ULIB_EXPORT
BOOLEAN
SORTED_LIST::Put (
	IN OUT  POBJECT Member
	)

/*++

Routine Description:

	Puts an OBJECT in the sorted list, maintaining the list sorted

Arguments:

	Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    if ( _Array.QueryMemberCount() > 0 ) {
        return _Array.Insert( Member, Search( Member, 0, _Array.QueryMemberCount()-1 ) );
    } else {
        return _Array.Insert( Member, 0 );
    }
}




ULIB_EXPORT
PITERATOR
SORTED_LIST::QueryIterator (
	) CONST

/*++

Routine Description:

    Creates an iterator object for this sorted-list.

Arguments:

	None.

Return Value:

	PITERATOR - Pointer to an ITERATOR object.

--*/

{



    return (PITERATOR)_Array.QueryIterator();
}



ULIB_EXPORT
ULONG
SORTED_LIST::QueryMemberCount (
	) CONST

/*++

Routine Description:

    Obtains the number of elements in the list

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the list


--*/

{
    return _Array.QueryMemberCount();
}


POBJECT
SORTED_LIST::Remove (
	IN OUT  PITERATOR   Position
	)

/*++

Routine Description:

    Removes a member from the list

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    return _Array.Remove( Position );
}




BOOLEAN
SORTED_LIST::Sort (
    IN  BOOLEAN Ascending
	)

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
    if ( ( Ascending == _Ascending ) ||
          _Array.Sort( Ascending ) ) {

        _Ascending = Ascending;
        return TRUE;

    } else {

        return FALSE;
    }
}




ULONG
SORTED_LIST::Search(
    IN  PCOBJECT    Key,
    IN  ULONG       FirstIndex,
    IN  ULONG       LastIndex
    )

/*++

Routine Description:

    Searches an element that matches the supplied key.
    If no such element is found, this method returns
    the element one past the largest element less
    than the given element.

Arguments:

    Key         -   Supplies the key
    FirstIndex  -   Supplies lowerbound for the search
    LastIndex   -   Supplies upperbound for the search

Return Value:

    ULONG   -   Index of the element that matched the key, or
                LastIndex+1 if no match

--*/

{
    LONG    First, Middle, Last;
    LONG    Match;

    DebugPtrAssert( Key );
    DebugPtrAssert( FirstIndex < _Array.QueryMemberCount() );
    DebugPtrAssert( (LastIndex == INVALID_INDEX)  ||
                  (LastIndex < _Array.QueryMemberCount()) );
    DebugPtrAssert( FirstIndex <= LastIndex );

    if (LastIndex == INVALID_INDEX) {
        return 0;
    }

    First = FirstIndex;
    Last = LastIndex;
    while (First <= Last) {
        Middle = (First + Last)/2;
        Match = _Array.CompareAscDesc((POBJECT) Key,
                                      _Array.GetAt(Middle),
                                      _Ascending);

        if (!Match) {
            break;
        }

        if (Match < 0) {
            Last = Middle - 1;
        } else {
            First = ++Middle;
        }
    }

    return Middle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\sortlit.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sortlit.cxx

Abstract:

	This file contains the definitions for the SORTED_LIST_ITERATOR class.
	SORTED_LIST_ITERATOR is a concrete implementation of the abstract ITERATOR
	class.

Author:

    Ramon J. San Andres ( ramonsa) 29-Oct-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST_ITERATOR );

DEFINE_CONSTRUCTOR( SORTED_LIST_ITERATOR, ITERATOR );


VOID
SORTED_LIST_ITERATOR::Construct (
	)

/*++

Routine Description:

	Construct a SORTED_LIST_ITERATOR

Arguments:

	None.

Return Value:

	None.

--*/

{
	_List = NULL;
}



SORTED_LIST_ITERATOR::~SORTED_LIST_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the SORTED_LIST_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
#endif
}


POBJECT
SORTED_LIST_ITERATOR::FindNext(
    IN  PCOBJECT    Key
    )
/*++

Routine Description:

    Finds the next object in the list that matches the given key

Arguments:

    Key -   Supplies the key

Return Value:

    POBJECT -   Pointer to next member of the list that matches the key

--*/

{

    ULONG   Index;

    //
    //  Wrap if necessary
    //
    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = 0;
    }

    //
    //  If we are not at the end of the list, look for the next object
    //  that matches the key.
    //
    if ( _CurrentIndex < _List->QueryMemberCount()-1 ) {

        Index = _List->Search( Key, _CurrentIndex+1, _List->QueryMemberCount()-1 );

        //
        //  If an object was found, set our currency and return the object
        //
        if ( Index < _List->QueryMemberCount() &&
             !Key->Compare(_List->_Array.GetAt( Index )))  {

            _CurrentIndex = Index;
            return _List->_Array.GetAt( Index );
        }
    }

    //
    //  No match, return NULL
    //
    _CurrentIndex = INVALID_INDEX;
    return NULL;
}


POBJECT
SORTED_LIST_ITERATOR::GetCurrent(
	)
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _List->_Array.GetAt( _CurrentIndex );
    }
}




POBJECT
SORTED_LIST_ITERATOR::GetNext(
	)
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _List->_Array.QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}


POBJECT
SORTED_LIST_ITERATOR::GetPrevious(
	)
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //
    _CurrentIndex--;

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _List->_Array.QueryMemberCount() - 1;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}



VOID
SORTED_LIST_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}




BOOLEAN
SORTED_LIST_ITERATOR::Initialize (
	IN PSORTED_LIST List
	)

/*++

Routine Description:

	Associate a SORTED_LIST with this SORTED_LIST_ITERATOR and
    reset the current index

Arguments:

    List   -   Supplies pointer to the sorted list object

Return Value:

	BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
	DebugPtrAssert( List );

#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
    List->_IteratorCount++;
#endif
    _List           = List;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\system.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    system.cxx

Abstract:

    This contains the implementation for all methods communicating
    with the operating system.

Author:

    David J. Gilman (davegi) 13-Jan-1991

Environment:

    ULIB, user mode

Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "system.hxx"

extern "C" {
    #include <stdio.h>
    #include <string.h>
    #include "winbasep.h"
}

#include "dir.hxx"
#include "file.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "timeinfo.hxx"


ULIB_EXPORT
BOOLEAN
SYSTEM::IsCorrectVersion (
    )

/*++

Routine Description:

    Verify that the version of the operating system is correct.

Arguments:

    None

Return Value:

    BOOLEAN - TRUE is the version is correct
            - FALSE if wrong version

--*/

{
    // It makes more sense to just allow this binary to run.
    // Future version of Windows NT will have to be backward
    // compatible.
    return TRUE;
    // return (GetVersion()&0x0000FFFF) == 0x0A03; // Windows 3.10
}


BOOLEAN
ClearDirectoryJunction(
    IN  PCWSTR  PathString
    )

{
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    PWSTR                   pathString;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          reparseName;
    DWORD                   l;
    DWORD                   last_err;
    DWORD                   flags;
    BOOLEAN                 done;

    h = CreateFile(PathString, GENERIC_READ,
                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                   FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                   INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = (PREPARSE_DATA_BUFFER)
              LocalAlloc(0, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL) ||
        (reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT)) {
        LocalFree(reparse);
        CloseHandle(h);
        return TRUE;
    }

    flags = GetFileAttributes(PathString);
    if (flags != -1) {
        if (flags & FILE_ATTRIBUTE_READONLY) {
            flags &= ~FILE_ATTRIBUTE_READONLY;
            if (!SetFileAttributes(PathString, flags)) {
                last_err = GetLastError();
                LocalFree(reparse);
                CloseHandle(h);
                SetLastError(last_err);
                return FALSE;
            }
            flags = FILE_ATTRIBUTE_READONLY;
        } else
            flags = 0;
    }

    // at this point, flags can be -1, 0, or FILE_ATTRIBUTE_READONLY

    done = FALSE;
    last_err = ERROR_SUCCESS;

    //
    // previous handle was read only, we need a new read/write handle 
    //
    CloseHandle(h);
    h = CreateFile(PathString, GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                   FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        last_err = GetLastError();
        done = TRUE;
    }

    if (!done) {
        l = wcslen(PathString);
        if (l && PathString[l - 1] == '\\') {
            if (DeleteVolumeMountPoint(PathString)) {
                done = TRUE;
            }
        } else {
            pathString = (PWSTR) LocalAlloc(0, l*sizeof(WCHAR) + 2*sizeof(WCHAR));
            if (!pathString) {
                last_err = ERROR_NOT_ENOUGH_MEMORY;
                done = TRUE;
            } else {
                if (l) {
                    CopyMemory(pathString, PathString, l*sizeof(WCHAR));
                }
                pathString[l] = '\\';
                pathString[l + 1] = 0;
                if (DeleteVolumeMountPoint(pathString)) {
                    done = TRUE;
                }
                LocalFree(pathString);
            }
        }

        if (!done) {
            reparse->ReparseDataLength = 0;

            if (!DeviceIoControl(h, FSCTL_DELETE_REPARSE_POINT, reparse,
                                 REPARSE_DATA_BUFFER_HEADER_SIZE, NULL, 0, &bytes,
                                 NULL)) {
                last_err = GetLastError();
            }
        }
    }

    if (reparse != NULL)
        LocalFree(reparse);
    if (h != INVALID_HANDLE_VALUE)
        CloseHandle(h);

    if ((last_err == ERROR_SUCCESS) && (flags == FILE_ATTRIBUTE_READONLY)) {
        flags = GetFileAttributes(PathString);
        if (flags != -1) {
            flags |= FILE_ATTRIBUTE_READONLY;
            if (!SetFileAttributes(PathString, flags)) {
                last_err = GetLastError();
            }
        }
    }

    SetLastError(last_err);
    return (last_err == ERROR_SUCCESS);
}

ULIB_EXPORT
PFSN_DIRECTORY
SYSTEM::MakeDirectory (
    IN     PCPATH             Path,
    IN     PCPATH             TemplatePath,
       OUT PCOPY_ERROR        CopyError,
    IN     LPPROGRESS_ROUTINE Callback,
    IN     PVOID              Data,
    IN     PBOOL              Cancel,
    IN     ULONG              CopyFlags
    )

/*++

Routine Description:

    Creates a Directory and returns the corresponging FSN_Directory object.

Arguments:

    Path            - Supplies the Path of the directory to be created.
    TemplatePath    - Supplies the template directory from which to
                        copy alternate data streams.
    CopyError       - Pointer to location where the copy error code is to be returned
    Callback        - Pointer to callback routine passed to CopyFileEx.
    Data            - Pointer to opaque data passed to CopyFileEx.
    Cancel          - Pointer to cancel flag passed to CopyFileEx.
    CopyFlags       - Supplies the following flags:
                        FSN_FILE_COPY_RESTARTABLE
                            - copy is restartable.
                        FSN_FILE_COPY_COPY_OWNER
                            - copy the ownership of the file.
                        FSN_FILE_COPY_COPY_ACL
                            - copy the security information of the file

Return Value:

    PFSN_DIRECTORY  -   A pointer to the object of the directory created.

--*/

{
    PCWSTR                  PathString, TemplateString;
    BOOL                    r;
    PFSN_DIRECTORY          pdir;

    DebugAssert(Path);

    *CopyError = COPY_ERROR_SUCCESS;

    PathString = Path->GetPathString()->GetWSTR();
    DebugAssert(PathString);
    if (TemplatePath) {
        TemplateString = TemplatePath->GetPathString()->GetWSTR();
    } else {
        TemplateString = NULL;
    }

    if (TemplateString) {

        ULONG   flags;

        flags = PRIVCOPY_FILE_DIRECTORY;
        flags |= (FSN_FILE_COPY_RESTARTABLE & CopyFlags) ? COPY_FILE_RESTARTABLE : 0;
        flags |= (FSN_FILE_COPY_COPY_OWNER & CopyFlags) ? PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_METADATA : 0;
        flags |= (FSN_FILE_COPY_COPY_ACL & CopyFlags)   ? PRIVCOPY_FILE_SACL : 0;
        flags |= (FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION & CopyFlags) ? COPY_FILE_ALLOW_DECRYPTED_DESTINATION : 0;

#if !defined(RUN_ON_NT4)
        r = PrivCopyFileExW( TemplateString,
                             PathString,
                             Callback,
                             Data,
                             Cancel,
                             flags );
        if (r) {
            r = ClearDirectoryJunction(PathString);
        }
#else
        r = FALSE;
        SetLastError(ERROR_NOT_SUPPORTED);
#endif

    } else {
        r = CreateDirectory((PWSTR) PathString, NULL);
    }

    if (!r) {
        *CopyError = (COPY_ERROR)GetLastError();
        return NULL;
    }

    pdir = QueryDirectory( Path );

    if (pdir == NULL) {
        DebugPrintTrace(("ULIB: QueryDirectory returns NULL\n"));
    }

    return pdir;
}

ULIB_EXPORT
PFSN_FILE
SYSTEM::MakeFile (
    IN PCPATH   Path
    )

/*++

Routine Description:

    Creates a File and returs the corresponging FSN_FILE object.

    If the file already exists, its contents are destroyed.

    Note that all the subdirectories along the path must exist (this
    method does not create directories).

Arguments:

    Path            - Supplies the Path of the file to be created.

Return Value:

    PFSN_FILE   -   A pointer to the FSN_FILE object of the file created.

--*/

{

    HANDLE      Handle;
    PCWSTR      PathString;
    PFSN_FILE   File = NULL;

    DebugPtrAssert( Path );

    PathString = Path->GetPathString()->GetWSTR();

    DebugPtrAssert( PathString );

    if ( PathString ) {

        Handle = CreateFile( (LPWSTR) PathString,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             0 );


        DebugAssert( Handle != INVALID_HANDLE_VALUE );

        if ( Handle != INVALID_HANDLE_VALUE ) {

            //
            //  Now that we know that the file exists, we use the
            //  QueryFile method to obtain the FSN_FILE object.
            //
            CloseHandle( Handle );

            File = QueryFile( Path );

        }
    }

    return File;

}

ULIB_EXPORT
PFSN_FILE
SYSTEM::MakeTemporaryFile (
    IN PCWSTRING PrefixString,
    IN PCPATH           Path
    )

/*++

Routine Description:

    Creates a file with a unique name using the provided path and
    prefix string. If the path is NULL, then the defult path for
    temporary files is used.

Arguments:

    PrefixString    - Supplies the file prefix used for creating the
                      file name.

    Path            - Supplies the Path of the directory to contain the
                      temporary file.


Return Value:

    PFSN_FILE   -   A pointer to the FSN_FILE object of the file created.

--*/

{
    DWORD       BufferSize;
    LPWSTR      TempPath;
    PCWSTR      TempPrefix;

    WCHAR       FileName[ MAX_PATH ];

    PFSN_FILE   File = NULL;
    PATH        FilePath;


    DebugPtrAssert( PrefixString );

    TempPrefix = PrefixString->GetWSTR();

    DebugPtrAssert( TempPrefix );

    if ( TempPrefix ) {

        //
        //  Get the STR representation of the directory for temporary files
        //
        if ( !Path ) {

            //
            //  Path not supplied, we will use the default
            //
            BufferSize = GetTempPath( 0, NULL );
            TempPath = (LPWSTR)MALLOC( (unsigned int)BufferSize * 2 );

            if ((TempPath != NULL) &&
                !GetTempPath( BufferSize, TempPath )) {
                FREE( TempPath );
                TempPath = NULL;
            }

        } else {

            //
            //   We will use the supplied path (and it better exist)
            //
            TempPath = Path->GetPathString()->QueryWSTR();

        }

        DebugPtrAssert( TempPath );

        if ( TempPath ) {

            //
            //  Now get the file name of the Temporary File.
            //
            if (!GetTempFileName( TempPath, (LPWSTR) TempPrefix, 0, FileName )) {
                FREE( TempPath );
                return NULL;
            }

            //
            //  Now create the file
            //
            FilePath.Initialize( FileName );

            File = MakeFile( &FilePath );

            FREE( TempPath );


        }
    }

    return File;

}

ULIB_EXPORT
BOOLEAN
SYSTEM::RemoveNode (
    IN OUT PFSNODE  *PointerToNode,
    IN     BOOLEAN   Force
    )

/*++

Routine Description:

    DDeletes nodes and directories.

    Read-only files are deleted only if the supplied "Force" flag
    is true.

Arguments:

    Node    -   Supplies a pointer to a pointer to the node

    Force   -   Supplies a flag which if TRUE means that the file
                should be deleted even if it is read-only.


Return Value:

    BOOLEAN -   Returns TRUE if the file was deleted successfully.

--*/

{

    PFSN_FILE       File;
    PFSN_DIRECTORY  Dir;
    PCWSTR          FileName;
    BOOL            Deleted = FALSE;

    DebugPtrAssert( PointerToNode );
    DebugPtrAssert( *PointerToNode );


    File = FSN_FILE::Cast( *PointerToNode );

    if ( File ) {

        //
        //  The node is a file
        //

        //
        //  We delete the file if it is not read-only or if the Force flag
        //  is set.
        //
        if ( Force || !File->IsReadOnly() ) {

            //
            //  If readonly, we reset the read only attribute.
            //
            if ( File->IsReadOnly() ) {

                File->ResetReadOnlyAttribute();

            }

            //
            //  Now we delete the file
            //
            FileName = File->GetPath()->GetPathString()->GetWSTR();

            DebugPtrAssert( FileName );

            if ( FileName ) {

                Deleted = DeleteFile( (LPWSTR) FileName );

                if ( Deleted ) {

                    //
                    //  The file has been deleted, now we have to get rid of
                    //  the file object, which is no longer valid.
                    //
                    DELETE( File );
                    *PointerToNode = NULL;

                }
            }

        }

    } else {

        Dir = FSN_DIRECTORY::Cast( *PointerToNode );

        if ( Dir ) {

            //
            //  We remove the directory if it is not read-only or if the Force flag
            //  is set.
            //
            if ( Force || !Dir->IsReadOnly() ) {

                //
                //  If readonly, we reset the read only attribute.
                //
                if ( Dir->IsReadOnly() ) {

                    Dir->ResetReadOnlyAttribute();

                }

                //
                //  Now we remove the directory
                //
                FileName = Dir->GetPath()->GetPathString()->GetWSTR();

                DebugPtrAssert( FileName );

                if ( FileName ) {

                    Deleted = RemoveDirectory( (LPWSTR) FileName );

                    if ( Deleted ) {

                        //
                        //  The directory has been  removed, now we have
                        //  to get rid of
                        //  the directory object, which is no longer valid.
                        //
                        DELETE( Dir );
                        *PointerToNode = NULL;

                    }
                }

            }

        } else {

            DebugAssert( FALSE );

        }

    }
    return Deleted != FALSE;

}

ULIB_EXPORT
PFSN_DIRECTORY
SYSTEM::QueryDirectory (
    IN PCPATH   Path,
    IN BOOLEAN  GetWhatYouCan
    )

/*++

Routine Description:

    Construct, initialize and return a FSN_DIRECTORY object.

Arguments:

    Path            - Supplies a PATH object to construct as a FSN_DIRECTORY.
                      **** IMPORTANT ****
                      If Path represents a drive (ie, C: ) the it must be terminated
                      by '\'. Otherwise the return value (PFSN_DIRECTORY will
                      contain information about the current directory, and not
                      the root directory.

    GetWhatYouCan   - Supplies a flag which if TRUE causes QueryDirectory to
                      backtrack along the path until it finds something
                      that it can open.

Return Value:

    PFSN_DIRECTORY - Returns a pointer to a FSN_DIRECTORY, NULL if the
        supplied path name does not point to an existing directory.

--*/

{
    WIN32_FIND_DATA             FindData;
    HANDLE                      Handle;
    PPATH                       TempPath;
    PFSN_DIRECTORY              Directory;
    PATH                        Parent;
    PCWSTRING                   TempString;
    PWSTRING                    DeviceString;
    BOOLEAN                     IsRoot;
    FSTRING                     TmpString;
    PCWSTR                      RootString = NULL;
    PATH                        FullPath;

    DebugPtrAssert( Path );

    //
    // Initialize the FSN_DIRECTORY and PATH pointers
    //
    Directory   = NULL;
    TempPath    = NULL;

    if ( !Path->HasWildCard() ) {

        //
        // If the supplied path exists and it references an existing entry
        // in the file system and it's a directory
        //

        TempPath = Path->QueryPath();
        DebugPtrAssert( TempPath );
        FullPath.Initialize( TempPath, TRUE );


        if ( TempPath != NULL ) {

            DeviceString = FullPath.QueryDevice();

            if ( DeviceString ) {
                IsRoot = (FullPath.IsRoot() || !FullPath.GetPathString()->Stricmp( DeviceString ) );
                DELETE( DeviceString );
            } else {
                IsRoot = TempPath->IsRoot();
            }

            if( !IsRoot ) {
                //
                // If path does not represent the root directory, then let it
                // call FindFirstFile()
                //
                if( ( Handle = FindFirstFile( TempPath, &FindData )) != INVALID_HANDLE_VALUE ) {

                    //
                    // Terminate the search
                    //
                    FindClose( Handle );

                    if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                        if ( !((( Directory = NEW FSN_DIRECTORY ) != NULL ) &&
                            Directory->Initialize( TempPath->GetPathString( ), &FindData ))) {

                            DELETE( Directory );
                        }
                    }
                }
            } else {

                //
                //  So we have a root directory. We have to determine if it
                //  is a valid drive. We used to call FindFirstFile on it,
                //  but it so happens that FindFirstFile may fail if the
                //  volume in question is empty (we don't even get the
                //  "." or ".." entries!)
                //
                if ( TmpString.Initialize( (PWSTR) L"." )                 &&
                     TempPath->AppendBase( &TmpString )                   &&
                     (RootString = TempPath->GetPathString()->GetWSTR())  &&
                     (GetFileAttributes( (LPWSTR) RootString ) != -1) ) {
                    //
                    // Path represents the root directory. We don't use the information
                    // obtained by FindFirstFile because that refers to the first entry
                    // in the root directory, not the root directory itself.
                    // This is not a bug in the API, but the way it is specified.
                    //
                    // The concept of WIN32_FIND_DATA does not apply to the root directory.
                    // For this reason I will do the initialization of FindData.
                    // Everything in FindData will be initialized, but the FILETIMEs will
                    // be initialized with zero.
                    //
                    // It is important that Path is contains a '\' at the end
                    // if it represents a drive.

                    TempPath->TruncateBase();

                    FindData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                    FindData.ftCreationTime.dwLowDateTime       = 0;
                    FindData.ftCreationTime.dwHighDateTime      = 0;
                    FindData.ftLastAccessTime.dwLowDateTime     = 0;
                    FindData.ftLastAccessTime.dwHighDateTime    = 0;
                    FindData.ftLastWriteTime.dwLowDateTime      = 0;
                    FindData.ftLastWriteTime.dwHighDateTime     = 0;
                    FindData.nFileSizeHigh  = 0;
                    FindData.nFileSizeLow   = 0;

                    TempString = TempPath->GetPathString();
                    DebugPtrAssert( TempString );
                    TempString->QueryWSTR( 0, TO_END, (LPWSTR)FindData.cFileName, MAX_PATH );
                    if ( !((( Directory = NEW FSN_DIRECTORY ) != NULL ) &&
                        Directory->Initialize( TempPath->GetPathString( ), &FindData ))) {

                        DELETE( Directory );
                    }
                }
            }
        }

        DELETE( TempPath );
    }

    if (!Directory && GetWhatYouCan && !Path->IsDrive() && !Path->IsRoot()) {
        //
        //  The path is not that of an existing directory.
        //  take off the base and try again.
        //
        Parent.Initialize( Path );
        Parent.TruncateBase();

        Directory = QueryDirectory( &Parent, GetWhatYouCan );
    }

    return Directory;
}



ULIB_EXPORT
PPATH
SYSTEM::QuerySystemDirectory (
    )

/*++

Routine Description:

    Returns the directory where the system files are located.

Arguments:

    None

Return Value:

    PPATH   -   Path of the system directory.

--*/

{
    WCHAR   Buffer[MAX_PATH];
    DSTRING PathName;
    PPATH   Path = NULL;
    DWORD   Cb;

    Cb = GetSystemDirectory( Buffer, MAX_PATH );

    if ( (Cb != 0) || (Cb < MAX_PATH) ) {

        if ( !PathName.Initialize( (PWSTR)Buffer) ||
             !(Path = NEW PATH)           ||
             !Path->Initialize( &PathName )
           ) {

            DELETE( Path );

        }
    }

    return Path;
}



const MaxEnvVarLen = 256;

ULIB_EXPORT
PWSTRING
SYSTEM::QueryEnvironmentVariable (
    IN PCWSTRING    Variable
    )

/*++

Routine Description:

    Obtains the value of an environment variable

Arguments:

    Variable    -   Supplies the variable to look for

Return Value:

    Value of the environment variable, NULL if not defined

--*/

{

    PCWSTR      Buffer;
    WCHAR       Value[MaxEnvVarLen];
    PWSTRING    pString;
    ULONG       ValueLength;

    if (!Variable) {
        return NULL;
    }

    //
    //  Get the ApiString of the variable to look for
    //
    Buffer = Variable->GetWSTR();

    //
    //  Look for the variable
    //
    ValueLength = GetEnvironmentVariable( (LPWSTR) Buffer, Value, MaxEnvVarLen );

    if ( ValueLength == 0 ) {

        //
        //  The environment variable is not defined
        //
        return NULL;
    }

    //
    //  Got the value, form a string with it and return it
    //
    if ( (pString = NEW DSTRING) != NULL ) {

         if (pString->Initialize( Value )) {

            return pString;

         }

         DELETE( pString );
     }

     return NULL;

}

ULIB_EXPORT
PPATH
SYSTEM::SearchPath(
    PWSTRING    pFileName,
    PWSTRING    pSearchPath
    )
/*++

Routine Description:

    Search a given path for a file name.  If the input path is NULL, the
    routine searches the default path.

Arguments:

    pSearchPath - Supplies a set of semicolon terminated paths.
    pFileName   - The name of the file to search for.

Return Value:

    A pointer to a path containing the first occurance of pFileName.  If the
    name isn't found, the path is NULL.

--*/
{
    CHNUM   cb;
    WSTR    ReturnPath[ MAX_PATH + 1 ];
    PPATH   pFullPath;
    LPWSTR  pFilePart;
    PCWSTR  pPath;
    PCWSTR  pName;

    if( pSearchPath != NULL ) {
        // Extract the path from pSearchPath for the API call...
        pPath = pSearchPath->GetWSTR();
    } else {
        pPath = NULL;
    }
    if( pFileName == NULL ) {
        DebugPrint( "The input filename is NULL - Can't find it...\n" );
        return( NULL );
    }
    // Extract the filename from the pFileName string...
    pName = pFileName->GetWSTR();

    //
    // Call the API ...
    //
    cb = ::SearchPath( (LPWSTR) pPath,
                     (LPWSTR) pName,
                     NULL,      // The extension must be specified as part of the file name...
                     MAX_PATH,
                     ReturnPath,
                     &pFilePart
                   );


    if( !cb ) {
        DebugPrint( "File name not found...\n" );
        return( NULL );
    }

    //
    // Create a new path and Initialize it with the buffer resulting
    //
    if( ( pFullPath = NEW PATH ) == NULL ) {
        DebugPrint( "Unable to allocate the path to return the data...\n" );
        return( NULL );
    }

    if( !pFullPath->Initialize( ReturnPath, FALSE ) ) {
        DebugPrint( "Unable to initialize the new path!\n" );
        return( NULL );
    }

    //
    // The path should now be constucted...
    //
    return( pFullPath );
}

ULIB_EXPORT
PFSN_FILE
SYSTEM::QueryFile (
    IN PCPATH       Path,
    IN BOOLEAN      SkipOffline,
    OUT PBOOLEAN    pOfflineSkipped
    )

/*++

Routine Description:

    Construct, initialize and return a FSN_FILE object.

Arguments:

    Path - Supplies a PATH object to construct as a FSN_FILE.
    SkipOffline - Specifies whether to skip offline files
    OfflineSkipped - Specifies whether an offline file has beed skipped

Return Value:

    A pointer to a FSN_FILE.

--*/

{

    PFSN_FILE           File        =   NULL;
    PPATH               FullPath    =   NULL;
    HANDLE              Handle;
    WIN32_FIND_DATA     FindData;

    DebugPtrAssert( Path );

    if (pOfflineSkipped) {
        *pOfflineSkipped = FALSE;
    }

    if ( Path                                                                       &&
         !Path->HasWildCard()                                                       &&
         ((FullPath = Path->QueryFullPath()) != NULL )                              &&
         ((Handle = FindFirstFile( FullPath, &FindData )) != INVALID_HANDLE_VALUE) ) {

        FindClose( Handle );

        if (! (SkipOffline && (FindData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)) ) {

            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                if ((File = NEW FSN_FILE) != NULL) {
                    if ( !(File->Initialize(FullPath->GetPathString(), &FindData)) ) {
                        DELETE( File );
                        File = NULL;
                    }
                }
            }

        } else {
            // Skip offline file
            if (pOfflineSkipped) {
                *pOfflineSkipped = TRUE;
            }
        }
    }

    DELETE( FullPath );

    return File;
}


BOOLEAN
SYSTEM::PutStandardStream(
    IN  DWORD   StdHandle,
    IN  PSTREAM pStream
    )
/*++

Routine Description:

    Redirect a standard stream.

Arguments:

    StdHandle - An identifier for the Standard Handle to modify.
    pStream   - The standard stream is redirected to this stream.

Return Value:

    TRUE if successful.

--*/
{
    //
    // First, set the system standard handle to the stream
    //
    if( !SetStdHandle( StdHandle, pStream->QueryHandle() ) ) {
        DebugPrint( "Unable to redirect the system handle - nothing changed!\n" );
        return( FALSE );
    }


    //
    // Get a pointer to the stream to change...
    //
    switch( StdHandle ) {
        case STD_INPUT_HANDLE:
            Standard_Input_Stream = pStream;
            break;
        case STD_OUTPUT_HANDLE:
            Standard_Output_Stream = pStream;
            break;
        case STD_ERROR_HANDLE:
            Standard_Error_Stream = pStream;
            break;
        default:
            DebugPrint( "Unrecognized Standard Handle Type - Returning Error!\n" );
            return( FALSE );
    }
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryCurrentDosDriveName(
    OUT PWSTRING    DosDriveName
    )
/*++

Routine Description:

    This routine returns the name of the current drive.

Arguments:

    DosDriveName    - Returns the name of the current drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATH                path;
    PWSTRING     p;

    if (!path.Initialize( (LPWSTR)L"foo", TRUE)) {
        return FALSE;
    }

    if (!(p = path.QueryDevice())) {
        return FALSE;
    }

    if (!DosDriveName->Initialize(p)) {
        return FALSE;
    }

    DELETE(p);

    return TRUE;
}


ULIB_EXPORT
DRIVE_TYPE
SYSTEM::QueryDriveType(
    IN  PCWSTRING    DosDriveName
    )
/*++

Routine Description:

    This routine computes the type of drive pointed to by 'DosDriveName'.

Arguments:

    DosDriveName    - Supplies the dos name of the drive.

Return Value:

    The type of drive that is pointed to by 'DosDriveName'.

--*/
{
    DSTRING     wstring;
    DSTRING     slash;
    PCWSTR      p;
    DRIVE_TYPE  r;

    if (!wstring.Initialize(DosDriveName)) {
        return UnknownDrive;
    }

    if (!slash.Initialize("\\")) {
        return UnknownDrive;
    }

    wstring.Strcat(&slash);

    if (!(p = wstring.GetWSTR())) {
        return UnknownDrive;
    }

    switch (GetDriveType((LPWSTR) p)) {
        case DRIVE_REMOVABLE:
            r = RemovableDrive;
            break;

        case DRIVE_FIXED:
            r = FixedDrive;
            break;

        case DRIVE_REMOTE:
            r = RemoteDrive;
            break;

        case DRIVE_CDROM:
            r = CdRomDrive;
            break;

        case DRIVE_RAMDISK:
            r = RamDiskDrive;
            break;

        default:
            r = UnknownDrive;
            break;

    }

    return r;
}

ULIB_EXPORT
FILE_TYPE
SYSTEM::QueryFileType(
    IN  PCWSTRING    DosFileName
    )
/*++

Routine Description:

    This routine computes the type of filee pointed to by 'DosFileName'.

Arguments:

    DosFileName - Supplies the dos name of the file.

Return Value:

    The type of file that is pointed to by 'DosFileName'.

--*/
{
    DSTRING     wstring;
    PCWSTR      p;
    FILE_TYPE   r;
    HANDLE      Handle;

    if (!wstring.Initialize(DosFileName)) {
        return UnknownFile;
    }

    if (!(p = wstring.GetWSTR())) {
        return UnknownFile;
    }

    Handle = CreateFile( (LPWSTR) p,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                         NULL );

    if ( Handle != INVALID_HANDLE_VALUE ) {

        switch ( GetFileType( Handle ) ) {

            case FILE_TYPE_DISK:
                r = DiskFile;
                break;

            case FILE_TYPE_CHAR:
                r = CharFile;
                break;

            case FILE_TYPE_PIPE:
                r = PipeFile;
                break;

            default:
                r = UnknownFile;
                break;

        }

        CloseHandle( Handle );

    } else {

        r = UnknownFile;
    }

    return r;
}



ULIB_EXPORT
PWSTRING
SYSTEM::QueryVolumeLabel(
    IN      PPATH               Path,
       OUT  PVOL_SERIAL_NUMBER      VolSerialNumber
    )
/*++

Routine Description:

    Returns the name and serial number of a volume.

Arguments:

    Path - Path in the file system whose volume information is to be
           retrieved.

    VolSerialNumber -   Pointer to a structure that will contain the
                        serial number

Return Value:

    PWSTRING -  Pointer to a WSTRING that will contain the volume name, or
                NULL if an error occurs.


--*/
{
    PWSTRING            VolumeName;
    PWSTRING            RootString;
    PCWSTR              RootName;
    WCHAR               VolumeNameBuffer[ MAX_PATH ];
    ULONG               SerialNumber[2];

    DebugPtrAssert( Path );
    DebugPtrAssert( VolSerialNumber );
    RootString = Path->QueryRoot();
    if (RootString == NULL) {
        return NULL;
    }
    DebugPtrAssert( RootString );
    RootName = RootString->GetWSTR();
    if( !GetVolumeInformation( (LPWSTR) RootName,
                              (LPWSTR)VolumeNameBuffer,
                              MAX_PATH,
                              ( PDWORD )SerialNumber,
                              NULL,
                              NULL,
                              NULL,
                              0 ) ) {
        DELETE( RootString );
        return( NULL );
    }
    VolSerialNumber->LowOrder32Bits = SerialNumber[ 0 ];
    VolSerialNumber->HighOrder32Bits = SerialNumber[ 1 ];
    VolumeName = NEW( DSTRING );
    if (VolumeName == NULL ||
        !VolumeName->Initialize( VolumeNameBuffer )) {
        DELETE( RootString );
        DELETE( VolumeName );
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }
    DELETE( RootString );
    return( VolumeName );
}



const MaximumLibraryNameLength = 256;
const MaximumEntryPointNameLength = 128;

ULIB_EXPORT
FARPROC
SYSTEM::QueryLibraryEntryPoint(
    IN  PCWSTRING   LibraryName,
    IN  PCWSTRING   EntryPointName,
    OUT PHANDLE     LibraryHandle
    )
/*++

Routine Description:

    Loads a dynamically-linked library and returns an
    entry point into it.

Arguments:

    LibraryName -- name of the library to load

    EntryPointName -- name of the entry point to get

    LibraryHandle -- receives handle of loaded library

Return Value:

    Pointer to the requested function; NULL to indicate failure.

--*/
{
    WCHAR AnsiLibraryName[MaximumLibraryNameLength+1];
    CHAR  AnsiEntryPointName[MaximumEntryPointNameLength+1];
    FARPROC EntryPoint;


    LibraryName->QueryWSTR( 0, TO_END, AnsiLibraryName, MaximumLibraryNameLength + 1);

    EntryPointName->QuerySTR( 0, TO_END, AnsiEntryPointName,
                                         MaximumEntryPointNameLength + 1 );

    if( (*LibraryHandle = (HANDLE)LoadLibrary( AnsiLibraryName )) != NULL &&
        (EntryPoint = GetProcAddress( (HINSTANCE)*LibraryHandle,
                                      (LPSTR)AnsiEntryPointName )) != NULL ) {

        return EntryPoint;

    } else {

        if( *LibraryHandle != NULL ) {

            FreeLibrary( (HMODULE)*LibraryHandle );
            *LibraryHandle = NULL;
        }

        return NULL;
    }
}


ULIB_EXPORT
VOID
SYSTEM::FreeLibraryHandle(
    HANDLE LibraryHandle
    )
/*++

Routine Description:

    Frees a library handle gotten by QueryLibraryEntryPoint

Arguments:

    LibraryHandle -- handle to free

Return Value:

    None.

--*/
{
    FreeLibrary( (HMODULE)LibraryHandle );
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryLocalTimeFromUTime(
    IN  PCTIMEINFO  UTimeInfo,
    OUT PTIMEINFO   LocalTimeInfo
    )
/*++

Routine Description:

    This routine computes the local time from the given
    universal time.

Arguments:

    UTimeInfo       - Supplies the universal time to convert.
    LocalTimeInfo   - Returns the corresponding local time.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILETIME    filetime;

    DebugAssert(UTimeInfo->GetFileTime());

    if (!FileTimeToLocalFileTime(UTimeInfo->GetFileTime(), &filetime)) {
        return FALSE;
    }

    return LocalTimeInfo->Initialize(&filetime);
}


BOOLEAN
SYSTEM::QueryUTimeFromLocalTime(
    IN  PCTIMEINFO  LocalTimeInfo,
    OUT PTIMEINFO   UTimeInfo
    )
/*++

Routine Description:

    This routine computes the universal time from the given
    local time.

Arguments:

    LocalTimeInfo   - Supplies the local time to convert.
    UTimeInfo       - Returns the corresponding universal time.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILETIME    filetime;

    DebugAssert(LocalTimeInfo->GetFileTime());

    if (!LocalFileTimeToFileTime(LocalTimeInfo->GetFileTime(), &filetime)) {
        return FALSE;
    }

    return UTimeInfo->Initialize(&filetime);
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryWindowsErrorMessage(
    IN  ULONG       WindowsErrorCode,
    OUT PWSTRING    ErrorMessage
    )
/*++

Routine Description:

    This routine returns the text corresponding to the given
    windows error message.

Arguments:

    WindowsErrorCode    - Supplies the windows error code.
    ErrorMessage        - Returns the error message for this error code.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WCHAR   buffer[MAX_PATH];

    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                       WindowsErrorCode, 0, buffer, MAX_PATH, NULL)) {

        return FALSE;
    }

    return ErrorMessage->Initialize(buffer);
}


STATIC BOOLEAN
GetFileSecurityBackupW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded,
    BOOLEAN UseBackUp,
    PULONG FileAttributes
    )
/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a file or directory.  Based on the caller's access
    rights and privileges, this procedure will return a security
    descriptor containing the requested security descriptor fields.
    To read the handle's security descriptor the caller must be
    granted READ_CONTROL access or be the owner of the object.  In
    addition, the caller must have SeSecurityPrivilege privilege to
    read the system ACL.

Arguments:

    lpFileName - Represents the name of the file or directory whose
                security is being retrieved.

    RequestedInformation - A pointer to the security information being
                requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.

    FileAttributes - returns the file attributes (hidden, system, etc).

Return Value:

    TRUE is returned for success, FALSE if access is denied or if the
        buffer is too small to hold the security descriptor.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    PVOID FreeBuffer;
    ULONG Flags;

    DesiredAccess = SYNCHRONIZE | FILE_GENERIC_READ;

    if ((RequestedInformation & OWNER_SECURITY_INFORMATION) ||
        (RequestedInformation & GROUP_SECURITY_INFORMATION) ||
        (RequestedInformation & DACL_SECURITY_INFORMATION)) {
        DesiredAccess |= READ_CONTROL;
    }

    if ((RequestedInformation & SACL_SECURITY_INFORMATION)) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (!RtlDosPathNameToRelativeNtPathName_U(lpFileName, &FileName, NULL,
        &RelativeName)) {
        return(FALSE);
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja, &FileName, OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory, NULL);

    if (UseBackUp) {
        Flags = FILE_OPEN_FOR_BACKUP_INTENT;
    } else {
        Flags = 0;
    }

    Status = NtOpenFile(&FileHandle, DesiredAccess, &Obja,
        &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        Flags);

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtQueryInformationFile(FileHandle, &IoStatusBlock, &BasicInfo,
        sizeof(BasicInfo), FileBasicInformation);

    if (!NT_SUCCESS(Status)) {
        NtClose(FileHandle);
        return FALSE;
    }

    *FileAttributes = BasicInfo.FileAttributes;

    Status = NtQuerySecurityObject(FileHandle, RequestedInformation,
        pSecurityDescriptor, nLength, lpnLengthNeeded);

    NtClose(FileHandle);

    return NT_SUCCESS(Status);
}


ULIB_EXPORT
BOOLEAN
SYSTEM::GetFileSecurityBackup(
    IN  PCPATH  Path,
    IN  SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_ATTRIBUTES SecurityAttrib,
    OUT PULONG  FileAttributes
    )
/*++

Routine Description:

    This routine retrieves the security descriptor from the specified
    path.  The file is opened for BACKUP_READ, so if the right privilege
    is enabled it should be able to retrieve information even for files
    that the caller does not directly have access to.

Arguments:

    Path            - Specifies the path for which info is queried.
    SecurityInfo    - Specifies what types of information is to be retrieved.
    SecurityAttrib  - Returns the security descriptor and its size.
    FileAttributes  - Returns file attributes (hidden, system, etc.)

Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    ULONG cbSdSize, cbRequired;
    BOOLEAN bSuccess;
    PVOID psd;
    PCWSTR pcwsSource;
    const int LargeSecurityDescriptorSize = 6000;

    pcwsSource = Path->GetPathString()->GetWSTR();
    DebugPtrAssert(pcwsSource);

    cbSdSize = LargeSecurityDescriptorSize;
    cbRequired = 0;

    if (NULL == (psd = MALLOC(cbSdSize))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    bSuccess = GetFileSecurityBackupW(pcwsSource, SecurityInfo, psd, cbSdSize,
        &cbRequired, TRUE, FileAttributes);

    if (!bSuccess) {
        if (0 == cbRequired) {
            return FALSE;
        }
        cbSdSize = cbRequired;

        GlobalFree(psd);

        if (NULL == (psd = MALLOC(cbSdSize))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        bSuccess = GetFileSecurityBackupW(pcwsSource, SecurityInfo, psd,
            cbSdSize, &cbRequired, TRUE, FileAttributes);

        if (!bSuccess) {
            return FALSE;
        }
    }

    SecurityAttrib->nLength = cbSdSize;
    SecurityAttrib->lpSecurityDescriptor = psd;
    SecurityAttrib->bInheritHandle = TRUE;

    return TRUE;
}

ULIB_EXPORT
VOID
SYSTEM::DisplaySystemError(
    IN DWORD ErrorCode,
    IN BOOL Exit
    )
{
    DWORD Result;
    LPTSTR Buffer;

    //
    //  Use the system to generate an error message.
    //

    Result = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL,
                            ErrorCode,
                            0,
                            (LPTSTR) &Buffer,
                            0,
                            NULL);
    if (Result)  {

        wprintf( L"%s", Buffer);
        LocalFree( Buffer);
    }

    if (Exit)  {

        PROGRAM::ExitProgram( EXIT_READWRITE_ERROR );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\spackmsg.cxx ===
/*++

Copyright (c) 1991-1994 Microsoft Corporation

Module Name:

    spackmsg.cxx

Abstract:

    Contains the implementation of the SP_AUTOCHECK_MESSAGE subclass.

Author:

    Lonny McMichael (lonnym) 09-Jun-94

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "spackmsg.hxx"


DEFINE_CONSTRUCTOR(SP_AUTOCHECK_MESSAGE, AUTOCHECK_MESSAGE);

SP_AUTOCHECK_MESSAGE::~SP_AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for SP_AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
SP_AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
}


VOID
SP_AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
}


BOOLEAN
SP_AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine outputs the message to the debugger (if checked build).

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

    //
    // Log the output if necessary
    //
    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    //
    // Send the output to the debug port.
    //
    if( display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
SP_AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR            buffer[256];
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    //
    // Send the output to the debug port.
    //
    if( string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
    }

    return Default;
}

BOOLEAN
SP_AUTOCHECK_MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}

BOOLEAN
SP_AUTOCHECK_MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns TRUE to indicate it is in
    setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\string.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	GENERIC_STRING

Abstract:

	This module contains the implementation for the GENERIC_STRING class.

Author:

	Ramon J. San Andres (ramonsa)	07-May-1991


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "string.hxx"


DEFINE_CONSTRUCTOR( GENERIC_STRING, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( GENERIC_STRING );

GENERIC_STRING::~GENERIC_STRING(
    )
{
}

VOID
GENERIC_STRING::Construct (
    )

/*++

Routine Description:

	Constructs a GENERIC_STRING object

Arguments:

    None.

Return Value:

    None.


--*/

{
}

BOOLEAN
GENERIC_STRING::Initialize (
    )

/*++

Routine Description:

	Phase 2 of construction for a GENERIC_STRING.

Arguments:

	none

Return Value:

	TRUE  if the string was successfully initialized,
	FALSE otherwise.

--*/

{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\timeinfo.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    timeinfo.cxx

Abstract:

    This module contains the definitions of the member functions
    of TIMEINFO class.

Author:

    Jaime Sasson (jaimes) 13-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"
#include "timeinfo.hxx"

extern "C" {
    #include <stdio.h>
}


//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST USHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST USHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};



//
//  The tables below contain the number of days in each month of
//  a year (leap and normal year)
//

CONST USHORT LeapYearDaysInMonth[12] = {
                                   31, // January
                                   29, // February
                                   31, // March
                                   30, // April
                                   31, // May
                                   30, // June
                                   31, // July
                                   31, // August
                                   30, // September
                                   31, // October
                                   30, // November
                                   31  // December
                                   };

CONST USHORT NormalYearDaysInMonth[12] = {
                                   31, // January
                                   28, // February
                                   31, // March
                                   30, // April
                                   31, // May
                                   30, // June
                                   31, // July
                                   31, // August
                                   30, // September
                                   31, // October
                                   30, // November
                                   31  // December
                                   };




DEFINE_EXPORTED_CONSTRUCTOR ( TIMEINFO, OBJECT, ULIB_EXPORT );

VOID
TIMEINFO::Construct (
    )

/*++

Routine Description:

    Contructs a TIMEINFO.

Arguments:

    None.

Return Value:

    None.


--*/

{
    // unreferenced parameters
    (void)(this);
}




BOOLEAN
TIMEINFO::Initialize(
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the current date and time.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    SYSTEMTIME  st;

    GetSystemTime( &st );
    return( this->Initialize( &st ) );
}




ULIB_EXPORT
BOOLEAN
TIMEINFO::Initialize(
    IN PFILETIME    FileTime
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the structured pointed by FileTime.

Arguments:

    FileTime - Pointer to a FILETIME structure that contains the
               date and time to be used in the initialization of the
               date members.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    _FileTime = *FileTime;
    return( FileTimeToSystemTime( &_FileTime, &_SystemTime ) != FALSE );
}


BOOLEAN
TIMEINFO::Initialize(
    IN PSYSTEMTIME  SystemTime
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the structured pointed by SystemTime.

Arguments:

    SystemTime - Pointer to a SYSTEMTIME structure that contains the
                 date and time to be used in the initialization of the
                 data members.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    BOOLEAN Result;

    _SystemTime = *SystemTime;
    Result = (BOOLEAN)SystemTimeToFileTime( &_SystemTime, &_FileTime );
//
//  The call below is necessary in order to make sure that
//  SystemTime.wDayOfWeek is correctly initialized
//
    Result &= FileTimeToSystemTime( &_FileTime, &_SystemTime );
    return( Result );
}


ULIB_EXPORT
VOID
TIMEINFO::Initialize(
    IN PCTIMEINFO   TimeInfo
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the class pointed by pTimeInfo.

Arguments:

    TimeInfo -  Pointer to a TIMEINFO class that contains the
                date and time to be used in the initialization of the
                data members in this class.

Return Value:

    None.


--*/


{
    _FileTime = TimeInfo->_FileTime;
    _SystemTime = TimeInfo->_SystemTime;
}



BOOLEAN
TIMEINFO::Initialize(
    IN USHORT   Year,
    IN USHORT   Month,
    IN USHORT   Day,
    IN USHORT   Hour,
    IN USHORT   Minute,
    IN USHORT   Second,
    IN USHORT   Milliseconds
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time information received as parameter.

Arguments:

    Year - A number indicating the year
    Month - A number indicating the month
    Day - A number indicating the day
    Hour  - Number of hours
    Minute - Number of minutes
    Second - Number of seconds
    Milliseconds - Number of milliseconds

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    SYSTEMTIME  st;
    st.wYear = Year;
    st.wMonth = Month;
    st.wDay = Day;
    st.wHour = Hour;
    st.wMinute = Minute;
    st.wSecond = Second;
    st.wMilliseconds = Milliseconds;

    return( this->Initialize( &st ) );
}


SHORT
TIMEINFO::CompareTimeInfo(
    IN PFILETIME    FileTime
    ) CONST


/*++

Routine Description:

    This function compares the date and time information stored in
    this class, with one pointed by FileTime.

Arguments:

    FileTime -  Pointer to a FILETIME structure that contains the
                date and time to be used in the comparison.

Return Value:

    -1: - Indicates that the time information in this class is less
          than the time information pointed by FileTime.

     0: - Indicates that the time information in this class is equal
          to the time information pointed by FileTime.

     1: - Indicates that the time information in this class is greater
          than the time information pointed by FileTime.


--*/

{
    FILETIME    ft1;

    ft1 = _FileTime;
    return( (SHORT)CompareFileTime( &ft1, FileTime ) ) ;
}



SHORT
TIMEINFO::CompareTimeInfo(
    IN PSYSTEMTIME  SystemTime
    ) CONST


/*++

Routine Description:

    This function compares the date and time information stored in
    this class, with the one pointed by SysteTime.

Arguments:

    SystemTime - Pointer to a FILETIME structure that contains the
                  date and time to be used in the comparison.

Return Value:

    -1: - Indicates that the time information in this class is less
          than the time information pointed by SystemTime.

     0: - Indicates that the time information in this class is equal
          to the time information pointed by SystemTime.

     1: - Indicates that the time information in this class is greater
          than the time information pointed by SystemTime.


--*/

{
    FILETIME    ft1;
    FILETIME    ft2;

    ft1 = _FileTime;
    SystemTimeToFileTime( SystemTime, &ft2 );
    return( (SHORT)CompareFileTime( &ft1, &ft2 ) );
}



USHORT
TIMEINFO::QueryDayOffset(
    ) CONST

/*++

Routine Description:

    This function determines the offset in year of the day stored in
    this class.

Arguments:

    None.

Return Value:

    USHORT - Offset in year of the current day.


--*/

{
    USHORT  Offset;

    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        Offset = LeapYearDaysPrecedingMonth[ _SystemTime.wMonth ];
    }
    else {
        Offset = NormalYearDaysPrecedingMonth[ _SystemTime.wMonth ];
    }
    Offset += _SystemTime.wDay;
    return( Offset );
}



USHORT
TIMEINFO::QueryDaysInMonth(
    ) CONST

/*++

Routine Description:

    This function determines the number of days in the month of the
    date stored in this class.

Arguments:

    None.

Return Value:

    USHORT - Number of days in the month.


--*/

{
    USHORT  NumberOfDays;

    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        NumberOfDays = LeapYearDaysInMonth[ _SystemTime.wMonth ];
    }
    else {
        NumberOfDays = NormalYearDaysInMonth[ _SystemTime.wMonth ];
    }
    return( NumberOfDays );
}



USHORT
TIMEINFO::QueryDaysInYear(
    ) CONST

/*++

Routine Description:

    This function determines the total number of days in the year
    stored in this class.

Arguments:

    None.

Return Value:

    USHORT - Number of days in the year.


--*/

{
    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        return( LeapYearDaysPrecedingMonth[ 12 ] );
    }
    else {
        return( NormalYearDaysPrecedingMonth[ 12 ] );
    }
}



BOOLEAN
TIMEINFO::SetDate(
    USHORT  Year,
    USHORT  Month,
    USHORT  Day
    )

/*++

Routine Description:

    This function sets the date of the TIMEINFO object (the time
    remains unchanged).

Arguments:

    Year  - A number that indicates the year.
    Month - A number that indicates the month.
    Day   - A number that indicates the day.

Return Value:

    BOOLEAN - A boolean value indicating if the date was set correctly.


--*/

{
    SYSTEMTIME    TempSystemTime;

    TempSystemTime = _SystemTime;
    TempSystemTime.wYear = Year;
    TempSystemTime.wMonth = Month;
    TempSystemTime.wDay = Day;
    return( this->Initialize( &TempSystemTime ) );
}



BOOLEAN
TIMEINFO::SetDate(
    PCWSTRING    Date
    )

/*++

Routine Description:

    This function sets the date of a TIMEINFO object (the time remains
    unchanged).

Arguments:

    Date  - A string that contains the date.

Return Value:

    BOOLEAN - A boolean value indicating if the date was set correctly.

Notes:

    THE IMPLEMENTATION BELOW ASSUMES THAT THE DATE REPRESENTED IN THE
    STRING HAS THE FORM: m-d-y or m/d/y, where:

        m: represents the month (1 or 2 characters);
        d: represents the day (1 or 2 characters);
        y: represents the year (any number of characters)

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    SYSTEMTIME  TempSystemTime;
    CHNUM       FirstDelimiter;
    CHNUM       SecondDelimiter;
    FSTRING     Delimiters;
    USHORT      Day;
    USHORT      Month;
    USHORT      Year;
    BOOLEAN     IsNumber;
    LONG        Number;


    //
    //  Check if the string is a valid one ( must contain two separators )
    //
    if( !Delimiters.Initialize( (PWSTR) L"/-" ) ) {
        return( FALSE );
    }
    if( ( FirstDelimiter = Date->Strcspn( &Delimiters ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    if( ( SecondDelimiter = Date->Strcspn(   &Delimiters,
                                             FirstDelimiter + 1 ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    if( Date->Strcspn( &Delimiters, SecondDelimiter + 1 ) != INVALID_CHNUM ) {
        return( FALSE );
    }
    //
    // At this point we know that the string has two delimiters and
    // three numeric fields.
    // We now have to extract the numbers that represent the date,
    // and validate these numbers.
    //

    if (!(IsNumber = Date->QueryNumber(&Number, 0, FirstDelimiter ))) {
        return FALSE;
    }
    Month = (USHORT)Number;

    if (!(IsNumber = Date->QueryNumber(&Number, FirstDelimiter+1, SecondDelimiter-FirstDelimiter-1))) {
        return FALSE;
    }
    Day = (USHORT)Number;

    if (!(IsNumber = Date->QueryNumber(&Number, SecondDelimiter+1))) {
        return FALSE;
    }
    Year = (USHORT)Number;

    if( ( Month == 0 ) || ( Month > 12 ) ) {
        return( FALSE );
    }
    //
    //  Years in the range 00 - 79 are transformed to 2000-2079
    //  Years in the range 80 - 99 are transformed to 1980-1999
    if( ( Year >= 80 ) && ( Year < 100 ) ) {
        Year += 1900;
    } else {
        if( Year <= 79 ) {
            Year += 2000;
        }

    }
    if( ( Day > 31 ) ||
        ( ( Day >= 30 ) && ( Month == 2 ) ) ||
        ( ( Day == 29 ) && ( Month == 2 ) && !IsLeapYear( Year ) ) ||
        ( ( Day == 31 ) && ( ( Month == 4 ) || ( Month == 6 ) ||
                             ( Month == 9 ) || ( Month == 11 ) ) ) ) {
        return( FALSE );
    }

    TempSystemTime = _SystemTime;
    TempSystemTime.wYear = ( USHORT )Year;
    TempSystemTime.wMonth = ( USHORT )Month;
    TempSystemTime.wDay = ( USHORT )Day;
    return( this->Initialize( &TempSystemTime ) );
}


BOOLEAN
TIMEINFO::SetDateAndTime (
    IN PCWSTRING DateAndTime
    )

/*++

Routine Description:

    This function sets the date or time of a TIMEINFO object.

Arguments:

    DateAndTime - A string that contains the date or time.

Return Value:

    BOOLEAN - A boolean value indicating if the date or time was set
    correctly.

Notes:

    THIS IMPLEMENTATION SETS ONLY THE DATE OR THE TIME, BUT NOT BOTH.
    IT RELIES ON HACKS UNTIL THE WINNLS SUPPORT IS AVAILABLE FOR
    TRANSFORMING STRINGS INTO DATES AND TIMES.

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    if( DateAndTime->Strchr( (WCHAR)':' ) == INVALID_CHNUM ) {
        //
        //  We assume that we have a date
        //
        if( !SetDate( DateAndTime ) ) {
            return( FALSE );
        }
        //
        // Sets the time to the earliest time in the day
        //
        return( SetTime( 0, 0, 0, 0 ) );
    } else {
        //
        //  We assume that we have a time
        //
        return SetTime( DateAndTime );
    }
}


BOOLEAN
TIMEINFO::SetTime(
    USHORT  Hour,
    USHORT  Minute,
    USHORT  Second,
    USHORT  Milliseconds
    )

/*++

Routine Description:

    This function sets the time of of a TIMEINFO object (the date
    remains unchanged).

Arguments:

    Hour -         Number of hours.
    Minute -       Number of minutes.
    Second -       Number of seconds.
    Milliseconds - Number of milliseconds

Return Value:

    BOOLEAN - A boolean value indicating if the time was set correctly.


--*/

{
    SYSTEMTIME    TempSystemTime;

    TempSystemTime = _SystemTime;
    TempSystemTime.wHour = Hour;
    TempSystemTime.wMinute = Minute;
    TempSystemTime.wSecond = Second;
    TempSystemTime.wMilliseconds = Milliseconds;
    return( this->Initialize( &TempSystemTime ) );
}



BOOLEAN
TIMEINFO::SetTime(
    PCWSTRING    Time
    )

/*++

Routine Description:

    This function sets the time of a TIMEINFO object (the date remains
    unchanged).

Arguments:

    Date  - A string that contains the time. This string must have
            one of the following formats:

                h:m
                h:m:s

            Where:

                h: represents the hour (1 or 2 digits)
                m: represents the minutes (1 or 2 digits)
                s: represents the seconds (1 or 2 digits)


Return Value:

    BOOLEAN - A boolean value indicating if the time was set correctly.

Notes:

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    CHNUM       FirstDelimiter;
    CHNUM       SecondDelimiter;
    USHORT      Hour;
    USHORT      Minute;
    USHORT      Second;
    BOOLEAN     IsNumber;
    LONG        Number;
    FSTRING     Delimiters;
    SYSTEMTIME  TempSystemTime;

    //
    //  Check if the string is a valid one
    //
    FirstDelimiter = INVALID_CHNUM;
    SecondDelimiter = INVALID_CHNUM;

    if( !Delimiters.Initialize( (LPWSTR) L":" ) ) {
        return( FALSE );
    }
    if( ( FirstDelimiter = Time->Strcspn( &Delimiters ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    SecondDelimiter = Time->Strcspn( &Delimiters, FirstDelimiter + 1 );

    //
    // At this point we know that the string has one or two delimiters, and
    // two or three numeric fields.
    // We now have to extract the numbers that represent the time,
    // and validate these numbers.
    //

    if (!(IsNumber = Time->QueryNumber(&Number, 0, FirstDelimiter ))) {
        return FALSE;
    }
    Hour = (USHORT)Number;

    if( SecondDelimiter == INVALID_CHNUM ) {
        if (!(IsNumber = Time->QueryNumber(&Number, FirstDelimiter+1))) {
            return FALSE;
        }
        Minute = (USHORT)Number;
        Second = 0;
    } else {
        if (!(IsNumber = Time->QueryNumber(&Number, FirstDelimiter+1, SecondDelimiter-FirstDelimiter-1))) {
            return FALSE;
        }
        Minute = (USHORT)Number;

        if (!(IsNumber = Time->QueryNumber(&Number, SecondDelimiter+1))) {
            return FALSE;
        }
        Second = (USHORT)Number;
    }

    //
    //  Check if the time is valid
    //
    if( ( Hour >= 24 ) || ( Minute >= 60 ) || ( Second >= 60 ) ) {
        return( FALSE );
    }

    TempSystemTime = _SystemTime;
    TempSystemTime.wHour = ( USHORT )Hour;
    TempSystemTime.wMinute = ( USHORT )Minute;
    TempSystemTime.wSecond = ( USHORT )Second;
    TempSystemTime.wMilliseconds = 0;
    return( this->Initialize( &TempSystemTime ) );
}


ULIB_EXPORT
BOOLEAN
TIMEINFO::QueryTime(
    OUT PWSTRING    FormattedTimeString
    ) CONST
/*++

Routine Description:

    This routine computes the correct time string for this TIMEINFO.

Arguments:

    FormattedTimeString - Returns a formatted time string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR buf[50];

    return( GetTimeFormatW( GetSystemDefaultLCID(),
                            TIME_NOSECONDS,
                            &_SystemTime,
                            NULL,
                            buf,
                            50 ) &&
            FormattedTimeString->Initialize(buf) );

}


NONVIRTUAL
ULIB_EXPORT
BOOLEAN
TIMEINFO::QueryDate(
    OUT PWSTRING    FormattedDateString
    ) CONST
/*++

Routine Description:

    This routine computes the correct date string for this TIMEINFO.

Arguments:

    FormattedTimeString - Returns a formatted date string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR buf[50];

    return( GetDateFormatW( GetSystemDefaultLCID(),
                            DATE_SHORTDATE,
                            &_SystemTime,
                            NULL,
                            buf,
                            50 ) != 0 &&
             FormattedDateString->Initialize(buf) );
}


BOOLEAN
ULIB_EXPORT
TIMEINFO::ConvertToUTC (
    )
/*++

Routine Description:

    This function converts the filetime (presumably it was
    previously local) to UTC.  The system time is left unchanged.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/

{
    FILETIME temp;
    BOOL b;

    b = LocalFileTimeToFileTime( &_FileTime, &temp );

    if (!b) {
        return FALSE;
    }

    _FileTime = temp;
    return TRUE;
}

BOOLEAN
ULIB_EXPORT
TIMEINFO::ConvertToLocal (
    )
/*++

Routine Description:

    This function converts the filetime (presumably it was
    previously UTC) to local time.  The system time is left unchanged.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/

{
    FILETIME temp;
    BOOL b;

    b = FileTimeToLocalFileTime( &_FileTime, &temp );

    if (!b) {
        return FALSE;
    }

    _FileTime = temp;
    return TRUE;
}



BOOLEAN
TIMEINFO::operator== (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is equal to the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is equal to the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {
    case 0:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator!= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is different than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is different than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 0:
        return( FALSE );

    default:
        return( TRUE );
    }
}



ULIB_EXPORT
BOOLEAN
TIMEINFO::operator< (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is smaller than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is smaller than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case -1:
        return( TRUE );

    default:
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
TIMEINFO::operator> (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is greter than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is greater than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 1:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator<= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is less or equal than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is less or equal than the information in the object
              received as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case -1:
    case  0:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator>= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is greater or equal than the time information received as
    parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is greater or equal than the information in the object
              received as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 0:
    case 1:
        return( TRUE );

    default:
        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\stream.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    stream.cxx

Abstract:

    This module contains the definitions of the member functions
    of STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "mbstr.hxx"
#include "wstring.hxx"
#include "stream.hxx"
#include "system.hxx"

extern "C" {
    #include <ctype.h>
}

DEFINE_CONSTRUCTOR ( STREAM, OBJECT );


STREAM::~STREAM (
    )

/*++

Routine Description:

    Destroy a STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
}



BOOLEAN
STREAM::ReadByte(
    OUT PBYTE   Data
    )

/*++

Routine Description:

    Reads one byte from the stream.

Arguments:

    Data    - Address of the variable that will contain the byte read.


Return Value:

    BOOLEAN - Returns TRUE if the read operation succeeded.


--*/


{
    ULONG   BytesRead;

    DebugPtrAssert( Data );
    if( Read( Data, sizeof( BYTE ), &BytesRead ) &&
        ( BytesRead == sizeof( BYTE ) ) ) {
        return( TRUE );
    } else {
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
STREAM::ReadLine(
            OUT PWSTRING    String,
                        IN  BOOLEAN     Unicode
        )

/*++

Routine Description:

    Reads a line from the stream.
    A line is sequence of WCHARs, terminated by '\n' or '\r\n'.
    The delimiters are not returned in the string, but are removed
    from the stream.

Arguments:

    String - Pointer to an initialized string object. This object
             will contain the string read from the stream, without the
             delimiters.

Return Value:

    BOOLEAN - Returns TRUE if the operation succeeded, and String points to
              a valid WSTRING.
              Returns FALSE otherwise.


--*/


{
    WCHAR           Wchar;
    CHNUM           StringSize;

    DebugPtrAssert( String );
    //
    //  Read a string from the stream
    //
    if( !ReadString( String, &_Delimiter , Unicode) ) {
        DebugAbort( "ReadString() failed \n" );
        return( FALSE );
    }
    //
    //  If a string was successfully read, then we have to remove the
    //  delimiter from the stream
    //
    if( !IsAtEnd() ) {
        //
        //  Read the delimiter
        //
        if( !ReadChar( &Wchar , Unicode) ) {
            DebugAbort( "ReadChar() failed \n" );
            return( FALSE );
        }
    }
    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    StringSize = String->QueryChCount();
    StringSize--;
    if( String->QueryChAt( StringSize ) == ( WCHAR )'\r' ) {
        String->Truncate( StringSize );
    }


/*
    if( !IsAtEnd() ) {
        //
        //  Read the first delimiter
        //
        if( !ReadChar( &Wchar, Unicode ) ) {
            DebugAbort( "ReadChar() failed \n" );
            return( FALSE );
        }
        if( Wchar == ( WCHAR )'\r' ) {
            //
            //  If the delimiter read was '\r' then there is a second
            //  delimiter ('\n') and we have to remove it from the stream
            //
            if( !IsAtEnd() ) {
                if( !ReadChar( &Wchar, Unicode ) ) {
                    DebugAbort( "ReadChar() failed \n" );
                    return( FALSE );
                }
            }
        }
    }
*/
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
STREAM::ReadMbLine(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
        )

/*++

Routine Description:


Arguments:


Return Value:


--*/


{

    BYTE    Char;


    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( StringSize );

    //
    //  Read a string from the stream
    //  Note that ReadMbString will remove the delimiter from the stream,
    //  in order to improve performance of FC and Find
    //
    if( !ReadMbString( String, BufferSize, StringSize, _MbDelimiter, ExpandTabs, TabExp ) ) {
        DebugAbort( "ReadMbString() failed \n" );
        return( FALSE );
    }


    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    if ( (*StringSize > 0 ) && (String[*StringSize-1] == '\r') ) {
        (*StringSize)--;
        String[*StringSize] = '\0';
    }

    return( TRUE );
}



ULIB_EXPORT
BOOLEAN
STREAM::ReadWLine(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
        )

/*++

Routine Description:


Arguments:


Return Value:


--*/


{

    WCHAR    Char;


    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( StringSize );

    //
    //  Read a string from the stream
    //  Note that ReadWString will remove the delimiter from the stream,
    //  in order to improve performance of FC and Find
    //
    if( !ReadWString( String, BufferSize, StringSize, _WDelimiter, ExpandTabs, TabExp ) ) {
        DebugAbort( "ReadWString() failed \n" );
        return( FALSE );
    }


    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    if ( (*StringSize > 0 ) && (String[*StringSize-1] == L'\r') ) {
        (*StringSize)--;
        String[*StringSize] = 0;
    }

    return( TRUE );
}



BOOLEAN
STREAM::Write(
    IN  PCBYTE  Buffer,
    IN  ULONG   BytesToWrite,
    OUT PULONG  BytesWritten
    )

/*++

Routine Description:

    Writes data to the stream.

Arguments:

    Buffer  - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write.

    BytesWritten - Points to the variable that will contain the number of
                   bytes actually written.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    if( QueryAccess() != READ_ACCESS ) {
        return( WriteFile( QueryHandle(),
                           (LPVOID)Buffer,
                           BytesToWrite,
                           BytesWritten,
                           NULL
                           ) != FALSE );
    } else {
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
STREAM::WriteByte(
    IN  BYTE    Data
    )

/*++

Routine Description:

    Writes one byte to the stream.

Arguments:

    Data - Byte to be written.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   BytesWritten = 0;

    if( Write( &Data, sizeof( BYTE ), &BytesWritten ) &&
      ( BytesWritten == sizeof( BYTE ) ) ) {
        return( TRUE );
    } else {
        return( FALSE );
    }
}


BOOLEAN
STREAM::WriteChar(
    IN  WCHAR   Char
    )

/*++

Routine Description:

    Writes one character to the stream, Doing wide character - to -
    multibyte conversion before writting

Arguments:

    Char    - Supplies character to be converted and written

Return Value:

    TRUE if character converted and written. FALSE otherwise


--*/


{

    BYTE    Buffer[ 2 ];    // FIX, FIX - can this be anything but 2?
    USHORT  BytesToWrite;
    ULONG   BytesWritten;
    BOOLEAN Result = FALSE;

    BytesToWrite = (USHORT)wctomb( (char *)Buffer, (wchar_t)Char );

    if ( BytesToWrite > 0 ) {

        Result = Write( Buffer, BytesToWrite, &BytesWritten );

        if ( BytesWritten != BytesToWrite) {
            Result =FALSE;
        }
    }

    return Result;
}



BOOLEAN
STREAM::WriteString(
    IN PCWSTRING String,
    IN CHNUM            Position,
    IN CHNUM            Length,
    IN CHNUM            Granularity
    )

/*++

Routine Description:

    Writes a string to the stream.

Arguments:

    String      - Pointer to a STRING object.
    Position    - Starting character within the string
    Length      - Number of characters to write
    Granularity - The maximum number of bytes to write at one time.
                    A value of 0 indicates to write it all at once.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   BytesWritten = 0;
    BOOLEAN Result       = TRUE;
    ULONG   Size, i, to_write;
    PBYTE   Buffer;

    DebugPtrAssert( String );
#if defined(DBCS)
    //
    // let convert unicode string to oem string with current console codepage.
    //
    String->SetConsoleConversions();
#endif // defined(DBCS)
    Buffer = (PBYTE)String->QuerySTR( Position, Length );

    if (Buffer == NULL) {
#if defined(DBCS)
        //
        // Reset/Back to conversion mode.
        //
        String->ResetConversions();
#endif // defined(DBCS)
        return FALSE;
    }

    Size = strlen((char *)Buffer);

    if (!Granularity) {
        Granularity = Size;
    }

    Result = TRUE;
    for (i = 0; Result && i < Size; i += Granularity) {

        to_write = min(Granularity, Size - i);

        Result = Write( Buffer + i, to_write, &BytesWritten ) &&
                 to_write == BytesWritten;
    }

#if defined(DBCS)
    //
    // Reset/Back to conversion mode.
    //
    String->ResetConversions();
#endif // defined(DBCS)

    FREE( Buffer );
    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\tmackmsg.cxx ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    tmackmsg.cxx

Abstract:

    Contains the implementation of the TM_AUTOCHECK_MESSAGE subclass.

Author:

    Daniel Chan (DanielCh) 11-11-96

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "windows.h"

#include "fmifs.h"
#include "setupdd.h"

#include "tmackmsg.hxx"


DEFINE_CONSTRUCTOR(TM_AUTOCHECK_MESSAGE, AUTOCHECK_MESSAGE);

TM_AUTOCHECK_MESSAGE::~TM_AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for TM_AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
TM_AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   attributes;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;

    RtlInitUnicodeString(&unicodeString, DD_SETUP_DEVICE_NAME_U);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenFile(&_handle,
                        FILE_GENERIC_WRITE,
                        &attributes,
                        &ioStatusBlock,
                        FILE_SHARE_READ,
                        FILE_OPEN);

    if (!NT_SUCCESS(status)) {
        _handle = NULL;
        DebugPrintTrace(("Unable to obtain a handle from setup device driver ( %08X )\n", status));
    }

    _base_percent = 0;
    _percent_divisor = 1;
    _kilobytes_total_disk_space = 0;
    _values_in_mb = 0;
}


VOID
TM_AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
    if (_handle) {
        NtClose(_handle);
        _handle = NULL;
    }
}


BOOLEAN
TM_AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine outputs the message to the debugger (if checked build).
    It also sends messages to the setup device driver.
    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR                buffer[256];
    DSTRING             display_string;
    SETUP_FMIFS_MESSAGE setupDisplayInfo;
    BOOLEAN             match = FALSE;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;
    ULONG               unit_bits = 0;

    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_FORMAT_REPORT_INFORMATION     chkdsk_report;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

    //
    // Log the output if necessary
    //
    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    //
    // Send the output to the debug port.
    //
    if( display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {

        if (MSG_HIDDEN_STATUS != GetMessageId()) {
            DebugPrint(buffer);
        }

        if (_handle) {

            switch (GetMessageId()) {
                case MSG_CHK_NTFS_CHECKING_FILES:       // first stage
                    _base_percent = 0;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_CHECKING_INDICES:     // second stage
                    _base_percent = 25;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_CHECKING_SECURITY:    // third stage
                    _base_percent = 50;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_RESETTING_USNS:       // optional fourth stage
                    _base_percent = 75;
                    _percent_divisor = 8;
                    break;

                case MSG_CHK_NTFS_RESETTING_LSNS:       // optional fifth stage
                    _base_percent = 87;
                    _percent_divisor = 8;
                    break;

                case MSG_PERCENT_COMPLETE:
                case MSG_PERCENT_COMPLETE2:
                    percent_info.PercentCompleted = va_arg(VarPointer, ULONG)/_percent_divisor+_base_percent;
                    setupDisplayInfo.FmifsPacket = (PVOID)&percent_info;
                    setupDisplayInfo.FmifsPacketType = FmIfsPercentCompleted;
                    match = TRUE;
                    break;

                case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB:
                    unit_bits = TOTAL_DISK_SPACE_IN_MB;

                    // fall thru

                case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB:
                    _values_in_mb = unit_bits;
                    _kilobytes_total_disk_space = va_arg(VarPointer, ULONG);

                    //
                    // drop through to fake a 100% completion as we are already at
                    // the very final statistics stage
                    //
                case MSG_CHK_VOLUME_CLEAN:
                    // This is the case when the drive is not dirty and autochk
                    // returns right away.  Setup needs a way to cancel/close the
                    // progress bar.
                    percent_info.PercentCompleted = 100;
                    setupDisplayInfo.FmifsPacket = (PVOID)&percent_info;
                    setupDisplayInfo.FmifsPacketType = FmIfsPercentCompleted;
                    match = TRUE;
                    break;

                case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB:
                    _values_in_mb |= BYTES_AVAILABLE_IN_MB;

                    // fall thru

                case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB:
                    chkdsk_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
                    chkdsk_report.KiloBytesAvailable = va_arg(VarPointer, ULONG);
                    setupDisplayInfo.FmifsPacket = (PVOID)&chkdsk_report;
                    setupDisplayInfo.FmifsPacketType = FmIfsFormatReport;
                    match = TRUE;
                    break;

                case MSG_DASD_ACCESS_DENIED:
                    setupDisplayInfo.FmifsPacket = NULL;
                    setupDisplayInfo.FmifsPacketType = FmIfsAccessDenied;
                    match = TRUE;
                    break;
            }
            if (match) {

                status = NtDeviceIoControlFile(_handle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ioStatusBlock,
                                               IOCTL_SETUP_FMIFS_MESSAGE,
                                               &setupDisplayInfo,
                                               sizeof(setupDisplayInfo),
                                               NULL,
                                               0);

                if (!NT_SUCCESS(status)) {
                    DebugPrintTrace(("Unable to send message to setup ( %08X )", status));
                }
            }

        }
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
TM_AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR            buffer[256];
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    //
    // Send the output to the debug port.
    //
    if( string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
    }

    return Default;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns TRUE to indicate it is in
    setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return TRUE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate no
    key has been pressed.

Arguments:

    None.

Return Value:

    FALSE   - No key is pressed within the time out period.

--*/
{
    // unreferenced parameters
    (void)(this);
    UNREFERENCED_PARAMETER( MsgId );
    UNREFERENCED_PARAMETER( TimeOutInSeconds );

    return FALSE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\stringar.cxx ===
/*++

Copyright (c) 1991      Microsoft Corporation

Module Name:

        stringar.cxx

Abstract:

        This module contains the implementation of the STRING_ARRAY class.
        STRING_ARRAY is used only to store strings, and it provides a
        method to sort the strings in ascending or descending order.
        The sort methods uses the qsort() function of the C run time
        library.

Author:

        Jaime F. Sasson (jaimes) 01-May-1991

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "wstring.hxx"
#include "stringar.hxx"

#if defined( __BCPLUSPLUS__ )

        #include <search.h>

#else

        extern "C" {
                #include <search.h>
        };

#endif // __BCPLUSPLUS__

CHNUM    STRING_ARRAY::_Position;
BOOLEAN  STRING_ARRAY::_Ascending;

DEFINE_EXPORTED_CONSTRUCTOR( STRING_ARRAY, ARRAY, ULIB_EXPORT );


ULIB_EXPORT
BOOLEAN
STRING_ARRAY::Initialize (
        IN CHNUM        Position,
        IN ULONG        Capacity,
        IN ULONG        CapacityIncrement
        )

/*++

Routine Description:

        Initialize a STRING_ARRAY object by setting it's internal state to s
        upplied or default values.

Arguments:

        Position                        - Supplies the position in each string to be used as
                                                  strating position when sorting the array.
        Capacity                        - Supplies the total number of WSTRINGs the
                                                  STRING_ARRAY can contain.
        CapacityIncrement       - Supplies the number of OBJECTs to make room for
                                                  when growing the STRING_ARRAY


Return Value:

        BOOLEAN - TRUE if the ARRAY is successfully initialized.

--*/

{
        _Position = Position;
        return( ARRAY::Initialize( Capacity, CapacityIncrement ) );
}



ULIB_EXPORT
BOOLEAN
STRING_ARRAY::Sort (
        BOOLEAN Ascending
        )

/*++

Routine Description:

        Sorts the array in ascending or descending order, depending
        on the parameter passed.

Arguments:

        Ascending - Specifies if the sort is to be performed in ascending (TRUE)
                                or descending (FALSE) order.

Return Value:

        BOOLEAN -

--*/

{
    _Ascending = Ascending;

    qsort( GetObjectArray(),
           ( size_t )QueryMemberCount(),
           sizeof( PWSTRING ),
           &STRING_ARRAY::StringCompare );

    return( TRUE );
}



int __cdecl
STRING_ARRAY::
StringCompare (
        IN const void * String1,
        IN const void * String2
        )

/*++

Routine Description:

        This function is used by qsort(), and it compares *String1
        and *String2. The string used as key depends on the value
        of _Ascending.
        If _Ascending == TRUE, then it uses *String1 as a key.
        If _Ascending == FALSE, then it uses *String2 as a key.

Arguments:

        *String1 - Pointer to a string object.

        *String2 - Pointer to a string object.

Return Value:

        Returns:

                if _Ascending == TRUE, then it returns
                        -1      if **String1 is less that **String2
                        0       if **String1 is equal to **String2
                        1       if **String1 is greater than **String2

                if _Ascending == FALSE, then it returns
                        -1      if **String2 is less that **String1
                        0       if **String2 is equal to **String1
                        1       if **String2 is greater than **String1

--*/

{
        PCWSTRING       St1;
        PCWSTRING       St2;
        CHNUM           Position1;
        CHNUM           Length1;
        CHNUM           Position2;
        CHNUM           Length2;
// char name[256];
// LONG result;

        if( _Ascending ) {
                St1 = *(PCWSTRING *)String1;
                St2 = *(PCWSTRING *)String2;
        } else  {
                St1 = *(PCWSTRING *)String2;
                St2 = *(PCWSTRING *)String1;
        }
        Length1 = St1->QueryChCount();
        Position1 = ( Length1 >= _Position ) ?  _Position : Length1;
        Length1 -= Position1;
        Length2 = St2->QueryChCount();
        Position2 = ( Length2 >= _Position ) ?  _Position : Length2;
        Length2 -= Position2;
/*
        St1->QueryApiString(name, 256);
        printf( "Length1 = %d, Position1 = %d, %s \n", Length1, Position1, name );
        St2->QueryApiString(name, 256);
        printf( "Length2 = %d, Position2 = %d, %s \n", Length2, Position2, name );
        result = St1->StringCompare( Position1,
                                                                 Length1,
                                                                 St2,
                                                                 Position2,
                                                                 Length2,
                                                                 CF_IGNORECASE );
        printf( "Result = %d \n", result );
        return( result );
*/
    return( St1->Stricmp( St2,
                          Position1,
                          Length1,
                          Position2,
                          Length2 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\substrng.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SUB_STRING

Abstract:

    Implementation of the SUB_STRING class.

Author:

    Stve Rowe (stever)

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "substrng.hxx"


#if DBG==1
	#define SUBSTRING_SIGNATURE	0xADDCACA1
#endif




DEFINE_CONSTRUCTOR( SUB_STRING, GENERIC_STRING );

DEFINE_CAST_MEMBER_FUNCTION( SUB_STRING );

VOID
SUB_STRING::Construct (
    )

/*++

Routine Description:

    Construct a SUBS_TRING by initializing it's internal state.

Arguments:

    None.

Return Value:

    None.

--*/

{
	_BaseString	= NULL;

#if DBG==1
	_Signature	 = SUBSTRING_SIGNATURE;
	_Initialized = FALSE;
#endif
}

SUB_STRING::~SUB_STRING ()

{
	Destroy();
}

VOID
SUB_STRING::Destroy (
    )

/*++

Routine Description:

	Detaches this substring from the chain (if it belongs to one).

Arguments:

	none

Return Value:

	none

--*/

{
	if ( _BaseString != NULL ) {
		//
		//	We extract ourselves from the substring chain
		//
		if (_Previous) {

			//
			//	Update the previous in the chain
			//
			DebugAssert( _Previous->_Signature == SUBSTRING_SIGNATURE );
			_Previous->_Next = _Next;

		}

		if ( _Next ) {

			//
			//	Update the next in the chain
			//
			DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
			_Next->_Previous = _Previous;

		}

	}

	//
	//	Forget everything about our previous life
	//
	_BaseString 		= NULL;
	_CountOfChars		= 0;
	_StartingPosition	= 0;
	_Next = _Previous	= NULL;

#if DBG==1
	_Initialized = FALSE;
#endif

}

BOOLEAN
SUB_STRING::InitializeChainHead (
	IN	PGENERIC_STRING BaseString
	)

/*++

Routine Description:

	Initializes the substring with a base string. This should be called
	only for the head of the substring chain.

Arguments:

	BaseString		- Supplies pointer to base string

Return Value:

	TRUE

--*/

{
	DebugPtrAssert( BaseString );

	DebugAssert( _BaseString == NULL );

	Destroy();

	GENERIC_STRING::Initialize();

	_BaseString = BaseString;

#if DBG==1
	_Initialized = TRUE;
#endif

	return TRUE;

}

BOOLEAN
SUB_STRING::InitializeChainNode (
	IN OUT	PSUB_STRING	SubString,
	IN		CHNUM		Position,
	IN		CHNUM		Length
    )

/*++

Routine Description:

	Links this substring to a substring chain.

	This method should ONLY be used by a string class, who knows about string
	chains.

Arguments:

	SubString		- Supplies pointer to a substring in the chain.
	Position		- Supplies the starting position value for this substring.
					  Note that this is relative to the BASE string.
	Length			- Supplies Number of Characters in substring.

Return Value:

	TRUE

--*/

{

	//
	//	It is a bug to call this method on a substring that already belongs
	//	to a chain.
	//
	DebugAssert( SubString && (SubString->_Signature == SUBSTRING_SIGNATURE) );
	DebugAssert( _BaseString == NULL );

	Destroy();

	GENERIC_STRING::Initialize();

	//
	//	Initialize our pointers and counters
	//
	_StartingPosition	= Position;
	_CountOfChars		= Length;

	//
	//	Add ourselves to the substring chain
	//
	_BaseString = SubString->_BaseString;
	_Next		= SubString->_Next;
	_Previous	= SubString;

	SubString->_Next = this;

	if (_Next) {
		DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
		_Next->_Previous = this;
	}

#if DBG==1
	_Initialized = TRUE;
#endif

	return TRUE;

}

PBYTE
SUB_STRING::GetInternalBuffer (
	IN	CHNUM	Position
	) CONST

/*++

Routine Description:

	Gets pointer to buffer containing the string.

Arguments:

	none

Return Value:

	Pointer to the buffer

--*/
{

	DebugAssert( Position < _CountOfChars );

	return _BaseString->GetInternalBuffer( _StartingPosition + Position );

}

BOOLEAN
SUB_STRING::IsChAt (
	IN		WCHAR	Ch,
    IN      CHNUM   Position
    ) CONST

/*++

Routine Description:

    Finds out if a certain character is at the specified position.

Arguments:

    Ch          -   Supplies the character to llok for
    Position    -   Supplies the position to look at

Return Value:

    TRUE if the character is at the specified position

--*/

{
	DebugAssert( _StartingPosition + Position < _CountOfChars );

	return ( QueryChAt( Position ) == Ch );

}

BOOLEAN
SUB_STRING::MakeNumber (
	OUT PLONG	Number,
    IN  CHNUM   Position,
    IN  CHNUM   Length
	) CONST

/*++

Routine Description:

    Converts the string to a number.

Arguments:

	Number		-	Pointer to returned number
    Position    -   Supplies the starting position
    Length      -   Supplies the length


Return Value:

	TRUE	if made a valid number
	FALSE	otherwise

--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->MakeNumber( Number, _StartingPosition + Position, Length );
}

ULONG
SUB_STRING::QueryByteCount (
	IN	CHNUM	Position,
	IN	CHNUM	Length
	) CONST

/*++

Routine Description:

	Gets the number of bytes in the buffer containing this substring

Arguments:

    Position    -   Supplies the starting position
    Length      -   Supplies the length


Return Value:

	Number of bytes in buffer.

--*/

{

	GetValidLength( Position, &Length );

	return _BaseString->QueryByteCount( _StartingPosition + Position, Length );
}

CHNUM
SUB_STRING::QueryChCount (
    ) CONST

/*++

Routine Description:

	Returns the number of characters in this substring.

Arguments:

    None.

Return Value:

	The number of characters in this substring.

--*/

{
	DebugAssert( _Initialized );
	return _CountOfChars;
}

WCHAR
SUB_STRING::QueryChAt(
    IN CHNUM    Position
    ) CONST

/*++

Routine Description:

    returns the character at the supplied position.

Arguments:

    Position - Supplies the character position.

Return Value:

	Returns the character at the supplied position.

--*/

{
	DebugAssert( Position < _CountOfChars );

	if ( Position < _CountOfChars ) {
		return _BaseString->QueryChAt( _StartingPosition + Position );
	} else {
		return INVALID_CHAR;
	}
}


PGENERIC_STRING
SUB_STRING::QueryGenericString(
	IN	CHNUM		Position,
	IN	CHNUM		Length
    ) CONST

/*++

Routine Description:

	Obtains a string off this substring

Arguments:

    Position - Supplies the character position.
	Length	 - Supplies the length of the substring

Return Value:

    Pointer to the string

--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->QueryGenericString( _StartingPosition + Position, Length );

}

PSTR
SUB_STRING::QuerySTR(
	IN		CHNUM	Position,
	IN		CHNUM	Length,
	IN OUT	PSTR	Buffer,
	IN		ULONG	BufferSize
	) CONST



/*++

Routine Description:

	Obtains a null-terminated multibyte string ( PSTR )

Arguments:

	Position	-	Supplies starting position
	Length		-	Supplies length (in characters) of substring desired
	Buffer		-	Supplies optional pointer to buffer
	BufferSize	-	Supplies length of the buffer (in bytes)

Return Value:

	Pointer to PSTR


--*/

{

	GetValidLength( Position, &Length );

	return _BaseString->QuerySTR( _StartingPosition + Position,
								  Length,
								  Buffer,
								  BufferSize );


}

PSUB_STRING
SUB_STRING::QuerySubString(
	IN	CHNUM		Position,
	IN	CHNUM		Length,
	OUT PSUB_STRING SubString
    )

/*++

Routine Description:

    Obtains a substring of this string

Arguments:

	Position	- Supplies the character position.
	Length		- Supplies the length of the substring
	SubString	- Supplies optional pointer to SUB_STRING object

Return Value:

    Pointer to the substring

--*/

{
	GetValidLength( Position, &Length );

	if (SubString == NULL) {
		SubString = NEW SUB_STRING;
	}

	if (SubString) {

		SubString->InitializeChainNode( this, _StartingPosition + Position, Length );

	}

	return SubString;

}

PWSTR
SUB_STRING::QueryWSTR (
	IN		CHNUM	Position,
	IN		CHNUM	Length,
	IN OUT	PWSTR	Buffer,
    IN      ULONG   BufferSize,
    IN      BOOLEAN ForceNull
	) CONST

/*++

Routine Description:

	Obtains a null-terminated wide	character string ( PWSTR )

Arguments:

	Position	-	Supplies starting position
	Length		-	Supplies length (in characters) of substring desired
	Buffer		-	Supplies optional pointer to buffer
    BufferSize  -   Supplies length of the buffer (in bytes)
    ForceNull   -   Supplies a flag which indicates, if TRUE, that the
                    returned string must be null-terminated.  If this
                    flag is not FALSE, QueryWSTR will return as much
                    of the string as fits in the buffer; if it is TRUE,
                    QueryWSTR will return as much as fits in the buffer
                    minus one character for the terminating NULL.


Return Value:

	Pointer to PWSTR


--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->QueryWSTR( _StartingPosition + Position,
								   Length,
								   Buffer,
                                   BufferSize,
                                   ForceNull );

}

CHNUM
SUB_STRING::Strchr (
	IN WCHAR	 Char,
	IN CHNUM	 Position,
	IN CHNUM	 Length
    ) CONST

/*++

Routine Description:

    Searches for first occurence of a character in the string

Arguments:

    Char        -   Supplies character to match
    Position    -   Supplies index of first character where search
					will start.
	Length		-	Supplies length of the subsequence in which to
					search.

Return Value:


    Index within the string where the character was found.

--*/

{
	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strchr( Char,
								_StartingPosition + Position,
								Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;

}

LONG
SUB_STRING::Strcmp (
	IN PCGENERIC_STRING		GenericString
    ) CONST

/*++

Routine Description:

    Does a case sensitive string compare.

Arguments:

	GenericString - Supplies a pointer to string to compare against

Return Value:

    == 0    - strings are equal
    <0      - this string is less then StringToCompare
    >0      - this string is greater then StringToCompare

--*/

{
    return _BaseString->StringCompare( _StartingPosition,
                                       _CountOfChars,
                                       GenericString,
                                       0,
                                       GenericString->QueryChCount() );
}

CHNUM
SUB_STRING::Strcspn (
	IN PCGENERIC_STRING		GenericString,
	IN CHNUM				Position,
	IN CHNUM				Length
	) CONST

/*++

Routine Description:

	Returns index of the first character that belongs to the set of
	characters provided in the generic string.

Arguments:

   GenericString	- Supplies the string to match from
   Position 		- Supplies position where match should start
   Length			- Supplies the length of the subsequence in which to
					  search.


Return Value:

	Index of the character that matched.

--*/

{
	CHNUM Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strcspn( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;

}

LONG
SUB_STRING::Stricmp (
	IN PCGENERIC_STRING	GenericString
    ) CONST

/*++

Routine Description:

    Does a case insensitive string compare.

Arguments:

    String - Supplies a pointer to string to compare against

Return Value:

    == 0    - strings are equal
    <0      - this string is less then StringToCompare
    >0      - this string is greater then StringToCompare

--*/

{
    return _BaseString->StringCompare( _StartingPosition,
                                       _CountOfChars,
                                       GenericString,
                                       0,
                                       GenericString->QueryChCount(),
									   COMPARE_IGNORECASE );
}

LONG
SUB_STRING::StringCompare (
	IN CHNUM			Position1,
	IN CHNUM			Length1,
	IN PCGENERIC_STRING GenericString2,
	IN CHNUM			Position2,
	IN CHNUM			Length2,
	IN USHORT			CompareFlags
    ) CONST

/*++

Routine Description:

    Compares this string with another one

Arguments:

    Position1       -   Supplies Index within this string
    Length1         -   Supplies Length within this string
	GenericString2	-	Supplies other string
    Position2       -   Supplies index within other string
    Length2         -   Supplies length of other string
    CompareFlags    -   Supplies compare flags

Return Value:

    < 0 if this string lexically less than other
      0 if both strings the same
    > 0 if other string lexically more than this one

--*/
{
	GetValidLength( Position1, &Length1 );

	return _BaseString->StringCompare( _StartingPosition + Position1,
									   Length1,
									   GenericString2,
									   Position2,
									   Length2,
									   CompareFlags );
}

CHNUM
SUB_STRING::Strrchr (
	IN WCHAR	Char,
	IN CHNUM	Position,
	IN CHNUM	Length
    ) CONST

/*++

Routine Description:

    Finds last occurrence of the character to match in the string.

Arguments:

	Char		- Supplies the character to match
	Position	- Supplies the starting position
	Length		- Supplies length of subsequence in which to search.

Return Value:

    Index of last occurence of the character

--*/

{
	CHNUM Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strrchr( Char,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}

CHNUM
SUB_STRING::StrLen (
    ) CONST

/*++

Routine Description:

	Returns the number of characters in this substring.

Arguments:

    None.

Return Value:

	The number of characters in this substring.

--*/

{
	return _CountOfChars;
}

CHNUM
SUB_STRING::Strspn (
	IN PCGENERIC_STRING		GenericString,
	IN CHNUM				Position,
	IN CHNUM				Length
    ) CONST

/*++

Routine Description:

    Returns index of the first character in the string that
    does not belong to the set of characters in the string to match.

Arguments:

    String   -   Supplies pointer to string to match from
    Position -   Supplies initial position to start search
    Length   -   Supplies length.

Return Value:

    Index of the first character that does not belong to the set
    of characters in the string passed.

--*/

{
	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strspn( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}

CHNUM
SUB_STRING::Strstr (
	IN PCGENERIC_STRING	GenericString,
	IN CHNUM			Position,
	IN CHNUM			Length
    ) CONST

/*++

Routine Description:

	Returns the index of the first occurrence of a string within us.

Arguments:

	GenericString	- Supplies pointer to string to match from
	Position		- Supplies initial position to start search
	Length			- Supplies the length of the subsequence in which to
					  search.

Return Value:

	Index of first occurence of the string

--*/

{

	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strstr( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}


BOOLEAN
SUB_STRING::Replace (
	IN	PCGENERIC_STRING	String2,
	IN	CHNUM				Position,
	IN	CHNUM				Length,
	IN	CHNUM				Position2,
	IN	CHNUM				Length2
	)

/*++

Routine Description:

	Illegal method in SUB_STRING

Arguments:

    String2     -   Supplies pointer to other string
	Position	-	Suplies the starting position to start copy
	Lengh		-	Supplies the length of the portion to replace
    Position2   -   Supplies position in other string
    Length2     -   Supplies length to copy

Return Value:

	FALSE

--*/

{
	UNREFERENCED_PARAMETER( String2 );
	UNREFERENCED_PARAMETER( Position );
	UNREFERENCED_PARAMETER( Length );
	UNREFERENCED_PARAMETER( Position2 );
	UNREFERENCED_PARAMETER( Length2 );

	DebugAssert( FALSE );
	return FALSE;
}

BOOLEAN
SUB_STRING::SetChAt(
	IN		WCHAR	Char,
	IN		CHNUM	Position,
	IN		CHNUM	Length
    )

/*++

Routine Description:

	Illegal method in SUB_STRING

Arguments:

	Char		-	Supplies the character to set.
	Position	-	Supplies the character position to set.
	Length		-	Supplies the number of characters to set.

Return Value:

	FALSE

--*/

{
	UNREFERENCED_PARAMETER( Char );
	UNREFERENCED_PARAMETER( Position );
	UNREFERENCED_PARAMETER( Length );

	DebugAssert( FALSE );
	return FALSE;

}

BOOLEAN
SUB_STRING::Update (
	IN	CHNUM	Length
    )

/*++

Routine Description:

	Updates a substring. When the length of the base string changes, the
	new length has to be propagated along the substring chain, so that
	substrings are maintained up-to-date.  Each substring is responsible
	for propagating the new length to its successors in the chain.


Arguments:

	Length	-	Supplies the new length of the base string


Return Value:

    TRUE if updated, FALSE otherwise.

--*/

{

	//
	//	Set the new starting position
	//
	_StartingPosition = min ( _StartingPosition, Length - 1);

	//
	//	Set the new length
	//
	if ( _StartingPosition + _CountOfChars > Length ) {

		_CountOfChars = Length - _StartingPosition;
    }

	//
	//	Propagate along the chain
	//
	if ( _Next ) {

		DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
		return _Next->Update( Length );
	}

    return TRUE;

}


/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DYNAMIC_SUB_STRING

Abstract:

    Implementation of the DYNAMIC_SUB_STRING class.

Author:

    Stve Rowe (stever)

Environment:

    ULIB, User Mode

--*/

DEFINE_CONSTRUCTOR( DYNAMIC_SUB_STRING, SUB_STRING);

VOID
DYNAMIC_SUB_STRING::Construct (
    )

{
	UNREFERENCED_PARAMETER( (void)this );
}

BOOLEAN
DYNAMIC_SUB_STRING::Copy (
	IN PCGENERIC_STRING GenericString
    )
/*++

Routine Description:

	Copies one substring to another. The size of the substring changes

Arguments:

    None.

Return Value:

    TRUE if copied, false otherwise

--*/

{

	DebugPtrAssert( GenericString );

	if	( GetBaseString()->Replace( GenericString,
									QueryStartingPosition(),
									QueryChCount(),
									0,
									GenericString->QueryChCount() )) {
		//
		//	Update the length
		//
		SetChCount( GenericString->QueryChCount());

		return TRUE;
	}

	return FALSE;
}

BOOLEAN
DYNAMIC_SUB_STRING::SetChAt(
	IN		WCHAR	Char,
	IN		CHNUM	Position,
	IN		CHNUM	Length
    )

/*++

Routine Description:

	Sets the specified number of characters, starting at a certain
	position, with the supplied character.

Arguments:

	Char		-	Supplies the character to set.
	Position	-	Supplies the character position to set.
	Length		-	Supplies the number of characters to set.

Return Value:

	BOOLEAN - Returns TRUE if the characters were succesfully set.

--*/

{

	GetValidLength( Position, &Length );

	return GetBaseString()->SetChAt( Char,
									 QueryStartingPosition() + Position,
									 Length );

}

CHNUM
DYNAMIC_SUB_STRING::Truncate(
	IN		CHNUM	Position
    )

/*++

Routine Description:

	Truncates the substring at the specified position. The corresponding
	part of the base string is chopped out.

Arguments:

	Position	-	Supplies the character position where truncation is to
					occur.

Return Value:

	CHNUM	- Returns new size of the substring

--*/

{


	DebugAssert( Position < QueryStartingPosition() + QueryChCount() );

	if	( GetBaseString()->Replace( NULL,
									QueryStartingPosition() + Position,
									QueryChCount() - Position,
									0,
									0 )) {
		//
		//	Update the length
		//
		SetChCount( Position );

	}

	return QueryChCount();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\attrcol.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        attrcol.cxx

Abstract:

        This module contains the implementation for the
        NTFS_ATTRIBUTE_COLUMNS class, which models
        the attribute columns of an attribute definition table
        file for an NTFS volume.

Author:

        Norbert P. Kusters (norbertk) 19-Aug-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"
#include "attrcol.hxx"

#include "attrib.hxx"


DEFINE_CONSTRUCTOR( NTFS_ATTRIBUTE_COLUMNS, OBJECT );

NTFS_ATTRIBUTE_COLUMNS::~NTFS_ATTRIBUTE_COLUMNS(
    )
/*++

Routine Description:

    Destructor for NTFS_ATTRIBUTE_COLUMNS.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_ATTRIBUTE_COLUMNS::Construct(
    )
/*++

Routine Description:

    This routine initializes the class to an initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _columns = NULL;
    _num_columns = 0;
}


VOID
NTFS_ATTRIBUTE_COLUMNS::Destroy(
    )
/*++

Routine Description:

    This routine returns the class to an initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_columns);
    _num_columns = 0;
}


BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::Initialize(
    IN  ULONG                           NumberOfColumns,
    IN  PCATTRIBUTE_DEFINITION_COLUMNS  Columns
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    NumberOfColumns - Supplies the number of columns.
    Columns         - Supplies 'NumberOfColumns' columns to
                        initialize to.  This parameter is optional.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _num_columns = NumberOfColumns;

    // NOTE: use old new for vectors.
    if (!(_columns = NEW ATTRIBUTE_DEFINITION_COLUMNS[_num_columns])) {
        Destroy();
        return FALSE;
    }

    if (Columns) {
        memcpy(_columns, Columns,
               (UINT) (NumberOfColumns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS)));
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::Read(
    IN OUT  PNTFS_ATTRIBUTE AttributeDefinitionTableData
    )
/*++

Routine Description:

    This routine reads in the attribute definition columns from disk.

Arguments:

    AttributeDefinitionTableData    - Supplies the data attribute of the
                                        attribute definition table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   bytes_to_read;
    ULONG   bytes_read;

    bytes_to_read = _num_columns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS);

    return AttributeDefinitionTableData->Read(_columns,
                                              0,
                                              bytes_to_read,
                                              &bytes_read) &&
           (bytes_read == bytes_to_read);
}


BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::QueryIndex(
    IN  ATTRIBUTE_TYPE_CODE AttributeCode,
    OUT PULONG              Index
    ) CONST
/*++

Routine Description:

    This routine computes the location of the column for
    'AttributeCode' and sets the internal pointer to that
    column.  This makes it so that subsequent 'Query' operations
    are for the attribute type of 'AttributeCode'.

Arguments:

    AttributeCode   - Supplies the attribute type code to search for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;

    DebugAssert(Index);

    for (i = 0; i < _num_columns; i++) {
        if (_columns[i].AttributeTypeCode == AttributeCode) {
            *Index = i;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\inc\fsrtlp.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fsrtlp.h

Abstract:

    This header file is included by largemcb.h, and is used to stub out the
    kernel-only subroutine calls, as well as declare types and functions
    provided by the MCB package.

Author:

    Matthew Bradburn (mattbr) 19-August-95

Environment:

    ULIB, User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define NTKERNELAPI

typedef ULONG ERESOURCE, *PERESOURCE;
typedef ULONG FAST_MUTEX, *PFAST_MUTEX;
typedef ULONG KEVENT, *PKEVENT;
typedef ULONG KMUTEX, *PKMUTEX;

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} POOL_TYPE;

typedef ULONG VBN, *PVBN;
typedef ULONG LBN, *PLBN;
typedef LONGLONG LBN64, *PLBN64;

#define PAGED_CODE()                    /* nothing */
#define DebugTrace(a, b, c, d)          /* nothing */
#define ExInitializeFastMutex(a)        /* nothing */
#define ExAcquireFastMutex(a)           /* nothing */
#define ExReleaseFastMutex(a)           /* nothing */
#define ExAcquireSpinLock(a, b)         /* nothing */
#define ExReleaseSpinLock(a, b)         /* nothing */

#define ExIsFullZone(a)                    FALSE
#define ExAllocateFromZone(a)              ((PVOID)1)
#define ExIsObjectInFirstZoneSegment(a, b) TRUE
#define ExFreeToZone(a, p)                 /* nothing */

#define try_return(S)       { S; goto try_exit; }

extern
PVOID
MemAlloc(
    IN  ULONG   Size
    );

extern
PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    );

extern
VOID
MemFree(
    IN  PVOID   Addr
    );

#define ExAllocatePool(type, size)      MemAlloc(size)
#define FsRtlAllocatePool(type, size)   MemAllocOrRaise(size)
#define ExFreePool(p)                   MemFree(p)

//
//  Large Integer Mapped Control Blocks routines, implemented in LargeMcb.c
//
//  An LARGE_MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//
//  Current the structure consists of the following.
//      PVOID
//      ULONG
//      ULONG
//      POOL_TYPE (enumerated type)
//      PVOID
//
//  We will round the structure up to a quad-word boundary.
//

typedef struct _LARGE_MCB {
#ifdef _WIN64
    ULONG Opaque[ 8 ];
#else
    ULONG Opaque[ 6 ];
#endif
} LARGE_MCB;
typedef LARGE_MCB *PLARGE_MCB;

NTKERNELAPI
VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Lbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    OUT PLONGLONG Lbn OPTIONAL,
    OUT PLONGLONG SectorCountFromLbn OPTIONAL,
    OUT PLONGLONG StartingLbn OPTIONAL,
    OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN ULONG RunIndex,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn,
    OUT PLONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Amount
    );


//
//  Mapped Control Blocks routines, implemented in Mcb.c
//
//  An MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//

typedef struct _MCB {
    ULONG Opaque[ 4 + (sizeof(PKMUTEX)+3)/4 ];
} MCB;
typedef MCB *PMCB;

NTKERNELAPI
VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\attrdef.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    attrdef.cxx

Abstract:

    This module contains the member function implementation for
    the NTFS_ATTRIBUTE_DEFINITION_TABLE class, which models
    the attribute definition table file for an NTFS volume.

Author:

    Bill McJohn (billmc) 17-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "attrdef.hxx"
#include "ifssys.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "attrcol.hxx"

// This is the initial table for NT 4.0:

CONST ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions_1[$EA_DATA+1] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(STANDARD_INFORMATION), 0},                  // Minimum length
    {sizeof(STANDARD_INFORMATION), 0}},                 // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    {sizeof(FILE_NAME), 0},                             // Minimum length
    {sizeof(FILE_NAME) + (255 * sizeof(WCHAR)), 0}},    // Maximum length

    {{'$','V','O','L','U','M','E','_','V','E','R','S','I','O','N'},
    $VOLUME_VERSION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_VERSION), 0},                        // Minimum length
    {sizeof(VOLUME_VERSION), 0}},                       // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {2,0},                                              // Minimum length
    {256,0}},                                           // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_INFORMATION),0},                     // Minimum length
    {sizeof(VOLUME_INFORMATION),0}},                    // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','S','Y','M','B','O','L','I','C','_','L','I','N','K'},
    $SYMBOLIC_LINK,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(EA_INFORMATION), 0},                        // Minimum length
    {sizeof(EA_INFORMATION), 0}},                       // Maximum length

    {{'$','E','A',},
    $EA_DATA,                                           // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0,0}}                                              // Maximum length
};

// This is the initial table for NT 5.0 (W2K):

CONST ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions_2[] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(STANDARD_INFORMATION), 0},                  // Minimum length
    {sizeof(STANDARD_INFORMATION2), 0}},                // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    {sizeof(FILE_NAME), 0},                             // Minimum length
    {sizeof(FILE_NAME) + (255 * sizeof(WCHAR)), 0}},    // Maximum length

    {{'$','O','B','J','E','C','T','_','I','D'},
    $OBJECT_ID,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0, 0},                                             // Minimum length
    {256, 0}},                                          // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {2,0},                                              // Minimum length
    {256,0}},                                           // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_INFORMATION),0},                     // Minimum length
    {sizeof(VOLUME_INFORMATION),0}},                    // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','R','E','P','A','R','S','E','_','P','O','I','N','T'},
    $REPARSE_POINT,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {16*1024,0}},                                       // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(EA_INFORMATION), 0},                        // Minimum length
    {sizeof(EA_INFORMATION), 0}},                       // Maximum length

    {{'$','E','A'},
    $EA_DATA,                                           // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{'$','L','O','G','G','E','D','_','U','T','I','L','I','T','Y','_','S','T','R','E','A','M'},
    $LOGGED_UTILITY_STREAM,                             // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0,0}}                                              // Maximum length
};

CONST NumberOfNtfsAttributeDefinitions_1 = sizeof(NtfsAttributeDefinitions_1)/
                                           sizeof(ATTRIBUTE_DEFINITION_COLUMNS);
CONST NumberOfNtfsAttributeDefinitions_2 = sizeof(NtfsAttributeDefinitions_2)/
                                           sizeof(ATTRIBUTE_DEFINITION_COLUMNS);


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_ATTRIBUTE_DEFINITION_TABLE::~NTFS_ATTRIBUTE_DEFINITION_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_ATTRIBUTE_DEFINITION_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) this;
}


VOID
NTFS_ATTRIBUTE_DEFINITION_TABLE::Destroy(
    )
/*++

Routine Description:

    Worker function for destruction/reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) this;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      UCHAR                   VolumeMajorVersion
    )
/*++

Routine Description:

    This method initializes an Attribute Definition Table object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Attribute Definition Table.

Arguments:

    Drive           -- Supplies the drive on which the segment resides.
    Mft             -- Supplies the volume MasterFile Table.
    ClusterFactor   -- Supplies the volume Cluster Factor.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    _volume_major_version = VolumeMajorVersion;

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( ATTRIBUTE_DEF_TABLE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats a Attribute Definition Table File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.
    VolumeBitmap        -- supplies the bitmap for the volume on
                            which this object resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN FirstLcn;
    ULONG Size;
    ULONG NumberOfClusters;
    ULONG BytesWritten;
    ULONG ClusterSize;

    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // The Attribute Definition Table has a data attribute whose value
    // consists of the attribute definition table.  The initial table,
    // with the system-defined attributes, is copied into this attribute.

    Size = QueryDefaultSize();

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    NumberOfClusters = Size/ClusterSize;

    if( Size % ClusterSize ) {

        NumberOfClusters += 1;
    }

    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.Resize( NumberOfClusters, VolumeBitmap ) ||
        !DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    Size,
                                    Size,
                                    $DATA ) ||
        !DataAttribute.Write( (PVOID) (_volume_major_version >= 2) ?
                                        NtfsAttributeDefinitions_2 :
                                        NtfsAttributeDefinitions_1,
                                0,
                                Size,
                                &BytesWritten,
                                VolumeBitmap ) ||
        BytesWritten != Size ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::VerifyAndFix(
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS     AttributeDefTable,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN OUT  PNTFS_INDEX_TREE            RootIndex,
       OUT  PBOOLEAN                    Changes,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      BOOLEAN                     SilentMode
    )
/*++

Routine Description:

    This routine compares the given attribute definition table with
    the one contained in this file's DATA attribute and ensures
    that both are the same.  The in-memory version will override the
    on-disk version.

Arguments:

    AttributeDefTable   - Supplies the in-memory version of the table.
    VolumeBitmap        - Supplies the volume bitmap.
    BadClusters         - Supplies the list of bad clusters.
    RootIndex           - Supplies the root index.
    Changes             - Returns whether or not changes were made.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.
    SilentMode          - Suppresses changes message as errors is expected

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE                  data_attribute;
    BOOLEAN                         error;
    ULONG                           num_columns;
    ULONG                           value_length;
    PCATTRIBUTE_DEFINITION_COLUMNS  mem_columns;
    PATTRIBUTE_DEFINITION_COLUMNS   disk_columns;
    ULONG                           num_bytes;
    NTFS_EXTENT_LIST                extent_list;
    BOOLEAN                         ErrorInAttribute;

    *Changes = FALSE;

    mem_columns = AttributeDefTable->GetColumns(&num_columns);
    value_length = num_columns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS);

    if (!(disk_columns = new ATTRIBUTE_DEFINITION_COLUMNS[num_columns])) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        *Changes = TRUE;

        if (!extent_list.Initialize(0, 0) ) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE_ARRAY(disk_columns);
            return FALSE;
        }

        if (!data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extent_list,
                                       0,
                                       0,
                                       $DATA)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE_ARRAY(disk_columns);
            return FALSE;

        }
    }

    error = FALSE;
    if (value_length != data_attribute.QueryValueLength()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_DEF_TABLE_LENGTH,
                     "%I64x%x",
                     data_attribute.QueryValueLength().GetLargeInteger(),
                     value_length);
        error = TRUE;
    } else if (!data_attribute.Read(disk_columns, 0, value_length, &num_bytes)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_ATTR_DEF_TABLE);

        error = TRUE;
    } else if (num_bytes != value_length) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_ATTR_DEF_TABLE);

        error = TRUE;
    } else if (memcmp(mem_columns, disk_columns, value_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_DEF_TABLE);

        error = TRUE;
    }

    if (error) {

        *Changes = TRUE;

        if (!SilentMode) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_ATTR_DEF);
        }

        if (FixLevel != CheckOnly) {
            if (!data_attribute.MakeNonresident(VolumeBitmap) ||
                !data_attribute.Resize(value_length, VolumeBitmap) ||
                !data_attribute.Write(mem_columns, 0, value_length, &num_bytes,
                                      VolumeBitmap) ||
                value_length != num_bytes) {

                if (!data_attribute.RecoverAttribute(VolumeBitmap, BadClusters) ||
                    !data_attribute.Write(mem_columns, 0, value_length,
                                          &num_bytes, VolumeBitmap) ||
                    value_length != num_bytes) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
                    DELETE_ARRAY(disk_columns);
                    return FALSE;
                }
            }
        }

        if (!data_attribute.InsertIntoFile(this, VolumeBitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
            DELETE_ARRAY(disk_columns);
            return FALSE;
        }
    }

    if (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
        DELETE_ARRAY(disk_columns);
        return FALSE;
    }

    DELETE_ARRAY(disk_columns);
    return TRUE;
}

ULONG
NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultSize(
    )
/*++

Routine Description:

    This method returns the size of the default upcase table.

Arguments:

    None.

Return Value:

    The size of the default upcase table;

--*/
{
    if (_volume_major_version >= 2)
        return (sizeof( NtfsAttributeDefinitions_2 ));
    else
        return( sizeof( NtfsAttributeDefinitions_1 ) );
}

ULONG
NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultMaxSize(
    )
/*++

Routine Description:

    This method returns the maximum size of the default upcase table.

Arguments:

    None.

Return Value:

    The maximum size of the default upcase table;

--*/
{
    return max(sizeof( NtfsAttributeDefinitions_1 ),
               sizeof( NtfsAttributeDefinitions_2 ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\i386\dosttr.c ===
#include <windows.h>

#define MaxCallStack		20

VOID
DoStackTrace( DWORD callstack[] )

/*++

Routine Description:

	Backtrace a stack recording all the return addresses in the supplied
	structure.	The mips version of this code does nothing.

Arguments:

	DWORD Callstack[]	- The array in which the addresses are stored.

Return Value:

	None.

--*/

{

#pragma message( "Including the stack trace!" )

	int i;
	DWORD bytes;
	HANDLE hProcess;
	DWORD dwEbp;

	hProcess = GetCurrentProcess();

	//
	// Get the current contents of the control registers...
	//
	_asm {
	
		mov dwEbp, ebp

	}

	//
	// Ignore the entry on the stack for this procedure...
	//
	if( !ReadProcessMemory( hProcess,
							(LPVOID)dwEbp,
							(LPVOID)&dwEbp,
							sizeof( DWORD ),
							NULL ) ) {
		return;
	}

	for( i = 0; ( i < MaxCallStack ) && dwEbp; i++ ) {

		if( !ReadProcessMemory( hProcess,
								(LPVOID)( (PDWORD)dwEbp + 1 ),
								(LPVOID)( &callstack[ i ] ),
								sizeof( DWORD ),
								NULL ) ) {
			break;
		}
		if( !ReadProcessMemory( hProcess,
								(LPVOID)dwEbp,
								(LPVOID)&dwEbp,
								sizeof( DWORD ),
								NULL ) ) {
		   break;
		}

	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\attrib.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

   attrib.cxx

Abstract:

   This module contains member function definitions for NTFS_ATTRIBUTE,
   which models an NTFS attribute instance.

Author:

   Bill McJohn (billmc) 21-June-91

Environment:

   ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "cmem.hxx"
#include "drive.hxx"
#include "mft.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"
#include "frs.hxx"
#include "ntfsbit.hxx"
#include "badfile.hxx"
#include "numset.hxx"
#include "rtmsg.h"

// This constant specifies the maximum number of clusters Read and
// Write will try to transfer at once.  Note that it is chosen to
// ensure that MaximumClustersToTransfer * ClusterSize will fito
// in  a ULONG.

CONST MaximumClustersToTransfer = 32;

UCHAR
ComputeCompressionUnit(
    IN ULONG    ClusterSize
    );

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE, OBJECT, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_ATTRIBUTE::~NTFS_ATTRIBUTE(
         )
{
   Destroy();
}


VOID
NTFS_ATTRIBUTE::Construct (
   )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Type = 0;
    _Flags = 0;
    _CompressionUnit = 0;
    _ValueLength = 0;
    _ValidDataLength = 0;

    _ResidentData = NULL;
    _ExtentList = NULL;

    _StorageModified = FALSE;
}


VOID
NTFS_ATTRIBUTE::Destroy(
   )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Type = 0;

    _Flags = 0;
    _CompressionUnit = 0;
    _ValueLength = 0;
    _ValidDataLength = 0;

    if( _ResidentData != NULL ) {

        FREE( _ResidentData );
        _ResidentData = NULL;
    }

    if( _ExtentList != NULL ) {

        DELETE( _ExtentList );
        _ExtentList = NULL;
    }

    _StorageModified = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Initialize (
   IN OUT  PLOG_IO_DP_DRIVE     Drive,
   IN      ULONG                ClusterFactor,
   IN      PCVOID               Value,
   IN      ULONG                ValueLength,
   IN      ATTRIBUTE_TYPE_CODE  TypeCode,
   IN      PCWSTRING            Name,
   IN      USHORT               Flags
   )
/*++

Routine Description:

    This method initializes a resident attribute based on its value.

Arguments:


    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    Value           -- supplies the attribute's value.
    ValueLength     -- supplies the length of the attribute's value.
    TypeCode        -- supplies the attribute's type code.
    Name            -- supplies the attribute's name.  NULL indicates
                        that the attribute has no name.
    Flags           -- supplies the attribute's flags.

Return Value:

    TRUE upon successful completion.

Notes:

    If ValueLength is zero, then this is an empty attribute (and Value
    may be NULL).

--*/
{
    Destroy();

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;
    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE |
                 ATTRIBUTE_FLAG_ENCRYPTED)) {
        _CompressionUnit = ComputeCompressionUnit(
                            _Drive->QuerySectorSize() * ClusterFactor);
    }

    if( (_ResidentData = MALLOC( (UINT) ValueLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    if (Name) {
        if (!_Name.Initialize(Name)) {
            Destroy();
            return FALSE;
        }
    } else {
        if (!_Name.Initialize("")) {
            Destroy();
            return FALSE;
        }
    }


    // Copy the value into our buffer:

    memcpy( _ResidentData, Value, (UINT) ValueLength );

    _ValueLength = ValueLength;
    _ValidDataLength = ValueLength;

    _Type = TypeCode;
    _Flags = Flags;
    _ResidentFlags = 0;
    _FormCode = RESIDENT_FORM;

    _StorageModified = TRUE;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Initialize (
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN      PCNTFS_EXTENT_LIST  Extents,
    IN      BIG_INT             ValueLength,
    IN      BIG_INT             ValidLength,
    IN      ATTRIBUTE_TYPE_CODE TypeCode,
    IN      PCWSTRING           Name,
    IN      USHORT              Flags
   )
/*++

Routine Description:

    This method initializes a non-resident attribute based on an
    extent list.

Arguments:

    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    Extents         -- supplies the extent list describing the attribute
                        value's disk storage.
    ValueLength     -- supplies the actual length of the attribute's value.
    ValidLength     -- supplies the valid length of the attribute's value.
    TypeCode        -- supplies the attribute's type code.
    Name            -- supplies the attribute's name.  NULL indicates
                        that the attribute has no name.
    Flags           -- supplies the attribute's flags.

Return Code:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if (Extents->QueryLowestVcn() != 0) {
        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE |
                 ATTRIBUTE_FLAG_ENCRYPTED)) {
        _CompressionUnit = ComputeCompressionUnit(
                            _Drive->QuerySectorSize() * ClusterFactor);
    }

    if( (_ExtentList = NEW NTFS_EXTENT_LIST) == NULL ||
        !_ExtentList->Initialize( Extents ) ) {

        Destroy();
        return FALSE;
    }

    if (Name) {
        if (!_Name.Initialize(Name)) {
            Destroy();
            return FALSE;
        }
    } else {
        if (!_Name.Initialize("")) {
            Destroy();
            return FALSE;
        }
    }

    _ResidentData = NULL;
    _ResidentFlags = 0;

    _ValueLength = ValueLength;
    _ValidDataLength =  ValidLength;

    if (CompareGT(_ValidDataLength, _ValueLength) ||
        CompareGT(_ValueLength, QueryAllocatedLength())) {

        Destroy();
        return FALSE;
    }

    _Type = TypeCode;
    _Flags = Flags;
    _FormCode = NONRESIDENT_FORM;
    _StorageModified = TRUE;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::Initialize (
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      ULONG                   ClusterFactor,
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord
   )
/*++

Routine Description:

    This method initializes an attribute based on an attribute record.

Arguments:

    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    AttributeRecord -- supplies the attribute record.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT AllocatedLength;

    Destroy();

    if (AttributeRecord->QueryLowestVcn() != 0) {
        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;

    _Type = AttributeRecord->QueryTypeCode();
    _Flags = AttributeRecord->QueryFlags();
    _CompressionUnit = (UCHAR)AttributeRecord->QueryCompressionUnit();
    _StorageModified = FALSE;

    if (!AttributeRecord->QueryName(&_Name)) {

        Destroy();
        return FALSE;
    }

    if( AttributeRecord->IsResident() ) {

        _ValueLength = AttributeRecord->QueryResidentValueLength();

        if( (_ResidentData = MALLOC( (UINT) AttributeRecord->
                                            QueryResidentValueLength() )) ==
            NULL ) {

            Destroy();
            return FALSE;
        }

        // Copy the value into our buffer:

        memcpy( _ResidentData,
                AttributeRecord->GetResidentValue(),
                (UINT) AttributeRecord->QueryResidentValueLength() );

        _ValidDataLength = _ValueLength;

        _FormCode = RESIDENT_FORM;
        _ResidentFlags = AttributeRecord->QueryResidentFlags();

    } else {

        if (!(_ExtentList = NEW NTFS_EXTENT_LIST) ||
            !AttributeRecord->QueryExtentList(_ExtentList)) {

            Destroy();
            return FALSE;
        }

        AttributeRecord->QueryValueLength( &_ValueLength,
                                           &AllocatedLength,
                                           &_ValidDataLength );

        _FormCode = NONRESIDENT_FORM;
        _ResidentFlags = 0;
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::AddAttributeRecord (
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN OUT  PNTFS_EXTENT_LIST       *BackupExtent
   )
/*++

Routine Description:

    This method adds an attribute record to the attribute.

    This method is intended to be used in inializing the
    attribute with multiple attribute records.

Arguments:

    AttributeRecord -- supplies the attribute record.
    BackupExtent    -- supplies/receives a copy of the extent list

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING             record_name;
    NTFS_EXTENT_LIST    extent_list;
    ULONG               i, n;
    VCN                 vcn;
    LCN                 lcn;
    BIG_INT             run_length;

    if (IsResident() || AttributeRecord->IsResident()) {

        // Can't have multiple resident attribute records.
        return FALSE;
    }

    DebugAssert(_ExtentList);

    if (_Type != AttributeRecord->QueryTypeCode()) {

        // Attribute record must have the same type code.
        return FALSE;
    }

    // The filesystem only cares about and maintains the Flags member
    // in the first attribute record of a multi-frs attribute.  So
    // I removed the check below, which used to insure that each set
    // of flags was identical. -mjb.

    if (!AttributeRecord->QueryName(&record_name) ||
        record_name.Strcmp(&_Name) ||
        /* _Flags != AttributeRecord->QueryFlags() || */
        !AttributeRecord->QueryExtentList(&extent_list) ||
        (*BackupExtent == NULL &&
         ((*BackupExtent = NEW NTFS_EXTENT_LIST) == NULL ||
          !(*BackupExtent)->Initialize(_ExtentList)))) {

        return FALSE;
    }

    n = extent_list.QueryNumberOfExtents();

    for (i = 0; i < n; i++) {
        // Query i'th extent from attribute record and
        // add it to the backup extent list
        if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
            !(*BackupExtent)->AddExtent(vcn, lcn, run_length)) {
            DebugPrint("UNTFS: Unable to update the backup extent list\n");
            return FALSE;
        }
    }

    for (i = 0; i < n; i++) {

        // Query i'th extent from attribute record and
        // add it to the current extent list
        if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
            !_ExtentList->AddExtent(vcn, lcn, run_length)) {

            // Restore the extent list.
            for (i=0; i < n; i++) {
                if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
                    !(*BackupExtent)->DeleteRange(vcn, run_length)) {
                    DebugPrint("UNTFS: Unable to restore extent list\n");
                    return FALSE;
                }
            }
            _ExtentList->Initialize(*BackupExtent);
            return FALSE;
        }
    }

    // If the LowestVcn of this record is less than the LowestVcn
    // of the extent list, update the extent list.  If the NextVcn
    // of this record is greater than the NextVcn of the extent list,
    // update the extent list.  This will cover the cases where the
    // the attribute is sparse and the new record begins or ends with
    // a gap
    //

    if( AttributeRecord->QueryLowestVcn() < _ExtentList->QueryLowestVcn() ) {

        _ExtentList->SetLowestVcn( AttributeRecord->QueryLowestVcn() );
        (*BackupExtent)->SetLowestVcn( AttributeRecord->QueryLowestVcn() );
    }

    if( AttributeRecord->QueryNextVcn() > _ExtentList->QueryNextVcn() ) {

        _ExtentList->SetNextVcn( AttributeRecord->QueryNextVcn() );
        (*BackupExtent)->SetNextVcn( AttributeRecord->QueryNextVcn() );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::VerifyAndFix(
    IN  BIG_INT VolumeSectors
    )
/*++

Routine Description:

    This routine ensures that the allocation of the given
    attribute is non-self overlapping and that the allocation
    does not use the clusters reserved for the boot file.

    It also tweeks the allocation sizes if necessary.

Arguments:

    VolumeSectors   - Supplies the number of sectors on the volume.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               i;
    LCN                 j;
    LCN                 lcn;
    VCN                 vcn;
    BIG_INT             run_length;
    NTFS_BITMAP         allocated_clusters;
    NTFS_EXTENT_LIST    new_extent_list;
    BOOLEAN             cross_link;
    BIG_INT             num_clusters;

    cross_link = FALSE;

    if (_ExtentList) {

        // Now analyse the mapping pairs for cross-links.
        // Truncate the attribute at the first offending
        // cluster.

        num_clusters = VolumeSectors/QueryClusterFactor();

        if (!allocated_clusters.Initialize(num_clusters, FALSE, _Drive,
                _ClusterFactor) ||
            !new_extent_list.Initialize(0, 0)) {

            return FALSE;
        }

        // Mark as allocate sector zero since this always belongs
        // to the boot file.  Don't bother marking n/2 as allocated
        // because we deal with copying that cross-links there.

        allocated_clusters.SetAllocated(0, 1);

        for (i = 0; _ExtentList->QueryExtent(i, &vcn, &lcn, &run_length); i++) {

            if (LCN_NOT_PRESENT == lcn) {
                continue;
            }

            if (!allocated_clusters.IsFree(lcn, run_length)) {

                for (j = 0; j < run_length; j += 1) {
                    if (!allocated_clusters.IsFree(lcn + j, 1)) {
                        break;
                    }
                }

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_REC_CROSS_LINKED,
                                 "%x%I64x%I64x",
                                 QueryTypeCode(),
                                 (lcn + j).GetLargeInteger(),
                                 (run_length - j).GetLargeInteger());
                    }
                }

                if (j > 0 && !new_extent_list.AddExtent(vcn, lcn, j)) {
                    return FALSE;
                }

                cross_link = TRUE;
                break;
            }

            allocated_clusters.SetAllocated(lcn, run_length);

            if (!new_extent_list.AddExtent(vcn, lcn, run_length)) {
                return FALSE;
            }
        }
    }

    if (cross_link) {
        if (!_ExtentList->Initialize(&new_extent_list)) {
            return FALSE;
        }
        _StorageModified = TRUE;
    }

    if (CompareGT(_ValueLength, QueryAllocatedLength())) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_UNKNOWN_TAG_ATTR_SIZES,
                         "%I64x%I64x%I64x%x",
                         _ValidDataLength.GetLargeInteger(),
                         _ValueLength.GetLargeInteger(),
                         QueryAllocatedLength().GetLargeInteger(),
                         QueryTypeCode());
            }
        }

        _ValueLength = QueryAllocatedLength();
        _StorageModified = TRUE;
    }

    if (CompareGT(_ValidDataLength, _ValueLength)) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_UNKNOWN_TAG_ATTR_SIZES,
                         "%I64x%I64x%I64x%x",
                         _ValidDataLength.GetLargeInteger(),
                         _ValueLength.GetLargeInteger(),
                         QueryAllocatedLength().GetLargeInteger(),
                         QueryTypeCode());
            }
        }

        _ValidDataLength = _ValueLength;
        _StorageModified = TRUE;
    }

    return TRUE;
}


BOOLEAN
PartitionExtentList(
    IN  PCNTFS_EXTENT_LIST  SourceList,
    IN  ULONG               MaxSize,
    OUT PNTFS_EXTENT_LIST   ResultList,
    OUT PNTFS_EXTENT_LIST   RemainderList
    )
/*++

Routine Description:

    This routine partitions 'SourceList' into 'ResultList' and
    'RemainderList'.

    'ResultList' contains as many extents from 'SourceList' as can be
    compressed into 'MaxSize' bytes.

    'RemainderList' contains all of the extents of 'SourceList' which are
    not in 'ResultList'.

Arguments:

    SourceList      - Supplies the list of extents to partition.
    MaxSize         - Supplies the maximum number of bytes for
                        the compressed mapping pairs of the first
                        part of the partition.
    ResultList      - Returns the first part of the partition.
    RemainderList   - Returns the second part of the partition.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   MaxBytesPerMappingPair = sizeof(LCN) + sizeof(VCN) + 1;

    VCN lowest;
    VCN next;
    ULONG mapping_length;
    PUCHAR mapping_space;
    ULONG buffer_size;
    ULONG count;
    ULONG ptr;
    VCN vcn;
    LCN lcn;
    BIG_INT run_length;
    ULONG i;
    VCN part_next;
    ULONG num_extents;
    UCHAR v, l;
    BIG_INT tmp;
    BIG_INT sum;
    BOOLEAN ends_with_gap = FALSE;
    BOOLEAN HasHoleInFront;


    // Handle an empty list gracefully

    if( SourceList->IsEmpty() ) {

        if( !ResultList->Initialize( SourceList ) ||
            !RemainderList->Initialize( 0, 0 ) ) {

            return FALSE;
        }

        return TRUE;
    }


    // compute an upper bound for the space required by the compressed
    // extents of the source extent list.

    // This upper bound formula may be too much as QueryNumberOfExtents will
    // return all entries including gaps except the last one if it is a gap.

    buffer_size = MaxBytesPerMappingPair*
                  (2*SourceList->QueryNumberOfExtents() + 1) + 1;

    if ( (mapping_space = (PUCHAR) MALLOC( (UINT) buffer_size )) == NULL ) {

        return FALSE;
    }


    // Get the compressed mapping pairs for the source list.

    // The HasHoleInFront flag allows us to take into account of the
    // (0, ffffffff. ????) entry at the very beginning of an extented
    // list.  As this entry won't make it into the compression pairs.
    // The code below that counts the compression pairs and retrieves
    // vcn/lcn/runlength tuple needs to take into account of this entry.


    if (!SourceList->QueryCompressedMappingPairs(&lowest,
                                                 &next,
                                                 &mapping_length,
                                                 buffer_size,
                                                 mapping_space,
                                                 &HasHoleInFront)) {
        FREE(mapping_space);
        return FALSE;
    }

    // Let count denote the number of extents in the first partition

    count = 0;
    ptr = 0;
    sum = 0;
    while (mapping_space[ptr] != 0) {

        v = VcnBytesFromCountByte(mapping_space[ptr]);
        l = LcnBytesFromCountByte(mapping_space[ptr]);

        // Only consider this mapping pair if it will fit along with
        // the next description byte.

        if (ptr + v + l + 2 > MaxSize) {
            break;
        }

        tmp.Set(l, &mapping_space[ptr + v + 1]);
        sum += tmp;

#if 0
        if (SourceList->QueryNumberOfExtents() > 20) {
            DebugPrintTrace(("%d, %I64x, ", count, sum));
            if (SourceList->QueryExtent(count, &vcn, &lcn, &run_length)) {
                DebugPrintTrace(("(%I64x, %I64x, %I64x)\n", vcn, lcn, run_length));
            } else {
                DebugPrintTrace(("(error)\n"));
            }
        }
#endif

        count++;

        // If the number of LCN bytes is 0 or the lcn is -1,
        // then it's a place holder, not a real extent.

        if (l != 0 && sum != -1) {
            ends_with_gap = FALSE;
        } else {
            ends_with_gap = TRUE;
        }

        ptr += v + l + 1;
    }

#if 0
    if (SourceList->QueryNumberOfExtents() > 20) {
        DebugPrintTrace(("%d", count));
        if (SourceList->QueryExtent(count, &vcn, &lcn, &run_length)) {
            DebugPrintTrace(("(%I64x, %I64x, %I64x)\n", vcn, lcn, run_length));
        } else {
            DebugPrintTrace(("(error)\n"));
        }
    }
#endif

    // Compute the next VCN of the first partition, which is also the
    // starting VCN of the remainder.
    //
    if (mapping_space[ptr] == 0) {

        // We processed and accepted for the first partition the entire
        // source list; this means that the result list is the same as
        // the sources, and the remainder is empty.
        //
        count = SourceList->QueryNumberOfExtents();
        part_next = next;

    } else {

        if (!SourceList->QueryExtent(count,
                                     &part_next, &lcn, &run_length)) {
            return FALSE;
        }
    }

    FREE(mapping_space);


    // Now that we know how to split it up, create the two partitions.

    if (!ResultList->Initialize(lowest, part_next) ||
        !RemainderList->Initialize(part_next, next)) {

        return FALSE;
    }

    for (i = 0; i < count; i++) {

        if (!SourceList->QueryExtent(i, &vcn, &lcn, &run_length)) {
            return FALSE;
        }

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }

        if (!ResultList->AddExtent(vcn, lcn, run_length)) {
            return FALSE;
        }
    }

    num_extents = SourceList->QueryNumberOfExtents();

    for (i = count; i < num_extents; i++) {

        if (!SourceList->QueryExtent(i, &vcn, &lcn, &run_length)) {
            return FALSE;
        }

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }

        if (!RemainderList->AddExtent(vcn, lcn, run_length)) {
            return FALSE;
        }
    }

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::InsertIntoFile (
   IN OUT  PNTFS_FILE_RECORD_SEGMENT   BaseFileRecordSegment,
   IN OUT  PNTFS_BITMAP                Bitmap
   )
/*++


Routine Description:

    This method inserts the attribute into a File Record Segment.
    The attribute packages itself up into Attribute Records and
    jams them into the File Record Segment.

Arguments:

    FileRecordSegment   -- Supplies the File Record Segment into
                            which the attribute will jam itself.
    Bitmap              -- Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    If the volume bitmap is supplied, the attribute may make itself
    nonresident, or the File Record Segment may make one or more of
    its attribute records nonresident or external.

--*/
{
    NTFS_ATTRIBUTE_RECORD AttributeRecord;
    PVOID AttributeRecordData;
    BOOLEAN Result;
    ULONG MaxSize;
    ULONG MaxExtentsSize, CurrentMaxExtentsSize;
    NTFS_EXTENT_LIST source;
    NTFS_EXTENT_LIST result;
    NTFS_EXTENT_LIST remainder;
    BOOLEAN FirstChunkInserted = FALSE;
    BOOLEAN Completed = FALSE;


    // First purge the attribute out of the file, unless it's indexed.

    if (!IsIndexed()) {

        if (!BaseFileRecordSegment->PurgeAttribute(_Type, &_Name)) {
            return FALSE;
        }
    }

    // If this is the MFT Data attribute, use the private worker method:
    //
    if( BaseFileRecordSegment->QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
        QueryTypeCode() == $DATA &&
        _Name.QueryChCount() == 0 ) {

        // First, try to save the MFT data attribute conservatively,
        // leaving space for future hotfixing.  If that fails (typically
        // because of bootstrapping problems), fill it to the gills.
        //
        if( InsertMftDataIntoFile( BaseFileRecordSegment, Bitmap, TRUE ) ) {

            ResetStorageModified();
            return TRUE;

        } else {

            Result = BaseFileRecordSegment->PurgeAttribute(_Type, &_Name) &&
                     InsertMftDataIntoFile( BaseFileRecordSegment, Bitmap, FALSE );
            ResetStorageModified();
            return Result;
        }
    }


    // Allocate a buffer to hold attribute records.

    MaxSize = BaseFileRecordSegment->QueryMaximumAttributeRecordSize();

    if( (AttributeRecordData = MALLOC( (UINT) MaxSize )) == NULL ) {

        return FALSE;
    }


    // Handle the resident attribute case:

    if ( _ResidentData != NULL ) {

        if( !AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize ) ) {

            FREE( AttributeRecordData );
            return FALSE;
        }

        // The attribute value is resident.  Package up a resident
        // attribute record.

        Result = AttributeRecord.
                    CreateResidentRecord( _ResidentData,
                                          _ValueLength.GetLowPart(),
                                          _Type,
                                          &_Name,
                                          _Flags,
                                          _ResidentFlags );

        //
        // Check to see if there is enough space to Create a resident record
        //

        if (Result) {
            Result = BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );

            FREE( AttributeRecordData );
            return Result;
        } else {
            // Not enough space to do so, make attribute record non-resident
            if (IsIndexed() || !Bitmap || !MakeNonresident(Bitmap)) {
               FREE( AttributeRecordData );
               return FALSE;
            }
        }
    }


    // Compute the maximum number of bytes in an extent list.
    //
    MaxExtentsSize = MaxSize - SIZE_OF_NONRESIDENT_HEADER;
    if (_Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE)) {
        MaxExtentsSize -= sizeof(BIG_INT);
    }
    MaxExtentsSize -= QuadAlign(_Name.QueryChCount());
    Result = source.Initialize(_ExtentList);

    while (Result && !Completed) {

        // Initialize attribute record.

        Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );


        // Partition extent list into two pieces, the first of which
        // can be made into an attribute record.

        Result = Result &&
                 PartitionExtentList(&source,
                                     MaxExtentsSize,
                                     &result,
                                     &remainder);


        // Create the attribute record.

        Result = Result &&
                 AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit,
                                             _ClusterFactor*_Drive->QuerySectorSize());


        // If we were able to package it up, then give the attribute
        // record to the File Record Segment.

        Result = Result &&
                 BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );


        // If all of the extents fit in the last record then we are done.

        if (remainder.IsEmpty()) {

            Completed = TRUE;

        } else {

            Result = Result &&
                    source.Initialize(&remainder);
        }
    }


    ResetStorageModified();
    FREE( AttributeRecordData );
    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::MakeNonresident (
   IN OUT  PNTFS_BITMAP    Bitmap
   )
/*++

Routine Description:

    This method makes the attribute value nonresident.

Arguments:

    Bitmap  -- supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    If the attribute is already nonresident, this method succeeds.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    LCN Lcn;
    ULONG DataLength, ClusterSize, ClustersRequired, ClustersAllocated, MaxRunLength;
    ULONG RunLength;

    if (!IsResident()) {

        // The attribute is already nonresident, which makes
        // this task pretty easy.

        return TRUE;
    }


    // Since the attribute is resident, its length will fit in a ULONG.
    //
    DebugAssert(_ValueLength.GetHighPart() == 0);

    DataLength = _ValueLength.GetLowPart();

    if (DataLength == 0) {

        // This attribute has no data, so we just set up an empty
        // extent list.

        if ((_ExtentList = NEW NTFS_EXTENT_LIST) == NULL ||
            !_ExtentList->Initialize( 0, 0 )) {
            if (_ExtentList != NULL)
                DELETE(_ExtentList);
            return FALSE;
        }

        FREE(_ResidentData);
        _ResidentData = NULL;

        _FormCode = NONRESIDENT_FORM;
        SetStorageModified();
        return TRUE;
    }

    // This attribute has data, so we need to allocate disk space
    // for it, copy it into that disk space, and set up an extent
    // list that describes that disk space.  Determine how many
    // clusters we need to hold the resident value.

    if ((_ExtentList = NEW NTFS_EXTENT_LIST ) == NULL ||
        !_ExtentList->Initialize( 0, 0 )) {

        if (_ExtentList != NULL)
            DELETE( _ExtentList );
        return FALSE;
    }

    ClusterSize = _Drive->QuerySectorSize() * _ClusterFactor;

    ClustersRequired = DataLength / ClusterSize;
    if (DataLength % ClusterSize) {

        ClustersRequired += 1;
    }

    ClustersAllocated = 0;
    MaxRunLength = ClustersRequired;

    while (ClustersAllocated < ClustersRequired) {

        //
        // Never try to allocate more clusters than we need to finish the
        // allocation.
        //

        RunLength = min(MaxRunLength, ClustersRequired - ClustersAllocated);

        if (!Bitmap->AllocateClusters( 0, RunLength, &Lcn )) {

            if (RunLength == 1) {

                // Out of disk space.
                return FALSE;
            }

            MaxRunLength /= 2;
            continue;
        }

        _ExtentList->AddExtent( ClustersAllocated /* vcn */,
                                Lcn,
                                RunLength );

        //
        // Copy data from the resident attribute value into this chunk of
        // the nonresident attribute allocation.
        //

        if (!IntermediateBuffer.Initialize() ||
            !ClusterRun.Initialize( &IntermediateBuffer, _Drive, Lcn, _ClusterFactor,
                                    RunLength )) {

            Bitmap->SetFree( Lcn, RunLength );
            return FALSE;
        }

        memset( ClusterRun.GetBuf(), '\0', ClusterSize * RunLength );
        memcpy( ClusterRun.GetBuf(),
                PUCHAR(_ResidentData) + ClustersAllocated * ClusterSize,
                min(ClusterSize * RunLength,
                    DataLength - ClustersAllocated * ClusterSize) );

        if (!ClusterRun.Write()) {

            Bitmap->SetFree( Lcn, RunLength );
            return FALSE;
        }

        ClustersAllocated += RunLength;
    }

    //
    // We've succeeded in making the attribute value nonresident.
    // Clean up the resident data and change the state variables.
    //

    FREE( _ResidentData );
    _ResidentData = NULL;

    _FormCode = NONRESIDENT_FORM;

    SetStorageModified();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Resize (
   IN      BIG_INT      NewSize,
   IN OUT  PNTFS_BITMAP Bitmap
   )
/*++

Routine Description:

    This method changes the file size of an attribute.  It will also modify
    the allocated size appropriately, either extending or truncating it.

Arguments:

    NewSize -- supplies the attribute value's new allocated size.
    Bitmap  -- supplies the volume bitmap.  May be NULL.

Return Value:

    None.

Notes:

    If the attribute value is resident and the client attempts to
    allocate to a new size which is greater than the maximum ULONG,
    this method will fail.  The client must call MakeNonresident first.

    Note that a nonresident attribute cannot be extended without
    the bitmap; if a nonresident attribute is truncated without
    a bitmap then the free space is not updated in the bitmap.

--*/
{
    BIG_INT NewNumberOfClusters, NewAllocatedSize;
    PVOID NewData;
    ULONG ClusterSize;

    if (_ValueLength == NewSize &&
        QueryAllocatedLength() == NewSize) {

        return TRUE;
    }

    if( _ResidentData != NULL ) {

        // The attribute value is resident.  We just allocate a
        // new chunk of memory, zero it out, copy in the old value
        // (or as much of it as fits), and adjust the length fields.

        // Note that we do not allow the client to resize a resident
        // attribute to a size greater than the maximum ULONG.

        if( NewSize.GetHighPart() == 0 &&
            (NewData = MALLOC( NewSize.GetLowPart() )) != NULL ) {

            memset( NewData, '\0', NewSize.GetLowPart() );
            memcpy( NewData,
                    _ResidentData,
                    MIN(_ValueLength.GetLowPart(), NewSize.GetLowPart()) );

            _ValueLength = NewSize;
            _ValidDataLength = NewSize;

            FREE( _ResidentData );
            _ResidentData = NewData;

            SetStorageModified();

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        // The attribute value is nonresident.  First, we round the
        // allocation size up to a multiple of the volume cluster size.
        // Since ClusterSize is always a power of two, the use of
        // the low part of NewSize in this modulo operation is safe.

        ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

        NewAllocatedSize = NewSize;

        if( NewAllocatedSize % ClusterSize != 0 ) {

            NewAllocatedSize += (ClusterSize - NewAllocatedSize % ClusterSize);
        }

        NewNumberOfClusters = NewAllocatedSize / ClusterSize;

        DebugAssert( _ExtentList != NULL );

        if (_ExtentList == NULL)
            return FALSE;

        if( _ExtentList->Resize( NewNumberOfClusters, Bitmap ) ) {

            _ValueLength = NewSize;

            if( CompareGT(_ValidDataLength, _ValueLength) ) {

                _ValidDataLength = _ValueLength;
            }

            SetStorageModified();

            return TRUE;

        } else {

            return FALSE;
        }
    }
}

UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::SetSparse(
   IN      BIG_INT      NewSize,
   IN OUT  PNTFS_BITMAP Bitmap
   )
/*++

Routine Description:

    This method changes the file size of an sparse attribute to the given size.  It
    will free any allocated clusters and put a hole at the beginning.

Arguments:

    NewSize -- supplies the attribute value's new file size.
    Bitmap  -- supplies the volume bitmap.

Return Value:

    None.

Notes:

--*/
{
    BIG_INT NewNumberOfClusters, NewAllocatedSize;
    ULONG   ClusterSize;

    if (!(_Flags & ATTRIBUTE_FLAG_SPARSE)) {

        // return error if this is not a sparse file

        return FALSE;
    }

    if ( _ResidentData != NULL ) {

        // The attribute value is resident.  So, make it into a non-resident
        // one first.

        if (!MakeNonresident(Bitmap))
            return FALSE;

    }

    // The attribute value is nonresident.  First, we round the
    // allocation size up to a multiple of the volume cluster size.
    // Since ClusterSize is always a power of two, the use of
    // the low part of NewSize in this modulo operation is safe.

    ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

    NewAllocatedSize = NewSize;

    if( NewAllocatedSize % ClusterSize != 0 ) {

        NewAllocatedSize += (ClusterSize - NewAllocatedSize % ClusterSize);
    }

    NewNumberOfClusters = NewAllocatedSize / ClusterSize;

    DebugAssert( _ExtentList != NULL );

    if (_ExtentList == NULL)
        return FALSE;

    // now throw away any allocation and then make
    // the stream sparse

    if( _ExtentList->Resize( 0, Bitmap ) &&
        _ExtentList->SetSparse(NewNumberOfClusters)) {

        _ValueLength = NewSize;

        _ValidDataLength = 0;

        SetStorageModified();

        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_ATTRIBUTE::AddExtent(
    IN  VCN     Vcn,
   IN  LCN     Lcn,
   IN  BIG_INT RunLength
   )
/*++

Routine Description:

    This method adds an extent to the Attribute's allocation.  (Note
    that if the attribute is resident, this method will fail.)

Arguments:

    Vcn         -- supplies the starting VCN of the run.
    Lcn         -- supplies the starting LCN of the run.
    RunLength   -- supplies the number of clusters in the run.

Return Value:

    TRUE upon successful completion.
--*/
{
    if( _ExtentList == NULL ) {

        return FALSE;

    } else {

        if ( _ExtentList->AddExtent( Vcn, Lcn, RunLength ) ) {

            SetStorageModified();
            return TRUE;

        } else {

            return FALSE;
        }
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Read (
   OUT PVOID   Data,
   IN BIG_INT ByteOffset,
   IN ULONG   BytesToRead,
   OUT PULONG  BytesRead
   )
/*++

Routine Description:

    This method reads data from the attribute's value.

Arguments:

    Data        -- supplies the user's buffer, into which data
                    will be read.
    ByteOffset  -- supplies the byte offset into the attribute value
                    at which the read should commence.
    BytesToRead -- supplies the number of bytes to read.
    BytesRead   -- receives the number of bytes actually read.

Return Value:

    TRUE upon successful completion.

Notes:

    Read will only read up to the attribute's actual length.

    Note that Read ignores the attribute's valid data length.

    Note that if Read fails, the contents of the user's buffer is
    undefined.

    This method is able to handle sparse attributes.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    BIG_INT TempBigInt;
    BIG_INT RunLength;
    VCN CurrentVcn;
    LCN CurrentLcn;
    PBYTE CurrentData;
    ULONG BytesToCopy;
    ULONG OffsetIntoCluster;
    ULONG ClusterSize;
    ULONG CurrentRunLength;
    ULONG RemainingRequest;
    ULONG BytesToZero = 0;

    // First, perform some range-checking.  We can only read to
    // the end of the actual size of the attribute value.

    if( _ValueLength <= ByteOffset ) {

        BytesToRead = 0;

    } else if ( _ValueLength < ByteOffset + BytesToRead ) {

        // Since this difference is less than BytesToRead, this
        // assignment is safe:

        TempBigInt = _ValueLength - ByteOffset;
        BytesToRead = TempBigInt.GetLowPart();
    }


    if( _ResidentData != NULL ) {

        // Since the attribute value is resident, we can
        // just copy it.  We've verified above that the request
        // fits in the allocated space, so there's nothing more
        // to do except the copy itself.

        memcpy( Data,
                (PCHAR) _ResidentData + ByteOffset.GetLowPart(),
                (UINT) BytesToRead );

    } else if ( _ExtentList != NULL ) {

        RemainingRequest = BytesToRead;

        // Now check the valid length.  If the entire read is beyond
        // the end valid data, just zero it out; otherwise, zero out
        // the portion beyond the end of valid data.
        //
        if( CompareLTEQ(_ValidDataLength, ByteOffset) ) {

            // The entire read is beyond the end of valid data.
            //
            memset( Data, 0, BytesToRead );
            *BytesRead = BytesToRead;
            return TRUE;

        } else if( CompareLT(_ValidDataLength, ByteOffset + BytesToRead) ) {

            // Only read the portion up to the end of valid data;
            // zero the rest out.
            //
            TempBigInt = _ValidDataLength - ByteOffset;
            RemainingRequest = TempBigInt.GetLowPart();

            BytesToZero = BytesToRead - RemainingRequest;

            memset( (PBYTE) Data + RemainingRequest, 0, BytesToZero );
        }

        // The attribute value is nonresident, so we'll have to go
        // find it on disk.  First, we'll read any leading partial
        // cluster through an intermediate buffer.  Then we'll read
        // as many whole clusters as there are in the request directly
        // into the user's buffer.  Finally, we'll read any trailing
        // partial cluster through the intermediate buffer.

        if( RemainingRequest > 0 ) {

            ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();
            CurrentData = (PBYTE) Data;

            OffsetIntoCluster = (ByteOffset % ClusterSize).GetLowPart();

            if( OffsetIntoCluster != 0 ) {

                // We have a partial leading cluster, so we'll read
                // it through the intermediate buffer.

                BytesToCopy = MIN( BytesToRead - BytesToZero,
                                   ClusterSize - OffsetIntoCluster );

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->  QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the request hits a hole in a
                    // sparse file, so we just fill the corresponding
                    // part of the request with zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read the cluster containing this part of the
                    // request and copy the partial leading cluster
                    // into the client's buffer.

                    if( !IntermediateBuffer.Initialize() ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                1 ) ||
                        !ClusterRun.Read() ) {

                        DebugPrint( "Cannot read leading clusters.\n" );

                        return FALSE;
                    }

                    memcpy( CurrentData,
                            (PBYTE)ClusterRun.GetBuf() + OffsetIntoCluster,
                            (UINT) BytesToCopy );
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            // Now transfer any complete clusters.  Because the
            // client's buffer may not be suitably aligned, we
            // have to cycle these through an intermediate buffer.

            while( RemainingRequest >= ClusterSize ) {

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( RunLength.GetHighPart() != 0 ||
                    RunLength.GetLowPart() >
                            MaximumClustersToTransfer ) {

                    CurrentRunLength = MaximumClustersToTransfer;

                } else {

                    CurrentRunLength = RunLength.GetLowPart();
                }

                if( CurrentRunLength * ClusterSize >
                    RemainingRequest ) {

                    CurrentRunLength = RemainingRequest/ClusterSize;
                }

                BytesToCopy = CurrentRunLength * ClusterSize;

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the read request falls into a hole
                    // in a sparse attribute, so we can just fill the
                    // client's buffer with zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read the data into the temporary buffer (used
                    // to avoid alignment problems) and then copy it
                    // into the client's buffer.

                    if( !IntermediateBuffer.Initialize( ) ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                CurrentRunLength ) ||
                        !ClusterRun.Read() ) {

                        DebugPrint( "Cannot read complete clusters.\n" );
                        return FALSE;
                    }

                    memcpy( CurrentData,
                            IntermediateBuffer.GetBuf(),
                            BytesToCopy );
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            if( RemainingRequest > 0 ) {

                // OK, we have a partial trailing cluster.  Read
                // it through the intermediate buffer.

                BytesToCopy = RemainingRequest;

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the read request falls into a hole
                    // in a sparse attribute, so we can just fill the
                    // appropriate part of the client's buffer with
                    // zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read this part of the request into an intermediate
                    // buffer (to avoid alignment problems) and then
                    // copy the data into the client's buffer.

                    if( !IntermediateBuffer.Initialize() ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                1 ) ||
                         !ClusterRun.Read() ) {
                         DebugPrint( "Cannot read partial clusters.\n" );

                        return FALSE;
                    }


                    // We've read the cluster in question; copy the partial
                    // trailing cluster of our request.

                    memcpy( CurrentData,
                            ClusterRun.GetBuf(),
                            (UINT) BytesToCopy );
                }
            }
        }

    } else {

        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }

    *BytesRead = BytesToRead;
    return TRUE;
}


VOID
NTFS_ATTRIBUTE::PrimeCache (
    IN  BIG_INT ByteOffset,
    IN  ULONG   BytesToRead
    )
/*++

Routine Description:

    This routine reads the given range from the attribute.  If the drive
    hierarchy is cached then this will have the effect of priming the
    cache so that fewer reads are necessary.

Arguments:

    ByteOffset  - Supplies where to start the read.
    BytesToRead - Supplies the number of bytes to read.

Return Value:

    None.

--*/
{
    HMEM    hmem;
    PVOID   buf;
    ULONG   bytes_read;

    if (hmem.Initialize() &&
        (buf = hmem.Acquire(BytesToRead))) {

        Read(buf, ByteOffset, BytesToRead, &bytes_read);
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Write (
   IN     PCVOID        Data,
   IN     BIG_INT       ByteOffset,
   IN     ULONG         BytesToWrite,
   OUT       PULONG        BytesWritten,
   IN OUT   PNTFS_BITMAP   Bitmap
   )

/*++

Routine Description:

    This method writes data to the attribute's value.

Arguments:

    Data            -- supplies the user's buffer containing data
                        to be written
    ByteOffset      -- supplies the byte offset within the attribute's
                        value at shich the write should commence.
    BytesToWrite    -- supplies the number of bytes to write.
    BytesWritten    -- receives the number of bytes written.
    Bitmap          -- supplies the volume bitmap.  This may be NULL.

Notes:

    If the user supplies a bitmap, Write will attempt to extend the
    attribute's allocation (if necessary) in order to complete the
    write.  If the user does not supply a bitmap, Write will fail if
    the write extends past the attribute value's allocated length.
    (It may or may not write some of the data.)

    Note that this method does not check the attribute's valid data
    length, but it does reset the valid data length if it writes
    past the valid data length.  Therefore, clients must use some
    caution to avoid introducing stretches of uninitialized data
    in the attribute (which would be a security leak).

    Note that if Write fails, the contents of the attribute on
    disk is undefined.

    Note also that Write is not supported for sparse files.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    BIG_INT TempBigInt;
    BIG_INT RunLength;
    BIG_INT OldValidDataLength;
    VCN CurrentVcn, RecentLcn;
    LCN CurrentLcn;
    PBYTE CurrentData;
    ULONG BytesToCopy, OffsetIntoCluster, CurrentRunLength;
    ULONG ClusterSize;
    ULONG RemainingRequest;
    ULONG BytesToZero;

    // First, make sure that the space allocated to the attribute
    // value is sufficient.

    if( CompareLT(QueryAllocatedLength(), ByteOffset + BytesToWrite) &&
        !Resize( ByteOffset + BytesToWrite, Bitmap ) ) {

        // This attribute does not have enough space allocated
        // to it to satisfy the write request, and we could not
        // extend the allocation, so the write fails.

        return FALSE;
    }

    // Now check the valid data length.  If the write begins
    // past the end of valid data, we have to fill the intervening
    // gap with zeroes.  Note that before we call Fill, we
    // must set the Valid Data Length appropriately, since Fill
    // just recurses back into Write.
    //
    if( CompareLT(_ValidDataLength, ByteOffset) ) {

        TempBigInt = ByteOffset - _ValidDataLength;

        if( TempBigInt.GetHighPart() != 0 ) {

            DebugPrint( "UNTFS: Writing discontiguous huge attribute.\n" );
            return FALSE;
        }

        BytesToZero = TempBigInt.GetLowPart();

        OldValidDataLength = _ValidDataLength;
        _ValidDataLength = ByteOffset;

        if( !Fill( OldValidDataLength, 0, BytesToZero ) ) {

            // Couldn't zero-fill the gap; restore Valid Data
            // Length and return failure.
            //
            _ValidDataLength = OldValidDataLength;
            return FALSE;
        }
    }


    if( _ResidentData != NULL ) {

        // Since the attribute value is resident, we can
        // just copy it.
        //
        DebugAssert( ByteOffset.GetHighPart() == 0 );

        memcpy( (PBYTE)_ResidentData + ByteOffset.GetLowPart(),
                Data,
                (UINT) BytesToWrite );

        SetStorageModified();
        ByteOffset += BytesToWrite;

    } else if ( _ExtentList != NULL ) {

        // Now we can actually start writing stuff!  First, we'll write
        // any partial leading cluster through an intermediate buffer.
        // Next, we write entire clusters directly from the user's buffer.
        // Finally, we write any partial trailing cluster.

        ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

        RemainingRequest = BytesToWrite;

        // RecentLcn is used in case we need to grab extents on the
        // fly--if we have to allocate space to fill in holes in a
        // sparse attribute, using RecentLcn will increase the probability
        // that the space we grab is close to the rest of the attribute.

        RecentLcn = 0;

        if( RemainingRequest > 0 ) {

            CurrentData = (PBYTE) Data;

            OffsetIntoCluster = (ByteOffset % ClusterSize).GetLowPart();

            if( OffsetIntoCluster != 0 ) {

                // We have a partial leading cluster, so we'll write
                // it through the intermediate buffer.  Note that we
                // must read the cluster in, copy the part we intend
                // to write, and then write it back out.

                BytesToCopy = MIN( BytesToWrite,
                                   ClusterSize - OffsetIntoCluster );

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   1,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            1 ) ||
                     !ClusterRun.Read() ) {

                    DebugPrint( "Could not read partial leading sector\n" );
                    return FALSE;
                }

                // We've read the cluster in question; copy the partial
                // leading cluster of our write request and write it
                // back out.

                memcpy( (PBYTE)ClusterRun.GetBuf() + OffsetIntoCluster,
                        CurrentData,
                        (UINT) BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write partial leading sector.\n" );
                    return FALSE;
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;

            }

            // Now transfer any complete clusters.  Because the
            // client's buffer may not be suitably aligned, we
            // have to cycle these through an intermediate buffer.

            while( RemainingRequest >= ClusterSize ) {

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( RunLength.GetHighPart() != 0 ||
                    RunLength.GetLowPart() >
                            MaximumClustersToTransfer ) {

                    CurrentRunLength = MaximumClustersToTransfer;

                } else {

                    CurrentRunLength = RunLength.GetLowPart();
                }

                if( CurrentRunLength * ClusterSize >
                    RemainingRequest ) {

                    CurrentRunLength = RemainingRequest/ClusterSize;
                }

                BytesToCopy = CurrentRunLength * ClusterSize;

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   CurrentRunLength,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            CurrentRunLength ) ) {


                    DebugPrint( "Could not get memory to write user data.\n" );
                    return FALSE;
                }

                memcpy( IntermediateBuffer.GetBuf(),
                        CurrentData,
                        BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write complete clusters.\n" );
                    return FALSE;
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            if( RemainingRequest > 0 ) {

                // OK, we have a partial trailing cluster.  Write
                // it through the intermediate buffer.  Again,
                // we have to read the cluster, copy the data,
                // and write the cluster back out.

                BytesToCopy = RemainingRequest;

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   1,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            1 ) ||
                    !ClusterRun.Read() ) {

                    DebugPrint( "Failure getting LCN or intermediat buffer.\n" );
                    return FALSE;
                }

                // We've read the cluster in question; copy the partial
                // leading cluster of our write request and write it
                // back out.

                memcpy( ClusterRun.GetBuf(),
                        CurrentData,
                        (UINT) BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write trailing partial cluster.\n" );
                    DebugPrintTrace(("Status: %x\n", _Drive->QueryLastNtStatus()));
                    DebugPrintTrace(("LCN: %x\n", CurrentLcn.GetLowPart()));
                    return FALSE;
                }

                // Update ByteOffset, since it may be used to check
                // _ValidDataLength below.

                ByteOffset += RemainingRequest;
            }
        }

    } else {

        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }

    if( CompareLT(_ValidDataLength, ByteOffset) ) {

        _ValidDataLength = ByteOffset;
        SetStorageModified();
    }

    if( CompareLT(_ValueLength, ByteOffset) ) {

        _ValueLength = ByteOffset;
        SetStorageModified();
    }

    *BytesWritten = BytesToWrite;
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::Fill (
    IN BIG_INT  Offset,
    IN CHAR     FillCharacter
    )
/*++

Routine Description:

    This method fills the attribute with the specified character
    from the given offset until the end of the attribute.

Arguments:

    Offset          --  Starting offset to begin the fill.
    FillCharacter   --  Supplies the character that will be written
                        to every byte of the attribute value.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will fail if it is used on an attribute which has a size
    greater than MAXULONG.

--*/
{
    BIG_INT TempBigInt;

    if( Offset >= QueryValueLength() )  {

        // Nothing to do.
        //
        return TRUE;
    }

    // Fill to the end of the attribute--compute the number of
    // bytes in the attribute starting at Offset.  Make sure
    // that the amount to fill fits in a ULONG.
    //
    TempBigInt = QueryValueLength() - Offset;

    if( TempBigInt.GetHighPart() != 0 ) {

        DebugPrint( "UNTFS: Trying to fill a very large attribute.\n" );
        return FALSE;
    }

    return( Fill( Offset, FillCharacter, TempBigInt.GetLowPart() ) );
}


BOOLEAN
NTFS_ATTRIBUTE::Fill (
    IN BIG_INT  Offset,
    IN CHAR     FillCharacter,
    IN ULONG    NumberOfBytes
    )
/*++

Routine Description:

    This method fills the attribute with the specified character
    from the given offset for the specified number of bytes.

Arguments:

    Offset          --  Starting offset to begin the fill.
    FillCharacter   --  Supplies the character that will be written
                        to every byte of the attribute value.
    NumberOfBytes   --  Number of bytes to fill.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will fail if it is used on an attribute which has a size
    greater than MAXULONG.

--*/
{
    PVOID FillBuffer;
    ULONG BytesRemaining, FillBufferSize, BytesToWrite, BytesWritten;
    BOOLEAN Result;

    CONST ULONG MaximumBufferSize = 0x10000;

    if( Offset > QueryValueLength() ) {

        DebugPrint( "UNTFS: Filling an attribute starting past end.\n" );
        return TRUE;
    }

    // Get a buffer to fill with the fill character.  Start out by
    // requesting the full amount; if we can't get it, keep asking
    // for smaller amounts.
    //
    BytesRemaining = NumberOfBytes;
    FillBufferSize = min( BytesRemaining, MaximumBufferSize );

    while( FillBufferSize > 0 &&
           (FillBuffer = MALLOC( FillBufferSize )) == NULL ) {

        FillBufferSize /= 2;
    }

    // If we couldn't get a buffer, fail.
    //
    if( FillBufferSize == 0 || FillBuffer == NULL ) {

        return FALSE;
    }

    // Fill the buffer with the fill character.
    //
    memset( FillBuffer,
            FillCharacter,
            FillBufferSize );

    // Chug through the attribute, writing each chunk until we hit
    // a failure or reach the end.
    //
    Result = TRUE;

    while( BytesRemaining > 0 && Result ) {

        // Write the lesser of our buffer size or the remainder
        // of the attribute.  Note that we pass NULL for the
        // bitmap parameter to Write, since this write should
        // not affect the allocated length of the buffer.
        //
        BytesToWrite = min( BytesRemaining, FillBufferSize );

        if( !Write( FillBuffer,
                    Offset,
                    BytesToWrite,
                    &BytesWritten,
                    NULL ) ||
            BytesWritten != BytesToWrite ) {

            DebugPrintTrace(("Write failed in NTFS_ATTRIBUTE::Fill with status %x\n",
                             GetDrive()->QueryLastNtStatus()));
            Result = FALSE;
        }

        Offset += BytesToWrite;
        BytesRemaining -= BytesToWrite;
    }

    FREE( FillBuffer );
    return Result;
}



BOOLEAN
NTFS_ATTRIBUTE::RecoverAttribute(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusters,
    OUT    PBIG_INT     BytesRecovered
    )
/*++

Routine Description:

    This method recovers an attribute.  Recovery consists of reading each
    cluster in the attribute value, and replacing it with a cluster full
    of zeroes if it is unreadable.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusters     --  receives the bad clusters identified by this method.
    BytesRecovered  --  receives the number of bytes recovered (not
                        mapped out).  This parameter may be NULL, in
                        which case this information is not returned.
                        Note that if the method returns FALSE, this
                        parameter's contents will be undefined.

Notes:

    This method should not be called for any system-defined attribute
    other than $DATA.

    Recover for resident attributes is trivial.

--*/
{
    HMEM MultiClusterMem, SingleClusterMem;
    NTFS_CLUSTER_RUN MultiClusterRun, SingleClusterRun;
    VCN StartingVcn, ClustersAttempted, BadVcn;
    LCN StartingLcn;
    BIG_INT RunLength, dVcn;
    ULONG CurrentRunLength;
    ULONG ExtentNumber, i, j;
    BOOLEAN FoundBad;
    LCN NewLcn;
    BIG_INT OldOffset;
    ULONG ClusterSize;
    ULONG MaxClusters, Take;
    BOOLEAN AllHoles = TRUE;
    VCN     LastStartingVcn;
    BIG_INT LastRunLength;

    // Compressed attributes receive special handling.
    //
    if (IsCompressed() && !IsResident()) {

        return RecoverCompressedAttribute( VolumeBitmap, BadClusters,
                                           BytesRecovered );
    }

    if( _ExtentList == NULL ) {

        // The attribute is resident--Recover is a no-op.
        //
        if( BytesRecovered != NULL ) {

            *BytesRecovered = QueryValueLength();
        }

        return TRUE;
    }

    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();
    MaxClusters = 0x10000/ClusterSize;

    if( !MultiClusterMem.Initialize() ||
        !MultiClusterRun.Initialize( &MultiClusterMem,
                                     GetDrive(),
                                     0,
                                     QueryClusterFactor(),
                                     MaxClusters ) ||
        !SingleClusterMem.Initialize() ||
        !SingleClusterRun.Initialize( &SingleClusterMem,
                                      GetDrive(),
                                      0,
                                      QueryClusterFactor(),
                                      1 ) ) {
        // insufficient memory.

        return FALSE;
    }


    // Initialize the counters.
    //
    ExtentNumber = 0;
    ClustersAttempted = 0;

    if( BytesRecovered != NULL ) {

        *BytesRecovered = 0;
    }

    while( _ExtentList->QueryExtent( ExtentNumber,
                                     &StartingVcn,
                                     &StartingLcn,
                                     &RunLength ) ) {

        if( RunLength.GetHighPart() != 0 ) {

            DebugPrint( "NTFS_ATTRIBUTE::Recover--RunLength > Max ULONG )\n" );
            return FALSE;
        }

        if (StartingLcn == LCN_NOT_PRESENT) {
            ExtentNumber += 1;
            continue;
        }

        AllHoles = FALSE;
        LastStartingVcn = StartingVcn;
        LastRunLength = RunLength;

        // Read the extent in chunks until we get a bad sector
        // (read failure) or run out.
        //
        CurrentRunLength = RunLength.GetLowPart();

        FoundBad = FALSE;

        Take = MaxClusters;
        for( i = 0; i < CurrentRunLength && !FoundBad; i += Take ) {

            Take = min(MaxClusters, CurrentRunLength - i);

            MultiClusterRun.Initialize( &MultiClusterMem,
                                        GetDrive(),
                                        StartingLcn + i,
                                        QueryClusterFactor(),
                                        Take );

            if( MultiClusterRun.Read() ) {

                // This whole run of clusters is good.  If this
                // range of VCNs has not already been attempted,
                // update the count of bytes recovered.
                //
                if( BytesRecovered &&
                    StartingVcn + i + Take > ClustersAttempted ) {

                    dVcn = StartingVcn + i + Take - ClustersAttempted;
                    OldOffset = ClustersAttempted * ClusterSize;

                    ClustersAttempted += dVcn;

                    if( OldOffset + dVcn * ClusterSize < QueryValueLength() ) {

                        *BytesRecovered += dVcn * ClusterSize;

                    } else if( OldOffset < QueryValueLength() ) {

                        *BytesRecovered += QueryValueLength() - OldOffset;
                    }
                }

            } else {

                // Check each of the clusters individually.
                //
                for( j = 0; j < Take && !FoundBad; j++ ) {

                    SingleClusterRun.Relocate( StartingLcn + i + j );

                    if( SingleClusterRun.Read() ) {

                        // This cluster is good.  Update the total
                        // of bytes recovered.
                        //
                        if( BytesRecovered &&
                            StartingVcn + i + j + 1 > ClustersAttempted ) {

                            OldOffset = ClustersAttempted * ClusterSize;
                            ClustersAttempted += 1;

                            if( OldOffset+ClusterSize < QueryValueLength() ) {

                                *BytesRecovered += ClusterSize;

                            } else if( OldOffset < QueryValueLength() ) {

                                *BytesRecovered += QueryValueLength() -
                                                                OldOffset;
                            }
                        }

                    } else {

                        // Found a bad cluster.  Allocate a replacement
                        // for it, fill the replacement with zeroes, and
                        // splinter the extent.  Note that we don't check
                        // the return value of the write; instead, on the
                        // next iteration, we'll check this VCN again.
                        //
                        FoundBad = TRUE;
                        BadVcn = StartingVcn + i + j;

                        if( BytesRecovered &&
                            ClustersAttempted < BadVcn + 1 ) {

                            ClustersAttempted = BadVcn + 1;
                        }

                        if( !VolumeBitmap->AllocateClusters( StartingLcn,
                                                             1,
                                                             &NewLcn) ) {

                            return FALSE;
                        }

                        SingleClusterRun.Relocate( NewLcn );

                        memset( SingleClusterMem.GetBuf(),
                                '\0',
                                GetDrive()->QuerySectorSize() *
                                                QueryClusterFactor() );

                        SingleClusterRun.Write();

                        _ExtentList->DeleteExtent( ExtentNumber );

                        if( ( i + j > 0 &&
                              !AddExtent( StartingVcn,
                                          StartingLcn,
                                          i + j ) ) ||
                            !AddExtent( BadVcn, NewLcn, 1 ) ||
                            ( i + j + 1 < CurrentRunLength &&
                              !AddExtent( StartingVcn + i + j + 1,
                                          StartingLcn + i + j + 1,
                                          CurrentRunLength - (i + j + 1) ) ) ) {

                            DebugPrint( "RECOVER: couldn't splinter extent." );
                            return FALSE;
                        }

                        // Add the bad cluster to the list of identified
                        // bad clusters, and remember that the attribute's
                        // storage has been modified.
                        //
                        if( !BadClusters->Add( StartingLcn + i + j ) ) {

                            return FALSE;
                        }

                        SetStorageModified();
                    }
                }
            }
        }

        // If we processed this entire extent without finding any bad
        // sectors, update the count of bytes recovered and go on to
        // the next one.  Otherwise, try this one again.
        //
        if( !FoundBad ) {

            ExtentNumber += 1;
        }
    }

    if (BytesRecovered) {
        //
        // fix up BytesRecovered for sparse looking (including encrypted) file
        //
        if (AllHoles) {
            DebugAssert(*BytesRecovered == 0);
            *BytesRecovered = QueryValueLength();
        } else {
            OldOffset = (LastStartingVcn + LastRunLength)*ClusterSize;
            if (OldOffset < QueryValueLength()) {
                //
                // Hole at the end of the extent list
                //
                *BytesRecovered += (QueryValueLength() - OldOffset);
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::MarkAsAllocated(
    IN OUT  PNTFS_BITMAP    VolumeBitmap
    ) CONST
/*++

Routine Description:

    This routine allocated the space taken by this attribute in the
    given Volume Bitmap.  If any of the space taken by this attribute is
    beyond the range of the given bitmap then this routine will fail
    without allocating any new space in the bitmap.

    This routine allocates the space in the bitmap regardless of whether
    or not this space is already allocated in the bitmap.

Arguments:

    VolumeBitmap    - Supplies the bitmap which to mark the allocation.

Return Value:

    FALSE   - The space requested is beyond the natural range of the
                given bitmap.
    TRUE    - Success.

--*/
{
    ULONG   num_extents;
    ULONG   i;
    VCN     next_vcn;
    LCN     current_lcn;
    BIG_INT run_length;


    DebugAssert(VolumeBitmap);


    // If the attribute is resident then we have already succeeded.

    if (!_ExtentList) {
        return TRUE;
    }


    num_extents = _ExtentList->QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!_ExtentList->QueryExtent(i, &next_vcn, &current_lcn,
                                      &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        if (!VolumeBitmap->IsInRange(current_lcn, run_length)) {
            return FALSE;
        }
    }

    for (i = 0; i < num_extents; i++) {

        if (!_ExtentList->QueryExtent(i, &next_vcn, &current_lcn,
                                      &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            return FALSE;
        }

        VolumeBitmap->SetAllocated(current_lcn, run_length);
    }

    return TRUE;
}


BOOLEAN
AccountForBadClusters(
    IN      LCN                 Lcn,
    IN      BIG_INT             RunLength,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    OUT     PBOOLEAN            SomeWereBad,
    IN OUT  PNUMBER_SET         BadClusters
    )
/*++

Routine Description:

    This routine read through the given run of clusters.  The clusters
    that are bad are added to the list of BadClusters and marked
    as allocated in the volume bitmap.  The clusters which are good are
    marked free in the volume bitmap.

Arguments:

    Lcn                 - Supplies the first logical cluster number.
    RunLength           - Supplies the length of the run.
    VolumeBitmap        - Supplies the volume bitmap.
    Drive               - Supplies the drive.
    ClusterFactor       - Supplies the cluster factor.
    SomeWereBad         - Returns whether or not any clusters were bad.
    BadClusters   - Supplies the list of bad volume clusters.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                hmem;
    NTFS_CLUSTER_RUN    clusrun;
    BIG_INT             i;
    LCN                 sup;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    *SomeWereBad = FALSE;

    sup = Lcn + RunLength;
    for (i = Lcn; i < sup; i += 1) {

        if (!clusrun.Initialize(&hmem, Drive, i, ClusterFactor, 1)) {
            return FALSE;
        }

        if (clusrun.Read()) {

            VolumeBitmap->SetFree(i, 1);

        } else {

            VolumeBitmap->SetAllocated(i, 1);

            *SomeWereBad = TRUE;

            if (!BadClusters->Add(i)) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::Hotfix(
    IN      VCN                 Vcn,
    IN      BIG_INT             RunLength,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusters,
    IN      BOOLEAN             Contiguous
    )
/*++

Routine Description:

    This routine replaces the cluster run specified by 'Vcn' and
    'RunLength' with new readable clusters allocated from
    'VolumeBitmap'.

    If 'Contiguous' is TRUE then the readable clusters will be allocated
    from the bitmap in one contiguous run.

    If 'BadClusters' is specified then the logical cluster numbers
    of all of the bad clusters detected by this routine will be added
    to this list.  This does not include the run to hotfix.

Arguments:

    Vcn             - Supplies the first vcn of the run to hotfix.
    RunLength       - Supplies the number of clusters to hotfix.
    VolumeBitmap    - Supplies a valid volume bitmap from which to
                        allocate new clusters.
    BadClusters     - Supplies a list to which to add the bad clusters
                        of the volume.
    Contiguous      - Supplies whether or not the new clusters must be
                        contiguous.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT             alloc_size;
    BIG_INT             total_so_far;
    LCN                 first_lcn;
    BOOLEAN             some_were_bad;
    NTFS_EXTENT_LIST    new_stuff;
    NTFS_EXTENT_LIST    backup_copy;
    VCN                 i;
    VCN                 vcn;
    LCN                 lcn;
    BIG_INT             run_length;
    ULONG               j;
    ULONG               num_extents;


    DebugAssert(RunLength != 0);

    if (!_ExtentList) {
        return FALSE;
    }

    if (!new_stuff.Initialize(0, 0) ||
        !backup_copy.Initialize(_ExtentList)) {

        return FALSE;
    }

    // Allocate the space necessary on the bitmap making sure that
    // the sectors are good.

    alloc_size = RunLength;
    total_so_far = 0;

    while (total_so_far < RunLength) {

        if (VolumeBitmap->AllocateClusters(0, alloc_size, &first_lcn)) {

            if (!AccountForBadClusters(first_lcn, alloc_size,
                                       VolumeBitmap, GetDrive(),
                                       QueryClusterFactor(),
                                       &some_were_bad,
                                       BadClusters)) {

                return FALSE;
            }

            if (some_were_bad) {
                continue;
            }

            VolumeBitmap->SetAllocated(first_lcn, alloc_size);

            if (!new_stuff.AddExtent(Vcn + total_so_far,
                                     first_lcn,
                                     alloc_size)) {

                return FALSE;
            }

            total_so_far += alloc_size;

            alloc_size = min(alloc_size, RunLength - total_so_far);

        } else {

            if (Contiguous || alloc_size == 1) {
                return FALSE;
            }

            alloc_size = alloc_size/2;
        }
    }


    // Delete the given range of VCN's from the extent list.

    if (!_ExtentList->DeleteRange(Vcn, RunLength)) {
        return FALSE;
    }


    // Now insert the extents into the extent list.

    num_extents = new_stuff.QueryNumberOfExtents();

    for (j = 0; j < num_extents; j++) {

        if (!new_stuff.QueryExtent(j, &vcn, &lcn, &run_length) ||
            !_ExtentList->AddExtent(vcn, lcn, run_length)) {

            _ExtentList->Initialize(&backup_copy);
            return FALSE;
        }
    }

	SetStorageModified();	
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::ReplaceVcns(
    IN  VCN     StartingVcn,
    IN  LCN     NewLcn,
    IN  BIG_INT NumberOfClusters
    )
/*++

Routine Description:

    This routine replaces the VCNs specified by 'StartingVcn' and
    'NumberOfClusters' with the contiguous run that starts at
    'NewLcn'.

Arguments:

    StartingVcn         - Supplies the starting vcn to replace.
    NewLcn              - Supplies a run of 'NumberOfClusters' clusters.
    NumberOfClusters    - Supplies the number of clusters to replace.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_ExtentList->DeleteRange(StartingVcn, NumberOfClusters)) {
        return FALSE;
    }

    if (!_ExtentList->AddExtent(StartingVcn, NewLcn, NumberOfClusters)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
operator==(
    IN  RCNTFS_ATTRIBUTE    Left,
    IN  RCNTFS_ATTRIBUTE    Right
    )
/*++

Routine Description:

    This routine computes whether or not the two given attributes are
    equal.

Arguments:

    Left    - Supplies the left argument.
    Right   - Supplies the right argument.

Return Value:

    FALSE   - The given attributes are not equal.
    TRUE    - The given attributes are equal.

--*/
{
    VCN                 left_vcn, right_vcn;
    LCN                 left_lcn, right_lcn;
    BIG_INT             left_length, right_length;
    ULONG               num_extents;
    PNTFS_EXTENT_LIST   left_list;
    PNTFS_EXTENT_LIST   right_list;
    ULONG               i;

    if (Left._ClusterFactor != Right._ClusterFactor ||
        Left._Type != Right._Type ||
        Left._Name.Strcmp(&Right._Name) ||
        Left._Flags != Right._Flags ||
        Left._FormCode != Right._FormCode ||
        Left._ValueLength != Right._ValueLength ||
        Left._ValidDataLength != Right._ValidDataLength ||
        Left._ResidentFlags != Right._ResidentFlags) {

        return FALSE;
    }

    if (Left._ResidentData) {

        if (!Right._ResidentData) {
            return FALSE;
        }

        return !memcmp(Left._ResidentData,
                       Right._ResidentData,
                       (UINT) Left._ValueLength.GetLowPart());
    }

    DebugAssert(Left._ExtentList);
    DebugAssert(Right._ExtentList);

    left_list = Left._ExtentList;
    right_list = Right._ExtentList;

    if (left_list->QueryNumberOfExtents() !=
            right_list->QueryNumberOfExtents() ||
        left_list->QueryLowestVcn() != right_list->QueryLowestVcn() ||
        left_list->QueryNextVcn() != right_list->QueryNextVcn()) {

        return FALSE;
    }

    num_extents = left_list->QueryNumberOfExtents();

    for (i = 0; i < num_extents; i += 1) {

        if (!left_list->QueryExtent(i, &left_vcn, &left_lcn, &left_length) ||
            !right_list->QueryExtent(i, &right_vcn, &right_lcn, &right_length) ||
            left_vcn != right_vcn ||
            left_lcn != right_lcn ||
            left_length != right_length) {

            return FALSE;
        }
    }

    return TRUE;
}


BIG_INT
NTFS_ATTRIBUTE::QueryClustersAllocated(
    ) CONST
/*++

Routine Description:

    This routine computes the number of clusters allocated for this
    attribute.

Arguments:

    None.

Return Value:

    The number of clusters allocated by this attribute.

--*/
{
    BIG_INT r;

    if (_ExtentList) {
        r = _ExtentList->QueryClustersAllocated();
    } else {
        r = 0;
    }

    return r;
}



BOOLEAN
NTFS_ATTRIBUTE::InsertMftDataIntoFile (
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   BaseFileRecordSegment,
    IN OUT  PNTFS_BITMAP                Bitmap OPTIONAL,
    IN      BOOLEAN                     BeConservative
    )
/*++

Routine Description:

    This method inserts the MFT Data attribute into a File Record
    Segment (presumably FRS 0).  It is a private worker method for
    InsertIntoFile.

Arguments:

    FileRecordSegment   --  Supplies the File Record Segment into
                            which the attribute will jam itself.
    Bitmap              --  Supplies the volume bitmap.
    BeConservative      --  Supplies a flag which indicates, if TRUE,
                            that the attribute should try to leave free
                            space in the File Record Segments (to leave
                            room for changes due to hotfixing).  If this
                            flag is FALSE, the attribute will make each
                            attribute record as large as it can.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE_RECORD AttributeRecord;
    PVOID AttributeRecordData;
    BOOLEAN Result;
    ULONG MaxSize;
    ULONG MaxExtentsSize, CurrentMaxExtentsSize;
    NTFS_EXTENT_LIST source;
    NTFS_EXTENT_LIST result;
    NTFS_EXTENT_LIST remainder;
    BOOLEAN FirstChunkInserted = FALSE;
    BOOLEAN Completed = FALSE;

    // Allocate a buffer to hold attribute records.  If we're being
    // conservative, reduce the size of the maximum record by 1/8.
    //
    MaxSize = BaseFileRecordSegment->QueryMaximumAttributeRecordSize();

    if( BeConservative ) {

        // Reduce the maximum record size by 1/8 of the FRS size,
        // to allow for hotfixing and other changes.
        //
        MaxSize -= BaseFileRecordSegment->QuerySize()/8;
    }

    if( (AttributeRecordData = MALLOC( (UINT) MaxSize )) == NULL ) {

        return FALSE;
    }


    // The MFT data attribute must be resident.
    //
    if( _ResidentData != NULL ) {

        if( !AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize ) ) {

            FREE( AttributeRecordData );
            return FALSE;
        }

        // The attribute value is resident.  Package up a resident
        // attribute record.

        Result = AttributeRecord.
                    CreateResidentRecord( _ResidentData,
                                          _ValueLength.GetLowPart(),
                                          _Type,
                                          &_Name,
                                          _Flags,
                                          _ResidentFlags );

        //
        // Check to see if there is enough space to Create a resident record
        //

        if (Result) {
            Result = BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );

            FREE( AttributeRecordData );
            return Result;
        } else {
            // Not enough space to do so, make attribute record non-resident
            if (IsIndexed() || !Bitmap || !MakeNonresident(Bitmap)) {
               FREE( AttributeRecordData );
               return FALSE;
            }
        }
    }

    // Compute the maximum number of bytes in an extent list.
    //
    MaxExtentsSize = MaxSize - SIZE_OF_NONRESIDENT_HEADER;
    if (_Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE)) {
        MaxExtentsSize -= sizeof(BIG_INT);
    }
    MaxExtentsSize -= QuadAlign(_Name.QueryChCount());

    // The first chunk of the MFT's DATA attribute gets
    // special treatment, since it has to fit into the
    // Base FRS.  If our first attempt doesn't fit, we
    // keep whittling it down until it does or until we
    // run out of possibilities.
    //
    CurrentMaxExtentsSize = MaxExtentsSize;

    Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );

    while( Result && !FirstChunkInserted ) {

        // Partition the extent list.
        //
        if( PartitionExtentList( _ExtentList,
                                 CurrentMaxExtentsSize,
                                 &result,
                                 &remainder ) ) {

            if( !AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit ) ||
                !BaseFileRecordSegment->
                        InsertAttributeRecord( &AttributeRecord ) ) {

                // This partition didn't work.  Try a smaller one.
                //
                CurrentMaxExtentsSize /= 2;

                if( CurrentMaxExtentsSize == 0 ) {

                    Result = FALSE;
                }

            } else {

                // Successfully inserted first chunk.  Set up
                // source to continue inserting the remaining
                // chunks.
                //
                FirstChunkInserted = TRUE;

                if (remainder.IsEmpty()) {

                    Completed = TRUE;

                } else {

                    Result = source.Initialize(&remainder);
                }
            }

        } else {

            Result = FALSE;
        }
    }



    while (Result && !Completed) {

        // Initialize attribute record.

        Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );


        // Partition extent list into two pieces, the first of which
        // can be made into an attribute record.

        Result = Result &&
                 PartitionExtentList(&source,
                                     MaxExtentsSize,
                                     &result,
                                     &remainder);


        // Create the attribute record.

        Result = Result &&
                 AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit );


        // If we were able to package it up, then give the attribute
        // record to the File Record Segment.

        Result = Result &&
                 BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );


        // If all of the extents fit in the last record then we are done.

        if (remainder.IsEmpty()) {

            Completed = TRUE;

        } else {

            Result = Result &&
                    source.Initialize(&remainder);
        }
    }


    ResetStorageModified();
    FREE( AttributeRecordData );
    return Result;
}


BOOLEAN
NTFS_ATTRIBUTE::RecoverCompressedAttribute(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusters,
    OUT    PBIG_INT     BytesRecovered
    )
/*++

Routine Description:

    This method is a private helper function for RecoverAttribute;
    it is invoked if the attribute is compressed.  Recovery consists
    of reading each cluster in the attribute value, and replacing it
    with a cluster full of zeroes if it is unreadable.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusters     --  receives the bad clusters identified by this method.
    BytesRecovered  --  receives the number of bytes recovered (not
                        mapped out).  This parameter may be NULL, in
                        which case this information is not returned.
                        Note that if the method returns FALSE, this
                        parameter's contents will be undefined.

Return Value:

    TRUE upon successful completion.

--*/
{
    HMEM             ClusterMem, OneClusterMem;
    NTFS_CLUSTER_RUN ClusterRun, OneCluster;
    VCN              CurrentVcn, Vcn;
    LCN              Lcn, lcnStart, lcnEnd;
    BIG_INT          RunLength, j;
    ULONG            i;
    ULONG            BytesPerCluster, ClustersPerCompressionUnit, ClustersRemaining;
    ULONG            CompressedClusters, ThisRun, UncompressedSize, Holes;
    BOOLEAN          DiscardThisUnit;
    PUCHAR           CompressedBuffer, UncompressedBuffer;
    NTSTATUS         Status;


    if (IsResident() || !IsCompressed()) {

        DebugPrintTrace(( "UNTFS: RecoverCompressedAttribute called for non-compressed attribute.\n" ));
        return FALSE;
    }

    if( !OneClusterMem.Initialize() ||
        !OneCluster.Initialize( &OneClusterMem,
                                GetDrive(),
                                0,
                                QueryClusterFactor(),
                                1 ) ) {

        return FALSE;
    }

    if( BytesRecovered ) {

        *BytesRecovered = 0;
    }

    ClustersPerCompressionUnit = 1 << QueryCompressionUnit();
    BytesPerCluster = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    CompressedBuffer = (PUCHAR)MALLOC( ClustersPerCompressionUnit * BytesPerCluster );
    UncompressedBuffer = (PUCHAR)MALLOC( ClustersPerCompressionUnit * BytesPerCluster );

    if( CompressedBuffer == NULL || UncompressedBuffer == NULL ) {

        CompressedBuffer   ? FREE( CompressedBuffer )   : 0;
        UncompressedBuffer ? FREE( UncompressedBuffer ) : 0;
        return FALSE;
    }

    ClustersRemaining = QueryAllocatedLength().GetLowPart()/BytesPerCluster;
    CurrentVcn = 0;

    while( ClustersRemaining ) {

        DiscardThisUnit = FALSE;

        if( ClustersRemaining < ClustersPerCompressionUnit ) {

            ClustersPerCompressionUnit = ClustersRemaining;
        }

        CompressedClusters = 0;
        Holes = 0;

        while( CompressedClusters + Holes < ClustersPerCompressionUnit ) {

            if( !QueryLcnFromVcn( CurrentVcn + CompressedClusters + Holes,
                                  &Lcn,
                                  &RunLength ) ) {

                // No more clusters in this compression unit.
                // Check to make sure that the gap covers at
                // least the rest of the compression unit.
                //

                if( CompressedClusters + Holes < ClustersPerCompressionUnit ) {

                    DebugPrintTrace(( "UNTFS: malformed compression unit at VCN 0x%I64x\n",
                                      CurrentVcn.GetLargeInteger() ));
                    DiscardThisUnit = TRUE;
                }
                break;
            }

            if( Lcn == LCN_NOT_PRESENT ) {

                Holes += RunLength.GetLowPart();
                continue;
            }

            if( CompressedClusters + RunLength.GetLowPart() >
                    ClustersPerCompressionUnit ) {

                ThisRun = ClustersPerCompressionUnit - CompressedClusters;

            } else {

                ThisRun = RunLength.GetLowPart();
            }

            if( !ClusterMem.Initialize() ||
                !ClusterRun.Initialize( &ClusterMem,
                                        GetDrive(),
                                        Lcn,
                                        QueryClusterFactor(),
                                        ThisRun ) ) {

                FREE( CompressedBuffer );
                FREE( UncompressedBuffer );
                return FALSE;
            }

            if( !ClusterRun.Read() ) {

                // There's a bad sector in here.  Read the clusters
                // one at a time to see which ones are bad.
                //
                for( i = 0; i < ThisRun; i++ ) {

                    OneCluster.Relocate( Lcn + i );

                    if( !OneCluster.Read() ) {

                        // This one's bad--add it to the bad block list.
                        //
                        BadClusters->Add( Lcn + i );
                    }
                }

                DebugPrintTrace(( "UNTFS: unreadable compression unit at VCN 0x%I64x\n",
                                  (CurrentVcn + CompressedClusters + Holes).GetLargeInteger() ));
                DiscardThisUnit = TRUE;

            } else {

                // Copy this run into the compressed buffer.
                //
                memcpy( CompressedBuffer + CompressedClusters * BytesPerCluster,
                        ClusterRun.GetBuf(),
                        ThisRun * BytesPerCluster );

            }

            CompressedClusters += ThisRun;
        }

        if( !DiscardThisUnit &&
            CompareLT(CurrentVcn * BytesPerCluster, QueryValidDataLength()) &&
            CompressedClusters != 0 &&
            CompressedClusters != ClustersPerCompressionUnit ) {

            // The clusters can all be read--see if they can be
            // decompressed.
            //
            Status = RtlDecompressBuffer( COMPRESSION_FORMAT_LZNT1,
                                          UncompressedBuffer,
                                          ClustersPerCompressionUnit * BytesPerCluster,
                                          CompressedBuffer,
                                          CompressedClusters * BytesPerCluster,
                                          &UncompressedSize );

            // If the RTL compression routines are not implemented,
            // assume that the compressed data is just fine.
            //
            if( Status != STATUS_NOT_IMPLEMENTED &&
                Status != STATUS_NOT_SUPPORTED   &&
                !NT_SUCCESS( Status ) ) {

                // Can't decompress it.
                //
                DebugPrintTrace(( "UNTFS: RtlDecompressBuffer failed--status 0x%x\n", Status ));
                DiscardThisUnit = TRUE;
            }
        }

        if( DiscardThisUnit ) {

            // Replace this compression unit with a gap.
            // Walk through all the extents, clipping any
            // extent that intersects the discarded unit.
            //
            SetStorageModified();

            i = 0;

            while( _ExtentList->QueryExtent( i,
                                             &Vcn,
                                             &Lcn,
                                             &RunLength ) ) {

                if( Lcn == LCN_NOT_PRESENT ) {

                    i++;
                    continue;
                }

                if( Vcn >= CurrentVcn + ClustersPerCompressionUnit ) {

                    // We're done.
                    //
                    break;
                }

                if( Vcn + RunLength <= CurrentVcn ) {

                    // This run does not overlap the discarded
                    // segment.  Try the next one.
                    //
                    i++;
                    continue;
                }

                _ExtentList->DeleteExtent( i );

                if( Vcn < CurrentVcn) {

                    if (!_ExtentList->AddExtent( Vcn,
                                                 Lcn,
                                                 CurrentVcn - Vcn ) ) {

                        FREE( CompressedBuffer );
                        FREE( UncompressedBuffer );
                        return FALSE;
                    }
                    lcnStart = Lcn + (CurrentVcn - Vcn);
                } else
                    lcnStart = Lcn;

                if( Vcn + RunLength > CurrentVcn + ClustersPerCompressionUnit) {

                    lcnEnd = Lcn + (CurrentVcn - Vcn) + ClustersPerCompressionUnit;
                    if (!_ExtentList->AddExtent( CurrentVcn + ClustersPerCompressionUnit,
                                                 lcnEnd,
                                                 RunLength - (CurrentVcn - Vcn) -
                                                 ClustersPerCompressionUnit ) ) {

                        FREE( CompressedBuffer );
                        FREE( UncompressedBuffer );
                        return FALSE;
                    }
                } else
                    lcnEnd = Lcn + RunLength;

                // Free stuff in the bitmap.
                //
                for( j = lcnStart; j < lcnEnd; j = j + 1) {

                    if( !BadClusters->DoesIntersectSet( j, 1 ) ) {

                        // this cluster was not added to the bad clusters,
                        // it has become free.
                        //
                        VolumeBitmap->SetFree( j, 1 );
                    }
                }

                // Don't advance to the next extent, since we may have
                // deleted this entire extent.
            }

        } else {

            if( BytesRecovered &&
                CurrentVcn * BytesPerCluster < QueryValueLength() ) {

                if( CurrentVcn * BytesPerCluster +
                        ClustersPerCompressionUnit * BytesPerCluster >
                    QueryValueLength() ) {

                    *BytesRecovered += QueryValueLength() - CurrentVcn * BytesPerCluster;

                } else {

                    *BytesRecovered += ClustersPerCompressionUnit * BytesPerCluster;
                }
            }
        }

        ClustersRemaining -= ClustersPerCompressionUnit;
        CurrentVcn += ClustersPerCompressionUnit;
    }

    FREE( CompressedBuffer );
    FREE( UncompressedBuffer );
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::IsAllocationZeroed(
    OUT PBOOLEAN  Error
    )
/*++

Routine Description:

    This routine reads the attribute value and checks whether all the
    bytes in the allocation are zeros.

Arguments:

    Error   - if this routine returns false, check error to see if it
              encountered an error trying to read the attribute.

Return Value:

    TRUE if all zeroes, FALSE otherwise.

--*/
{
    CONST   MaxNumBytesToCheck = 65536;
    ULONG   num_bytes, chomp_length, bytes_read, disk_bytes;
    ULONG   bytes_left;
    PUCHAR  buf;
    PBYTE   p1, p2;
    ULONG   i, j;
    BOOLEAN error;

    DebugAssert(QueryValueLength().GetHighPart() == 0);

    if (NULL != Error) {
        *Error = FALSE;
    } else {
        Error = &error;
    }

    disk_bytes = QueryValueLength().GetLowPart();

    if (NULL == (buf = NEW UCHAR[min(MaxNumBytesToCheck, disk_bytes)])) {

        *Error = TRUE;
        return FALSE;
    }

    for (i = 0; i < disk_bytes; i += MaxNumBytesToCheck) {

        chomp_length = min(MaxNumBytesToCheck, disk_bytes - i);

        if (!Read(buf, i, chomp_length, &bytes_read) ||
            bytes_read != chomp_length) {

            *Error = TRUE;
            DELETE_ARRAY(buf);
            return FALSE;
        }

        for (j = 0; j < chomp_length; j++) {

            if (buf[j] != 0) {
                DELETE_ARRAY(buf);
                return FALSE;
            }
        }
    }

    DELETE_ARRAY(buf);
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::GetNextAllocationOffset(
    IN OUT PBIG_INT     ByteOffset,
    IN OUT PBIG_INT     Length
    )
/*++

Routine Description:

    This routine locates the next allocation offset and allocation length of a
    file.  This routine is useful for skipping over holes within the value of
    the attribute.

Arguments:

    ByteOffset  - Supplies the location to start searching and returns
                  the next existing location.
    Length      - Supplies the length of existing clusters starting at
                  ByteOffset of the attribute.  If -1, the search starts
                  at the given location; otherwise, it starts at the
                  location after the given location.  On return, it
                  contains the length of the allocation starting at
                  ByteOffset.  If return value is zero, it means there
                  is no more allocation starting at that offset.

Return Value:

    TRUE if all succeeded.
    FALSE if failed.

Notes:

    All offsets and lengths are rounded down to the nearest cluster.

--*/
{
    BIG_INT CurrentVcn;
    BIG_INT CurrentLcn;
    ULONG   ClusterSize;

    ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();
    CurrentVcn = *ByteOffset / ClusterSize;

    if (_ResidentData != NULL) {

        // attribute is resident; allocation is contiguous
        // return zero as the offset and the attribute's valid
        // data length as the length from the offset.

        *ByteOffset = 0;
        *Length = _ValidDataLength;
        return TRUE;

    } else if (_ExtentList != NULL) {

        if (*Length != -1)
            CurrentVcn += *Length/ClusterSize;

        for(;;) {
            if (!_ExtentList->QueryLcnFromVcn(CurrentVcn,
                                              &CurrentLcn,
                                              Length)) {

                // the CurrentVcn is out of range already
                // so set the length to zero and return
                // successful status

                *Length = 0;
                break;
            }

            if (CurrentLcn == LCN_NOT_PRESENT) {
                CurrentVcn += *Length;
            } else {
                *Length = *Length * ClusterSize;
                break;
            }
        }

        *ByteOffset = CurrentVcn * ClusterSize;
        return TRUE;

    } else {
        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }
}

UCHAR
ComputeCompressionUnit(
    IN ULONG    ClusterSize
    )
{
    if (ClusterSize <= (1024*4))
        return 4;
    else if (ClusterSize == (1024*8))
        return 3;
    else if (ClusterSize == (1024*16))
        return 2;
    else if (ClusterSize == (1024*32))
        return 1;
    else if (ClusterSize == (1024*64))
        return 0;
    else {
        DebugAbort("Unable to determine compression unit value.");
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\ulib.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    ulib.cxx

Abstract:

    This module contains run-time, global support for the ULIB class library.
    This support includes:

        - creation of CLASS_DESCRIPTORs
        - Global objects
        - Ulib to Win32 API mapping functions

Author:

    David J. Gilman (davegi) 05-Dec-1990

Environment:

    ULIB, User Mode

Notes:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "system.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "bitvect.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "keyboard.hxx"
#include "message.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "pipestrm.hxx"
#include "prtstrm.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "timeinfo.hxx"

#include <locale.h>

#endif // _AUTOCHECK_ || _SETUP_LOADER_


//
// Constants
//

CONST CLASS_ID  NIL_CLASS_ID    = 0;

#if defined(RUN_ON_W2K) && ((DBG==1) || defined(_AUTOCHECK_DBG_))
ULIB_EXPORT
VOID
DebugPrintfReal2(
    IN ULONG    ComponentId,
    IN ULONG    Level,
    IN PCSTR    Format,
    IN ...
    )

/*++

Routine Description:

    Printf to the debug console.

Arguments:

    Format      - Supplies a printf style format string.

Return Value:

    None.

--*/

{
    va_list     args;

    va_start( args, Format );
#if DBG==1
    DebugPrintfReal(Format, args);
#else defined(_AUTOCHECK_DBG_)
    DbgPrint((PCH)Format, args);
#endif
    va_end( args );
}
#endif // defined(RUN_ON_W2K) && ((DBG==1) || defined(_AUTOCHECK_DBG_))

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#if DBG==1

//
// UlibGlobalFlag is used to selectively enable debugging options at
// run-time.
//

ULONG           UlibGlobalFlag     = 0x00000000;

ULIB_EXPORT
VOID
DebugPrintfReal(
    IN PCSTR    Format,
    IN ...
    )

/*++

Routine Description:

    Printf to the debug console.

Arguments:

    Format      - Supplies a printf style format string.

Return Value:

    None.

--*/

{
    STR         Buffer[ 512 ];
    va_list     args;

    va_start( args, Format );
    vsprintf( Buffer, Format, args );
    va_end( args );
    OutputDebugStringA( Buffer );
}
#endif // DBG

//
// GLobal object pointers.
//

// Clients of the DLL cannot access the DLL's
// global data yet, so I have the delightful hacks to get at it.

ULIB_EXPORT
PSTREAM
Get_Standard_Input_Stream(
 )
{
    return Standard_Input_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Output_Stream(
 )
{
    return Standard_Output_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Error_Stream(
 )
{
    return Standard_Error_Stream;
}

PSTREAM     Standard_Input_Stream;
PSTREAM     Standard_Output_Stream;
PSTREAM     Standard_Error_Stream;

#endif // _AUTOCHECK_ || _SETUP_LOADER_

//
//  Declare class descriptors for all classes.
//

DECLARE_CLASS(  CLASS_DESCRIPTOR        );

DECLARE_CLASS(  ARGUMENT                );
DECLARE_CLASS(  ARGUMENT_LEXEMIZER      );
DECLARE_CLASS(  ARRAY                   );
DECLARE_CLASS(  ARRAY_ITERATOR          );
DECLARE_CLASS(  BDSTRING                );
DECLARE_CLASS(  BITVECTOR               );
DECLARE_CLASS(  BUFFER_STREAM           );
DECLARE_CLASS(  BYTE_STREAM             );
DECLARE_CLASS(  CHKDSK_MESSAGE          );
DECLARE_CLASS(  COMM_DEVICE             );
DECLARE_CLASS(  CONT_MEM                );
DECLARE_CLASS(  CONTAINER               );
DECLARE_CLASS(  DSTRING                 );
DECLARE_CLASS(  FILE_STREAM             );
DECLARE_CLASS(  FLAG_ARGUMENT           );
DECLARE_CLASS(  FSNODE                  );
DECLARE_CLASS(  FSN_DIRECTORY           );
DECLARE_CLASS(  FSN_FILE                );
DECLARE_CLASS(  FSN_FILTER              );
DECLARE_CLASS(  FSTRING                 );
DECLARE_CLASS(  HMEM                    );
DECLARE_CLASS(  ITERATOR                );
DECLARE_CLASS(  KEYBOARD                );
DECLARE_CLASS(  LIST                    );
DECLARE_CLASS(  LIST_ITERATOR           );
DECLARE_CLASS(  LONG_ARGUMENT           );
DECLARE_CLASS(  MEM                     );
DECLARE_CLASS(  MESSAGE                 );
DECLARE_CLASS(  MULTIPLE_PATH_ARGUMENT  );
DECLARE_CLASS(  OBJECT                  );
DECLARE_CLASS(  PATH                    );
DECLARE_CLASS(  PATH_ARGUMENT           );
DECLARE_CLASS(  PIPE                    );
DECLARE_CLASS(  PIPE_STREAM             );
DECLARE_CLASS(  PROGRAM                 );
DECLARE_CLASS(  PRINT_STREAM            );
DECLARE_CLASS(  REST_OF_LINE_ARGUMENT   );
DECLARE_CLASS(  SCREEN                  );
DECLARE_CLASS(  SEQUENTIAL_CONTAINER    );
DECLARE_CLASS(  SORTABLE_CONTAINER      );
DECLARE_CLASS(  SORTED_LIST             );
DECLARE_CLASS(  SORTED_LIST_ITERATOR    );
DECLARE_CLASS(  STREAM_MESSAGE          );
DECLARE_CLASS(  STACK                   );
DECLARE_CLASS(  STREAM                  );
DECLARE_CLASS(  WSTRING                 );
DECLARE_CLASS(  BSTRING                 );
DECLARE_CLASS(  STRING_ARGUMENT         );
DECLARE_CLASS(  STRING_ARRAY            );
DECLARE_CLASS(  TIMEINFO                );
DECLARE_CLASS(  TIMEINFO_ARGUMENT       );
DECLARE_CLASS(  STATIC_MEM_BLOCK_MGR    );
DECLARE_CLASS(  MEM_ALLOCATOR           );
DECLARE_CLASS(  MEM_BLOCK_MGR           );


#if defined( _AUTOCHECK_ )

    DECLARE_CLASS( AUTOCHECK_MESSAGE    );
    DECLARE_CLASS( TM_AUTOCHECK_MESSAGE );

#endif // _AUTOCHECK_





//
//  Local prototypes
//
STATIC
BOOLEAN
DefineClassDescriptors (
    );

STATIC
BOOLEAN
UndefineClassDescriptors (
    );

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

BOOLEAN
CreateStandardStreams (
    );

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    );

#endif // _AUTOCHECK_ || _SETUP_LOADER_

BOOLEAN
DllMain (
    IN HANDLE   DllHandle,
    IN ULONG    Reason,
    IN PVOID    Reserved
    )

/*++

Routine Description:

    Initilize Ulib by constructing and initializing all global objects. These
    include:

        - all CLASS_DESCRIPTORs (class_cd)
        - SYSTEM (System)
        - Standard streams

Arguments:

    DllHandle   - Not used.
    Reason      - Supplies the reason why the entry point was called.
    Reserved    - Not used.

Return Value:

    BOOLEAN - Returns TRUE if all global objects were succesfully constructed
        and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Reserved );

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ulib initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_ULIB_MEM_LEAK)
    DebugPrint("ULIB.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG   count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            //
            // Initialization of ULIB can no longer depend on
            // the initialization of the standard streams since they don't seem
            // to exist for Windows programs (no console...)
            //

            if( !DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ulib initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_ULIB_MEM_LEAK)
            DebugPrint("ULIB.DLL got attached.\n");
#endif

            CreateStandardStreams();

            {
                UINT Codepage;
                char achCodepage[12] = ".OCP";      // ".", "uint in decimal", null
                if (Codepage = GetConsoleOutputCP()) {
                    wsprintfA(achCodepage, ".%u", Codepage);
                }
                setlocale(LC_ALL, achCodepage);
            }

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL got detached.\n");
#endif

                UndefineClassDescriptors();

                DELETE(Standard_Input_Stream);
                DELETE(Standard_Output_Stream);
                DELETE(Standard_Error_Stream);

                count--;
            } else {
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL detached more than attached\n");
#endif
            }
            break;

        break;

    }
#endif // _AUTOCHECK || _SETUP_LOADER_

    return( TRUE );

}

BOOLEAN
InitializeUlib (
    IN HANDLE   DllHandle,
    IN ULONG    Reason,
    IN PVOID    Reserved
    )
{
    return DllMain(DllHandle, Reason, Reserved);
}




STATIC
BOOLEAN
DefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

    // This is broken up into many ifs because of compiler limitations.

    BOOLEAN Success = TRUE;

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT                ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARRAY                   ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          ) &&
        DEFINE_CLASS_DESCRIPTOR(    BDSTRING                ) &&
        DEFINE_CLASS_DESCRIPTOR(    BITVECTOR               ) &&
        DEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          ) &&
        DEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             ) &&
        DEFINE_CLASS_DESCRIPTOR(    CONTAINER               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSNODE                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILE                ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              ) &&
        DEFINE_CLASS_DESCRIPTOR(    ITERATOR                ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           ) &&
        DEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    PROGRAM                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    WSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    BSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO                ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       ) &&
        DEFINE_CLASS_DESCRIPTOR(    MESSAGE                 ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           ) &&
        DEFINE_CLASS_DESCRIPTOR(    CONT_MEM                ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    HMEM                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM_ALLOCATOR           ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    KEYBOARD                ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM                     ) &&
        DEFINE_CLASS_DESCRIPTOR(    PIPE                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            ) &&


        DEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   ) &&
        DEFINE_CLASS_DESCRIPTOR(    SCREEN                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          ) &&

#if defined( _AUTOCHECK_ )

        DEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       ) &&
        DEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    ) &&

#endif // _AUTOCHECK_

        TRUE ) {
    } else {
        Success = FALSE;
    }


    if  (!Success) {
        DebugPrint( "Could not initialize class descriptors!");
    }
    return Success;

}


STATIC
BOOLEAN
UndefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT                );
    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      );
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY                   );
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          );
    UNDEFINE_CLASS_DESCRIPTOR(    BDSTRING                );
    UNDEFINE_CLASS_DESCRIPTOR(    BITVECTOR               );
    UNDEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          );
    UNDEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             );
    UNDEFINE_CLASS_DESCRIPTOR(    CONTAINER               );
    UNDEFINE_CLASS_DESCRIPTOR(    DSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSNODE                  );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILE                );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              );
    UNDEFINE_CLASS_DESCRIPTOR(    ITERATOR                );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST                    );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           );
    UNDEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    PROGRAM                 );
    UNDEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    );
    UNDEFINE_CLASS_DESCRIPTOR(    WSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    BSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO                );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       );
    UNDEFINE_CLASS_DESCRIPTOR(    MESSAGE                 );

    UNDEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           );
    UNDEFINE_CLASS_DESCRIPTOR(    CONT_MEM                );

    UNDEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    FSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    HMEM                    );
    UNDEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM_ALLOCATOR           );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           );

    UNDEFINE_CLASS_DESCRIPTOR(    KEYBOARD                );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM                     );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            );


    UNDEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   );
    UNDEFINE_CLASS_DESCRIPTOR(    SCREEN                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          );

#if defined( _AUTOCHECK_ )

    UNDEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       );
    UNDEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    );

#endif // _AUTOCHECK_

    return TRUE;

}


#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

BOOLEAN
CreateStandardStreams (
    )

/*++

Routine Description:

    Creates the standard streams

Arguments:

    None.

Return Value:

    TRUE if the streams were successfully created,
    FALSE otherwise

--*/

{

    Standard_Input_Stream   = GetStandardStream( GetStdHandle( STD_INPUT_HANDLE),
                                                 READ_ACCESS );

    Standard_Output_Stream  = GetStandardStream( GetStdHandle( STD_OUTPUT_HANDLE),
                                                 WRITE_ACCESS );

    Standard_Error_Stream   = GetStandardStream( GetStdHandle( STD_ERROR_HANDLE),
                                                 WRITE_ACCESS );


    return ( (Standard_Input_Stream  != NULL) &&
             (Standard_Output_Stream != NULL) &&
             (Standard_Error_Stream  != NULL) );
}

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Creates a standard stream out of a standard handle

Arguments:

    Handle  -   Supplies the standard handle
    Access  -   Supplies the access.

Return Value:

    Pointer to the stream object created.

--*/


{
    PSTREAM         Stream = NULL;
    PFILE_STREAM    FileStream;
    PPIPE_STREAM    PipeStream;
    PKEYBOARD       Keyboard;
    PSCREEN         Screen;


    switch ( GetFileType( Handle ) ) {

    case (DWORD)FILE_TYPE_DISK:

        if ((FileStream = NEW FILE_STREAM) != NULL ) {
            if ( !FileStream->Initialize( Handle, Access ) ) {
                DELETE( FileStream );
            }
            Stream = (PSTREAM)FileStream;
        }
        break;


    case (DWORD)FILE_TYPE_CHAR:

        //
        // There is no API to determine if a handle is a console handle.
        // Any console API will return ERROR_INVALID_HANDLE if the handle is
        // not a console handle.
        // The following code uses GetConsoleMode().
        //
        switch ( Access ) {

        case READ_ACCESS:

            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {

                    if (GetLastError() != ERROR_INVALID_HANDLE)
                        break;

                    //
                    //  This is not a console, but some other character
                    //  device. Create a pipe stream for it.
                    //
                    if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
                        if ( !PipeStream->Initialize( Handle, Access ) ) {
                            DELETE( PipeStream );
                        }
                        Stream = (PSTREAM)PipeStream;
                    }
                    break;
                }
            }
            if ((Keyboard = NEW KEYBOARD) != NULL ) {
                if ( !Keyboard->Initialize() ) {
                    DELETE( Keyboard );
                }
                Stream = (PSTREAM)Keyboard;
            }
            break;

        case WRITE_ACCESS:

            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {

                    if (GetLastError() != ERROR_INVALID_HANDLE)
                        break;

                    //
                    //  This is not a console, but some other character
                    //  device. Create a file stream for it.
                    //
                    if ((FileStream = NEW FILE_STREAM) != NULL ) {
                        if ( !FileStream->Initialize( Handle, Access ) ) {
                            DELETE( FileStream );
                        }
                        Stream = (PSTREAM)FileStream;
                    }
                    break;
                }
            }

            if ((Screen = NEW SCREEN) != NULL ) {
                if ( !Screen->Initialize() ) {
                    DELETE( Screen );
                }
                Stream = (PSTREAM)Screen;
            }
            break;

        default:
            break;
        }

        break;

    case (DWORD)FILE_TYPE_PIPE:

        if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
            if ( !PipeStream->Initialize( Handle, Access ) ) {
                DELETE( PipeStream );
            }
            Stream = (PSTREAM)PipeStream;
        }
        break;

    case (DWORD)FILE_TYPE_UNKNOWN:
        // Probably a windows app. Don't print anything to debug.
        break;

    default:
        DebugPrintTrace(("ERROR: FileType for standard stream %lx is invalid (%lx)\n", Handle, GetFileType(Handle)));
        break;

    }

    return Stream;

}

NONVIRTUAL
ULIB_EXPORT
HANDLE
FindFirstFile (
    IN  PCPATH              Path,
    OUT PWIN32_FIND_DATA     FileFindData
    )

/*++

Routine Description:

    Perform a FindFirst file given a PATH rather tha a PSTR.

Arguments:

    Path         - Supplies a pointer to the PATH to search.
    FileFindData - Supplies a pointer where the results of the find is
        returned.

Return Value:

    HANDLE - Returns the results of the call to the Win32 FindFirstFile API.

--*/

{
    PWSTR           p;

    //
    // If the supplied pointers are non-NULL and an OEM representation
    // (i.e. API ready) of the PATH is available, return the
    // HANDLE returned by the Win32 FindFirstFile API
    //

    DebugPtrAssert( Path );
    DebugPtrAssert( FileFindData );
    if (!Path || !FileFindData) {
        return INVALID_HANDLE_VALUE;
    }

    p = (PWSTR) Path->GetPathString()->GetWSTR();
    if (!p) {
        return INVALID_HANDLE_VALUE;
    }

    return FindFirstFile(p, FileFindData);
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\wstring.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    wstring.cxx

Author:

    Norbert P. Kusters (norbertk) 6-Aug-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"

#include <stdio.h>
#include <wchar.h>

BOOLEAN WSTRING::_UseAnsiConversions = FALSE;
BOOLEAN WSTRING::_UseConsoleConversions = FALSE;
#if defined FE_SB
BOOLEAN WSTRING::_UseAnsiConversionsPrev = FALSE;
BOOLEAN WSTRING::_UseConsoleConversionsPrev = FALSE;
#endif

// Helper functions for OEM/Unicode conversion.  Note that these
// are abstracted to private functions to make it easier to set
// them up for various environments.
//
#if defined( _AUTOCHECK_ )

INLINE
BOOLEAN
WSTRING::ConvertOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    return _UseAnsiConversions ?
           NT_SUCCESS(RtlMultiByteToUnicodeN( UnicodeString,
                                   MaxBytesInUnicodeString,
                                   BytesInUnicodeString,
                                   OemString,
                                   BytesInOemString )) :
           NT_SUCCESS(RtlOemToUnicodeN( UnicodeString,
                             MaxBytesInUnicodeString,
                             BytesInUnicodeString,
                             OemString,
                             BytesInOemString ));
}

INLINE
BOOLEAN
WSTRING::ConvertUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    return _UseAnsiConversions ?
           NT_SUCCESS(RtlUnicodeToMultiByteN( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString )) :
           NT_SUCCESS(RtlUnicodeToOemN( OemString,
                             MaxBytesInOemString,
                             BytesInOemString,
                             UnicodeString,
                             BytesInUnicodeString ));
}

#else // _AUTOCHECK_ not defined

INLINE
BOOLEAN
ConvertToUnicodeWithConsoleCP(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    int result;

    *BytesInUnicodeString =
        MultiByteToWideChar( GetConsoleCP(),
                             MB_PRECOMPOSED,
                             OemString,
                             BytesInOemString,
                             UnicodeString,
                             MaxBytesInUnicodeString/sizeof(WCHAR) ) *
        sizeof(WCHAR);

    return( *BytesInUnicodeString != 0 );
}

#if defined FE_SB // ConvertToOemWithConsoleCP()
INLINE
BOOLEAN
ConvertToOemWithConsoleCP(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    int result;

    *BytesInOemString =
        WideCharToMultiByte( GetConsoleCP(),
                             0,
                             UnicodeString,
                             BytesInUnicodeString/sizeof(WCHAR),
                             OemString,
                             MaxBytesInOemString,
                             NULL,
                             NULL );

    return( *BytesInOemString != 0 );
}
#endif

INLINE
BOOLEAN
WSTRING::ConvertOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    return
       _UseConsoleConversions ?
           ConvertToUnicodeWithConsoleCP( UnicodeString,
                                          MaxBytesInUnicodeString,
                                          BytesInUnicodeString,
                                          OemString,
                                          BytesInOemString ) :
       _UseAnsiConversions ?
           NT_SUCCESS(RtlMultiByteToUnicodeN( UnicodeString,
                                   MaxBytesInUnicodeString,
                                   BytesInUnicodeString,
                                   OemString,
                                   BytesInOemString )) :
           NT_SUCCESS(RtlOemToUnicodeN( UnicodeString,
                             MaxBytesInUnicodeString,
                             BytesInUnicodeString,
                             OemString,
                             BytesInOemString ));
}

INLINE
BOOLEAN
WSTRING::ConvertUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
#if defined FE_SB // WSTRING::ConvertUnicodeToOemN()
    return
       _UseConsoleConversions ?
           ConvertToOemWithConsoleCP( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString ) :
           _UseAnsiConversions ?
#else
    return _UseAnsiConversions ?
#endif
           NT_SUCCESS(RtlUnicodeToMultiByteN( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString )) :
           NT_SUCCESS(RtlUnicodeToOemN( OemString,
                             MaxBytesInOemString,
                             BytesInOemString,
                             UnicodeString,
                             BytesInUnicodeString ));
}


#endif  // not autochk

INLINE
VOID
WSTRING::Construct(
    )
{
    _s = NULL;
    _l = 0;
}


DEFINE_CONSTRUCTOR( WSTRING, OBJECT );


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTRING   InitialString,
    IN  CHNUM       Position,
    IN  CHNUM       Length
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.
    Position        - Supplies the position in the given string to start at.
    Length          - Supplies the length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= InitialString->_l);

    Length = min(Length, InitialString->_l - Position);

    if (!NewBuf(Length)) {
        return FALSE;
    }

    memcpy(_s, InitialString->_s + Position, (UINT) Length*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTR  InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (StringLength == TO_END) {
        StringLength = wcslen(InitialString);
    }

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    memcpy(_s, InitialString, (UINT) StringLength*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCSTR   InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM       length;
    BOOLEAN     status;

    if (StringLength == TO_END) {
        StringLength = strlen(InitialString);
    }

    if (!StringLength) {
        return Resize(0);
    }


    // We want to avoid making two calls to RtlOemToUnicodeN so
    // try to guess an adequate size for the buffer.

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (status) {
        return Resize(length);
    }


    // We didn't manage to make in one try so ask exactly how much
    // we need and then make the call.

    status = ConvertOemToUnicodeN(NULL, 0, &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (!status || !NewBuf(length)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString, StringLength);

    if (!status) {
        return FALSE;
    }

    DebugAssert(length == _l*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  LONG    Number
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    Number  - Supplies the number to initialize the string to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR    tmp[64];

    sprintf(tmp, "%d", Number);
    return Initialize(tmp);
}


NONVIRTUAL
PWSTRING
WSTRING::QueryString(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine returns a copy of this string from the specified
    coordinates.

Arguments:

    Position    - Supplies the initialize position of the string.
    Length      - Supplies the length of the string.

Return Value:

    A pointer to a string or NULL.

--*/
{
    PWSTRING    p;

    if (!(p = NEW DSTRING) ||
        !p->Initialize(this, Position, Length)) {

        DELETE(p);
    }

    return p;
}


BOOLEAN
WSTRING::QueryNumber(
    OUT PLONG   Number,
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine queries a number from the string.

Arguments:

    Number      - Returns the number parsed out of the string.
    Position    - Supplies the position of the number.
    Length      - Supplies the length of the number.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FSTRING String;
    PSTR    p;
    CHNUM   spn;
    __int64 BigNumber;

    if (Position >= _l) {
        return FALSE;
    }

    Length = min(Length, _l - Position);

        //
    //  Note that 123+123 will be a number!
        //
    String.Initialize((PWSTR) L"1234567890+-");

    spn = Strspn(&String, Position);

    if ((spn == INVALID_CHNUM || spn >= Position + Length) &&
        (p = QuerySTR(Position, Length))) {

        *Number = atol(p);
        BigNumber = _atoi64(p);

        DELETE(p);

		// Ensure that there is no overflow of long
        if (BigNumber == *Number) 
	        return TRUE;
    }

    return FALSE;
}


VOID
WSTRING::DeleteChAt(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine removes the character at the given position.

Arguments:

    Position    - Supplies the position of the character to remove.
    Length      - Supplies the number of characters to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    memmove(_s + Position, _s + Position + Length,
            (UINT) (_l - Position - Length)*sizeof(WCHAR));

    Resize(_l - Length);
}


NONVIRTUAL
BOOLEAN
WSTRING::InsertString(
    IN  CHNUM       AtPosition,
    IN  PCWSTRING   String,
    IN  CHNUM       FromPosition,
    IN  CHNUM       FromLength
    )
/*++

Routine Description:

    This routine inserts the given string at the given position in
    this string.

Arguments:

    AtPosition  - Supplies the position at which to insert the string.
    String      - Supplies the string to insert.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    FromLength = min(FromLength, String->_l - FromPosition);

    old_length = _l;
    if (!Resize(_l + FromLength)) {
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    memcpy(_s + AtPosition, String->_s + FromPosition,
           (UINT) FromLength*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::Replace(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN PCWSTRING    String,
    IN CHNUM        FromPosition,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    'Position' to 'Length' with the contents of 'String2'
    from 'Position2' to 'Length2'.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    String          - Supplies the string to replace with.
    FromPosition    - Supplies the position to replace from in String2.
    FromLength      - Supplies the position to replace from in String2.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    AtLength = min(AtLength, _l - AtPosition);
    FromLength = min(FromLength, String->_l - FromPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    if (!InsertString(AtPosition, String, FromPosition, FromLength)) {
        DebugAbort("This absolutely can never happen\n");
        return FALSE;
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::ReplaceWithChars(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN WCHAR        Character,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    AtPosition of AtLength with the string formed by Character
    of FromLength.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    Character       - Supplies the character to replace with.
    FromLength      - Supplies the total number of new characters to replace the old one with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;
    PWCHAR  currptr, endptr;

    DebugAssert(AtPosition <= _l);

    AtLength = min(AtLength, _l - AtPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    old_length = _l;

    if (!Resize(_l + FromLength)) {
        DebugPrint("This should not fail\n");
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    for (currptr = _s + AtPosition, endptr = currptr + FromLength;
         currptr < endptr;
         currptr++) {
        *currptr = Character;
    }

    return TRUE;
}


PWSTR
WSTRING::QueryWSTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PWSTR   Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine makes a copy of this string into the provided
    buffer.  If this string is not provided then a buffer is
    allocated on the heap.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to copy to.
    BufferLength    - Supplies the number of characters in the buffer.
    ForceNull       - Specifies whether or not to force the final character
                        of the buffer to be NULL in the case when there
                        isn't enough room for the whole string including
                        the NULL.

Return Value:

    A pointer to a NULL terminated string.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    if (!Buffer) {
        BufferLength = Length + 1;
        if (!(Buffer = (PWCHAR) MALLOC(BufferLength*sizeof(WCHAR)))) {
            return NULL;
        }
    }

    if (BufferLength > Length) {
        memcpy(Buffer, _s + Position, (UINT) Length*sizeof(WCHAR));
        Buffer[Length] = 0;
    } else {
        memcpy(Buffer, _s + Position, (UINT) BufferLength*sizeof(WCHAR));
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


PSTR
WSTRING::QuerySTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PSTR    Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine computes a multi-byte version of the current
    unicode string.  If the buffer is not supplied then it
    will be allocated by this routine.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to convert into.
    BufferLength    - Supplies the number of characters in this buffer.
    ForceNull       - Specifies whether or not to force a NULL even
                        when the buffer is too small for the string.

Return Value:

    A pointer to a NULL terminated multi byte string.

--*/
{
    ULONG       ansi_length;

    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);


    // First special case the empty result.

    if (!Length) {

        if (!Buffer) {
            if (!(Buffer = (PSTR) MALLOC(1))) {
                return NULL;
            }
        } else if (!BufferLength) {
            return NULL;
        }

        Buffer[0] = 0;
        return Buffer;
    }


    // Next case is that the buffer is not provided and thus
    // we have to figure out what size it should be.

    if (!Buffer) {

        // We want to avoid too many calls to RtlUnicodeToOemN
        // so we'll estimate a correct size for the buffer and
        // hope that that works.

        BufferLength = 2*Length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }

        if (ConvertUnicodeToOemN(Buffer, BufferLength - 1,
                                 &ansi_length, _s + Position,
                                 Length*sizeof(WCHAR))) {
            Buffer[ansi_length] = 0;
            return Buffer;
        }


        // We failed to estimate the necessary size of the buffer.
        // So ask the correct size and try again.

        FREE(Buffer);

        if (!ConvertUnicodeToOemN(NULL, 0, &ansi_length,
                                  _s + Position, Length*sizeof(WCHAR))) {
            return NULL;
        }

        BufferLength = ansi_length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }
    }

    if (!ConvertUnicodeToOemN(Buffer, BufferLength, &ansi_length,
                              _s + Position, Length*sizeof(WCHAR))) {
        return NULL;
    }

    if (BufferLength > ansi_length) {
        Buffer[ansi_length] = 0;
    } else {
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


BOOLEAN
WSTRING::Strcat(
    IN  PCWSTRING   String
    )
/*++

Routine Description:

    This routine concatenates the given string onto this one.

Arguments:

    String  - Supplies the string to concatenate to this one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    old_length = _l;
    if (!Resize(_l + String->_l)) {
        return FALSE;
    }

    memcpy(_s + old_length, String->_s, (UINT) String->_l*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
PWSTRING
WSTRING::Strupr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine upcases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to upcase.
    Length          - Supplies the length of the substring to upscase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

    _wcsupr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
PWSTRING
WSTRING::Strlwr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine lowercases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to lowercase.
    Length          - Supplies the length of the substring to lowercase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

    _wcslwr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
LONG
WSTRING::Strcmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

    r = wcscmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}


NONVIRTUAL
LONG
WSTRING::Stricmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings insensitive of case.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

#if !defined _AUTOCHECK_

    // This works around a bug in the libc version of wcsicoll, where
    // it doesn't specify STRINGSORT to CompareString().  To reproduce the
    // bug, try sorting 1 and -1.  (-1 should sort before 1.) -mjb.
    //

    r = CompareString(GetUserDefaultLCID(),
                      NORM_IGNORECASE | SORT_STRINGSORT,
                      _s + LeftPosition,
                      -1,
                      String->_s + RightPosition,
                      -1
                      );


    if (r >= 1) {

        //
        // return codes 1, 2, and 3 map to -1, 0, and 1.
        //

        _s[LeftPosition + LeftLength] = c;
        String->_s[RightPosition + RightLength] = d;
        return r - 2;
    }

    // If 'r' is 0, this indicates failure and we'll fall through and
    // call wcsicoll.
    //

#endif // _AUTOCHECK_

    r = _wcsicmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}


PWSTR
WSTRING::SkipWhite(
    IN  PWSTR    p
    )
{
#ifdef FE_SB

  while (*p) {

    if (iswspace(*p))
      p++;
    else if ( *p == 0x3000 )
    {
      *p++ = TEXT(' ');
    }
    else
      break;
  }

#else
    while (iswspace(*p)) {
        p++;
    }
#endif

  return p;

}


/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
INT
WSTRING::Strcmps (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;

  p1 = WSTRING::SkipWhite(p1);                /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef FE_SB
      if (CheckSpace(p1))
#else
      if (iswspace(*p1))           /* compress multiple spaces */
#endif
      {
        q = WSTRING::SkipWhite(p1);
        p1 = (*q == 0) ? q : q - 1;
      }

#ifdef FE_SB
      if (CheckSpace(p2))
#else
      if (iswspace(*p2))
#endif
      {
        q = WSTRING::SkipWhite(p2);
        p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}





/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
INT
WSTRING::Strcmpis (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;
#ifdef FE_SB
  WCHAR c1,c2;
#endif

  p1 = WSTRING::SkipWhite(p1);                  /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
      if (towupper(*p1) == towupper(*p2))
      {
        if (*p1++ == 0)                /* quit if at the end */
          return (0);
        else
          p2++;
#ifdef FE_SB
        if (CheckSpace(p1))
#else
        if (iswspace(*p1))              /* compress multiple spaces */
#endif
        {
          q = SkipWhite(p1);
          p1 = (*q == 0) ? q : q - 1;
        }
#ifdef FE_SB
        if (CheckSpace(p2))
#else
        if (iswspace(*p2))
#endif
        {
          q = WSTRING::SkipWhite(p2);
          p2 = (*q == 0) ? q : q - 1;
        }
      }
      else
        return *p1-*p2;
  }
}

#ifdef FE_SB

/**************************************************************************/
/* Routine:  CheckSpace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/
INT
WSTRING::CheckSpace(
    IN  PWSTR    s
    )
{
  if (iswspace(*s) || *s == 0x3000 )
    return (TRUE);
  else
    return (FALSE);
}

#endif


#define     DUMMY_ULIB_EXPORT

DEFINE_EXPORTED_CONSTRUCTOR( FSTRING, WSTRING, DUMMY_ULIB_EXPORT );


BOOLEAN
FSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING Resize routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return NewBuf(NewStringLength);
}


BOOLEAN
FSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING NewBuf routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (NewStringLength >= _buffer_length) {
        return FALSE;
    }

    PutString((PWSTR) GetWSTR(), NewStringLength);

    return TRUE;
}


INLINE
VOID
DSTRING::Construct(
    )
/*++

Routine Description:

    This routine initializes the string to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _length = 0;
}


DEFINE_EXPORTED_CONSTRUCTOR( DSTRING, WSTRING, DUMMY_ULIB_EXPORT );


DSTRING::~DSTRING(
    )
/*++

Routine Description:

    Destructor for DSTRING.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_buf);
}


BOOLEAN
DSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (_buf) {
            if (!(new_buf = (PWSTR)
                  REALLOC(_buf, (NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }
        } else {
            if (!(new_buf = (PWSTR)
                  MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }
        }

        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}


BOOLEAN
DSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (!(new_buf = (PWSTR)
              MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

            return FALSE;
        }

        if (_buf) {
            FREE(_buf);
        }
        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}

#if defined FE_SB
VOID
WSTRING::ResetConversions(
    )
{
    _UseAnsiConversions = _UseAnsiConversionsPrev;
    _UseConsoleConversions = _UseConsoleConversionsPrev;
}
#endif

VOID
WSTRING::SetAnsiConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the ANSI code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = TRUE;
    _UseConsoleConversions = FALSE;
}


VOID
WSTRING::SetOemConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the OEM code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

    This is the default if neither this nor the above function is
    called.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = FALSE;
}

VOID
WSTRING::SetConsoleConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the current console code page.
    Note that this is a STATIC method.  Therefore this switch
    affects *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif
    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = TRUE;
}

#if defined FE_SB
CHNUM
WSTRING::QueryByteCount(
        ) CONST
/*++

Routine Description:

    This routine returns the number of ANSI bytes the UNICODE string
    consists of.

Arguments:

    None.

Return Value:

    Number of ANSI bytes the UNICODE string is made from, or INVALID_CHNUM
    on error.

--*/

{
    ULONG   ansi_length;
    ULONG   BufferLen = _l * sizeof(WCHAR) + 1;
    PSTR    Buffer;
    BOOLEAN success;

    if ( !_l ) {
        return( (CHNUM)0 );
    }

    if (NULL == (Buffer = (PSTR)MALLOC( BufferLen ))) {
        return( INVALID_CHNUM );
    }

    success = ConvertUnicodeToOemN( Buffer, BufferLen - 1, &ansi_length,
        _s, BufferLen - 1 );

    FREE( Buffer );

    if (!success) {
        return INVALID_CHNUM;
    }
    return ansi_length;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\bootfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootfile.cxx

Abstract:

    This module contains the member function definitions for
    the NTFS_BOOT_FILE class.

Author:

    Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "bootfile.hxx"
#include "ifssys.hxx"
#include "ntfsbit.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BOOT_FILE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BOOT_FILE::~NTFS_BOOT_FILE(
    )
{
    Destroy();
}


VOID
NTFS_BOOT_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_BOOT_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_BOOT_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes a Master File Table Reflection object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Boot File.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( BOOT_FILE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_BOOT_FILE::CreateDataAttribute(
    )
/*++

Routine Description:

    This routine creates the data attribute for the boot file.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    ULONG Size, ClusterSize, ClustersInBootArea;
    ULONG NumBootClusters;

    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    ClustersInBootArea = (BYTES_IN_BOOT_AREA % ClusterSize) ?
                            BYTES_IN_BOOT_AREA / ClusterSize + 1 :
                            BYTES_IN_BOOT_AREA / ClusterSize;

    NumBootClusters = max(1, BYTES_PER_BOOT_SECTOR/ClusterSize);

    Size = ClustersInBootArea * ClusterSize;

    if( !Extents.Initialize( 0, 0 ) ) {

        return FALSE;
    }

    if( !Extents.AddExtent( 0,
                            0,
                            ClustersInBootArea ) ) {
        return FALSE;
    }

    if( !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   Size,
                                   Size,
                                   $DATA ) ) {

        return FALSE;
    }

    if( !DataAttribute.InsertIntoFile( this, NULL ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_BOOT_FILE::Create(
    IN  PCSTANDARD_INFORMATION  StandardInformation
    )
/*++

Routine Description:

    This method formats a Boot-File File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.

Return Value:

    TRUE upon successful completion.

--*/
{
    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    if (!CreateDataAttribute()) {
        return FALSE;
    }

    return TRUE;
}



NONVIRTUAL
BOOLEAN
NTFS_BOOT_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that the boot file's $DATA attribute is present
    and encompases the two boot sectors.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE      data_attribute;
    LCN                 lcn, mid_lcn;
    BIG_INT             run_length;
    BOOLEAN             ErrorInAttribute;
    BOOLEAN             replace_data;
    BOOLEAN             found_zero;
    BOOLEAN             found_mid;
    VCN                 i;
    NTFS_EXTENT_LIST    extents;
    ULONG               size;
    ULONG               num_boot_clusters;

    //
    // We used to do a replica boot sector in the middle of the volume.
    // Now we want it at the end, so chkdsk has to deal with both cases.
    // The rule is that the boot file should have a data attribute.  If
    // that data attribute has two extents, the second one should describe
    // a replica at n/2.  If there's a single extent, the replica is
    // assumed to occupy the last sector of the partition.
    //

    // Insure that the $DATA attribute is present and that it
    // allocates cluster 0 and the cluster in the middle of the disk.

    *Changes = FALSE;

    num_boot_clusters = max(1,
                            BYTES_PER_BOOT_SECTOR/(GetDrive()->QuerySectorSize()*
                            QueryClusterFactor()));
    mid_lcn = QueryVolumeSectors()/2/QueryClusterFactor();

    replace_data = FALSE;
    if (QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        found_zero = FALSE;
        found_mid = FALSE;
        for (i = 0; data_attribute.QueryLcnFromVcn(i, &lcn, &run_length); i += 1) {
            if (lcn == 0) {
                found_zero = (run_length >= num_boot_clusters);
            }
            if (lcn == mid_lcn) {
                found_mid = (run_length >= num_boot_clusters);
            }
        }

        if (!found_zero) {

            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SECTOR_ZERO_IN_BOOT_FILE);

            replace_data = TRUE;
            data_attribute.Resize(0, VolumeBitmap);
        }

    } else {

        replace_data = TRUE;
    }

    // If it's not good then replace it with one that takes
    // up only the boot sector and the middle sector.


    //
    // When creating a new boot sector we just do sector 0.
    //

    if (replace_data) {

        *Changes = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_BOOT_FILE);

        size = GetDrive()->QuerySectorSize()*QueryClusterFactor();

        if (!extents.Initialize(0,0) ||
            !extents.AddExtent(0, 0, num_boot_clusters) ||
            !data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extents,
                                       size,
                                       size,
                                       $DATA) ||
            !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
            (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex))) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BOOT_FILE);
            return FALSE;
        }

        VolumeBitmap->SetAllocated(0, num_boot_clusters);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\clusrun.cxx ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

	clusrun.cxx

Abstract:

	This class models a run of clusters on an NTFS volume.	Its
	principle purpose is to mediate between the cluster-oriented
	NTFS volume and the sector-oriented drive object.

Author:

	Bill McJohn (billmc) 11-July-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "clusrun.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_CLUSTER_RUN, SECRUN, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_CLUSTER_RUN::~NTFS_CLUSTER_RUN(
	)
{
	Destroy();
}


VOID
NTFS_CLUSTER_RUN::Construct(
	)
/*++

Routine Description:

	Worker function for construction of the NTFS_CLUSTER_RUN object.

Arguments:

	None.

Return Value:

	None.

--*/
{
	_StartLcn = 0;
	_ClusterFactor = 0;
	_Drive = NULL;
	_IsModified = FALSE;
}

VOID
NTFS_CLUSTER_RUN::Destroy(
	)
/*++

Routine Description:

	Worker function for destruction of the NTFS_CLUSTER_RUN object.

Arguments:

	None.

Return Value:

	None.

--*/
{
	_StartLcn = 0;
	_ClusterFactor = 0;
	_Drive = NULL;
	_IsModified = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_CLUSTER_RUN::Initialize (
	IN OUT  PMEM 		        Mem,
	IN OUT  PLOG_IO_DP_DRIVE	Drive,
	IN      LCN			        Lcn,
	IN      ULONG		        ClusterFactor,
	IN      ULONG		        RunLength
	)
/*++

Routine Description:

	Initialize an NTFS_CLUSTER_RUN object.

Arguments:

	Mem 			-- supplies the memory object for this cluster run.
	Drive			-- supplies the drive on which this cluster run resides.
	Lcn 			-- supplies the staring Lcn of the cluster run.
	Cluster Factor	-- supplies the cluster factor for the drive.
	RunLength		-- supplies the length of the run in clusters.

Return Value:

	TRUE upon successful completion.

Notes:

	This class is reinitializable.

--*/
{
	DebugPtrAssert( Mem );
	DebugPtrAssert( Drive );

	Destroy();

	if( !SECRUN::Initialize( Mem, Drive,
                             Lcn * ClusterFactor,
                             RunLength * ClusterFactor ) ) {

		return FALSE;
	}

	_StartLcn = Lcn;
	_Drive = Drive;
	_ClusterFactor = ClusterFactor;

	return TRUE;
}


UNTFS_EXPORT
VOID
NTFS_CLUSTER_RUN::Relocate (
	IN LCN NewLcn
	)
/*++

Routine Description:

	Move the cluster run to point at a different section of
	the volume.

Arguments:

	NewLcn	-- supplies the first Lcn of the new location.

Return Value:

	None.

--*/
{
	_StartLcn = NewLcn;

	SECRUN::Relocate( NewLcn * _ClusterFactor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\entry.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    This module contains the entry points for UNTFS.DLL.  These
    include:

        Chkdsk
        ChkdskEx
        Format
        FormatEx
        Recover
        Extend

Author:

    Bill McJohn (billmc) 31-05-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfsvol.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "rcache.hxx"
#include "ifsserv.hxx"

extern "C" {
    #include "nturtl.h"
}

#include "message.hxx"
#include "rtmsg.h"


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       DesiredLogFileSize,
    OUT     PULONG      ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Verbose             TRUE if Chkdsk should list every file it finds
    OnlyIfDirty         TRUE if the drive should be checked only if
                            it is dirty
    Recover             TRUE if the drive is to be completely checked
                            for bad sectors.
    PathToCheck         supplies a path to files Chkdsk should check
                            for contiguity
    Extend              TRUE if Chkdsk should extend the volume
    ResizeLogfile       TRUE if Chkdsk should resize the logfile.
    DesiredLogfileSize  if ResizeLogfile is true, supplies the desired logfile
                            size, or 0 if we're to resize the logfile to the
                            default size.
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL        NtfsVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    BOOLEAN         r;
    DWORD           oldErrorMode;
    ULONG           flags;

    if (Extend) {

        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;

        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart();
        BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

        if (!Secrun.Write()) {
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    RecoverFree = RecoverAlloc = Recover;

    if (Extend) {

        // If we're to extend the volume, we also want to verify the
        // new free space we're adding.
        //

        RecoverFree = TRUE;
    }

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!NtfsVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix || (ResizeLogFile && DesiredLogFileSize != 0)) {

        if (!NtfsVol.IsWriteable()) {
            Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }

        if (!NtfsVol.Lock()) {

            // The client wants to modify the drive, but we can't lock it.
            // Offer to do it on next reboot.
            //
            Message->DisplayMsg(MSG_CHKDSK_ON_REBOOT_PROMPT);

            if (Message->IsYesResponse( FALSE )) {

                flags = Recover ? CHKDSK_RECOVER : 0;
                flags |= ResizeLogFile ? CHKDSK_RESIZE_LOGFILE : 0;

                if (NtfsVol.ForceAutochk( Fix,
                                          flags,
                                          DesiredLogFileSize,
                                          0,
                                          NtDriveName )) {

                    Message->DisplayMsg(MSG_CHKDSK_SCHEDULED);

                } else {

                    Message->DisplayMsg(MSG_CHKDSK_CANNOT_SCHEDULE);
                }
            }

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    if (!Fix && ResizeLogFile) {

        if (!NtfsVol.GetNtfsSuperArea()->ResizeCleanLogFile( Message,
                                                             TRUE, /* ExplicitResize */
                                                             DesiredLogFileSize )) {
            Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            return FALSE;
        }
        return TRUE;
    }

    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (RecoverFree ? CHKDSK_RECOVER_FREE_SPACE : 0);
    flags |= (RecoverAlloc ? CHKDSK_RECOVER_ALLOC_SPACE : 0);
    flags |= (ResizeLogFile ? CHKDSK_RESIZE_LOGFILE : 0);

    return NtfsVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           flags,
                           DesiredLogFileSize,
                           0,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    OUT     PULONG              ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Param               supplies the chkdsk parameter block
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL        NtfsVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    BOOLEAN         r;
    DWORD           oldErrorMode;
    USHORT          algorithm;

    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Param->Major > 1 || (Param->Major == 1 && Param->Minor == 1)) {
        algorithm = Param->Algorithm;
    } else
        algorithm = 0;

    if (Param->Flags & CHKDSK_EXTEND) {

        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;

        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart();
        BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

        if (!Secrun.Write()) {
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    RecoverFree = RecoverAlloc = (BOOLEAN)(Param->Flags & CHKDSK_RECOVER);

    if (Param->Flags & CHKDSK_EXTEND) {

        // If we're to extend the volume, we also want to verify the
        // new free space we're adding.
        //

        RecoverFree = TRUE;
    }

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!NtfsVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix || ((Param->Flags & CHKDSK_RESIZE_LOGFILE) &&
                Param->LogFileSize != 0)) {

        MSGID   msgId = MSG_CHKDSK_ON_REBOOT_PROMPT;
        WCHAR   windows_path[MAX_PATH];
        DSTRING sdrive, nt_drive_name;
        BOOLEAN system_drive = FALSE;
        BOOLEAN do_not_dismount = FALSE;

        if (!NtfsVol.IsWriteable()) {
            Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }

        if (GetWindowsDirectory(windows_path, sizeof(windows_path)/sizeof(WCHAR)) &&
            wcslen(windows_path) >= 2 &&
            windows_path[1] == TEXT(':') &&
            !(windows_path[2] = 0) &&
            sdrive.Initialize(windows_path) &&
            IFS_SYSTEM::DosDriveNameToNtDriveName(&sdrive, &nt_drive_name)) {

            system_drive = nt_drive_name.Stricmp(NtDriveName) == 0;
        } else {

            Message->DisplayMsg(MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE);
            system_drive = FALSE;
        }

        if (!NtfsVol.Lock()) {
            if (!system_drive) {
                if (!(Param->Flags & CHKDSK_FORCE)) {

                    Message->DisplayMsg(MSG_CHKDSK_FORCE_DISMOUNT_PROMPT);

                    if (Message->IsYesResponse( FALSE )) {
                        if (NtfsVol.DismountAndLock()) {
                            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
                        } else {
                            msgId = MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT;
                            do_not_dismount = TRUE;
                        }
                    } else {
                        do_not_dismount = TRUE;
                    }

                } else if (NtfsVol.DismountAndLock()) {
                    Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
                } else {
                    msgId = MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT;
                    do_not_dismount = TRUE;
                }
            } else {
                do_not_dismount = TRUE;
            }
        }

        if (do_not_dismount) {

            // The client wants to modify the drive, but we can't lock it.
            // Offer to do it on next reboot.
            //
            Message->DisplayMsg(msgId);

            if (Message->IsYesResponse( FALSE )) {

                if (NtfsVol.ForceAutochk( Fix,
                                          Param->Flags,
                                          Param->LogFileSize,
                                          algorithm,
                                          NtDriveName )) {

                    Message->DisplayMsg(MSG_CHKDSK_SCHEDULED);

                } else {

                    Message->DisplayMsg(MSG_CHKDSK_CANNOT_SCHEDULE);
                }
            }

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }
    }

    if (!Fix && (Param->Flags & CHKDSK_RESIZE_LOGFILE)) {

        if (!NtfsVol.GetNtfsSuperArea()->ResizeCleanLogFile( Message,
                                                             TRUE, /* ExplicitResize */
                                                             Param->LogFileSize )) {
            Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
        *ExitStatus = CHKDSK_EXIT_SUCCESS;
        return TRUE;
    }

    if (!Fix && !NtfsVol.Lock()) {
        Message->DisplayMsg(MSG_CHKDSK_FALSE_ALARM);
    }


    return NtfsVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           Param->Flags,
                           Param->LogFileSize,
                           algorithm,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Quick,
    IN      BOOLEAN     BackwardCompatible,
    IN      MEDIA_TYPE  MediaType,
    IN      PCWSTRING   LabelString,
    IN      ULONG       ClusterSize
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Quick           -- supplies a flag to indicate whether to do Quick Format
    BackwardCompatible
                    -- supplies a flag to indicate if formatting to previous
                       version of file system (e.g. FAT32->FAT16, NTFS 5.0->NTFS 4.0)
    MediaType       -- supplies the volume's Media Type
    LabelString     -- supplies the volume's label
    ClusterSize     -- supplies the cluster size for the volume.

--*/
{
    DP_DRIVE            DpDrive;
    NTFS_VOL            NtfsVol;
    ULONG               SectorsNeeded;
    FORMAT_ERROR_CODE   errcode;
    ULONG               flags;

    if (ClusterSize && ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    SectorsNeeded = NTFS_SA::QuerySectorsInElementaryStructures( &DpDrive );

    if( SectorsNeeded > DpDrive.QuerySectors() ) {

        Message->DisplayMsg( MSG_FMT_VOLUME_TOO_SMALL );
        return FALSE;
    }

    errcode = NtfsVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  !Quick,
                                  MediaType );

    if (errcode == NoError) {
        flags = (BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
        errcode = NtfsVol.Format( LabelString, Message, flags, ClusterSize );
    }

    if (errcode == LockError) {
        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Param           -- supplies the format parameter block
    MediaType       -- supplies the volume's Media Type

--*/
{
    DP_DRIVE            DpDrive;
    NTFS_VOL            NtfsVol;
    ULONG               SectorsNeeded;
    FORMAT_ERROR_CODE   errcode;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if (Param->ClusterSize && Param->ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    SectorsNeeded = NTFS_SA::QuerySectorsInElementaryStructures( &DpDrive );

    if( SectorsNeeded > DpDrive.QuerySectors() ) {

        Message->DisplayMsg( MSG_FMT_VOLUME_TOO_SMALL );
        return FALSE;
    }

    errcode = NtfsVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  (Param->Flags & FORMAT_QUICK) ? 0 : 1,
                                  MediaType );

    if (errcode == NoError) {
        errcode = NtfsVol.Format( Param->LabelString,
                                  Message,
                                  Param->Flags,
                                  Param->ClusterSize );
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->DisplayMsg(MSG_FMT_FORCE_DISMOUNT_PROMPT);

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
            } else {
                Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
                return FALSE;
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
        }

        errcode = NtfsVol.Initialize( NtDriveName,
                                      Message,
                                      FALSE,
                                      (Param->Flags & FORMAT_QUICK) ? 0 : 1,
                                      MediaType,
                                      TRUE);

        if (errcode == NoError) {
            errcode = NtfsVol.Format( Param->LabelString,
                                      Message,
                                      Param->Flags,
                                      Param->ClusterSize );
        }

        if (errcode == LockError) {
            Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
            return FALSE;
        } else
            return (errcode == NoError);
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
Recover(
    IN      PPATH       RecFilePath,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    Recover a file on an NTFS disk.

Arguments:

    RecFilePath --  supplies the path to the file to recover
    Message     --  supplies a channel for messages

Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL    NtfsVol;
    PWSTRING    FullPath;
    PWSTRING    DosDriveName;
    DSTRING     NtDriveName;
    BOOLEAN     Result;

    FullPath = RecFilePath->QueryDirsAndName();
    DosDriveName = RecFilePath->QueryDevice();

    if ( DosDriveName == NULL ||
         !IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName,
                                                &NtDriveName) ||
         FullPath == NULL ) {

        DELETE(DosDriveName);
        DELETE(FullPath);
        return FALSE;
    }

    Message->DisplayMsg(MSG_RECOV_BEGIN,
                     "%W", DosDriveName);
    Message->WaitForUserSignal();

    Result = ( NtfsVol.Initialize( &NtDriveName, Message ) &&
               NtfsVol.Recover( FullPath, Message ) );

    DELETE(DosDriveName);
    DELETE(FullPath);
    return Result;
}

BOOLEAN
FAR APIENTRY
Extend(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Verify
    )
/*++

Routine Description:

    Extend an NTFS volume without going through the whole chkdsk
    process.

Arguments:

    NtDrivName      Supplies the name of the drive to extend.
    Message         Supplies an outlet for messages.
    Verify          TRUE if we should verify the new space.

Return Value:

    TRUE if successful.

--*/
{
    BIG_INT         nsecOldSize;            // previous size in sectors

    //
    // First save the old volume size from the boot sector, then query
    // the new size from the device driver and write a new boot sector
    // contining that size.  When the Drive object is destroyed, the
    // dasd handle will be closed.
    //

    {
        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;


        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        nsecOldSize = BootSector->NumberSectors;

        // Leave one sector at the end of the volume for the replica boot
        // sector.
        //

        BootSector->NumberSectors.LowPart = (Drive.QuerySectors() - 1).GetLowPart();
        BootSector->NumberSectors.HighPart = (Drive.QuerySectors() - 1).GetHighPart();

        if (!Secrun.Write()) {
            return FALSE;
        }
    }

    //
    // When the ntfs volume object is initialized, it will get the new
    // size from the boot sector.  When it opens a handle on the volume,
    // the filesystem will re-mount and pick up the new size, as well.
    //

    NTFS_VOL        ntfs_vol;

    if (!ntfs_vol.Initialize(NtDriveName, Message) || !ntfs_vol.Lock()) {
        return FALSE;
    }

    return ntfs_vol.Extend(Message, Verify, nsecOldSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\attrrec.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    attrrec.hxx

Abstract:

    This module contains the member function definitions for
    NTFS_ATTRIBUTE_RECORD, which models NTFS attribute records.

    An Attribute Record may be a template laid over a chunk of
    memory; in that case, it does not own the memory.  It may
    also be told, upon initialization, to allocate its own memory
    and copy the supplied data.  In that case, it is also responsible
    for freeing that memory.

    Attribute Records are passed between Attributes and File
    Record Segments.  A File Record Segment can initialize
    an Attribute with a list of Attribute Records; when an
    Attribute is Set into a File Record Segment, it packages
    itself up into Attribute Records and inserts them into
    the File Record Segment.

    File Record Segments also use Attribute Records to scan
    through their list of attribute records, and to shuffle
    them around.

Author:

    Bill McJohn (billmc) 14-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "wstring.hxx"
#include "extents.hxx"
#include "attrrec.hxx"
#include "attrcol.hxx"
#include "ntfsbit.hxx"
#include "extents.hxx"
#include "upcase.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE_RECORD, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_ATTRIBUTE_RECORD::~NTFS_ATTRIBUTE_RECORD(
    )
{
    Destroy();
}

VOID
NTFS_ATTRIBUTE_RECORD::Construct(
    )
/*++

Routine Description:

    This method is the private worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Data = NULL;
    _MaximumLength = 0;
    _IsOwnBuffer = FALSE;
    _DisableUnUse = FALSE;
    _Drive = NULL;
}

VOID
NTFS_ATTRIBUTE_RECORD::Destroy(
    )
/*++

Routine Description:

    This method is the private worker function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if( _IsOwnBuffer && _Data != NULL ) {

        FREE( _Data );
    }

    _Data = NULL;
    _MaximumLength = 0;
    _IsOwnBuffer = FALSE;
    _Drive = NULL;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::Initialize(
    IN      PIO_DP_DRIVE    Drive,
    IN OUT  PVOID           Data,
    IN      ULONG           MaximumLength,
    IN      BOOLEAN         MakeCopy
    )
/*++

Routine Description:

    This method initializes an NTFS_ATTRIBUTE_RECORD object,
    handing it a buffer with attribute record data.  The caller
    may also ask the object to make a private copy of the data.

Arguments:

    Drive           -- supplies the drive on which the attribute record resides
    Data            -- supplies a buffer containing the attribute
                        record data the object will own.
    MaximumLength   -- supplies the size of the buffer.
    MakeCopy        -- supplies a flag indicating whether the object
                        should copy the data to a private buffer.

Return Value:

    TRUE upon successful completion.

Notes:

    If MakeCopy is TRUE, then the object must allocate its own
    buffer and copy the attribute record data to it, in which
    case the object is also responsible for freeing that private
    buffer.  It that flag is FALSE, then the object will cache a
    pointer to the buffer supplied by the client; the client is
    responsible for making sure that buffer remains valid for
    the lifetime of the NTFS_ATTRIBUTE_RECORD object.

    This object is reinitializable.

--*/
{
    Destroy();

    if( !MakeCopy ) {

        _Data = (PATTRIBUTE_RECORD_HEADER) Data;
        _MaximumLength = MaximumLength;
        _IsOwnBuffer = FALSE;
        _Drive = Drive;

        return TRUE;

    } else {

        if( (_Data = (PATTRIBUTE_RECORD_HEADER)
                     MALLOC( (UINT) MaximumLength )) == NULL ) {

            Destroy();
            return FALSE;
        }

        _MaximumLength = MaximumLength;
        _IsOwnBuffer = TRUE;
        _Drive = Drive;
        memcpy(_Data, Data, (UINT) MaximumLength);

        return TRUE;
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::Initialize(
    IN      PIO_DP_DRIVE    Drive,
    IN OUT  PVOID           Data
    )
/*++

Routine Description:

    This version of Initialize takes it's maximum size from the
    attribute record.

Arguments:

    Drive   - supplies the drive on which the attribute record resides
    Data    - supplies a buffer containing the attribute
                record data.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    _Data = (PATTRIBUTE_RECORD_HEADER) Data;
    _MaximumLength = _Data->RecordLength;
    _IsOwnBuffer = FALSE;
    _Drive = Drive;

    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE_RECORD::CreateResidentRecord(
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    IN  ATTRIBUTE_TYPE_CODE TypeCode,
    IN  PCWSTRING           Name,
    IN  USHORT              Flags,
    IN  UCHAR               ResidentFlags
    )
/*++

Routine Description:

    This method formats the object's buffer with a resident
    attribute record.

Arguments:

    Value           -- supplies the attribute value
    ValueLength     -- supplies the length of the value
    TypeCode        -- supplies the attribute type code
    Name            -- supplies the name of the attribute
                        (may be NULL)
    Flags           -- supplies the attribute's flags.
    ResidentFlags   -- supplies the attribute's resident flags

Return Value:

    TRUE upon successful completion.

--*/
{
    // Clear the memory first.
    memset(_Data, 0, (UINT) _MaximumLength);

    // We will arrange the attribute in the following order:
    //  Attribute Record Header
    //  Name (if any)
    //  Value

    if( _MaximumLength < SIZE_OF_RESIDENT_HEADER )  {

        DebugAbort( "Create:  buffer is too small.\n" );
        return FALSE;
    }

    _Data->TypeCode = TypeCode;
    _Data->FormCode = RESIDENT_FORM;
    _Data->Flags = Flags;

    if( Name != NULL ) {

        _Data->NameLength = (UCHAR) Name->QueryChCount();
        _Data->NameOffset = QuadAlign(SIZE_OF_RESIDENT_HEADER);

        //
        // The structure should be quad aligned already.  This check is just in case.
        //
        DebugAssert(QuadAlign(SIZE_OF_RESIDENT_HEADER) == SIZE_OF_RESIDENT_HEADER);

        _Data->Form.Resident.ValueOffset =
            QuadAlign( _Data->NameOffset +
                        _Data->NameLength * sizeof( WCHAR ) );

    } else {

        _Data->NameLength = 0;
        _Data->NameOffset = 0;

        _Data->Form.Resident.ValueOffset =
                    QuadAlign(SIZE_OF_RESIDENT_HEADER);
    }

    _Data->Form.Resident.ValueLength = ValueLength;
    _Data->Form.Resident.ResidentFlags = ResidentFlags;

    _Data->RecordLength =
        QuadAlign(_Data->Form.Resident.ValueOffset + ValueLength );

    if( _Data->RecordLength > _MaximumLength ) {

        return FALSE;
    }

    // Now that we're sure there's room, copy the name (if any)
    // and the value into their respective places.

    if( Name != NULL ) {

        Name->QueryWSTR( 0,
                         _Data->NameLength,
                         (PWSTR)((PBYTE)_Data + _Data->NameOffset),
                         _Data->NameLength,
                         FALSE );
    }

    memcpy( (PBYTE)_Data + _Data->Form.Resident.ValueOffset,
            Value,
            (UINT) ValueLength );

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::CreateNonresidentRecord(
    IN  PCNTFS_EXTENT_LIST  Extents,
    IN  BIG_INT             AllocatedLength,
    IN  BIG_INT             ActualLength,
    IN  BIG_INT             ValidLength,
    IN  ATTRIBUTE_TYPE_CODE TypeCode,
    IN  PCWSTRING           Name,
    IN  USHORT              Flags,
    IN  USHORT              CompressionUnit,
    IN  ULONG               ClusterSize
    )
/*++

Routine Description:

    This method formats the attribute record to hold a nonresident
    attribute.

Arguments:

    Extents         -- supplies an extent list describing the
                        attribute value's disk storage.
    AllocatedLength -- supplies the allocated length of the value
    ActualLength    -- supplies the actual length of the value
    ValidLength     -- supplies the valid length of the value
    TypeCode        -- supplies the attribute type code
    Name            -- supplies the name of the attribute
                        (may be NULL)
    Flags           -- supplies the attribute's flags.
    CompressionUnit -- supplies the log in base 2 of the number of
                        clusters per compression unit.

--*/
{
    ULONG   MappingPairsLength;
    VCN     NextVcn, HighestVcn;
    USHORT  sizeOfNonResidentHeader = SIZE_OF_NONRESIDENT_HEADER;

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE)) {
        sizeOfNonResidentHeader += sizeof(BIG_INT); // TotalAllocated field
    }

    // Clear the memory first.
    memset(_Data, 0, (UINT) _MaximumLength);

    // We will arrange the attribute in the following order:
    //  Attribute Record Header
    //  Name (if any)
    //  Compressed Mapping Pairs

    if( _MaximumLength < sizeOfNonResidentHeader )   {

        DebugAbort( "Create:  buffer is too small.\n" );
        return FALSE;
    }

    _Data->TypeCode = TypeCode;
    _Data->FormCode = NONRESIDENT_FORM;
    _Data->Flags = Flags;

    if( Name != NULL ) {

        _Data->NameLength = (UCHAR) Name->QueryChCount();
        _Data->NameOffset = QuadAlign(sizeOfNonResidentHeader);

        //
        // The structure should be quad aligned already.  This check is just in case.
        //
        DebugAssert(QuadAlign(sizeOfNonResidentHeader) == sizeOfNonResidentHeader);

        _Data->Form.Nonresident.MappingPairsOffset =
            (USHORT)QuadAlign( _Data->NameOffset +
                                _Data->NameLength * sizeof( WCHAR ) );

    } else {

        _Data->NameLength = 0;
        _Data->NameOffset = 0;

        _Data->Form.Nonresident.MappingPairsOffset =
            (USHORT)QuadAlign(sizeOfNonResidentHeader);
    }

    _Data->Form.Nonresident.CompressionUnit = (UCHAR)CompressionUnit;

    _Data->Form.Nonresident.AllocatedLength =
                    AllocatedLength.GetLargeInteger();

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE)) {
        _Data->Form.Nonresident.TotalAllocated =
            (Extents->QueryClustersAllocated()*ClusterSize).GetLargeInteger();
    }
    _Data->Form.Nonresident.FileSize = ActualLength.GetLargeInteger();
    _Data->Form.Nonresident.ValidDataLength = ValidLength.GetLargeInteger();


    // Copy the name

    if( Name != NULL ) {

        if( (ULONG)(_Data->NameOffset + _Data->NameLength) > _MaximumLength ) {

            // There isn't enough room for the name.

            return FALSE;
        }

        Name->QueryWSTR( 0,
                         _Data->NameLength,
                         (PWSTR)((PBYTE)_Data + _Data->NameOffset),
                         _Data->NameLength,
                         FALSE );
    }


    if( !Extents->QueryCompressedMappingPairs(
                        (PVCN)&(_Data->Form.Nonresident.LowestVcn),
                        &NextVcn,
                        &MappingPairsLength,
                        _MaximumLength -
                          _Data->Form.Nonresident.MappingPairsOffset,
                        (PVOID)((PBYTE)_Data +
                          _Data->Form.Nonresident.MappingPairsOffset) ) ) {

        // Unable to get the compressed mapping pairs.

        DebugPrint( "Could not get compressed mapping pairs.\n" );
        return FALSE;
    }

    HighestVcn = NextVcn - 1;
    memcpy( &_Data->Form.Nonresident.HighestVcn, &HighestVcn, sizeof(VCN) );

    _Data->RecordLength =
        QuadAlign(_Data->Form.Nonresident.MappingPairsOffset +
                  MappingPairsLength );

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::Verify(
    IN  PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN  BOOLEAN                     BeLenient
    ) CONST
/*++

Routine Description:

    This routine verifies an attribute record for consistency against
    itself and against the attribute definition table.  This routine
    will return FALSE if the attribute record contains any
    inconsistencies.

Arguments:

    AttributeDefTable   - Supplies the attribute definition table.

Return Value:

    FALSE   - The attribute record is inconsistent.
    TRUE    - The attribute record is ok.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    BOOLEAN             bad_mapping_pairs;
    ULONG               index;
    ULONG               column_flags;
    BIG_INT             length;
    PFILE_NAME          file_name;
    ULONG               value_length;
    UCHAR               i;
    PWCHAR              p;
    USHORT              sizeOfNonResidentHeader = SIZE_OF_NONRESIDENT_HEADER;

    DebugAssert(_Data);

    // Make sure that we can access at least the form code.

    if (FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Instance) > _Data->RecordLength) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Instance),
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute form code out-of-bounds.\n"));
        return FALSE;
    }

    // Make sure that the form code is either resident or non-resident.

    if (_Data->FormCode != RESIDENT_FORM &&
        _Data->FormCode != NONRESIDENT_FORM) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_ATTR_FORM_CODE,
                         "%x%x%x",
                         _Data->FormCode,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute %d has non-existent form code.\n", _Data->TypeCode));
        return FALSE;
    }

    if (_Data->FormCode == NONRESIDENT_FORM &&
        (_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                         ATTRIBUTE_FLAG_SPARSE))) {
        sizeOfNonResidentHeader += sizeof(BIG_INT); // TotalAllocated field
    }

    // Make sure that the record is at least as big as the header
    // for the record

    if (_Data->FormCode == RESIDENT_FORM &&
        _Data->RecordLength < SIZE_OF_RESIDENT_HEADER) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         SIZE_OF_RESIDENT_HEADER,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute record res header out-of-bounds.\n"));
        return FALSE;
    }

    if (_Data->FormCode == NONRESIDENT_FORM &&
        _Data->RecordLength < sizeOfNonResidentHeader) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         sizeOfNonResidentHeader,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute record nonres header out-of-bounds.\n"));

        return FALSE;
    }


    switch (_Data->TypeCode) {

        case $STANDARD_INFORMATION:

            if (!IsResident() ||
                (_Data->Form.Resident.ValueLength !=
                sizeof(STANDARD_INFORMATION) &&
                _Data->Form.Resident.ValueLength !=
                SIZEOF_NEW_STANDARD_INFORMATION)
                    ) {

                // This attribute must be resident and at least
                // as big as the above structure.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {

                        if (!IsResident()) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_RESIDENT,
                                     "%x%x",
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        } else {
                            msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_STD_INFO_ATTR_SIZE,
                                     "%x%x%x",
                                     _Data->Form.Resident.ValueLength,
                                     sizeof(STANDARD_INFORMATION),
                                     SIZEOF_NEW_STANDARD_INFORMATION);
                        }
                    }
                }

                DebugPrintTrace(("The standard information is too small\n"));
                return FALSE;
            }

            // Fall through for next check.

        case $ATTRIBUTE_LIST:
        case $VOLUME_VERSION:
        case $SECURITY_DESCRIPTOR:
        case $VOLUME_NAME:
        case $VOLUME_INFORMATION:
        case $SYMBOLIC_LINK:
        case $EA_INFORMATION:
        case $EA_DATA:

            if (_Data->NameLength) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_HAVE_NAME,
                                 "%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                // These attribute may not have names.
                DebugPrintTrace(("Attribute %d should not have a name.\n", _Data->TypeCode));
                return FALSE;
            }

            break;

        case $INDEX_ALLOCATION:

            // $INDEX_ALLOCATION's can't be resident.

            if (IsResident()) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_RESIDENT,
                                 "%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has resident index allocation\n", _Data->TypeCode));
                return FALSE;
            }
            break;

        default:
            break;

    }


    // Make sure the name offset is well-aligned and in bounds.
    // Also make sure that the name does not have any unicode NULLs
    // in them.

    if (_Data->NameOffset%sizeof(WCHAR) ||
        ULONG(_Data->NameOffset + _Data->NameLength) > _Data->RecordLength) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INCORRECT_ATTR_NAME_OFFSET);
                msg->Log("%x%x",
                         QueryTypeCode(),
                         QueryInstanceTag());
                msg->DumpDataToLog(_Data,
                                   sizeof(ATTRIBUTE_RECORD_HEADER)+
                                   sizeof(WCHAR)*_Data->NameLength);
                msg->Unlock();
            }
        }

        DebugPrintTrace(("Corrupt name for attribute %d.\n", _Data->TypeCode));
        return FALSE;
    }

    p = (PWCHAR) ((PCHAR) _Data + _Data->NameOffset);
    for (i = 0; i < _Data->NameLength; i++) {
        if (!p[i]) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_NULL_FOUND_IN_ATTR_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Unicode NULL in attribute name for attribute %d.\n",
                      _Data->TypeCode));
            return FALSE;
        }
    }


    // Make sure that things mesh with the attribute definition table.

    if (AttributeDefTable) {


        if (_Data->TypeCode == $UNUSED ||
            !AttributeDefTable->QueryIndex(_Data->TypeCode, &index)) {

            // The attribute type code doesn't exist in the attribute
            // definition table.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_ATTR_TO_ATTR_DEF_TABLE,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d does not exist in the definition table.\n", _Data->TypeCode));
            return FALSE;
        }

        column_flags = AttributeDefTable->QueryFlags(index);

        if (IsResident() &&
            (_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) &&
            !(column_flags & ATTRIBUTE_DEF_INDEXABLE)) {

            // Non-indexable indexed attribute.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d is NOT indexable.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_INDEXED) &&
            !(IsResident() &&
              (_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED))) {

            // Attribute must be indexed but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST be indexed.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_INDEXABLE) && _Data->NameLength) {

            // Indexable attributes cannot have names.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEXABLE_ATTR_SHOULD_NOT_HAVE_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Attribute %d cannot have a name.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_NAMED) &&
            !_Data->NameLength) {

            // Attribute must be named but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_NAMED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST have a name.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_RESIDENT) &&
            !IsResident()) {

            // Attribute must be resident but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_RESIDENT,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST be resident.\n", _Data->TypeCode));
            return FALSE;
        }

        if (IsResident()) {
            length = _Data->Form.Resident.ValueLength;
        } else if (_Data->Form.Nonresident.LowestVcn == 0) {
            length = _Data->Form.Nonresident.FileSize;
        } else {
            length = 0;
        }

        if (length != 0) {

            if (length < AttributeDefTable->QueryMinimumLength(index)) {

                // Length is less than the minimum.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_SMALL,
                                 "%I64x%x%x%x",
                                 length.GetLargeInteger(),
                                 AttributeDefTable->QueryMinimumLength(index),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has length less than the minimum.\n", _Data->TypeCode));
                return FALSE;
            }

            // Note that a value of -1 in the Length field of the
            // Attribute Definition Table entry indicates that the
            // attribute can be as large as it pleases.
            //
            // Note the length of the $STANDARD_INFORMATION attribute
            // is checked above.
            //

            if (AttributeDefTable->QueryMaximumLength(index) != -1 &&
                length > AttributeDefTable->QueryMaximumLength(index) &&
                _Data->TypeCode != $VOLUME_VERSION &&
                _Data->TypeCode != $STANDARD_INFORMATION ) {

                // Length is greater than the maximum.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_BIG,
                                 "%I64x%x%x%x",
                                 length.GetLargeInteger(),
                                 AttributeDefTable->QueryMaximumLength(index),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has length greater than the maximum.\n", _Data->TypeCode));
                return FALSE;
            }
        }
    }


    if (IsResident()) {

        // Make sure that the value is in bounds and
        // make sure that name comes before value.

        if (_Data->Form.Resident.ValueLength > _Data->RecordLength ||
            _Data->Form.Resident.ValueOffset >
            _Data->RecordLength - _Data->Form.Resident.ValueLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_RESIDENT_ATTR,
                             "%x%x%x%x%x",
                             _Data->Form.Resident.ValueLength,
                             _Data->Form.Resident.ValueOffset,
                             _Data->RecordLength,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has corrupt resident value.\n", _Data->TypeCode));
            return FALSE;
        }

        if (_Data->NameOffset +
            _Data->NameLength >
            _Data->Form.Resident.ValueOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_RESIDENT_ATTR_COLLISION,
                             "%x%x%x%x%x",
                             _Data->NameLength,
                             _Data->NameOffset,
                             _Data->Form.Resident.ValueOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d colliding name and resident value.\n", _Data->TypeCode));
            return FALSE;
        }

        // Make sure that if the attribute is indexed then it
        // has no name.

        if ((_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) &&
            _Data->NameLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEXABLE_ATTR_SHOULD_NOT_HAVE_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Attribute %d is indexed AND has a name.\n", _Data->TypeCode));
            return FALSE;
        }


    } else {

        // Make sure that the mapping pairs are in bounds.

        if (_Data->Form.Nonresident.MappingPairsOffset >=
            _Data->RecordLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_HAS_BAD_MAPPING_PAIRS_OFFSET,
                             "%x%x%x%x",
                             _Data->Form.Nonresident.MappingPairsOffset,
                             _Data->RecordLength,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has mapping pairs that are out of bounds.\n", _Data->TypeCode));
            return FALSE;
        }

        if (QuadAlign(_Data->Form.Nonresident.MappingPairsOffset) !=
            _Data->Form.Nonresident.MappingPairsOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_HAS_UNALIGNED_MAPPING_PAIRS_OFFSET,
                             "%x%x%x%x",
                             _Data->Form.Nonresident.MappingPairsOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has unaligned mapping pairs offset %x.\n",
                             _Data->Form.Nonresident.MappingPairsOffset));
            return FALSE;
        }

        if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                             ATTRIBUTE_FLAG_SPARSE)) != 0) {

            if (_Data->Form.Nonresident.LowestVcn == 0 &&
                _Data->Form.Nonresident.MappingPairsOffset <
                    4 * sizeof(BIG_INT)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_MAPPING_PAIRS_OFFSET_TOO_SMALL,
                                     "%x%x%x%x",
                                     _Data->Form.Nonresident.MappingPairsOffset,
                                     4 * sizeof(BIG_INT),
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        }
                    }

                    DebugPrintTrace(("Attribute %d MappingPairsOffset too small (%d).\n",
                                     _Data->TypeCode,
                                     _Data->Form.Nonresident.MappingPairsOffset));

                return FALSE;
            }
        } else {
            if (_Data->Form.Nonresident.LowestVcn == 0 &&
                _Data->Form.Nonresident.MappingPairsOffset <
                    3 * sizeof(BIG_INT)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_MAPPING_PAIRS_OFFSET_TOO_SMALL,
                                     "%x%x%x%x",
                                     _Data->Form.Nonresident.MappingPairsOffset,
                                     3 * sizeof(BIG_INT),
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        }
                    }

                    DebugPrintTrace(("Attribute %d has MappingPairsOffset too small (%d).\n",
                                     _Data->TypeCode,
                                     _Data->Form.Nonresident.MappingPairsOffset));
            }
        }

        // Make sure that the name comes before the mapping pairs.

        if (_Data->NameLength &&
            _Data->NameOffset +
            _Data->NameLength >
            _Data->Form.Nonresident.MappingPairsOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_COLLISION,
                             "%x%x%x%x%x",
                             _Data->NameLength,
                             _Data->NameOffset,
                             _Data->Form.Nonresident.MappingPairsOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has its name colliding with the mapping pairs.\n", _Data->TypeCode));
            return FALSE;
        }


        // Validate the mapping pairs.

        bad_mapping_pairs = FALSE;

        if (!extent_list.Initialize(_Data->Form.Nonresident.LowestVcn,
                                    (PCHAR) _Data +
                                    _Data->Form.Nonresident.MappingPairsOffset,
                                    _Data->RecordLength -
                                    _Data->Form.Nonresident.MappingPairsOffset,
                                    &bad_mapping_pairs)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {

                    MSGID   msgid;

                    if (bad_mapping_pairs) {
                        msgid = MSG_CHKLOG_NTFS_BAD_MAPPING_PAIRS;
                    } else {
                        msgid = MSG_CHKLOG_NTFS_UNABLE_TO_INITIALIZE_EXTENT_LIST;
                    }
                    msg->LogMsg(msgid,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has bad mapping pairs.\n", _Data->TypeCode));
            return FALSE;
        }

        if (extent_list.QueryNextVcn() !=
            _Data->Form.Nonresident.HighestVcn + 1 && !BeLenient) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_HAS_INVALID_HIGHEST_VCN,
                             "%I64x%I64x%x%x",
                             _Data->Form.Nonresident.HighestVcn + 1,
                             extent_list.QueryNextVcn().GetLargeInteger(),
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has an invalid highest vcn.\n", _Data->TypeCode));
            return FALSE;
        }


        // If the lowest vcn is 0 then make sure that the three sizes
        // make sense.

        if (_Data->Form.Nonresident.LowestVcn == 0 && !BeLenient) {

            if (CompareGT(_Data->Form.Nonresident.ValidDataLength,
                          _Data->Form.Nonresident.FileSize) ||
                CompareGT(_Data->Form.Nonresident.FileSize,
                          _Data->Form.Nonresident.AllocatedLength)) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_SIZES,
                                 "%I64x%I64x%I64x%x%x",
                                 _Data->Form.Nonresident.ValidDataLength,
                                 _Data->Form.Nonresident.FileSize,
                                 _Data->Form.Nonresident.AllocatedLength,
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has inconsistent sizes.\n", _Data->TypeCode));
                return FALSE;
            }

            if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE)) != 0 &&
                CompareGT(_Data->Form.Nonresident.TotalAllocated,
                          _Data->Form.Nonresident.AllocatedLength)) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_TOTAL_ALLOC,
                                 "%I64x%I64x%x%x",
                                 _Data->Form.Nonresident.TotalAllocated,
                                 _Data->Form.Nonresident.AllocatedLength,
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has inconsistent TotalAllocated.\n",
                    _Data->TypeCode));
#if 0
//
// This would cause the attribute record to be deleted, which is considered
// to be too harsh a penalty for this minor error.
//
                return FALSE;
#endif
            }

            if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE |
                                 ATTRIBUTE_FLAG_ENCRYPTED)) != 0 &&
                (_Data->Form.Nonresident.AllocatedLength %
                 (1 << QueryCompressionUnit())) != 0) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_TOTAL_ALLOC_BLOCK,
                                 "%I64x%x%x%x",
                                 _Data->Form.Nonresident.AllocatedLength,
                                 1<<QueryCompressionUnit(),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has TotalAllocated not multiple of "
                                 "compression unit\n", _Data->TypeCode));

                return FALSE;
            }
        }

    }


    // $FILE_NAME attribute must follow additional special structure.

    if (_Data->TypeCode == $FILE_NAME) {

        if (!IsIndexed()) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("File name attribute is not indexed.\n"));
            return FALSE;
        }

        file_name = (PFILE_NAME) ((PCHAR) _Data +
                                  _Data->Form.Resident.ValueOffset);

        value_length = _Data->Form.Resident.ValueLength;

        if (value_length < sizeof(FILE_NAME)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_FILE_NAME_VALUE_LENGTH_TOO_SMALL,
                             "%x%x%x%x",
                             value_length,
                             sizeof(FILE_NAME),
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }

        if (NtfsFileNameGetLength(file_name) != value_length) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_FILE_NAME_VALUE);
                    msg->Log("%x%x%x",
                             value_length,
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(file_name, NtfsFileNameGetLength(file_name));
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }

        if (file_name->FileNameLength == 0) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_LENGTH_IN_FILE_NAME_VALUE);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(file_name, sizeof(FILE_NAME)+0x20);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }


        // Make sure that the file name has no NULL
        // characters in it.  If it does then the attribute
        // is "corrupt".

        for (i = 0; i < file_name->FileNameLength; i++) {
            if (!file_name->FileName[i]) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->Lock();
                        msg->Set(MSG_CHKLOG_NTFS_NULL_FOUND_IN_FILE_NAME_OF_FILE_NAME_VALUE);
                        msg->Log("%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                        msg->DumpDataToLog(file_name, NtfsFileNameGetLength(file_name));
                        msg->Unlock();
                    }
                }

                DebugPrintTrace(("Attribute %d has filename w/ null characters\n", _Data->TypeCode));
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    OUT     PBIG_INT        ClusterCount
    ) CONST
/*++

Routine Description:

    This routine allocates the disk space claimed by this attribute
    record in the bitmap provided.  A check is made to verify that
    the requested disk space is free before the allocation takes
    place.  If the requested space is not available in the bitmap
    then this routine will return FALSE.

Arguments:

    VolumeBitmap    - Supplies the bitmap.
    ClusterCount    - Receives the number of clusters allocated
                      to this record.  Not set if method fails.

Return Value:

    FALSE   - The request bitmap space was not available.
    TRUE    - Success.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    ULONG               num_extents;
    ULONG               i, j;
    VCN                 next_vcn;
    LCN                 current_lcn;
    BIG_INT             run_length;

    DebugAssert(VolumeBitmap);

    if (IsResident()) {
        *ClusterCount = 0;
        return TRUE;
    }

    if (!QueryExtentList(&extent_list)) {
        return FALSE;
    }

    num_extents = extent_list.QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!extent_list.QueryExtent(i, &next_vcn, &current_lcn,
                                     &run_length)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_EXTENT_FAILED,
                             "%x%x%x", QueryTypeCode(), QueryInstanceTag(), i);
                }
            }
            return FALSE;
        }

        if (current_lcn == LCN_NOT_PRESENT) {
            continue;
        }


        // Make sure that the run is free before allocating.
        // If it is not, this indicates a cross-link.

        if (!VolumeBitmap->IsFree(current_lcn, run_length)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_REC_CROSS_LINKED,
                             "%x%x%I64x%I64x",
                             QueryTypeCode(), QueryInstanceTag(),
                             current_lcn, run_length);
                }
            }

            DebugPrintTrace(("cross-linked run starts at 0x%I64x for 0x%I64x\n",
                             current_lcn.GetLargeInteger(),
                             run_length.GetLargeInteger()));

            // Free everything so far allocated by this routine.

            for (j = 0; j < i; j++) {

                if (!extent_list.QueryExtent(j, &next_vcn, &current_lcn,
                                             &run_length)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_EXTENT_FAILED,
                                     "%x%x%x", QueryTypeCode(), QueryInstanceTag(), i);
                        }
                    }
                    DebugAbort("Could not query extent");
                    return FALSE;
                }
                if (current_lcn == LCN_NOT_PRESENT) {
                    continue;
                }

                VolumeBitmap->SetFree(current_lcn, run_length);
            }

            return FALSE;
        }

        VolumeBitmap->SetAllocated(current_lcn, run_length);
    }

    *ClusterCount = extent_list.QueryClustersAllocated();
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    OUT     PBIG_INT        ClusterCount,
    IN      ULONG           AllowCrossLinkStart,
    IN      ULONG           AllowCrossLinkLength,
    OUT     PBOOLEAN        DidCrossLinkOccur
    ) CONST
/*++

Routine Description:

    This routine allocates the disk space claimed by this attribute
    record in the bitmap provided.  A check is made to verify that
    the requested disk space is free before the allocation takes
    place.  If the requested space is not available in the bitmap
    then this routine will return FALSE.

    This methode assumes that the range specified by the Allow
    parameters are marked as allocated in the given bitmap.

Arguments:

    VolumeBitmap            - Supplies the bitmap.
    ClusterCount            - Receives the number of clusters allocated
                                to this record.  Not set if method fails.
    AllowCrossLinkStart     - Supplies the start of a range where
                                cross-links are allowed.
    AllowCrossLinkLength    - Supplies the length of the range where
                                cross-links are allowed.
    DidCrossLinkOccur       - Returns whether or not an allowable
                                cross-link occurred.

Return Value:

    FALSE   - The request bitmap space was not available.
    TRUE    - Success.

--*/
{
    BOOLEAN r;

    DebugAssert(DidCrossLinkOccur);

    *DidCrossLinkOccur = FALSE;

    if (UseClusters(VolumeBitmap,ClusterCount)) {
        return TRUE;
    }

    *DidCrossLinkOccur = TRUE;

    if (AllowCrossLinkLength == 0)  // if we are not freeing any cluster
                                    // there is no need to check again
        return FALSE;

    VolumeBitmap->SetFree(AllowCrossLinkStart, AllowCrossLinkLength);

    r = UseClusters(VolumeBitmap,ClusterCount);

    VolumeBitmap->SetAllocated(AllowCrossLinkStart, AllowCrossLinkLength);

    return r;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UnUseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      ULONG           LeaveInUseStart,
    IN      ULONG           LeaveInUseLength
    ) CONST
/*++

Routine Description:

    This operation reverses a successful 'UseClusters' operation.

    This method assumes that the LeaveInUse range is already in
    use by the bitmap.

Arguments:

    VolumeBitmap        - Supplies the bitmap.
    LeaveInUseStart     - Supplies the start of the range that this routine
                            should leave in use.
    LeaveInUseLength    - Supplies the length of the range that this
                            routine should leave in use.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    ULONG               num_extents;
    ULONG               i;
    VCN                 next_vcn;
    LCN                 current_lcn;
    BIG_INT             run_length;

    DebugAssert(VolumeBitmap);

    if (IsResident() || _DisableUnUse) {
        return TRUE;
    }

    if (!QueryExtentList(&extent_list)) {
        return FALSE;
    }

    num_extents = extent_list.QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!extent_list.QueryExtent(i, &next_vcn, &current_lcn,
                                     &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        VolumeBitmap->SetFree(current_lcn, run_length);
    }

    VolumeBitmap->SetAllocated(LeaveInUseStart, LeaveInUseLength);

    return TRUE;
}



NONVIRTUAL
UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::QueryName(
    OUT PWSTRING    Name
    ) CONST
/*++

Routine Description:

    This method returns the name of the attribute.

Arguments:

    Name    - Returns the name of the attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Flags) >= _MaximumLength ||
        ULONG(_Data->NameOffset + _Data->NameLength) > _MaximumLength ||
        _Data->NameLength == 0) {

        return Name->Initialize( "" );

    } else {

        return Name->Initialize((PWSTR)((PBYTE)_Data + _Data->NameOffset),
                                _Data->NameLength);

    }
}


VOID
NTFS_ATTRIBUTE_RECORD::QueryValueLength(
    OUT PBIG_INT ValueLength,
    OUT PBIG_INT AllocatedLength,
    OUT PBIG_INT ValidLength,
    OUT PBIG_INT TotalAllocated
    ) CONST
/*++

Routine Description:

    This method returns the actual, allocated, valid, and
    total allocated lengths
    of the attribute value associated with this record.

    If the attribute is resident, these values are all
    the length of the resident value, except total allocated,
    which is meaningless.

    If the attribute is nonresident, these four values are only
    meaningful if the LowestVcn of this attribute record is 0.
    Additionally, TotalAllocated is only valid for compressed
    attributes.

Arguments:

    ValueLength     -- receives the actual length of the value.
    AllocatedLength -- receives the allocated size of the value.
                        (may be NULL if the caller doesn't care)
    ValidLength     -- receives the valid length of the value.
                        (may be NULL if the caller doesn't care)
    TotalAllocated  -- receives the total allocated length of the
                        value (may be NULL).

Return Value:

    None.

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == RESIDENT_FORM ) {

        *ValueLength = _Data->Form.Resident.ValueLength;

        if( AllocatedLength != NULL ) {

            *AllocatedLength = _Data->Form.Resident.ValueLength;
        }

        if( ValidLength != NULL ) {

            *ValidLength = _Data->Form.Resident.ValueLength;
        }

        if (TotalAllocated != NULL ) {

            // no such value for resident attributes

            *TotalAllocated = 0;
        }

    } else {

        DebugAssert( _Data->FormCode == NONRESIDENT_FORM );

        *ValueLength = _Data->Form.Nonresident.FileSize;

        if( AllocatedLength != NULL ) {

            *AllocatedLength = _Data->Form.Nonresident.AllocatedLength;
        }

        if( ValidLength != NULL ) {

            *ValidLength = _Data->Form.Nonresident.ValidDataLength;
        }

        if (TotalAllocated != NULL) {
            if ((_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE)) != 0) {
                *TotalAllocated = _Data->Form.Nonresident.TotalAllocated;
            } else {
                *TotalAllocated = 0;
            }
        }

    }
}

VOID
NTFS_ATTRIBUTE_RECORD::SetTotalAllocated(
    IN BIG_INT TotalAllocated
    )
/*++

Routine Description:

    Set the "TotalAllocated" field in the attribute record.  If the
    attribute record doesn't have a total allocated field because
    the attribute isn't compressed or because it's resident, this
    method has no effect.

Arguments:

    TotalAllocated - the new value.

Return Value:

    None.

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == RESIDENT_FORM ) {

        // no such value for resident attributes; ignore

        return;

    }

    DebugAssert( _Data->FormCode == NONRESIDENT_FORM );

    if ((_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                         ATTRIBUTE_FLAG_SPARSE)) != 0) {
        _Data->Form.Nonresident.TotalAllocated =
            TotalAllocated.GetLargeInteger();
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::QueryExtentList(
    OUT PNTFS_EXTENT_LIST   ExtentList
    ) CONST
/*++

Routine Description:

Arguments:

    None.

Return Value:

    A pointer to the extent list.  A return value of NULL indicates
    that the attribute is resident or that an error occurred processing
    the compressed mapping pairs.  (Clients should use IsResident to
    determine whether the attribute value is resident.)

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == NONRESIDENT_FORM &&
        ExtentList->Initialize( _Data->Form.Nonresident.LowestVcn,
                                (PVOID)((PBYTE)_Data +
                                    _Data->Form.Nonresident.MappingPairsOffset),
                                 _MaximumLength -
                                    _Data->Form.Nonresident.
                                        MappingPairsOffset ) ) {

        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::IsMatch(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength
    ) CONST
/*++

Routine Description:

    This method determines whether the attribute record matches the
    parameters given.

Arguments:

    Type        --  Supplies the type code of the attribute.  This
                        is the primary key, and must always be present.
    Name        --  Supplies a name to match.  A name of NULL is the
                        same as specifying the null string.
    Value       --  Supplies the value to match.  If this argument is
                        null, any value matches.  Only resident
                        attributes can be checked for value matches.
    ValueLength --  Supplies the length of the value (if any).

Notes:

    Value matching is not supported for nonresident attribute values;
    if a Value parameter is supplied, then no non-resident attribute
    records will match.

--*/
{
    DSTRING RecordName;

    DebugPtrAssert( _Data );

    if( Type != _Data->TypeCode ) {

        return FALSE;
    }

    if( Name != NULL ) {

        if( !RecordName.Initialize((PWSTR)((PBYTE)_Data + _Data->NameOffset),
                                   _Data->NameLength ) ) {

            return FALSE;
        }

        if( Name->Strcmp( &RecordName ) != 0 ) {

            return FALSE;
        }
    } else if (_Data->NameLength) {
        return FALSE;
    }

    if( Value != NULL &&
        ( _Data->FormCode != RESIDENT_FORM ||
          ValueLength != _Data->Form.Resident.ValueLength ||
          memcmp( Value,
                  (PBYTE)_Data + _Data->Form.Resident.ValueOffset,
                  (UINT) ValueLength ) ) ) {

        return FALSE;
    }

    return TRUE;
}


LONG
CompareAttributeRecords(
    IN  PCNTFS_ATTRIBUTE_RECORD Left,
    IN  PCNTFS_ATTRIBUTE_RECORD Right,
    IN  PCNTFS_UPCASE_TABLE     UpcaseTable
    )
/*++

Routine Description:

    This method compares two attribute records to determine their
    correct ordering in the File Record Segment.

Arguments:

    Left        --  Supplies the left-hand operand of the comparison.
    Right       --  Supplies the right-hand operand of the comparison.
    UpcaseTable --  Supplies the upcase table for the volume.
                    If this parameter is NULL, name comparison
                    cannot be performed.

Return Value:

    <0 if Left is less than Right
     0 if Left equals Right
    >0 if Left is greater than Right.

Notes:

    Attribute records are ordered first by type code and then
    by name.  An attribute record without a name is less than
    any attribute record of the same type with a name.

    Name comparision is first done case-insensitive; if the names
    are equal by that metric, a case-sensitive comparision is made.

    The UpcaseTable parameter may be omitted if either or both names
    are zero-length, or if they are identical (including case).
    Otherwise, it must be supplied.

--*/
{
    ULONG Result;

    // First, compare the type codes:
    //
    Result = Left->QueryTypeCode() - Right->QueryTypeCode();

    if( Result != 0 ) {

        return Result;
    }

    // They have the same type code, so we have to compare the names.
    // Pass in TRUE for the IsAttribute parameter, to indicate that
    // we are comparing attribute names.
    //
    return( NtfsUpcaseCompare( Left->GetName(),
                               Left->QueryNameLength(),
                               Right->GetName(),
                               Right->QueryNameLength(),
                               UpcaseTable,
                               TRUE ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\downgrad.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    ntfschk.cxx

Abstract:

    This module implements NTFS CHKDSK.

Author:

    Norbert P. Kusters (norbertk) 29-Jul-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#if defined(TIMING_ANALYSIS)
extern "C" {
    #include <stdio.h>
    #include <time.h>
}
#endif

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"

BOOLEAN
NTFS_SA::DownGradeNtfs(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes an NTFS volume.

Arguments:

    Message             - Supplies an outlet for messages.
    Mft                 - Supplies the MFT.
    ChkdskInfo          - Supplies the current chkdsk info.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if 1
    return FALSE;
#else
    ULONG                       i, j, n;
    PSTANDARD_INFORMATION       standard_information;
    PSTANDARD_INFORMATION2      standard_information2;
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_FILE_RECORD_SEGMENT    extend_frs;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    ULONG                       percent;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     error;
    BOOLEAN                     changes;
    ULONG                       depth;
    ULONG                       bytesWritten;
    NTFS_INDEX_TREE             index;
    PVOLUME_INFORMATION         vol_info;
    DSTRING                     name;
    NUMBER_SET                  bad_clusters;

    extern WCHAR          FileNameQuota[];
    CONST USHORT                FileNameBufferSize = 256;
    CHAR                        FileNameBuffer[FileNameBufferSize];
    CONST PFILE_NAME            FileName = (PFILE_NAME)FileNameBuffer;
    CONST PVOID                 FileNameValue = NtfsFileNameGetName( FileName );
    MFT_SEGMENT_REFERENCE       RootFileIndexSegment;
    STANDARD_INFORMATION        StandardInformation;
    LARGE_INTEGER               SystemTime;
    PCINDEX_ENTRY               index_entry;
    NTFS_ATTRIBUTE_COLUMNS      attr_def_table;
    NTFS_ATTRIBUTE_DEFINITION_TABLE attr_def_file;
    USHORT                      volume_flags;
    BOOLEAN                     corrupt_volume;
    UCHAR                       major, minor;

    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor);
    if (corrupt_volume) {
        Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
        return FALSE;
    }

    // If volume is current, a downgrade followed by an upgrade will have no effect.
    // If volume is not current, a upgrade followed by a downgrade will have no effect.
    // So, remove upgrade bit and return in any case.

    if (volume_flags & VOLUME_UPGRADE_ON_MOUNT) {
        if (!ClearVolumeFlag(VOLUME_UPGRADE_ON_MOUNT,
                             NULL,
                             FALSE,
                             LargestLsnEncountered,
                             &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
            return FALSE;
        }
        Message->DisplayMsg(MSG_CHK_NTFS_UPGRADE_DOWNGRADE);
        return TRUE;
    }

    //
    // make sure the version to operate on is correct
    //

    if (ChkdskInfo->major != 3 && ChkdskInfo->major != 2) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_DOWNGRADE);
        return TRUE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_SCANNING);

    percent = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
        return FALSE;
    }

    n = ChkdskInfo->NumFiles;
    for (i = 0; i < n; i++) {

        if (i*100/n > percent) {
            percent = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {
            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = n - i;
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!frs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!frs.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (!frs.ReadNext(i))
            continue;

        if (Mft->GetMftBitmap()->IsFree(i, 1) ||
            !frs.IsInUse() ||
            !frs.IsBase()) {
            continue;
        }

        // scan for $REPARSE_POINT attribute

        if (frs.QueryAttribute(&attrib,
                               &error,
                               $REPARSE_POINT)) {
            Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan for $LOGGED_UTILITY_STREAM attributes

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $LOGGED_UTILITY_STREAM,
                                              j); j++) {
            Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan for $PROPERTY_SET attributes

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $PROPERTY_SET,
                                              j); j++) {
            Message->DisplayMsg(MSG_CHK_NTFS_PROPERTY_SET_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan all $data for sparse or encryption settings

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $DATA,
                                              j); j++) {
            if (attrib.QueryFlags() & ATTRIBUTE_FLAG_ENCRYPTED) {
                Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE_FOUND,
                                 "%d", i);
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
                return TRUE;
            }
            if (attrib.QueryFlags() & ATTRIBUTE_FLAG_SPARSE) {
                Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE_FOUND,
                                 "%d", i);
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
                return TRUE;
            }
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100);

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_SCANNING_COMPLETED);

    //
    // now look for encrypted bits and turn them off
    // delete any object Id found
    // reduce the size of large standard information
    // Add security descriptor attribute
    //

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE);

    percent = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
        return FALSE;
    }

    for (i = 0; i < n; i++) {

        if (i*100/n > percent) {
            percent = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {
            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = n - i;
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!frs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!frs.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.ReadNext(i))
            continue;

        if (Mft->GetMftBitmap()->IsFree(i, 1) ||
            !frs.IsInUse() ||
            !frs.IsBase()) {
            continue;
        }

        if (!frs.PurgeAttribute($OBJECT_ID)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.QueryAttribute(&attrib,
                               &error,
                               $STANDARD_INFORMATION)) {
            DebugPrintTrace(("Standard Information is missing from FRS %d\n",
                            frs.QueryFileNumber().GetLowPart()));
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                 "%d", i);
                return FALSE;
            }
            continue;
        }
        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (attrib.QueryValueLength() != sizeof(STANDARD_INFORMATION2)) {
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                 "%d", i);
                return FALSE;
            }
            continue;   // if small standard information, we are done!
        }

        if (!attrib.Resize(sizeof(STANDARD_INFORMATION), Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }

        standard_information = (PSTANDARD_INFORMATION)attrib.GetResidentValue();

        //
        // clear some flags just to be sure; they should not be there in the first place
        //

        standard_information->FileAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED|
                                                   FILE_ATTRIBUTE_SPARSE_FILE|
                                                   FILE_ATTRIBUTE_REPARSE_POINT);
        standard_information->Reserved = 0;

        if (!attrib.Write(standard_information,
                          0,
                          sizeof(STANDARD_INFORMATION),
                          &bytesWritten,
                          Mft->GetVolumeBitmap()) ||
            bytesWritten != sizeof(STANDARD_INFORMATION)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }
        if (attrib.IsStorageModified() &&
            !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }
        if (!frs.AddSecurityDescriptor(EditCannedSd, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                             "%d", i);
            return FALSE;
        }
        if (!frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                             "%d", i);
            return FALSE;
        }

        //
        // don't worry about the same bits in attribute flag in DUPLICATED_INFORMATION
        // as they should not be there in the first place.  If they were there,
        // chkdsk will fix it up as minor inconsistences.
        //
    }

    Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100);

    //
    // now go thru the extend directory and eliminate things inside it
    //

    if (!extend_frs.Initialize(EXTEND_TABLE_NUMBER, Mft) ||
        !extend_frs.Read() ||
        !name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive, QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          extend_frs.QuerySize()/2,
                          &extend_frs,
                          &name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    ChkdskInfo->ObjectIdFileNumber = 0;
    ChkdskInfo->QuotaFileNumber = 0;
    ChkdskInfo->UsnJournalFileNumber = 0;
    ChkdskInfo->ReparseFileNumber = 0;

    if (!ExtractExtendInfo(&index, ChkdskInfo, Message)) {
        return FALSE;
    }

    if (ChkdskInfo->ObjectIdFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->ObjectIdFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->QuotaFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->QuotaFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->UsnJournalFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->UsnJournalFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->ReparseFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->ReparseFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (!frs.Initialize(SECURITY_TABLE_NUMBER, Mft) || !frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    frs.Delete(Mft->GetVolumeBitmap());

    extend_frs.Delete(Mft->GetVolumeBitmap());

    //
    // Remove the $Security & $Extend entries from the root index
    //

    if (!root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) || !root_frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive, QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          root_frs.QuerySize()/2,
                          &root_frs,
                          &name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    index.ResetIterator();

    while (index_entry = index.GetNext(&depth, &error)) {
        switch (index_entry->FileReference.LowPart) {
            case SECURITY_TABLE_NUMBER:
            case EXTEND_TABLE_NUMBER:
                if (index_entry->FileReference.HighPart == 0) {
                    if (!index.DeleteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
                break;
        }
    }

    //
    // Re-Initialize FRS 0x9 to $Quota FRS
    //

    RootFileIndexSegment.LowPart = ROOT_FILE_NAME_INDEX_NUMBER;
    RootFileIndexSegment.HighPart = 0;
    RootFileIndexSegment.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameQuota );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameQuota,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // Set up the Standard Information structure that will
    // be used by all the special files.  The creation and modification
    // times are now, and all files created by format are hidden.

    memset( (PVOID)&StandardInformation,
            0,
            sizeof(STANDARD_INFORMATION) );

    IFS_SYSTEM::QueryNtfsTime( &SystemTime );

    StandardInformation.CreationTime =
        StandardInformation.LastModificationTime =
        StandardInformation.LastChangeTime =
        StandardInformation.LastAccessTime = SystemTime;

    StandardInformation.FileAttributes = FILE_ATTRIBUTE_HIDDEN |
                                         FILE_ATTRIBUTE_SYSTEM;

    Mft->GetMftBitmap()->SetAllocated( QUOTA_TABLE_NUMBER, 1);

    if( !frs.Initialize( QUOTA_TABLE_NUMBER,
                         Mft ) ||
        !frs.Create( &StandardInformation ) ||
        !frs.AddEmptyAttribute( $DATA ) ||
        !frs.AddFileNameAttribute( FileName ) ||
        !frs.AddSecurityDescriptor( WriteCannedSd, Mft->GetVolumeBitmap() ) ||
        !index.InsertEntry( NtfsFileNameGetLength( FileName ),
                            FileName,
                            frs.QuerySegmentReference() ) ||
        !frs.Flush(Mft->GetVolumeBitmap(), &index) ) {

        DebugPrint( "Can't create Quota Table File Record Segment.\n" );
        return FALSE;
    }

    //
    // Re-Initialize FRS 0xB to a generic FRS
    //

    Mft->GetMftBitmap()->SetAllocated( EXTEND_TABLE_NUMBER, 1 );

    if( !frs.Initialize( EXTEND_TABLE_NUMBER, Mft ) ||
        !frs.Create( &StandardInformation ) ||
        !frs.AddEmptyAttribute( $DATA ) ||
        !frs.AddSecurityDescriptor( WriteCannedSd, Mft->GetVolumeBitmap() ) ||
        !frs.Flush( Mft->GetVolumeBitmap() ) ) {

        DebugPrint( "Can't create a generic FRS.\n" );
        return FALSE;
    }

    //
    // Fix up the Attribute Definition Table
    //

    SetVersionNumber(1,2);  // back to NTFS for NT 4.0

    if (!FetchAttributeDefinitionTable(NULL,
                                       Message,
                                       &attr_def_table)) {
        return FALSE;
    }

    if (!attr_def_file.Initialize(Mft, 1) ||
        !bad_clusters.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!attr_def_file.Read()) {
        DebugAbort("Can't read in hotfixed attribute definition file.");
        return FALSE;
    }

    if (!attr_def_file.VerifyAndFix(&attr_def_table,
                                    Mft->GetVolumeBitmap(),
                                    &bad_clusters,
                                    &index,
                                    &changes,
                                    TotalFix,
                                    Message,
                                    TRUE)) {
        return FALSE;
    }

    if( !index.Save( &root_frs ) ||
        !root_frs.Flush( Mft->GetVolumeBitmap() ) ) {

        DebugPrint( "Can't save root index.\n" );
        return FALSE;
    }

    //
    // change volume version from 3.0 (for NT 5.0) to 1.2 (for NT 4.0)
    //

    if (!frs.Initialize(VOLUME_DASD_NUMBER, Mft) || !frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.QueryAttribute(&attrib, &error, $VOLUME_INFORMATION) || error) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_VOLUME_VERSION);
        return FALSE;
    }

    vol_info = (PVOLUME_INFORMATION)attrib.GetResidentValue();
    vol_info->MajorVersion = 1;
    vol_info->MinorVersion = 2;

    if (!attrib.Write(vol_info,
                      0,
                      sizeof(VOLUME_INFORMATION),
                      &bytesWritten,
                      NULL)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                         "%d%d", attrib.QueryTypeCode(), VOLUME_DASD_NUMBER);
        return FALSE;
    }
    if (attrib.IsStorageModified() &&
        !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                         "%d%d", attrib.QueryTypeCode(), VOLUME_DASD_NUMBER);
        return FALSE;
    }
    if (!frs.Flush(Mft->GetVolumeBitmap())) {
        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                         "%d", VOLUME_DASD_NUMBER);
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_COMPLETED);

    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\bitfrs.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	bitfrs.cxx

Abstract:

	This module contains the member function definitions for
    the NTFS_BITMAP_FILE class.

Author:

	Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "bitfrs.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BITMAP_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BITMAP_FILE::~NTFS_BITMAP_FILE(
	)
{
	Destroy();
}


VOID
NTFS_BITMAP_FILE::Construct(
	)
/*++

Routine Description:

	Worker function for the construtor.

Arguments:

	None.

Return Value:

	None.

--*/
{
}


VOID
NTFS_BITMAP_FILE::Destroy(
	)
/*++

Routine Description:

	Clean up an NTFS_BITMAP_FILE object in preparation for
	destruction or reinitialization.

Arguments:

	None.

Return Value:

	None.

--*/
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP_FILE::Initialize(
	IN OUT  PNTFS_MASTER_FILE_TABLE	Mft
	)
/*++

Routine Description:

    This method initializes a Bitmap File object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Bitmap File.

Arguments:

	Mft 			-- Supplies the volume MasterFile Table.

Return Value:

	TRUE upon successful completion

Notes:

	This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( BIT_MAP_FILE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_BITMAP_FILE::Create(
	IN      PCSTANDARD_INFORMATION	StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
	)
/*++

Routine Description:

    This method formats a Bitmap-File File Record
    Segment in memory (without writing it to disk).

    It creates a DATA attribute to hold the volume bitmap, and
    allocates space on disk for the bitmap.  Note that it does
    not write the bitmap.

Arguments:

	StandardInformation -- supplies the standard information for the
							file record segment.

    VolumeBitmap        -- supplies the volume bitmap

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN BitmapLcn;
    BIG_INT NumberOfClusters;
    ULONG Size;
    ULONG ClusterSize;
    ULONG ClustersToHoldBitmap;


    // Set this object up as a File Record Segment.

	if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }


    // Determine the number of clusters necessary to hold the bitmap.

    NumberOfClusters = VolumeBitmap->QuerySize();

    if( NumberOfClusters.GetHighPart() != 0 ) {

        DebugAbort( "Bitmap is too big.\n" );
        return FALSE;
    }

    Size = NumberOfClusters.GetLowPart()/8;

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    if( NumberOfClusters.GetLowPart() % (ULONG)8 ) {

        Size += 1;
    }

    Size = QuadAlign(Size);

    ClustersToHoldBitmap = Size/ClusterSize;
    if( Size % ClusterSize ) {

        ClustersToHoldBitmap++;
    }

    // Create a zero-length non-resident attribute, and
    // then resize it to the correct size to hold the bitmap.
    //
    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.Resize( ClustersToHoldBitmap, VolumeBitmap ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   Size,
                                   Size,
                                   $DATA ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\attrlist.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    attrlist.cxx

Abstract:

    This module contains the member function definitions for
    NTFS_ATTRIBUTE_LIST, which models an ATTRIBUTE_LIST Attribute
    in an NTFS File Record Segment.

    If a file has any external attributes (i.e. if it has more than
    one File Record Segment), then it will have an ATTRIBUTE_LIST
    attribute.  This attribute's value consists of a series of
    Attribute List Entries, which describe the attribute records
    in the file's File Record Segments.  There is an entry for each
    attribute record attached to the file, including the attribute
    records in the base File Record Segment, and in particular
    including the attribute records which describe the ATTRIBUTE_LIST
    attribute itself.

    An entry in the Attribute List gives the type code and name (if any)
    of the attribute, along with the LowestVcn of the attribute record
    (zero if the attribute record is Resident) and a segment reference
    (which combines an MFT VCN with a sequence number) showing where
    the attribute record may be found.

    The entries in the Attribute List are sorted first by attribute
    type code and then by name.  Note that two attributes can have the
    same type code and name only if they can be distinguished by
    value.

Author:

    Bill McJohn (billmc) 12-Aug-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "wstring.hxx"
#include "hackwc.hxx"

#include "attrlist.hxx"
#include "attrrec.hxx"
#include "upcase.hxx"

#include "message.hxx"
#include "rtmsg.h"


ULONG
CompareAttributeListEntries(
    IN PCATTRIBUTE_LIST_ENTRY   Left,
    IN PCATTRIBUTE_LIST_ENTRY   Right,
    IN PCNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This function compares two attribute list entries.

Arguments:

    Left        --  Supplies the left hand of the comparison
    Right       --  Supplies the right hand of the comparison
    UpcaseTable --  Supplies the volume upcase table.

Return Value:

    <0 if Left is less than Right
     0 if Left equals Right
    >0 if Left is greater than Right.

Notes:

    Attribute List Entries are ordered first by type code, then
    by name, and finally by lowest VCN.  An attribute list entry
    with no name is less than any entry of the same type code with
    a name.

    Name comparision is first done case-insensitive; if the names
    are equal by that metric, a case-sensitive comparision is made.

    The UpcaseTable parameter may be omitted if either or both names
    are zero-length, or if they are identical (including case).
    Otherwise, it must be supplied.

--*/
{
    LONG Result;

    // First, compare the type codes:
    //
    Result = Left->AttributeTypeCode - Right->AttributeTypeCode;

    if( Result != 0 ) {

        return Result;
    }

    // The entries have the same type code, so we compare the
    // names.  Pass in TRUE for the IsAttribute parameter, to
    // indicate that we are comparing attribute names.
    //
    Result = NtfsUpcaseCompare( NameFromEntry( Left ),
                                Left->AttributeNameLength,
                                NameFromEntry( Right ),
                                Right->AttributeNameLength,
                                UpcaseTable,
                                TRUE );

    if( Result != 0 ) {

        return Result;
    }

    // These two entries have the same type code and name;
    // compare the lowest VCN.
    //
    if( Left->LowestVcn < Right->LowestVcn ) {

        Result = -1;

    } else if( Left->LowestVcn < Right->LowestVcn ) {

        Result = 1;

    } else {

        Result = 0;
    }

    return Result;
}


DEFINE_CONSTRUCTOR( NTFS_ATTRIBUTE_LIST, NTFS_ATTRIBUTE );


NTFS_ATTRIBUTE_LIST::~NTFS_ATTRIBUTE_LIST(
    )
{
    Destroy();
}

VOID
NTFS_ATTRIBUTE_LIST::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LengthOfList = 0;
    _UpcaseTable = NULL;
}

VOID
NTFS_ATTRIBUTE_LIST::Destroy(
    )
/*++

Routine Description:

    Worker function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LengthOfList = 0;
    _UpcaseTable = NULL;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This method initializes an empty attribute list.

Arguments:

    Drive           -- supplies the drive on which the attribute list resides
    ClusterFactor   -- supplies the cluster factor for that drive
    UpcaseTable     -- supplies the volume upcase table.

Return Value:

    TRUE upon successful completion.

Notes:

    UpcaseTable may be NULL if the client will never compare
    named attribute records.

--*/
{
    Destroy();

    if( !_Mem.Initialize() ||
        !NTFS_ATTRIBUTE::Initialize( Drive,
                                     ClusterFactor,
                                     NULL,
                                     0,
                                     $ATTRIBUTE_LIST ) ) {

        return FALSE;
    }

    _UpcaseTable = UpcaseTable;
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      ULONG                   ClusterFactor,
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN      PNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This method initializes an attribute list based on an
    attribute record.

Arguments:

    Drive           -- supplies the drive on which the attribute list resides
    ClusterFactor   -- supplies the cluster factor for that drive
    AttributeRecord -- supplies the attribute record describing the
                        attribute list.
    UpcaseTable     -- supplies the volume upcase table.

Return Value:

    TRUE upon successful completion.

Notes:

    This method does not read the attribute list.

    UpcaseTable may be NULL if the client will never compare
    named attribute records.

--*/
{
    Destroy();

    if( !_Mem.Initialize() ||
        !NTFS_ATTRIBUTE::Initialize( Drive,
                                     ClusterFactor,
                                     AttributeRecord ) ) {

        return FALSE;
    }

    _UpcaseTable = UpcaseTable;
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::VerifyAndFix(
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN OUT  PMESSAGE        Message,
    IN      VCN             FileNumber,
    OUT     PBOOLEAN        Tube,
    IN OUT  PBOOLEAN        DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies and fixes this attribute list under
    the assumption that this class was initialized with an
    attribute record that was itself VerifiedAndFixed.

    In other words, this routine will check the issues specific
    to the $ATTRIBUTE_LIST attribute.

Arguments:

    FixLevel        - Supplies the fix up level.
    VolumeBitmap    - Supplies the volume bitmap.
    Message         - Supplies an outlet for messages.
    FileNumber      - Supplies the file number for the file that owns
                        this attribute list.
    Tube            - Returns whether or not the attribute list is beyond
                        repair.
    DiskErrorsFound - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT                 file_size;
    BIG_INT                 alloc_size;
    BIG_INT                 valid_size;
    PATTRIBUTE_LIST_ENTRY   p;
    ULONG                   length;
    BOOLEAN                 need_write;
    BOOLEAN                 changes;
    BOOLEAN                 error;
    PCNTFS_EXTENT_LIST      extent_list;
    ULONG                   num_extents;
    ULONG                   i;
    VCN                     next_vcn;
    LCN                     current_lcn;
    BIG_INT                 run_length;
    BIG_INT                 temp_length;

    DebugAssert(VolumeBitmap);
    DebugAssert(Message);
    DebugAssert(Tube);

    *Tube = FALSE;

    // If the attribute is non-resident then make sure that the
    // lowest vcn is 0 and the the three size parameters make sense.

    if (!GetResidentValue()) {

        QueryValueLength(&file_size, &alloc_size, &valid_size);

        temp_length = QueryClusterFactor()*
                      GetDrive()->QuerySectorSize()*
                      GetExtentList()->QueryNextVcn();

        error = FALSE;
        if (GetExtentList()->QueryLowestVcn() != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                         "%x%I64x%I64x",
                         QueryTypeCode(),
                         GetExtentList()->QueryLowestVcn().GetLargeInteger(),
                         FileNumber.GetLargeInteger());

            error = TRUE;
        } else if (alloc_size != temp_length) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_INCORRECT_ALLOCATE_LENGTH,
                         "%x%I64x%I64x%I64x",
                         QueryTypeCode(),
                         alloc_size.GetLargeInteger(),
                         temp_length.GetLargeInteger(),
                         FileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                "%d", FileNumber.GetLowPart());

            *Tube = TRUE;
            return TRUE;
        }
    }


    // Read the attribute.  If it is not readable then it must be tubed.

    if (!ReadList()) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_ATTR_LIST,
                            "%d", FileNumber.GetLowPart());

        *Tube = TRUE;
        return TRUE;
    }


    // Go through the attribute list entries and make sure that
    // they're all ok.  If any of them are not good then delete
    // them.

    need_write = FALSE;

    p = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
    length = 0;
    while (length + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(USHORT) <
           _LengthOfList) {

        // Make sure that the record fits inside the attribute list.

        if (length + p->RecordLength > _LengthOfList) {
            break;
        }

        // If the record length is zero then break out of this loop.

        if (!p->RecordLength) {
            break;
        }

        // Make sure the name fits inside the attribute list entry.

        error = FALSE;
        if (((p->RecordLength & 0x7) != 0)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_ENTRY_LENGTH_MISALIGNED,
                         "%x%x%x%I64x",
                         p->AttributeTypeCode,
                         p->Instance,
                         p->RecordLength,
                         FileNumber.GetLargeInteger());

            error = TRUE;
        } else if (p->AttributeNameLength != 0) {
            if (p->AttributeNameLength + p->AttributeNameOffset >
                p->RecordLength) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_NAME_IN_ATTR_LIST_ENTRY,
                             "%x%x%x%x%x%I64x",
                             p->AttributeTypeCode,
                             p->Instance,
                             p->AttributeNameLength,
                             p->AttributeNameOffset,
                             p->RecordLength,
                             FileNumber.GetLargeInteger());
                error = TRUE;
            } else if (p->AttributeNameOffset <
                       FIELD_OFFSET(ATTRIBUTE_LIST_ENTRY, AttributeName)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NAME_OFFSET_IN_ATTR_LIST_ENTRY_TOO_SMALL,
                             "%x%x%x%x%I64x",
                             p->AttributeTypeCode,
                             p->Instance,
                             p->AttributeNameOffset,
                             FIELD_OFFSET(ATTRIBUTE_LIST_ENTRY, AttributeName),
                             FileNumber.GetLargeInteger());
                error = TRUE;
            }
        }

        if (error) {

            need_write = TRUE;

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                             "%d%d", p->AttributeTypeCode,
                                     FileNumber.GetLowPart());

            _LengthOfList -= p->RecordLength;

            memmove(p,
                    (PCHAR) p + p->RecordLength,
                    (UINT) (_LengthOfList - length));

            p = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
            length = 0;
            continue;
        }

        length += p->RecordLength;
        p = NextEntry(p);
    }


    if (length != _LengthOfList) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_LIST_LENGTH,
                     "%x%x%I64x",
                     length,
                     _LengthOfList,
                     FileNumber.GetLargeInteger());

        need_write = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_ATTR_LIST_TRUNC,
                         "%d", FileNumber.GetLowPart());
        _LengthOfList = length;
    }


    // Now that the attribute list is valid, it must next be sorted.

    if (!Sort(&changes)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_ATTR_LIST,
                         "%d", FileNumber.GetLowPart());
        need_write = TRUE;
    }

    if (need_write) {

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        //
        // Make sure attr list is not cross linked before writing out the list
        //

        if (!*Tube && !GetResidentValue()) {

            extent_list = GetExtentList();
            num_extents = extent_list->QueryNumberOfExtents();

            for (i = 0; i < num_extents; i++) {

                if (!extent_list->QueryExtent(i, &next_vcn, &current_lcn,
                                              &run_length)) {

                    DebugAbort("Could not query extent");
                    return FALSE;
                }

                if (current_lcn == LCN_NOT_PRESENT) {
                    continue;
                }


                // Make sure that the run is free before allocating.
                // If it is not, this indicates a cross-link.

                if (!VolumeBitmap->IsFree(current_lcn, run_length)) {

                    DebugPrintTrace(("cross-linked run starts at 0x%I64x for 0x%I64x\n",
                                     current_lcn.GetLargeInteger(), run_length.GetLargeInteger()));

                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_CROSS_LINKED,
                                 "%I64x%I64x%I64x",
                                 current_lcn.GetLargeInteger(),
                                 run_length.GetLargeInteger(),
                                 FileNumber.GetLargeInteger());

                    *Tube = TRUE;

                    return TRUE;
                }
            }
        }


        if (FixLevel != CheckOnly && !WriteList(VolumeBitmap)) {

            DebugAbort("Cant write readable attribute list");
            *Tube = TRUE;
            return TRUE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::AddEntry(
    IN ATTRIBUTE_TYPE_CODE      Type,
    IN VCN                      LowestVcn,
    IN PCMFT_SEGMENT_REFERENCE  SegmentReference,
    IN USHORT                   InstanceTag,
    IN PCWSTRING                Name
    )
/*++

Routine Description:

    This adds an Attribute List Entry to the list.

Arguments:

    Type                --  supplies the attribute type code of the
                            attribute record corresponding to this entry
    LowestVcn           --  supplies the record's LowestVcn
    SegmentReference    --  supplies the location of the record
    InstanceTag         --  supplies the record's attribute instance tag.
    Name                --  supplies the name associated with the
                            record (NULL if it has no name).

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG LengthOfNewEntry;
    ULONG NewLengthOfList;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset, NameLength;


    // Compute the size of the new entry and the new length of the
    // list with this entry added.
    //
    NameLength = ( Name == NULL ) ? 0 : (Name->QueryChCount());

    LengthOfNewEntry = QuadAlign( sizeof(ATTRIBUTE_LIST_ENTRY) +
                                            NameLength * sizeof(WCHAR) );

    NewLengthOfList = _LengthOfList + LengthOfNewEntry;

    // If our existing buffer isn't big enough, stretch it to
    // hold the new entry.

    if( !_Mem.Resize( NewLengthOfList ) ) {

        return FALSE;
    }

    // Scan forward to the point at which the new entry should
    // be inserted.

    CurrentEntry = FindEntry( Type, Name, LowestVcn, &EntryOffset );

    if (CurrentEntry == NULL)
        return FALSE;   // fail as there is no insertion point

    // Insert a new entry at CurrentEntry.

    memmove( (PBYTE)CurrentEntry + LengthOfNewEntry,
             (PVOID)CurrentEntry,
             _LengthOfList - EntryOffset );

    memset( (PVOID)CurrentEntry, '\0', LengthOfNewEntry );

    _LengthOfList = NewLengthOfList;

    // Fill in the new entry

    CurrentEntry->AttributeTypeCode = Type;
    CurrentEntry->RecordLength = (USHORT)LengthOfNewEntry;
    CurrentEntry->AttributeNameLength = (UCHAR)NameLength;
    CurrentEntry->LowestVcn = LowestVcn;
    CurrentEntry->SegmentReference = *SegmentReference;
    CurrentEntry->Instance = InstanceTag;
    CurrentEntry->AttributeNameOffset = FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY,
                                                      AttributeName );

    if( Name != NULL ) {

        Name->QueryWSTR( 0,
                         TO_END,
                         NameFromEntry( CurrentEntry ),
                         Name->QueryChCount(),
                         FALSE );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntry(
    IN ULONG EntryIndex
    )
/*++

Routine Description:

    This method deletes the nth entry from the list.

Arguments:

    EntryIndex  --  supplies the index of the entry to be deleted

Return Value:

    TRUE upon successful completion.  Note that if there are
    not enough entries, this method returns TRUE.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    ULONG BytesToRemove;
    ULONG i;


    // Scan forward to the requested entry

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return TRUE;
    }


    for( i = 0; i < EntryIndex; i++ ) {

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return TRUE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }



    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( CurrentOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (CurrentOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteCurrentEntry(
    IN PATTR_LIST_CURR_ENTRY    Entry
    )
/*++

Routine Description:

    This method deletes the current entry from the list.

Arguments:

    Entry  --  supplies the entry to delete

Return Value:

    TRUE upon successful completion.  Note that if there are
    not enough entries, this method returns TRUE.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    ULONG BytesToRemove;
    ULONG i;


    if( _LengthOfList == 0 ) {

        // The list is empty.

        return TRUE;
    }

    CurrentEntry = Entry->CurrentEntry;
    CurrentOffset = Entry->CurrentOffset;

    if( CurrentOffset >= _LengthOfList ) {

        // We ran out of entries.

        return TRUE;
    }

    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( CurrentOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (CurrentOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntry(
    IN ATTRIBUTE_TYPE_CODE      Type,
    IN VCN                      LowestVcn,
    IN PCWSTRING                Name,
    IN PCMFT_SEGMENT_REFERENCE  SegmentReference
    )
/*++

Routine Description:

    This method deletes from the list the first entry which matches
    its parameters.  This method is used when deleting a non-unique
    (resident) attribute.  It may also be used to delete the entry
    for a known attribute record (for instance, when we move shuffle
    records between File Record Segments).

Arguments:

    Type                --  Supplies the attribute type code of the
                            entry to be deleted.
    Name                --  Supplies the name of the entry to be deleted;
                            may be NULL, in which case it is ignored.
    LowestVCN           --  Supplies the LowestVcn of the entry to delete.
    SegmentReference    --  Supplies the segment reference field of the
                            entry to be deleted; may be NULL, in which
                            case it is ignored.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset;
    ULONG BytesToRemove;
    PWSTR NameBuffer = NULL;
    ULONG NameLength;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // Scan forward to the first entry that matches the input

    CurrentEntry = FindEntry( Type, Name, LowestVcn, &EntryOffset );

    if (CurrentEntry == NULL) {
        if (NameBuffer)
            FREE(NameBuffer);
        return TRUE;    // assume nothing to delete
    }

    if( SegmentReference != NULL ) {

        // The caller specified a segment reference, so we have to
        // scan through the matching entries until we find that segment
        // reference or we run out of matching entries.

        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 (NameLength == CurrentEntry->AttributeNameLength &&
                  memcmp( NameBuffer,
                          NameFromEntry(CurrentEntry),
                          NameLength * sizeof(WCHAR) ) == 0) ) &&
               CurrentEntry->LowestVcn == LowestVcn &&
               memcmp( SegmentReference,
                       &CurrentEntry->SegmentReference,
                       sizeof(MFT_SEGMENT_REFERENCE) ) != 0 ) {

            EntryOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry(CurrentEntry);
        }
    }

    // If we've gone off the end of the list, or if the type, name,
    // and LowestVcn don't match, then we don't have any matching
    // records.

    if( EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        ( Name != NULL &&
          ( NameLength != CurrentEntry->AttributeNameLength ||
            memcmp( NameBuffer,
                    NameFromEntry(CurrentEntry),
                    NameLength * sizeof(WCHAR) ) != 0 ) ) ||
        CurrentEntry->LowestVcn != LowestVcn ) {

        // There are no matching entries, so there's nothing to
        // delete.

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }

        return TRUE;
    }


    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( EntryOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (EntryOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntries(
    IN ATTRIBUTE_TYPE_CODE  Type,
    IN PCWSTRING            Name
    )
/*++

Routine Description:

    This method deletes all entries in the list which match the input.
    This is used when deleting a unique attribute, since all attribute
    records for that attribute type-code and name will be removed.

Arguments:

    Type                --  Supplies the attribute type code of the
                            entry to be deleted.
    Name                --  Supplies the name of the entry to be deleted;
                            may be NULL, in which case it is ignored.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset;
    ULONG BytesToRemove;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // find the first matching entry.

    CurrentEntry = FindEntry( Type, Name, 0, &EntryOffset );

    if (CurrentEntry) {
        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 ( NameLength == CurrentEntry->AttributeNameLength &&
                   memcmp( NameBuffer,
                           NameFromEntry( CurrentEntry ),
                           NameLength * sizeof(WCHAR) ) == 0 ) ) ) {

            // This entry matches, so we delete it.  Note that instead of
            // incrementing CurrentEntry and EntryOffset, we draw the
            // succeeding entries down to the current point.

            BytesToRemove = CurrentEntry->RecordLength;

            DebugAssert( EntryOffset + BytesToRemove <= _LengthOfList );

            memmove( CurrentEntry,
                     (PBYTE)CurrentEntry + BytesToRemove,
                     _LengthOfList - (EntryOffset + BytesToRemove) );

            _LengthOfList -= BytesToRemove;
        }
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_ATTRIBUTE_LIST::IsInList(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name
    ) CONST
/*++

Routine Description:

Arguments:

    Type        -- supplies the type code of the attribute in question.
    Name        -- supplies the name of the attribute in question.
                    (may be NULL, in which case the attribute has no name.)
Return Value:

    TRUE if there is an entry in the attribute list with this
    type code and (if specified) name.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset, CurrentEntryIndex;
    ULONG NameLength;
    PCWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->GetWSTR();

    } else {

        NameLength = 0;
    }


    // Find the first entry which matches this type code & name.

    CurrentEntry = FindEntry( Type, Name, 0,
                                &EntryOffset, &CurrentEntryIndex );

    if( CurrentEntry == NULL ||
        EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        NameLength != CurrentEntry->AttributeNameLength ||
        (NameLength != 0 &&
         NtfsUpcaseCompare( NameBuffer,
                            NameLength,
                            NameFromEntry( CurrentEntry ),
                            NameLength,
                            _UpcaseTable,
                            TRUE) != 0) ) {

        // We've gone too far.  There are no matching entries.

        return FALSE;
    }

    return TRUE;
}

#if 0

BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryEntry(
    IN  ULONG                   EntryIndex,
    OUT PATTRIBUTE_TYPE_CODE    Type,
    OUT PVCN                    LowestVcn,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PUSHORT                 InstanceTag,
    OUT PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This method fetches the nth entry in the list.

Arguments:

    EntryIndex          --  supplies the index into the list of the
                            entry to fetch
    Type                --  receives the entry's attribute type code
    LowestVcn           --  receives the entry's LowestVcn
    SegmentReference    --  receives the entry's SegmentReference
    InstanceTag         --  receives the entry's attribute instance tag.
    Name                --  receives the entry's Name (if any)

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }


    for( i = 0; i < EntryIndex; i++ ) {

        if (CurrentEntry->RecordLength == 0)
            return FALSE;

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return FALSE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;
    *SegmentReference = CurrentEntry->SegmentReference;
    *InstanceTag = CurrentEntry->Instance;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}
#endif


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryNextEntry(
    IN OUT PATTR_LIST_CURR_ENTRY   CurrEntry,
    OUT    PATTRIBUTE_TYPE_CODE    Type,
    OUT    PVCN                    LowestVcn,
    OUT    PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT    PUSHORT                 InstanceTag,
    OUT    PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This method fetches the next entry in the list.

Arguments:

    NextEntry           --  supplies the pointer to the entry
    Type                --  receives the entry's attribute type code
    LowestVcn           --  receives the entry's LowestVcn
    SegmentReference    --  receives the entry's SegmentReference
    InstanceTag         --  receives the entry's attribute instance tag.
    Name                --  receives the entry's Name (if any)

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG                 CurrentOffset;

    DebugPtrAssert(CurrEntry);

    if (CurrEntry->CurrentEntry == NULL) {

        CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());
        CurrEntry->CurrentEntry = CurrentEntry;
        CurrEntry->CurrentOffset = 0;

        *Type = CurrentEntry->AttributeTypeCode;
        *LowestVcn = CurrentEntry->LowestVcn;
        *SegmentReference = CurrentEntry->SegmentReference;
        *InstanceTag = CurrentEntry->Instance;

        if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                               CurrentEntry->AttributeNameLength ) ) {

            return FALSE;
        }

        return TRUE;
    } else {

        CurrentEntry = CurrEntry->CurrentEntry;
        CurrentOffset = CurrEntry->CurrentOffset;
    }

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }

    if ( CurrentEntry->RecordLength == 0 ) {

        // something is not right or it's the end

        return FALSE;
    }

    CurrentOffset += CurrentEntry->RecordLength;

    if( CurrentOffset >= _LengthOfList ) {

        // it's the end

        return FALSE;
    }

    CurrentEntry = NextEntry( CurrentEntry );

    CurrEntry->CurrentEntry = CurrentEntry;
    CurrEntry->CurrentOffset = CurrentOffset;

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;
    *SegmentReference = CurrentEntry->SegmentReference;
    *InstanceTag = CurrentEntry->Instance;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryEntry(
    IN  MFT_SEGMENT_REFERENCE   SegmentReference,
    IN  USHORT                  InstanceTag,
    OUT PATTRIBUTE_TYPE_CODE    Type,
    OUT PVCN                    LowestVcn,
    OUT PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This routine returns the type, lowestvcn, and name of the attribute
    list entry with the given segment reference and instance tag.

Arguments:

    SegmentReference    - Supplies the entry's segment reference.
    InstanceTag         - Supplies the entry's instance tag.
    Type                - Returns the entry's type code.
    LowestVcn           - Returns the entry's lowest vcn.
    Name                - Returns the entry's name.

Return Value:

    FALSE   - An entry with the given segment reference and instance was
                not found.
    TRUE    - Success.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }


    for( i = 0; ; i++ ) {

        if (CurrentEntry->Instance == InstanceTag &&
            CurrentEntry->SegmentReference == SegmentReference) {

            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return FALSE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
PCATTRIBUTE_LIST_ENTRY
NTFS_ATTRIBUTE_LIST::GetNextAttributeListEntry(
    IN  PCATTRIBUTE_LIST_ENTRY  CurrentEntry
    ) CONST
/*++

Routine Description:

    This routine fetches the next attribute list entry structure.

Arguments:

    CurrentEntry    - Supplies the current attribute list entry.
                        Supplying NULL as the current entry specifies that
                        you want the first entry in the list.

Return Value:

    The next attribute list entry or NULL if the current entry
    is at the end of the list.

--*/
{
    ULONG   CurrentOffset;

    if (!_LengthOfList) {
        return NULL;
    }

    if (!CurrentEntry) {
        return (PCATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
    }

    CurrentOffset = (ULONG)((PCHAR) CurrentEntry - (PCHAR) _Mem.GetBuf());

    if (CurrentOffset + CurrentEntry->RecordLength >= _LengthOfList) {
        return NULL;
    }

    return (PCATTRIBUTE_LIST_ENTRY) ((PCHAR) CurrentEntry + CurrentEntry->RecordLength);
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryExternalReference(
    IN  ATTRIBUTE_TYPE_CODE     Type,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PULONG                  EntryIndex,
    IN  PCWSTRING               Name,
    IN  PVCN                    DesiredVcn,
    OUT PVCN                    StartingVcn
    ) CONST
/*++

Routine Description:

    This method fetches an entry from the list based on a type code,
    name (optional), and VCN.

Arguments:

    Type                --  supplies the attribute type code to search for.
    SegmentReference    --  receives the entry's SegmentReference
    EntryIndex          --  receives the entry's index into the list
    Name                --  supplies the entry's name.  If this pointer
                            is NULL, attribute names are ignored.
    DesiredVcn          --  supplies a pointer to the VCN we're interested
                            in.  (Note that this pointer may be NULL if
                            the caller just wants the first entry for this
                            type & name.)
    StartingVcn         --  receives the LowestVcn of the entry found;
                            if this pointer is NULL, that information is
                            not returned.


Return Value:

    TRUE if a matching entry is found.

Notes:

    A client who wishes to find all the entries for a particular
    attribute can take advantage of the fact that the list is sorted
    by type code and name.  Thus, the client finds the first matching
    entry (using QueryExternalReference), and then queries successive
    entries by index until one doesn't match.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry, PreviousEntry;
    ULONG EntryOffset, CurrentEntryIndex;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // The search algorithm for this method is slightly different than
    // the other methods for this class.  Instead of the first matching
    // entry, we want the last matching entry which has a LowestVcn field
    // less than or equal to *DesiredVcn.  (If DesiredVcn is NULL, we can
    // just return the first entry we find.)

    CurrentEntry = FindEntry( Type, Name, 0,
                                &EntryOffset, &CurrentEntryIndex );

    if( CurrentEntry == NULL ||
        EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        ( Name != NULL &&
          ( NameLength != CurrentEntry->AttributeNameLength ||
            memcmp( NameBuffer,
                    NameFromEntry( CurrentEntry ),
                    NameLength * sizeof(WCHAR) ) != 0 ) ) ||
        ( DesiredVcn != NULL &&
          CurrentEntry->LowestVcn > *DesiredVcn ) ) {

        // We've gone too far.  There are no matching entries.

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }

        return FALSE;
    }

    if( DesiredVcn != NULL ) {

        // The caller specified a particular VCN, so we have to find the
        // entry that contains it.  We do this by scanning forward until
        // we find an entry that is beyond what we want, and then backing
        // up one.  Since we passed the test above, we know that the
        // loop below will execute at least once, so PreviousEntry is
        // sure to get set.

        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 ( NameLength == CurrentEntry->AttributeNameLength &&
                   memcmp( NameBuffer,
                           NameFromEntry( CurrentEntry ),
                           NameLength * sizeof(WCHAR) ) == 0 ) ) &&
               CurrentEntry->LowestVcn <= *DesiredVcn ) {

            PreviousEntry = CurrentEntry;
            CurrentEntryIndex += 1;
            EntryOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

        // Now back up one, to the entry we really want:

        CurrentEntry = PreviousEntry;
        CurrentEntryIndex -= 1;
    }

    // Fill in the output parameters.

    memcpy( SegmentReference,
            &CurrentEntry->SegmentReference,
            sizeof( MFT_SEGMENT_REFERENCE ) );

    *EntryIndex = CurrentEntryIndex;

    if( StartingVcn != NULL ) {

        *StartingVcn = CurrentEntry->LowestVcn;
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryNextAttribute(
    IN OUT PATTRIBUTE_TYPE_CODE TypeCode,
    IN OUT PWSTRING             Name
    ) CONST
/*++

Routine Description:

    This method determines the type code and name of the first
    attribute list which is strictly greater than the supplied
    type and name.

Arguments:

    TypeCode    --  supplies the current attribute type code.  Receives
                    the type code of the next attribute.  A returned type
                    code of $END indicates that there are no more attributes.
    Name        --  supplies the current name.  Receives the name of the
                    next attribute.


Return Value:

    TRUE upon successful completion.

Notes:

    This method is useful for iterating through the non-indexed
    attributes of a file, since there can only be one non-indexed
    attribute with a given type code and name in the file.  However,
    it offers no way of dealing with indexed attributes, which may
    be distinguished only by value.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentEntryOffset, CurrentEntryIndex;

    // Use FindEntry to get to the entry we want.  Note that we use
    // a LowestVcn of -1, to skip over all matching entries.

    if( (CurrentEntry = FindEntry( *TypeCode,
                                   Name,
                                   -1,
                                   &CurrentEntryOffset,
                                   &CurrentEntryIndex )) == NULL ) {

        // An error occurred searching the list.
        return FALSE;
    }

    if( CurrentEntryOffset >= _LengthOfList ) {

        // This is the end of the list; there are no more entries.

        *TypeCode = $END;

        return Name->Initialize("");
    }

    // OK, we have the entry we want.  Copy its type and name (if any).

    *TypeCode = CurrentEntry->AttributeTypeCode;

    if( !Name->Initialize( NameFromEntry(CurrentEntry),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::ReadList(
    )
/*++

Routine Description:

    This method reads the list into the object's private buffer.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT ValueLength;
    ULONG BytesRead;

    // Determine the length of the list.

    QueryValueLength( &ValueLength );

    DebugAssert( ValueLength.GetHighPart() == 0 );

    _LengthOfList = ValueLength.GetLowPart();

    // Initialize our MEM object and use it to get the correct
    // amount of memory.

    if( !_Mem.Initialize() ||
        !_Mem.Acquire( (LONG)_LengthOfList ) ) {

        return FALSE;
    }

    // Read the attribute's value into our buffer.

    return( Read( _Mem.GetBuf(), 0, _LengthOfList, &BytesRead) &&
            BytesRead == _LengthOfList );
}



PATTRIBUTE_LIST_ENTRY
NTFS_ATTRIBUTE_LIST::FindEntry(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  VCN                 LowestVcn,
    OUT PULONG              EntryOffset,
    OUT PULONG              EntryIndex
    ) CONST
/*++

Routine Description:

    This method finds the first entry in the list which matches
    its input or, if there is no match, the first entry that
    would come after it (i.e. the place it would be if it were there).

Arguments:

    Type        -- supplies the attribute type code to find
    Name        -- supplies the name to find (may be NULL, in which case it
                    is ignored)
    LowestVcn   -- supplies the VCN to find.  A value of -1 indicates
                    we should skip all entries for this type and name.
    EntryOffset -- receives the offset into the list of the
                    returned pointer.  (May be NULL, in which case
                    this value is not returned.)
    EntryIndex  -- receives the index into the list of the returned
                    entry.  (May be NULL, in which case this value
                    is not returned.


Return Value:

    A pointer to the first entry in the list which matches the input.
    If there is no match, this method returns the next entry (i.e. the
    point at which a matching entry should be inserted).

    NULL is returned to indicate end of entry.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset, CurrentIndex;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return NULL;
        }
    }

    // Start at the beginning of the list.

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());
    CurrentOffset = 0;
    CurrentIndex = 0;

    // Scan forward to the first entry which has a type code
    // greater than or equal to the type code we want.

    while( CurrentOffset < _LengthOfList &&
           Type > CurrentEntry->AttributeTypeCode ) {

        CurrentIndex += 1;
        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry( CurrentEntry );
    }


    // CurrentEntry now points at the first entry with an attribute
    // type code greater than or equal to the one we're seeking.
    // Within the group of entries with the same type code, the
    // entries are sorted first by name and then by LowestVcn.

    if( Name != NULL ) {

        // The caller specified a name name, so we need to scan
        // through the entries with this attribute type code for
        // the first entry with a name greater than or equal to
        // that name.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               NtfsUpcaseCompare( NameBuffer,
                                  NameLength,
                                  NameFromEntry( CurrentEntry ),
                                  CurrentEntry->AttributeNameLength,
                                  _UpcaseTable,
                                  TRUE ) > 0 ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

        // Now scan forward by LowestVcn through the attributes with
        // this type code and name.  Note that a search value of -1
        // for LowestVcn indicates we should skip all matching entries.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               ( NameLength == CurrentEntry->AttributeNameLength &&
                 memcmp( NameBuffer,
                         NameFromEntry( CurrentEntry ),
                         NameLength * sizeof(WCHAR) ) == 0 ) &&
               ( (LowestVcn == -1) ||
                 (LowestVcn > CurrentEntry->LowestVcn) ) ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

    } else {

        // The caller did not specify a name, so we only examine
        // entries without names.  These come before entries with
        // that same attribute type code that have names.  Scan
        // forward by LowestVcn through the entries that have this
        // attribute type code and no name.  Note that a search value
        // of -1 for LowestVcn indicates that we should skip all matching
        // entries.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               CurrentEntry->AttributeNameLength == 0 &&
               ( (LowestVcn == -1) ||
                 (LowestVcn > CurrentEntry->LowestVcn) ) ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }
    }

    if( EntryOffset != NULL ) {

        *EntryOffset = CurrentOffset;
    }

    if( EntryIndex != NULL ) {

        *EntryIndex = CurrentIndex;
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return CurrentEntry;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryAttributeRecord(
    OUT PVOID                   AttributeRecordData,
    IN  ULONG                   MaximumLength,
    OUT PNTFS_ATTRIBUTE_RECORD  AttributeRecord
    ) CONST
/*++

Routine Description:

    This routine computes an attribute record which corresponds to
    this attribute.

Arguments:

    AttributeRecordData - Supplies a buffer for the attribute record.
    MaximumLength       - Supplies the length of the buffer in bytes.
    AttributeRecord     - Returns the attribute record for this attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT value_length;
    BIG_INT alloc_length;
    BIG_INT valid_length;

    DebugAssert(AttributeRecordData);
    DebugAssert(MaximumLength);
    DebugAssert(AttributeRecord);

    //LOGLOG: Is there a need to pass drive instead of NULL
    if (!AttributeRecord->Initialize(NULL, AttributeRecordData, MaximumLength)) {
        DebugAbort("Could not initialize attribute record.");
        return FALSE;
    }

    QueryValueLength(&value_length, &alloc_length, &valid_length);

    if (GetResidentValue()) {

        DebugAssert(value_length.GetHighPart() == 0);

        if (!AttributeRecord->CreateResidentRecord(GetResidentValue(),
                                                   value_length.GetLowPart(),
                                                   QueryTypeCode(),
                                                   NULL,
                                                   QueryFlags(),
                                                   QueryResidentFlags())) {

            return FALSE;
        }

    } else {

        if (!AttributeRecord->CreateNonresidentRecord(
                GetExtentList(),
                alloc_length,
                value_length,
                valid_length,
                QueryTypeCode(),
                NULL,
                QueryFlags(),
                (USHORT)QueryCompressionUnit())) {

            return FALSE;
        }

    }

    return TRUE;
}


BOOLEAN
SwapAttributeListEntries(
    IN OUT  PVOID   FirstAttributeListEntry
    )
/*++

Routine Description:

    This routine swaps 'FirstAttributeListEntry' with the next attribute
    list entry in the attribute list.  This method will fail if there is not
    enough memory available for a swap buffer.

Arguments:

    FirstAttributeListEntry - Supplies the first of two attribute list
                                entries to be swapped.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   BufSize = 256;
    CHAR    buffer[BufSize];

    PATTRIBUTE_LIST_ENTRY   p1, p2;
    PCHAR                   q1, q2;
    PVOID                   buf;
    UINT                    first_entry_length;
    BOOLEAN                 alloc_buf;

    p1 = (PATTRIBUTE_LIST_ENTRY) FirstAttributeListEntry;
    q1 = (PCHAR) p1;

    first_entry_length = p1->RecordLength;

    if (first_entry_length > BufSize) {
        if (!(buf = MALLOC(first_entry_length))) {
            return FALSE;
        }
        alloc_buf = TRUE;
    } else {
        buf = buffer;
        alloc_buf = FALSE;
    }

    // Tuck away the first record.

    memcpy(buf, p1, first_entry_length);


    q2 = q1 + p1->RecordLength;
    p2 = (PATTRIBUTE_LIST_ENTRY) q2;


    // Overwrite first attribute record with second attribute record.

    memmove(p1, p2, (UINT) p2->RecordLength);


    // Copy over the first attribute record after the second.

    memcpy(q1 + p1->RecordLength, buf, first_entry_length);

    if (alloc_buf) {
        FREE(buf);
    }

    return TRUE;
}


INT
CompareInstances(
    IN  PCATTRIBUTE_LIST_ENTRY  Left,
    IN  PCATTRIBUTE_LIST_ENTRY  Right
    )
/*++

Routine Description:

    This routine compares the left and right instance and segment
    reference values for these two attribute list entries.

Arguments:

    Left    - Supplies the left side of the comparison.
    Right   - Supplies the right side of the comparison.

Return Value:

    < 0 - Left < Right
    0   - Left == Right
    > 0 - Left > Right

--*/
{
    BIG_INT l, r;

    // First compare the segment references as BIG_INTs.

    l = *((PBIG_INT) &Left->SegmentReference);
    r = *((PBIG_INT) &Right->SegmentReference);

    if (l < r) {
        return -1;
    }

    if (l > r) {
        return 1;
    }

    if (Left->Instance < Right->Instance) {
        return -1;
    }

    if (Left->Instance > Right->Instance) {
        return 1;
    }

    return 0;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Sort(
    OUT PBOOLEAN    Changes
    )
/*++

Routine Description:

    This routine sorts an attribute list by type, name, and lowest vcn.
    It reports through Message if any attribute list entries are out
    of order.

Arguments:

    Changes - Returns whether or not a change was made.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                 stable;
    PATTRIBUTE_LIST_ENTRY   prev, curr;
    PCHAR                   start;
    ULONG                   i;
    INT                     r;

    DebugAssert(Changes);

    *Changes = FALSE;

    start = (PCHAR) _Mem.GetBuf();

    stable = FALSE;

    while (!stable) {

        stable = TRUE;

        prev = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
        DebugAssert(prev);

        for (i = 0; ; i++) {

            curr = NextEntry(prev);

            if ((ULONG)((PCHAR) curr - start) >= _LengthOfList) {
                break;
            }

            r = CompareAttributeListEntries( prev,
                                             curr,
                                             _UpcaseTable );

            if( r > 0 ) {

                // prev is greater than curr--these two
                // entries are out of order.  Swap them.

                PIO_DP_DRIVE    drive = GetDrive();

                if (drive) {

                    PMESSAGE msg = drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_ENTRIES_OUT_OF_ORDER,
                                 "%x%x%x%x",
                                 prev->AttributeTypeCode,
                                 prev->Instance,
                                 curr->AttributeTypeCode,
                                 curr->Instance);
                    }
                }

                if (!SwapAttributeListEntries(prev)) {
                    return FALSE;
                }

                *Changes = TRUE;
                stable = FALSE;
                break;

            } else if( r == 0 ) {

                // These two entries have the same type code, name,
                // and lowest vcn.  We must now insure that they
                // have different instance numbers.

                r = CompareInstances(prev, curr);

                if (r == 0) {

                    // Duplicates.  Remove them both.

                    PIO_DP_DRIVE    drive = GetDrive();

                    if (drive) {

                        PMESSAGE msg = drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_LIST_ENTRIES,
                                     "%x%x",
                                     prev->AttributeTypeCode,
                                     prev->Instance);
                        }
                    }

                    if (!DeleteEntry(i + 1) ||
                        !DeleteEntry(i)) {

                        DebugAbort("Could not delete entry");
                        return FALSE;
                    }

                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                if (r > 0) {

                    // Out of order.  Swap.

                    if (!SwapAttributeListEntries(prev)) {
                        return FALSE;
                    }

                    // We don't set the 'Changes' flag here because
                    // attribute list entries don't have to be ordered by
                    // instance.

                    stable = FALSE;
                    curr = NextEntry(prev);
                }
            }

            prev = curr;
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE_LIST::ModifyInstanceTag(
    IN  PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN  MFT_SEGMENT_REFERENCE   SegmentReference,
    IN  USHORT                  NewInstanceTag
    )
/*++

Routine Description:

    Find an entry in the attribute list and change it's instance
    tag to the given value.


Arguments:

    AttributeRecord -
    SegmentReference -  These two objects describe the interesting
                        attribute list entry -- it's the entry for this
                        attribute record in this segment.

    NewInstanceTag -    The desired instance tag value.

Return Value:

    FALSE           - Failure (the entry could not be located)
    TRUE            - Success.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    USHORT InstanceTag;

    InstanceTag = AttributeRecord->QueryInstanceTag();

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {
        // The list is empty.
        return FALSE;
    }

    for (i = 0; ; i++) {

        if (CurrentEntry->Instance == InstanceTag &&
            CurrentEntry->SegmentReference == SegmentReference) {
            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {
            // We ran out of entries.
            return FALSE;
        }

        CurrentEntry = NextEntry(CurrentEntry);
    }

    CurrentEntry->Instance = NewInstanceTag;

    SetStorageModified();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\badfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    badfile.hxx

Abstract:

    This module contains the declarations for the NTFS_BAD_CLUSTER_FILE
    class, which models the bad cluster file for an NTFS volume.

    The DATA attribute of the bad cluster file is a non-resident
    attribute to which bad clusters are allocated.  It is stored
    as a sparse file with LCN = VCN.

Author:

    Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "numset.hxx"

#include "ntfsbit.hxx"
#include "mft.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"

#include "badfile.hxx"
#include "ifssys.hxx"
#include "message.hxx"
#include "rtmsg.h"

#define BadfileDataNameData "$Bad"


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BAD_CLUSTER_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BAD_CLUSTER_FILE::~NTFS_BAD_CLUSTER_FILE(
    )
{
    Destroy();
}

VOID
NTFS_BAD_CLUSTER_FILE::Construct(
    )
/*++

Routine Description:

    Worker method for NTFS_BAD_CLUSTER_FILE construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
}

VOID
NTFS_BAD_CLUSTER_FILE::Destroy(
    )
/*++

Routine Description:

    Worker method for NTFS_BAD_CLUSTER_FILE destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _DataAttribute );
}


UNTFS_EXPORT
BOOLEAN
NTFS_BAD_CLUSTER_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes an NTFS_BAD_CLUSTER_FILE object.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::
                Initialize( BAD_CLUSTER_FILE_NUMBER,
                            Mft ) );
}


BOOLEAN
NTFS_BAD_CLUSTER_FILE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            Bitmap,
    IN      PCNUMBER_SET            BadClusters
    )
/*++

Routine Description:

    This method sets up the volume's Bad Cluster List.  It also accepts
    a set of clusters to add to the list, and marks those clusters
    as used in the volume bitmap.

Arguments:

    Bitmap      -- supplies the volume bitmap.
    BadClusters -- supplies the set of bad clusters.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_EXTENT_LIST Extents;
    DSTRING DataAttributeName;
    LCN Lcn;
    BIG_INT Size, ClustersOnVolume, RunLength;
    ULONG i;

    // If we have an old data attribute lying around,
    // throw it out.
    //
    DELETE( _DataAttribute );


    // First, we have to set up the File Record Segment structure.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation) ) {

        return FALSE;
    }

    ClustersOnVolume = QueryVolumeSectors()/QueryClusterFactor();


    // Now we put together an extent list with all the bad clusters.
    //
    if( !Extents.Initialize( 0, ClustersOnVolume ) ) {

        return FALSE;
    }

    for( i = 0; i < BadClusters->QueryNumDisjointRanges(); i++ ) {

        BadClusters->QueryDisjointRange(i, &Lcn, &RunLength);

        Bitmap->SetAllocated( Lcn, RunLength);

        if( !Extents.AddExtent( Lcn, Lcn, RunLength ) ) {

            return FALSE;
        }
    }

    // Finally, create a data attribute and initialize it with
    // the extent list.  Then insert it into this File Record
    // Segment (but keep it around in case we want to add to it).
    // This data attribute has a value length equal to the size
    // of the disk, but a valid length of zero.
    //
    // Note that the size of the attribute only includes clusters
    // on the volume; it excludes any partial cluster at the end
    // of the volume.
    //
    Size = ClustersOnVolume * QueryClusterFactor() *
                                    GetDrive()->QuerySectorSize();

    if( (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
        !DataAttributeName.Initialize( BadfileDataNameData ) ||
        !_DataAttribute->Initialize( GetDrive(),
                                     QueryClusterFactor(),
                                     &Extents,
                                     Size,
                                     0,
                                     $DATA,
                                     &DataAttributeName ) ||
        !_DataAttribute->InsertIntoFile( this, NULL ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }


    // Add an unnamed, empty $DATA attribute.

    if (!AddAttribute($DATA, NULL, NULL, 0, NULL)) {

        DELETE( _DataAttribute );
        return FALSE;
    }


    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Add(
    IN  LCN Lcn
    )
/*++

Routine Description:

    This method adds a cluster to the Bad Cluster List.  Note that it
    does not mark it as used in the volume bitmap.

Arguments:

    Lcn -- supplies the LCN of the bad cluster

Return Value:

    TRUE upon successful completion.

--*/
{
    return( AddRun( Lcn, 1 ) );
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Add(
    IN  PCNUMBER_SET    ClustersToAdd
    )
/*++

Routine Description:

    This method adds a set of clusters to the Bad Cluster List.  Note
    that it does not mark them as used in the volume bitmap.

Arguments:

    BadClusters --  Supplies the clusters to be added to the
                    bad cluster file.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT NumberOfClustersToAdd;
    LCN CurrentLcn;
    ULONG i;

    NumberOfClustersToAdd = ClustersToAdd->QueryCardinality();

    for( i = 0; i < NumberOfClustersToAdd; i++ ) {

        CurrentLcn = ClustersToAdd->QueryNumber(i);

        if( !IsInList( CurrentLcn ) &&
            !Add( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::AddRun(
    IN  LCN     Lcn,
    IN  BIG_INT RunLength
    )
/*++

Routine Description:

    This method adds a run of clusters to the Bad Cluster List.  Note
    that it does not mark these clusters as used in the volume bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run.
    RunLength   -- supplies the number of clusters in the run.

Return Value:

    TRUE upon successful completion.

Notes:

    If LCN is in the range of the volume but the run extends past
    the end of the volume, then the run is truncated.

    If LCN or the RunLength is negative, the run is ignored.  (The
    method succeeds without doing anything in this case.)

--*/
{
    DSTRING DataAttributeName;
    BIG_INT num_clusters;
    BOOLEAN Error;

    num_clusters = QueryVolumeSectors()/QueryClusterFactor();

    if( Lcn < 0             ||
        Lcn >= num_clusters ||
        RunLength < 0 ) {

        return TRUE;
    }

    if (Lcn + RunLength > num_clusters) {

        RunLength = num_clusters - Lcn;
    }

    if( _DataAttribute == NULL &&
        ( !DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }

    return( _DataAttribute->AddExtent( Lcn, Lcn, RunLength ) );
}


BOOLEAN
NTFS_BAD_CLUSTER_FILE::IsInList(
    IN LCN Lcn
    )
/*++

Routine Description:

    This method determines whether a particular LCN is in the bad
    cluster list.

Arguments:

    Lcn --  supplies the LCN in question.

Return Value:

    TRUE if the specified LCN is in the list of bad clusters.

Notes:

    This method cannot be CONST because it may need to fetch the
    data attribute.

--*/
{
    DSTRING DataAttributeName;
    LCN QueriedLcn;
    BOOLEAN Error;

    if( _DataAttribute == NULL &&
        (!DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }

    if( !_DataAttribute->QueryLcnFromVcn( Lcn, &QueriedLcn ) ||
        QueriedLcn == LCN_NOT_PRESENT ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Flush(
    IN OUT  PNTFS_BITMAP        Bitmap,
    IN OUT  PNTFS_INDEX_TREE    ParentIndex
    )
/*++

Routine Description:

    Write the modified bad cluster list to disk.

Arguments:

    Bitmap  -- supplies the volume bitmap.  (May be NULL).

Return Value:

    TRUE upon successful completion.

--*/
{
    if( _DataAttribute != NULL &&
        _DataAttribute->IsStorageModified() &&
        !_DataAttribute->InsertIntoFile( this, Bitmap ) ) {

        return FALSE;
    }

    return( NTFS_FILE_RECORD_SEGMENT::Flush( Bitmap, ParentIndex ) );
}

BOOLEAN
NTFS_BAD_CLUSTER_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that this bad cluster file is prepared
    to receive new bad clusters.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                 DataAttributeName;
    NTFS_EXTENT_LIST        extent_list;
    BOOLEAN                 errors;
    BOOLEAN                 ErrorInAttribute;

    errors = *Changes = FALSE;

    if (!_DataAttribute) {

        if (!(_DataAttribute = NEW NTFS_ATTRIBUTE) ||
            !DataAttributeName.Initialize(BadfileDataNameData)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!QueryAttribute(_DataAttribute,
                            &ErrorInAttribute,
                            $DATA,
                            &DataAttributeName)) {

            *Changes = TRUE;

            if (!errors) {
                errors = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_BAD_FILE);
            }

            if (!extent_list.Initialize(0, QueryVolumeSectors()/
                                           QueryClusterFactor())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!_DataAttribute->Initialize(GetDrive(),
                                            QueryClusterFactor(),
                                            &extent_list,
                                            0,
                                            0,
                                            $DATA,
                                            &DataAttributeName ) ) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!_DataAttribute->InsertIntoFile(this, VolumeBitmap)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }
    }

    if (_DataAttribute->IsStorageModified())
        *Changes = TRUE;

    if (_DataAttribute->IsStorageModified() &&
        !_DataAttribute->InsertIntoFile(this, VolumeBitmap) ||
        (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex))) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BAD_FILE);
        return FALSE;
    }

    return TRUE;
}


BIG_INT
NTFS_BAD_CLUSTER_FILE::QueryNumBad(
    )
/*++

Routine Description:

    This routine return the number of bad clusters in the bad cluster
    file.

Arguments:

    None.

Return Value:

    The number of bad clusters in the bad cluster file.

--*/
{
    DSTRING DataAttributeName;
    BOOLEAN Error;

    if( _DataAttribute == NULL &&
        ( !DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return 0;
    }

    return _DataAttribute->QueryClustersAllocated();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\format.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

   format.cxx

Abstract:

    This module contains the definition of NTFS_SA::Create,
    which performs FORMAT for an NTFS volume.

Author:

   Bill McJohn (billmc) 15-Aug-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "error.hxx"
#include "untfs.hxx"
#include "..\..\ufat\inc\fatsa.hxx" // for PHYS_REMOVABLE and PHYS_FIXED ;

#include "string.hxx"
#include "wstring.hxx"
#include "numset.hxx"
#include "numset.hxx"

#include "ifssys.hxx"

#include "ntfssa.hxx"
#include "attrib.hxx"
#include "frs.hxx"
#include "mftfile.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "attrdef.hxx"
#include "badfile.hxx"
#include "bootfile.hxx"
#include "bitfrs.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "logfile.hxx"

#include "rtmsg.h"
#include "message.hxx"

#define LOGFILE_PLACEMENT_V1    1

CONST WCHAR FileNameMft[] = {'$', 'M', 'F', 'T', 0};
CONST WCHAR FileNameMftRef[] = {'$', 'M', 'F', 'T', 'M', 'i', 'r', 'r', 0 };
CONST WCHAR FileNameLogFile[] = {'$', 'L', 'o', 'g', 'F', 'i', 'l', 'e', 0 };
CONST WCHAR FileNameDasd[] = {'$', 'V', 'o', 'l', 'u', 'm', 'e', 0 };
CONST WCHAR FileNameAttrDef[] = {'$', 'A', 't', 't', 'r', 'D', 'e', 'f', 0 };
CONST WCHAR FileNameRootIndex[] = {'.', 0 };
CONST WCHAR FileNameBitmap[] = {'$', 'B', 'i', 't', 'm', 'a', 'p', 0 };
CONST WCHAR FileNameBootFile[] = {'$', 'B', 'o', 'o', 't', 0 };
CONST WCHAR FileNameBadFile[] = {'$', 'B', 'a', 'd', 'C', 'l', 'u', 's', 0 };
CONST WCHAR FileNameQuota[] = {'$', 'Q', 'u', 'o', 't', 'a', 0 };
CONST WCHAR FileNameUpcase[] = { '$', 'U', 'p', 'C', 'a', 's', 'e', 0 };


UNTFS_EXPORT
ULONG
NTFS_SA::QuerySectorsInElementaryStructures(
    IN  PCDP_DRIVE  Drive,
    IN  ULONG       ClusterFactor,
    IN  ULONG       FrsSize,
    IN  ULONG       ClustersPerIndexBuffer,
    IN  ULONG       LogFileSize
    )
/*++

Routine Description:

    This method computes the number of sectors required for
    the elementary structures of an NTFS volume.

Arguments:

    Drive                   --  Supplies the drive under consideration.
    ClusterFactor           --  Supplies the number of sectors per
                                cluster.  May be zero, in which case
                                a default value is supplied.
    FrsSize                 --  Supplies the number of bytes per
                                NTFS File Record Segment.  May be zero,
                                in which case a default value is supplied.
    ClustersPerIndexBuffer  --  Supplies the number of clusters per NTFS
                                index allocation buffer.  May be zero,
                                in which case a default value is supplied.
    LogFileSize             --  Supplies the size of the log file.  May
                                be zero, in which case a default value
                                is supplied.

Return Value:

    Returns the number of sectors required by an NTFS volume on
    this drive with the specified parameters.  Returns zero if
    it is unable to compute this figure.

--*/
{
    BIG_INT SectorsOnVolume;
    ULONG   SectorsRequired, ClusterSize, SectorSize;

#if 0
    if( Drive->QuerySectors().GetHighPart() != 0 ) {

        return 0;
    }
#endif

    //
    // Check to see that the drive has a valid size
    //

    if( Drive->QuerySectors() == 0 ) {

        return 0;
    }


    SectorsOnVolume = Drive->QuerySectors() - 1;

    SectorSize = Drive->QuerySectorSize();

    if( SectorSize == 0 ) {

        return 0;
    }

    // compute defaults.
    //
    if( ClusterFactor == 0 ) {

        ClusterFactor = NTFS_SA::QueryDefaultClusterFactor( Drive );
    }

    if( FrsSize == 0 ) {
        FrsSize = SMALL_FRS_SIZE;
    }

    //
    //  We'll be in trouble if the frs size is less than the sector
    //  size, because we do all our io in units of sectors.
    //

    if (FrsSize < Drive->QuerySectorSize()) {
        FrsSize = Drive->QuerySectorSize();
    }

    if( ClustersPerIndexBuffer == 0 ) {

        ClustersPerIndexBuffer = QueryDefaultClustersPerIndexBuffer( Drive, ClusterFactor);
    }

    if( LogFileSize == 0 ) {

        LogFileSize = NTFS_LOG_FILE::QueryDefaultSize( Drive, SectorsOnVolume );
    }

    ClusterSize = ClusterFactor * SectorSize;

    // Now add up the various elementary structures:
    //
    // MFT
    //

    SectorsRequired = ((FIRST_USER_FILE_NUMBER * FrsSize + (ClusterSize - 1))
                       / ClusterSize) * ClusterFactor;

    // MFT Mirror
    //

    SectorsRequired += ((REFLECTED_MFT_SEGMENTS * FrsSize + (ClusterSize - 1))
                        / ClusterSize) * ClusterFactor;

    // Log file
    //

    SectorsRequired += LogFileSize/SectorSize + 1;

    // Attribute Definition Table
    //
    SectorsRequired += NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultMaxSize()/SectorSize + 1;

    // Bitmap
    //

    // Number of clusters has to be within 32 bits
    //
    DebugAssert((SectorsOnVolume / ClusterFactor).GetHighPart() == 0);

    SectorsRequired += ((SectorsOnVolume / ClusterFactor).GetLowPart() / 8)/SectorSize + 1;

    // Boot file
    //
    SectorsRequired += BYTES_IN_BOOT_AREA/SectorSize;

    // Upcase Table
    //
    SectorsRequired += NTFS_UPCASE_TABLE::QueryDefaultSize()/SectorSize;

    // The Volume DASD file, the Bad Cluster file, and the Quota
    // Table don't take up any extra space.

    return SectorsRequired;
}



UNTFS_EXPORT
BOOLEAN
NTFS_SA::WriteRemainingBootCode(
    )
/*++

Routine Description:

    This method writes the remainder of the boot code, ie. the
    portion that is not stored in the first sector (which is
    written when the superarea itself is written).

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    HMEM BootCodeMem;
    SECRUN BootCodeSecrun;
    ULONG SectorsInBootArea, SectorSize;

    SectorSize = _drive->QuerySectorSize();

    SectorsInBootArea = ( BYTES_IN_BOOT_AREA % SectorSize ) ?
                            ( BYTES_IN_BOOT_AREA / SectorSize + 1 ) :
                            ( BYTES_IN_BOOT_AREA / SectorSize );

    if( !BootCodeMem.Initialize() ||
        !BootCodeSecrun.Initialize( &BootCodeMem,
                                    _drive,
                                    1,
                                    SectorsInBootArea - 1 ) ) {

        return FALSE;
    }

    memcpy( BootCodeSecrun.GetBuf(),
            _bootcode + SectorSize,
            _bootcodesize - SectorSize );

    if( !BootCodeSecrun.Write( ) ) {

        return FALSE;
    }

    SetSystemId();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_SA::CreateElementaryStructures(
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN      ULONG                   ClusterFactor,
    IN      ULONG                   FrsSize,
    IN      ULONG                   IndexBufferSize,
    IN      ULONG                   InitialLogFileSize,
    IN      PCNUMBER_SET            BadSectors,
    IN      BOOLEAN                 BackwardCompatible,
    IN      BOOLEAN                 IsConvert,
    IN OUT  PMESSAGE                Message,
    IN      PBIOS_PARAMETER_BLOCK   OldBpb,
    IN      PCWSTRING               Label
    )
/*++

Routine Description:

    This method creates the system-defined files on the volume.  Note
    that it does not write the superarea (ie. the boot sectors).

Arguments:

    VolumeBitmap            --  Supplies the bitmap for the volume.
    ClusterFactor           --  Supplies the number of sectors per cluster.
    FrsSize                 --  Supplies the size of each FRS (in bytes).
    IndexBufferSize         --  Supplies the volume default index allocation
                                buffer size.
    InitialLogFileSize      --  Supplies the initial size of the log file.
                                If zero is given for this parameter, this
                                method will choose a default size based on
                                the size of the volume.
    BadSectors              --  Supplies a list of the bad sectors on the disk.
    BackwardCompatible      --  TRUE if volume is not suppose to be upgraded;
                                FALSE if volume is suppose to be upgraded on mount.
    Message                 --  Supplies an outlet for messages.
    OldBpb                  --  Supplies a pointer to the volume's existing
                                Bios Parameter Block.  If this parameter
                                is present, then the disk geometry information
                                (Sectors per Track, Heads, and HiddenSectors)
                                are copied from it; otherwise, they are
                                queried from the drive.
    Label                   --  Supplies an optional volume label (may be NULL)
    IsConvert               --  TRUE if we are being called to convert a FAT partition to NTFS.
                                FALSE if we are being called to format a partition.

Return Value:

    TRUE upon successful completion.

Notes:

    The supplied Bitmap is updated and written to disk.

    We want the volume layout to be something like this:

#ifdef LOGFILE_PLACEMENT_V1
        0   $Boot

        3GB ||
        1GB ||
        n/3 $LogFile
            $Mft Bitmap (at least 8k)
            $Mft

        n/2 $MftMirr
            $AttrDef
            $Bitmap
            $UpCase
            root index allocation
#else
        0   $Boot
            $Mft Bitmap (at least 8k)
            $Mft

            $AttrDef

        n/2 $MftMirr
            $LogFile
            root index allocation
            $Bitmap
            $UpCase
            $SDS
#endif

--*/
{

    NUMBER_SET                          BadClusters;
    NTFS_MFT_FILE                       MftFile;
    NTFS_REFLECTED_MASTER_FILE_TABLE    MftReflection;
    NTFS_ATTRIBUTE_DEFINITION_TABLE     AttributeDefinitionTable;
    NTFS_BAD_CLUSTER_FILE               BadClusterFile;
    NTFS_BITMAP_FILE                    BitmapFile;
    NTFS_BOOT_FILE                      BootFile;
    NTFS_LOG_FILE                       LogFile;
    NTFS_FILE_RECORD_SEGMENT            RootIndexFile;
    NTFS_FILE_RECORD_SEGMENT            QuotaFile;
    NTFS_FILE_RECORD_SEGMENT            VolumeDasdFile;
    NTFS_FILE_RECORD_SEGMENT            GenericFrs;
    NTFS_INDEX_TREE                     RootIndex;
    NTFS_ATTRIBUTE                      BitmapAttribute;
    NTFS_ATTRIBUTE                      VolumeInformationAttribute;
    DSTRING                             RootIndexName;
    NTFS_UPCASE_FILE                    UpcaseFile;
    NTFS_UPCASE_TABLE                   UpcaseTable;

    MFT_SEGMENT_REFERENCE               RootFileIndexSegment;
    STANDARD_INFORMATION                StandardInformation;
    VOLUME_INFORMATION                  VolumeInformation;
    LARGE_INTEGER                       SystemTime;
    LCN                                 InitialMftLcn;
    LCN                                 MftLcn;
    LCN                                 Lcn;
    LCN                                 LogFileNearLcn;
    ULONG                               i;
    ULONG                               nFirstUserFrs;
    ULONG                               ClusterSize;
    ULONG                               ClustersInBootArea;
    ULONG                               MftSize;
    BIG_INT                             NumberOfSectors;
    BIG_INT                             NumberOfClusters;
    BIG_INT                             ClustersNeeded;
    PWSTR                               LabelString;
    ULONG                               NumBootClusters;

    CANNED_SECURITY_TYPE RootACL;

    CONST FileNameBufferSize = 256;
    CHAR FileNameBuffer[ FileNameBufferSize ];
    CONST PFILE_NAME FileName = (PFILE_NAME)(FileNameBuffer);
    CONST PVOID FileNameValue = NtfsFileNameGetName( FileName );

#if 0
    // Determine the size of the volume:
    //
    if (_drive->QuerySectors().GetHighPart() != 0) {

        DebugAbort("Number of sectors exceeds 32 bits");
        return FALSE;
    }
#endif

    NumberOfSectors = _drive->QuerySectors() - 1;

    //
    // The replica boot sector will be just past the end of the volume.
    //

    if (_boot2 != 0 && _boot2 != NumberOfSectors) {

        DebugPrintTrace(("NTFS_SA::CreateElementary - found _boot2 incorrect.\n"));
    }

    _boot2 = NumberOfSectors;


    if (!IsConvert) {

        memset( _boot_sector->Oem, 0, 8 );

        if (!Write(Message)) {
            DebugPrintTrace(("UNTFS: Unable to wipe out boot sector signature\n"));
        }

        // clear up any FAT/FAT32 reserved sectors

        PBYTE   ZeroBuf = (PBYTE)MALLOC(_drive->QuerySectorSize());

        if (ZeroBuf == NULL) {
            Message->Set( MSG_FMT_NO_MEMORY );
            Message->Display( "" );
            return FALSE;
        }
        memset(ZeroBuf, 0, _drive->QuerySectorSize());

        for (i=1; i<32; i++) {
            if (!_drive->Write(i, 1, ZeroBuf)) {
                DebugPrintTrace(("UNTFS: Unable to clean sector %d\n", i));
            }
        }
        FREE(ZeroBuf);
    }

    // Set up the Standard Information structure that will
    // be used by all the special files.  The creation and modification
    // times are now, and all files created by format are hidden.

    memset( (PVOID)&StandardInformation,
            0,
            sizeof(STANDARD_INFORMATION) );

    IFS_SYSTEM::QueryNtfsTime( &SystemTime );

    StandardInformation.CreationTime =
        StandardInformation.LastModificationTime =
        StandardInformation.LastChangeTime =
        StandardInformation.LastAccessTime = SystemTime;

    StandardInformation.FileAttributes = FILE_ATTRIBUTE_HIDDEN |
                                         FILE_ATTRIBUTE_SYSTEM;

    // Get the default system upcase table
    //
    if( !UpcaseTable.Initialize() ) {

        DebugAbort( "Can't initialize upcase table.\n" );
        return FALSE;
    }

    // Calculate the cluster size.  Currently cluster sizes greater
    // than 64k are not supported, so make sure we don't create volumes
    // with larger clusters.
    //

    ClusterSize = ClusterFactor * _drive->QuerySectorSize();

    if (ClusterSize > 64 * 1024) {

        ClusterSize = 64 * 1024;
        ClusterFactor = ClusterSize / _drive->QuerySectorSize();
    }

    NumberOfClusters = NumberOfSectors / ClusterFactor; 

    // Clear the boot block and the backup boot cluster in the
    // bitmap.  Note that these will get set immediately after
    // the bad sectors are marked as in use--this allows me to
    // detect if these sectors are on the bad sector list.
    //

    ClustersInBootArea = (BYTES_IN_BOOT_AREA % ClusterSize) ?
                            BYTES_IN_BOOT_AREA / ClusterSize + 1 :
                            BYTES_IN_BOOT_AREA / ClusterSize;

    NumBootClusters = max(1, BYTES_PER_BOOT_SECTOR/ClusterSize);

    VolumeBitmap->SetFree( 0, ClustersInBootArea );

    // Convert the Bad Sectors to Bad Clusters, and mark those
    // clusters as in-use in the bitmap.  Note that we have to
    // check for duplicates, or else the Bad Cluster File will
    // choke on the list.

    if( !BadClusters.Initialize() ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );

        DebugPrint( "Can't initialize bad clusters numset.\n" );
        return FALSE;
    }

    for( i = 0; i < BadSectors->QueryCardinality(); i++ ) {

        Lcn = BadSectors->QueryNumber(i)/ClusterFactor;

        // Only map bad sectors that fall within the range of 
        // clusters addressed by NTFS. It is possible that there 
        // are a few bad sectors beyond those that can be addressed
        // as clusters eg. backup boot sector which is the last 
        // sector on the disk
        if (Lcn < NumberOfClusters) {
            BadClusters.Add( Lcn );
            VolumeBitmap->SetAllocated( Lcn, 1 );
        }

    }


    // The first BYTES_IN_BOOT_AREA bytes on the volume and
    // the cluster which contains the middle sector of the volume
    // are reserved for the Boot file.  If these sectors are not
    // free, it means that we have bad sectors in one of these
    // reserved spots.  We won't allow such a volume to be formatted
    // to NTFS.

    if( !VolumeBitmap->IsFree( 0, ClustersInBootArea )) {

        DebugPrint( "Boot sector is in bad cluster list.\n" );
        return FALSE;
    }

    VolumeBitmap->SetAllocated( 0, ClustersInBootArea );

    // Allocate space for the MFT itself.  We want the mft bitmap to
    // be immediately after the primary boot cluster, with the Mft following,
    // so we leave space for the mft bitmap.
    //

    MftSize = (FIRST_USER_FILE_NUMBER * FrsSize + (ClusterSize - 1))/ClusterSize;

    if (_cvt_zone != 0 && _cvt_zone_size != 0) {
        //
        // Make those reserved clusters appear to be unused
        // so that it will be allocated for the MFT and Logfile
        //
        DebugAssert(VolumeBitmap->IsAllocated(_cvt_zone, _cvt_zone_size));
        VolumeBitmap->SetFree(_cvt_zone, _cvt_zone_size);

        //
        // Figure out the amount of space needed
        //
        ULONG log_file_size = InitialLogFileSize ?
                            InitialLogFileSize :
                            NTFS_LOG_FILE::QueryDefaultSize(_drive, _drive->QuerySectors());
        ClustersNeeded = log_file_size/ClusterSize;
        if (log_file_size % ClusterSize)
            ClustersNeeded = ClustersNeeded + 1;

        ClustersNeeded = ClustersNeeded + (MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize;
        MftLcn = _cvt_zone + ClustersNeeded;
        ClustersNeeded = ClustersNeeded + MftSize;
    }

    if (_cvt_zone == 0 || _cvt_zone_size == 0 || _cvt_zone_size < ClustersNeeded) {
        if (_cvt_zone != 0) {
            Message->Set( MSG_CONV_CVTAREA_TOO_SMALL );
            Message->Display( "%d", (ClustersNeeded*ClusterSize-1)/(1024*1024)+1 );
        }
        _cvt_zone_size = 0;
        _cvt_zone = 0;
        ClustersNeeded = 0;
#if LOGFILE_PLACEMENT_V1
        #define ONE_GB 0x40000000U
        if (_drive->QuerySectors() < (2 * ONE_GB / _drive->QuerySectorSize())) {
            MftLcn = (_drive->QuerySectors() / 3) / ClusterFactor;
        } else if (_drive->QuerySectors() < ((BIG_INT)6 * ONE_GB / _drive->QuerySectorSize())) {
            MftLcn = ONE_GB / ClusterSize; // put it at 1GB for now
        } else {
            MftLcn = (3 * ONE_GB) / ClusterSize; // put it at 3GB for now
        }
#else
        MftLcn = ClustersInBootArea +
                    (MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize;
#endif
    } else {
        InitialMftLcn = MftLcn;
    }

    if( !VolumeBitmap->AllocateClusters( MftLcn, MftSize, &MftLcn ) ) {

        DebugPrint( "Can't allocate space for the MFT.\n" );
        return FALSE;
    }

    if (ClustersNeeded != 0) {
        //
        // Make sure those reserved clusters are used as expected
        //
        DebugAssert(MftLcn == InitialMftLcn);
        DebugAssert(VolumeBitmap->IsAllocated(InitialMftLcn, MftSize));
    }


#if LOGFILE_PLACEMENT_V1
    LogFileNearLcn = MftLcn - ((MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize);
#endif // PLACEMENT_EXP

    // Another bit of housecleaning:  I need the file segment reference
    // of the root file name index so I can add file-name attributes
    // to the system files.  The initial sequence number of the Root
    // File Index FRS is the same as its file number.
    //

    RootFileIndexSegment.LowPart = ROOT_FILE_NAME_INDEX_NUMBER;
    RootFileIndexSegment.HighPart = 0;
    RootFileIndexSegment.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    if( !RootIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( $FILE_NAME,
                               _drive,
                               ClusterFactor,
                               VolumeBitmap,
                               &UpcaseTable,
                               COLLATION_FILE_NAME,
                               IndexBufferSize,
                               FrsSize / 2,
                               &RootIndexName ) ) {

        DebugPrint( "Cannot initialize Index Tree for root file name index.\n" );
        return FALSE;
    }

    // These "Hidden Status" messages are a hack to allow WinDisk to
    // cancel a quick format, which ordinarily doesn't send any status
    // messages, but which might take a while and for which there is a
    // cancel button.  When using format.com, no message will be displayed
    // for this.

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize and create the MFT.  Note that this will not
    // actually write the MFT to disk.

    // Set up the FILE_NAME attribute.

    memset( FileName,
            0,
            FileNameBufferSize );

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameMft );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameMft,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !MftFile.Initialize( _drive,
                             MftLcn,
                             ClusterFactor,
                             FrsSize,
                             _drive->QuerySectors() - 1,
                             VolumeBitmap,
                             &UpcaseTable ) ||
        !MftFile.Create( FIRST_USER_FILE_NUMBER,
                         &StandardInformation,
                         VolumeBitmap ) ||
        !MftFile.AddFileNameAttribute( FileName ) ||
        !MftFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                MftFile.QuerySegmentReference() ) ) {

        DebugPrint( "Can't create MFT.\n" );
        return FALSE;
    }

#if LOGFILE_PLACEMENT_V1
    // Initialize, create, and write the log file.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameLogFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameLogFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Create( &StandardInformation,
                         LogFileNearLcn,
                         InitialLogFileSize,
                         VolumeBitmap ) ||
        !LogFile.AddFileNameAttribute( FileName ) ||
        !LogFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                LogFile.QuerySegmentReference() ) ||
        !LogFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Log File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }
#endif

    // Initialize, create, and write the reflection of the Master
    // File Table.  Note that this allocates space for the MFT
    // Reflection's data attribute, but does not write the data
    // attribute.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameMftRef );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameMftRef,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !MftReflection.Initialize( MftFile.GetMasterFileTable() ) ||
        !MftReflection.Create( &StandardInformation,
                               VolumeBitmap ) ||
        !MftReflection.AddFileNameAttribute( FileName ) ||
        !MftReflection.AddSecurityDescriptor( ReadCannedSd,
                                              VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                MftReflection.QuerySegmentReference() ) ||
        !MftReflection.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create MFT Reflection.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

#if !defined(LOGFILE_PLACEMENT_V1)
    // Initialize, create, and write the log file.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameLogFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameLogFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Create( &StandardInformation,
                         0,
                         InitialLogFileSize,
                         VolumeBitmap ) ||
        !LogFile.AddFileNameAttribute( FileName ) ||
        !LogFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                LogFile.QuerySegmentReference() ) ||
        !LogFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Log File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }
#endif

    // Initialize, create, and write an empty file for the Volume DASD info.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameDasd );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameDasd,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // Set up the volume information attribute.
    //
    memset(&VolumeInformation, 0, sizeof(VOLUME_INFORMATION));

    VolumeInformation.MajorVersion = NTFS_CURRENT_MAJOR_VERSION;
    VolumeInformation.MinorVersion = NTFS_CURRENT_MINOR_VERSION;
    VolumeInformation.VolumeFlags = 0;
    if (!BackwardCompatible)
        VolumeInformation.VolumeFlags |= VOLUME_UPGRADE_ON_MOUNT;

    if (!VolumeInformationAttribute.Initialize(_drive, ClusterFactor,
            &VolumeInformation, sizeof(VOLUME_INFORMATION),
            $VOLUME_INFORMATION)) {

        DebugPrint( "Can't create volume information attribute.\n" );
        return FALSE;
    }

    if (Label) {
        LabelString = Label->QueryWSTR();
    } else {
        LabelString = NULL;
    }

    if( !VolumeDasdFile.Initialize( VOLUME_DASD_NUMBER,
                                    MftFile.GetMasterFileTable() ) ||
        !VolumeDasdFile.Create( &StandardInformation ) ||
        !VolumeDasdFile.AddFileNameAttribute( FileName ) ||
        !VolumeDasdFile.AddSecurityDescriptor( WriteCannedSd, VolumeBitmap ) ||
        !VolumeDasdFile.AddEmptyAttribute( $DATA ) ||
        !(LabelString == NULL ||
          VolumeDasdFile.AddAttribute( $VOLUME_NAME, NULL, LabelString,
                                       Label->QueryChCount()*sizeof(WCHAR),
                                       VolumeBitmap )) ||
        !VolumeInformationAttribute.InsertIntoFile( &VolumeDasdFile,
                                                    NULL ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                VolumeDasdFile.QuerySegmentReference() ) ||
        !VolumeDasdFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Volume DASD file.\n" );
        return FALSE;
    }

    DELETE(LabelString);

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Attribute Definition Table
    // File Record Segment.  This will also allocate and write the
    // Attribute Definition Table's DATA attribute, which is the
    // actual attribute definition table.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameAttrDef );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameAttrDef,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !AttributeDefinitionTable.Initialize( MftFile.GetMasterFileTable(),
                                              1) ||
        !AttributeDefinitionTable.Create( &StandardInformation,
                                          VolumeBitmap ) ||
        !AttributeDefinitionTable.AddFileNameAttribute( FileName ) ||
        !AttributeDefinitionTable.AddSecurityDescriptor( ReadCannedSd,
                                                         VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                AttributeDefinitionTable.
                                            QuerySegmentReference() ) ||
        !AttributeDefinitionTable.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Attribute Definition Table.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the FRS for the root file name
    // index.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameRootIndex );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameRootIndex,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // If we are converting, use a generic ACL

    if (IsConvert) {
        RootACL = NoAclCannedSd;
    } else {
        RootACL = NewRootSd;
    }

    if( !RootIndexFile.Initialize( ROOT_FILE_NAME_INDEX_NUMBER,
                                   MftFile.GetMasterFileTable() ) ||
        !RootIndexFile.Create( &StandardInformation,
                               FILE_FILE_NAME_INDEX_PRESENT ) ||
        !RootIndexFile.AddFileNameAttribute( FileName ) ||
        !RootIndexFile.AddSecurityDescriptor( RootACL,
                                              VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                RootIndexFile.QuerySegmentReference() ) ||
        !RootIndexFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Root Index FRS.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the bitmap File Record Segment.
    // Note that this does not write the bitmap, just its File Record
    // Segment.  Note also that the disk space for the bitmap is
    // allocated at this time.


    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBitmap );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBitmap,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BitmapFile.Create( &StandardInformation, VolumeBitmap ) ||
        !BitmapFile.AddFileNameAttribute( FileName ) ||
        !BitmapFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BitmapFile.QuerySegmentReference() ) ||
        !BitmapFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Bitmap File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Boot-File File Record Segment.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBootFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBootFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BootFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BootFile.Create( &StandardInformation ) ||
        !BootFile.AddFileNameAttribute( FileName ) ||
        !BootFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BootFile.QuerySegmentReference() ) ||
        !BootFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create boot file.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Bad Cluster File.
    //
    // Set up the FILE_NAME attribute.
    //
    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBadFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBadFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BadClusterFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BadClusterFile.Create( &StandardInformation,
                                VolumeBitmap,
                                &BadClusters ) ||
        !BadClusterFile.AddFileNameAttribute( FileName ) ||
        !BadClusterFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BadClusterFile.QuerySegmentReference() ) ||
        !BadClusterFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Bad Cluster File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Quota Table.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameQuota );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameQuota,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !QuotaFile.Initialize( QUOTA_TABLE_NUMBER,
                               MftFile.GetMasterFileTable() ) ||
        !QuotaFile.Create( &StandardInformation ) ||
        !QuotaFile.AddEmptyAttribute( $DATA ) ||
        !QuotaFile.AddFileNameAttribute( FileName ) ||
        !QuotaFile.AddSecurityDescriptor( WriteCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                QuotaFile.QuerySegmentReference() ) ||
        !QuotaFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Quota Table File Record Segment.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Create the Upcase Table file.
    //
    // Set up the FILE_NAME attribute.
    //
    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameUpcase );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameUpcase,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Create( &StandardInformation,
                            &UpcaseTable,
                            VolumeBitmap ) ||
        !UpcaseFile.AddFileNameAttribute( FileName ) ||
        !UpcaseFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                UpcaseFile.QuerySegmentReference() ) ||
        !UpcaseFile.Flush( VolumeBitmap, &RootIndex ) ) {

        DebugPrint( "Can't create Upcase Table File Record Segment.\n" );
        return FALSE;
    }



    // The reserved FRS's between the Upcase Table and the first user
    // file must be valid and in-use.

    if (ClusterSize > (FrsSize*FIRST_USER_FILE_NUMBER))
        nFirstUserFrs = (ClusterSize + FrsSize - 1) / FrsSize;
    else
        nFirstUserFrs = FIRST_USER_FILE_NUMBER;

    for( i = UPCASE_TABLE_NUMBER + 1; i < nFirstUserFrs; i++ ) {

        if( !GenericFrs.Initialize( i,
                                    MftFile.GetMasterFileTable() ) ||
            !GenericFrs.Create( &StandardInformation ) ||
            !GenericFrs.AddEmptyAttribute( $DATA ) ||
            !GenericFrs.AddSecurityDescriptor( WriteCannedSd,
                                               VolumeBitmap ) ||
            ((i >= FIRST_USER_FILE_NUMBER) && (GenericFrs.ClearInUse(), FALSE)) ||
            !GenericFrs.Flush( VolumeBitmap ) ) {

            DebugPrint( "Can't create a generic FRS.\n" );
            return FALSE;
        }
    }


    // Construct the root file name index.


    if( !RootIndex.Save( &RootIndexFile ) ||
        !RootIndexFile.Flush(VolumeBitmap) ) {

        DebugPrint( "Can't save root index.\n" );
        return FALSE;
    }


    // Flush the MFT.  Note that flushing the MFT writes the volume
    // bitmap and the MFT Mirror.

    if( !MftFile.Flush() ) {

        DebugPrint( "Can't flush MFT.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    memset( _boot_sector->Unused1, 0, sizeof(_boot_sector->Unused1) );
    memset( _boot_sector->Unused2, 0, sizeof(_boot_sector->Unused2) );

    // Fill in sector zero.  First, copy the boot code in.  Then
    // set the fields of interest.
    //
    memcpy( _boot_sector, _bootcode, _drive->QuerySectorSize() );

    memcpy( _boot_sector->Oem, "NTFS    ", 8 );

    _bpb.BytesPerSector = (USHORT)_drive->QuerySectorSize();
    _bpb.SectorsPerCluster = (UCHAR)ClusterFactor;
    _bpb.ReservedSectors = 0;
    _bpb.Fats = 0;
    _bpb.RootEntries = 0;
    _bpb.Sectors = 0;
    _bpb.Media = _drive->QueryMediaByte();
    _bpb.SectorsPerFat = 0;

    if( OldBpb == NULL ) {

        // Use geometry supplied by the driver.
        //
        _bpb.SectorsPerTrack = (USHORT) _drive->QuerySectorsPerTrack();
        _bpb.Heads = (USHORT) _drive->QueryHeads();
        _bpb.HiddenSectors = _drive->QueryHiddenSectors().GetLowPart();

    } else {

        // Use geometry recorded in the existing Bios
        // Parameter Block.
        //
        _bpb.SectorsPerTrack = OldBpb->SectorsPerTrack;
        _bpb.Heads = OldBpb->Heads;
        _bpb.HiddenSectors = OldBpb->HiddenSectors;
    }

    _bpb.LargeSectors = 0;

    // Unused[0] is used by the boot code to indicate Drive Number.
    //
    memset( _boot_sector->Unused, '\0', sizeof(_boot_sector->Unused) );

    memset( _boot_sector->Unused1, '\0', sizeof(_boot_sector->Unused1) );
    memset( _boot_sector->Unused2, '\0', sizeof(_boot_sector->Unused2) );

    _boot_sector->Unused[0] = _drive->IsRemovable() ? PHYS_REMOVABLE :
                                                      PHYS_FIXED ;

    _boot_sector->NumberSectors = (_drive->QuerySectors() - 1).GetLargeInteger();

    _boot_sector->MftStartLcn = MftLcn;
    _boot_sector->Mft2StartLcn = MftReflection.QueryFirstLcn();

    // If the frs size is less than the cluster size, we write 0 in the
    // ClustersPerFileRecordSegment.  In that case the actual frs size
    // should be SMALL_FRS_SIZE.
    //

    // If the frs size is greater than or equal to the cluster size, we
    // write cluster size divided by frs size into the ClustersPerFrs field.
    // Otherwise, we will want the frs size to be 1024 bytes, and we will
    // set the ClustersPerFileRecordSegment to the negation of the log (base 2)
    // of 1024.
    //

    ULONG cluster_size = ClusterFactor * _drive->QuerySectorSize();

    if (FrsSize < cluster_size) {

        ULONG temp;
        LONG j;

        for (j = 0, temp = FrsSize; temp > 1; temp >>= 1) {
            j++;
        }

        _boot_sector->ClustersPerFileRecordSegment = CHAR(-j);

    } else {

        _boot_sector->ClustersPerFileRecordSegment = CHAR(FrsSize / cluster_size);
    }

    // The treatment of DefaultClustersPerIndexBuffer is similar to that of
    // ClustersPerFRS, except we use SMALL_INDEX_BUFFER_SIZE if the clusters
    // are larger than a cluster.
    //

    if (IndexBufferSize < cluster_size) {

        ULONG temp;
        LONG j;

        for (j = 0, temp = SMALL_INDEX_BUFFER_SIZE; temp > 1; temp >>= 1) {
            j++;
        }

        _boot_sector->DefaultClustersPerIndexAllocationBuffer = CHAR(-j);

    } else {

        _boot_sector->DefaultClustersPerIndexAllocationBuffer =
            CHAR(IndexBufferSize / cluster_size);
    }

    _boot_sector->SerialNumber.LowPart = SUPERAREA::ComputeVolId();
    _boot_sector->SerialNumber.HighPart =
            SUPERAREA::ComputeVolId(_boot_sector->SerialNumber.LowPart);

    _boot_sector->Checksum = 0;

    // The elementary disk structures have been created.

    return TRUE;
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors
    )
/*++

Routine Description:

    This routine creates a new NTFS volume on disk based on defaults.

Arguments:

    BadSectors  - Supplies a list of the bad sectors on the disk.
    Message     - Supplies an outlet for messages.
    Label       - Supplies an optional volume label (may be NULL).
    ClusterSize - Supplies the desired size of a cluster in bytes.
    Flags       - Supplies various flags from format.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   ClusterFactor, ClustersPerIndexBuffer;
    BOOLEAN BackwardCompatible = ((Flags & FORMAT_BACKWARD_COMPATIBLE) ? TRUE : FALSE);

    UNREFERENCED_PARAMETER( VirtualSectors );

    if (ClusterSize) {
        if (ClusterSize > 64*1024) {
            Message->Set(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
            Message->Display();
            return FALSE;
        }
        ClusterFactor = max(1, ClusterSize/_drive->QuerySectorSize());
    } else {
        ClusterFactor = QueryDefaultClusterFactor( _drive );
    }

    if (ClusterSize != 0 &&
        ClusterFactor * _drive->QuerySectorSize() != ClusterSize) {

        Message->Set(MSG_FMT_ALLOCATION_SIZE_CHANGED);
        Message->Display("%d", ClusterFactor * _drive->QuerySectorSize());
    }

    return( Create( BadSectors,
                    ClusterFactor,
                    SMALL_FRS_SIZE,
                    SMALL_INDEX_BUFFER_SIZE,
                    0,
                    BackwardCompatible,
                    Message,
                    Label ) );
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN      ULONG           ClusterFactor,
    IN      ULONG           FrsSize,
    IN      ULONG           IndexBufferSize,
    IN      ULONG           InitialLogFileSize,
    IN      BOOLEAN         BackwardCompatible,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label
    )
/*++

Routine Description:

    This routine creates a new NTFS volume on disk.

Arguments:

    BadSectors              --  Supplies a list of the bad sectors
                                on the disk.
    ClusterFactor           --  Supplies the volume cluster factor
    FrsSize                 --  Supplies the size of each FRS
    IndexBufferSize         --  Supplies the default size of
                                an index allocation block.
    InitialLogFileSize      --  Supplies the log file size.  May be zero,
                                in which case a default value is used.
    BackwardCompatible      --  TRUE if volume is not suppose to be upgraded;
                                FALSE if volume is suppose to be upgraded on mount.
    Message                 --  Supplies an outlet for messages.
    Label                   --  Supplies an optional volume label
                                (may be NULL).

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_BITMAP VolumeBitmap;
    DSTRING InternalLabel;
    SECRUN BootCodeSecrun;
    HMEM BootCodeMem;

    BIG_INT KBytesInVolume;
    BIG_INT NumberOfSectors;
    ULONG NumberOfClusters, SectorSize, ClusterSize, SectorsInBootArea;


#if 0
    // For testing, add a bad cluster.
    //
    ((PNUMBER_SET) BadSectors)->Add( _drive->QuerySectors() - 16 );
#endif


    // Determine the number of sectors and clusters on the drive.

    if ((_drive->QuerySectors()/ClusterFactor).GetHighPart() != 0) {

        Message->Set( MSG_FMT_TOO_MANY_CLUSTERS );
        Message->Display( "" );
        return FALSE;
    }


    NumberOfSectors = _drive->QuerySectors()- 1;
    NumberOfClusters = (NumberOfSectors/ClusterFactor).GetLowPart();

    // We're currently not prepared to deal with disks where the frs
    // size is smaller than the sector size, so bump the frs size
    // up if that is the case.  Same deal with the default index buffer
    // size.
    //

    if (FrsSize < _drive->QuerySectorSize()) {

        FrsSize = _drive->QuerySectorSize();
    }
    if (IndexBufferSize < _drive->QuerySectorSize()) {

        IndexBufferSize = _drive->QuerySectorSize();
    }

    // The replica boot sector will be at the very end of the volume.

    _boot2 = NumberOfSectors;

    // Generate a bitmap to cover the number of clusters on the drive.

    if (!VolumeBitmap.Initialize(NumberOfClusters, FALSE, NULL, 0)) {

        DebugPrint( "Cannot initialize bitmap.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    // If the user did not specify a label, prompt for it:
    //
    if (Label) {
        if (!InternalLabel.Initialize(Label)) {
            return FALSE;
        }
    } else {
        Message->Set(MSG_VOLUME_LABEL_NO_MAX);
        Message->Display("");
        Message->QueryStringInput(&InternalLabel);
    }

    while( !IsValidLabel(&InternalLabel)) {

        Message->Set(MSG_INVALID_LABEL_CHARACTERS);
        Message->Display("");

        Message->Set(MSG_VOLUME_LABEL_NO_MAX);
        Message->Display("");
        Message->QueryStringInput(&InternalLabel);
    }

    Message->Set( MSG_FMT_CREATING_FILE_SYSTEM );
    Message->Display( "" );

    // Create the elementary file system structures.  Pass in
    // zero for the initial log file size to indicate that
    // CreateElementaryStructures should choose the size of
    // the log file, and NULL for the OldBpb to indicate that
    // it should use the geometry information from the drive.
    //
    if( !CreateElementaryStructures( &VolumeBitmap,
                                     ClusterFactor,
                                     FrsSize,
                                     IndexBufferSize,
                                     InitialLogFileSize,
                                     BadSectors,
                                     BackwardCompatible,
                                     FALSE,
                                     Message,
                                     NULL,
                                     &InternalLabel ) ) {

        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    if( !Write( Message ) ) {

        DebugPrint( "UNTFS: Unable to write superarea.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    // Write the rest of the boot code:
    //
    SectorSize = _drive->QuerySectorSize();

    SectorsInBootArea = ( BYTES_IN_BOOT_AREA % SectorSize ) ?
                            BYTES_IN_BOOT_AREA / SectorSize + 1 :
                            BYTES_IN_BOOT_AREA / SectorSize;

    if( !BootCodeMem.Initialize() ||
        !BootCodeSecrun.Initialize( &BootCodeMem,
                                    _drive,
                                    1,
                                    SectorsInBootArea - 1 ) ) {

        DebugPrint( "UNTFS: Unable to write boot code.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    memcpy( BootCodeSecrun.GetBuf(),
            _bootcode + _drive->QuerySectorSize(),
            _bootcodesize - _drive->QuerySectorSize() );

    if( !BootCodeSecrun.Write( ) ) {

        DebugPrint( "UNTFS: Unable to write boot code.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    if (!SetSystemId()) {
        Message->Set(MSG_WRITE_PARTITION_TABLE);
        Message->Display("");
        return FALSE;
    }

    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");

    // -----------------------
    // Generate a nice report.
    // -----------------------
    //
    ClusterSize = ClusterFactor * _drive->QuerySectorSize();

    KBytesInVolume = NumberOfClusters;
    KBytesInVolume = KBytesInVolume * ClusterSize / 1024;

    if (KBytesInVolume.GetHighPart() != 0) {
        Message->Set(MSG_TOTAL_MEGABYTES);
        Message->Display("%10u", (KBytesInVolume / 1024).GetLowPart()  );

    } else {
        Message->Set(MSG_TOTAL_KILOBYTES);
        Message->Display("%10u", KBytesInVolume.GetLowPart()  );
    }

    KBytesInVolume = (ClusterSize * VolumeBitmap.QueryFreeClusters())/1024;
    if (KBytesInVolume.GetHighPart() != 0) {
        Message->Set(MSG_AVAILABLE_MEGABYTES);
        Message->Display("%10u", (KBytesInVolume / 1024).GetLowPart() );
    } else {
        Message->Set(MSG_AVAILABLE_KILOBYTES);
        Message->Display("%10u", KBytesInVolume.GetLowPart() );
    }

    return TRUE;
}

VOID
NTFS_SA::PrintFormatReport (
    IN OUT PMESSAGE                     Message,
    IN     PFILE_FS_SIZE_INFORMATION    FsSizeInfo,
    IN     PFILE_FS_VOLUME_INFORMATION  FsVolInfo
    )
{
    DebugAbort("This should never be called\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\frsstruc.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "mem.hxx"
#include "attrib.hxx"
#include "drive.hxx"
#include "clusrun.hxx"
#include "wstring.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "ntfsbit.hxx"
#include "bigint.hxx"
#include "numset.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_FRS_STRUCTURE, OBJECT, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_FRS_STRUCTURE::~NTFS_FRS_STRUCTURE(
    )
/*++

Routine Description:

    Destructor for NTFS_FRS_STRUCTURE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_FRS_STRUCTURE::Construct(
    )
/*++

Routine Description:

    This routine initialize this class to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FrsData = NULL;
    _secrun = NULL;
    _mftdata = NULL;
    _file_number = 0;
    _cluster_factor = 0;
    _size = 0;
    _drive = NULL;
    _volume_sectors = 0;
    _upcase_table = NULL;
    _first_file_number = 0;
    _frs_count = 0;
    _frs_state = _read_status = FALSE;
    _usa_check = UpdateSequenceArrayCheckValueOk;
}



VOID
NTFS_FRS_STRUCTURE::Destroy(
    )
/*++

Routine Description:

    This routine returns this class to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FrsData = NULL;
    DELETE(_secrun);
    _mftdata = NULL;
    _file_number = 0;
    _cluster_factor = 0;
    _size = 0;
    _drive = NULL;
    _volume_sectors = 0;
    _upcase_table = NULL;
    _first_file_number = 0;
    _frs_count = 0;
    _frs_state = _read_status = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    IN      VCN                 FileNumber,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This routine initializes a NTFS_FRS_STRUCTURE to a valid
    initial state.

Arguments:

    Mem             - Supplies memory for the FRS.
    MftData         - Supplies the $DATA attribute of the MFT.
    FileNumber      - Supplies the file number for this FRS.
    ClusterFactor   - Supplies the number of sectors per cluster.
    VolumeSectors   - Supplies the number of volume sectors.
    FrsSize         - Supplies the size of each frs, in bytes.
    UpcaseTable     - Supplies the volume upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table, but then
    it cannot manipulate named attributes until the ucpase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(MftData);
    DebugAssert(ClusterFactor);

    _mftdata = MftData;
    _file_number = FileNumber;
    _cluster_factor = ClusterFactor;
    _drive = MftData->GetDrive();
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectorSize());

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
               Mem->Acquire(QuerySize(), _drive->QueryAlignmentMask());

    if (!_FrsData) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    IN      VCN                 FirstFileNumber,
    IN      ULONG               FrsCount,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This routine initializes a NTFS_FRS_STRUCTURE to a valid
    initial state in preparation for reading a block of FRS'es.

Arguments:

    Mem             - Supplies memory for the FRS.
    MftData         - Supplies the $DATA attribute of the MFT.
    FirstFileNumber - Supplies the first file number for this FRS block.
    FrsCount        - Supplies the number of FRS'es in this FRS block.
    ClusterFactor   - Supplies the number of sectors per cluster.
    VolumeSectors   - Supplies the number of volume sectors.
    FrsSize         - Supplies the size of each frs, in bytes.
    UpcaseTable     - Supplies the volume upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table, but then
    it cannot manipulate named attributes until the ucpase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(MftData);
    DebugAssert(ClusterFactor);

    _mftdata = MftData;
    _file_number = FirstFileNumber;
    _first_file_number = FirstFileNumber;
    _frs_count = FrsCount;
    _frs_state = _read_status = FALSE;
    _cluster_factor = ClusterFactor;
    _drive = MftData->GetDrive();
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectorSize());

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
               Mem->Acquire(QuerySize()*FrsCount, _drive->QueryAlignmentMask());

    if (!_FrsData) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LCN                 StartOfFrs,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      ULONG               Offset
    )
/*++

Routine Description:

    This routine initializes an NTFS_FRS_STRUCTURE to point at one
    of the low frs's.

Arguments:

    Mem             - Supplies memory for the FRS.
    Drive           - Supplies the drive.
    StartOfFrs      - Supplies the starting LCN for the frs.
    ClusterFactor   - Supplies the number of sectors per cluster.
    UpcaseTable     - Supplies the volume upcase table.
    FrsSize         - Supplies the size of frs 0 in bytes.
    Offset          - Supplies the offset in the cluster for the frs.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table; in that case,
    the FRS cannot manipulate named attributes until the upcase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(Drive);

    _file_number = 0;
    _cluster_factor = ClusterFactor;
    _drive = Drive;
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    //
    // Our SECRUN will need to hold the one or more sectors occupied
    // by this frs.
    //

#define BYTES_TO_SECTORS(bytes, sector_size)  \
    (((bytes) + ((sector_size) - 1))/(sector_size))

    ULONG sectors_per_frs = BYTES_TO_SECTORS(FrsSize,
                                             Drive->QuerySectorSize());

    if (!(_secrun = NEW SECRUN) ||
        !_secrun->Initialize(Mem,
                             Drive,
                             StartOfFrs * QueryClusterFactor() +
                                Offset/Drive->QuerySectorSize(),
                             sectors_per_frs)) {

        Destroy();
        return FALSE;
    }

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)_secrun->GetBuf();

    DebugAssert(_FrsData);

    return TRUE;
}


BOOLEAN
NTFS_FRS_STRUCTURE::VerifyAndFix(
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies, and if necessary, fixes an NTFS_FRS_STRUCTURE.

    This routine will clear the IN_USE bit on this FRS if the FRS is
    completely hosed.

Arguments:

    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    AttributeDefTable   - Supplies an attribute definition table.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr;
    NTFS_ATTRIBUTE_RECORD       attr;
    DSTRING                     string;
    BOOLEAN                     changes, duplicates;
    BOOLEAN                     need_write;
    DSTRING                     null_string;
    BOOLEAN                     errors_found;
    NUMBER_SET                  instance_numbers;
    BOOLEAN                     standard_info_found;
    PSTANDARD_INFORMATION       pstandard;
    BOOLEAN                     disk_errors_found;
    ULONG                       file_attributes;
    BOOLEAN                     v0_frs;
    PFILE_RECORD_SEGMENT_HEADER_V0  pfrs_v0 = (PFILE_RECORD_SEGMENT_HEADER_V0)_FrsData;

    if (!null_string.Initialize("\"\"") ||
        !instance_numbers.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (DiskErrorsFound == NULL)
        DiskErrorsFound = &disk_errors_found;

    need_write = FALSE;

    // First make sure that the update sequence array precedes the
    // attribute records and that the two don't overlap.

    errors_found = FALSE;

    DebugAssert(FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly) <=
                FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly));

    if (_FrsData->MultiSectorHeader.Signature[0] != 'F' ||
        _FrsData->MultiSectorHeader.Signature[1] != 'I' ||
        _FrsData->MultiSectorHeader.Signature[2] != 'L' ||
        _FrsData->MultiSectorHeader.Signature[3] != 'E') {

        Message->Lock();
        Message->Set(MSG_CHKLOG_NTFS_INCORRECT_FRS_MULTI_SECTOR_HEADER_SIGNATURE);
        Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
        Message->DumpDataToLog(_FrsData, sizeof(MULTI_SECTOR_HEADER));
        Message->Unlock();

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
                FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly)) {

        // A less precise check before we figure out if this is the smaller or larger
        // file record segment header.

        Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (QuerySize() % SEQUENCE_NUMBER_STRIDE != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_SIZE,
                     "%x%I64x",
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset %
               sizeof(UPDATE_SEQUENCE_NUMBER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_OFFSET,
                     "%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArraySize !=
               QuerySize()/SEQUENCE_NUMBER_STRIDE + 1) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_SIZE,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArraySize,
                     QuerySize()/SEQUENCE_NUMBER_STRIDE + 1,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if ((_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
                _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
                sizeof(UPDATE_SEQUENCE_NUMBER)) > _FrsData->FirstAttributeOffset ||
               _FrsData->FirstAttributeOffset + sizeof(ATTRIBUTE_TYPE_CODE) > QuerySize() ||
               !IsQuadAligned(_FrsData->FirstAttributeOffset)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_ATTR_OFFSET,
                     "%x%I64x",
                     _FrsData->FirstAttributeOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->BytesAvailable != QuerySize()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_HEADER,
                     "%x%x%I64x",
                     _FrsData->BytesAvailable,
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    }

    if (!errors_found) {
        v0_frs = (pfrs_v0->MultiSectorHeader.UpdateSequenceArrayOffset ==
                  FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly));
        if (!v0_frs &&
            _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
                   FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                         "%x%x%I64x",
                         _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                         FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly),
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }
    }

    if (errors_found) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        ClearInUse();

        *DiskErrorsFound = TRUE;

        if (FixLevel != CheckOnly && !Write()) {

            DebugAbort("Could not write a readable sector");
            return FALSE;
        }

        return TRUE;
    }


    // If this is the MFT then make sure that the Sequence Number
    // is not zero.

    if (_FrsData->SequenceNumber != 1 && QueryFileNumber() == 0) {

        DebugPrintTrace(("UNTFS: MFT sequence number is not equal to 1\n"));

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%I64x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SequenceNumber = 1;
        need_write = TRUE;
    }

    if (QueryFileNumber() < FIRST_USER_FILE_NUMBER &&
        QueryFileNumber() != 0 &&
        QueryFileNumber().GetLowPart() != _FrsData->SequenceNumber) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        DebugPrintTrace(("UNTFS: File record segment 0x%I64x sequence number is not equal to 0x%x\n",
                         QueryFileNumber().GetLargeInteger(),
                         _FrsData->SequenceNumber));


        _FrsData->SequenceNumber = (USHORT)QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }

    if (!v0_frs &&
        (_FrsData->SegmentNumberHighPart != (USHORT)QueryFileNumber().GetHighPart() ||
         _FrsData->SegmentNumberLowPart != QueryFileNumber().GetLowPart())) {

        BIG_INT     x;

        x.Set(_FrsData->SegmentNumberHighPart, _FrsData->SegmentNumberLowPart);

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEGMENT_NUMBER,
                     "%I64x%I64x",
                     x.GetLargeInteger(),
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SegmentNumberHighPart = (USHORT)QueryFileNumber().GetHighPart();
        _FrsData->SegmentNumberLowPart = QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }

    // Validate the stucture of the list of attribute records,
    // make sure that there are no special attributes with names,
    // and make sure that all of the attribute records are well
    // composed.

    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   GetNextAttributeRecord(pattr, Message, &errors_found)) {

        need_write = need_write || errors_found;

        // Make sure that the attribute record is in good shape.
        // Don't account for it's disk space yet.
        // Make sure that the attribute instance number is not duplicated.

        if (!attr.Initialize(GetDrive(), pattr)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        errors_found = FALSE;
        if (!attr.Verify(AttributeDefTable, FALSE)) {
            errors_found = TRUE;
        } else if (instance_numbers.DoesIntersectSet((ULONG) pattr->Instance, 1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_COLLISION,
                         "%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        } else if (pattr->Instance >= _FrsData->NextAttributeInstance) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_TOO_LARGE,
                         "%x%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         _FrsData->NextAttributeInstance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }

        if (errors_found) {

            if (!attr.QueryName(&string)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                             "%d%W%d", pattr->TypeCode,
                                       string.QueryChCount() ? &string : &null_string,
                                       QueryFileNumber().GetLowPart());

            DeleteAttributeRecord(pattr);

            if (!instance_numbers.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            need_write = TRUE;
            pattr = NULL;
            continue;
        }

        if (!instance_numbers.Add((ULONG) pattr->Instance)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    need_write = need_write || errors_found;


    // Sort the base FRS attribute records by type, and name.
    // This method will also eliminate duplicates.

    if (!Sort(&changes, &duplicates)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (duplicates || (changes && IsBase())) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        need_write = TRUE;
    }


    // Detect whether or not there is a $STANDARD_INFORMATION.

    standard_info_found = FALSE;
    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pattr)) {
        if (pattr->TypeCode == $STANDARD_INFORMATION) {

            standard_info_found = TRUE;

            // Make sure that if this is a system file than the
            // system and hidden bits are set in the $STANDARD_INFORMATION.

            if (QueryFileNumber() < FIRST_USER_FILE_NUMBER) {
                pstandard = (PSTANDARD_INFORMATION)
                            ((PCHAR) pattr + pattr->Form.Resident.ValueOffset);

                if (!(pstandard->FileAttributes&FAT_DIRENT_ATTR_HIDDEN) ||
                    !(pstandard->FileAttributes&FAT_DIRENT_ATTR_SYSTEM)) {

                    file_attributes = pstandard->FileAttributes |
                                      FAT_DIRENT_ATTR_SYSTEM |
                                      FAT_DIRENT_ATTR_HIDDEN;

                    Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_FILE_ATTR,
                                 "%x%x%I64x",
                                 pstandard->FileAttributes,
                                 file_attributes,
                                 QueryFileNumber().GetLargeInteger()
                                 );

                    pstandard->FileAttributes = file_attributes;

                    Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                                     "%d", QueryFileNumber().GetLowPart());
                    need_write = TRUE;
                }
            }
            break;
        }
    }

    if (IsBase() && !standard_info_found) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_STANDARD_INFO,
                     "%I64x", QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        ClearInUse();
        need_write = TRUE;
    }


    // Write out changes if necessary.

    if (need_write || (_usa_check == UpdateSequenceArrayCheckValueMinorError)) {

        if (need_write) {
            *DiskErrorsFound = TRUE;
        } else {
            DebugPrintTrace(("UNTFS: Quietly fix up check value in file record segment 0x%I64x\n",
                             _file_number.GetLargeInteger()));
        }

        if (FixLevel != CheckOnly && !Write()) {

            DebugAbort("Could not write a readable sector");
            return FALSE;
        }
    }

    return TRUE;
}

#if defined(LOCATE_DELETED_FILE)
BOOLEAN
NTFS_FRS_STRUCTURE::LocateUnuseFrs(
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine locates a deleted file.

Arguments:

    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    AttributeDefTable   - Supplies an attribute definition table.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr;
    NTFS_ATTRIBUTE_RECORD       attr;
    DSTRING                     string;
    BOOLEAN                     changes, duplicates;
    BOOLEAN                     need_write;
    DSTRING                     null_string;
    BOOLEAN                     errors_found;
    NUMBER_SET                  instance_numbers;
    BOOLEAN                     standard_info_found;
    PSTANDARD_INFORMATION       pstandard;
    BOOLEAN                     disk_errors_found;
    ULONG                       file_attributes;

    if (!null_string.Initialize("\"\"") ||
        !instance_numbers.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (DiskErrorsFound == NULL)
        DiskErrorsFound = &disk_errors_found;

    need_write = FALSE;

    // First make sure that the update sequence array precedes the
    // attribute records and that the two don't overlap.

    errors_found = FALSE;

    if (_FrsData->MultiSectorHeader.Signature[0] != 'F' ||
        _FrsData->MultiSectorHeader.Signature[1] != 'I' ||
        _FrsData->MultiSectorHeader.Signature[2] != 'L' ||
        _FrsData->MultiSectorHeader.Signature[3] != 'E') {

        Message->Lock();
        Message->Set(MSG_CHKLOG_NTFS_INCORRECT_FRS_MULTI_SECTOR_HEADER_SIGNATURE);
        Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
        Message->DumpDataToLog(_FrsData, sizeof(MULTI_SECTOR_HEADER));
        Message->Unlock();

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
               FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (QuerySize() % SEQUENCE_NUMBER_STRIDE != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_SIZE,
                     "%x%I64x",
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset %
               sizeof(UPDATE_SEQUENCE_NUMBER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_OFFSET,
                     "%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArraySize !=
               QuerySize()/SEQUENCE_NUMBER_STRIDE + 1) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_SIZE,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArraySize,
                     QuerySize()/SEQUENCE_NUMBER_STRIDE + 1,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
               _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
               sizeof(UPDATE_SEQUENCE_NUMBER) > _FrsData->FirstAttributeOffset ||
               _FrsData->FirstAttributeOffset + sizeof(ATTRIBUTE_TYPE_CODE) >
               QuerySize() ||
               !IsQuadAligned(_FrsData->FirstAttributeOffset)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_ATTR_OFFSET,
                     "%x%I64x",
                     _FrsData->FirstAttributeOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->BytesAvailable != QuerySize()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_HEADER,
                     "%x%x%I64x",
                     _FrsData->BytesAvailable,
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    }

    if (errors_found) {

        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                         "%s%x", "Corrupted unused FRS: ", QueryFileNumber().GetLowPart());

        return TRUE;
    }


    // If this is the MFT then make sure that the Sequence Number
    // is not zero.

    if (_FrsData->SequenceNumber != 1 && QueryFileNumber() == 0) {

        DebugPrintTrace(("UNTFS: MFT sequence number is not equal to 1\n"));

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%I64x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SequenceNumber = 1;
        need_write = TRUE;
    }

    if (QueryFileNumber() < FIRST_USER_FILE_NUMBER &&
        QueryFileNumber() != 0 &&
        QueryFileNumber().GetLowPart() != _FrsData->SequenceNumber) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        DebugPrintTrace(("UNTFS: File record segment 0x%I64x sequence number is not equal to 0x%x\n",
                         QueryFileNumber().GetLargeInteger(),
                         _FrsData->SequenceNumber));


        _FrsData->SequenceNumber = (USHORT)QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }


    // Validate the stucture of the list of attribute records,
    // make sure that there are no special attributes with names,
    // and make sure that all of the attribute records are well
    // composed.

    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   GetNextAttributeRecord(pattr, Message, &errors_found)) {

        need_write = need_write || errors_found;

        // Make sure that the attribute record is in good shape.
        // Don't account for it's disk space yet.
        // Make sure that the attribute instance number is not duplicated.

        if (!attr.Initialize(GetDrive(), pattr)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        errors_found = FALSE;
        if (!attr.Verify(AttributeDefTable, FALSE)) {
            errors_found = TRUE;
        } else if (instance_numbers.DoesIntersectSet((ULONG) pattr->Instance, 1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_COLLISION,
                         "%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        } else if (pattr->Instance >= _FrsData->NextAttributeInstance) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_TOO_LARGE,
                         "%x%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         _FrsData->NextAttributeInstance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }

        if (errors_found) {

            if (!attr.QueryName(&string)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                             "%d%W%d", pattr->TypeCode,
                                       string.QueryChCount() ? &string : &null_string,
                                       QueryFileNumber().GetLowPart());

            DeleteAttributeRecord(pattr);

            if (!instance_numbers.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            need_write = TRUE;
            pattr = NULL;
            continue;
        }

        if (!instance_numbers.Add((ULONG) pattr->Instance)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    need_write = need_write || errors_found;


    // Sort the base FRS attribute records by type, and name.
    // This method will also eliminate duplicates.

    if (!Sort(&changes, &duplicates)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (duplicates || (changes && IsBase())) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        need_write = TRUE;
    }


    // Detect whether or not there is a $FILE_NAME

    PFILE_NAME      fn;
    WCHAR           buf[MAX_PATH];
    BOOLEAN         found_name = FALSE;

    standard_info_found = FALSE;
    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pattr)) {
        if (pattr->TypeCode == $FILE_NAME) {

            found_name = TRUE;
            fn = (PFILE_NAME)((PBYTE)pattr + SIZE_OF_RESIDENT_HEADER);
            memcpy(buf, fn->FileName, fn->FileNameLength*sizeof(WCHAR));
            buf[fn->FileNameLength] = 0;

            if (_wcsicmp(buf, L"drmtool.cpp") == 0) {
                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                                    "%s%x",
                                    "Potential match:  ", QueryFileNumber().GetLowPart());
                return TRUE;
            } else {
                WCHAR   buf2[MAX_PATH+50];

                buf[15] = 0;

                wsprintf(buf2, L"Unused FRS %x Name: %ls",
                         QueryFileNumber().GetLowPart(), buf);

                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                                    "%ws%s",
                                    buf2, "");
            }
        }
    }

    if (!found_name)
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                            "%s%x",
                            "Unused FRS:       ",
                            QueryFileNumber().GetLowPart());

    return TRUE;
}
#endif


BOOLEAN
NTFS_FRS_STRUCTURE::LoneFrsAllocationCheck(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound
    )
/*++

Routine Description:

    This routine checks the allocation of the attribute records in
    the given FRS under the presumption that there is no attribute
    list for this FRS and that this FRS is a base FRS.

Arguments:

    VolumeBitmap            - Supplies a volume bitmap on which to mark off
                                the non-resident attribute records'
                                allocations.
    ChkdskReport            - Supplies the current chkdsk report to be updated
                                with the statistics from this file.
    ChkdskInfo              - Supplies the chkdsk information.
    FixLevel                - Supplies the fix level.
    Message                 - Supplies an outlet for messages.
    DiskErrorsFound         - Supplies whether or not disk errors have
                                been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                       pattr, next_attribute;
    NTFS_ATTRIBUTE_RECORD       attribute_record;
    DSTRING                     string;
    DSTRING                     null_string;
    BIG_INT                     file_length;
    BIG_INT                     alloc_length;
    BIG_INT                     total_allocated;
    BIG_INT                     compute_alloc_length;
    BIG_INT                     compute_total_allocated;
    BIG_INT                     cluster_count;
    BOOLEAN                     changes;
    BIG_INT                     total_user_bytes;
    ATTRIBUTE_TYPE_CODE         type_code;
    BOOLEAN                     user_file;
    BOOLEAN                     got_allow_cross_link;
    BOOLEAN                     error;

    DebugAssert(VolumeBitmap);
    DebugAssert(Message);

    user_file = FALSE;
    changes = FALSE;
    pattr = NULL;
    total_user_bytes = 0;
    pattr = GetNextAttributeRecord(NULL);

    while (pattr) {

        if (!attribute_record.Initialize(GetDrive(), pattr)) {

            DebugAbort("Can't initialize attribute record");
            return FALSE;
        }

        if (attribute_record.IsResident()) {

            compute_alloc_length = 0;
            cluster_count = 0;

        } else {

            compute_alloc_length = (attribute_record.QueryNextVcn() -
                                    attribute_record.QueryLowestVcn())*
                                   QueryClusterFactor()*
                                   _drive->QuerySectorSize();

            attribute_record.QueryValueLength(&file_length, &alloc_length,
                NULL, &total_allocated);

            error = FALSE;
            if (attribute_record.QueryLowestVcn() != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                             "%x%I64x%x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryLowestVcn().GetLargeInteger(),
                             attribute_record.QueryInstanceTag(),
                             QueryFileNumber().GetLargeInteger());
                error = TRUE;
            } else if (compute_alloc_length != alloc_length) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_INCORRECT_ALLOCATE_LENGTH,
                             "%x%x%I64x%I64x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryInstanceTag(),
                             alloc_length.GetLargeInteger(),
                             compute_alloc_length.GetLargeInteger(),
                             QueryFileNumber().GetLargeInteger());

                error = TRUE;
            } else if (!attribute_record.UseClusters(VolumeBitmap,
                                              &cluster_count,
                                              ChkdskInfo->CrossLinkStart,
                                              ChkdskInfo->CrossLinkYet ? 0 :
                                                  ChkdskInfo->CrossLinkLength,
                                              &got_allow_cross_link)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                             "%x%x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryInstanceTag(),
                             QueryFileNumber().GetLargeInteger());

                error = TRUE;
            }

            if (error) {

                DebugPrintTrace(("Attribute %d has either a cross-link or a bad allocation length\n",
                          attribute_record.QueryTypeCode()));

                // The lowest vcn must be zero and
                // the allocated length must match the length allocated and
                // the allocated space must be available in the volume
                // bitmap.
                // So tube this attribute record.

                if (!null_string.Initialize("\"\"") ||
                    !attribute_record.QueryName(&string)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                 "%d%W%d", attribute_record.QueryTypeCode(),
                                 string.QueryChCount() ? &string : &null_string,
                                 QueryFileNumber().GetLowPart());

                next_attribute = GetNextAttributeRecord(pattr);

                DeleteAttributeRecord(pattr);
                changes = TRUE;

                // Do not increment pattr--DeleteAttributeRecord
                // will bring the next attribute record down to us.
                //
                if( !next_attribute ) {

                    // The deleted attribute record was the
                    // last in this FRS.
                    //
                    break;
                }

                continue;
            }

//+++
//ZZZ
            if ((attribute_record.QueryFlags() &
                 (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE))) {

                NTFS_EXTENT_LIST extent_list;

                if (!attribute_record.QueryExtentList(&extent_list)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                compute_total_allocated = extent_list.QueryClustersAllocated() *
                    QueryClusterFactor() * _drive->QuerySectorSize();

                if (compute_total_allocated != total_allocated) {

                    DebugPrintTrace(("Attribute %d has bad total allocated\n"
                                     "total allocated is 0x%I64x\n"
                                     "actual total allocated is 0x%I64x.\n",
                                     attribute_record.QueryTypeCode(),
                                     total_allocated.GetLargeInteger(),
                                     compute_total_allocated.GetLargeInteger()));

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_TOTAL_ALLOCATION,
                                 "%x%x%I64x%I64x%I64x",
                                 attribute_record.QueryTypeCode(),
                                 attribute_record.QueryInstanceTag(),
                                 total_allocated.GetLargeInteger(),
                                 compute_total_allocated.GetLargeInteger(),
                                 QueryFileNumber().GetLargeInteger());

                    Message->DisplayMsg(MSG_CHK_NTFS_FIX_ATTR,
                                     "%d%W%d", attribute_record.QueryTypeCode(),
                                     string.QueryChCount() ? &string : &null_string,
                                     QueryFileNumber().GetLowPart());

                    attribute_record.SetTotalAllocated(compute_total_allocated);

                    changes = TRUE;
                }
            }
//---

            if (got_allow_cross_link) {
                ChkdskInfo->CrossLinkYet = TRUE;
                ChkdskInfo->CrossLinkedFile = QueryFileNumber().GetLowPart();
                ChkdskInfo->CrossLinkedAttribute =
                        attribute_record.QueryTypeCode();
                if (!attribute_record.QueryName(&ChkdskInfo->CrossLinkedName)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }

        type_code = attribute_record.QueryTypeCode();

        if (type_code == $DATA ||
            type_code == $EA_DATA ||
            ((ChkdskInfo->major >= 2) ?
               (type_code >= $FIRST_USER_DEFINED_ATTRIBUTE_2) :
               (type_code >= $FIRST_USER_DEFINED_ATTRIBUTE_1)) ) {

            user_file = TRUE;
            total_user_bytes += cluster_count *
                                QueryClusterFactor()*
                                _drive->QuerySectorSize();
        }

        pattr = GetNextAttributeRecord(pattr);
    }

    if (changes && DiskErrorsFound) {
        *DiskErrorsFound = TRUE;
    }

    if (changes && FixLevel != CheckOnly && !Write()) {
        DebugAbort("readable FRS is unwriteable");
        return FALSE;
    }

    if (QueryFileNumber() >= FIRST_USER_FILE_NUMBER && user_file) {
        ChkdskReport->NumUserFiles += 1;
        ChkdskReport->BytesUserData += total_user_bytes;
    }

    return TRUE;
}

BOOLEAN
NTFS_FRS_STRUCTURE::CheckInstanceTags(
    IN      FIX_LEVEL               FixLevel,
    IN      BOOLEAN                 Verbose,
    IN OUT  PMESSAGE                Message,
    OUT     PBOOLEAN                Changes,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This routine attempts to prevent the instance tags on the
    FRS_STRUCTURE from rolling over...  if we see that the next
    instance tag field is above a reasonable value, we renumber
    the instance tags in the attribute records and reset the
    next instance tag field to the lowest acceptable value.

Arguments:

    AttributeList   - NULL if we're checking a lone frs, otherwise
                      changes to instance tags require us to update
                      this attribute list as well.

Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    PVOID pattr;
    NTFS_ATTRIBUTE_RECORD attr_rec;
    BOOLEAN errors;
    USHORT instance_tag;
    DSTRING Name;

    if (_FrsData->NextAttributeInstance <= ATTRIBUTE_INSTANCE_TAG_THRESHOLD) {
        *Changes = FALSE;
        return TRUE;
    }

    if (Verbose)
        Message->DisplayMsg(MSG_CHK_NTFS_ADJUSTING_INSTANCE_TAGS,
                            "%d", _file_number.GetLowPart());
    else
        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INSTANCE_TAG,
                        "%I64x", _file_number.GetLargeInteger());

    *Changes = TRUE;

    instance_tag = 0;
    pattr = NULL;
    while (NULL != (pattr = (PNTFS_ATTRIBUTE_RECORD)GetNextAttributeRecord(
        pattr ))) {

        if (!attr_rec.Initialize(GetDrive(), pattr)) {
            return FALSE;
        }

        if (NULL != AttributeList &&
            $ATTRIBUTE_LIST != attr_rec.QueryTypeCode()) {

            if (!AttributeList->ModifyInstanceTag(&attr_rec,
                                                  QuerySegmentReference(),
                                                  instance_tag)) {
                DebugAbort("UNTFS: Could not find attribute in attr list.");
                return FALSE;
            }
        }

        attr_rec.SetInstanceTag(instance_tag);

        instance_tag++;
    }

    _FrsData->NextAttributeInstance = instance_tag;

    if (FixLevel != CheckOnly && !Write()) {
        DebugAbort("UNTFS: Once readable frs struct is unwriteable");
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Read(
    )
/*++

Routine Description:

    This routine reads the FRS in from disk.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           bytes;
    BOOLEAN         r;
    PIO_DP_DRIVE    drive;

    DebugAssert(_mftdata || _secrun);

    if (_mftdata) {
        r = _mftdata->Read(_FrsData,
                           _file_number*QuerySize(),
                           QuerySize(),
                           &bytes) &&
            bytes == QuerySize();

        drive = _mftdata->GetDrive();
    } else {
        r = _secrun->Read();
        drive = _secrun->GetDrive();
    }

    _read_status = r &&
                   (_usa_check =
                    NTFS_SA::PostReadMultiSectorFixup(_FrsData,
                                                      QuerySize(),
                                                      drive,
                                                      _FrsData->FirstFreeByte));

    return _read_status;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadNext(
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This routine reads a block of FRS'es in from the disk.  This routine
    is to be used with Initialize(PMEM, PNTFS_ATTRIBUTE, VCN, ULONG,
    ULONG, BIG_INT, ...).

Arguments:

    FileNumber  - Supplies the FRS number to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           bytes;
    BOOLEAN         r;
    ULONG           bytesToRead;

    DebugAssert(_mftdata);

    if (_mftdata) {

        if (_frs_state) {
            _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
                            (((PCHAR)_FrsData)+QuerySize());
            _file_number = _file_number + 1;
            DebugAssert(_file_number == FileNumber);
            r = TRUE;
        } else {
            _file_number = FileNumber;
            if (FileNumber == _first_file_number) {
                bytesToRead = _frs_count * QuerySize();
                r = _frs_state = _mftdata->Read(_FrsData,
                                                FileNumber*QuerySize(),
                                                bytesToRead,
                                                &bytes) &&
                                 bytes == bytesToRead;
                if (!r) {
                    bytesToRead = QuerySize();
                    r = _mftdata->Read(_FrsData,
                                       FileNumber*QuerySize(),
                                       bytesToRead,
                                       &bytes) &&
                        bytes == bytesToRead;
                }
            } else {
                bytesToRead = QuerySize();
                r = _mftdata->Read(_FrsData,
                                   FileNumber*QuerySize(),
                                   bytesToRead,
                                   &bytes) &&
                    bytes == bytesToRead;
            }
        }

    } else {
        return FALSE;
    }

    _read_status = r &&
                   (_usa_check =
                    NTFS_SA::PostReadMultiSectorFixup(_FrsData,
                                                      QuerySize(),
                                                      _mftdata->GetDrive(),
                                                      _FrsData->FirstFreeByte));

    return _read_status;
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadAgain(
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This routine does not read the frs again.  It is provided to tell if
    the last ReadNext was successful.

Arguments:

    FileNumber  - Supplies the FRS number to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_mftdata);
    DebugAssert(_file_number == FileNumber);

    return _read_status;
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadSet(
    IN OUT  PTLINK      Link
    )
/*++

Routine Description:

    This routine reads a block of FRS'es in from the disk based on the given
    list.  This routine is to be used with Initialize(PMEM, PNTFS_ATTRIBUTE,
    VCN, ULONG, ULONG, BIG_INT, ...), and SetFrsData().


Arguments:

    Link            - Supplies the list of FRS numbers to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    This routine always set the _usa_check to UpdateSequenceArrayCheckValueOk.
    It does not matter as the check value would have been corrected during stage one
    and this routine should only be used in stage two or after.

--*/
{
    BOOLEAN         r = TRUE;
    ULONG           bytes;
    ULONG           bytesToRead;
    USHORT          i, j;
    PCHAR           frsData;
    PCHAR           frsdata;
    BIG_INT         start;
    USHORT          length, size;
    USHORT          effective_length;
    PVOID           pNode;
    PIO_DP_DRIVE    drive;


    DebugAssert(_mftdata);

    if (_mftdata) {

        _usa_check = UpdateSequenceArrayCheckValueOk;
        frsData = (PCHAR)_FrsData;
        pNode = Link->GetSortedFirst();
        size = Link->QueryMemberCount();
        if (size == 0) {
            DebugPrint("Size cannot be zero\n");
            return _read_status = FALSE;
        }
        drive = _mftdata->GetDrive();
        for (i=0; r && i<size;) {

            pNode = Link->QueryDisjointRangeAndAssignBuffer(&start,
                                                            &length,
                                                            &effective_length,
                                                            frsData,
                                                            QuerySize(),
                                                            pNode);

            i += length;
            bytesToRead = QuerySize() * effective_length;
            r = _mftdata->Read(frsData,
                               start*QuerySize(),
                               bytesToRead,
                               &bytes) &&
                bytes == bytesToRead;
            frsdata = frsData;
            for (j=0; r && j<effective_length; j++) {
                r = NTFS_SA::PostReadMultiSectorFixup(frsdata,
                                                      QuerySize(),
                                                      drive,
                                                      ((PFILE_RECORD_SEGMENT_HEADER)frsdata)->FirstFreeByte);
                frsdata += QuerySize();
            }
            frsData += bytesToRead;
        }
        return _read_status = r;

    } else {
        return _read_status = FALSE;
    }
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Write(
    )
/*++

Routine Description:

    This routine writes the FRS to disk.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   bytes;
    BOOLEAN r;

    DebugAssert(_mftdata || _secrun);

    NTFS_SA::PreWriteMultiSectorFixup(_FrsData, QuerySize());

    if (_mftdata) {

        r = _mftdata->Write(_FrsData,
                            _file_number*QuerySize(),
                            QuerySize(),
                            &bytes,
                            NULL) &&
            bytes == QuerySize();

    } else {
        r = _secrun->Write();
    }

    NTFS_SA::PostReadMultiSectorFixup(_FrsData, QuerySize(), NULL);

    return r;
}


UNTFS_EXPORT
PVOID
NTFS_FRS_STRUCTURE::GetNextAttributeRecord(
    IN      PCVOID      AttributeRecord,
    IN OUT  PMESSAGE    Message,
    OUT     PBOOLEAN    ErrorsFound
    )
/*++

Routine Description:

    This routine gets the next attribute record in the file record
    segment assuming that 'AttributeRecord' points to a valid
    attribute record.  If NULL is given as the first argument then
    the first attribute record is returned.

Arguments:

    AttributeRecord - Supplies a pointer to the current attribute record.
    Message         - Supplies an outlet for error processing.
    ErrorsFound     - Supplies whether or not errors were found and
                        corrected in the FRS.

Return Value:

    A pointer to the next attribute record or NULL if there are no more.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p;
    PCHAR                       q;
    PCHAR                       next_frs;
    ULONG                       bytes_free;
    BOOLEAN                     error;

    DebugAssert(_FrsData);

    if (ErrorsFound) {
        *ErrorsFound = FALSE;
    }

    next_frs = (PCHAR) _FrsData + QuerySize();

    if (!AttributeRecord) {

        // Make sure the FirstAttributeOffset field will give us a properly
        // aligned pointer.  If not, bail.
        //

        if (_FrsData->FirstAttributeOffset % 4 != 0) {

            return NULL;
        }

        AttributeRecord = (PCHAR) _FrsData + _FrsData->FirstAttributeOffset;

        p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;
        q = (PCHAR) AttributeRecord;

        if (q + QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE)) > next_frs) {

            // There is no way to correct this error.
            // The FRS is totally hosed, this will also be detected
            // by VerifyAndFix.  I can't really say *ErrorsFound = TRUE
            // because the error was not corrected.  I also cannot
            // update the firstfreebyte and bytesfree fields.

            return NULL;
        }

        if (p->TypeCode != $END) {

            error = FALSE;
            if (q + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(ULONG) > next_frs) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_OFFSET_TOO_LARGE,
                                 "%x%x%x%x%I64x",
                                 q - (PCHAR)_FrsData,
                                 QuerySize() - sizeof(ATTRIBUTE_TYPE_CODE) - sizeof(ULONG),
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (!p->RecordLength) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_CANNOT_BE_ZERO,
                                 "%x%x%I64x",
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (!IsQuadAligned(p->RecordLength)) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_MISALIGNED,
                                 "%x%x%x%I64x",
                                 p->RecordLength,
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (q + p->RecordLength + sizeof(ATTRIBUTE_TYPE_CODE) > next_frs) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_TOO_LARGE,
                                 "%x%x%x%x%I64x",
                                 p->RecordLength,
                                 next_frs - q - sizeof(ATTRIBUTE_TYPE_CODE),
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            }

            if (error) {

                p->TypeCode = $END;

                bytes_free = (ULONG)(next_frs - q) -
                                QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

                _FrsData->FirstFreeByte = QuerySize() - bytes_free;

                if (ErrorsFound) {
                    *ErrorsFound = TRUE;
                }

                if (Message) {
                    Message->DisplayMsg(MSG_CHK_NTFS_FRS_TRUNC_RECORDS,
                                     "%d", QueryFileNumber().GetLowPart());
                }

                return NULL;
            }
        }

    } else {

        // Assume that the attribute record passed in is good.

        p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;
        q = (PCHAR) AttributeRecord;

        q += p->RecordLength;
        p = (PATTRIBUTE_RECORD_HEADER) q;
    }


    if (p->TypeCode == $END) {

        // Update the bytes free and first free fields.

        bytes_free = (ULONG)(next_frs - q) - QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

        if (_FrsData->FirstFreeByte + bytes_free != QuerySize()) {

            if (Message) {
                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_FREE_BYTE,
                             "%x%x%x%I64x",
                             _FrsData->FirstFreeByte,
                             bytes_free,
                             QuerySize(),
                             QueryFileNumber().GetLargeInteger());
            }

            _FrsData->FirstFreeByte = QuerySize() - bytes_free;

            if (ErrorsFound) {
                *ErrorsFound = TRUE;
            }

            if (Message) {
                Message->DisplayMsg(MSG_CHK_NTFS_BAD_FIRST_FREE,
                                 "%d", QueryFileNumber().GetLowPart());
            }
        }

        return NULL;
    }


    // Make sure the attribute record is good.

    error = FALSE;
    if (q + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(ULONG) > next_frs) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_OFFSET_TOO_LARGE,
                         "%x%x%x%x%I64x",
                         q - (PCHAR)_FrsData,
                         QuerySize() - sizeof(ATTRIBUTE_TYPE_CODE) - sizeof(ULONG),
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (!p->RecordLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_CANNOT_BE_ZERO,
                         "%x%x%I64x",
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (!IsQuadAligned(p->RecordLength)) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_MISALIGNED,
                         "%x%x%x%I64x",
                         p->RecordLength,
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (q + p->RecordLength + QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE)) > next_frs) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_TOO_LARGE,
                         "%x%x%x%x%x%I64x",
                         q - (PCHAR)_FrsData,
                         p->RecordLength,
                         QuerySize(),
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    }

    if (error) {

        p->TypeCode = $END;

        bytes_free = (ULONG)(next_frs - q) - QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

        _FrsData->FirstFreeByte = QuerySize() - bytes_free;

        if (ErrorsFound) {
            *ErrorsFound = TRUE;
        }

        if (Message) {
            Message->DisplayMsg(MSG_CHK_NTFS_FRS_TRUNC_RECORDS,
                             "%d", QueryFileNumber().GetLowPart());
        }

        return NULL;
    }

    return p;
}


VOID
NTFS_FRS_STRUCTURE::DeleteAttributeRecord(
    IN OUT  PVOID   AttributeRecord
    )
/*++

Routine Description:

    This routine removes the pointed to attribute record from the
    file record segment.  The pointer passed in will point to
    the next attribute record

Arguments:

    AttributeRecord - Supplies a valid pointer to an attribute record.

Return Value:

    None.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p;
    PCHAR                       end;
    PCHAR                       frs_end;

    DebugAssert(AttributeRecord);

    p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;

    DebugAssert(p->TypeCode != $END);

    end = ((PCHAR) p) + p->RecordLength;
    frs_end = ((PCHAR) _FrsData) + QuerySize();

    DebugAssert(end < frs_end);

    memmove(p, end, (unsigned int)(frs_end - end));

    // This loop is here to straighten out the attribute records.
    p = NULL;
    while (p = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(p)) {
    }
}


BOOLEAN
NTFS_FRS_STRUCTURE::InsertAttributeRecord(
    IN OUT  PVOID   Position,
    IN      PCVOID  AttributeRecord
    )
/*++

Routine Description:

    This routine inserts the attribute record pointed to by
    'AttributeRecord' before the attribute record pointed to
    by Position.  When this routine is done, 'Position' will
    point to the copy of the attribute record just inserted
    inside this file record segment.

Arguments:

    Position        - Supplies a pointer to the attribute record that
                        will follow the attribute record to insert.
    AttributeRecord - Supplies the attribute record to insert.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pos, attr;
    PCHAR                       dest, frs_end;

    DebugAssert(Position);
    DebugAssert(AttributeRecord);

    pos = (PATTRIBUTE_RECORD_HEADER) Position;
    attr = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;

    if (attr->RecordLength > QueryAvailableSpace()) {
        return FALSE;
    }

    dest = (PCHAR) pos + attr->RecordLength;
    frs_end = (PCHAR) _FrsData + QuerySize();

    memmove(dest, pos, (unsigned int)(frs_end - dest));

    memcpy(pos, attr, (UINT) attr->RecordLength);

    // This loop is here to straighten out the attribute records.
    pos = NULL;
    while (pos = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pos)) {
    }

    return TRUE;
}


BOOLEAN
NTFS_FRS_STRUCTURE::QueryAttributeList(
    OUT PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This method fetches the Attribute List Attribute from this
    File Record Segment.

Arguments:

    AttributeList   - Returns A pointer to the Attribute List Attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    prec;
    NTFS_ATTRIBUTE_RECORD       record;

    return (prec = (PATTRIBUTE_RECORD_HEADER) GetAttributeList()) &&
           record.Initialize(GetDrive(), prec) &&
           AttributeList->Initialize(GetDrive(), QueryClusterFactor(),
                                     &record,
                                     GetUpcaseTable());
}


NONVIRTUAL
PVOID
NTFS_FRS_STRUCTURE::GetAttribute(
    IN  ULONG   TypeCode
    )
/*++

Routine Description:

    This routine returns a pointer to the unnamed attribute with the
    given type code or NULL if this attribute does not exist.

Arguments:

    TypeCode    - Supplies the type code of the attribute to search for.

Return Value:

    A pointer to an attribute or NULL if there none was found.

--*/
{
    PATTRIBUTE_RECORD_HEADER    prec;

    prec = NULL;
    while (prec = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(prec)) {

        if (prec->TypeCode == TypeCode &&
            prec->NameLength == 0) {
            break;
        }
    }

    return prec;
}


NONVIRTUAL
PVOID
NTFS_FRS_STRUCTURE::GetAttributeList(
    )
/*++

Routine Description:

    This routine returns a pointer to the attribute list or NULL if
    there is no attribute list.

Arguments:

    None.

Return Value:

    A pointer to the attribute list or NULL if there is no attribute list.

--*/
{
    return GetAttribute($ATTRIBUTE_LIST);
}


BOOLEAN
NTFS_FRS_STRUCTURE::UpdateAttributeList(
    IN  PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN  BOOLEAN                 WriteFrs
    )
/*++

Routine Description:

    This routine updates the local $ATTRIBUTE_LIST with the
    attribute list provided.  'AttributeList' must be smaller
    than or equal (and of the form) to the the local
    $ATTRIBUTE_LIST in order for this method to be guaranteed
    to succeed.

Arguments:

    AttributeList   - Supplies a valid attribute list.
    WriteFrs        - State whether or not to write the FRS when done.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE_RECORD       attribute;
    PATTRIBUTE_RECORD_HEADER    old_attr, new_attr;

    DebugAssert(AttributeList);


    // Don't do anything if the attribute list hasn't changed.

    if (!AttributeList->IsStorageModified()) {
        return TRUE;
    }


    // Allocate some storage for the new attribute record.

    if (!(new_attr = (PATTRIBUTE_RECORD_HEADER) MALLOC((UINT) QuerySize()))) {
        return FALSE;
    }


    // Get the new attribute record.

    if (!AttributeList->QueryAttributeRecord(new_attr,
                                             QuerySize(),
                                             &attribute)) {

        FREE(new_attr);
        return FALSE;
    }


    // Locate the old attribute record.

    old_attr = (PATTRIBUTE_RECORD_HEADER) GetAttributeList();

    if (!old_attr) {
        FREE(new_attr);
        return FALSE;
    }


    // Make sure that there is enough room for new attribute record.

    if (QueryAvailableSpace() + old_attr->RecordLength <
                                new_attr->RecordLength) {

        FREE(new_attr);
        return FALSE;
    }


    // Use the same old instance field that exists on the current
    // attribute list for the new attribute list.

    new_attr->Instance = old_attr->Instance;


    // Delete the old attribute record.

    DeleteAttributeRecord(old_attr);


    // Insert the new attribute record.

    if (!InsertAttributeRecord(old_attr, new_attr)) {
        DebugAbort("Could not insert attribute list");
        FREE(new_attr);
        return FALSE;
    }


    // If required, write the changes to disk.

    if (WriteFrs && !Write()) {

        DebugAbort("Readable FRS is unwritable");
        return FALSE;
    }


    FREE(new_attr);

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::SafeQueryAttribute(
    IN      ATTRIBUTE_TYPE_CODE TypeCode,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    OUT     PNTFS_ATTRIBUTE     Attribute
    )
/*++

Routine Description:

    This routine does a 'safe' query attribute operation.  This
    primarily needed by 'chkdsk' at times when it absolutely needs
    to retrieve a certain attribute but it cannot depend on the disk
    structures being good.

    This routine queries unnamed attributes only.

Arguments:

    TypeCode            - Supplies the type code of the attribute to retrieve.
    MftData             - Supplies the MFT $DATA attribute.
    Attribute           - Returns the attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   record;
    NTFS_ATTRIBUTE_RECORD   attr_record;
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    VCN                     next_lowest_vcn;
    NTFS_ATTRIBUTE_LIST     attrlist;
    ATTRIBUTE_TYPE_CODE     type_code;
    MFT_SEGMENT_REFERENCE   seg_ref;
    VCN                     lowest_vcn;
    DSTRING                 name;
    DSTRING                 record_name;
    VCN                     file_number;
    PNTFS_FRS_STRUCTURE     pfrs;
    BOOLEAN                 rvalue;
    ATTR_LIST_CURR_ENTRY    entry;
    USHORT                  instance;
    PNTFS_EXTENT_LIST       backup_extent_list = NULL;


    // First validate the attribute records linking in this FRS;

    record = NULL;
    while (record = GetNextAttributeRecord(record)) {
    }


    if (!QueryAttributeList(&attrlist)) {

        // There's no attribute list so just go through it and pluck
        // out the record.

        record = NULL;
        while (record = GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DebugAbort("Counldn't initialize attribute record");
                return FALSE;
            }

            if (attr_record.QueryTypeCode() == TypeCode &&
                attr_record.QueryLowestVcn() == 0 &&
                attr_record.Verify(NULL, TRUE) &&
                attr_record.QueryName(&name) &&
                !name.QueryChCount()) {

                break;
            }
        }

        if (!record) {
            return FALSE;
        }

        return Attribute->Initialize(GetDrive(), QueryClusterFactor(),
                                     &attr_record) &&
               Attribute->VerifyAndFix(QueryVolumeSectors());
    }


    // give out if the attribute list is unreadable.

    if (!attrlist.ReadList()) {
        return FALSE;
    }


    // Since, there's an attribute list, perform the analysis based
    // on it.

    // The first attribute record to pick up will have lowest_vcn of 0.
    next_lowest_vcn = 0;

    rvalue = FALSE;

    entry.CurrentEntry = NULL;
    while (attrlist.QueryNextEntry(&entry,
                                   &type_code,
                                   &lowest_vcn,
                                   &seg_ref,
                                   &instance,
                                   &name)) {

        if (type_code != TypeCode ||
            lowest_vcn != next_lowest_vcn ||
            name.QueryChCount()) {
            continue;
        }

        file_number.Set(seg_ref.LowPart, (LONG) seg_ref.HighPart);

        pfrs = NULL;

        if (file_number == QueryFileNumber()) {

            if (!(seg_ref == QuerySegmentReference())) {
                continue;
            }

            pfrs = this;

        } else {

            // If we're boot strapping the MFT then make sure that
            // the first one is in the base FRS.

            if (lowest_vcn == 0 && MftData == Attribute) {
                DELETE(backup_extent_list);
                return FALSE;
            }

            if (!hmem.Initialize() ||
                !frs.Initialize(&hmem, MftData, file_number,
                                QueryClusterFactor(), QueryVolumeSectors(),
                                QuerySize(), GetUpcaseTable()) ||
                !frs.Read() ||
                !(frs.QuerySegmentReference() == seg_ref) ||
                !(frs.QueryBaseFileRecordSegment() == QuerySegmentReference())) {

                continue;
            }

            pfrs = &frs;
        }

        DebugAssert(pfrs);

        record = NULL;
        while (record = pfrs->GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DELETE(backup_extent_list);
                DebugAbort("Could not initialize attribute record");
                return FALSE;
            }


            if (attr_record.QueryTypeCode() == type_code &&
                attr_record.QueryLowestVcn() == lowest_vcn &&
                attr_record.Verify(NULL, TRUE) &&
                attr_record.QueryName(&record_name) &&
                !record_name.QueryChCount()) {

                break;
            }
        }

        if (!record) {
            continue;
        }

        if (lowest_vcn == 0) {

            rvalue = Attribute->Initialize(GetDrive(),
                                           QueryClusterFactor(),
                                           &attr_record);

            if (!rvalue) {
                continue;
            }

        } else {

            if (!Attribute->AddAttributeRecord(&attr_record, &backup_extent_list)) {
                DELETE(backup_extent_list);
                continue;
            }
        }

        next_lowest_vcn = attr_record.QueryNextVcn();
        entry.CurrentEntry = NULL;
    }

    DELETE(backup_extent_list);
    return rvalue ? Attribute->VerifyAndFix(QueryVolumeSectors()) : FALSE;
}


ULONG
NTFS_FRS_STRUCTURE::QueryAvailableSpace(
    )
/*++

Routine Description:

    This routine returns the number of bytes available for
    attribute records.

Arguments:

    None.

Return Value:

    The number of bytes currently available for attribute records.

--*/
{
    PVOID   p;

    // Spin through in order to guarantee a valid field.

    p = NULL;
    while (p = GetNextAttributeRecord(p)) {
    }

    return QuerySize() - _FrsData->FirstFreeByte;
}


BOOLEAN
SwapAttributeRecords(
    IN OUT  PVOID   FirstAttributeRecord
    )
/*++

Routine Description:

    This routine swaps 'FirstAttributeRecord' with the next attribute
    record in the list.  This method will fail if there is not
    enough memory available for a swap buffer.

Arguments:

    FirstAttributeRecord    - Supplies the first of two attribute records
                                to be swapped.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p1, p2;
    PCHAR                       q1, q2;
    PVOID                       buf;
    UINT                        first_record_length;

    p1 = (PATTRIBUTE_RECORD_HEADER) FirstAttributeRecord;
    q1 = (PCHAR) p1;

    DebugAssert(p1->TypeCode != $END);

    first_record_length = (UINT) p1->RecordLength;

    if (!(buf = MALLOC(first_record_length))) {
        return FALSE;
    }

    // Tuck away the first record.

    memcpy(buf, p1, first_record_length);


    q2 = q1 + p1->RecordLength;
    p2 = (PATTRIBUTE_RECORD_HEADER) q2;

    DebugAssert(p2->TypeCode != $END);


    // Overwrite first attribute record with second attribute record.

    memmove(p1, p2, (UINT) p2->RecordLength);


    // Copy over the first attribute record after the second.

    memcpy(q1 + p1->RecordLength, buf, first_record_length);

    FREE(buf);

    return TRUE;
}


INT
CompareResidentAttributeValues(
    IN  PCNTFS_ATTRIBUTE_RECORD Left,
    IN  PCNTFS_ATTRIBUTE_RECORD Right
    )
/*++

Routine Description:

    This routine compares the attribute values of two resident attributes
    and returns -1 is Left < Right, 0 if Left == Right, or 1 if Left > Right.

Arguments:

    Left    - Supplies the left hand side of the comparison.
    Right   - Supplies the right hand side of the comparison.

Return Value:

    < 0 - Left < Right
    0   - Left == Right
    > 0 - Left > Right

--*/
{
    BIG_INT left_length, right_length;
    INT     r;

    Left->QueryValueLength(&left_length);
    Right->QueryValueLength(&right_length);

    r = memcmp(Left->GetResidentValue(), Right->GetResidentValue(),
               min(left_length.GetLowPart(), right_length.GetLowPart()));

    if (r != 0) {
        return r;
    }

    if (left_length == right_length) {
        r = 0;
    } else if (left_length < right_length) {
        r = -1;
    } else {
        r = 1;
    }

    return r;
}


BOOLEAN
NTFS_FRS_STRUCTURE::Sort(
    OUT PBOOLEAN    Changes,
    OUT PBOOLEAN    Duplicates
    )
/*++

Routine Description:

    This routine bubble sorts the attributes by type, name, and (if
    the attribute is indexed) value.

Arguments:

    Changes     - Returns whether or not there were any changes made.
    Duplicates  - Returns whether or not there were any duplicates
                    eliminated.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   prev;
    PVOID                   p;
    NTFS_ATTRIBUTE_RECORD   attr1;
    NTFS_ATTRIBUTE_RECORD   attr2;
    PNTFS_ATTRIBUTE_RECORD  prev_attr;
    PNTFS_ATTRIBUTE_RECORD  attr;
    PNTFS_ATTRIBUTE_RECORD  tmp_attr;
    BOOLEAN                 stable;
    INT                     r;
    LONG                    CompareResult;

    DebugAssert(Changes);

    *Changes = FALSE;
    *Duplicates = FALSE;

    prev_attr = &attr1;
    attr = &attr2;

    stable = FALSE;

    while (!stable) {

        stable = TRUE;

        if (!(prev = GetNextAttributeRecord(NULL))) {
            return TRUE;
        }

        if (!prev_attr->Initialize(GetDrive(), prev)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        while (p = GetNextAttributeRecord(prev)) {

            if (!attr->Initialize(GetDrive(), p)) {
                DebugAbort("Could not initialize attribute record.");
                return FALSE;
            }

            CompareResult = CompareAttributeRecords( prev_attr,
                                          attr,
                                          GetUpcaseTable() );

            if ( CompareResult > 0 ) {

                // Out of order.  Swap.

                PIO_DP_DRIVE        drive = GetDrive();

                if (drive) {
                    PMESSAGE msg = drive->GetMessage();
                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_OUT_OF_ORDER,
                                 "%x%x%x%x%I64x",
                                 prev_attr->QueryTypeCode(),
                                 prev_attr->QueryInstanceTag(),
                                 attr->QueryTypeCode(),
                                 attr->QueryInstanceTag(),
                                 QueryFileNumber().GetLargeInteger());
                    }
                }

                if (!SwapAttributeRecords(prev)) {
                    return FALSE;
                }

                *Changes = TRUE;
                stable = FALSE;
                break;
            }

            if ( CompareResult == 0 ) {

                // These two attribute records have the same type
                // code and name.  They better both be indexed and
                // have differing values.

                if (!attr->IsIndexed() ||
                    !prev_attr->IsIndexed()) {

                    // They're not both indexed so delete them.

                    PIO_DP_DRIVE        drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();
                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_RECORD_WITHOUT_INDEX,
                                     "%x%x%x%x%I64x",
                                     prev_attr->QueryTypeCode(),
                                     prev_attr->QueryInstanceTag(),
                                     attr->QueryTypeCode(),
                                     attr->QueryInstanceTag(),
                                     QueryFileNumber().GetLargeInteger());
                        }
                    }

                    DeleteAttributeRecord(p);
                    DeleteAttributeRecord(prev);

                    *Duplicates = TRUE;
                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                // They're both indexed so do a comparison.

                r = CompareResidentAttributeValues(prev_attr, attr);

                if (r == 0) {

                    // The attribute records are equal so
                    // delete them both.

                    PIO_DP_DRIVE        drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();
                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_VALUE,
                                     "%x%x%I64x",
                                     prev_attr->QueryTypeCode(),
                                     prev_attr->QueryInstanceTag(),
                                     QueryFileNumber().GetLargeInteger());
                        }
                    }

                    DeleteAttributeRecord(p);
                    DeleteAttributeRecord(prev);

                    *Duplicates = TRUE;
                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                if (r > 0) {

                    // Out of order.  Swap.

                    if (!SwapAttributeRecords(prev)) {
                        return FALSE;
                    }

                    // We don't set the 'Changes' flag here because
                    // indexed attributes don't have to be ordered by
                    // value.

                    stable = FALSE;
                    break;
                }
            }

            tmp_attr = prev_attr;
            prev_attr = attr;
            attr = tmp_attr;

            prev = p;
        }
    }

    return TRUE;
}

NONVIRTUAL
VOID
NTFS_FRS_STRUCTURE::SetFrsData(
    IN  VCN                         FileNumber,
    IN  PFILE_RECORD_SEGMENT_HEADER frsdata
    )
{
    _file_number = FileNumber;
    _FrsData = frsdata;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\hackwc.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

    hackwc.cxx

Abstract:

    This module contains the definition for a hack that allows me
    to compare attribute names correctly.

    The comparison of attribute names is binary (word by word);
    I can't use WSTRING because it's comparisons are all based
    on the locale, while this comparison is locale-independent.

Author:

	Bill McJohn (billmc) 14-Aug-91

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "hackwc.hxx"

INT
CountedWCMemCmp(
    IN PCWSTR String1,
    IN ULONG Length1,
    IN PCWSTR String2,
    IN ULONG Length2
    )
/*++

Routine Description:

    This function compares two counted wide-character buffers.
    It compares word-by-word, rather than byte by byte.

Arguments:

    String1 -- supplies the first wide-character buffer
    Length1 -- supplies the number of wide characters in String1
    String2 -- supplies the second wide-character buffer
    Length2 -- supplies the number of wide characters in String2

Return Value:

    a negative value if String1 is less than String2
    zero if String1 equals String2
    a positive value if String1 is greater than String2

--*/
{
    ULONG i;
    LONG res;

    i = ( Length1 < Length2 ) ? Length1 : Length2;

    while( i-- ) {

        if( (res = *String1++ - *String2++) != 0 ) {

            return res;
        }
    }

    return Length1 - Length2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\indxbuff.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    indxbuff.hxx

Abstract:

    This module contains the member function definitions for
    NTFS_INDEX_BUFFER, which models index buffers in an Index
    Allocation attribute.

    These buffers are the component blocks of a b-tree, which
    is rooted in the matching Index Root attribute.

Author:

    Bill McJohn (billmc) 04-Sept-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfssa.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "indxbuff.hxx"

DEFINE_CONSTRUCTOR( NTFS_INDEX_BUFFER, OBJECT );

NTFS_INDEX_BUFFER::~NTFS_INDEX_BUFFER(
    )
{
    Destroy();
}


VOID
NTFS_INDEX_BUFFER::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _ClusterSize = 0;
    _ThisBufferVcn = 0;
    _CollationRule = COLLATION_NUMBER_RULES;
    _UpcaseTable = NULL;
}


VOID
NTFS_INDEX_BUFFER::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ClustersPerBuffer = 0;
    _ThisBufferVcn = 0;
    _ClusterSize = 0;
    _BufferSize = 0;
    _CollationRule = COLLATION_NUMBER_RULES;
    _UpcaseTable = NULL;
}


BOOLEAN
NTFS_INDEX_BUFFER::Initialize(
    IN PCLOG_IO_DP_DRIVE    Drive,
    IN VCN                  ThisBufferVcn,
    IN ULONG                ClusterSize,
    IN ULONG                ClustersPerBuffer,
    IN ULONG                BufferSize,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_BUFFER.  Note that this class
    is reinitializable.

Arguments:

    Drive               --  supplies the drive on which the index resides.
    ThisBufferVcn       --  supplies the this buffer's VCN within the
                            index allocation attribute for the containing
                            index.
    ClusterSize         --  supplies the size of a cluster on this volume.
    ClustersPerBuffer   --  supplies the number of clusters per index
                            allocation buffer in this index b-tree.
    BufferSize          --  size of the buffer in bytes.
    CollationRule       --  supplies the collation rule for this index.
    UpcaseTable         --  supplies the volume upcase table.

Either the ClustersPerBuffer or the BufferSize may be zero, but not
both.  If BufferSize is zero, then we're doing an old-style buffer where
each buffer is at least one cluster.  If ClustersPerBuffer is zero, then
we're doing a new-style buffer where the buffer size may be a fraction of
the cluster size.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugPtrAssert( Drive );
    DebugAssert( ClusterSize != 0 );
    DebugAssert( BufferSize != 0 || ClustersPerBuffer != 0 );

    Destroy();

    _ClusterSize = ClusterSize;
    _ClustersPerBuffer = ClustersPerBuffer;
    _BufferSize = BufferSize;
    _ThisBufferVcn = ThisBufferVcn;
    _CollationRule = CollationRule;
    _UpcaseTable = UpcaseTable;

    if( !_Mem.Initialize() ||
        (_Data = (PINDEX_ALLOCATION_BUFFER)
                 _Mem.Acquire( BufferSize,
                               Drive->QueryAlignmentMask() )) == NULL ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
NTFS_INDEX_BUFFER::Create(
    IN BOOLEAN  IsLeaf,
    IN VCN      EndEntryDownpointer
    )
/*++

Arguments:

    IsLeaf  --              supplies a flag indicating whether this is a
                            leaf block (TRUE) or a node block (FALSE).
    EndEntryDownpointer --  supplies the B-Tree downpointer for the end
                            entry.  (This parameter is ignored if IsLeaf
                            is TRUE.)

Return Value:

    None.

--*/
{
    PINDEX_ENTRY EndEntry;

    DebugPtrAssert( _Data );

    // The layout of an index buffer is:
    //  Index Allocation Buffer Header
    //  Update Sequence Array
    //  First Entry.

    memset( _Data, 0, QuerySize() );

    // Write the 'FILE' signature in the MultiSectorHeader.

    memcpy( _Data->MultiSectorHeader.Signature,
            "INDX",
            4 );

    // Compute the number of Update Sequence Numbers in the
    // update array.  This number is (see ntos\inc\cache.h):
    //
    //      n/SEQUENCE_NUMBER_STRIDE + 1
    //
    // where n is the number of bytes in the protected structure
    // (in this case, an index allocation buffer ).

    _Data->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)(QuerySize()/SEQUENCE_NUMBER_STRIDE + 1);

    _Data->MultiSectorHeader.UpdateSequenceArrayOffset =
        (USHORT)((PBYTE)&(_Data->UpdateSequenceArray) - (PBYTE)_Data);

    _Data->Lsn.LowPart = 0;
    _Data->Lsn.HighPart = 0;

    _Data->ThisVcn = _ThisBufferVcn;
    _Data->IndexHeader.Flags = IsLeaf ? 0 : INDEX_NODE;


    _Data->IndexHeader.FirstIndexEntry =
        QuadAlign( _Data->MultiSectorHeader.UpdateSequenceArrayOffset +
                   _Data->MultiSectorHeader.UpdateSequenceArraySize *
                       sizeof(UPDATE_SEQUENCE_NUMBER));

    // the first entry is the end entry.  The only fields in it that
    // matter are the length, the flags, and the downpointer (if any).

    EndEntry = (PINDEX_ENTRY)((PBYTE)&(_Data->IndexHeader) +
                                 _Data->IndexHeader.FirstIndexEntry);


    EndEntry->Length = NtfsIndexLeafEndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    if( !IsLeaf ) {

        EndEntry->Flags |= INDEX_ENTRY_NODE;
        EndEntry->Length += sizeof(VCN);
        GetDownpointer(EndEntry) = EndEntryDownpointer;
    }


    _Data->IndexHeader.FirstFreeByte =
            _Data->IndexHeader.FirstIndexEntry + EndEntry->Length;

    _Data->IndexHeader.BytesAvailable =
        QuerySize() - (ULONG)( (PBYTE)&(_Data->IndexHeader) - (PBYTE)_Data );

}



BOOLEAN
NTFS_INDEX_BUFFER::Read(
    IN OUT PNTFS_ATTRIBUTE AllocationAttribute
    )
/*++

Routine Description:

    This method reads the index allocation buffer.

Arguments:

    AllocationAttribute --  supplies the Index Allocation Attribute
                            that describes the allocation for this
                            b-tree.

Return Value:

    TRUE upon successful completion

--*/
{
    ULONG           BytesRead;
    BOOLEAN         Result;
    PINDEX_ENTRY    CurrentEntry;
    ULONG           RemainingSpace, FirstEntryOffset;
    BIG_INT         AttributeOffset;
    PMESSAGE        msg;
    PIO_DP_DRIVE    drive;

    DebugPtrAssert( AllocationAttribute );

    drive = AllocationAttribute->GetDrive();
    DebugAssert(drive);
    msg = drive ? drive->GetMessage() : NULL;

    if (_BufferSize < _ClusterSize) {
        AttributeOffset = NTFS_INDEX_BLOCK_SIZE * QueryVcn();
    } else {
        AttributeOffset = _ClusterSize * QueryVcn();
    }

    Result = AllocationAttribute->Read( _Data,
                                        AttributeOffset,
                                        QuerySize(),
                                        &BytesRead ) &&
             BytesRead == QuerySize() &&
             NTFS_SA::PostReadMultiSectorFixup( _Data,
                                                BytesRead,
                                                drive,
                                                _Data->IndexHeader.FirstFreeByte );

    // if the read succeeded, sanity-check the buffer.
    //
    if( Result ) {

        CurrentEntry = GetFirstEntry();
        FirstEntryOffset = (ULONG)((PBYTE)CurrentEntry - (PBYTE)_Data);

        if( FirstEntryOffset > QuerySize() ) {

            // The first entry pointer is completely wrong.
            //
            Result = FALSE;

        } else {

            RemainingSpace = QuerySize() - FirstEntryOffset;

            while( TRUE ) {

                if( NTFS_INDEX_TREE::IsIndexEntryCorrupt( CurrentEntry,
                                                          RemainingSpace,
                                                          msg ) ) {

                    Result = FALSE;
                    break;
                }

                if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

                    break;
                }

                RemainingSpace -= CurrentEntry->Length;
                CurrentEntry = GetNextEntry( CurrentEntry );
            }
        }
    }

    return Result;
}


BOOLEAN
NTFS_INDEX_BUFFER::Write(
    IN OUT PNTFS_ATTRIBUTE AllocationAttribute
    )
/*++

Routine Description:

    This method writes the index allocation buffer.

Arguments:

    AllocationAttribute --  supplies the Index Allocation Attribute
                            that describes the allocation for this
                            b-tree.

Return Value:

    TRUE upon successful completion

--*/
{
    ULONG BytesWritten;
    BIG_INT Offset;
    BOOLEAN r;

    DebugPtrAssert( AllocationAttribute );

    NTFS_SA::PreWriteMultiSectorFixup( _Data, QuerySize() );

    if (_ClusterSize <= QuerySize()) {
        Offset = _ClusterSize * QueryVcn();
    } else {
        Offset = NTFS_INDEX_BLOCK_SIZE * QueryVcn();
    }

    r = AllocationAttribute->Write( _Data,
                                    Offset,
                                    QuerySize(),
                                    &BytesWritten, NULL ) &&
        BytesWritten == QuerySize();

    NTFS_SA::PostReadMultiSectorFixup( _Data,
                                       QuerySize(),
                                       NULL );

    return r;
}



BOOLEAN
NTFS_INDEX_BUFFER::FindEntry(
    IN      PCINDEX_ENTRY       SearchEntry,
    IN OUT  PULONG              Ordinal,
    OUT     PINDEX_ENTRY*       EntryFound
    )
/*++

Routine Description:

    This method locates an entry in the index buffer.  Note that it
    does not recurse into the buffer's children (if any).  If no matching
    entry is found, it returns the first entry which is greater than
    the desired entry; if the search key is greater than all the entries
    in the buffer, it returns the END entry.

Arguments:

    SearchEntry --  Supplies an entry with the search key and length.
                    (Note that this entry has a meaningless file reference).
    Ordinal     --  supplies an ordinal showing which matching entry
                    to return; see note below.
    EntryFound  --  receives a pointer to the located entry.  Receives
                    NULL if an error has occurred.

Return Value:

    TRUE if a matching entry is found.  If an error occurs, *EntryFound
    is set to NULL.  If no error occurs, and no matching entry is found,
    *EntryFound is set to the next entry (i.e. the point at which the
    search key would be inserted into this buffer).

Notes:

    This method assumes that the index buffer is consistent.

    The ordinal argument indicates how many matching entries should be
    passed over before one is returned.  When an entry is found which
    matches the search key, if *Ordinal is zero, that entry is returned;
    otherwise, *Ordinal is decremented, and the FindEntry goes on to
    the next entry.

    If *Ordinal is INDEX_SKIP, then all matching entries are skipped.

--*/
{
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN Found;
    int CompareResult;

    CurrentEntry = GetFirstEntry();
    Found = FALSE;

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CompareResult = CompareNtfsIndexEntries( SearchEntry,
                                                 CurrentEntry,
                                                 _CollationRule,
                                                 _UpcaseTable );

        if( CompareResult < 0 ) {

            // The search value is less than the current entry's
            // value, so we've overshot where our search key would
            // be.  Stop (and return the current entry).

            break;

        } else if( CompareResult == 0 ) {

            // The current entry matches the search entry.  Check
            // the ordinal argument to see if we should return this
            // entry or skip it.

            if( *Ordinal == 0 ) {

                Found = TRUE;
                break;

            } else if( *Ordinal != INDEX_SKIP ) {

                *Ordinal -= 1;
            }
        }

        // Haven't found our entry, so we'll just go on to the next.

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    *EntryFound = CurrentEntry;
    return( Found );
}


BOOLEAN
NTFS_INDEX_BUFFER::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  PINDEX_ENTRY    InsertPoint
    )
/*++

Routine Description:

    This method inserts an index entry into the buffer.

Arguments:

    NewEntry    --  Supplies the entry to insert.
    InsertPoint --  supplies the point in the buffer at which this entry
                    should be inserted, if known.  This parameter may be
                    NULL, in which case the buffer determines where to
                    insert the new entry.

Return Value:

    TRUE upon successful completion.  A return value of FALSE indicates
    that the entry will not fit in the buffer.

Notes:

    This method assumes that the buffer is consistent.

    InsertPoint should be a pointer previously returned from FindEntry;
    otherwise, this method will go badly astray.

--*/
{
    ULONG Ordinal, BytesToCopy;

    // First, check to see if there's enough room:

    if( _Data->IndexHeader.FirstFreeByte + NewEntry->Length >
        _Data->IndexHeader.BytesAvailable ) {

        return FALSE;
    }

    // We know there's enough space, so we know we'll succeed.

    if( InsertPoint == NULL ) {

        // The client has not supplied the insert point, so we get to
        // figure it out for ourselves.  Fortunately, we can get FindEntry
        // to do our work for us.

        // Note that we don't care what InsertEntry returns--we know it
        // won't hit an error, and we don't care whether there are any
        // matching entries in the buffer.  (If we get a matching buffer,
        // we insert the new one before it, which is just fine.)

        Ordinal = 0;

        FindEntry( NewEntry,
                   &Ordinal,
                   &InsertPoint );

        DebugPtrAssert( InsertPoint );
    }

    // Now we just make room for the entry and jam it in.

    BytesToCopy = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)((PBYTE)InsertPoint - (PBYTE)&(_Data->IndexHeader));

    memmove( (PBYTE)InsertPoint + NewEntry->Length,
             InsertPoint,
             BytesToCopy );

    _Data->IndexHeader.FirstFreeByte += NewEntry->Length;

    memcpy( InsertPoint, NewEntry, NewEntry->Length );

    return TRUE;
}


VOID
NTFS_INDEX_BUFFER::RemoveEntry(
    IN  PINDEX_ENTRY    EntryToRemove
    )
/*++

Routine Description:

    This method removes an entry from the index buffer, closing up
    the buffer over it.

Arguments:

    EntryToRemove   --  supplies a pointer to the entry to remove.

Return Value:

    None.  This method always succeeds.

Notes:

    This method assumes that the index buffer is consistent.

    EntryToRemove must be a pointer that was returned by a previous
    call (with no intervening inserts or deletes) to FindEntry or
    GetFirstEntry.

--*/
{
    PBYTE NextEntry;
    ULONG BytesToCopy;

    NextEntry = (PBYTE)EntryToRemove + EntryToRemove->Length;

    BytesToCopy = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)(NextEntry - (PBYTE)&(_Data->IndexHeader));

    _Data->IndexHeader.FirstFreeByte -= EntryToRemove->Length;

    memmove( EntryToRemove,
             NextEntry,
             BytesToCopy );

}



PINDEX_ENTRY
NTFS_INDEX_BUFFER::FindSplitPoint(
    )
/*++

Routine Description:

    This method finds a point at which the index allocation buffer
    would like to be split.

Arguments:

    None.

Return Value:

    A pointer to the entry which will be promoted in the split.

    Note that we can return any non-end entry, but we cannot return
    the end entry.

--*/
{
    PINDEX_ENTRY CurrentEntry, PreviousEntry, NextEntry;
    ULONG CurrentOffset;


    CurrentOffset = _Data->IndexHeader.FirstIndexEntry;
    CurrentEntry = GetFirstEntry();

    DebugAssert( !(CurrentEntry->Flags & INDEX_ENTRY_END) );

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) &&
           CurrentOffset < _Data->IndexHeader.FirstFreeByte/2 ) {

        PreviousEntry = CurrentEntry;
        CurrentOffset += CurrentEntry->Length;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // We need to make sure we don't pick the last entry in the buffer
    // to split before; the entry just after the split point gets promoted
    // to the parent buffer, which would leave us with an empty buffer.
    //

    if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

        // Oops!  Back up one.  [XXX.mjb: really need to back up *two*
        // in this case, because the last entry is just a marker to hold
        // the flag, it's not a true entry.]
        //

        CurrentEntry = PreviousEntry;

    } else {

        NextEntry = GetNextEntry( CurrentEntry );

        if( NextEntry->Flags & INDEX_ENTRY_END ) {

            CurrentEntry = PreviousEntry;
        }
    }

    return CurrentEntry;
}


VOID
NTFS_INDEX_BUFFER::InsertClump(
    IN ULONG    LengthOfClump,
    IN PCVOID   Clump
    )
/*++

Routine Description:

    This method inserts a clump of entries at the beginning of
    the buffer.  It is used to insert entries into a newly-created
    buffer.

Arguments:

    LengthOfClump   --  supplies the number of bytes to insert
    Clump           --  supplies the source from which the data
                        is to be copied.

Return Value:

    None.

Notes:

    This private method should be used with care; the client must
    ensure that the entries being inserted are valid, and that they
    will not cause the buffer to overflow.

--*/
{
    ULONG BytesToMove;
    PBYTE InsertPoint;

    DebugAssert( _Data->IndexHeader.FirstFreeByte + LengthOfClump <=
               _Data->IndexHeader.BytesAvailable );

    // We'll insert the new entries in front of the first entry in
    // the buffer, which means we have to shift all the existing
    // entries up to make room.

    InsertPoint = (PBYTE)GetFirstEntry();

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                    _Data->IndexHeader.FirstIndexEntry;

    memmove( InsertPoint + LengthOfClump,
             InsertPoint,
             BytesToMove );

    // Copy the new entries into the space we just created:

    memcpy( InsertPoint,
            Clump,
            LengthOfClump );

    // Adjust the offset of the First Free Byte to reflect
    // what we just did:

    _Data->IndexHeader.FirstFreeByte += LengthOfClump;

}


VOID
NTFS_INDEX_BUFFER::RemoveClump(
    IN ULONG    LengthOfClump
    )
/*++

Routine Description:

    This method removes a clump of entries from the beginning of
    the index buffer.  It's particularly useful when splitting
    a buffer.

Arguments:

    LengthOfClump   --  supplies the number of bytes to remove from
                        the index buffer.

Return Value:

    None.

Notes:

    This private method should be used with care; the client must
    ensure that the number of bytes to be removed covers a valid
    clump of entries, and does not include (or extend past) the
    END entry.

--*/
{
    ULONG BytesToMove;
    PBYTE FirstEntry;

    DebugAssert( LengthOfClump + _Data->IndexHeader.FirstIndexEntry
               < _Data->IndexHeader.FirstFreeByte );

    //  Compute the number of bytes in entries after the clump:

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (LengthOfClump + _Data->IndexHeader.FirstIndexEntry);

    //  Shift those entries down to the beginning of the index
    //  entries in this index buffer.

    FirstEntry = (PBYTE)GetFirstEntry();

    memmove( FirstEntry,
             FirstEntry + LengthOfClump,
             BytesToMove );

    // Adjust the offset of the First Free Byte to reflect
    // what we just did:

    _Data->IndexHeader.FirstFreeByte -= LengthOfClump;
}



BOOLEAN
NTFS_INDEX_BUFFER::IsEmpty(
    )
/*++

Routine Description:

    This method determines whether the buffer is empty.

Arguments:

    None.

Return Value:

    TRUE if the first entry is an END entry.

--*/
{
    PINDEX_ENTRY FirstEntry;

    FirstEntry = GetFirstEntry();

    return( FirstEntry->Flags & INDEX_ENTRY_END );
}


BOOLEAN
NTFS_INDEX_BUFFER::Copy(
    IN  PNTFS_INDEX_BUFFER  p,
    IN  PCLOG_IO_DP_DRIVE   Drive
    )
/*++

Routine Description:

    This method makes a copy of the given index buffer.

Arguments:

    p       - Supplies the index buffer to be copied
    Drive   - Supplies the drive on which the index buffer resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugPtrAssert(p);

    _ThisBufferVcn = p->_ThisBufferVcn;
    _ClusterSize = p->_ClusterSize;
    _ClustersPerBuffer = p->_ClustersPerBuffer;
    _BufferSize = p->_BufferSize;
    _CollationRule = p->_CollationRule;
    _UpcaseTable = p->_UpcaseTable;

    if( !_Mem.Initialize() ||
        (_Data = (PINDEX_ALLOCATION_BUFFER)
                 _Mem.Acquire( _BufferSize,
                               Drive->QueryAlignmentMask() )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memcpy(_Data, p->_Data, _BufferSize);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\frs.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

   frs.cxx

Abstract:

   This module contains the member function definitions for the
   NTFS_FILE_RECORD_SEGMENT class.  This class models File
   Record Segments in the NTFS Master File Table; it is the
   object through which a file's attributes may be accessed.



Author:

   Bill McJohn (billmc) 21-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "list.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "cannedsd.hxx"
#include "drive.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "frs.hxx"
#include "badfile.hxx"
#include "ntfsbit.hxx"
#include "indxtree.hxx"
#include "rtmsg.h"

#include "hackwc.hxx"
#include "sdchk.hxx"



DEFINE_EXPORTED_CONSTRUCTOR( NTFS_FILE_RECORD_SEGMENT, NTFS_FRS_STRUCTURE, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_FILE_RECORD_SEGMENT::~NTFS_FILE_RECORD_SEGMENT (
         )
{
    Destroy();
}

VOID
NTFS_FILE_RECORD_SEGMENT::Construct (
   )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT construction.

Arguments:

   None.

Return Value:

   None.

--*/
{
    _Mft = NULL;
    _AttributeList = NULL;
    _ChildIterator = NULL;
}


inline
VOID
NTFS_FILE_RECORD_SEGMENT::Destroy2 (
    )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT partial destruction.

Arguments:

   None.

Return Value:

   None.

--*/
{
    // If the child iterator is not NULL, then the
    // list of children has been initialized.

    if( _ChildIterator != NULL ) {

        DELETE( _ChildIterator );
        _Children.DeleteAllMembers();
    }

    DELETE(_AttributeList);
    _AttributeList = NULL;
}

VOID
NTFS_FILE_RECORD_SEGMENT::Destroy (
   )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT destruction.

Arguments:

   None.

Return Value:

   None.

--*/
{
   _Mft = NULL;

   Destroy2();
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                     FileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.

Arguments:

   FileNumber     -- Supplies the FRS's cluster number within the MFT.
    Mft             -- Supplies the volume MasterFile Table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
   Destroy();

   DebugAssert(Mft);

   _Mft = Mft;

    if( !Mft->GetDataAttribute()    ||
        !_Mem.Initialize()          ||
        !_Children.Initialize()     ||
        (_ChildIterator = _Children.QueryIterator()) == NULL ||
        !NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                        Mft->GetDataAttribute(),
                                        FileNumber,
                                        Mft->QueryClusterFactor(),
                                        Mft->QueryVolumeSectors(),
                                        Mft->QueryFrsSize(),
                                        Mft->GetUpcaseTable() ) ) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                     FirstFileNumber,
    IN      ULONG                   FrsCount,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.  This is meant to use together with
   Initialize(), ReadSet(), and ReadNext().

Arguments:

   FirstFileNumber - Supplies the first file number for this FRS block.
   FrsCount        - Supplies the number of FRS'es in this FRS block.
   Mft             - Supplies the volume MasterFile Table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
   Destroy();

   DebugAssert(Mft);

   _Mft = Mft;

   if( !Mft->GetDataAttribute()    ||
       !_Mem.Initialize()          ||
       !_Children.Initialize()     ||
       (_ChildIterator = _Children.QueryIterator()) == NULL ||
       !NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                       Mft->GetDataAttribute(),
                                       FirstFileNumber,
                                       FrsCount,
                                       Mft->QueryClusterFactor(),
                                       Mft->QueryVolumeSectors(),
                                       Mft->QueryFrsSize(),
                                       Mft->GetUpcaseTable() ) ) {
       Destroy();
       return FALSE;
   }

   return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
   )
/*++

Routine Description:

   Partially initialize a File Record Segment object.  Note that this
   will not cause the FRS to be read.  This is meant to use together
   with SetFrsData() or ReadFrsData().

Arguments:

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
    Destroy2();

    if (!_Children.Initialize() ||
        (_ChildIterator = _Children.QueryIterator()) == NULL) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                 FileNumber,
    IN OUT  PNTFS_MFT_FILE      MftFile
    )
/*++

Routine Description:

    This routine initializes this class to a valid initial state.

Arguments:

    FileNumber  - Supplies the file number for this FRS.
    MftFile     - Supplies the MFT file.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The upcase-table may be NULL; in this case, attributes with
    names cannot be manipulated until the upcase table is set.

--*/
{
    return Initialize(FileNumber,
                      MftFile->GetMasterFileTable());
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      LCN                     StartOfMft,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.

Arguments:

    Drive           - Supplies the drive object.
    StartOfMft      - Supplies the starting cluster for the MFT.
    Mft             - Supplies the master file table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
    Destroy();

    DebugAssert(Mft);

    _Mft = Mft;
    _AttributeList = NULL;

    return _Children.Initialize() &&
           (_ChildIterator = _Children.QueryIterator()) != NULL &&
           _Mem.Initialize() &&
           NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                          Drive,
                                          StartOfMft,
                                          Mft->QueryClusterFactor(),
                                          Mft->QueryVolumeSectors(),
                                          Mft->QueryFrsSize(),
                                          Mft->GetUpcaseTable());
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN USHORT   Flags
   )
/*++

Routine Description:

   Create   (i.e. Format) a file record segment.  This is a private
   worker method which is called by the other Create methods.  It
   creates a File Record Segment which has no attribute records.

Arguments:

    Flags   --  Supplies the FILE_xxx flags which should be set in this
                File Record Set.  (Note that FILE_RECORD_SEGMENT_IN_USE
                will also be set, whether or not is is specified.)

Return value:

   TRUE upon successful completion.

--*/
{
    PATTRIBUTE_TYPE_CODE FirstAttribute;

    DebugPtrAssert( _FrsData );

    memset( _FrsData, 0, (UINT) QuerySize() );

    _FrsData->Lsn.LowPart = 0;
    _FrsData->Lsn.HighPart = 0;

    _FrsData->SequenceNumber = (USHORT) max(QueryFileNumber().GetLowPart(),1);
    _FrsData->ReferenceCount = 0;
    _FrsData->Flags = FILE_RECORD_SEGMENT_IN_USE | Flags;
    _FrsData->BytesAvailable = QuerySize();
    _FrsData->NextAttributeInstance = 0;

    memset( &_FrsData->BaseFileRecordSegment,
            0,
            sizeof(MFT_SEGMENT_REFERENCE) );


    // Write the 'FILE' signature in the MultiSectorHeader.

    memcpy( _FrsData->MultiSectorHeader.Signature,
            "FILE",
            4 );


    // Compute the number of Update Sequence Numbers in the
    // update array.  This number is (see ntos\inc\cache.h):
    //
    //      n/SEQUENCE_NUMBER_STRIDE + 1
    //
    // where n is the number of bytes in the protected structure
    // (in this case, a cluster).

    _FrsData->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)(QuerySize()/SEQUENCE_NUMBER_STRIDE + 1);

    // The update sequence array starts at the field
    // UpdateArrayForCreateOnly.  (In other words, create locates
    // it using this field, all other methods locate it using
    // the offset that Create computes.)
    //
    _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset =
        FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER,
                      UpdateArrayForCreateOnly );

    _FrsData->FirstAttributeOffset =
      QuadAlign( _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
                   _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
                        sizeof( UPDATE_SEQUENCE_NUMBER ) );

    _FrsData->SegmentNumberHighPart = (USHORT)QueryFileNumber().GetHighPart();
    _FrsData->SegmentNumberLowPart = QueryFileNumber().GetLowPart();

    // Make sure that the offset of the first attribute is in range:
    //
    if( _FrsData->FirstAttributeOffset + sizeof(ULONG) > QuerySize() ) {

        return FALSE;
    }

    // Put an END attribute at the first-attribute offset.  (Note
    // that this attribute doesn't have an attribute header, it just
    // consists of an Attribute Type Code of $END.)
    //
    FirstAttribute = (PATTRIBUTE_TYPE_CODE)
                     ((PBYTE)_FrsData +
                      _FrsData->FirstAttributeOffset);

    *FirstAttribute = $END;

    // The first free byte comes after the END attribute, which
    // consists of a single ATTRIBUTE_TYPE_CODE.
    //
    _FrsData->FirstFreeByte = _FrsData->FirstAttributeOffset +
                                QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ) );

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN  PCSTANDARD_INFORMATION  StandardInformation,
    IN  USHORT                  Flags
   )
/*++

Routine Description:

   Create   (i.e. Format) a base file record segment.  The base
   file record segment is the primary FRS for a file; it contains
   any resident attributes (and hence any indexed attributes) of the
   file and the External Attributes List, if any.

   Note that Create will not cause the FRS to be written, only to
   be formatted in memory.

Arguments:

   StandardInformation --  supplies the standard information for the
                     file record segment.
    Flags               --  Supplies the FILE_xxx flags which should
                            be set in this File Record Set.  (Note
                            that FILE_RECORD_SEGMENT_IN_USE will also
                            be set, whether or not is is specified.)


Return value:

   TRUE upon successful completion.

--*/
{
   NTFS_ATTRIBUTE StandardInfoAttribute;

    DebugPtrAssert( _FrsData );

    if( Create( Flags ) &&
      StandardInfoAttribute.Initialize( GetDrive(),
                                          QueryClusterFactor(),
                                          StandardInformation,
                                sizeof( STANDARD_INFORMATION ),
                                $STANDARD_INFORMATION ) &&
        StandardInfoAttribute.InsertIntoFile( this, NULL ) ) {

        return TRUE;

   } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN PCMFT_SEGMENT_REFERENCE  BaseSegment,
    IN USHORT                   Flags
   )
/*++

Routine Description:

   Create (i.e. Format) a secondary file record segment.  A secondary
   file record segment contains external attributes; it is referenced
   in the file's External Attributes List, which is in the file's
   base file record segment.

Arguments:

    BaseSegment         --  supplies a reference to the base file
                     record segment for this file.
    Flags               --  Supplies the FILE_xxx flags which should
                            be set in this File Record Set.  (Note
                            that FILE_RECORD_SEGMENT_IN_USE will also
                            be set, whether or not is is specified.)

Return value:

   TRUE upon successful completion.

--*/
{
   DebugPtrAssert( _FrsData );

    if( Create( Flags ) ) {

        memcpy( &_FrsData->BaseFileRecordSegment,
                BaseSegment,
                sizeof(MFT_SEGMENT_REFERENCE) );

      return TRUE;

   } else {

      return FALSE;
   }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateSystemFile(
    IN UCHAR    major,
    IN UCHAR    minor
    )
/*++

Routine Description:

    This method creates a new base frs with a STANDARD_INFORMATION and
    a FILE_NAME attribute.  The standard info attribute will be
    set to the current time.

    This function looks up the correct file name base on this FRS's
    file number.

    This function will not succeed unless this FRS is a system file.

    This function does not update the root index or write to the frs.

Arguments:

    major   - the major revision number for the volume
    minor   - the minor revsion number for the volume

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    STANDARD_INFORMATION        standard_info;
    PFILE_NAME                  file_name;
    UCHAR                       name_length;
    ULONG                       buffer_length;
    NTFS_FILE_RECORD_SEGMENT    root_dir;
    DSTRING                     file_name_text;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    BOOLEAN                     no_file_name;
    MFT_SEGMENT_REFERENCE       root_ref;
    BOOLEAN                     this_is_root;


    // Figure out the correct file name for this.

    if (!GetSystemFileName(major,
                           QueryFileNumber(),
                           &file_name_text,
                           &no_file_name))
        return FALSE;

    this_is_root = (QueryFileNumber() == ROOT_FILE_NAME_INDEX_NUMBER);

    // Create a standard info structure.

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;

    standard_info.FileAttributes = FAT_DIRENT_ATTR_HIDDEN |
                                   FAT_DIRENT_ATTR_SYSTEM;

    if (!Create(&standard_info)) {
        return FALSE;
    }

    if (!no_file_name) {

        // Figure out the segment reference for the root index.

        if (this_is_root) {
            root_ref = QuerySegmentReference();
        } else {

            if (!root_dir.Initialize(ROOT_FILE_NAME_INDEX_NUMBER,
                                     _Mft) ||
                !root_dir.Read()) {

                return FALSE;
            }

            root_ref = root_dir.QuerySegmentReference();
        }


        // Allocate a buffer of sufficient length for the FILE_NAME struct.

        name_length = (UCHAR) file_name_text.QueryChCount();

        buffer_length = FIELD_OFFSET(FILE_NAME, FileName) +
                        name_length*sizeof(WCHAR);

        if (!(file_name = (PFILE_NAME) MALLOC(buffer_length))) {
            return FALSE;
        }
        memset(file_name, 0, buffer_length);


        // Initialize the FILE_NAME structure and add it to this FRS.

        file_name->ParentDirectory = root_ref;
        file_name->FileNameLength = name_length;
        file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text.QueryWSTR(0,
                                 TO_END,
                                 file_name->FileName,
                                 name_length,
                                 FALSE);

        if (!AddFileNameAttribute(file_name)) {

            FREE(file_name);
            return FALSE;
        }

        // Set the ref count back to zero because this guy doesn't yet
        // exist in the root directory.

        SetReferenceCount(0);

        FREE(file_name);
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateExtendSystemFile(
    PCWSTRING   file_name_text,
    IN USHORT   FrsFlags,
    IN ULONG    FileAttributes
    )
/*++

Routine Description:

    This method creates a new base frs with a STANDARD_INFORMATION and
    a FILE_NAME attribute.  The standard info attribute will be
    set to the current time.   The parent of this frs is \$Extend.

    This function does not update the root index or write to the frs.

Arguments:

    file_name_text
            --  Supplies the file name.
    Flags   --  Supplies the FILE_xxx flags which should be set in this
                File Record Set.  (Note that FILE_RECORD_SEGMENT_IN_USE
                will also be set, whether or not is is specified.)
    FileAttributes
            --  Supplies the FILE_xxx flags which should be set in the
                standard information of this file record segment.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    STANDARD_INFORMATION        standard_info;
    PFILE_NAME                  file_name;
    UCHAR                       name_length;
    ULONG                       buffer_length;
    NTFS_FILE_RECORD_SEGMENT    root_dir;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    BOOLEAN                     no_file_name;
    MFT_SEGMENT_REFERENCE       root_ref;

    // Check file name

    no_file_name = (!file_name_text || file_name_text->QueryChCount() == 0);

    // Create a standard info structure.

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;

    standard_info.FileAttributes = FAT_DIRENT_ATTR_HIDDEN |
                                   FAT_DIRENT_ATTR_SYSTEM |
                                   FAT_DIRENT_ATTR_ARCHIVE |
                                   FileAttributes;

    if (!Create(&standard_info, FrsFlags)) {
        return FALSE;
    }

    if (!no_file_name) {

        // Figure out the segment reference for the root index.

        if (!root_dir.Initialize(EXTEND_TABLE_NUMBER, _Mft) ||
            !root_dir.Read()) {

            return FALSE;
        }

        root_ref = root_dir.QuerySegmentReference();

        // Allocate a buffer of sufficient length for the FILE_NAME struct.

        name_length = (UCHAR) file_name_text->QueryChCount();

        buffer_length = FIELD_OFFSET(FILE_NAME, FileName) +
                        name_length*sizeof(WCHAR);

        if (!(file_name = (PFILE_NAME) MALLOC(buffer_length))) {
            return FALSE;
        }
        memset(file_name, 0, buffer_length);


        // Initialize the FILE_NAME structure and add it to this FRS.

        file_name->ParentDirectory = root_ref;
        file_name->FileNameLength = name_length;
        file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text->QueryWSTR(0,
                                  TO_END,
                                  file_name->FileName,
                                  name_length,
                                  FALSE);

        if (!AddFileNameAttribute(file_name)) {

            FREE(file_name);
            return FALSE;
        }

        // Set the ref count back to zero because this guy doesn't yet
        // exist in the root directory.

        SetReferenceCount(0);

        FREE(file_name);
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::VerifyAndFixFileNames(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN      PCNTFS_CHKDSK_INFO  ChkdskInfo,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound,
    IN      BOOLEAN             FixDupInfo,
    IN      BOOLEAN             ClearSystemFlags
    )
/*++

Routine Description:

    This routine ensures that the duplicate information in the
    file name attributes is correct.  It otherwise corrects
    these entries and outputs a message.

    This method will also make sure that for every NTFS
    file name there is a corresponding FAT file name with
    the same parent pointer and that for every FAT file
    name there is a corresponding NTFS file name with the
    same parent pointer.

Arguments:

    CurrentDirectory    - Supplies the directory to which this
                            file belongs.
    VolumeBitmap        - Supplies the volume bitmap.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.
    FixDupInfo          - Supplies whether or not to fix incorrect
                            duplicated information.
    ClearSystemFlags    - Supplies whether or not to clear the
                            FILE_VIEW_INDEX_PRESENT and
                            DUP_VIEW_INDEX_PRESENT flags

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE          attribute;
    DSTRING                 index_name;
    DSTRING                 file_name;
    ULONG                   i;
    BOOLEAN                 error;
    DUPLICATED_INFORMATION  actual_info;
    PFILE_NAME              pfile_name;
    PFILE_NAME              pntfs_name;
    PFILE_NAME              pdos_name;
    ULONG                   num_bytes;
    BOOLEAN                 index_present;
    MFT_SEGMENT_REFERENCE   parent_for_dos_name;
    BOOLEAN                 ntfs_name_encountered;
    BOOLEAN                 dos_name_encountered;
    BOOLEAN                 flags_mod;
    BOOLEAN                 merge_flags;
    BOOLEAN                 attr_del;
    BOOLEAN                 success;
    HMEM                    hmem;
    ULONG                   value_length, cluster_size;
    PINDEX_ROOT             index_root;
    PSTANDARD_INFORMATION2  standard_info2;
    BOOLEAN                 frs_needs_flushing;
    BOOLEAN                 file_is_sparse;
    BOOLEAN                 file_is_encrypted;
    ULONG                   bytesWritten;
    UCHAR                   file_name_buffer[sizeof(FILE_NAME)+sizeof(WCHAR)*254];   // FileNameLength <= 255 characters

    // First check the validity of the FILE_FILE_NAME_INDEX_PRESENT bit.

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    error = FALSE;
    index_present = QueryAttribute(&attribute, &error, $INDEX_ROOT,
                                   &index_name);


    // Make sure that if the $INDEX_ROOT is present then
    // that it is also valid enough so that it won't be tubed.

    if (index_present) {

        value_length = attribute.QueryValueLength().GetLowPart();

        if (error || !hmem.Acquire(value_length)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!attribute.Read(hmem.GetBuf(), 0, value_length, &num_bytes) ||
            num_bytes != value_length ||
            value_length < sizeof(INDEX_ROOT) ||
            !(index_root = (PINDEX_ROOT) hmem.GetBuf()) ||
            index_root->IndexHeader.FirstIndexEntry < sizeof(INDEX_HEADER)) {

            index_present = FALSE;
        }

        // If our cluster size is greater than the index buffer size,
        // the ClustersPerIndexBuffer in the index root should reflect
        // a 512-byte block size.
        //

        if (index_present) {

            ULONG cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();

            if (index_root->BytesPerIndexBuffer < cluster_size &&
                ULONG(index_root->ClustersPerIndexBuffer * NTFS_INDEX_BLOCK_SIZE) !=
                    index_root->BytesPerIndexBuffer) {

                DebugPrintTrace(("VerifyAndFixFileNames: %x %x %x\n",
                    index_root->BytesPerIndexBuffer, index_root->ClustersPerIndexBuffer,
                    cluster_size));

                index_present = FALSE;
            }
        }
    }

    if (ClearSystemFlags) {
        ClearViewIndexPresent();

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't write it out");
            return FALSE;
        }
    }


    if ((IsIndexPresent() && !index_present) ||
        (!IsIndexPresent() && index_present)) {

        MSGID   msgid;

        index_present ? SetIndexPresent() : ClearIndexPresent();

        if (index_present)
            msgid = MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT;
        else
            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_PRESENT_BIT;
        Message->LogMsg(msgid, "%I64x", QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't write it out");
            return FALSE;
        }
    }

    if (ChkdskInfo->major >= 2) {
        file_is_sparse = FALSE;
        file_is_encrypted = FALSE;
        frs_needs_flushing = FALSE;
        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $DATA,
                                            i); i++) {

            if (attribute.QueryFlags() & ATTRIBUTE_FLAG_SPARSE) {
                file_is_sparse = TRUE;
            }
            if (attribute.QueryFlags() & ATTRIBUTE_FLAG_ENCRYPTED) {
                if (attribute.IsResident()) {
                    attribute.SetFlags(attribute.QueryFlags() &
                                       ~ATTRIBUTE_FLAG_ENCRYPTED);

                    Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_ENCRYPTED_FLAG,
                                    "%I64x", QueryFileNumber().GetLargeInteger());

                    if (ChkdskInfo->Verbose) {
                        Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                                         "%d", QueryFileNumber().GetLowPart());
                    }
                    if (FixLevel != CheckOnly &&
                        !attribute.InsertIntoFile(this, VolumeBitmap)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                         "%d%d", attribute.QueryTypeCode(),
                                         QueryFileNumber().GetLowPart());
                        return FALSE;
                    }
                    frs_needs_flushing = TRUE;
                } else {
                    file_is_encrypted = TRUE;
                }
            }
        }
        if (frs_needs_flushing && FixLevel != CheckOnly) {
            if (!Flush(VolumeBitmap)) {
                DebugAbort("Can't flush out changes");
                return FALSE;
            }
        }

        if (!QueryAttribute(&attribute, &error, $STANDARD_INFORMATION)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        //
        // It could be a small STANDARD_INFORMATION but it makes no difference
        // as we are only altering FileAttributes.
        //
        if (!(standard_info2 = (PSTANDARD_INFORMATION2)attribute.GetResidentValue())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs_needs_flushing = FALSE;
        if (file_is_sparse) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE)) {
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SPARSE_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE,
                                 "%d", QueryFileNumber().GetLowPart());
                frs_needs_flushing = TRUE;
            }
        } else {
            //
            // do this quietly
            //
            if (standard_info2->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
                standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_SPARSE_FILE;

                Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_SPARSE_FLAG,
                                "%I64x", QueryFileNumber().GetLargeInteger());

                if (ChkdskInfo->Verbose) {
                    Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE,
                                     "%d", QueryFileNumber().GetLowPart());
                }
                frs_needs_flushing = TRUE;
            }
        }

        if (standard_info2->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED_OLD) {

            // clear the old bit and turn on the new bit

            standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED_OLD;
            standard_info2->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;

            Message->LogMsg(MSG_CHKLOG_NTFS_REPLACING_OLD_ENCRYPTED_FLAG_WITH_NEW_ONE_IN_STD_INFO,
                         "%I64x", QueryFileNumber().GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                             "%d", QueryFileNumber().GetLowPart());
            frs_needs_flushing = TRUE;
        }

        if (file_is_encrypted) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_ENCRYPTED_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                                 "%d", QueryFileNumber().GetLowPart());
                frs_needs_flushing = TRUE;
            }
        }   // don't clear the encryption bit even the file is not encrypted


        if (!ChkdskInfo->FilesWithReparsePoint.IsFree(QueryFileNumber(), 1)) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_REPARSE_POINT_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT,
                                 "%d", QueryFileNumber());
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                frs_needs_flushing = TRUE;
            }
        } else {
            if (standard_info2->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_POINT_FLAG_SET_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT,
                                 "%d", QueryFileNumber());
                standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;
                frs_needs_flushing = TRUE;
            }
        }

        if (ClearSystemFlags) {
            standard_info2->FileAttributes &= ~DUP_VIEW_INDEX_PRESENT;
            frs_needs_flushing = TRUE;
        }

        DebugAssert(attribute.QueryValueLength().GetHighPart() == 0);

        if (frs_needs_flushing && FixLevel != CheckOnly) {
            if (!attribute.Write(standard_info2,
                                 0,
                                 attribute.QueryValueLength().GetLowPart(),
                                 &bytesWritten,
                                 VolumeBitmap) ||
                bytesWritten != attribute.QueryValueLength().GetLowPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                 "%d%d", attribute.QueryTypeCode(),
                                 QueryFileNumber().GetLowPart());
                return FALSE;
            }
            if (attribute.IsStorageModified() &&
                !attribute.InsertIntoFile(this, VolumeBitmap)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                 "%d%d", attribute.QueryTypeCode(),
                                 QueryFileNumber().GetLowPart());
                return FALSE;
            }
            if (!Flush(VolumeBitmap)) {
                DebugAbort("Can't flush out changes");
                return FALSE;
            }
        }
        if (DiskErrorsFound)
            *DiskErrorsFound = *DiskErrorsFound || frs_needs_flushing;
    }

    if (FixDupInfo)
        if (!QueryDuplicatedInformation(&actual_info)) {
            DebugAbort("Cannot get duplicated information");
            return FALSE;
        }

    // Now go through the file name attributes and make sure that
    // they have the correct duplicated information.  Also insure
    // consistency of DOS and NTFS bits set.

    dos_name_encountered = FALSE;
    ntfs_name_encountered = FALSE;
    flags_mod = merge_flags = attr_del = FALSE;
    pdos_name = pntfs_name = NULL;

    for (i = 0; QueryAttributeByOrdinal(&attribute,
                                        &error,
                                        $FILE_NAME,
                                        i);) {

        pfile_name = (PFILE_NAME) attribute.GetResidentValue();

        if (!pfile_name) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }


        if (FixDupInfo) {

            // Validate the duplicate information.

            if (memcmp(&pfile_name->Info, &actual_info,
                       sizeof(DUPLICATED_INFORMATION))) {

// No need to be verbal about this fix, since the duplicate information
// in the file name attribute is not maintained by the file system.

#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", QueryFileNumber().GetLowPart());
#endif

                if (!UpdateFileNames(&actual_info, NULL, FALSE)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (DiskErrorsFound) {
                    *DiskErrorsFound = TRUE;
                }

                if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
                    DebugAbort("Can't flush out changes");
                    return FALSE;
                }

                i = 0;
                dos_name_encountered = FALSE;
                ntfs_name_encountered = FALSE;
                flags_mod = merge_flags = FALSE;
                pdos_name = pntfs_name = NULL;
                continue;
            }
        }


        // Make sure there's only one NTFS name and that it's in the
        // same directory as the corresponding DOS name.

        if (pfile_name->Flags & FILE_NAME_NTFS) {
            
            if (!NTFS_SA::IsNtfsName(pfile_name)) {
                
                if (!DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success)) {

            		Message->DisplayMsg(MSG_CHK_NO_MEMORY);
		            return FALSE;
                    
                } else {
    
                    if (!file_name.Initialize(
                                NtfsFileNameGetName(pfile_name),
                                (ULONG) pfile_name->FileNameLength)) {
    
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
    
    
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_FILENAME_ATTRIBUTE,
                                        "%W%d%I64d", 
                                        &file_name,
                                        pfile_name->ParentDirectory.LowPart,
                                        QueryFileNumber().GetLargeInteger());
                    //
                    // DeleteResidentAttribute shouldn't fail since we have accessed the
                    // attribute with QueryAttributeByOrdinal prior to this call and are  
                    // sure it exists.If this does fail then the cause of this failure
                    // must be investigated. 
                    //
                    DebugAssert(success);
                    
                }

                attr_del = TRUE;
                 
                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_NTFS_NAME);
                Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
                Message->DumpDataToLog(NtfsFileNameGetName(pfile_name),
                                           sizeof(WCHAR)*pfile_name->FileNameLength);
                Message->Unlock();
                    
                i = 0;
                dos_name_encountered = FALSE;
                ntfs_name_encountered = FALSE;
                flags_mod = merge_flags = FALSE;
                pdos_name = pntfs_name = NULL;
                continue;
            }



            if (ntfs_name_encountered) {

                Message->LogMsg(MSG_CHKLOG_NTFS_NTFS_FILE_NAME_ALREADY_ENCOUNTERED,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                flags_mod = TRUE;
            } else {
                ntfs_name_encountered = TRUE;
                if (dos_name_encountered) {
                    if (!(parent_for_dos_name == pfile_name->ParentDirectory)) {
                        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_HAVE_DIFFERENT_PARENTS,
                                     "%I64x%I64x%I64x",
                                     parent_for_dos_name,
                                     pfile_name->ParentDirectory,
                                     QueryFileNumber().GetLargeInteger());
                        flags_mod = TRUE;
                    }

                    //
                    // Make sure the ntfs name is not the same as the dos name
                    //
                    merge_flags = !flags_mod &&
                                  pdos_name &&
                                  (NtfsUpcaseCompare(NtfsFileNameGetName(pdos_name),
                                                     pdos_name->FileNameLength,
                                                     NtfsFileNameGetName(pfile_name),
                                                     pfile_name->FileNameLength,
                                                     GetUpcaseTable(),
                                                     FALSE) == 0);
                } else {
                    parent_for_dos_name = pfile_name->ParentDirectory;
                    if (!flags_mod &&
                        !(pfile_name->Flags & FILE_NAME_DOS) &&
                        NTFS_SA::IsDosName(pfile_name)) {
                        pntfs_name = (PFILE_NAME)file_name_buffer;
                        memcpy(pntfs_name, pfile_name, attribute.QueryValueLength().GetLowPart());
                    } else
                        pntfs_name = NULL;
                }
            }
        }


        // Make sure there's only one DOS name and that it's in the
        // same directory as the corresponding NTFS name.

        if (pfile_name->Flags & FILE_NAME_DOS) {

            if (!NTFS_SA::IsDosName(pfile_name)) {
                if (!DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success)) {

            		Message->DisplayMsg(MSG_CHK_NO_MEMORY);
		            return FALSE;
                    
                } else {
                                
                    if (!file_name.Initialize(
                                NtfsFileNameGetName(pfile_name),
                                (ULONG) pfile_name->FileNameLength)) {
    
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
    
    
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_FILENAME_ATTRIBUTE,
                                        "%W%d%I64d", 
                                        &file_name,
                                        pfile_name->ParentDirectory.LowPart,
                                        QueryFileNumber().GetLargeInteger());
                    
                    //
                    // DeleteResidentAttribute shouldn't fail since we have accessed the
                    // attribute with QueryAttributeByOrdinal prior to this call and are  
                    // sure it exists.If this does fail then the cause of this failure
                    // must be investigated. 
                    //
                    DebugAssert(success);
                }
                
                attr_del = TRUE;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_DOS_NAME);
                Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
                Message->DumpDataToLog(NtfsFileNameGetName(pfile_name),
                                       sizeof(WCHAR)*pfile_name->FileNameLength);
                Message->Unlock();

                i = 0;
                dos_name_encountered = FALSE;
                ntfs_name_encountered = FALSE;
                flags_mod = merge_flags = FALSE;
                pdos_name = pntfs_name = NULL;
                continue;
            
            }


            if (dos_name_encountered) {

                Message->LogMsg(MSG_CHKLOG_NTFS_DOS_FILE_NAME_ALREADY_ENCOUNTERED,
                                 "%I64x", QueryFileNumber().GetLargeInteger());
                flags_mod = TRUE;
            } else {
                dos_name_encountered = TRUE;

                if (ntfs_name_encountered) {
                    if (!(parent_for_dos_name == pfile_name->ParentDirectory)) {
                        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_HAVE_DIFFERENT_PARENTS,
                                     "%I64x%I64x%I64x",
                                     parent_for_dos_name,
                                     pfile_name->ParentDirectory,
                                     QueryFileNumber().GetLargeInteger());
                        flags_mod = TRUE;
                    }

                    //
                    // Make sure the dos name is not the same as the ntfs name
                    //
                    merge_flags = !flags_mod &&
                                  pntfs_name &&
                                  !(pfile_name->Flags & FILE_NAME_NTFS) &&
                                  (NtfsUpcaseCompare(NtfsFileNameGetName(pntfs_name),
                                                     pntfs_name->FileNameLength,
                                                     NtfsFileNameGetName(pfile_name),
                                                     pfile_name->FileNameLength,
                                                     GetUpcaseTable(),
                                                     FALSE) == 0);
                } else {
                    parent_for_dos_name = pfile_name->ParentDirectory;
                    if (!flags_mod &&
                        !(pfile_name->Flags & FILE_NAME_NTFS)) {
                        pdos_name = (PFILE_NAME)file_name_buffer;
                        memcpy(pdos_name, pfile_name, attribute.QueryValueLength().GetLowPart());
                    } else
                        pdos_name = NULL;
                }
            }
        }
        i++;
    }

    if ((i == 0) && (attr_del)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CREATING_ORPHAN,
                            "%I64d", 
                            QueryFileNumber().GetLargeInteger());

    }
    

    // Make sure DOS name iff NTFS name.

    if (dos_name_encountered && !ntfs_name_encountered ||
        !dos_name_encountered && ntfs_name_encountered) {

        MSGID   msgid;

        if (dos_name_encountered)
            msgid = MSG_CHKLOG_NTFS_MISSING_NTFS_NAME;
        else
            msgid = MSG_CHKLOG_NTFS_MISSING_DOS_NAME;
        Message->LogMsg(msgid, "%I64x", QueryFileNumber().GetLargeInteger());

        flags_mod = TRUE;
    }


    if (flags_mod) {

        merge_flags = FALSE;

        // There were some flags errors so clear all the flags.

        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $FILE_NAME,
                                            i);) {

            pfile_name = (PFILE_NAME) attribute.GetResidentValue();

            if (pfile_name->Flags & FILE_NAME_DOS ||
                pfile_name->Flags & FILE_NAME_NTFS) {

                if (!DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success)) {

            		Message->DisplayMsg(MSG_CHK_NO_MEMORY);
		            return FALSE;
                    
                } else {
    
                    //
                    // DeleteResidentAttribute shouldn't fail since we have accessed the
                    // attribute with QueryAttributeByOrdinal prior to this call and are  
                    // sure it exists.If this does fail then the cause of this failure
                    // must be investigated. 
                    //
                    DebugAssert(success);
                }
                    
                // Clear the flags.
                pfile_name->Flags &= ~(FILE_NAME_DOS | FILE_NAME_NTFS);

                if (!attribute.InsertIntoFile(this, VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i = 0;
                continue;
                
            }

            i++;
        }
    }

    if (merge_flags) {

        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_ARE_IDENTICAL,
                     "%I64x", QueryFileNumber().GetLargeInteger());
        //
        // Combine the short and long names into one as both
        // are 8.3 names different in case at the most
        //
        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $FILE_NAME,
                                            i);) {

            pfile_name = (PFILE_NAME) attribute.GetResidentValue();

            if (pfile_name->Flags & FILE_NAME_DOS &&
                !(pfile_name->Flags & FILE_NAME_NTFS)) {

                if (!DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success)) {

            		Message->DisplayMsg(MSG_CHK_NO_MEMORY);
		            return FALSE;
                    
                } else {
    
                    //
                    // DeleteResidentAttribute shouldn't fail since we have accessed the
                    // attribute with QueryAttributeByOrdinal prior to this call and are  
                    // sure it exists.If this does fail then the cause of this failure
                    // must be investigated. 
                    //
                    DebugAssert(success);
                }
                    
                i = 0;
                continue;
                
            }
            if (pfile_name->Flags & FILE_NAME_NTFS &&
                !(pfile_name->Flags & FILE_NAME_DOS)) {

                if (!DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success)) {

            		Message->DisplayMsg(MSG_CHK_NO_MEMORY);
		            return FALSE;
                    
                } else {
                    //
                    // DeleteResidentAttribute shouldn't fail since we have accessed the
                    // attribute with QueryAttributeByOrdinal prior to this call and are  
                    // sure it exists.If this does fail then the cause of this failure
                    // must be investigated. 
                    //
                    DebugAssert(success);
                }

                // Set the DOS flag as well
                pfile_name->Flags |= FILE_NAME_DOS;

                if (!attribute.InsertIntoFile(this, VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i = 0;
                continue;   // may not have encountered the dos name yet
            }
            i++;
        }
    }


    // Commit any flag changes to disk.

    if (flags_mod || merge_flags || attr_del) {

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_FILE_NAME_ERRORS,
                         "%d", QueryFileNumber().GetLowPart());

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't flush out changes");
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddDataAttribute(
    IN     ULONG        InitialSize,
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      Fill,
    IN     CHAR         FillCharacter
    )
/*++

Routine Description:

    This method adds a nonresident data attribute to the File Record Segment.

Arguments:

    InitialSize     --  Supplies the number of bytes to allocate for
                        the data attribute.
    VolumeBitmap    --  Supplies the volume bitmap.
    Fill            --  Supplies a flag which, if TRUE, indicates that
                        the value of the attribute should be set to
                        the supplied fill character.
    FillCharacter   --  Supplies a fill character.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE   DataAttribute;
    NTFS_EXTENT_LIST Extents;

    // Initialize the data attribute [type is $DATA, no name] with an
    // empty extent list, and then resize it to the desired size.

    if( !Extents.Initialize( 0, 0 ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   0,
                                   0,
                                   $DATA,
                                   NULL ) ||
        !DataAttribute.Resize( InitialSize, VolumeBitmap ) ) {

        return FALSE;
    }

    if( Fill &&
        !DataAttribute.Fill( 0, FillCharacter ) ) {

        return FALSE;
    }

    // Insert the data attribute into this File Record Segment.  If that
    // operation fails, we need to free up the space allocated by
    // resizing the attribute back to zero.

    if( !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        DataAttribute.Resize( 0, VolumeBitmap );
        return FALSE;
    }

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddFileNameAttribute(
    IN PFILE_NAME   FileName
    )
/*++

Routine Description:

    This method adds a File Name attribute to the File Record Segment.
    Note that it assumes that the File Name is indexed.

Arguments:

    FileName    --  Supplies the value of the File Name attribute, which
                    is a FILE_NAME structure.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE FileNameAttribute;

    // Initialize a file-name attribute and insert it into this FRS.

    if( FileNameAttribute.Initialize( GetDrive(),
                                      QueryClusterFactor(),
                                      FileName,
                                      NtfsFileNameGetLength( FileName ),
                                      $FILE_NAME ) ) {

        FileNameAttribute.SetIsIndexed();

        return( FileNameAttribute.InsertIntoFile( this, NULL ) );

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddAttribute(
    IN ATTRIBUTE_TYPE_CODE  Type,
    IN PCWSTRING            Name,
    IN PCVOID               Value,
    IN ULONG                Length,
    IN OUT PNTFS_BITMAP     Bitmap,
    IN BOOLEAN              IsIndexed
    )
/*++

Routine Description:

    This method adds an attribute of the specified type to the file.

Arguments:

    Type        --  Supplies the type of the attribute.
    Name        --  Supplies the name of the attribute--may be NULL,
                    which is interpreted as no name.
    Value       --  Supplies a pointer to the attribute's value.  May
                    be NULL if the attribute value length is zero.
    Length      --  Supplies the length of the attribute value.
    Bitmap      --  Supplies the volume bitmap.  May be NULL,
                    in which case the attribute cannot be made
                    nonresident.
    IsIndexed   --  Supplies a flag which indicates whether the
                    attribute is indexed.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE Attribute;

    // Initialize a resident attribute with the desired
    // characteristics.  If it is to be indexed, mark
    // it as such.
    //
    if( !Attribute.Initialize( GetDrive(),
                               QueryClusterFactor(),
                               Value,
                               Length,
                               Type,
                               Name ) ) {

        return FALSE;
    }

    if( IsIndexed ) {

        Attribute.SetIsIndexed();
    }

    // Insert the attribute into the file.  If it cannot be inserted
    // as a resident attribute, make it non-resident and try again.
    //
    if( Attribute.InsertIntoFile( this, NULL ) ) {

        // Success!
        //
        return TRUE;
    }

    // Couldn't insert it as a resident attribute; if it isn't
    // indexed, make it nonresident and try again.  Note that
    // we can't make it nonresident if the client did not provide
    // a bitmap, and that indexed attributes cannot be made
    // nonresident.
    //
    if( !IsIndexed &&
        Bitmap != NULL &&
        Attribute.MakeNonresident( Bitmap ) &&
        Attribute.InsertIntoFile( this, Bitmap ) ) {

        // Second time lucky.
        //
        return TRUE;
    }

    // Can't insert this attribute into this FRS.  If the attribute
    // is nonresident, truncate it to zero length to free up the
    // space allocated to it.
    //
    if( !Attribute.IsResident() ) {

        DebugPtrAssert( Bitmap );
        Attribute.Resize( 0, Bitmap );
    }

    // return failure.
    //
    return FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddSecurityDescriptor(
    IN     CANNED_SECURITY_TYPE SecurityType,
    IN OUT PNTFS_BITMAP         Bitmap
    )
/*++

Routine Description:

    This method adds a security descriptor, chosen from the
    canned security descriptors, to the file.

Arguments:

    SecurityType    --  Identifies the sort of security descriptor
                        to add.
    Bitmap          --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

--*/
{
    PCANNED_SECURITY CannedSecurity;
    PVOID SecurityDescriptor;
    ULONG SdLength;

#if defined( _SETUP_LOADER_ )

    // Security descriptors are not supported under the
    // setup loader.
    //
    return TRUE;

#else

    if( (CannedSecurity = IFS_SYSTEM::GetCannedSecurity()) == NULL ||
        (SecurityDescriptor =
            CannedSecurity->GetCannedSecurityDescriptor( SecurityType,
                                                         &SdLength ))
            == NULL ) {

        DebugPrint( "UNTFS: Canned security is not available.\n" );
        return FALSE;
    }

    return( AddAttribute( $SECURITY_DESCRIPTOR,
                          NULL,
                          SecurityDescriptor,
                          SdLength,
                          Bitmap ) );

#endif // _SETUP_LOADER_

}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddSecurityDescriptorData(
    IN     PNTFS_ATTRIBUTE      Attribute,
    IN OUT PVOID                Buffer,
    OUT    PSECURITY_ENTRY      *SecurityEntry,
    IN     ULONG                SecurityId,
    IN     CANNED_SECURITY_TYPE SecurityType,
    IN OUT PNTFS_BITMAP         Bitmap,
    IN     BOOLEAN              FixLevel
    )
/*++

Routine Description:

    This method adds a default security descriptor entry to the
    end of the security descriptor data stream.  This routine assumes
    that the security descriptor data stream has been checked out
    or corrected.

    A flush of the frs is required to commit changes onto disk.

Arguments:

    Attribute       --  supplies the attribute.
    Buffer          --  work buffer of SecurityDescriptorsBlockSize.
    SecurityEntry   --  returns a pointer into the working buffer where the
                        security entry lies.
    SecurityId      --  supplies the security id.
    SecurityType    --  Identifies the sort of security descriptor to add.
    Bitmap          --  Supplies the volume bitmap.
    FixLevel        --  Supplies a flag which, if equals to CheckOnly, indicates
                        that this method should not actually modify the
                        security descriptor data stream on disk.

Return Value:

    TRUE upon successful completion.

--*/
{
    PCANNED_SECURITY cannedSecurity;
    PVOID   securityDescriptor;
    ULONG   sdLength;
    ULONG   num_bytes = 0;
    ULONG   bytesWritten;
    ULONG   length, length1, length2, offset, pad1_size;

    SECURITY_DESCRIPTOR_HEADER  sdh;

#if defined( _SETUP_LOADER_ )

    // Security descriptors are not supported under the
    // setup loader.
    //
    return TRUE;

#else

    if( (cannedSecurity = IFS_SYSTEM::GetCannedSecurity()) == NULL ||
        (securityDescriptor =
            cannedSecurity->GetCannedSecurityDescriptor( SecurityType,
                                                         &sdLength ))
            == NULL ) {

        DebugPrint( "UNTFS: Canned security is not available.\n" );
        return FALSE;
    }

    length = Attribute->QueryValueLength().GetLowPart();
    if (length < SecurityDescriptorsBlockSize) {

        // this should not occur if the data stream has been checked

        if (FixLevel != CheckOnly)  // if stream has been corrected
            return FALSE;           // then we got bad news

        // If in read-only mode, then fake the length and continue

        length = SecurityDescriptorsBlockSize;
    }

    length -= SecurityDescriptorsBlockSize;
    offset = length & ~(SecurityDescriptorsBlockSize-1);

    length1 = length & (SecurityDescriptorsBlockSize-1);
    pad1_size = ((length1 + 0xf) & ~0xf) - length1;

    length2 = sizeof(SECURITY_DESCRIPTOR_HEADER)+sdLength;

    sdh.Length = length2;
    sdh.HashKey.SecurityId = SecurityId;
    sdh.HashKey.Hash = ComputeSecurityDescriptorHash(securityDescriptor,
                                                     sdLength);

    if (length1 + pad1_size + length2 <= SecurityDescriptorsBlockSize) {
        // everything fits into the current block
        memset(Buffer, 0, pad1_size);
        sdh.Offset = length + pad1_size;
        *SecurityEntry = (PSECURITY_ENTRY)((PCHAR)Buffer+pad1_size);
        memcpy((PVOID)*SecurityEntry,
               &sdh,
               sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        offset += length1;
        length = pad1_size + length2;
    } else if (length1 + pad1_size +
               sizeof(SECURITY_DESCRIPTOR_HEADER) <=
               SecurityDescriptorsBlockSize) {
        // add End of Block marker then
        // goto next block and add the security descriptor
        memset(Buffer, 0, pad1_size);
        MarkEndOfSecurityDescriptorsBlock(
            (PSECURITY_ENTRY)((PCHAR)Buffer+pad1_size),
            SecurityDescriptorsBlockSize - length1 - pad1_size);
        length = SecurityDescriptorsBlockSize - length1;
        if (FixLevel != CheckOnly &&
            (!Attribute->Write(Buffer,
                               length1,
                               length,
                               &bytesWritten,
                               Bitmap) ||
             bytesWritten != length)) {
            return FALSE;
        }
        offset += (SecurityDescriptorsBlockSize<<1);
        sdh.Offset = offset;
        *SecurityEntry = (PSECURITY_ENTRY)Buffer;
        memcpy(*SecurityEntry, &sdh, sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        length = length2;
    } else if ((length1 == SecurityDescriptorsBlockSize) ||
               (length1 + pad1_size == SecurityDescriptorsBlockSize)) {
        // goto next block and add the security descriptor
        offset += (SecurityDescriptorsBlockSize<<1);
        sdh.Offset = offset;
        *SecurityEntry = (PSECURITY_ENTRY)Buffer;
        memcpy(*SecurityEntry, &sdh, sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        length = length2;
    } else {
        // move the last security descriptor to the beginning
        // of next block then append the new security descriptor
        *SecurityEntry = NULL;
        DebugAssert(FALSE);
        return FALSE;
    }

    if (FixLevel != CheckOnly &&
        (!Attribute->Write(Buffer,
                           offset,
                           length,
                           &bytesWritten,
                           Bitmap) ||
         bytesWritten != length ||
         !Attribute->Write(Buffer,
                           offset + SecurityDescriptorsBlockSize,
                           length,
                           &bytesWritten,
                           Bitmap) ||
         bytesWritten != length)) {
         return FALSE;
    }
    if (FixLevel != CheckOnly && Attribute->IsStorageModified() &&
        !Attribute->InsertIntoFile(this, Bitmap)) {
        return FALSE;
    }

    return TRUE;

#endif // _SETUP_LOADER_

}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::IsAttributePresent (
   IN  ATTRIBUTE_TYPE_CODE Type,
   IN  PCWSTRING           Name,
   IN  BOOLEAN             IgnoreExternal
   )
/*++

Routine Description:

   This function determines whether a specified attribute is present
   in the attributes associated with the File Record Segment.

Arguments:

   Type         -- supplies the type code of the attribute in question.
   Name         -- supplies the name of the attribute in question.
                  (may be NULL, in which case the attribute has no name.)
   IgnoreExternal -- supplies a flag indicating that the FRS should
               not look for external attributes.

Return Value:

   TRUE if the File Record Segment has an attribute which matches
   the type (and name, if given).

Notes:

   This method assumes that the file record segment is consistent,
   and that it has been read.

   Note that we can determine what attribute records are present,
   and whether they are unique, without reading the child FRS's,
   since the information we need is in the Attribute List.

   The NoExternal flag is provided mainly to allow us to check for
   the presence of the ATTRIBUTES_LIST attribute without falling
   into infinite recursion.

--*/
{
   ULONG CurrentRecordOffset;
   NTFS_ATTRIBUTE_RECORD CurrentRecord;
   NTFS_ATTRIBUTE AttributeList;
   BOOLEAN Found = FALSE;

    DebugPtrAssert( _FrsData );

    if( !IgnoreExternal &&
        Type != $ATTRIBUTE_LIST &&
        (_AttributeList != NULL ||
         IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE )) ) {

      // This File Record Segment has an ATTRIBUTE_LIST attribute,
      // and the caller wants to include external attributes, so
      // we can traverse that list.

        if( !SetupAttributeList() ) {

            return FALSE;
        }

        return( _AttributeList->IsInList( Type, Name ) );

    } else {

      // Either the caller has asked us to ignore external
        // attributes or there is no ATTRIBUTE_LIST attribute,
        // or we're looking for the attribute list itself,
      // so we'll go through the list of attribute records
      // in this File Record Segment.

      CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
             CurrentRecord.QueryTypeCode() != $END ) {

         if( CurrentRecord.IsMatch( Type, Name ) ) {

                Found = TRUE;
                break;
         }

            // If this record has a zero length, then this FRS
            // is corrupt.  Otherwise, just go on to the next
            // attribute record.
            //
            if( CurrentRecord.QueryRecordLength() == 0 ) {
                Found = FALSE;
                break;
            }

         CurrentRecordOffset += CurrentRecord.QueryRecordLength();
      }
   }

   return Found;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttribute (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
   IN  ATTRIBUTE_TYPE_CODE  Type,
   IN  PCWSTRING            Name
   )
/*++

Routine Description:

   This function fetches an attribute associated with the
   File Record Segment.

   This method cannot be used to fetch the ATTRIBUTE_LIST attribute.

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.
    Type        --  Supplies the type of the desired attribute
    Name        --  Supplies the name of the desired attribute (NULL if
                    the attribute has no name).

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method will check both internal and external attributes,
   reading child File Record Segments as necessary to access their
   attribute records.

--*/
{
    MFT_SEGMENT_REFERENCE   SegmentReference;
    NTFS_ATTRIBUTE_RECORD   Record;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs = NULL;
    VCN                     TargetFileNumber;
    ULONG                   Index;
    ATTRIBUTE_TYPE_CODE     FetchType;
    VCN                     LowestVcn;
    DSTRING                 FetchName;
    USHORT                  Instance;
    PNTFS_EXTENT_LIST       backup_extent_list = NULL;

    DebugPtrAssert( Attribute );
    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

   // This method cannot be used to fetch the ATTRIBUTE_LIST
   // attribute.

   if( Type == $ATTRIBUTE_LIST ) {

        *Error = TRUE;
        return FALSE;
   }

    if( !IsAttributePresent( Type, Name, FALSE ) ) {

      // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }


    // Get the TargetFileNumber.

    if ( _AttributeList ) {

        if (!_AttributeList->QueryExternalReference( Type,
                                                     &SegmentReference,
                                                     &Index,
                                                     Name )) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }

        // We've found the first entry in the Attribute List
        // for this attribute.  We'll use that entry to
        // initialize the attribute object.  But first,
        // we have to find it...

        TargetFileNumber.Set( SegmentReference.LowPart,
                              (LONG) SegmentReference.HighPart );

    } else {

        TargetFileNumber = QueryFileNumber();
    }


    // Get the first attribute record.

    if ( TargetFileNumber == QueryFileNumber() ) {

        if (!QueryAttributeRecord(&Record, Type, Name)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }

    } else {

        // The record we want is in a child record segment.
        // Fetch the child.  (Note that SetupChild will construct
        // an FRS for the child and read it, if it's not already
        // in the list of children.)

        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                             "%I64x%I64x",
                             QueryFileNumber().GetLargeInteger(),
                             TargetFileNumber.GetLargeInteger());
                }
            }

            return FALSE;
        }

        if (!ChildFrs->QueryAttributeRecord(&Record, Type, Name)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 ChildFrs->QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 ChildFrs->QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }
    }


    // Initialize the Attribute with the first attribute record.

    if ( !Attribute->Initialize( GetDrive(),
                                 QueryClusterFactor(),
                                 &Record) ) {
        return FALSE;
    }

    if( Attribute->IsResident() ) {

        // A resident attribute can only have one attribute record;
        // since we've found it, we can return now.
        //
        *Error = FALSE;
        return TRUE;
    }

    // Add any other attribute records to the attribute.


    if (_AttributeList) {

        ATTR_LIST_CURR_ENTRY    Entry;
        ULONG                   i = 0;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry(&Entry,
                                              &FetchType,
                                              &LowestVcn,
                                              &SegmentReference,
                                              &Instance,
                                              &FetchName)) {
            if (i++ == Index) {
                while (_AttributeList->QueryNextEntry(&Entry,
                                                      &FetchType,
                                                      &LowestVcn,
                                                      &SegmentReference,
                                                      &Instance,
                                                      &FetchName) &&
                       FetchType == Type &&
                       ((!Name && !FetchName.QueryChCount()) ||
                        (Name && !Name->Strcmp(&FetchName)))) {

                    TargetFileNumber.Set( SegmentReference.LowPart,
                                          (LONG) SegmentReference.HighPart );

                    // Get attribute record from file record segment.

                    if ( TargetFileNumber == QueryFileNumber() ) {

                        if (!QueryAttributeRecord(&Record, Type, Name)) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    if (Name) {

                                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                             "%x%W%I64x",
                                             Type,
                                             Name,
                                             QueryFileNumber().GetLargeInteger());
                                    } else {

                                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                             "%x%I64x",
                                             Type,
                                             QueryFileNumber().GetLargeInteger());
                                    }
                                }
                            }

                            return FALSE;
                        }

                    } else {

                        // The record we want is in a child record segment.
                        // Fetch the child.  (Note that SetupChild will construct
                        // an FRS for the child and read it, if it's not already
                        // in the list of children.)
                        //
                        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                                             "%I64x%I64x",
                                             QueryFileNumber().GetLargeInteger(),
                                             TargetFileNumber.GetLargeInteger());
                                }
                            }
                            return FALSE;

                        }

                        if (!ChildFrs->QueryAttributeRecord(&Record, Type, Name)) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    if (Name) {

                                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                                 "%x%W%I64x",
                                                 Type,
                                                 Name,
                                                 QueryFileNumber().GetLargeInteger());
                                    } else {

                                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                                 "%x%I64x",
                                                 Type,
                                                 QueryFileNumber().GetLargeInteger());
                                    }
                                }
                            }

                            return FALSE;
                        }
                    }


                    // Add attribute record to attribute.

                    if (!Attribute->AddAttributeRecord(&Record, &backup_extent_list)) {

                        DELETE(backup_extent_list);
                        DebugAbort("Couldn't do an Add attribute record.");
                        return FALSE;
                    }
                }
                break;
            }
        }
    }

    *Error = FALSE;
    DELETE(backup_extent_list);
    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryFileSizes (
    OUT PBIG_INT            AllocatedLength,
    OUT PBIG_INT            FileSize,
    OUT PBOOLEAN            Error
   )
/*++

Routine Description:

   This function fetches the allocated length and file size of a
   file associated with a base File Record Segment.

Arguments:

    AllocatedLength -- receives the allocated length of the file.
    FileSize        -- receives the valid length of the file.
    Error           -- receives TRUE if the method fails because of an error.

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method will check both internal and external attributes,
   reading child File Record Segments as necessary to access their
   attribute records.

    Please note that the file size and allocated length of the file
   is entire in the base frs or the first child frs.  There is no
   need to read in all the child frs in order to compute the desired
   values.

--*/
{
    NTFS_ATTRIBUTE Attribute;
    ULONG ClusterSize;
    BIG_INT TotalAllocated;
    MFT_SEGMENT_REFERENCE SegmentReference;
    NTFS_ATTRIBUTE_RECORD Record;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs = NULL;
    VCN TargetFileNumber;
    ULONG Index;
    ATTRIBUTE_TYPE_CODE FetchType;
    VCN LowestVcn;
    DSTRING FetchName;
    USHORT Instance;

    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

    // This method cannot be used to fetch the ATTRIBUTE_LIST
    // attribute.

    if( !IsAttributePresent( $DATA, NULL, FALSE ) ) {

        // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }


    // Get the TargetFileNumber.

    if ( _AttributeList ) {

        if (!_AttributeList->QueryExternalReference( $DATA,
                                                     &SegmentReference,
                                                     &Index,
                                                     NULL )) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }

        // We've found the first entry in the Attribute List
        // for this attribute.  We'll use that entry to
        // initialize the attribute object.  But first,
        // we have to find it...

        TargetFileNumber.Set( SegmentReference.LowPart,
                              (LONG) SegmentReference.HighPart );

    } else {

        TargetFileNumber = QueryFileNumber();
    }


    // Get the first attribute record.

    if ( TargetFileNumber == QueryFileNumber() ) {

        if (!QueryAttributeRecord(&Record, $DATA, NULL)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }

    } else {

        // The record we want is in a child record segment.
        // Fetch the child.  (Note that SetupChild will construct
        // an FRS for the child and read it, if it's not already
        // in the list of children.)

        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                             "%I64x%I64x",
                             QueryFileNumber().GetLargeInteger(),
                             TargetFileNumber.GetLargeInteger());
                }
            }

            return FALSE;
        }

        if (!ChildFrs->QueryAttributeRecord(&Record, $DATA, NULL)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }
    }

    Record.QueryValueLength(FileSize,
                            AllocatedLength,
                            NULL,
                            &TotalAllocated);

    // for uncompressed file, the total allocated length does
    // not exist

    if (Record.IsResident()) {

        *AllocatedLength = QuadAlign(AllocatedLength->GetLowPart());

    } else if((Record.QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                      ATTRIBUTE_FLAG_SPARSE))) {

        // for compressed file, the allocated length is the
        // total allocated length
        *AllocatedLength = TotalAllocated;

    }

    *Error = FALSE;
    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryResidentAttribute (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    IN  COLLATION_RULE      CollationRule
    )
/*++

Routine Description:

    This method fetches a resident attribute associated with
    the File Record Segment based on attribute type code and
    attribute value.

    Note that it does not distinguish between attributes which
    have the same type code but different names; its primary use
    it to fetch indexable attributes, which are by convention
    do not have names.

Arguments:

    Attribute       --  Receives (ie. is initialized to) the attribute.
                        Note that this parameter may be uninitialized on
                        entry, and may be left uninitialized if this
                        method fails.
    Error           --  Receives TRUE if the method fails because of
                        an error (corrupt FRS or out of memory).
    Type            --  Supplies the type of the desired attribute
    Value           --  Supplies a pointer to the value to match.
    ValueLength     --  Supplies the length of the value to be matched.
    CollationRule   --  Supplies the collation rule to use for comparison.
                        The first attribute found whose value matches
                        the supplied value according to this collation
                        rule will be returned.

Return Value:

    TRUE if a matching attribute is found.

Notes:

    If this method succeeds, *Error should be ignored.

    If this method fails because of error, *Error will be set to
    TRUE.  If this method returns FALSE and *Error is FALSE, the
    client may assume that this File Record Segment has no
    matching attributes.

--*/
{
    ULONG AttributeValueLength, i;
    BOOLEAN Found;

   // This method cannot be used to fetch the ATTRIBUTE_LIST
   // attribute.

   if( Type == $ATTRIBUTE_LIST ) {

        *Error = TRUE;
        return FALSE;
   }

    // If the attribute list is present, force it into memory.

    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        *Error = TRUE;
        return FALSE;
    }

    // Iterate through all the attributes with this type code
    // until we run out or find a match.  Start by resetting *Error
    // to FALSE--if QueryAttributeByOrdinal encounters an error,
    // it will set *Error for us.

    *Error = FALSE;
    Found = FALSE;
    i = 0;

    while( !Found &&
           QueryAttributeByOrdinal( Attribute, Error, Type, i ) ) {

        DebugAssert( !Attribute->IsResident() ||
                   Attribute->GetResidentValue() != NULL );

        // If the attribute is resident and the value is the right
        // length, compare its value with the search value.
        //
        AttributeValueLength = Attribute->QueryValueLength().GetLowPart();

        if( Attribute->IsResident() &&
            AttributeValueLength == ValueLength &&
            NtfsCollate( Attribute->GetResidentValue(),
                         AttributeValueLength,
                         Value,
                         ValueLength,
                         CollationRule,
                         GetUpcaseTable() ) == 0 ) {

            if( CollationRule == COLLATION_FILE_NAME ) {

                // NOTE: for FILE_NAME comparison, we also have to
                // check that the parent pointer in the attribute
                // we found is the same as the search value, to ensure
                // that we are returning the name associated with the
                // appropriate index.
                //
                if( (((PFILE_NAME)
                      (Attribute->GetResidentValue()))->ParentDirectory ==
                     ((PFILE_NAME)Value)->ParentDirectory ) &&
                    (((PFILE_NAME)
                      (Attribute->GetResidentValue()))->Flags ==
                     ((PFILE_NAME)Value)->Flags)
                  ){

                    Found = TRUE;
                }

            } else {

                // This attribute is a match.  Return it to the client.
                //
                Found = TRUE;
            }
        }

        i++;
    }

    return Found;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeByOrdinal (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  ULONG               Ordinal
    )
/*++

Routine Description:

    This method returns the n-th attribute of the specified
    type.  Note that it ignores attribute names (but, of course,
    the client can query the name of the returned attribute from
    that attribute).

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.
    Type        --  Supplies the type of the desired attribute
    Ordinal     --  Supplies the (zero-based) ordinal number of the
                    attribute to return.

Return Value:

    TRUE upon successful completion.

    If this method succeeds, the client should ignore *Error.

    If this method fails because of error, *Error will be set; if
    this method returns FALSE and *Error is FALSE, the client may
    assume that there is no such matching attribute.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, NextSegmentReference;
    DSTRING Name;
    VCN LowestVcn;
    VCN TargetFileNumber;
    ATTRIBUTE_TYPE_CODE CurrentType;

    PVOID CurrentRecordData;
    PNTFS_FILE_RECORD_SEGMENT TargetFrs = NULL;

    USHORT InstanceTag, NextInstanceTag;


    DebugPtrAssert( Attribute );
    DebugPtrAssert( Error );

    // If the attribute list is present, force it into memory.
    //
    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        *Error = TRUE;
        return FALSE;
    }


    if( _AttributeList != NULL ) {

        ATTR_LIST_CURR_ENTRY    Entry;

        // Spin through the attribute list until we find the nth
        // entry with the requested type and a LowestVcn of zero.
        //
        Entry.CurrentEntry = NULL;
        while( TRUE ) {

            if( !_AttributeList->QueryNextEntry( &Entry,
                                                 &CurrentType,
                                                 &LowestVcn,
                                                 &SegmentReference,
                                                 &InstanceTag,
                                                 &Name ) ) {

                // Out of entries in the attribute list, so there
                // is no matching attribute type.

                *Error = FALSE;
                return FALSE;
            }

            if( CurrentType == Type && LowestVcn == 0 ) {

                // This entry has the desired type code;  check
                // to see if we want to skip it or grab it.
                //
                if( Ordinal == 0 ) {

                    // Found the entry we want.
                    //
                    break;

                } else {

                    // Skip this one.
                    //
                    Ordinal--;
                }
            }
        }

        // Now we have an entry for the attribute we want.  If there's
        // only one entry for this attribute, we can initialize an
        // attribute with that record and return; if there are multiple
        //
        // If the next entry does not have a LowestVcn of zero, it
        // is another entry for this attribute.  Note that we need
        // SegmentReference and Instance tag for later use.
        //

        if( _AttributeList->QueryNextEntry( &Entry,
                                            &CurrentType,
                                            &LowestVcn,
                                            &NextSegmentReference,
                                            &NextInstanceTag,
                                            &Name ) &&
            CurrentType == Type &&
            LowestVcn != 0 ) {

            // This is a multi-record attribute, which means it is
            // uniquely identified by Type and Name.
            //
            return( QueryAttribute( Attribute,
                                    Error,
                                    Type,
                                    &Name ) );

        } else {

            // There are no more entries for this attribute,
            // so we can initialize an the attribute with
            // this record.  We'll let QueryAttributeByTag
            // do the work for us.
            //
            TargetFileNumber.Set( SegmentReference.LowPart,
                                  (LONG) SegmentReference.HighPart );

            if( TargetFileNumber == QueryFileNumber() ) {

                // The record is in this FRS.
                //
                TargetFrs = this;

            } else {

                // The record we want is in a child FRS; get that
                // child and squeeze the attribute out of it.
                //
                if( (TargetFrs = SetupChild( TargetFileNumber)) == NULL ) {

                    // Something is wrong--we can't get the child.
                    //
                    PIO_DP_DRIVE    drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                                     "%I64x%I64x",
                                     QueryFileNumber().GetLargeInteger(),
                                     TargetFileNumber.GetLargeInteger());
                        }
                    }

                    *Error = TRUE;
                    return FALSE;
                }
            }


            if( !TargetFrs->QueryAttributeByTag( Attribute,
                                                 Error,
                                                 InstanceTag ) ) {

                // We know the attribute is there, but we can't
                // get it.
                //
                *Error = TRUE;
                return FALSE;

            } else {

                return TRUE;
            }
        }

    } else {

        // This File Record Segment does not have an attribute list,
        // so we only have to grope through this FRS.

        // First, skip over attribute records with a type-code
        // less than the one we're looking for:

        CurrentRecordData = NULL;
        *Error = FALSE;

        do {

            if( (CurrentRecordData =
                  GetNextAttributeRecord( CurrentRecordData,
                                          NULL,
                                          Error )) == NULL ||
                *Error ) {

                // No more, or an error was found.
                return FALSE;
            }

            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                *Error = TRUE;
                return FALSE;
            }

        } while( CurrentRecord.QueryTypeCode() != $END &&
                 CurrentRecord.QueryTypeCode() < Type );

        if( CurrentRecord.QueryTypeCode() == $END ||
            CurrentRecord.QueryTypeCode() > Type ) {

            // There are no attributes of the specified type in
            // this FRS.  Note that *Error has already been set
            // to FALSE.

            return FALSE;
        }

        // Now step through the attributes of this type code to
        // find the one we want.

        while( Ordinal != 0 ) {

            // In determining the ordinal of an attribute, we only
            // count attribute records which are resident or have
            // a LowestVcn of zero.

            if( CurrentRecord.IsResident() ||
                CurrentRecord.QueryLowestVcn() == 0 ) {

                Ordinal--;
            }

            if( (CurrentRecordData =
                 GetNextAttributeRecord( CurrentRecordData,
                                         NULL,
                                         Error )) == NULL ||
                *Error ) {

                // No more, or an error was found.
                return FALSE;
            }

            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( CurrentRecord.QueryTypeCode() == $END ||
                CurrentRecord.QueryTypeCode() > Type ) {

                // Ran out of matching records.

                return FALSE;
            }
        }

        // We've found our baby.  Initialize the attribute and return.

        if( CurrentRecord.IsResident() ) {

            // Since this attribute record is resident, it is
            // the only attribute record for this attribute, and
            // so it suffices to initialize the attribute with
            // this record.

            if( Attribute->Initialize( GetDrive(),
                                       QueryClusterFactor(),
                                       &CurrentRecord ) ) {

                // Everything is just fine.

                return TRUE;

            } else {

                // Foiled at the last minute by some dastardly error.

                *Error = TRUE;
                return FALSE;
            }

        } else {

            // Since there may be other attribute records associated
            // with this attribute, we have to invoke QueryAttribute
            // to do our work for us.  Get the name from the attribute
            // record, and then query this FRS for the attribute with
            // the requested type and that name.

            if( !CurrentRecord.QueryName( &Name ) ) {

                *Error = TRUE;
                return FALSE;
            }

            return( QueryAttribute( Attribute,
                                    Error,
                                    Type,
                                    &Name ) );
        }

    }
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeByTag (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ULONG               Tag
    )
/*++

Routine Description:

    This method initializes an attribute based on the single attribute
    record with the specified instance tag.  Note that it only examines
    records in this File Record Segment; it does not look at child FRS's.

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute
                    in question.  Note that this parameter may be
                    uninitialized on entry, and may be left in that
                    state if this method fails.
    Error       --  Receives TRUE if the method fails because of
                    an error.
    Tag         --  Supplies the attribute record instance tag of
                    the desired record.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    PVOID CurrentRecordData = NULL;
    BOOLEAN Found = FALSE;


    while( !Found ) {

        CurrentRecordData = GetNextAttributeRecord( CurrentRecordData );

        if( CurrentRecordData == NULL ) {

            // No more records.
            //
            *Error = FALSE;
            return FALSE;
        }

        if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

            // Error initializing object.
            //
            *Error = TRUE;
            return FALSE;
        }

        if( CurrentRecord.QueryInstanceTag() == Tag ) {

            Found = TRUE;
        }
    }

    if( !Attribute->Initialize( GetDrive(),
                                QueryClusterFactor(),
                                &CurrentRecord ) ) {

        *Error = TRUE;
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::PurgeAttribute (
   IN  ATTRIBUTE_TYPE_CODE Type,
   IN  PCWSTRING           Name,
    IN  BOOLEAN             IgnoreExternal
   )
/*++

Routine Description:

   This method removes all attribute records for the given attribute
   type and name from the File Record Segment and its children.

Arguments:

   Type  -- supplies the type of the attribute to purge
   Name  -- supplies the name of the attribute to purge (NULL if
            the attribute has no name).
    IgnoreExternal -- supplies a flag that, if TRUE, indicates we
                      should ignore the attribute list and only delete
                      matching records found in this File Record Segment

Return Value:

   TRUE upon successful completion.

--*/
{
   NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    VCN TargetFileNumber;
    ULONG EntryIndex;
   ULONG CurrentRecordOffset;
   ULONG NextRecordOffset;

   if( !IgnoreExternal &&
        Type != $ATTRIBUTE_LIST &&
        (_AttributeList != NULL ||
       IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE) ) ) {

        // This File Record Segment has an attribute list, so
        // we should consult it.

        if( !SetupAttributeList() ) {

            return FALSE;
        }


        while( _AttributeList->QueryExternalReference( Type,
                                                       &SegmentReference,
                                                       &EntryIndex,
                                                       Name ) ) {

            TargetFileNumber.Set( SegmentReference.LowPart,
                                (LONG) SegmentReference.HighPart );

            if( TargetFileNumber == QueryFileNumber() ) {

                // The record we want to delete is in this File
                // Record Segment.  The easiest way to get at it
                // is to recurse back into this function with
                // IgnoreExternal equal to TRUE (which prevents
                // further recursion).

                PurgeAttribute( Type, Name, TRUE );

            } else {

                // The record we want to delete is in a child record
                // segment.  Note that SetupChild will construct and
                // read a new FRS if the child isn't already in the list.

                if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

                    return FALSE;
                }

                // Now we've got the child; purge any matching attributes
                // from it.  (It's OK if we purge more than one; we'll
                // catch up on later iterations.)

                if( !ChildFrs->PurgeAttribute( Type, Name ) ) {

                    return FALSE;
                }
            }

            _AttributeList->DeleteEntry( EntryIndex );
        }

   } else {

      // Either there is no Attribute List, or we're deleting
      // the Attribute List itself, or we've been instructed to
        // ignore it, so we can just go through this File Record
        // Segment and blow away any matching records we find.

        CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
              CurrentRecord.QueryTypeCode() != $END ) {

            if( CurrentRecord.QueryRecordLength() == 0 ) {

                return FALSE;
            }

         if( CurrentRecord.IsMatch( Type, Name ) ) {

            // This record matches, so away it goes!

            NextRecordOffset =CurrentRecordOffset +
                           CurrentRecord.QueryRecordLength();

            DebugAssert( NextRecordOffset < QuerySize() );

                _FrsData->FirstFreeByte -= CurrentRecord.QueryRecordLength();

            memmove( (PBYTE)_FrsData + CurrentRecordOffset,
                   (PBYTE)_FrsData + NextRecordOffset,
                   (UINT) (QuerySize() - NextRecordOffset) );



            // Note that, since we've brought the next record to
            // CurrentRecordOffset, there's no need to adjust
            // CurrentRecordOffset.

         } else {

            // This record doesn't match, so we won't purge it.

            CurrentRecordOffset += CurrentRecord.QueryRecordLength();
         }
      }
   }

   return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::DeleteResidentAttribute(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    OUT PBOOLEAN            Deleted,
    IN  BOOLEAN             IgnoreExternal
    )
/*++

Routine Description:

    This method will delete any attribute record associated with the
    File Record Segment which represents a resident attribute of the
    specified type and name with a value equal to the supplied value.

Arguments:

    Type            --  Supplies the attribute type code.
    Name            --  Supplies the attribute name.  May be NULL, which
                        indicates that the attribute has no name.
    Value           --  Supplies the value of the attribute to delete.
    ValueLength     --  Supplies the length of the value.
    IgnoreExternal  --  Supplies a flag which indicates, if TRUE,
                        that this method should only examine records
                        in this FRS (ie. it should ignore external
                        attributes).
    Deleted         --  Receives TRUE if the method found and deleted
                        a matching record.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CurrentName;
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, FoundSegmentReference;

    PNTFS_FILE_RECORD_SEGMENT ChildFrs;

    ATTRIBUTE_TYPE_CODE CurrentType;
    VCN LowestVcn, TargetFileNumber;
    USHORT Instance, FoundInstance;
    BOOLEAN IsIndexed;

    DebugPtrAssert( Value );
    DebugPtrAssert( Deleted );

    *Deleted = FALSE;

    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( !IgnoreExternal &&
        _AttributeList != NULL ) {

        // First, traverse the list to force all the children into
        // memory.
        //

        ATTR_LIST_CURR_ENTRY        Entry;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry( &Entry,
                                               &CurrentType,
                                               &LowestVcn,
                                               &SegmentReference,
                                               &Instance,
                                               &CurrentName )) {

            TargetFileNumber.Set( SegmentReference.LowPart,
                                  (LONG)SegmentReference.HighPart );

            if( TargetFileNumber != QueryFileNumber() &&
                SetupChild( TargetFileNumber ) == NULL ) {

                return FALSE;
            }
        }

        // Now traverse the list of children, trying to delete
        // the record in question.
        //
        _ChildIterator->Reset();

        while( (ChildFrs = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

            if( !ChildFrs->DeleteResidentAttributeLocal( Type,
                                                         Name,
                                                         Value,
                                                         ValueLength,
                                                         Deleted,
                                                         &IsIndexed,
                                                         &Instance ) ) {

                return FALSE;
            }

            if( *Deleted ) {

                // We found our victim.  Remember the segment reference
                // and instance tag, so we can delete the attribute list
                // entry.
                //
                FoundSegmentReference = ChildFrs->QuerySegmentReference();
                FoundInstance = Instance;

                break;
            }
        }

        if( !*Deleted ) {

            // We didn't find the target attribute record in any
            // of the children; see if it's in this FRS itself.
            //
            if( !DeleteResidentAttributeLocal( Type,
                                               Name,
                                               Value,
                                               ValueLength,
                                               Deleted,
                                               &IsIndexed,
                                               &Instance ) ) {

                return FALSE;
            }

            if( *Deleted ) {

                // Found it in this FRS.
                //
                FoundSegmentReference = QuerySegmentReference();
                FoundInstance = Instance;
            }
        }

        if( *Deleted ) {

            // We found and deleted a matching attribute record.
            // Find the corresponding entry in the attribute list
            // and delete it.  Note that the Segment Reference and
            // Instance Tag are sufficient to identify that entry.
            //

            ATTR_LIST_CURR_ENTRY    Entry;

            Entry.CurrentEntry = NULL;
            while (_AttributeList->QueryNextEntry( &Entry,
                                                   &CurrentType,
                                                   &LowestVcn,
                                                   &SegmentReference,
                                                   &Instance,
                                                   &CurrentName )) {

                if( SegmentReference == FoundSegmentReference &&
                    Instance == FoundInstance ) {

                    _AttributeList->DeleteCurrentEntry( &Entry );
                    break;
                }
            }
        }

    } else {

        // This FRS does not have an attribute list (or the client
        // wants to ignore it), so we just have to examine the records
        // in this FRS.
        //
        if( !DeleteResidentAttributeLocal( Type,
                                           Name,
                                           Value,
                                           ValueLength,
                                           Deleted,
                                           &IsIndexed,
                                           &Instance ) ) {

            return FALSE;
        }

    }

    // If we successfully deleted an indexed attribute record
    // from a Base File Record Segment, we need to adjust the
    // reference count.
    //
    if( *Deleted && IsBase() && IsIndexed ) {
        SetReferenceCount(QueryReferenceCount() - 1);
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::DeleteResidentAttributeLocal(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name OPTIONAL,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    OUT PBOOLEAN            Deleted,
    OUT PBOOLEAN            IsIndexed,
    OUT PUSHORT             InstanceTag
    )
/*++

Routine Description:

    This method deletes a resident attribute from the FRS.  Note
    that it will not affect external attributes.

Arguments:

    Type            --  Supplies the attribute type code.
    Name            --  Supplies the attribute name.  May be NULL, which
                        indicates that the attribute has no name.
    Value           --  Supplies the value of the attribute to delete.
    ValueLength     --  Supplies the length of the value.
    Deleted         --  Receives TRUE if the method found and deleted
                        a matching record.
    IsIndexed       --  Receives TRUE if the deleted record was indexed.
                        If no matching record was found, *Deleted is
                        FALSE and *IsIndexed is undefined.
    InstanceTag     --  Receives the instance tag of the deleted record;
                        if no matching record was found, *Deleted is
                        FALSE and *InstanceTag is undefined.

Return Value:

    TRUE upon successful completion.


--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    PVOID CurrentRecordData;
    PCWSTR NameBuffer = NULL;
    ULONG NameLength;       //  Length of Name in characters

    DebugPtrAssert( Value );
    DebugPtrAssert( Deleted );

    *Deleted = FALSE;

    // Get the search name into a WSTR buffer, for
    // easier comparison:
    //
    if( Name == NULL ) {

        NameLength = 0;

    } else {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->GetWSTR();
    }

    // Go through the attribute records in this FRS until
    // we find one that matches.  If we find one, it is
    // unique (unless the FRS is corrupt), so we delete
    // it and return.

    CurrentRecordData = NULL;

    while( (CurrentRecordData =
            GetNextAttributeRecord( CurrentRecordData )) != NULL ) {

        if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

            return FALSE;
        }

        // This record matches if the type codes are the same,
        // the record is resident, the names are the same length
        // and compare exactly, and the values are the same length
        // and compare exactly.
        //
        if( CurrentRecord.QueryTypeCode() == Type &&
            CurrentRecord.IsResident() &&
            CurrentRecord.QueryNameLength() == NameLength &&
            memcmp( NameBuffer,
                    CurrentRecord.GetName(),
                    NameLength * sizeof(WCHAR) ) == 0 &&
            CurrentRecord.QueryResidentValueLength() == ValueLength &&
            memcmp( CurrentRecord.GetResidentValue(),
                    Value,
                    ValueLength ) == 0 ) {

            // This is the record we want to delete.
            //
            *IsIndexed = CurrentRecord.IsIndexed();
            *InstanceTag = CurrentRecord.QueryInstanceTag();

            DeleteAttributeRecord( CurrentRecordData );
            *Deleted = TRUE;

            return TRUE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::SetupAttributeList(
    )
/*++

Routine Description:

    This method makes sure that the attribute list, if present,
    has been properly set up.  If the attribute list is present
    but cannot be initialized, this method returns FALSE.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    if ( _AttributeList == NULL &&
         IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

        if (!(_AttributeList = NEW NTFS_ATTRIBUTE_LIST) ||
            !QueryAttributeList(_AttributeList) ||
            !_AttributeList->ReadList()) {

            //  This File Record Segment has an Attribute List, and I
            //  can't get it.  Return failure.

            DELETE(_AttributeList);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateAttributeList(
    OUT PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This method generates an Attribute List Attribute for this
    File Record Segment.

Arguments:

    AttributeList   - Returns a newly-create Attribute List.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    It is an error to create an Attribute List Attribute for a
    File Record Segment that already has one.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference;
    ULONG CurrentRecordOffset;
    DSTRING CurrentName;

    // Construct an attribute list object:

    if( !AttributeList->Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    GetUpcaseTable() ) ) {

        return FALSE;
    }

    // Walk through the record entries in this File Record Segment,
    // adding an entry to the Attribute List for each record we find.
    // Note that we can use the same Segment Reference for every entry,
    // since they are all in this File Record Segment.

    SegmentReference = QuerySegmentReference();

    CurrentRecordOffset = _FrsData->FirstAttributeOffset;

    while( CurrentRecordOffset < QuerySize() &&
           CurrentRecord.Initialize( GetDrive(),
                                     (PBYTE)_FrsData + CurrentRecordOffset,
                                     QuerySize() - CurrentRecordOffset ) &&
           CurrentRecord.QueryTypeCode() != $END ) {

        if( CurrentRecord.QueryRecordLength() == 0 ) {

            // Corrupt FRS.
            //
            return FALSE;
        }

        if (!CurrentRecord.QueryName(&CurrentName) ||
            !AttributeList->AddEntry( CurrentRecord.QueryTypeCode(),
                                      CurrentRecord.QueryLowestVcn(),
                                      &SegmentReference,
                                      CurrentRecord.QueryInstanceTag(),
                                      &CurrentName ) ) {

            return FALSE;
        }

        CurrentRecordOffset += CurrentRecord.QueryRecordLength();
    }

    return TRUE;
}


PVOID
GetBiggestLocalAttributeRecord(
    IN  PNTFS_FRS_STRUCTURE Frs
    )
/*++

Routine Description:

    This routine returns the biggest attribute record in this
    file record segment.

Arguments:

    Frs - Supplies a Frs.

Return Value:

    A pointer to the biggest attribute record or NULL.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr, biggest;

    biggest = NULL;
    while (biggest = (PATTRIBUTE_RECORD_HEADER)
                     Frs->GetNextAttributeRecord(biggest)) {

        if (biggest->TypeCode != $STANDARD_INFORMATION) {
            break;
        }
    }

    if (!biggest) {
        return NULL;
    }

    pattr = biggest;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   Frs->GetNextAttributeRecord(pattr)) {

        if (pattr->TypeCode != $STANDARD_INFORMATION &&
            pattr->RecordLength > biggest->RecordLength) {
            biggest = pattr;
        }
    }

    return biggest;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::SaveAttributeList(
    PNTFS_BITMAP VolumeBitmap
    )
/*++

Routine Description:

    This method instructs the File Record Segment to save its
    attribute record list.

Arguments:

    VolumeBitmap    -- supplies the volume bitmap.

Notes:

    If _AttributesList is NULL, then the File Record Segment has not
    modified its attribute list (if it has one) and therefore does
    not need to save it.

    If this method fails, it will leave the File Record Segment in
    a consistent state (it will leave the old attribute list, if any,
    in place).

--*/
{
    NTFS_ATTRIBUTE_RECORD OldAttributeListRecord;
    NTFS_ATTRIBUTE_RECORD TemporaryRecord;
    BOOLEAN InsertSucceeded, OldPresent;
    PATTRIBUTE_RECORD_HEADER Biggest;
    ATTRIBUTE_TYPE_CODE type;
    VCN lowest_vcn;
    MFT_SEGMENT_REFERENCE seg_ref;
    USHORT instance;
    DSTRING name, tmp_name;
    BOOLEAN found_entry;


    if( _AttributeList == NULL ) {

        return TRUE;
    }

    // Note that there is no attribute list entry for the
    // attribute list's own attribute record.
    //
    // Write the attribute list.
    //
    if( !_AttributeList->WriteList( VolumeBitmap ) ) {

        return FALSE;
    }

    // We'll hedge our bets by squirreling away a copy of the old
    // attribute list's attribute record, if it exists.  Note that
    // this is a two-step process; first, we query the attribute
    // list's record from the File Record Segment; however, since
    // this record's data is actually owned by the File Record Segment,
    // we need to copy it into a record that has its own data.

    if( IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

        OldPresent = TRUE;

        if( !QueryAttributeRecord(&TemporaryRecord, $ATTRIBUTE_LIST) ||
            !OldAttributeListRecord.Initialize( GetDrive(),
                                                (PVOID) TemporaryRecord.GetData(),
                                                TemporaryRecord.QueryRecordLength(),
                                                TRUE ) ) {

            // This File Record Segment has an attribute list record,
            // but we weren't able to copy it to a safe place.  Stop
            // right here, instead of going forward into a mess from
            // which we can't recover.

            return FALSE;
        }

    } else {

        OldPresent = FALSE;
    }


    // Now that we have our own copy of the old record (if it existed),
    // we can safely delete it from the File Record Segment.  We could
    // rely on _AttributeList->InsertIntoFile to do that for us, but
    // that would complicate our error handling further down.

    if( !PurgeAttribute( $ATTRIBUTE_LIST ) ) {

        return FALSE;
    }


    // Now we try every trick we've got to insert the new attribute
    // list into the File Record Segment.

    InsertSucceeded = FALSE;

    while( !InsertSucceeded ) {

        InsertSucceeded = _AttributeList->InsertIntoFile( this,
                                                          VolumeBitmap );

        if( !InsertSucceeded ) {

            // We weren't able to insert the attribute.  Try different
            // strategems to jam it in.   First, if the attribute list
            // is resident, we can make it non-resident.

            if( _AttributeList->IsResident() ) {

                if( !_AttributeList->MakeNonresident( VolumeBitmap ) ) {

                    // We failed trying to make the attribute list
                    // nonresident.  Give up.

                    break;
                }

            } else {

                // It's nonresident, so we have to move to our next
                // contingency plan:  start moving records out of the
                // base File Record Segment and into children.

                // Find the biggest attribute record in the base
                // and then eliminate it from the attribute list
                // and the base file record segment but save it.

                Biggest = (PATTRIBUTE_RECORD_HEADER)
                          GetBiggestLocalAttributeRecord(this);
                if (!Biggest ||
                    !TemporaryRecord.Initialize(GetDrive(),
                                                Biggest,
                                                Biggest->RecordLength,
                                                TRUE)) {

                    // Serious problems.
                    break;
                }

                found_entry = FALSE;

                ATTR_LIST_CURR_ENTRY    entry;

                entry.CurrentEntry = NULL;
                while (_AttributeList->QueryNextEntry(&entry,
                                                      &type,
                                                      &lowest_vcn,
                                                      &seg_ref,
                                                      &instance,
                                                      &name)) {

                    if (type == TemporaryRecord.QueryTypeCode() &&
                        lowest_vcn == TemporaryRecord.QueryLowestVcn() &&
                        seg_ref == QuerySegmentReference() &&
                        instance == TemporaryRecord.QueryInstanceTag() &&
                        TemporaryRecord.QueryName(&tmp_name) &&
                        !tmp_name.Strcmp(&name)) {

                        _AttributeList->DeleteCurrentEntry(&entry);
                        found_entry = TRUE;
                        break;
                    }
                }

                if (found_entry) {
                    DeleteAttributeRecord(Biggest);
                } else {
                    DebugAbort("Could not find attribute list entry for big");
                    break;
                }

                // Now just pull an insert external on this record to
                // finish the task.

                if (!InsertExternalAttributeRecord(&TemporaryRecord) ||
                    !_AttributeList->WriteList(VolumeBitmap)) {

                    // Out of memory or out of disk space.
                    break;
                }
            }
        }
    }


    if( !InsertSucceeded && OldPresent ) {

        // Since we were unable to insert the new attribute
        // record, we reinsert the old one.  Note that we can
        // be sure that there's room for it, since we haven't
        // added anything to the File Record Segment since we
        // deleted this record.

        InsertAttributeRecord( &OldAttributeListRecord );
    }

    // For good or ill, we're done.

    return( InsertSucceeded );
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeRecord (
    OUT PNTFS_ATTRIBUTE_RECORD  AttributeRecord,
    IN  ATTRIBUTE_TYPE_CODE     Type,
    IN  PCWSTRING               Name
   )
/*++

Routine Description:

    This method finds an attribute record in the FRS.  Note that it only
    searches this FRS, it will not look for external attribute records.

Arguments:

    AttributeRecord -- returns the Attribute Record object.
    Type            -- supplies the type of the desired attribute record
    Name            -- supplies the name of the desired attribute (NULL if
                           the attribute has no name).

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG CurrentRecordOffset;
    BOOLEAN Found = FALSE;

    DebugPtrAssert( _FrsData );
    DebugPtrAssert( AttributeRecord );

    // Spin through the records in this File Record Segment
    // looking for a match.  If we find one, set the Found
    // flag and break out.

    CurrentRecordOffset = _FrsData->FirstAttributeOffset;

    while( CurrentRecordOffset < QuerySize() &&
           AttributeRecord->Initialize( GetDrive(),
                                        (PBYTE)_FrsData + CurrentRecordOffset,
                                        QuerySize() - CurrentRecordOffset ) &&
           AttributeRecord->QueryTypeCode() != $END ) {

        if( AttributeRecord->IsMatch( Type, Name ) ) {

            Found = TRUE;
            break;
        }

        // Go on to the next record

        CurrentRecordOffset += AttributeRecord->QueryRecordLength();
    }

    // If Found is TRUE, then CurrentRecord is the attribute
    // record we want, so we'll return it to the caller.

    return Found;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::InsertAttributeRecord (
    IN  PNTFS_ATTRIBUTE_RECORD  NewRecord,
    IN  BOOLEAN                 ForceExternal
   )
/*++

Routine Description:

   This method inserts an attribute record into the File Record
   Segment.

   If the File Record Segment has room, it will just insert the
   record.  If not, it may make the attribute external, or it
   may make room for the record by making other attributes nonresident
   or external.

   The Attribute List attribute and the Standard Information attribute
   cannot be made external.

   This method is virtual because classes which derive from
   File Record Segment may have preferences about how they manage
   their attribute records.

Arguments:

   AttributeRecord   -- supplies the attribute record to insert

   ForceExternal     -- supplies a flag telling whether to force
                        this record into a child File Record Segment;
                        if this flag is TRUE, we force this record
                        to be external.

Return Value:

    TRUE upon successful completion.

Notes:

    This method may also update the Instance tag in the attribute record.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, CheckSegment;
    DSTRING               NewName, CheckName;
    NTFS_ATTRIBUTE_RECORD TempRecord;
    PATTRIBUTE_RECORD_HEADER EvicteeData, TempRecordData;
    DSTRING NewRecordName;
    VCN CheckVcn;
    ULONG CurrentRecordOffset;
    ULONG FreeSpace;
    ATTRIBUTE_TYPE_CODE CheckType;
    BOOLEAN Result, MatchPresent;
    USHORT CheckInstance;

    // The reservation for the attribute list is enought for
    // a nonresident attribute with no name and two worst-case
    // extents.  Since this reservation is only required for
    // FRS 0, this should be plenty.
    //
    CONST AttributeListReservation = SIZE_OF_NONRESIDENT_HEADER +
                                     3 * ( 1 + 2 * sizeof(VCN) );


   DebugPtrAssert( _FrsData );
    DebugPtrAssert( NewRecord );

    // The utilities will never insert any non-$DATA records into
    // the reserved MFT-overflow FRS when it is being used as
    // a child of the MFT.
    //
    if( !IsBase() &&
        QueryFileNumber() == MFT_OVERFLOW_FRS_NUMBER &&
        NewRecord->QueryTypeCode() != $DATA ) {

        return FALSE;
    }

    // If this File Record Segment has an attribute list, we have
    // to make sure that we've read it.

    if( !SetupAttributeList() ) {

        return FALSE;
    }

    // Determine whether an attribute record of the same type and
    // name is already present in this precise FRS (ie. in this
    // FRS and not one of its children).  If this is the case,
    // then if this
    //
    if( !NewRecord->QueryName( &NewRecordName ) ) {

        DebugPrint( "UNTFS: Can't get name from attribute record.\n" );
        return FALSE;
    }

    MatchPresent = IsAttributePresent( NewRecord->QueryTypeCode(),
                                       &NewRecordName,
                                       TRUE );

    // Determine how much space is available in the File Record Segment.
   // If there's enough, find the correct insertion point for this
    // attribute record and put it there.
    //
    FreeSpace = QueryFreeSpace();

    if( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
        IsBase() &&
        NewRecord->QueryTypeCode() != $ATTRIBUTE_LIST ) {

        // Reserve space for the Attribute List.
        //
        if ( FreeSpace < AttributeListReservation ) {

            FreeSpace = 0;

        } else{

            FreeSpace -= AttributeListReservation;
        }
    }

    // The new record can go in this FRS if the client has not
    // requested that it be made external, if there's sufficient
    // room for it, and if there is no collision with other records
    // for this attribute.
    //
   if( !ForceExternal &&
        NewRecord->QueryRecordLength() <= FreeSpace &&
        ( NewRecord->IsResident() || !MatchPresent ) ) {

        // There's enough free space for the new record, so it'll
        // go in this FRS.  Attach the current Next Instance tag
        // to this attribute record and increment the tag.
        //
        NewRecord->SetInstanceTag( QueryNextInstance() );
        IncrementNextInstance();

        // Scan through the list of records to find the point
      // at which we should insert it.
        //
      CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
             CurrentRecord.QueryTypeCode() != $END &&
             CompareAttributeRecords( &CurrentRecord,
                                        NewRecord,
                                        GetUpcaseTable() ) <= 0 ) {

            if( CurrentRecord.QueryRecordLength() == 0 ) {

                // Corrupt FRS.
                //
                return FALSE;
            }

         // Go on to the next record

         CurrentRecordOffset += CurrentRecord.QueryRecordLength();
      }

      // We want to insert the new record at CurrentRecordOffset;
      // make room for it there and copy it in.

      memmove( (PBYTE)_FrsData + CurrentRecordOffset +
                           NewRecord->QueryRecordLength(),
                 (PBYTE)_FrsData + CurrentRecordOffset,
                 _FrsData->FirstFreeByte - CurrentRecordOffset);

        _FrsData->FirstFreeByte += NewRecord->QueryRecordLength();

      memcpy( (PBYTE)_FrsData + CurrentRecordOffset,
            NewRecord->GetData(),
            (UINT) NewRecord->QueryRecordLength() );

        // if this File Record Segment has an attribute list, then
        // we add an entry to it for the attribute record we just added.
        // Note that we can safely assume that an attribute list is
        // present if and only if _AttributeList is non-NULL because
        // we made sure we had read it at the beginning of this method.

        if( _AttributeList != NULL &&
            NewRecord->QueryTypeCode() != $ATTRIBUTE_LIST ) {

            SegmentReference = QuerySegmentReference();

            if (!NewRecord->QueryName(&NewName) ||
                !_AttributeList->AddEntry(NewRecord->QueryTypeCode(),
                                          NewRecord->QueryLowestVcn(),
                                          &SegmentReference,
                                          NewRecord->QueryInstanceTag(),
                                          &NewName)) {

                // So near and yet so far.  We have to back all the
                // way out because we couldn't add an entry for this
                // record to the attribute list.

                memmove( (PBYTE)_FrsData + CurrentRecordOffset,
                         (PBYTE)_FrsData + CurrentRecordOffset +
                                            NewRecord->QueryRecordLength(),
                         _FrsData->FirstFreeByte -
                            (CurrentRecordOffset +
                             NewRecord->QueryRecordLength()) );

                _FrsData->FirstFreeByte -= NewRecord->QueryRecordLength();

                return FALSE;
            }
        }

        Result = TRUE;

    } else if( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
               NewRecord->QueryTypeCode() == $DATA &&
               NewRecord->QueryLowestVcn() == 0 ) {

        // The first chunk of the MFT's $DATA attribute must
        // be in the base File Record Segment.  Evict as many
        // other records as possible.
        //
        if( (TempRecordData = (PATTRIBUTE_RECORD_HEADER)
                              MALLOC( QuerySize() )) == NULL ) {

            DebugPrint( "UNTFS: Can't allocate memory for temporary attribute record.\n" );
            return FALSE;
        }

        EvicteeData = (PATTRIBUTE_RECORD_HEADER)GetNextAttributeRecord( NULL );

        while( EvicteeData != NULL &&
               EvicteeData->TypeCode != $END ) {

            // If this is not an attribute record we can evict,
            // then skip over it; otherwise, move it to a child
            // FRS.  Note that we don't check for the first chunk
            // of the $DATA attribute becuase, after all, that's
            // what we're inserting.
            //
            if( EvicteeData->TypeCode == $STANDARD_INFORMATION ||
                EvicteeData->TypeCode == $ATTRIBUTE_LIST ) {

                EvicteeData = (PATTRIBUTE_RECORD_HEADER)
                              GetNextAttributeRecord( EvicteeData );

            } else {

                // Copy this record to the temporary buffer and
                // delete it from the FRS.
                //
                memcpy( TempRecordData,
                        EvicteeData,
                        EvicteeData->RecordLength );

                if( !TempRecord.Initialize( GetDrive(), TempRecordData ) ) {

                    FREE( TempRecordData );
                    return FALSE;
                }

                DeleteAttributeRecord( EvicteeData );

                // Delete the attribute list entry that corresponds
                // to this attribute record.
                //
                if( _AttributeList != NULL ) {

                    ATTR_LIST_CURR_ENTRY    Entry;

                    Entry.CurrentEntry = NULL;
                    while( _AttributeList->QueryNextEntry( &Entry,
                                                           &CheckType,
                                                           &CheckVcn,
                                                           &CheckSegment,
                                                           &CheckInstance,
                                                           &CheckName ) ) {

                        // It's enough to establish a match if the
                        // segment reference and instance tag match,
                        // but we'll throw in a check for the type
                        // code just to be safe.
                        //
                        if( CheckType == TempRecord.QueryTypeCode() &&
                            CheckInstance == TempRecord.QueryInstanceTag() &&
                            CheckSegment == QuerySegmentReference() ) {

                            _AttributeList->DeleteCurrentEntry( &Entry );
                            break;
                        }
                    }
                }

                // Insert this record into a child FRS.
                //
                if( !InsertExternalAttributeRecord( &TempRecord ) ) {

                    FREE( TempRecordData );
                    return FALSE;
                }

                // No need to advance EvicteeData, since
                // DeleteAttributeRecord will bring the next
                // one down to us.
            }

        }

        FREE( TempRecordData );

        // OK, we've made as much free space as possible.  Recompute
        // the free space; if it's enough, insert the record recursively.
        // Since we only recurse if there's enough free space, and
        // we only fall into this branch if there isn't enough space,
        // we won't get infinite recursion.
        //
        FreeSpace = QueryFreeSpace();

        if( FreeSpace < AttributeListReservation ) {

            FreeSpace = 0;

        } else {

            FreeSpace -= AttributeListReservation;
        }

        if( FreeSpace > NewRecord->QueryRecordLength() ) {

            // It'll fit--go ahead and insert it.
            //
            return( InsertAttributeRecord( NewRecord, FALSE ) );

        } else {

            return FALSE;

        }

    } else {

        // This attribute will be external.  Call the private worker
        // method.

        Result = InsertExternalAttributeRecord( NewRecord );
    }

    //  If this is a base file record segment and we've successfully
    //  inserted an indexed attribute, increment the reference count.

    if( Result &&
        IsBase() &&
        NewRecord->IsResident() &&
        (NewRecord->QueryResidentFlags() & RESIDENT_FORM_INDEXED ) ) {

        _FrsData->ReferenceCount += 1;
    }

    return Result;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::InsertExternalAttributeRecord(
    IN  PNTFS_ATTRIBUTE_RECORD NewRecord
    )
/*++

Routine Description:

    This method adds an external attribute record to the File Record
    Segment.  It is a private worker for InsertAttributeRecord.  (It
    can also be used to move attribute records out of the base segment).

    Note that it is nonvirtual--once the File Record Segment has decided
    to make the attribute record external, it's done the same way for
    all types of File Record Segments.

Arguments:

   AttributeRecord   -- supplies the attribute record to insert

Return Value:

    TRUE upon successful completion.

Notes:

    The Attribute List and Standard Information attributes cannot
    be made external; this method enforces that restriction.


--*/
{
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    MFT_SEGMENT_REFERENCE SegmentReference;
    VCN ChildFileNumber;
    ATTRIBUTE_TYPE_CODE TypeCode;
    VCN LowestVcn;
    DSTRING Name;
    USHORT Instance;
    BOOLEAN IsMft, IsMftData;
    ATTR_LIST_CURR_ENTRY    Entry;

    ULONG cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();


    IsMft = ( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER );
    IsMftData = IsMft && ( NewRecord->QueryTypeCode() == $DATA );

    // the standard information and attribute list attributes cannot
    // be made external.

    if( NewRecord->QueryTypeCode() == $STANDARD_INFORMATION ||
        NewRecord->QueryTypeCode() == $ATTRIBUTE_LIST ) {

        return FALSE;
    }

    // The Log File cannot have any external attributes.
    //
    if( !IsBase() &&
        QueryFileNumber() == LOG_FILE_NUMBER ) {

        return FALSE;
    }

    // Note that only Base File Record Segments can have attribute lists.

    if( !IsBase() || !SetupAttributeList() ) {

        return FALSE;
    }

    // OK, at this point, _AttributeList is NULL if and only if
    // the File Record Segment has no attribute list.  If the File
    // Record Segment has no attribute list, we need to create one.

    if (_AttributeList == NULL) {

        if (!(_AttributeList = NEW NTFS_ATTRIBUTE_LIST) ||
            !CreateAttributeList(_AttributeList)) {

            // We can't create an attribute list for this File Record
            // Segment.

            DELETE(_AttributeList);
            return FALSE;
        }
    }

    // Since this is a somewhat rare case, we can indulge ourselves
    // a bit.  Go through the Attribute List and force all the
    // children of this File Record Segment into memory.

    Entry.CurrentEntry = NULL;
    while (_AttributeList->QueryNextEntry( &Entry,
                                           &TypeCode,
                                           &LowestVcn,
                                           &SegmentReference,
                                           &Instance,
                                           &Name )) {

        ChildFileNumber.Set( SegmentReference.LowPart,
                             (LONG) SegmentReference.HighPart );

        if( ChildFileNumber != QueryFileNumber() &&
            SetupChild( ChildFileNumber ) == NULL ) {

            // Error.
            return FALSE;
        }
    }


    // Now go down the list of children and see if any of them
    // will accept this record.  Note that if this is the MFT
    // $DATA attribute, we must check each child before we try
    // to use it to make sure we don't break the bootstrap.
    // we much check each child
    //
    _ChildIterator->Reset();

    while( (ChildFrs =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL ) {

        // The MFT requires special handling.  Records for the data
        // attribute must be inserted into child FRS' in a way that
        // preserves the MFT's bootstrapping, ie. the starting VCN of
        // the record must be greater than the VCN (file number times
        // clusters per FRS) of the child.  In addition, $DATA records
        // cannot share a child FRS with any other attribute records.
        //
        if( IsMft ) {

            if (IsMftData &&
                ( ChildFrs->GetNextAttributeRecord( NULL ) != NULL ||
                  NewRecord->QueryLowestVcn() * cluster_size <=
                        ChildFrs->QueryFileNumber() * QuerySize())) {

                // Either this child FRS is not empty, or
                // inserting this record into it will break
                // the MFT's bootstrapping.  Either way,
                // it can't accept this record.
                //
                continue;
            }

            if( ChildFrs->IsAttributePresent( $DATA ) ) {

                // This child FRS already has a $DATA attribute
                // record, so it can't accept any other records.
                //
                continue;
            }
        }

        // This child FRS is eligible to hold this attribute record.
        //
        if( ChildFrs->InsertAttributeRecord( NewRecord ) ) {

            // Success!  Add an appropriate entry to the
            // attribute list.
            //
            SegmentReference = ChildFrs->QuerySegmentReference();

            if( !NewRecord->QueryName( &Name ) ||
                !_AttributeList->AddEntry( NewRecord->QueryTypeCode(),
                                           NewRecord->QueryLowestVcn(),
                                           &SegmentReference,
                                           NewRecord->QueryInstanceTag(),
                                           &Name ) ) {

                DebugPrintTrace(( "UNTFS: Can't add entry to attribute list." ));
                return FALSE;
            }

            return TRUE;
        }
    }

    // We have to allocate a new child File Record Segment.  If
    // This is the MFT File, see if we can grab the reserved FRS.
    //
    if( IsMftData &&
        GetChild( MFT_OVERFLOW_FRS_NUMBER ) == NULL ) {

        // This FRS is the MFT, and it hasn't already grabbed
        // the reserved FRS--grab it now.
        //
        ChildFileNumber = MFT_OVERFLOW_FRS_NUMBER;

    } else if( !_Mft->AllocateFileRecordSegment( &ChildFileNumber, IsMftData ) ) {

        // Can't get a new child File Record Segment.

        return FALSE;
    }

    // Set up the Segment Reference to refer to the Base File
    // Record Segment, ie. this File Record Segment.
    //
    SegmentReference = QuerySegmentReference();

    // Construct the new child File Record Segment and insert
    // the attribute record into it.  Again, make sure we don't
    // violate the MFT bootstrapping requirements.  (Note that
    // we don't have to check the sharing rule for the MFT data
    // attribute because this is a new FRS--it can't contain
    // any conflicting records.
    //
    if( (ChildFrs = NEW NTFS_FILE_RECORD_SEGMENT) == NULL ||
        !ChildFrs->Initialize( ChildFileNumber, _Mft )    ||
        !ChildFrs->Create( &SegmentReference )            ||
        ( IsMftData &&
          NewRecord->QueryLowestVcn() * cluster_size <=
            ChildFrs->QueryFileNumber() * QuerySize() ) ||
        !ChildFrs->InsertAttributeRecord( NewRecord )   ||
        !AddChild( ChildFrs ) ) {

        // That didn't do us any good at all.  Clean up the child
        // and return our failure.

        DELETE( ChildFrs );
        _Mft->FreeFileRecordSegment( ChildFileNumber );

        return FALSE;
    }

    // Note that the Child File Record Segment has passed into the
    // keeping of the children list, so we don't delete it.
    //
    // Add an entry to the attribute list for the new record.
    //
    SegmentReference = ChildFrs->QuerySegmentReference();

    if( !NewRecord->QueryName( &Name ) ||
        !_AttributeList->AddEntry( NewRecord->QueryTypeCode(),
                                   NewRecord->QueryLowestVcn(),
                                   &SegmentReference,
                                   NewRecord->QueryInstanceTag(),
                                   &Name ) ) {

        DebugPrintTrace(( "UNTFS: Can't add entry to attribute list." ));
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Write(
   )
/*++

Routine Description:

    This method writes the File Record Segment.  It does not affect the
    attribute list or the child record segments.

Arguments:

    None.

Return Value:

   TRUE upon successful completion.

--*/
{
   return( NTFS_FRS_STRUCTURE::Write() );
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Flush(
    IN OUT PNTFS_BITMAP     VolumeBitmap,
    IN OUT PNTFS_INDEX_TREE ParentIndex,
    IN     BOOLEAN          FrsIsEmpty
    )
/*++

Routine Description:

    This method is used to commit a file to disk.  It saves the attribute
    list, writes any child record segments that have been brought into
    memory, and writes the File Record Segment itself.

Arguments:

    VolumeBitmap    --  Supplies the volume bitmap.  This parameter may
                        be NULL, in which case non-resident attributes
                        cannot be resized.
    ParentIndex     --  Supplies the directory which indexes this FRS
                        over $FILE_NAME.  May be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    DUPLICATED_INFORMATION      DuplicatedInformation;
    PNTFS_FILE_RECORD_SEGMENT   CurrentChild, ChildToDelete;

    // If this is a child FRS, just write it.
    //
    if( !IsBase() ) {

        return( Write() );
    }

    // This FRS is a Base File Record Segment--it may have
    // an attribute list and children, and we have to update
    // the file-name information in the parent index.
    //

    if( !FrsIsEmpty && _AttributeList != NULL &&
        !SaveAttributeList( VolumeBitmap ) ) {

        return FALSE;
    }

    // Update the file name attributes:

    if ( !FrsIsEmpty )
        if( !QueryDuplicatedInformation( &DuplicatedInformation ) ||
            !UpdateFileNames( &DuplicatedInformation, ParentIndex, FALSE ) ) {

            DebugAbort( "Can't update file names in Flush.\n" );
            return FALSE;
        }

    // Flush all the children.  If a child is empty, mark it as
    // unused.
    //
    _ChildIterator->Reset();

    while( (CurrentChild = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

        if( !CurrentChild->GetNextAttributeRecord( NULL ) ) {


            // This child has no attribute records--we don't
            // need it anymore.
            //
            CurrentChild->ClearInUse();
            CurrentChild->Write();
            _Mft->FreeFileRecordSegment( CurrentChild->QueryFileNumber() );
            ChildToDelete = (PNTFS_FILE_RECORD_SEGMENT)_Children.Remove(_ChildIterator);
            DebugAssert(ChildToDelete == CurrentChild);
            DELETE(ChildToDelete);
            CurrentChild = NULL;
            _ChildIterator->Reset();

        } else if( !CurrentChild->Flush( VolumeBitmap ) ) {

            return FALSE;
        }
    }

    return( Write() );
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryNextAttribute(
    IN  PATTRIBUTE_TYPE_CODE    TypeCode,
    IN  PWSTRING                Name
    )
/*++

Routine Description:

    This method finds the first (attribute type, name) pair in this
    file which is greater than (TypeCode, Name).  Note that it will
    not return the ATTRIBUTE_LIST, if one is present.

Arguments:

    TypeCode    --  supplies the current attribute type code.  Receives
                    the type code of the next attribute.  A returned type
                    code of $END indicates that there are no more attributes.
    Name        --  supplies the current name.  Receives the name of the
                    next attribute.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is useful for iterating through the non-indexed
    attributes of a file, since there can only be one non-indexed
    attribute with a given type code and name in the file.  However,
    it offers no way of dealing with indexed attributes, which may
    be distinguished only by value.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    ULONG CurrentRecordOffset;
    PWSTR NameBuffer = NULL;
    ULONG NameLength;

    DebugAssert( Name );


    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( _AttributeList != NULL ) {

        return( _AttributeList->QueryNextAttribute( TypeCode, Name ) );
    }

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    NameLength = Name->QueryChCount();
    NameBuffer = Name->QueryWSTR();

    if( NameBuffer == NULL ) {

        return FALSE;
    }


    // Start at the first attribute record, and iterate forward from
    // there.

   CurrentRecordOffset = _FrsData->FirstAttributeOffset;

   while( CurrentRecordOffset < QuerySize() ) {

        if( !CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) ) {

            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }

            return FALSE;
        }


        if( CurrentRecord.QueryTypeCode() == $END ||
            CurrentRecord.QueryTypeCode() > *TypeCode ) {

            // Either we're at the end of the list, or we've found
            // an attribute with a type code greater than *TypeCode--
            // either way, we've succeeded.

            break;
        }

        if( CurrentRecord.QueryTypeCode() == *TypeCode ) {

            // This record has the same type code as current
            // type, so we have to compare names.

            if( CurrentRecord.QueryNameLength() > 0 &&
                CountedWCMemCmp( NameBuffer,
                                 NameLength,
                                 CurrentRecord.GetName(),
                                 CurrentRecord.QueryNameLength() ) > 0 ) {

                // This record has a name which is greater than
                // Name, so we're done.

                break;
            }
        }

        // Go on to the next record
        //
        if( CurrentRecord.QueryRecordLength() == 0 ) {

            // Corrupt FRS.
            //
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }

      CurrentRecordOffset += CurrentRecord.QueryRecordLength();
   }

    // Check for overflow.

    if( CurrentRecordOffset >= QuerySize() ) {

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }
        return FALSE;
    }

    // Copy the output parameters.

    *TypeCode = CurrentRecord.QueryTypeCode();

    if( *TypeCode != $END ) {

        if (!CurrentRecord.QueryName(Name)) {
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }

    } else {

        if (!Name->Initialize("")) {
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }
    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::RecoverFile(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusterList,
    IN     UCHAR        VolumeMajorVersion,
    OUT    PULONG       BadClusters,
    OUT    PBIG_INT     BytesRecovered,
    OUT    PBIG_INT     TotalBytes
    )
/*++

Routine Description:

    This method performs recovery on a file record segment.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusterFile  --  supplies the volume's bad-cluster file
    BadClusters     --  receives the number of bad clusters found in
                        attributes associated with this object.
    BytesRecovered  --  bytes recovered in all attributes subject to
                        recovery.
    TotalBytes      --  total bytes in attributes subject to recovery.

Notes:

    $DATA is the only system-defined attribute which is recovered.
    problems with other system-defined attributes must be handled by
    CHKDSK.

--*/
{
    NTFS_ATTRIBUTE CurrentAttribute;
    NUMBER_SET BadClusterNumSet;

    ATTRIBUTE_TYPE_CODE CurrentAttributeTypeCode;
    DSTRING CurrentAttributeName;
    BIG_INT CurrentBytesRecovered;

    BOOLEAN Error, Modified;

    DebugAssert(IsInUse());
    DebugAssert(IsBase());


    Modified = FALSE;

    if( !BadClusterNumSet.Initialize() ) {

        return FALSE;
    }


    // Force the attribute list, if we have one, into memory.

    if( !SetupAttributeList() ) {

        return FALSE;
    }


    if (!CurrentAttributeName.Initialize("")) {
        return FALSE;
    }


    CurrentAttributeTypeCode = $STANDARD_INFORMATION;

    *BytesRecovered = 0;
    *TotalBytes = 0;

    while( TRUE ) {

        // Determine the type code and name of the next attribute
        // to recover.

        if( !QueryNextAttribute( &CurrentAttributeTypeCode,
                                 &CurrentAttributeName ) ) {

            return FALSE;
        }


        // Are we done yet?

        if( CurrentAttributeTypeCode == $END ) {

            break;
        }

        // System defined attributes other than $DATA are not
        // recovered.

        if( ((VolumeMajorVersion >= 2) ?
             (CurrentAttributeTypeCode < $FIRST_USER_DEFINED_ATTRIBUTE_2) :
             (CurrentAttributeTypeCode <    $FIRST_USER_DEFINED_ATTRIBUTE_1)) &&
            CurrentAttributeTypeCode != $DATA ) {

            continue;
        }


        // Recover the attribute we decided to recover.

        if( !QueryAttribute( &CurrentAttribute,
                             &Error,
                             CurrentAttributeTypeCode,
                             &CurrentAttributeName ) ||
            !CurrentAttribute.RecoverAttribute( VolumeBitmap,
                                                &BadClusterNumSet,
                                                &CurrentBytesRecovered )) {

            return FALSE;
        }

        *BytesRecovered += CurrentBytesRecovered;
        *TotalBytes += CurrentAttribute.QueryValueLength();

        // If the attribute's storage has been modified, I have
        // to save the attribute.

        if( CurrentAttribute.IsStorageModified() ) {

            Modified = TRUE;
            if( !CurrentAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

                return FALSE;
            }
        }
    }

    DebugAssert(BadClusterNumSet.QueryCardinality().GetHighPart() == 0);

    *BadClusters = BadClusterNumSet.QueryCardinality().GetLowPart();

    if( *BadClusters != 0 ) {

        BadClusterList->Add( &BadClusterNumSet );

    }

    // If any of the attributes have been modified, flush the FRS.
    //
    if( Modified && !Flush( VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}


NTFS_SORT_CODE
NTFS_FILE_RECORD_SEGMENT::SortIndex(
    IN     PCWSTRING    IndexName,
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      DuplicatesAllowed,
    IN     BOOLEAN      CheckOnly
    )
/*++

Routine Description:

    This method sorts an index tree associated with the File
    Record Segment.

Arguments:

    IndexName           --  Supplies the name of the index.
    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.
    DuplicatesAllowed   --  Supplies a flag that indicates whether this
                            index tolerates duplicate entries.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_SORT_INDEX_NOT_FOUND       --  this FRS does not contain an
                                            index with the specified name.
        NTFS_SORT_INDEX_WELL_ORDERED    --  the index was not sorted because
                                            it was found to be well-ordered.
        NTFS_SORT_INDEX_BADLY_ORDERED   --  The index was found to be badly
                                            ordered, and it was not sorted.
        NTFS_SORT_INDEX_SORTED          --  The index was sorted and new
                                            attributes were inserted into
                                            the FRS.
        NTFS_INSERT_FAILED              --  An insertion of an index entry
                                            into the new tree failed.
                                            (Probable cause:  out of space.)
        NTFS_SORT_ERROR                 --  Sort failed because of an error.


--*/
{
    NTFS_INDEX_TREE OldTree, NewTree;

    PCINDEX_ENTRY   CurrentEntry;
    PINDEX_ENTRY    NewEntry;

    ULONG           Depth;
    BOOLEAN         Error;

    MFT_SEGMENT_REFERENCE SegmentReference;

    DebugPtrAssert( VolumeBitmap );

    // Get the existing index out of the FRS.

    if( !OldTree.Initialize( GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             QuerySize()/2,
                             this,
                             IndexName ) ) {

        return NTFS_SORT_INDEX_NOT_FOUND;
    }

    // Determine whether the index needs to be sorted:

    if( !OldTree.IsBadlyOrdered( &Error, DuplicatesAllowed ) ) {

        if( Error ) {

            // We could not determine whether the index was
            // badly ordered.

            return NTFS_SORT_ERROR;

        } else {

            // The index is well-ordered, so there's nothing to do.
            //
            return NTFS_SORT_INDEX_WELL_ORDERED;
        }
    }

    if( CheckOnly ) {

        // The client doesn't want us to actually sort the index,
        // just to determine whether it's badly ordered.

        return NTFS_SORT_INDEX_BADLY_ORDERED;
    }

    // The index is badly ordered, and the client wants us to
    // sort it.  Initialize a new index tree:
    //
    if( !NewTree.Initialize( OldTree.QueryIndexedAttributeType(),
                             GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             OldTree.QueryCollationRule(),
                             OldTree.QueryBufferSize(),
                             QuerySize()/2,
                             IndexName ) ) {

        // Couldn't initialize a new index.
        //
        return NTFS_SORT_ERROR;
    }

    // Iterate through the entries in the old tree, copying them
    // (by value) into the new tree.
    //
    OldTree.ResetIterator();

    while( (CurrentEntry = OldTree.GetNext( &Depth, &Error )) != NULL ) {

        if( !DuplicatesAllowed &&
            NewTree.QueryFileReference( CurrentEntry->AttributeLength,
                                        GetIndexEntryValue( CurrentEntry ),
                                        0,
                                        &SegmentReference,
                                        &Error ) ) {

            // This index does not tolerate duplicate entries; since
            // an entry with the very same name as this one has already
            // been added to the tree, we're skipping this one.
            //
            continue;
        }

        if (CurrentEntry->Length <
            (sizeof(INDEX_ENTRY)+CurrentEntry->AttributeLength)) {
            continue;   // skip bad entry
        }

        if (!(NewEntry = (PINDEX_ENTRY)MALLOC(CurrentEntry->Length))) {
            NewTree.FreeAllocation();
            return NTFS_SORT_ERROR;
        }

        memcpy(NewEntry, CurrentEntry, CurrentEntry->Length);

        if (NewEntry->Flags & INDEX_ENTRY_NODE)
            NewEntry->Length -= sizeof(VCN);
        NewEntry->Flags = 0;

        if( !NewTree.InsertEntry( NewEntry )) {

            NewTree.FreeAllocation();
            FREE( NewEntry );
            return NTFS_SORT_INSERT_FAILED;
        }
        FREE( NewEntry );
    }

    if( Error ) {

        // An error occurred while traversing the old tree.

        NewTree.FreeAllocation();
        return NTFS_SORT_ERROR;
    }

    // We've constructed the new index--save it into this FRS to
    // replace the old one.
    //
    if( !NewTree.Save( this ) ) {

        NewTree.FreeAllocation();
        return NTFS_SORT_ERROR;
    }

    // Clean up the old tree.

    OldTree.FreeAllocation();

    return NTFS_SORT_INDEX_SORTED;
}

NTFS_QUOTA_CODE
NTFS_FILE_RECORD_SEGMENT::VerifyAndFixQuotaDefaultId(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      CheckOnly
    )
/*++

Routine Description:

    This method verifies that the default quota ID exists inside the
    Userid2SidQuotaNameData Index.

Arguments:

    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_QUOTA_INDEX_NOT_FOUND      --  this FRS does not contain an
                                            index with the specified name.
        NTFS_QUOTA_DEFAULT_ENTRY_MISSING--  the default entry was not found
                                            in the index
        NTFS_QUOTA_INDEX_FOUND          --  Found the default Id entry in the
                                            index tree.
        NTFS_QUOTA_INDEX_INSERTED       --  Inserted the default Id entry into
                                            the index tree.
        NTFS_QUOTA_INSERT_FAILED        --  An insertion of the default Id
                                            entry into the index tree failed.
                                            (Probable cause:  out of space.)
        NTFS_QUOTA_ERROR                --  error occurred.  (Possibly out
                                            of memory or out of space.)


--*/
{
    NTFS_INDEX_TREE     OldTree;
    PINDEX_ENTRY        FoundEntry, NewEntry;
    PNTFS_INDEX_BUFFER  ContainingBuffer;
    PQUOTA_USER_DATA    QuotaUserData;
    BOOLEAN             Error;
    DSTRING             IndexName;
    ULONG               Key;
    USHORT              length;

    DebugPtrAssert( VolumeBitmap );

    // Get the existing index out of the FRS.

    if (!IndexName.Initialize(Userid2SidQuotaNameData) ||
        !OldTree.Initialize( GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             QuerySize()/2,
                             this,
                             &IndexName ) ) {
        return NTFS_QUOTA_INDEX_NOT_FOUND;   // index not found
    }

    // Search the index for the QUOTA_DEFAULTS_ID record

    Key = QUOTA_DEFAULTS_ID;

    if (!OldTree.QueryEntry(sizeof(ULONG),
                            &Key,
                            0,
                            &FoundEntry,
                            &ContainingBuffer,
                            &Error
                            )) {

        // The default entry not found, let inserts a new one in

        if (ContainingBuffer)
            DELETE(ContainingBuffer);

        if (CheckOnly)
            return NTFS_QUOTA_DEFAULT_ENTRY_MISSING;

        length = QuadAlign(sizeof(INDEX_ENTRY) +
                           sizeof(ULONG) +
                           SIZEOF_QUOTA_USER_DATA);
        if (!(NewEntry = (PINDEX_ENTRY)MALLOC(length)))
            return NTFS_QUOTA_ERROR;

        memset(NewEntry, 0, length);

        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(ULONG);
        NewEntry->DataLength = SIZEOF_QUOTA_USER_DATA;
        NewEntry->Length = length;
        NewEntry->AttributeLength = sizeof(ULONG);
        NewEntry->Flags = 0;

        *((ULONG*)GetIndexEntryValue(NewEntry)) = QUOTA_DEFAULTS_ID;

        QuotaUserData = (PQUOTA_USER_DATA)((char*)GetIndexEntryValue(NewEntry) + sizeof(ULONG));
        memset(QuotaUserData, 0, SIZEOF_QUOTA_USER_DATA);

        QuotaUserData->QuotaVersion = QUOTA_USER_VERSION;
        QuotaUserData->QuotaFlags = QUOTA_FLAG_DEFAULT_LIMITS |
                                    QUOTA_FLAG_OUT_OF_DATE;

        QuotaUserData->QuotaThreshold = MAXULONGLONG;
        QuotaUserData->QuotaLimit = MAXULONGLONG;
        NtQuerySystemTime((PLARGE_INTEGER)&(QuotaUserData->QuotaChangeTime));

        if ( !OldTree.InsertEntry( NewEntry )) {
            FREE( NewEntry );
            return NTFS_QUOTA_INSERT_FAILED;
        }

        FREE( NewEntry );

        //
        // replace the old one.
        //
        if( !OldTree.Save( this ) ) {

            return NTFS_QUOTA_ERROR;
        }

        return NTFS_QUOTA_INDEX_INSERTED;

    } else {

        if (ContainingBuffer)
            DELETE(ContainingBuffer);

        return NTFS_QUOTA_INDEX_FOUND;
    }
}


NTFS_SECURITY_CODE
NTFS_FILE_RECORD_SEGMENT::FindSecurityIndexEntryAndValidate(
    IN OUT PNTFS_INDEX_TREE             OldTree,
    IN     PVOID                        Key,
    IN     USHORT                       KeyLength,
    IN     PSECURITY_DESCRIPTOR_HEADER  SecurityDescriptorHeader,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    IN     BOOLEAN                      CheckOnly
    )
/*++

Routine Description:

    This method verifies that the given key exists in the specified
    index and that the given security descriptor header matches
    the data in the index entry.  If the given key does not exists
    in the index, one will be inserted into it.

Arguments:

    Key                 --  supplies the search key value
    KeyLength           --  supplies the length of the search key value
    SecurityDescriptorHeader
                        --  supplies the data portion of the index entry
    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_SECURITY_INDEX_ENTRY_MISSING  --  the specified index entry key
                                               cannot be found in the index
        NTFS_SECURITY_INDEX_FOUND          --  the found entry contains
                                               correct data
        NTFS_SECURITY_INDEX_FIXED          --  the found entry contains invalid
                                               data but is now corrected
        NTFS_SECURITY_INDEX_DATA_ERROR     --  The index was found but the data
                                               data in it is incorrect.
        NTFS_SECURITY_INDEX_INSERTED       --  An index was successfully inserted
                                               into the specified index.
        NTFS_SECURITY_INSERT_FAILED        --  An insertion of an index entry
                                               into the index tree failed.
                                               (Probable cause:  out of space.)
        NTFS_SECURITY_ERROR                --  failed because of an error.
                                               (Probably out of memory or out
                                               of space.)


--*/
{
    PINDEX_ENTRY        foundEntry, newEntry;
    PNTFS_INDEX_BUFFER  containingBuffer;
    BOOLEAN             error;
    USHORT              length;

    DebugPtrAssert( VolumeBitmap );

    // Search the index for the given Key

    if (!OldTree->QueryEntry(KeyLength,
                            Key,
                            0,
                            &foundEntry,
                            &containingBuffer,
                            &error
                            )) {

        if (containingBuffer)
            DELETE(containingBuffer);

        // The entry not found, let inserts a new one in

        if (CheckOnly)
            return NTFS_SECURITY_INDEX_ENTRY_MISSING;

        length = QuadAlign(sizeof(INDEX_ENTRY) +
                                     KeyLength +
                                     sizeof(SECURITY_DESCRIPTOR_HEADER));

        if (!(newEntry = (PINDEX_ENTRY)MALLOC(length)))
            return NTFS_SECURITY_ERROR;

        memset((PVOID)newEntry, 0, length);

        newEntry->DataOffset = sizeof(INDEX_ENTRY)+KeyLength;
        newEntry->DataLength = sizeof(SECURITY_DESCRIPTOR_HEADER);
        newEntry->Length = length;
        newEntry->AttributeLength = KeyLength;
        newEntry->Flags = 0;

        memcpy(GetIndexEntryValue(newEntry), Key, KeyLength);
        memcpy((PCHAR)GetIndexEntryValue(newEntry) + KeyLength,
               (PCHAR)SecurityDescriptorHeader,
               sizeof(SECURITY_DESCRIPTOR_HEADER));

        if ( !OldTree->InsertEntry( newEntry )) {
            FREE( newEntry );
            return NTFS_SECURITY_INSERT_FAILED;
        }

        FREE( newEntry );

        //
        // replace the old one.
        //
        if( !OldTree->Save( this ) ) {

            return NTFS_SECURITY_ERROR;
        }

        return NTFS_SECURITY_INDEX_INSERTED;

    } else {

        if (memcmp((PCHAR)GetIndexEntryValue(foundEntry)+KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER))) {

           if (CheckOnly) {
               if (containingBuffer)
                   DELETE(containingBuffer);
               return NTFS_SECURITY_INDEX_DATA_ERROR;
           }

            memcpy((PCHAR)GetIndexEntryValue(foundEntry)+KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER));

           if (containingBuffer)
               DELETE(containingBuffer);

            if (!OldTree->DeleteEntry(KeyLength, Key, 0)) {
                return NTFS_SECURITY_ERROR;
            }

            length = QuadAlign(sizeof(INDEX_ENTRY) +
                               KeyLength +
                               sizeof(SECURITY_DESCRIPTOR_HEADER));

            if (!(newEntry = (PINDEX_ENTRY)MALLOC(length)))
                return NTFS_SECURITY_ERROR;

            memset((PVOID)newEntry, 0, length);

            newEntry->DataOffset = sizeof(INDEX_ENTRY)+KeyLength;
            newEntry->DataLength = sizeof(SECURITY_DESCRIPTOR_HEADER);
            newEntry->Length = length;
            newEntry->AttributeLength = KeyLength;
            newEntry->Flags = 0;

            memcpy(GetIndexEntryValue(newEntry), Key, KeyLength);
            memcpy((PCHAR)GetIndexEntryValue(newEntry) + KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER));

            if ( !OldTree->InsertEntry( newEntry )) {
                FREE( newEntry );
                return NTFS_SECURITY_INSERT_FAILED;
            }

           FREE( newEntry );

           if (!OldTree->Save(this)) {
               return NTFS_SECURITY_ERROR;
           }

            return NTFS_SECURITY_INDEX_FIXED;
        }

        if (containingBuffer)
           DELETE(containingBuffer);

        return NTFS_SECURITY_INDEX_FOUND;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryDuplicatedInformation(
    OUT PDUPLICATED_INFORMATION DuplicatedInformation
    )
/*++

Routine Description:

    This method queries the FRS for the information which is
    duplicated in File Name attributes.

Arguments:

    DuplicatedInformation   --  Receives the duplicated information.

Return Value:

    TRUE upon successful completion.


--*/
{
    NTFS_ATTRIBUTE          Attribute;
    STANDARD_INFORMATION    StandardInformation;
    EA_INFORMATION          EaInformation;
    REPARSE_DATA_BUFFER     reparse_point;
    ULONG                   BytesRead, ClusterSize;
    BOOLEAN                 Error;

    // Start with a clean slate:
    //
    memset( DuplicatedInformation, 0, sizeof( DUPLICATED_INFORMATION ) );

    // Most of the duplicated information comes from the
    // Standard Information attribute.
    //
    if( !QueryAttribute( &Attribute,
                         &Error,
                         $STANDARD_INFORMATION ) ||
        !Attribute.Read( &StandardInformation,
                         0,
                         sizeof( STANDARD_INFORMATION ),
                         &BytesRead ) ||
        BytesRead != sizeof( STANDARD_INFORMATION ) ) {

        DebugPrintTrace(( "Can't fetch standard information.\n" ));
        return FALSE;
    }

    DuplicatedInformation->CreationTime =
                        StandardInformation.CreationTime;
    DuplicatedInformation->LastModificationTime =
                        StandardInformation.LastModificationTime;
    DuplicatedInformation->LastChangeTime =
                        StandardInformation.LastChangeTime;
    DuplicatedInformation->LastAccessTime  =
                        StandardInformation.LastAccessTime;

    DuplicatedInformation->FileAttributes = StandardInformation.FileAttributes;

    if( _FrsData->Flags & FILE_FILE_NAME_INDEX_PRESENT ) {

        DuplicatedInformation->FileAttributes |= DUP_FILE_NAME_INDEX_PRESENT;
    }

    if( _FrsData->Flags & FILE_VIEW_INDEX_PRESENT ) {

        DuplicatedInformation->FileAttributes |= DUP_VIEW_INDEX_PRESENT;
    }

    // We also need one field from the EA_INFORMATION attribute
    // or the REPARSE_POINT attribute.
    //
    if( !QueryAttribute( &Attribute, &Error, $EA_INFORMATION )) {

        if( Error ) {

            // The Ea Information attribute is present, but we
            // couldn't get it.  Bail out.
            //
            DebugAbort( "Error fetching Ea Information attribute.\n" );
            return FALSE;

        } else if (!QueryAttribute( &Attribute, &Error, $REPARSE_POINT )) {

            if( Error ) {

                // The Reparse Point attribute is present, but we
                // couldn't get it.  Bail out.
                //
                DebugAbort( "Error fetching Reparse Point attribute.\n" );
                return FALSE;
            } else {

                // The Ea Information attribute is not present and there
                // is no Reparse Point, which means this file has no EAs.

                DuplicatedInformation->PackedEaSize = 0;
            }
        } else if ( !Attribute.Read( &reparse_point,
                                     0,
                                     FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                  GenericReparseBuffer.DataBuffer),
                                     &BytesRead ) ||
                    BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                              GenericReparseBuffer.DataBuffer)) {

            // Couldn't read the Reparse Point data.
            //
            DebugAbort( "Can't read Reparse Point.\n" );
            return FALSE;

        } else {

            // We've got the Reparse Point.
            //
            DuplicatedInformation->ReparsePointTag = reparse_point.ReparseTag;
        }

    } else if( !Attribute.Read( &EaInformation,
                                0,
                                sizeof( EA_INFORMATION ),
                                &BytesRead ) ||
                BytesRead != sizeof( EA_INFORMATION ) ) {

        // Couldn't read the Ea Information data.
        //
        DebugAbort( "Can't read EA Information.\n" );
        return FALSE;

    } else {

        // We've got the Ea Information.
        //
        DuplicatedInformation->PackedEaSize = EaInformation.PackedEaSize;
    }


    // Now we grope the size of the unnamed $DATA attribute and we
    // are done.
    //

    if( !QueryFileSizes( &(DuplicatedInformation->AllocatedLength),
                         &(DuplicatedInformation->FileSize),
                         &Error ) ) {

        if( Error ) {

            // The Data attribute is present, but we couldn't get it.
            //
            DebugAbort( "Error fetching $DATA attribute.\n" );
            return FALSE;

        } else {

            // This file has no unnamed $DATA attribute.
            //
            DuplicatedInformation->AllocatedLength = 0;
            DuplicatedInformation->FileSize = 0;
        }

    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::UpdateFileNames(
    IN     PDUPLICATED_INFORMATION  DuplicatedInformation,
    IN OUT PNTFS_INDEX_TREE         Index,
    IN     BOOLEAN                  IgnoreExternal
    )
/*++

Routine Description:

    This method propagates

Arguments:

    DuplicatedInformation   --  Supplies the duplicated information which
                                is to be propagated into the File Names.
    Index                   --  Supplies the index for the directory which
                                contains this FRS.  It may be NULL, in which
                                case changes are not propagated to the index.
    IgnoreExternal          --  Supplies a flag which, if TRUE, indicates
                                that this method should only update file
                                names in this FRS, and not in its children.

Return Value:

    TRUE upon successful completion.

Notes:

    This method only propagates changes to the supplied index; thus,
    if a file is indexed by more than one directory, changes can
    only be propagated to one directory.  However, all entries for
    this file in the supplied index will be updated.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    DSTRING Name;
    MFT_SEGMENT_REFERENCE SegmentReference;

    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    LCN TargetFileNumber;
    VCN LowestVcn;
    ATTRIBUTE_TYPE_CODE CurrentType;
    PFILE_NAME CurrentName;
    PVOID CurrentRecordData;
    ULONG ValueLength;
    USHORT Tag;

    // Make sure that the supplied index, if any, is constructed
    // over the FILE_NAME attribute:

    if( Index != NULL &&
        Index->QueryIndexedAttributeType() != $FILE_NAME ) {

        DebugAbort( "Updating file names in an index that's not over $FILE_NAME.\n" );
        return FALSE;
    }

    // Force the attribute list, if we have one, into memory.
    //
    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( !IgnoreExternal &&
        _AttributeList != NULL ) {

        ATTR_LIST_CURR_ENTRY        Entry;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry( &Entry,
                                               &CurrentType,
                                               &LowestVcn,
                                               &SegmentReference,
                                               &Tag,
                                               &Name )) {

            if( CurrentType == $FILE_NAME ) {

                // The current entry represents a record for a
                // File Name attribute, which we may wish to
                // update.  Figure out what FRS it's in:

                TargetFileNumber.Set( SegmentReference.LowPart,
                                        (LONG) SegmentReference.HighPart );

                if( TargetFileNumber == QueryFileNumber() ) {

                    // This file name is in the base FRS, ie. in
                    // this FRS.  Call this method recursively,
                    // with IgnoreExternal TRUE to limit the
                    // recursion.

                    if( !UpdateFileNames( DuplicatedInformation,
                                          Index,
                                          TRUE ) ) {
                        return FALSE;
                    }

                } else {

                    // This attribute is in a child FRS.  Get the
                    // child and update any file names in it.  Note
                    // Note that we can ignore external names in
                    // the child, since child FRS's cannot have
                    // children.  (Note also that this will preemptively
                    // update any other names in that child, which is
                    // fine.
                    //
                    if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ||
                        !ChildFrs->UpdateFileNames( DuplicatedInformation,
                                                    Index,
                                                    TRUE ) ) {

                        return FALSE;
                    }
                }
            }
        }

    } else {

        // Crawl through the records in this FRS looking for File Names.
        //
        CurrentRecordData = NULL;

        while( (CurrentRecordData =
                GetNextAttributeRecord( CurrentRecordData )) != NULL ) {

            // Note that GetNextAttributeRecord always returns a
            // structurally-sound attribute record, which we can
            // pass directly to this flavor of Initialize, which
            // in turn will always succeed.  It is also important
            // that this flavor of initialize will cause the
            // attribute record to use directly the data in the
            // File Record Segment, so we can twiddle it there.
            //
            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                DebugAbort( "Can't initialize attribute record.\n" );
                return FALSE;
            }

            if( CurrentRecord.QueryTypeCode() == $FILE_NAME ) {

                // It's a file name.

                CurrentName = (PFILE_NAME)
                           (CurrentRecord.GetResidentValue() );

                ValueLength = CurrentRecord.QueryResidentValueLength();

                // Perform sanity checks--the attribute must be resident,
                // big enough to be a File Name, and big enough to hold
                // the name it claims to be.
                //
                if( CurrentName == NULL ||
                    ValueLength < sizeof( FILE_NAME ) ||
                    ValueLength < (ULONG)FIELD_OFFSET( FILE_NAME, FileName ) +
                                  CurrentName->FileNameLength ) {

                    DebugAbort( "Corrupt file name.\n" );
                    return FALSE;
                }

                // OK, it's a valid file name.  Update the duplicated
                // information and propagate duplicated information and
                // file name bits back to the index entry.
                //
                memcpy( &(CurrentName->Info),
                        DuplicatedInformation,
                        sizeof( DUPLICATED_INFORMATION ) );

                // Update the corresponding entry in the index.
                //

                SegmentReference = ( IsBase() ) ?
                        QuerySegmentReference() :
                        QueryBaseFileRecordSegment();


                if( Index != NULL &&
                    !Index->UpdateFileName( CurrentName,
                                            SegmentReference ) ) {

                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}



VOID
NTFS_FILE_RECORD_SEGMENT::SetLsn(
    IN  BIG_INT NewLsn
    )
/*++

Routine Description:

    This method sets the Lsn for the File Record Segment
    and any of its children which are in memory.

Arguments:

    NewLsn  --  Supplies the new LSN for this File Record
                Segment and any available children.

Return Value:

    None.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   CurrentChild;

    _FrsData->Lsn = NewLsn.GetLargeInteger();

    _ChildIterator->Reset();

    while( (CurrentChild = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

        CurrentChild->SetLsn( NewLsn );
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Backtrack(
    OUT PWSTRING Path
    )
/*++

Routine Description:

    This function finds a path from the root to this FRS.  Note
    that it does not detect cycles, and may enter into an infinite
    loop if there is a cycle in the logical directory structure.

    Note that the client must read this FRS before calling Backtrack.

Arguments:

    Path    --  Receives the path.

Return Value:

    TRUE upon successful completion.

--*/
{
    // First, check to see if this is the Root
    //
    if( QueryFileNumber() == ROOT_FILE_NAME_INDEX_NUMBER ) {

        return( Path->Initialize( "\\" ) );
    }

    // Initialize the path to the empty string and then pass it
    // to the worker routine.
    //
    return( Path->Initialize( "" ) &&
            BacktrackWorker( Path ) );
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::BacktrackWorker(
            IN OUT PWSTRING Path
            )
/*++

Routine Description:

    This member function is a private worker routine for Backtrack;
    it performs the actual work of constructing the path from the
    root to this FRS.

Arguments:

    Path    --  Receives the path to this FRS.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE FileNameAttribute;
    NTFS_FILE_RECORD_SEGMENT ParentFrs;
    VCN ParentFileNumber;
    PCFILE_NAME FileName;
    DSTRING FileNameString, Backslash;
    BOOLEAN Error;

    // Short circuit if this is the root--it doesn't add
    // anything to the path.
    //
    if( QueryFileNumber() ==  ROOT_FILE_NAME_INDEX_NUMBER ) {

        return TRUE;
    }

    // Extract a name from the FRS.  Any name will do.
    //
    if( !QueryAttribute( &FileNameAttribute, &Error, $FILE_NAME ) ||
        !FileNameAttribute.IsResident() ) {

        return FALSE;
    }

    FileName = (PCFILE_NAME)FileNameAttribute.GetResidentValue();

    ParentFileNumber.Set( FileName->ParentDirectory.LowPart,
                          (LONG)FileName->ParentDirectory.HighPart );

    // If the parent FRS is not the root, initialize and read it,
    // and then recurse into it.
    //
    if( ParentFileNumber != ROOT_FILE_NAME_INDEX_NUMBER &&
        (!ParentFrs.Initialize( ParentFileNumber, _Mft ) ||
         !ParentFrs.Read() ||
         !ParentFrs.Backtrack( Path ) ) ) {

        return FALSE;
    }

    // Now add this FRS's name to the path.
    //
    if( !Backslash.Initialize( "\\" ) ||
        !FileNameString.Initialize( NtfsFileNameGetName( FileName ),
                                    FileName->FileNameLength ) ||
        !Path->Strcat( &Backslash ) ||
        !Path->Strcat( &FileNameString ) ) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddChild(
    PNTFS_FILE_RECORD_SEGMENT ChildFrs
    )
/*++

Routine Description:

    This method adds a child File Record Segment to the list of
    children.  Management of that File Record Segment then passes
    to the list.

Arguments:

    ChildFrs    -- supplies a pointer to the child File Record Segment.

Return Value:

    TRUE upon successful completion.

--*/
{
    _ChildIterator->Reset();

    return( _Children.Insert( ChildFrs, _ChildIterator ) );
}



PNTFS_FILE_RECORD_SEGMENT
NTFS_FILE_RECORD_SEGMENT::GetChild(
    VCN FileNumber
    )
/*++

Routine Description:

    This method finds a File Record Segment in the list of children
    based on its File Number.

Arguments:

    FileNumber  -- supplies the file number of the desired child.

Return Value:

    A pointer to the desired File Record Segment.  Note that this
    object belongs to the child list, and should not be deleted by
    the client.

    NULL if the desired child could not be found in the list.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT CurrentChild;

    // Spin through the list of children until we run out or find
    // one with the appropriate VCN.

    _ChildIterator->Reset();

    while( (CurrentChild =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL &&
           CurrentChild->QueryFileNumber() != FileNumber );

    // If there is a matching child in the list, CurrentChild now points
    // at it; otherwise, CurrentChild is NULL.

    return CurrentChild;
}


PNTFS_FILE_RECORD_SEGMENT
NTFS_FILE_RECORD_SEGMENT::SetupChild(
    IN VCN  FileNumber
    )
/*++

Routine Description:

    This method sets up a child FRS.  If the desired child is already
    in the list, it is returned; otherwise, it is allocated and read
    and added to the list, and the returned.

Arguments:

    FileNumber  --  Supplies the file number of the desired child.

Return Value:

    A pointer to the child FRS, or NULL to indicate error.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    PNTFS_MFT_FILE MftFile;

    if( (ChildFrs = GetChild( FileNumber )) != NULL ) {

        // The child is already in the list.
        //
        return ChildFrs;
    }

    // Allocate a new FRS object, initialize it to be the
    // child we want, read it in, and add it to the list.
    //
    if( (ChildFrs = NEW NTFS_FILE_RECORD_SEGMENT) == NULL ) {

        return NULL;
    }

    if( _Mft != NULL ) {

        // This is an ordinary, run-of-the-mill File Record
        // Segment, so just initialize the child with the
        // same MFT as this object was initialized with.
        //
        if( !ChildFrs->Initialize( FileNumber, _Mft ) ||
            !ChildFrs->Read() ||
            !AddChild( ChildFrs ) ) {

            DELETE( ChildFrs );
            return NULL;
        }

    } else {

        // This File Record Segment is really the
        // MFT file itself, so we have to do some
        // arcane gesticulation.  Since we know this
        // is really an NTFS_MFT_FILE object, we'll
        // dynamically cast it to that class, and
        // then pass it in as the NTFS_MFT_FILE to
        // initialize the child.
        //
        if( QueryClassId() != NTFS_MFT_FILE_cd->QueryClassId() ) {

            DELETE( ChildFrs );
            return FALSE;
        }

        MftFile = (PNTFS_MFT_FILE)( this );

        if( !ChildFrs->Initialize( FileNumber, MftFile ) ||
            !ChildFrs->Read() ||
            !AddChild( ChildFrs ) ) {

            DELETE( ChildFrs );
            return FALSE;
        }
    }

    return ChildFrs;
}


VOID
NTFS_FILE_RECORD_SEGMENT::DeleteChild(
    VCN FileNumber
    )
/*++

Routine Description:

    This method removes a File Record Segment from the list of
    children based on its File Number.

Arguments:

    FileNumber  -- supplies the file number of the child to delete.

Return Value:

    None.

Notes:

    Since the list manages the File Record Segments which it has been
    given, it deletes the File Record Segment in question.

    This method assumes that only one matching child exists (since the
    same File Record Segment should not appear twice in the list).

--*/
{
    PNTFS_FILE_RECORD_SEGMENT CurrentChild, ChildToDelete;

    // Spin through the list of children until we run out or find
    // one with the appropriate VCN.

    _ChildIterator->Reset();

    while( (CurrentChild =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL &&
           CurrentChild->QueryFileNumber() != FileNumber );

    // If there is a matching child in the list, the iterator's current
    // state points at it and CurrentChild is non-NULL.

    if( CurrentChild != NULL ) {

        // A matching child was found; remove it from the list
        // and delete it.

        ChildToDelete = (PNTFS_FILE_RECORD_SEGMENT)
                        _Children.Remove( _ChildIterator );

        DebugAssert( ChildToDelete == CurrentChild );

        DELETE( ChildToDelete );
    }
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Delete(
    IN OUT PNTFS_BITMAP         VolumeBitmap
)
/*++

Routine Description:

    This method frees all the attributes within an FRS and finally
    frees the FRS itself.

Arguments:

    VolumeBitmap        - Supplies the volume bitmap.

Return Value:

    TRUE    - Success
    FALSE   - Failure

Notes:

--*/
{
    DSTRING                 name;
    ULONG                   type = 0;
    NTFS_ATTRIBUTE          attrib;
    BOOLEAN                 error;
    BOOLEAN                 rst = TRUE;
    NUMBER_SET              frs_involved;
    ULONG                   index;

    if (!name.Initialize("") ||
        !frs_involved.Initialize())
        return FALSE;

    while (QueryNextAttribute(&type, &name) && type != $END) {
        if (QueryAttribute(&attrib, &error, type, &name)) {
            if (!attrib.IsResident())
                rst = attrib.Resize(0, VolumeBitmap) && rst;
            rst = PurgeAttribute(type, &name) && rst;
            type = 0;
        } else if (error) {
            DebugPrintTrace(("Unable to Query attribute type %d of FRS %d",
                            type, QueryFileNumber().GetLowPart()));
            return FALSE;
        }
    }

    //
    // Delete the attribute list itself if there is one
    //
    if (IsAttributePresent($ATTRIBUTE_LIST)) {
        if (QueryAttributeListAttribute(&attrib, &error)) {
            if (!attrib.IsResident())
                rst = attrib.Resize(0, VolumeBitmap) && rst;
            rst = PurgeAttribute($ATTRIBUTE_LIST) && rst;
        } else if (error) {
            DebugPrintTrace(("Unable to Query attribute list of FRS %d",
                            QueryFileNumber().GetLowPart()));
            return FALSE;
        }
        DELETE(_AttributeList);
    }

    ClearInUse();

    rst = Write() && rst;
    rst = Flush(VolumeBitmap, NULL, TRUE) && rst;

    rst = _Mft->FreeFileRecordSegment(QueryFileNumber()) && rst;

    return rst;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeListAttribute (
    OUT PNTFS_ATTRIBUTE     AttrList,
    OUT PBOOLEAN            Error
)
/*++

Routine Description:

   This function fetches the attribute list associated with the
   File Record Segment.

Arguments:

    AttrList    --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method assumes the attribute list is local to the File Record Segment.

--*/
{
    NTFS_ATTRIBUTE_RECORD Record;

    DebugPtrAssert( AttrList );
    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

    if( !IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

      // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }

    // Get the first attribute record.

    if (!QueryAttributeRecord(&Record, $ATTRIBUTE_LIST)) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR_LIST_ATTR,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }

    // Initialize the Attribute with the first attribute record.

    if ( !AttrList->Initialize( GetDrive(),
                                QueryClusterFactor(),
                                &Record ) ) {

        return FALSE;
    }

    *Error = FALSE;
    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::PurgeAttributeList (
)
/*++

Routine Description:

   This function purges the attribute list off the File Record Segment.

Arguments:

    N/A

Return Value:

    TRUE upon successful completion.

Notes:
   It is the user's responsibility to make sure that all segment reference
   in the attribute list points back to the base frs.

--*/
{
    DELETE(_AttributeList);
    return PurgeAttribute($ATTRIBUTE_LIST, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\extents.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    extents.cxx

Abstract:

    This module contains the definitions for NTFS_EXTENT_LIST, which
    models a set of NTFS extents.

    An extent is a contiguous run of clusters; a non-resident
    attribute's value is made up of a list of extents.  The
    NTFS_EXTENT_LIST object can be used to describe the disk space
    allocated to a non-resident attribute.

    This class also encapsulates the knowledge of mapping pairs
    and their compression, i.e. of the representation of extent
    lists in attribute records.

    The extent list is kept sorted by VCN.  Since extent lists are
    typically quite short, linear search is used.

Author:

    Bill McJohn (billmc) 17-June-91
    Matthew Bradburn (mattbr) 19-August-95
        Changed to use NTFS MCB package for improved performance.

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfsbit.hxx"
#include "intstack.hxx"
#include "iterator.hxx"

#include "extents.hxx"
#include "ntfssa.hxx"

extern "C" {
#include "fsrtlp.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_EXTENT_LIST, OBJECT, UNTFS_EXPORT );
DEFINE_CONSTRUCTOR( NTFS_EXTENT, OBJECT );

//
// These routines are to support the NTFS MCB package.
//

extern "C"
PVOID
MemAlloc(
    IN  ULONG   Size
    );

PVOID
MemAlloc(
    IN  ULONG   Size
    )
{
    return  NEW BYTE[Size];
}

extern "C"
PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    );

PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    )
{
    PVOID p;

    p = MemAlloc(Size);

    if (NULL == p) {
        RtlRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
    }
    return p;
}

extern "C"
VOID
MemFree(
    IN  PVOID   Addr
    );

VOID
MemFree(
    IN  PVOID   Addr
    )
{
    delete[] Addr;
}


UNTFS_EXPORT
NTFS_EXTENT_LIST::~NTFS_EXTENT_LIST(
    )
/*++

Routine Description:

    Destructor for NTFS_EXTENT_LIST class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

VOID
NTFS_EXTENT_LIST::Construct(
    )
/*++

Routine Description:

    Worker method for NTFS_EXTENT_LIST construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LowestVcn = 0;
    _NextVcn = 0;
    _McbInitialized = FALSE;
    _Mcb = NULL;
}

VOID
NTFS_EXTENT_LIST::Destroy(
    )
/*++

Routine Description:

    Worker method for NTFS_EXTENT_LIST destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LowestVcn = 0;
    _NextVcn = 0;

    if (_McbInitialized) {

        FsRtlUninitializeLargeMcb(_Mcb);
        _McbInitialized = FALSE;
    }

    DELETE(_Mcb);
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN VCN LowestVcn,
    IN VCN NextVcn
    )
/*++

Routine Description:

    Initializes an empty extent list.

Arguments:

    LowestVcn   -- supplies the lowest VCN mapped by this extent list
    NextVcn     -- supplies the next VCN following this extent list

Return Value:

    TRUE upon successful completion.

Notes:

    Highest and Lowest VCN are typically zero; they are provided
    to permit creation of sparse files.

    This class is reinitializable.

--*/
{
    Destroy();

    _LowestVcn = LowestVcn;
    _NextVcn = (NextVcn < LowestVcn) ? LowestVcn : NextVcn;

    if (NULL == (_Mcb = NEW LARGE_MCB)) {
        Destroy();
        return FALSE;
    }

    __try {

        FsRtlInitializeLargeMcb(_Mcb, (POOL_TYPE)0);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Destroy();
        return FALSE;
    }

    _McbInitialized = TRUE;

    return TRUE;
}


BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN  VCN         StartingVcn,
    IN  PCVOID      CompressedMappingPairs,
    IN  ULONG       MappingPairsMaximumLength,
    OUT PBOOLEAN    BadMappingPairs
    )
/*++

Routine Description:

    Initialize an extent list based on a set of compressed mapping
    pairs (presumably taken from an attribute record).

Arguments:

    StartingVcn                 --  Supplies the starting VCN of the
                                    mapping pairs list
    CompressedMappingPairs      --  Supplies a pointer to the compressed
                                    list of mapping pairs
    MappingPairsMaximumLength   --  Supplies the length (in bytes) of
                                    the buffer in which the mapping
                                    pairs list resides
    BadMappingPairs             --  If non-NULL, receives TRUE if this
                                    method failed because the mapping
                                    pairs list could not be expanded.
                                    If this method returns TRUE, then
                                    *BadMappingPairs should be ignored.

Return Value:

    TRUE upon successful completion.

Notes:

    This method does not assume that the mapping pairs list can be
    correctly expanded.  It does assume that the MappingPairsMaximumLength
    is correct, i.e. that it can reference that many bytes of memory
    starting at CompressedMappingPairs.

    Clients who trust the mapping pairs list which they pass in may omit
    the BadMappingPairs parameter; those (like Chkdsk) who do not trust
    the list can use BadMappingPairs to determine whether Initialize failed
    because of a bad mapping pairs list.

--*/
{
    DebugPtrAssert( CompressedMappingPairs );

    return( Initialize( StartingVcn, StartingVcn ) &&
            AddExtents( StartingVcn,
                        CompressedMappingPairs,
                        MappingPairsMaximumLength,
                        BadMappingPairs ) );
}



BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN PCNTFS_EXTENT_LIST ExtentsToCopy
    )
/*++

Routine Description:

    Initializes an extent list based on another extent list.

Arguments:

    ExtentsToCopy   - Supplies the other list of extents.

Return Value:

    TRUE upon successful completion.

Notes:

    This class is reinitializable.

--*/
{
    VCN             Vcn;
    LCN             Lcn;
    BIG_INT         RunLength;
    ULONG           num_extents;

    Destroy();

    if (!Initialize(ExtentsToCopy->_LowestVcn,
                    ExtentsToCopy->_NextVcn)) {

        Destroy();
        return FALSE;
    }

    num_extents = ExtentsToCopy->QueryNumberOfExtents();

    for (ULONG i = 0; i < num_extents; ++i) {
        if (!ExtentsToCopy->QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            Destroy();
            return FALSE;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            continue;
        }

        if (!AddExtent(Vcn, Lcn, RunLength)) {
            Destroy();
            return FALSE;
        }
    }

    SetLowestVcn(ExtentsToCopy->_LowestVcn);
    SetNextVcn(ExtentsToCopy->_NextVcn);

    return TRUE;
}



BOOLEAN
NTFS_EXTENT_LIST::IsSparse(
    ) CONST
/*++

Routine Description:

    This method determines whether the extent list has holes
    (ie. if there are not-present-on-disk runs in the attribute).

Arguments:

    None.

Return Value:

    TRUE if the extent list is sparse.

--*/
{
    BIG_INT         previous_vcn, previous_lcn, previous_runlength;
    BIG_INT         current_vcn, current_lcn, current_runlength;
    ULONG           i = 0;

    if (!QueryExtent(i, &previous_vcn, &previous_lcn, &previous_runlength)) {

        if (_LowestVcn != _NextVcn) {

            // This extent list is one big hole.

            return TRUE;

        } else {

            // This extent list is empty.

            return FALSE;
        }
    }

    if (previous_vcn != _LowestVcn) {

        // This extent list starts with a hole.

        return TRUE;
    }

    // Check the rest of the extents, to see if there's a hole
    // before any of them:

    while (QueryExtent(++i, &current_vcn, &current_lcn, &current_runlength)) {

        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        if (previous_vcn + previous_runlength != current_vcn) {
            return TRUE;
        }

        previous_vcn = current_vcn;
        previous_lcn = current_lcn;
        previous_runlength = current_runlength;
    }

    // Check to see if there's a hole after the last extent:

    if (previous_vcn + previous_runlength != _NextVcn) {
        return TRUE;
    }

    // Didn't find any holes.

    return FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::AddExtent(
    IN VCN      Vcn,
    IN LCN      Lcn,
    IN BIG_INT  RunLength
    )
/*++

Routine Description:

    This method adds an extent, specified by its Virtual Cluster Number,
    Logical Cluster Number, and Run Length, to the extent list.

    NTFS_EXTENT_LIST may, at its discretion, merge contiguous extents,
    but it does not guarrantee this behavior.

Arguments:

    Vcn         --  Supplies the starting VCN of the extent.
    Lcn         --  Supplies the starting LCN of the extent.
    RunLength   --  Supplies the number of clusters in the extent.

Return Value:

    TRUE upon successful completion.

--*/
{
    VCN             TempVcn;
    BOOLEAN         b;

    if (RunLength <= 0) {

        // zero-length runs are not valid.  Neither are negative ones.

        return FALSE;
    }
    if (LCN_NOT_PRESENT == Lcn) {

        // We ignore attempts to explicitly add holes.

        return TRUE;
    }

    //
    // Currently, Mcb routines cannot handle number beyond 32 bits
    //

    if (Vcn.GetLargeInteger().HighPart) {
        return FALSE;
    }

    __try {

        b = FsRtlAddLargeMcbEntry(_Mcb,
                                  Vcn.GetLargeInteger().QuadPart,
                                  Lcn.GetLargeInteger().QuadPart,
                                  RunLength.GetLargeInteger().QuadPart);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

    if (!b) {
        return FALSE;
    }

    if (_LowestVcn == _NextVcn) {
        _LowestVcn = Vcn;
        _NextVcn = Vcn + RunLength;
    }


    // If this extent changes the lowest and highest VCNs mapped
    // by this extent list, update those values.

    if (Vcn < _LowestVcn) {

        _LowestVcn = Vcn;
    }

    TempVcn = Vcn + RunLength;

    if (TempVcn > _NextVcn) {

        _NextVcn = TempVcn;
    }

    return TRUE;
}



VOID
NTFS_EXTENT_LIST::Coalesce(
    )
/*++

Routine Description:

    This routine coalesces adjacent extents in the extent list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // The MCB package does this for us.

    return;
}


BOOLEAN
NTFS_EXTENT_LIST::AddExtents(
    IN  VCN         StartingVcn,
    IN  PCVOID      CompressedMappingPairs,
    IN  ULONG       MappingPairsMaximumLength,
    OUT PBOOLEAN    BadMappingPairs
    )
/*++

Routine Description:

    This method adds a set of extents defined by a compressed mapping
    pairs list (presumably taken from an Attribute Record).

Arguments:

    StartingVcn     -- supplies the starting VCN of the mapping pairs list
    CompressedMappingPairs  -- supplies a pointer to the compressed
                                list of mapping pairs
    MappingPairsMaximumLengt -- supplies the length (in bytes) of the buffer
                                in which the mapping pairs list resides
    BadMappingPairs -- if non-NULL, receives TRUE if an error occurrs
                        while processing the mapping pairs list.

Return Value:

    TRUE upon successful completion.

Notes:

    BadMappingPairs will be set to TRUE if the compressed mapping
    pairs list cannot be expanded or if any extent derived from
    this list overlaps with another extent in the list.  In either
    of these cases, AddExtents will return FALSE.

    If this method encounters an error after processing part of
    the list, it will leave the extent list in an undefined (but
    valid, as an object) state.

    Clients who trust their mapping pairs list may omit the
    BadMappingPairs parameter.

--*/
{
    VCN             CurrentVcn;
    ULONG           LengthOfCompressedPairs;
    ULONG           NumberOfPairs;
    PMAPPING_PAIR   MappingPairs;
    ULONG i;

    // Assume innocent until found guilty
    //
    if( BadMappingPairs != NULL ) {

        *BadMappingPairs = FALSE;
    }

    // Determine how many mapping pairs we actually have, so
    // we can allocate the correct size of an expanded mapping
    // pairs buffer.

    if( !QueryMappingPairsLength( CompressedMappingPairs,
                                  MappingPairsMaximumLength,
                                  &LengthOfCompressedPairs,
                                  &NumberOfPairs ) ) {

        if( BadMappingPairs != NULL ) {

            *BadMappingPairs = TRUE;
        }

        DebugPrint( "Can't determine length of mapping pairs.\n" );
        return FALSE;
    }

    // Allocate a buffer to hold the expanded mapping pairs.

    MappingPairs = (PMAPPING_PAIR)MALLOC( sizeof(MAPPING_PAIR) *
                                            (UINT) NumberOfPairs );

    if( MappingPairs == NULL ) {

        return FALSE;
    }


    if( !ExpandMappingPairs( CompressedMappingPairs,
                             StartingVcn,
                             MappingPairsMaximumLength,
                             NumberOfPairs,
                             MappingPairs,
                             &NumberOfPairs ) ) {

        DebugPrint( "Cannot expand mapping pairs.\n" );

        if( BadMappingPairs != NULL ) {

            *BadMappingPairs = TRUE;
        }

        FREE( MappingPairs );
        return FALSE;
    }


    // Convert the mapping pairs into extents.

    CurrentVcn = StartingVcn;

    for( i = 0; i < NumberOfPairs; i++ ) {

        if( MappingPairs[i].CurrentLcn != LCN_NOT_PRESENT ) {

            if( !AddExtent( CurrentVcn,
                            MappingPairs[i].CurrentLcn,
                            MappingPairs[i].NextVcn - CurrentVcn ) ) {

                FREE( MappingPairs );
                return FALSE;
            }
        }

        CurrentVcn = MappingPairs[i].NextVcn;
    }

    // Set _LowestVcn to the client-supplied value, if necessary.
    // (This is required for mapping pair lists that begin with
    // a hole.)
    //
    if( StartingVcn < _LowestVcn ) {

        _LowestVcn = StartingVcn;
    }


    // Update _NextVcn if neccessary.
    //
    if( CurrentVcn > _NextVcn ) {

        _NextVcn = CurrentVcn;
    }

    FREE( MappingPairs );
    return TRUE;
}



VOID
NTFS_EXTENT_LIST::DeleteExtent(
    IN ULONG ExtentNumber
    )
/*++

Routine Description:

    This method removes an extent from the list.

Arguments:

    ExtentNumber    --  supplies the (zero-based) extent number to remove

Return Value:

    None.

--*/
{
    VCN             Vcn;
    LCN             Lcn;
    BIG_INT         RunLength;

    //
    // Find the VCN for the extent number.
    //

    if (!QueryExtent(ExtentNumber, &Vcn, &Lcn, &RunLength)) {
        DebugAbort("Shouldn't get here.");
        return;
    }

    FsRtlRemoveLargeMcbEntry(_Mcb,
                             Vcn.GetLargeInteger().QuadPart,
                             RunLength.GetLargeInteger().QuadPart);

    return;
}



BOOLEAN
NTFS_EXTENT_LIST::Resize(
    IN      BIG_INT         NewNumberOfClusters,
    IN OUT  PNTFS_BITMAP    Bitmap
    )
/*++

Routine Description:

    This method either extends or truncates the disk allocation
    covered by this extent list.

Arguments:

    NewNumberOfClusters -- supplies the number of clusters in
                            in the new allocation.

    Bitmap              -- supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is only meaningful is the extent list covers an entire
    attribute instance.  In particular, if the extent list's LowestVcn
    is not zero, this method does nothing (and returns FALSE).

    If this method fails, it leaves the extent list in its original
    state.

--*/
{
    BIG_INT OldNumberOfClusters;
    BIG_INT ClustersToAdd;
    LCN     NewLcn, NearLcn;
    ULONG   ThisLump;

    if( _LowestVcn != 0 ) {

        // This extent list does not cover the entire attribute
        // instance, so it cannot be resized.

        return FALSE;
    }

    // Determine the number of clusters in the current size.

    OldNumberOfClusters = _NextVcn;


    if( OldNumberOfClusters == NewNumberOfClusters ) {

        // The extent list is already the size we want.

        return TRUE;

    } else if( NewNumberOfClusters < OldNumberOfClusters ) {

        // We're shrinking the extent list.  Note that Truncate
        // always succeeds, and does not have a return value.

        Truncate( NewNumberOfClusters, Bitmap );
        return TRUE;

    } else {

        // We are extending the allocation.

        ClustersToAdd = NewNumberOfClusters - OldNumberOfClusters;

        if( ClustersToAdd.GetHighPart() != 0 ) {

            DebugPrint( "Trying to allocate more than 4G clusters.\n" );
            return FALSE;
        }

        ThisLump = ClustersToAdd.GetLowPart();
        NearLcn = QueryLastLcn();

        while( ClustersToAdd != 0 ) {

            if (ClustersToAdd.GetLowPart() < ThisLump) {

                ThisLump = ClustersToAdd.GetLowPart();
            }

            if( !Bitmap->AllocateClusters( NearLcn,
                                           ThisLump,
                                           &NewLcn ) ) {

                // We can't allocate a chunk this size; cut it
                // in half and try again.
                //
                ThisLump /= 2;

                if( ThisLump == 0 )  {

                    // We're out of disk space.  Restore the extent
                    // list to its original state and exit with an
                    // error.

                    Truncate( OldNumberOfClusters, Bitmap );
                    return FALSE;
                }

            } else {

                // We allocated a chunk.  Add it on to the end.

                if( !AddExtent( _NextVcn, NewLcn, ThisLump ) ) {

                    // We hit an internal error trying to add
                    // this extent.  Restore the extent list to
                    // its original state and return failure.

                    Truncate( OldNumberOfClusters, Bitmap );
                    return FALSE;
                }

                ClustersToAdd -= ThisLump;

                // If there's more to get, we won't be able to get
                // it contiguous; instead, set NearLcn to 0 to take
                // advantage of the roving pointer.
                //
                NearLcn = 0;
            }
        }

        return TRUE;
    }
}

BOOLEAN
NTFS_EXTENT_LIST::SetSparse(
    IN      BIG_INT         NewNumberOfClusters
    )
/*++

Routine Description:

    This method sets up an extent lists to represents a sparse
    allocation (a hole).

Arguments:

    NewNumberOfClusters -- supplies the number of clusters in
                           the sparse extent list.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is only meaningful if the extent list covers an entire
    attribute instance.  In particular, if the extent list's LowestVcn
    is not zero, this method does nothing (and returns FALSE).

    If this method fails, it leaves the extent list in its original
    state.

--*/
{
    if( _LowestVcn != 0 || _NextVcn != 0) {

        // This extent list does not cover the entire attribute
        // instance or is not empty, so it cannot be set sparse.

        return FALSE;
    }

    // Determine the number of clusters in the current size.

    _NextVcn = NewNumberOfClusters;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::QueryExtent(
    IN  ULONG       ExtentNumber,
    OUT PVCN        Vcn,
    OUT PLCN        Lcn,
    OUT PBIG_INT    RunLength
    ) CONST
/*++

Routine Description:

    This methods gives the client information on an extent in
    the list.

Arguments:

    ExtentNumber -- supplies the number of the extent to return (zero-based).
    Vcn          -- receives the starting VCN of the extent.
    Lcn          -- receives the starting LCN of the extent.
    RunLength    -- receives the number of clusters in the extent.

Return Value:

    TRUE if ExtentNumber is less than the number of extents in the list;
    FALSE if it is out of range.

--*/
{
    BOOLEAN         b;
    LONGLONG        Vbn, Lbn, SectorCount;
    LARGE_INTEGER   li;

    b = FsRtlGetNextLargeMcbEntry((PLARGE_MCB)_Mcb,
            ExtentNumber, &Vbn, &Lbn, &SectorCount);
    if (!b) {
        return FALSE;
    }

    li.QuadPart = Vbn;
    *Vcn = li;

    li.QuadPart = Lbn;
    *Lcn = li;

    li.QuadPart = SectorCount;
    *RunLength = li;

    return TRUE;
}


BOOLEAN
NTFS_EXTENT_LIST::QueryLcnFromVcn(
    IN  VCN         Vcn,
    OUT PLCN        Lcn,
    OUT PBIG_INT    RunLength
    ) CONST
/*++

Routine Description:

    This method converts a VCN within the allocation described by
    this extent list into an LCN.

Arguments:

    Vcn       -- supplies the VCN to be converted.
    Lcn       -- receives the LCN that corresponds to the supplied Vcn.
    RunLength -- if non-NULL, receives the remaining length in the
                 extent from the supplied Vcn.

Return Value:

    TRUE upon successful completion.

    If the specified VCN is outside the range [_LowestVcn, _NextVcn),
    this method returns FALSE.

    If the extent list is sparse and the requested VCN is in the range
    of this extent list but falls in a hole, this method will return TRUE;
    *Lcn is set to LCN_NOT_PRESENT, and *RunLength is set to the remaining
    run length to the next actual extent.

--*/
{
    BOOLEAN         b;
    LONGLONG        Lbn = -1, SectorCount;
    LARGE_INTEGER   li;
    VCN             vcn;
    LCN             lcn;
    BIG_INT         runlength;

    if (Vcn < _LowestVcn || Vcn >= _NextVcn) {

        return FALSE;
    }

    b = FsRtlLookupLargeMcbEntry(
                   (PLARGE_MCB)_Mcb,
                   Vcn.GetLargeInteger().QuadPart,
                   &Lbn,
                   &SectorCount,            /* SectorCountFromLbn */
                   NULL,                    /* StartingLbn */
                   NULL,                    /* SectorCountFromStartingLbn */
                   NULL                     /* Index */
                   );
    if (!b) {

        // This VCN fell into a hole.  See if it comes after the last
        // real extent in the list, otherwise maybe it comes before the
        // first.
        //

        *Lcn = LCN_NOT_PRESENT;

        if (0 == QueryNumberOfExtents()) {
            if (NULL != RunLength) {
                *RunLength = _NextVcn - Vcn;
            }
            return TRUE;
        }

        if (!QueryExtent(QueryNumberOfExtents() - 1, &vcn, &lcn, &runlength)) {
            return FALSE;
        }

        if (Vcn > vcn) {
            if (NULL != RunLength) {
                *RunLength = _NextVcn - Vcn;
            }
            return TRUE;
        }

        if (!QueryExtent(0, &vcn, &lcn, &runlength)) {
            return FALSE;
        }

        if (Vcn < vcn) {
            if (NULL != RunLength) {
                *RunLength = Vcn - _LowestVcn;
            }
            return TRUE;
        }

        return FALSE;
    }

    if (NULL != RunLength) {
        li.QuadPart = SectorCount;
        *RunLength = li;
    }

    if (-1 == Lbn) {
        *Lcn = LCN_NOT_PRESENT;
        return TRUE;
    }

    li.QuadPart = Lbn;
    *Lcn = li;

    return TRUE;
}



BOOLEAN
NTFS_EXTENT_LIST::QueryCompressedMappingPairs(
    OUT    PVCN     LowestVcn,
    OUT    PVCN     NextVcn,
    OUT    PULONG   Length,
    IN     ULONG    BufferSize,
    IN OUT PVOID    Buffer,
    OUT    PBOOLEAN HasHoleInFront
    ) CONST
/*++

Routine Description:

    This method produces a set of compressed mapping pairs
    corresponding to this extent list.

Arguments:

    LowestVcn   -- receives the lowest VCN covered by this extent list.
    NextVcn     -- receives the VCN following this extent list.
    Length      -- receives the length of the compressed mapping pairs list.
    BufferSize  -- supplies the size of the mapping pairs buffer provided
                    by the caller
    Buffer      -- supplies the buffer into which the compressed mapping
                    pairs list is written.
    HasHoleInFront
                -- receives TRUE if we skipped a hole at the very beginning
                    of the extent list during compression; otherwise FALSE.
                    This is useful for code that counts the compression
                    pairs and calls QueryExtent with the count.

Return Value:

    A pointer to the compressed mapping pairs list.  Note that the client
    must free this memory (using FREE).  NULL indicates an error.

--*/
{
    ULONG           MaximumMappingPairs;
    PMAPPING_PAIR   MappingPairs;
    PMAPPING_PAIR   CurrentMappingPair;
    ULONG           NumberOfPairs;
    VCN             TheNextVcn;
    BOOLEAN         Result;
    ULONG           num_extents;

     if (HasHoleInFront)
          *HasHoleInFront = FALSE;

    // First, let's handle the degenerate case--if the list
    // has no extents, it's compresses to a single zero byte.
    //
    if (IsEmpty()) {

        if (BufferSize == 0) {

            return FALSE;

        } else {

            *LowestVcn = 0;
            *NextVcn = 0;
            *Length = 1;

            *(PBYTE)Buffer = 0;

            return TRUE;
        }
    }

    // Massage the extent list into a mapping pairs list and compress it.
    // In the worst case, no two extents are VCN-contiguous, and
    // so the number of mapping pairs would be one more than twice
    // the number of extents (gap extent gap extent gap ... extent gap).

    // This upper bound formula may be too much as QueryNumberOfExtents will
    // return all entries including gaps except the last one if it is a gap.

    num_extents = QueryNumberOfExtents();

    MaximumMappingPairs = 2 * num_extents + 1;

    MappingPairs = (PMAPPING_PAIR)MALLOC( (UINT) (sizeof(MAPPING_PAIR) *
                                            MaximumMappingPairs) );

    if( MappingPairs == NULL ) {

        return FALSE;
    }

    TheNextVcn = _LowestVcn;
    NumberOfPairs = 0;

    CurrentMappingPair = MappingPairs;

    for (ULONG i = 0; i < num_extents; ++i) {

        VCN Vcn;
        LCN Lcn;
        BIG_INT RunLength;

        DebugAssert(NumberOfPairs < MaximumMappingPairs);

        if (!QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            DebugAbort("This shouldn't happen\n");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            if ((i == 0) && HasHoleInFront)
                *HasHoleInFront = TRUE;
            continue;
        }

        if (Vcn != TheNextVcn) {

            // This extent is preceded by a gap, so we create
            // a mapping pair with the LCN equal to LCN_NOT_PRESENT.

            CurrentMappingPair->NextVcn = Vcn;
            CurrentMappingPair->CurrentLcn = LCN_NOT_PRESENT;

            CurrentMappingPair++;
            NumberOfPairs++;
        }

        // Create a mapping pair for the extent represented by
        // the current node.  At the same time, compute NextVcn
        // so we can check to see if there's a gap before the
        // next extent.

        TheNextVcn = Vcn + RunLength;

        CurrentMappingPair->NextVcn = TheNextVcn;
        CurrentMappingPair->CurrentLcn = Lcn;

        CurrentMappingPair++;
        NumberOfPairs++;
    }

    DebugAssert(NumberOfPairs < MaximumMappingPairs);

    if (TheNextVcn != _NextVcn) {

        // The last extent is followed by a gap.  Add a mapping pair
        // (with CurrentLcn of LCN_NOT_PRESENT) to cover that gap.

        CurrentMappingPair->NextVcn = _NextVcn;
        CurrentMappingPair->CurrentLcn = LCN_NOT_PRESENT;

        NumberOfPairs++;
        CurrentMappingPair++;
    }

    // We now have a properly set-up array of mapping pairs.  Compress
    // it into the user's buffer.

    Result = CompressMappingPairs( MappingPairs,
                                   NumberOfPairs,
                                   _LowestVcn,
                                   Buffer,
                                   BufferSize,
                                   Length );

    FREE( MappingPairs );

    *LowestVcn = _LowestVcn;
    *NextVcn = _NextVcn;

    return Result;
}

VOID
NTFS_EXTENT_LIST::Truncate(
    IN     BIG_INT      NewNumberOfClusters,
    IN OUT PNTFS_BITMAP Bitmap
    )
/*++

Routine Description:

    This method truncates the extent list.

Arguments:

    NewNumberOfClusters -- supplies the number of clusters to keep.
    Bitmap              -- supplies the volume bitmap (optional).

Return Value:

    None.

Notes:

    If the number of clusters covered by this extent list is already
    less than or equal to NewNumberOfClusters, then this method does
    nothing.

--*/
{
    BIG_INT         new_run_length;
    ULONG           num_extents;

    DebugAssert(_LowestVcn == 0);

    if (NewNumberOfClusters >= _NextVcn) {

        return;
    }

    num_extents = QueryNumberOfExtents();

    for (ULONG i = 0; i < num_extents; ++i) {

        VCN Vcn;
        LCN Lcn;
        BIG_INT RunLength;

        if (!QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            DebugAbort("This shouldn't happen\n");
            return;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            continue;
        }

        if (Vcn >= NewNumberOfClusters) {

            if (NULL != Bitmap) {
                Bitmap->SetFree(Lcn, RunLength);
            }
        } else if (Vcn + RunLength > NewNumberOfClusters) {

            new_run_length = NewNumberOfClusters - Vcn;

            if (NULL != Bitmap) {
                Bitmap->SetFree(Lcn + new_run_length,
                                RunLength - new_run_length);
            }
        }
    }

    _NextVcn = NewNumberOfClusters;
    FsRtlTruncateLargeMcb(_Mcb, _NextVcn.GetLargeInteger().QuadPart);
}



BOOLEAN
NTFS_EXTENT_LIST::QueryMappingPairsLength(
    IN  PCVOID  CompressedPairs,
    IN  ULONG   MaximumLength,
    OUT PULONG  Length,
    OUT PULONG  NumberOfPairs
    )
/*++

Routine Description:

    This function determines the length of a compressed
    mapping pairs list.

Arguments:

    CompressedPairs -- supplies the pointer to the compressed list
    MaximumLength   -- supplies the size of the buffer containing the
                        compressed list.
    Length          -- receives the length of the compressed list
    NumberOfPairs   -- receieves the number of pairs in the list

Return Value:

    TRUE upon successful completion.  FALSE indicates that the list
    overflows the supplied buffer.

--*/
{
    PBYTE CurrentCountByte;
    ULONG CurrentLength;

    CurrentCountByte = (PBYTE)CompressedPairs;

    *NumberOfPairs = 0;
    *Length = 0;

    while( *Length <= MaximumLength &&
           *CurrentCountByte != 0 ) {

        // The length for this pair is the number of LCN bytes, plus
        // the number of VCN bytes, plus one for the count byte.

        CurrentLength = LcnBytesFromCountByte( *CurrentCountByte ) +
                        VcnBytesFromCountByte( *CurrentCountByte ) +
                        1;

        (*NumberOfPairs)++;
        *Length += CurrentLength;

        CurrentCountByte += CurrentLength;
    }

    (*Length)++; // For the final 0 byte.

    return( *Length <= MaximumLength );
}


BOOLEAN
NTFS_EXTENT_LIST::ExpandMappingPairs(
    IN     PCVOID           CompressedPairs,
    IN     VCN              StartingVcn,
    IN     ULONG            BufferSize,
    IN     ULONG            MaximumNumberOfPairs,
    IN OUT PMAPPING_PAIR    MappingPairs,
    OUT    PULONG           NumberOfPairs
    )
/*++

Routine Description:

    This function expands a compressed list of mapping pairs into
    a client-supplied buffer.

Arguments:

    CompressedPairs         -- supplies the compressed mapping pairs
    StartingVcn             -- supplies the lowest VCN mapped by these
                                mapping pairs
    BufferSize              -- supplies the maximum size of the buffer from
                                which the compressed pairs are expanded
    MaximumNumberOfPairs    -- supplies the maximum number of expanded
                                mapping pairs the output buffer can accept
    MappingPairs            -- receives the expanded pairs
    NumberOfPairs           -- receives the number of pairs

Return Value:

    TRUE upon successful completion.

--*/
{
    PBYTE CurrentData;
    VCN CurrentVcn;
    LCN CurrentLcn;
    UCHAR v, l;
    ULONG CurrentLength;
    VCN DeltaVcn;
    LCN DeltaLcn;
    ULONG PairIndex;


    CurrentData = (PBYTE)CompressedPairs;
    CurrentVcn = StartingVcn;
    CurrentLcn = 0;
    CurrentLength = 0;
    PairIndex = 0;

    while(  CurrentLength < BufferSize &&
            *CurrentData != 0 &&
            PairIndex < MaximumNumberOfPairs
            ) {

        // Get the count byte.  Note that whenever we advance the
        // current data pointer, we first increment the length count,
        // to make sure our access is valid.

        CurrentLength ++;

        if( CurrentLength > BufferSize ) {

            return FALSE;
        }

        v = VcnBytesFromCountByte( *CurrentData );
        l = LcnBytesFromCountByte( *CurrentData );

        CurrentData ++;


        // Unpack DeltaVcn and compute the current VCN:

        CurrentLength += v;

        if( v > 8 || CurrentLength > BufferSize ) {

            return FALSE;
        }

        DeltaVcn.Set( v, CurrentData );
        CurrentData += v;

        CurrentVcn += DeltaVcn;
        MappingPairs[PairIndex].NextVcn = CurrentVcn;

        // Unpack DeltaLcn and compute the current LCN:
        //
        CurrentLength += l;

        if( l > 8 || CurrentLength > BufferSize ) {

            return FALSE;
        }

        if( l == 0 ) {

            // a delta-LCN count value of 0 indicates a
            // non-present run.
            //
            MappingPairs[PairIndex].CurrentLcn = LCN_NOT_PRESENT;

        } else {

            DeltaLcn.Set( l, CurrentData );
            CurrentLcn += DeltaLcn;
            MappingPairs[PairIndex].CurrentLcn = CurrentLcn;
        }

        CurrentData += l;
        PairIndex ++;
    }

    *NumberOfPairs = PairIndex;

    return( CurrentLength <= BufferSize &&
            *CurrentData == 0 &&
            PairIndex <= MaximumNumberOfPairs );
}


BOOLEAN
NTFS_EXTENT_LIST::CompressMappingPairs(
    IN      PCMAPPING_PAIR  MappingPairs,
    IN      ULONG           NumberOfPairs,
    IN      VCN             StartingVcn,
    IN OUT  PVOID           CompressedPairs,
    IN      ULONG           MaximumCompressedLength,
    OUT     PULONG          CompressedLength
    )
/*++

Notes:

    The returned length includes the terminating NULL count byte.

--*/
{
    PBYTE CurrentData;
    VCN CurrentVcn;
    LCN CurrentLcn;
    ULONG CurrentLength;
    VCN DeltaVcn;
    LCN DeltaLcn;
    ULONG i;
    UCHAR ComDeltaVcn[sizeof(VCN)];
    UCHAR ComDeltaLcn[sizeof(LCN)];
    UCHAR VcnLength;
    UCHAR LcnLength;
    UCHAR Major, Minor;
    BOOLEAN NewSparseFormat;

    // Determine whether to use the old or new format for
    // representing sparse files.
    //
    NTFS_SA::QueryVersionNumber( &Major, &Minor );
    NewSparseFormat = (Major > 1) || (Major == 1 && Minor > 1);

    // A mapping pair is (NextVcn, CurrentLcn); however, the compressed
    // form is a list of deltas.

    CurrentData = (PBYTE)CompressedPairs;
    CurrentVcn = StartingVcn;
    CurrentLcn = 0;
    CurrentLength = 0;

    for( i = 0; i < NumberOfPairs; i++ ) {

        DeltaVcn = MappingPairs[i].NextVcn - CurrentVcn;
        DeltaLcn = MappingPairs[i].CurrentLcn - CurrentLcn;

        DeltaVcn.QueryCompressedInteger(&VcnLength, ComDeltaVcn);

        if( NewSparseFormat && MappingPairs[i].CurrentLcn == LCN_NOT_PRESENT ) {

            LcnLength = 0;
            DeltaLcn = 0;

        } else {

            DeltaLcn.QueryCompressedInteger(&LcnLength, ComDeltaLcn);
        }

        // Fill in the count byte and step over it.

        CurrentLength ++;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        *CurrentData = ComputeMappingPairCountByte( VcnLength, LcnLength );
        CurrentData ++;


        // Copy DeltaVcn and advance the pointer

        CurrentLength += VcnLength;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        memcpy( CurrentData, ComDeltaVcn, VcnLength );
        CurrentData += VcnLength;


        // Copy DeltaLcn and advance the pointer

        CurrentLength += LcnLength;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        memcpy( CurrentData, ComDeltaLcn, LcnLength );
        CurrentData += LcnLength;

        CurrentVcn += DeltaVcn;
        CurrentLcn += DeltaLcn;
    }

    // Terminate the compressed list with a zero count byte

    CurrentLength ++;

    if( CurrentLength > MaximumCompressedLength ) {

        return FALSE;
    }

    *CurrentData = 0;
    CurrentData ++;

    *CompressedLength = CurrentLength;
    return TRUE;
}


LCN
NTFS_EXTENT_LIST::QueryLastLcn(
    ) CONST
/*++

Routine Description:

    This method returns the last LCN associated with this allocation.
    If it cannot determine that LCN, it returns an LCN of zero.

Arguments:

    None.

Return Value:

    The LCN of the last cluster in the extent list (or zero, if
    the list is empty or we can't determine the last cluster).

--*/
{
    LCN TempLcn;

    if( QueryLcnFromVcn( _NextVcn - 1, &TempLcn ) &&
        TempLcn != LCN_NOT_PRESENT ) {

        return TempLcn;

    } else {

        return( 0 );
    }
}



BOOLEAN
NTFS_EXTENT_LIST::DeleteRange(
    IN  VCN     Vcn,
    IN  BIG_INT RunLength
    )
/*++

Routine Description:

    This routine will remove any vcn's in the range specified from
    the extent list.  If this does not exist or exists only partially
    then those parts that exist will be removed.

Arguments:

    Vcn         - Supplies the first Vcn of the range.
    RunLength   - Supplies the length of the range.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FsRtlRemoveLargeMcbEntry(_Mcb,
                             Vcn.GetLargeInteger().QuadPart,
                             RunLength.GetLargeInteger().QuadPart
                             );

    return TRUE;
}



BIG_INT
NTFS_EXTENT_LIST::QueryClustersAllocated(
    ) CONST
/*++

Routine Description:

    This routine computes the number of clusters allocated for this
    attribute.

Arguments:

    None.

Return Value:

    The number of clusters allocated by this attribute.

--*/
{
    ULONG   i;
    VCN     vcn;
    LCN     lcn;
    BIG_INT run_length;
    BIG_INT r;

    r = 0;
    for (i = 0; QueryExtent(i, &vcn, &lcn, &run_length); i++) {

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }
        r += run_length;
    }

    return r;
}


VOID
NTFS_EXTENT_LIST::SetLowestVcn(
    IN BIG_INT  LowestVcn
    )
/*++

Routine Description:

    This method sets the lowest VCN covered by this extent
    list.  Note that for a sparse file, this is not necessarily
    the same as the VCN of the first extent in the list.

Arguments:

    The lowest VCN mapped by this extent list.  Note that this must
    be less than or equal to the starting VCN of the first entry
    in the list.

Return Value:

    None.

--*/
{
    _LowestVcn = LowestVcn;
}

VOID
NTFS_EXTENT_LIST::SetNextVcn(
    IN BIG_INT NextVcn
    )
/*++

Routine Description:

    This method sets the highest VCN covered by this extent
    list.  Note that for a sparse file, this is not necessarily
    the same as the last VCN of the last extent in the list.

Arguments:

    The highest VCN mapped by this extent list.

Return Value:

    None.

--*/
{
    _NextVcn = NextVcn;
}

UNTFS_EXPORT
ULONG
NTFS_EXTENT_LIST::QueryNumberOfExtents(
    ) CONST
/*++

Routine Description:

    This methods tells the client how many extents are in the
    extent list.

Arguments:

    None.

Return Value:

    The number of extents in the list.

--*/
{
    return FsRtlNumberOfRunsInLargeMcb((PLARGE_MCB)_Mcb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\indxroot.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    indxroot.hxx

Abstract:

    this module contains the member funciton definitions for the
    NTFS_INDEX_ROOT class, which models the root of an NTFS index

Author:

    Bill McJohn (billmc) 06-Sept-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"

DEFINE_CONSTRUCTOR( NTFS_INDEX_ROOT, OBJECT );

NTFS_INDEX_ROOT::~NTFS_INDEX_ROOT(
    )
{
    Destroy();
}


VOID
NTFS_INDEX_ROOT::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _MaximumSize = 0;
    _DataLength = 0;
    _Data = NULL;
    _IsModified = FALSE;
    _UpcaseTable = NULL;

}

VOID
NTFS_INDEX_ROOT::Destroy(
    )
/*++

Routine Description:

    This method cleans up an NTFS_INDEX_ROOT object in preparation
    for destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _MaximumSize = 0;
    _DataLength = 0;
    FREE( _Data );
    _IsModified = FALSE;
    _UpcaseTable = NULL;

}


BOOLEAN
NTFS_INDEX_ROOT::Initialize(
    IN PNTFS_ATTRIBUTE      RootAttribute,
    IN PNTFS_UPCASE_TABLE   UpcaseTable,
    IN ULONG                MaximumSize
    )
/*++

Routine Description:

    This method initializes the index root based on an $INDEX_ROOT
    attribute.  It is used to initialize an index root object for
    an extant index.

Arguments:

    RootAttribute   --  supplies the $INDEX_ROOT attribute for
                        this index.
    UpcaseTable     --  supplies the volume upcase table.
    MaximumSize     --  supplies the maximum size of this index root

Return Value:

    TRUE upon successful completion.

Notes:

    If the existing attribute's value length is greater than the
    supplied maximum size, the maximum size will be adjusted.

--*/
{
    BIG_INT ValueLength;
    ULONG BytesRead;

    DebugPtrAssert( RootAttribute );

    Destroy();

    RootAttribute->QueryValueLength( &ValueLength );

    // Check that the attribute is the correct type and that
    // it is a reasonable size.

    if( RootAttribute->QueryTypeCode() != $INDEX_ROOT ||
        ValueLength.GetHighPart() != 0  ) {

        return FALSE;
    }

    // If the existing attribute is already bigger than the specified
    // maximum size, then increase the maximum size, since it is only
    // provided to give an upper bound on the size of the attribute.

    if( ValueLength.GetLowPart() > MaximumSize ) {

        MaximumSize = ValueLength.GetLowPart();
    }

    _DataLength = ValueLength.GetLowPart();
    _MaximumSize = MaximumSize;
    _IsModified = FALSE;

    if( (_Data = (PINDEX_ROOT)MALLOC( _MaximumSize )) == NULL ) {

        Destroy();
        return FALSE;
    }

    if( !RootAttribute->Read( _Data,
                              0,
                              _DataLength,
                              &BytesRead ) ||
        BytesRead != _DataLength ) {

        Destroy();
        return FALSE;
    }

    _UpcaseTable = UpcaseTable;

    return TRUE;
}


BOOLEAN
NTFS_INDEX_ROOT::Initialize(
    IN ATTRIBUTE_TYPE_CODE  IndexedAttributeType,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable,
    IN ULONG                ClustersPerBuffer,
    IN ULONG                BytesPerBuffer,
    IN ULONG                MaximumRootSize
    )
/*++

Routine Description:

    This method initializes the index root based on the fundamental
    information of the index.  It is used to initialize an index root
    for a new index.

Arguments:

    IndexedAttributeType    --  supplies the type code of the attribute
                                which is indexed by this index.
    CollationRule           --  supplies the collation rule for this index.
    UpcaseTable             --  supplies the volume upcase table.
    BytesPerBuffer          --  supplies the number of bytes per Index
                                Allocation Buffer in this index.
    MaximumRootSize         --  supplies the maximum size of this index root.

Return Value:

    TRUE upon successful completion.

Notes:

    This method marks the index root as modified, since it is being
    created ex nihilo instead of being read from an attribute.

    It creates an empty leaf index root (ie. with only an END entry).

--*/
{
    PINDEX_ENTRY EndEntry;

    DebugAssert( sizeof( INDEX_ROOT ) % 8 == 0 );
    DebugAssert( sizeof( INDEX_HEADER ) % 8 == 0 );

    Destroy();

    _UpcaseTable = UpcaseTable;
    _MaximumSize = MaximumRootSize;
    _IsModified = TRUE;

    _DataLength = sizeof( INDEX_ROOT ) + NtfsIndexLeafEndEntrySize;

    // check to make sure that an empty index root will fit in the
    // maximum size given.  Note that we also reserve space for a
    // VCN downpointer, in case this index root gets converted into
    // a node by Recreate.

    if( _DataLength + sizeof(VCN) > _MaximumSize ) {

        Destroy();
        return FALSE;
    }

    if( (_Data = (PINDEX_ROOT)MALLOC( _MaximumSize )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memset( _Data, 0, _MaximumSize );

    _Data->IndexedAttributeType = IndexedAttributeType;
    _Data->CollationRule = CollationRule;
    _Data->BytesPerIndexBuffer = BytesPerBuffer;
    _Data->ClustersPerIndexBuffer = (UCHAR)ClustersPerBuffer;
    _Data->IndexHeader.FirstIndexEntry = sizeof( INDEX_HEADER );
    _Data->IndexHeader.FirstFreeByte = sizeof( INDEX_HEADER ) +
                                            NtfsIndexLeafEndEntrySize;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;
    _Data->IndexHeader.Flags = 0;

    // Fill in the end entry.  Its only meaningful fields are Length
    // and Flags.

    EndEntry = GetFirstEntry();

    EndEntry->Length = NtfsIndexLeafEndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    return TRUE;
}


BOOLEAN
NTFS_INDEX_ROOT::FindEntry(
    IN      PCINDEX_ENTRY       SearchEntry,
    IN OUT  PULONG              Ordinal,
    OUT     PINDEX_ENTRY*       EntryFound
    )
/*++

Routine Description:

    This method locates an entry in the index root.  Note that it does
    not search the index allocation b-tree (if any).


Arguments:

    SearchEntry --  Supplies a search entry, which gives the attribute
                    value to find.
    Ordinal     --  supplies an ordinal showing which matching entry
                    to return; see note below.  A value of INDEX_SKIP
                    indicates that all matching entries should be skipped.
    EntryFound  --  receives a pointer to the located entry.  Receives
                    NULL if an error has occurred.

Return Value:

    TRUE if a matching entry is found.

    If an error occurs, *EntryFound is set to NULL.

    If no error occurs, and no matching entry is found, *EntryFound
    is set to the next entry (i.e. the point at which the search key
    would be inserted into this index root) and the method returns
    FALSE.

Notes:

    This method assumes that the index root is consistent.

    The ordinal argument indicates how many matching entries should be
    passed over before one is returned.  When an entry is found which
    matches the search key, if *Ordinal is zero, that entry is returned;
    otherwise, *Ordinal is decremented, and the FindEntry goes on to
    the next entry.

    If *Ordinal is INDEX_SKIP, all matching entries are skipped.

--*/
{
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN Found;
    int CompareResult;

    CurrentEntry = GetFirstEntry();
    Found = FALSE;

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CompareResult = CompareNtfsIndexEntries( SearchEntry,
                                                 CurrentEntry,
                                                 _Data->CollationRule,
                                                 _UpcaseTable);

        if( CompareResult < 0 ) {

            // The search value is less than the current entry's
            // value, so we've overshot where our search key would
            // be.  Stop (and return the current entry).

            break;

        } else if( CompareResult == 0 ) {

            // The current entry matches the search entry.  Check
            // the ordinal argument to see if we should return this
            // entry or skip it.

            if( *Ordinal == 0 ) {

                Found = TRUE;
                break;

            } else if( *Ordinal != INDEX_SKIP ) {

                *Ordinal -= 1;
            }
        }

        // Haven't found our entry, so we'll just go on to the next.

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    *EntryFound = CurrentEntry;
    return( Found );
}


BOOLEAN
NTFS_INDEX_ROOT::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  PINDEX_ENTRY    InsertPoint
    )
/*++

Routine Description:

    This inserts an index entry into the index root.  It will
    expand the index root (if possible), but it will not split it.

Arguments:

    NewEntry    --  supplies the new entry to be inserted.
    InsertPoint --  supplies the point at which the new entry should be
                    inserted--it may be NULL, in which case the index
                    root should decide for itself.

Return Value:

    TRUE upon successful completion.

Notes:

    A return value of FALSE indicates that there is not enough room
    for the entry in this index root.

    If an insertion point is specified, it must be a pointer returned
    by a previous call to FindEntry or GetFirstEntry (with no intervening
    inserts or deletes).

    This method assumes that the index root and the new entry are
    consistent, which includes that the entry has a downpointer if
    and only if the index root is a node.

--*/
{
    ULONG Ordinal, BytesToMove;


    //  Check to see if there's room.

    if( _DataLength + NewEntry->Length  > _MaximumSize ) {

        return FALSE;
    }

    //  There's enough room, so we're bound to succeed.

    if( InsertPoint == NULL ) {

        // The client has not supplied the insert point, so we get to
        // figure it out for ourselves.  Fortunately, we can get FindEntry
        // to do our work for us.

        // Note that we don't care what InsertEntry returns--we know it
        // won't hit an error, and we don't care whether there are any
        // matching entries in the buffer.  (If we get a matching buffer,
        // we insert the new one before it, which is just fine.)

        Ordinal = 0;

        FindEntry( NewEntry,
                   &Ordinal,
                   &InsertPoint );

        DebugPtrAssert( InsertPoint );
    }


    // Make room for the new entry...

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)((PBYTE)InsertPoint - (PBYTE)&(_Data->IndexHeader));

    memmove( (PBYTE)InsertPoint + NewEntry->Length,
             InsertPoint,
             BytesToMove );

    _Data->IndexHeader.FirstFreeByte += NewEntry->Length;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    memcpy( InsertPoint, NewEntry, NewEntry->Length );

    _DataLength += NewEntry->Length;

    return TRUE;
}


VOID
NTFS_INDEX_ROOT::RemoveEntry(
    PINDEX_ENTRY EntryToRemove
    )
/*++

Routine Description:

    This method removes an entry from the index root.  Note that it will
    not find a replacement entry for nodes, or perform any other b-tree
    maintenance; it just expunges the entry from the root.

Arguments:

    EntryToRemove   --  supplies the index entry to be removed.  This
                        must be an entry returned by a previous call
                        to FindEntry or GetFirstEntry.

Return Value:

    None.

Notes:

    This method assumes that the index root is consistent.
--*/
{
    PBYTE NextEntry;
    ULONG BytesToMove;


    DebugAssert( (PBYTE)EntryToRemove <
               (PBYTE)&(_Data->IndexHeader) +
                    _Data->IndexHeader.FirstFreeByte );

    DebugAssert( (PBYTE)EntryToRemove >=
               (PBYTE)&(_Data->IndexHeader) +
                    _Data->IndexHeader.FirstIndexEntry );

    NextEntry = (PBYTE)GetNextEntry( EntryToRemove );

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)( NextEntry - (PBYTE)&(_Data->IndexHeader) );

    _Data->IndexHeader.FirstFreeByte -= EntryToRemove->Length;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    _DataLength -= EntryToRemove->Length;

    memmove( EntryToRemove,
             NextEntry,
             BytesToMove );

}



VOID
NTFS_INDEX_ROOT::Recreate(
    IN BOOLEAN  IsLeaf,
    IN VCN      EndEntryDownpointer
    )
/*++

Routine Description:

    This method recreates the Index Root with only an end entry.

Arguments:

    IsLeaf              --  supplies an indicator whether this index root
                            is a leaf (TRUE) or a node (FALSE).
    EndEntryDownpointer --  supplies the VCN DownPointer for the End
                            Entry.  (If IsLeaf is TRUE, this parameter
                            is ignored.)

Return Value:

    None.

Notes:

    The basic information of the index root is not changed; just the
    index entries and flags.

--*/
{
    PINDEX_ENTRY EndEntry;
    ULONG EndEntrySize;

    _IsModified = TRUE;
    _DataLength = sizeof( INDEX_ROOT ) + NtfsIndexLeafEndEntrySize;

    EndEntrySize = NtfsIndexLeafEndEntrySize;

    if( !IsLeaf ) {

        _Data->IndexHeader.Flags = INDEX_NODE;
        _DataLength += sizeof(VCN);
        EndEntrySize += sizeof( VCN );

    } else {

        _Data->IndexHeader.Flags = 0;
    }

    DebugAssert( _MaximumSize >= _DataLength );

    _Data->IndexHeader.FirstFreeByte = sizeof( INDEX_HEADER ) +
                                            EndEntrySize;

    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    // Fill in the end entry.  Its only meaningful fields are Length,
    // Flags, and downpointer (if any).

    EndEntry = GetFirstEntry();

    memset(&(EndEntry->FileReference), 0, sizeof(FILE_REFERENCE));
    EndEntry->Length = (USHORT)EndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    if( !IsLeaf ) {

        EndEntry->Flags |= INDEX_ENTRY_NODE;
        GetDownpointer( EndEntry ) = EndEntryDownpointer;
    }
}


BOOLEAN
NTFS_INDEX_ROOT::Write(
    PNTFS_ATTRIBUTE RootAttribute
    )
/*++

Routine Description:

    This method writes the index root to the supplied attribute.

Arguments:

    RootAttribute   --  supplies the INDEX_ROOT attribute.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG BytesWritten;

    // Resize the attribute to the correct size, and then write
    // the root's data to it.  Since this attribute is always
    // resident, pass in NULL for the bitmap.
    //

    return( RootAttribute->IsResident() &&
            RootAttribute->Resize( _DataLength, NULL ) &&
            RootAttribute->Write( _Data,
                                  0,
                                  _DataLength,
                                  &BytesWritten,
                                  NULL ) &&
            BytesWritten == _DataLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\indxchk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    indxchk.cxx

Abstract:

    This module implements the index verification stage of chkdsk.

Author:

    Norbert P. Kusters (norbertk) 10-Feb-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"

//#define TIMING_ANALYSIS     1

extern "C" {
    #include <stdio.h>
#if defined(TIMING_ANALYSIS)
    #include <time.h>
#endif
}

#include "ntfssa.hxx"

#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrib.hxx"
#include "attrdef.hxx"
#include "mft.hxx"
#include "numset.hxx"
#include "indxtree.hxx"
#include "attrcol.hxx"
#include "ifssys.hxx"
#include "digraph.hxx"
#include "ifsentry.hxx"

// This global flag is used to signal that incorrect duplicated
// information was found in some of the file name indices on the
// disk.

STATIC BOOLEAN  FileSystemConsistencyErrorsFound = FALSE;

// This is used to indicate that we are intentionally using an 
// assignment within a condition.
// The weird construct is designed to appease PREFAST
#define SET_TRUE(x)  (((x)=TRUE) == TRUE)

#define MAX_NUMBER_OF_BANDS         10

#define FRS_DATA_RECORD_MAX_SIZE    250

//
// A replicate of the structure defined in ntos\rtl\gentable.c
//
typedef struct _TABLE_ENTRY_HEADER {
    RTL_SPLAY_LINKS     SplayLinks;
    LIST_ENTRY          ListEntry;
    LONGLONG            UserData;
} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

BOOLEAN
NTFS_SA::ValidateIndices(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PDIGRAPH                    DirectoryDigraph,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN      USHORT                      Algorithm,
    IN      BOOLEAN                     SkipEntriesScan,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine validates the EAs and indices on the volume.  A complete
    list of all files which may (or may not) contain EAs or indices is
    supplied.  This, along with a valid Mft makes this validation possible.

Arguments:

    ChkdskInfo              - Supplies the current chkdsk information.
    DirectoryDigraph        - Returns a digraph of the directory structure.
    Mft                     - Supplies a valid MFT.
    AttributeDefTable       - Supplies the attribute definition table.
    ChkdskReport            - Supplies the current chkdsk report to be updated
                                by this routine.
    BadClusters             - Supplies the bad cluster list.
    SkipEntriesScan         - Supplies if index entries checking should be skipped.
    SkipCycleScan           - Supplies if cycles within directory tree should be checked.
    FixLevel                - Supplies the fix level.
    Message                 - Supplies an outlet for messages.
    DiskErrorsFound         - Supplies whether or not disk errors have been
                                found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, j;
    NTFS_ATTRIBUTE              bitmap_attrib;
    NTFS_ATTRIBUTE              root_attrib;
    NTFS_ATTRIBUTE              alloc_attrib;
    NTFS_BITMAP                 alloc_bitmap;
    PINDEX_ROOT                 index_root;
    ATTRIBUTE_TYPE_CODE         indexed_attribute_type;
    BOOLEAN                     alloc_present;
    BOOLEAN                     need_write;
    BOOLEAN                     complete_failure;
    PVOID                       bitmap_value;
    ULONG                       bitmap_length;
    ULONG                       attr_def_index;
    BOOLEAN                     tube;
    BOOLEAN                     ErrorInAttribute;
    NTFS_INDEX_TREE             index;
    BOOLEAN                     changes;
    ULONG                       percent_done = 0;
    ULONG                       new_percent = 0;
    BIG_INT                     num_file_names = 0;
    BOOLEAN                     error_in_index;
    BOOLEAN                     duplicates_allowed;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    DSTRING                     index_name;
    NTFS_MFT_INFO               mft_info;
    BOOLEAN                     files_with_too_many_filenames;

    SYSTEM_BASIC_INFORMATION    sys_basic_info;
    NTSTATUS                    status;
    BIG_INT                     pages_for_mft_info, pages_for_others;
    BIG_INT                     pages_needed, pages_available;
    ULONG                       bytes_per_frs;
    BIG_INT                     total_bytes_needed, bytes_needed;
    BIG_INT                     max_mem_use_for_mft_info;
    ULONG64                     vm_pages;
    ULONG64                     max_vm_pages;

    LONG                        order = -1;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    time_t                      timel1, timel2;
    PCHAR                       timestr;
#endif

    DebugAssert(ChkdskInfo);
    DebugAssert(Mft);
    DebugAssert(ChkdskReport);
    DebugAssert(Message);

    if (SkipEntriesScan || Algorithm == 0) {
        if (Algorithm == 0) {
            Message->DisplayMsg(MSG_CHK_NTFS_SLOWER_ALGORITHM);
        } else
            Algorithm = 0;
    } else {

        //
        // Obtain number of physical pages and page size first
        //
        status = NtQuerySystemInformation(SystemBasicInformation,
                                          &sys_basic_info,
                                          sizeof(sys_basic_info),
                                          NULL);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("UNTFS: NtQuerySystemInformation(SystemBasicInformation) failed (%x)\n", status));
            return FALSE;
        }

        vm_pages = (sys_basic_info.MaximumUserModeAddress -
                    sys_basic_info.MinimumUserModeAddress)/sys_basic_info.PageSize;
        max_vm_pages = vm_pages;

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Page Size = %x\n", sys_basic_info.PageSize));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: User Virtual pages = %I64x\n", vm_pages));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Physical pages = %x\n", sys_basic_info.NumberOfPhysicalPages));

        if (sys_basic_info.NumberOfPhysicalPages < vm_pages) {
            vm_pages = sys_basic_info.NumberOfPhysicalPages;
        }



#if defined(_AUTOCHECK_)
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: AvailablePages = %x\n", ChkdskInfo->AvailablePages));

        if (ChkdskInfo->AvailablePages < vm_pages)
            vm_pages = ChkdskInfo->AvailablePages;
#endif

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Final pages available = %I64x\n", vm_pages));

        if (Algorithm != CHKDSK_ALGORITHM_NOT_SPECIFIED &&
            Algorithm > ChkdskInfo->BaseFrsCount) {
            Message->DisplayMsg(MSG_CHK_NTFS_ADJUST_INDEX_PASSES, "%d", Algorithm);
            Algorithm = max(1, (USHORT)ChkdskInfo->BaseFrsCount);
        }

        //
        // Figure out the approximate amount of memory needed
        //
        pages_for_mft_info =
            (ChkdskInfo->BaseFrsCount *
             (sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO)) +
             ChkdskInfo->TotalNumFileNames *
             sizeof(_NTFS_FILE_NAME_INFO) +
             (sys_basic_info.PageSize - 1)
            )/sys_basic_info.PageSize;

        pages_for_others = ChkdskInfo->NumFiles;

        bytes_per_frs = ((FIELD_OFFSET(TABLE_ENTRY_HEADER, UserData)+
                          sizeof(CHILD_ENTRY)+sizeof(PVOID)+sizeof(USHORT)*2)*8+4);
                                    // 44.5(32-bit) or 64.5(64-bit) bytes/frs scaled up by 8
                                    // Here are the four bitmaps: mft_bitmap,
                                    // FilesWithIndices, FilesWhoNeedData,
                                    // FilesWithReparsePoint
                                    // plus 36(32-bit) or 56(64-bit) bytes for each edge
                                    // plus 2 bytes for NumFileNames
                                    // plus 2 bytes for ReferenceCount
                                    // plus sizeof(PVOID) bytes for mft_info

        if (SkipCycleScan)
            bytes_per_frs -= ((sizeof(CHILD_ENTRY)+
                               FIELD_OFFSET(TABLE_ENTRY_HEADER, UserData))*8);// less edge scaled by 8

        pages_for_others = ((pages_for_others*bytes_per_frs) +
                            Mft->GetVolumeBitmap()->QuerySize() +
                            (sys_basic_info.PageSize * 8 - 1))/
                            (sys_basic_info.PageSize * 8); // include the volume_bitmap

        pages_needed = pages_for_others + pages_for_mft_info;

        // leave 10% margin
        pages_available = vm_pages;
        pages_available = (pages_available * 9)/10;

        if (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED &&
            pages_for_others > pages_available) {

            Algorithm = 0;  // use old & slow algorithm

            if (pages_needed > max_vm_pages) {
                Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILES_TO_RUN_AT_FULL_SPEED);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_MORE_MEMORY_IS_NEEDED_TO_RUN_AT_FULL_SPEED, "%d",
                                    max(1, ((pages_needed - pages_available)*sys_basic_info.PageSize/1024/1024)));
            }


        } else if (Algorithm == 1 ||
                   (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED &&
                    pages_needed <= pages_available)) {
            Algorithm = 1;  // perfect, use the fastest algorithm
            max_mem_use_for_mft_info = -1;
        } else {

            // not enough memory to do it in one pass
            // let see if it can be done in multiple pass

            if (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED) {

                if (pages_needed > max_vm_pages) {
                    Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILES_TO_RUN_AT_FULL_SPEED);
                } else {
                    Message->DisplayMsg(MSG_CHK_NTFS_MORE_MEMORY_IS_NEEDED_TO_RUN_AT_FULL_SPEED, "%d",
                                        max(1, ((pages_needed - pages_available)*sys_basic_info.PageSize/1024/1024)));
                }

                total_bytes_needed = 0;

                max_mem_use_for_mft_info =
                    (pages_available - pages_for_others) * sys_basic_info.PageSize;

                //
                // figure out how many passes is needed
                // by counting how many base frs and how many names in each of them
                //

                Algorithm = 1;  // at least one pass

                for (i=0; i<ChkdskInfo->NumFiles; i++) {

                    if (ChkdskInfo->NumFileNames[i] != 0) {

                        bytes_needed =
                            (sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO)) +
                             ChkdskInfo->NumFileNames[i] * sizeof(_NTFS_FILE_NAME_INFO);

                        total_bytes_needed += bytes_needed;
                        if (total_bytes_needed > max_mem_use_for_mft_info) {
                            total_bytes_needed = bytes_needed;
                            Algorithm++;
                            if (Algorithm > MAX_NUMBER_OF_BANDS) {
                                Algorithm = 0;
                                Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_PASSES, "%d", MAX_NUMBER_OF_BANDS);
                                break;
                            }
                        }
                    }
                }
            } else
                max_mem_use_for_mft_info = -1;

            if (Algorithm) {
                //
                // recalculate max_mem_use_for_mft_info so as to even out the
                // usage of memory
                //
                bytes_needed = (pages_for_mft_info * sys_basic_info.PageSize+Algorithm)/Algorithm;
                if (max_mem_use_for_mft_info != -1) {
                    DebugAssert(bytes_needed <= max_mem_use_for_mft_info);
                }
                max_mem_use_for_mft_info = bytes_needed;
                Message->DisplayMsg(MSG_CHK_NTFS_PASSES_NEEDED, "%d", Algorithm);
            }
        }
    }

    if (!DirectoryDigraph->Initialize(ChkdskInfo->NumFiles)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_INDICES, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 2, GetNumberOfStages());
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "Before stage 2: ", timestr);
#endif

    if (Algorithm == 0) {

        if (SkipEntriesScan) {
            if (!ChkdskInfo->IndexEntriesToCheck.Initialize(ChkdskInfo->NumFiles,
                                                            TRUE)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            ChkdskInfo->IndexEntriesToCheckIsSet = FALSE;
        }

        ChkdskInfo->TotalNumFileNames += ((ChkdskInfo->NumFiles/16) + 1);

        for (i = 0; i < ChkdskInfo->NumFiles; i++) {

            if ((i & 0xF) == 0) {
                num_file_names += 1;
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {

                new_percent = (((num_file_names)*90) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                if (new_percent != percent_done) {
                    percent_done = new_percent;
                    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                        return FALSE;
                    }
                }
                continue;
            }

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // The following loop deletes all $INDEX_ALLOCATION attributes that
            // don't have a corresponding $INDEX_ROOT attribute.

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&alloc_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ALLOCATION,
                                                    j); j++) {

                // Make sure that there's an index root of the same name
                // here.  Otherwise tube this attribute.

                if (frs.IsAttributePresent($INDEX_ROOT, alloc_attrib.GetName())) {
                    continue;
                }

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INDEX_ROOT,
                             "%I64x%W",
                             frs.QueryFileNumber().GetLargeInteger(),
                             alloc_attrib.GetName());

                Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                 "%d%W",
                        frs.QueryFileNumber().GetLowPart(),
                        alloc_attrib.GetName());
                DebugPrintTrace(("UNTFS: Index allocation without index root.\n"));

                need_write = TRUE;

                if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                        alloc_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Because we deleted a $INDEX_ALLOCATION we need to
                // adjust j.

                j--;


                // If there's a $BITMAP then tube that also.

                if (!frs.QueryAttribute(&bitmap_attrib,
                                        &ErrorInAttribute,
                                        $BITMAP,
                                        alloc_attrib.GetName())) {

                    if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    continue;
                }

                if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                        bitmap_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }


            // This loop goes through all of the $INDEX_ROOT attributes in
            // this FRS.

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                // First find out if we have an INDEX_ALLOCATION here.

                alloc_present = frs.QueryAttribute(&alloc_attrib,
                                                   &ErrorInAttribute,
                                                   $INDEX_ALLOCATION,
                                                   root_attrib.GetName());

                if (!alloc_present && ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                error_in_index = FALSE;

                if (!VerifyAndFixIndex(ChkdskInfo,
                                       &root_attrib,
                                       alloc_present ? &alloc_attrib : NULL,
                                       alloc_present ? &alloc_bitmap : NULL,
                                       frs.QueryFileNumber(),
                                       BadClusters,
                                       Mft,
                                       AttributeDefTable,
                                       &tube,
                                       &order,
                                       FixLevel, Message,
                                       &error_in_index)) {

                    return FALSE;
                }

                *DiskErrorsFound = *DiskErrorsFound || error_in_index;

                if (tube) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    need_write = TRUE;

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_INDEX,
                            "%d%W",
                            frs.QueryFileNumber().GetLowPart(),
                            root_attrib.GetName());

                    if (!root_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(root_attrib.QueryTypeCode(),
                                            root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    // Adjust j because an $INDEX_ROOT has just been removed.

                    j--;

                    if (alloc_present) {

                        if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                                alloc_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (frs.QueryAttribute(&bitmap_attrib,
                                               &ErrorInAttribute,
                                               $BITMAP,
                                               root_attrib.GetName())) {

                            if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                                !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                    bitmap_attrib.GetName())) {

                                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                                return FALSE;
                            }
                        } else if (ErrorInAttribute) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    }

                    if (!index_name.Initialize(FileNameIndexNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (index_name.Strcmp(root_attrib.GetName()) == 0) {
                        frs.ClearIndexPresent();
                        ChkdskInfo->FilesWhoNeedData.SetAllocated(i, 1);
                    }
                    ChkdskInfo->CountFilesWithIndices -= 1;
                    ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                    continue;
                }

                if (root_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!root_attrib.InsertIntoFile(&frs,
                                                    Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present && alloc_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!alloc_attrib.InsertIntoFile(&frs,
                                                     Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present) {

                    BOOLEAN bitmap_present;
                    BOOLEAN bitmaps_equal;
                    BOOLEAN error;

                    // Make sure the bitmap is present and good.

                    complete_failure = FALSE;

                    bitmap_present = frs.QueryAttribute(&bitmap_attrib,
                                                        &ErrorInAttribute,
                                                        $BITMAP,
                                                        root_attrib.GetName());

                    if (bitmap_present) {
                        bitmaps_equal = AreBitmapsEqual(&bitmap_attrib,
                                                        &alloc_bitmap,
                                                        alloc_bitmap.QuerySize(),
                                                        Message,
                                                        &complete_failure);

                        //
                        // Make an exception here for cases where our internal bitmap
                        // is size zero but there is a positively-sized bitmap attribute,
                        // as long as the bitmap attribute's contents are zeroed.  The
                        // filesystem can leave the disk in this state after all the files
                        // are deleted from a large directory.
                        //

                        if (!bitmaps_equal && alloc_bitmap.QuerySize() == 0 &&
                            bitmap_attrib.QueryValueLength() > 0 &&
                            bitmap_attrib.IsAllocationZeroed()) {

                            bitmaps_equal = TRUE;
                        }
                    }


                    if (!bitmap_present || !bitmaps_equal) {

                        MSGID   msgid;

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (!bitmap_present) {
                            msgid = MSG_CHKLOG_NTFS_INDEX_BITMAP_MISSING;
                        } else {
                            DebugAssert(!bitmaps_equal);
                            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_BITMAP;
                        }
                        Message->LogMsg(msgid, "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: Incorrect index bitmap.\n"));

                        if (complete_failure ||
                            !(bitmap_value = (PVOID)
                              alloc_bitmap.GetBitmapData(&bitmap_length)) ||
                            !bitmap_attrib.Initialize(_drive,
                                                      QueryClusterFactor(),
                                                      bitmap_value,
                                                      bitmap_length,
                                                      $BITMAP,
                                                      root_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (!bitmap_attrib.InsertIntoFile(&frs,
                                                          Mft->GetVolumeBitmap())) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                        }
                    }
                } else {

                    // Since there's no allocation, make sure that there's
                    // no bitmap, either.
                    //

                    if (frs.QueryAttribute(&bitmap_attrib,
                                           &ErrorInAttribute,
                                           $BITMAP,
                                           root_attrib.GetName())) {

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        Message->LogMsg(MSG_CHKLOG_NTFS_EXTRA_INDEX_BITMAP,
                                     "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: no index allocation; removing bitmap.\n"));

                        if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                bitmap_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    } else if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                }

                // Don't go on to sort this, if you're in read/only
                // and it's corrupt.

                if ((error_in_index || need_write) && FixLevel == CheckOnly) {
                    continue;
                }


                // Now make sure that this is ordered.  The
                // Attribute Definition Table indicates whether indices
                // over this attribute can have duplicate entries.
                // Since this index has already passed through VerifyAndFixIndex,
                // the following operations are safe.
                //
                // Determine the indexed attribute type:
                //

                if ((frs.QueryFileNumber() != SECURITY_TABLE_NUMBER &&
                     frs.QueryFileNumber() != ChkdskInfo->QuotaFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ObjectIdFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ReparseFileNumber) ||
                    ChkdskInfo->major <= 1) {

                    index_root = (PINDEX_ROOT)root_attrib.GetResidentValue();
                    indexed_attribute_type = index_root->IndexedAttributeType;

                    AttributeDefTable->QueryIndex( indexed_attribute_type,
                                                   &attr_def_index );

                    duplicates_allowed =
                        0 != (AttributeDefTable->QueryFlags(attr_def_index) &
                            ATTRIBUTE_DEF_DUPLICATES_ALLOWED);

                } else
                    duplicates_allowed = FALSE;

                if (order > 0 ||
                    (order == 0 && !duplicates_allowed)) {

                    switch (frs.SortIndex(root_attrib.GetName(),
                                          Mft->GetVolumeBitmap(),
                                          duplicates_allowed,
                                          FixLevel == CheckOnly)) {
                        case NTFS_SORT_INDEX_WELL_ORDERED:
                            break;

                        case NTFS_SORT_INDEX_SORTED:
                        case NTFS_SORT_INDEX_BADLY_ORDERED:
                            *DiskErrorsFound = TRUE;
                            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                            Message->DisplayMsg(MSG_CHK_NTFS_BADLY_ORDERED_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            need_write = TRUE;
                            break;

                        case NTFS_SORT_INDEX_NOT_FOUND:
                            DebugPrint("Index not found");

                            // Fall through.

                        case NTFS_SORT_ERROR:
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;

                        case NTFS_SORT_INSERT_FAILED:
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            break;
                    }
                }

                // Update the chkdsk report.

                ChkdskReport->NumIndices += 1;

                if (alloc_present) {
                    ChkdskReport->BytesInIndices +=
                        alloc_attrib.QueryAllocatedLength();
                }

                if (frs.QueryFileNumber() == SECURITY_TABLE_NUMBER &&
                    ChkdskInfo->major >= 2) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(SECURITY_TABLE_NUMBER, 1);
                } else if (frs.QueryFileNumber() == ChkdskInfo->QuotaFileNumber) {

                    DSTRING     IndexName;

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->QuotaFileNumber, 1);
                    if (!IndexName.Initialize(Userid2SidQuotaNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (root_attrib.GetName()->Strcmp(&IndexName) == 0) {
                        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                                             FixLevel == CheckOnly)) {
                          case NTFS_QUOTA_INDEX_FOUND:
                              break;

                          case NTFS_QUOTA_INDEX_INSERTED:
                          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
                              *DiskErrorsFound = TRUE;
                              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              need_write = TRUE;
                              break;

                          case NTFS_QUOTA_INDEX_NOT_FOUND:
                              // possibly quota disabled
                              break;

                          case NTFS_QUOTA_ERROR:
                              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                              return FALSE;

                          case NTFS_QUOTA_INSERT_FAILED:
                              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              break;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ObjectIdFileNumber) {

                   // Now go through all of the index entries and make sure
                   // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ObjectIdFileNumber, 1);

                    if (!SkipEntriesScan) {
                        if (!index.Initialize(_drive, QueryClusterFactor(),
                                              Mft->GetVolumeBitmap(),
                                              Mft->GetUpcaseTable(),
                                              frs.QuerySize()/2,
                                              &frs,
                                              root_attrib.GetName())) {

                           Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                           return FALSE;
                        }

                        if (!ValidateEntriesInObjIdIndex(&index, &frs, ChkdskInfo,
                                                         &changes, Mft, FixLevel,
                                                         Message, DiskErrorsFound)) {
                           return FALSE;
                        }

                        if (changes) {
                            need_write = TRUE;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ReparseFileNumber) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ReparseFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInReparseIndex(&index, &frs, ChkdskInfo,
                                                       &changes, Mft, FixLevel,
                                                       Message, DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }

                } else {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft, SkipEntriesScan,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                       if (FixLevel != CheckOnly && !index.Save(&frs)) {
                           Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                   frs.QueryFileNumber().GetLowPart(),
                                   index.GetName());
                           ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                       }
                       need_write = TRUE;
                    }

                    if (i == EXTEND_TABLE_NUMBER && ChkdskInfo->major >= 2) {
                        if (!ExtractExtendInfo(&index, ChkdskInfo, Message))
                            return FALSE;
                    }
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }
    } else {    // Algorithm != 0

        BIG_INT         start_frs;
        BOOLEAN         out_of_memory;
        USHORT          passes;
        BIG_INT         increment, increment_fraction, remainder;

        DebugAssert(SkipEntriesScan == FALSE);

        ChkdskInfo->TotalNumFileNames += (ChkdskInfo->NumFiles/16 +
                                          ChkdskInfo->NumFiles*2 +
                                          (ChkdskInfo->NumFiles*Algorithm)/16);

        if (ChkdskInfo->CountFilesWithIndices != 0) {
            increment = ChkdskInfo->NumFiles / ChkdskInfo->CountFilesWithIndices;
            increment_fraction = ChkdskInfo->NumFiles -
                                 increment * ChkdskInfo->CountFilesWithIndices;
        } else {
            increment = 0;
            increment_fraction = 0;
        }
        remainder = 0;


#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel1);
        timestr = ctime(&timel1);
        timestr[strlen(timestr)-1] = 0;
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                            "%s%s", "Banding before stage 1: ", timestr);
#endif
        for (i=0; i < ChkdskInfo->NumFiles; i++) {

            if ((i & 0xf) == 0)
                num_file_names += 1;

            new_percent = ((num_file_names * 100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
            if (new_percent != percent_done) {
                percent_done = new_percent;
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {
                continue;
            }

            remainder += increment_fraction;
            while (remainder >= ChkdskInfo->CountFilesWithIndices) {
                remainder -= ChkdskInfo->CountFilesWithIndices;
                num_file_names += 1;
            }
            num_file_names += increment;

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // The following loop deletes all $INDEX_ALLOCATION attributes that
            // don't have a corresponding $INDEX_ROOT attribute.

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&alloc_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ALLOCATION,
                                                    j); j++) {

                // Make sure that there's an index root of the same name
                // here.  Otherwise tube this attribute.

                if (frs.IsAttributePresent($INDEX_ROOT, alloc_attrib.GetName())) {
                    continue;
                }

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INDEX_ROOT,
                                "%I64x%W",
                                frs.QueryFileNumber().GetLargeInteger(),
                                alloc_attrib.GetName());

                Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                    "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    alloc_attrib.GetName());
                DebugPrintTrace(("UNTFS: Index allocation without index root.\n"));

                need_write = TRUE;

                if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                        alloc_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Because we deleted a $INDEX_ALLOCATION we need to
                // adjust j.

                j--;


                // If there's a $BITMAP then tube that also.

                if (!frs.QueryAttribute(&bitmap_attrib,
                                        &ErrorInAttribute,
                                        $BITMAP,
                                        alloc_attrib.GetName())) {

                    if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    continue;
                }

                if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                        bitmap_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }


            // This loop goes through all of the $INDEX_ROOT attributes in
            // this FRS.

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                // First find out if we have an INDEX_ALLOCATION here.

                alloc_present = frs.QueryAttribute(&alloc_attrib,
                                                   &ErrorInAttribute,
                                                   $INDEX_ALLOCATION,
                                                   root_attrib.GetName());

                if (!alloc_present && ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                error_in_index = FALSE;

                if (!VerifyAndFixIndex(ChkdskInfo,
                                       &root_attrib,
                                       alloc_present ? &alloc_attrib : NULL,
                                       alloc_present ? &alloc_bitmap : NULL,
                                       frs.QueryFileNumber(),
                                       BadClusters,
                                       Mft,
                                       AttributeDefTable,
                                       &tube,
                                       &order,
                                       FixLevel, Message,
                                       &error_in_index)) {

                    return FALSE;
                }

                *DiskErrorsFound = *DiskErrorsFound || error_in_index;

                if (tube) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    need_write = TRUE;

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_INDEX,
                                        "%d%W",
                                        frs.QueryFileNumber().GetLowPart(),
                                        root_attrib.GetName());

                    if (!root_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(root_attrib.QueryTypeCode(),
                                            root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    // Adjust j because an $INDEX_ROOT has just been removed.

                    j--;

                    if (alloc_present) {

                        if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                                alloc_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (frs.QueryAttribute(&bitmap_attrib,
                                               &ErrorInAttribute,
                                               $BITMAP,
                                               root_attrib.GetName())) {

                            if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                                !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                    bitmap_attrib.GetName())) {

                                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                                return FALSE;
                            }
                        } else if (ErrorInAttribute) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    }

                    if (!index_name.Initialize(FileNameIndexNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (index_name.Strcmp(root_attrib.GetName()) == 0) {
                        frs.ClearIndexPresent();
                        ChkdskInfo->FilesWhoNeedData.SetAllocated(i, 1);
                    }
                    ChkdskInfo->CountFilesWithIndices -= 1;
                    ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                    continue;
                }

                if (root_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!root_attrib.InsertIntoFile(&frs,
                                                    Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present && alloc_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!alloc_attrib.InsertIntoFile(&frs,
                                                     Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present) {

                    BOOLEAN bitmap_present;
                    BOOLEAN bitmaps_equal;
                    BOOLEAN error;

                    // Make sure the bitmap is present and good.

                    complete_failure = FALSE;

                    bitmap_present = frs.QueryAttribute(&bitmap_attrib,
                                                        &ErrorInAttribute,
                                                        $BITMAP,
                                                        root_attrib.GetName());

                    if (bitmap_present) {
                        bitmaps_equal = AreBitmapsEqual(&bitmap_attrib,
                                                        &alloc_bitmap,
                                                        alloc_bitmap.QuerySize(),
                                                        Message,
                                                        &complete_failure);

                        //
                        // Make an exception here for cases where our internal bitmap
                        // is size zero but there is a positively-sized bitmap attribute,
                        // as long as the bitmap attribute's contents are zeroed.  The
                        // filesystem can leave the disk in this state after all the files
                        // are deleted from a large directory.
                        //

                        if (!bitmaps_equal && alloc_bitmap.QuerySize() == 0 &&
                            bitmap_attrib.QueryValueLength() > 0 &&
                            bitmap_attrib.IsAllocationZeroed()) {

                            bitmaps_equal = TRUE;
                        }
                    }


                    if (!bitmap_present || !bitmaps_equal) {

                        MSGID   msgid;

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (!bitmap_present) {
                            msgid = MSG_CHKLOG_NTFS_INDEX_BITMAP_MISSING;
                        } else {
                            DebugAssert(!bitmaps_equal);
                            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_BITMAP;
                        }
                        Message->LogMsg(msgid, "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: Incorrect index bitmap.\n"));

                        if (complete_failure ||
                            !(bitmap_value = (PVOID)
                              alloc_bitmap.GetBitmapData(&bitmap_length)) ||
                            !bitmap_attrib.Initialize(_drive,
                                                      QueryClusterFactor(),
                                                      bitmap_value,
                                                      bitmap_length,
                                                      $BITMAP,
                                                      root_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (!bitmap_attrib.InsertIntoFile(&frs,
                                                          Mft->GetVolumeBitmap())) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                        }
                    }
                } else {

                    // Since there's no allocation, make sure that there's
                    // no bitmap, either.
                    //

                    if (frs.QueryAttribute(&bitmap_attrib,
                                           &ErrorInAttribute,
                                           $BITMAP,
                                           root_attrib.GetName())) {

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        Message->LogMsg(MSG_CHKLOG_NTFS_EXTRA_INDEX_BITMAP,
                                     "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: no index allocation; removing bitmap.\n"));

                        if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                bitmap_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    } else if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                }

                // Don't go on to sort this, if you're in read/only
                // and it's corrupt.

                if ((error_in_index || need_write) && FixLevel == CheckOnly) {
                    continue;
                }


                // Now make sure that this is ordered.  The
                // Attribute Definition Table indicates whether indices
                // over this attribute can have duplicate entries.
                // Since this index has already passed through VerifyAndFixIndex,
                // the following operations are safe.
                //
                // Determine the indexed attribute type:
                //

                if ((frs.QueryFileNumber() != SECURITY_TABLE_NUMBER &&
                     frs.QueryFileNumber() != ChkdskInfo->QuotaFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ObjectIdFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ReparseFileNumber) ||
                    ChkdskInfo->major <= 1) {

                    index_root = (PINDEX_ROOT)root_attrib.GetResidentValue();
                    indexed_attribute_type = index_root->IndexedAttributeType;

                    AttributeDefTable->QueryIndex( indexed_attribute_type,
                                                   &attr_def_index );

                    duplicates_allowed =
                        0 != (AttributeDefTable->QueryFlags(attr_def_index) &
                            ATTRIBUTE_DEF_DUPLICATES_ALLOWED);

                } else
                    duplicates_allowed = FALSE;

                if (order > 0 ||
                    (order == 0 && !duplicates_allowed)) {

                    switch (frs.SortIndex(root_attrib.GetName(),
                                          Mft->GetVolumeBitmap(),
                                          duplicates_allowed,
                                          FixLevel == CheckOnly)) {
                        case NTFS_SORT_INDEX_WELL_ORDERED:
                            break;

                        case NTFS_SORT_INDEX_SORTED:
                        case NTFS_SORT_INDEX_BADLY_ORDERED:
                            *DiskErrorsFound = TRUE;
                            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                            Message->DisplayMsg(MSG_CHK_NTFS_BADLY_ORDERED_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            need_write = TRUE;
                            break;

                        case NTFS_SORT_INDEX_NOT_FOUND:
                            DebugPrint("Index not found");

                            // Fall through.

                        case NTFS_SORT_ERROR:
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;

                        case NTFS_SORT_INSERT_FAILED:
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            break;
                    }
                }

                // Update the chkdsk report.

                ChkdskReport->NumIndices += 1;

                if (alloc_present) {
                    ChkdskReport->BytesInIndices +=
                        alloc_attrib.QueryAllocatedLength();
                }

                if (frs.QueryFileNumber() == SECURITY_TABLE_NUMBER &&
                    ChkdskInfo->major >= 2) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(SECURITY_TABLE_NUMBER, 1);
                } else if (frs.QueryFileNumber() == ChkdskInfo->QuotaFileNumber) {

                    DSTRING     IndexName;

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->QuotaFileNumber, 1);
                    if (!IndexName.Initialize(Userid2SidQuotaNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (root_attrib.GetName()->Strcmp(&IndexName) == 0) {
                        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                                             FixLevel == CheckOnly)) {
                          case NTFS_QUOTA_INDEX_FOUND:
                              break;

                          case NTFS_QUOTA_INDEX_INSERTED:
                          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
                              *DiskErrorsFound = TRUE;
                              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              need_write = TRUE;
                              break;

                          case NTFS_QUOTA_INDEX_NOT_FOUND:
                              // possibly quota disabled
                              break;

                          case NTFS_QUOTA_ERROR:
                              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                              return FALSE;

                          case NTFS_QUOTA_INSERT_FAILED:
                              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              break;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ObjectIdFileNumber) {

                   // Now go through all of the index entries and make sure
                   // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ObjectIdFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                    }

                    if (!ValidateEntriesInObjIdIndex(&index, &frs, ChkdskInfo,
                                                     &changes, Mft, FixLevel,
                                                     Message, DiskErrorsFound)) {
                       return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ReparseFileNumber) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ReparseFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInReparseIndex(&index, &frs, ChkdskInfo,
                                                       &changes, Mft, FixLevel,
                                                       Message, DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }
                } else if (frs.QueryFileNumber() == EXTEND_TABLE_NUMBER) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft, FALSE,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                       if (FixLevel != CheckOnly && !index.Save(&frs)) {
                           Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                   frs.QueryFileNumber().GetLowPart(),
                                   index.GetName());
                           ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                       }
                       need_write = TRUE;
                    }

                    if (i == EXTEND_TABLE_NUMBER && ChkdskInfo->major >= 2) {
                        if (!ExtractExtendInfo(&index, ChkdskInfo, Message))
                            return FALSE;
                    }
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel2);
        Message->Lock();
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        timestr = ctime(&timel2);
        timestr[strlen(timestr)-1] = 0;
        Message->Display("%s%s", "Banding after stage 1: ", timestr);
        Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
        Message->Unlock();
#endif
        start_frs = 0;

        if (!mft_info.Initialize(ChkdskInfo->NumFiles,
                                 Mft->GetUpcaseTable(),
                                 NTFS_SA::_MajorVersion,
                                 NTFS_SA::_MinorVersion,
                                 max_mem_use_for_mft_info.GetLargeInteger().QuadPart)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel1);
#endif
        for (passes=1; passes <= Algorithm; passes++) {

            if (!mft_info.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            for (i=start_frs.GetLowPart(); i < ChkdskInfo->NumFiles; i++) {

                new_percent = ((num_file_names*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                if (new_percent != percent_done) {
                    percent_done = new_percent;
                    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                        return FALSE;
                    }
                }

                num_file_names += 1;

                if (i % MFT_READ_CHUNK_SIZE == 0) {
                    ULONG       remaining_frs;
                    ULONG       number_to_read;

                    remaining_frs = ChkdskInfo->NumFiles - i;
                    number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

                    if (!frs.Initialize(i, number_to_read, Mft)) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }
                }

                if (!frs.Initialize()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (!frs.ReadNext(i)) {
                    if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                    }
                    continue;
                }

                if (!frs.IsBase() || !frs.IsInUse()) {
                    continue;
                }

                files_with_too_many_filenames =
                    ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1);

                if (!files_with_too_many_filenames &&
                    !frs.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel,
                                               Message,
                                               DiskErrorsFound,
                                               FALSE)) {
                    return FALSE;
                }

                // After verifying the file names we know that this FRS is
                // not a candidate for a missing data attribute if it has
                // its index bit set.

                if (frs.IsIndexPresent()) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(i, 1);
                }

                if (!mft_info.ExtractIndexEntryInfo(&frs,
                                                    Message,
                                                    files_with_too_many_filenames,
                                                    &out_of_memory)) {
                    if (out_of_memory) {
                        DebugAssert(passes < Algorithm);
                        DebugAssert(mft_info.QueryMinFileNumber() == start_frs);
                        start_frs = i;
                        DebugAssert(mft_info.QueryMaxFileNumber() == (i-1));
                        break;
                    }
                    return FALSE;
                }
            }
            mft_info.UpdateRange(i-1);

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
            time(&timel2);
            Message->Lock();
            Message->Set(MSG_CHK_NTFS_MESSAGE);
            timestr = ctime(&timel2);
            timestr[strlen(timestr)-1] = 0;
            Message->Display("%s%s", "Banding after stage 2: ", timestr);
            Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
            Message->Unlock();
            time(&timel1);
#endif

            for (i = 0; i < ChkdskInfo->NumFiles; i++) {

                if ((i & 0xF) == 0) {
                    num_file_names += 1;
                }

                if (i == SECURITY_TABLE_NUMBER ||
                    i == EXTEND_TABLE_NUMBER ||
                    i == ChkdskInfo->QuotaFileNumber ||
                    i == ChkdskInfo->ObjectIdFileNumber ||
                    i == ChkdskInfo->ReparseFileNumber ||
                    ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {

                    new_percent = ((num_file_names*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                    if (new_percent != percent_done) {
                        percent_done = new_percent;
                        if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                            return FALSE;
                        }
                    }
                    continue;
                }

                if (!frs.Initialize(i, Mft)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (!frs.Read()) {
                    if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                    }
                    continue;
                }

                need_write = FALSE;

                // This loop goes through all of the $INDEX_ROOT attributes in
                // this FRS.

                for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                        &ErrorInAttribute,
                                                        $INDEX_ROOT,
                                                        j); j++) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                         Mft->GetVolumeBitmap(),
                                         Mft->GetUpcaseTable(),
                                         frs.QuerySize()/2,
                                         &frs,
                                         root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                &mft_info,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        if (FixLevel != CheckOnly && !index.Save(&frs)) {
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                                "%d%W",
                                                frs.QueryFileNumber().GetLowPart(),
                                                index.GetName());
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                        }
                        need_write = TRUE;
                    }
                }

                if (ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (need_write) {
                    *DiskErrorsFound = TRUE;
                }

                if (need_write &&
                    FixLevel != CheckOnly &&
                    !frs.Flush(Mft->GetVolumeBitmap())) {

                    DebugAbort("Can't write readable FRS");
                    return FALSE;
                }
            }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
            time(&timel2);
            Message->Lock();
            Message->Set(MSG_CHK_NTFS_MESSAGE);
            timestr = ctime(&timel2);
            timestr[strlen(timestr)-1] = 0;
            Message->Display("%s%s", "Banding after stage 3: ", timestr);
            Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
            Message->Unlock();
#endif
        }

        DebugAssert(i == ChkdskInfo->NumFiles);
    }

    if (SkipEntriesScan && ChkdskInfo->IndexEntriesToCheckIsSet) {

        NUMBER_SET      parents;
        BIG_INT         parent;
        NTFS_ATTRIBUTE  attrib;

        for (i=0; i < ChkdskInfo->NumFiles; i++) {

            if (ChkdskInfo->IndexEntriesToCheck.IsFree(i, 1))
                continue;

            // remove all links pointing to child

            if (!SkipCycleScan && DirectoryDigraph->QueryParents(i, &parents)) {
                while (parents.QueryCardinality() != 0) {
                    parent = parents.QueryNumber(0);
                    DebugAssert(parent.GetHighPart() == 0);
                    if (!parents.Remove(parent)) {
                        DebugPrintTrace(("Unable to remove %d from the number set.\n", parent));
                        return FALSE;
                    }
                    if (!DirectoryDigraph->RemoveEdge(parent.GetLowPart(), i)) {
                        DebugPrintTrace(("Unable to remove an edge between %d and %d.\n",
                                         parent, i));
                        return FALSE;
                    }
                }
            }

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // restore the number of files names count for this frs

            ChkdskInfo->NumFileNames[i] = 0;

            for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                                  &ErrorInAttribute,
                                                  $FILE_NAME,
                                                  j); j++) {
                ChkdskInfo->NumFileNames[i]++;
            }

            // restore the reference count for this frs

            ChkdskInfo->ReferenceCount[i] = (SHORT)frs.QueryReferenceCount();
        }

        // now rescan all the indices and check only those questionable frs references

        ULONG       num_dirs_checked = 0;
        ULONG       num_dirs = max(1, ChkdskInfo->CountFilesWithIndices);

        for (i = 0; i < ChkdskInfo->NumFiles; i++) {

            new_percent = ((num_dirs_checked*10) / num_dirs) + 90;

            if (new_percent != percent_done) {
                percent_done = new_percent;
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {
                continue;
            }

            num_dirs_checked += 1;

            if (i == ChkdskInfo->ObjectIdFileNumber ||
                i == ChkdskInfo->ReparseFileNumber ||
                i == ChkdskInfo->QuotaFileNumber ||
                i == SECURITY_TABLE_NUMBER)
                continue;

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                if (!index.Initialize(_drive, QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      frs.QuerySize()/2,
                                      &frs,
                                      root_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (!ValidateEntriesInIndex2(&index, &frs, ChkdskInfo,
                                             DirectoryDigraph, &changes,
                                             Mft, SkipCycleScan,
                                             FixLevel, Message,
                                             DiskErrorsFound)) {
                    return FALSE;
                }

                if (changes) {
                    if (FixLevel != CheckOnly && !index.Save(&frs)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         index.GetName());
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                    }
                    need_write = TRUE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_INDEX_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&timel2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After stage 2: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    // Now make sure all of the reference counts are good.

    for (i = 0; i < ChkdskInfo->NumFiles; i++) {

        if (!ChkdskInfo->ReferenceCount[i]) {
            continue;
        }

        FileSystemConsistencyErrorsFound = TRUE;

// Take out this message because it can be printed a billion times.
#if 0
        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS, "%d", i);
#endif

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            continue;
        }

        // If the reference count is being adjusted to zero then
        // it should be added to the list of files with no reference.
        // Otherwise if the reference is being adjusted to something
        // non-zero it must be taken out of the list.

        if (frs.QueryReferenceCount() == ChkdskInfo->ReferenceCount[i]) {
            if (!ChkdskInfo->FilesWithNoReferences.Add(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else {
            if (!ChkdskInfo->FilesWithNoReferences.Remove(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        frs.SetReferenceCount(frs.QueryReferenceCount() -
                              ChkdskInfo->ReferenceCount[i]);

        if (FixLevel != CheckOnly && !frs.Write()) {
            DebugAbort("can't write readable frs");
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FileSystemConsistencyErrorsFound) {
        if (ChkdskInfo->Verbose) {
            Message->DisplayMsg((FixLevel == CheckOnly) ?
                                MSG_NTFS_CHKDSK_ERRORS_DETECTED :
                                MSG_NTFS_CHKDSK_ERRORS_FIXED);
        } else {
            Message->LogMsg((FixLevel == CheckOnly) ?
                            MSG_NTFS_CHKDSK_ERRORS_DETECTED :
                            MSG_NTFS_CHKDSK_ERRORS_FIXED);
        }

        if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixIndex(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_ATTRIBUTE             RootIndex,
    IN OUT  PNTFS_ATTRIBUTE             IndexAllocation     OPTIONAL,
    OUT     PNTFS_BITMAP                AllocationBitmap    OPTIONAL,
    IN      VCN                         FileNumber,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
       OUT  PBOOLEAN                    Tube,
       OUT  PLONG                       Order,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies and fixes an index over an attribute.

    As it does this, it builds up an allocation bitmap which it
    returns in

Arguments:

    ChkdskInfo          - Supplies the chkdsk information
    RootIndex           - Supplies the root index attribute.
    IndexAllocation     - Supplies the index allocation attribute.
    AllocationBitmap    - Returns the allocation bitmap.
    FileNumber          - Supplies the frs number
    BadClusters         - Supplies the bad clusters list.
    Mft                 - Supplies a valid MFT.
    AttributeDefTable   - Supplies the attribute definition table.
    Tube                - Returns whether or not the index must be tubed.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               root_length;
    ULONG               num_bytes;
    PINDEX_ROOT         index_root;
    ULONG               attr_def_index;
    ULONG               flags;
    ULONG               bytes_per_buffer;
    ULONG               cluster_size;
    ULONG               clusters_per_index_buffer;
    PINDEX_HEADER       index_header;
    ULONG               index_block_length;
    BOOLEAN             changes;
    BOOLEAN             need_write = FALSE;
    DSTRING             index_name;
    INDEX_ENTRY_TYPE    index_entry_type;
    BOOLEAN             attribute_recovered = FALSE;
    PINDEX_ENTRY        first_leaf_index_entry;
    PINDEX_ENTRY        last_leaf_index_entry;


    *Tube = FALSE;

    root_length = RootIndex->QueryValueLength().GetLowPart();

    if (root_length < sizeof(INDEX_ROOT)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_LENGTH_TOO_SMALL,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     root_length,
                     sizeof(INDEX_ROOT),
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    if (!(index_root = (PINDEX_ROOT) MALLOC(root_length))) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!RootIndex->Read(index_root, 0, root_length, &num_bytes) ||
        num_bytes != root_length) {

        DebugAbort("Unreadable resident attribute");
        FREE(index_root);
        return FALSE;
    }


    if (index_root->IndexedAttributeType == $FILE_NAME) {

        // This index should be tubed if it indexes $FILE_NAME
        // but the index name is not $I30.

        if (!index_name.Initialize(FileNameIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over file name is not $I30.\n"));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_FILE_NAME) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_FILE_NAME
                         );

            index_root->CollationRule = COLLATION_FILE_NAME;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_FILE_NAME_TYPE;

    } else if (FileNumber == ChkdskInfo->ObjectIdFileNumber) {

        // This index should be tubed if it an object id
        // index but the index name is not ObjectIdIndexNameData

        if (!index_name.Initialize(ObjectIdIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over object id is not %s.\n",
                        ObjectIdIndexNameData));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_ULONGS) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_ULONGS
                         );

            index_root->CollationRule = COLLATION_ULONGS;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for object id index\n"));
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_16;

    } else if (FileNumber == ChkdskInfo->QuotaFileNumber) {

        // This index should be tubed if it an quota index
        // but the index name is not Sid2UseridQuotaNameData
        // or Userid2SidQuotaNameData

        // Furthermore, if the index name is Sid2UseridQuotaNameData,
        // the collation rule value should be COLLATION_SID.  If
        // the index name is Userid2SidQuotaNameData, the collation
        // rule value should be COLLATION_ULONG.

        if (!index_name.Initialize(Sid2UseridQuotaNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
            if (index_root->CollationRule != COLLATION_SID) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                             "%W%I64x%x%x",
                             &index_name,
                             FileNumber.GetLargeInteger(),
                             index_root->CollationRule,
                             COLLATION_SID
                             );

                index_root->CollationRule = COLLATION_SID;
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                 "%W%d", &index_name, FileNumber.GetLowPart());
                need_write = TRUE;
            }
            index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE;
        } else {
            if (!index_name.Initialize(Userid2SidQuotaNameData)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
                if (index_root->CollationRule != COLLATION_ULONG) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                                 "%W%I64x%x%x",
                                 &index_name,
                                 FileNumber.GetLargeInteger(),
                                 index_root->CollationRule,
                                 COLLATION_ULONG
                                 );

                    index_root->CollationRule = COLLATION_ULONG;
                    Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                     "%W%d", &index_name, FileNumber.GetLowPart());
                    need_write = TRUE;
                }
                index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_4;
            } else {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_NAME_FOR_QUOTA_FILE,
                             "%W%I64x",
                             RootIndex->GetName(),
                             FileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: index over quota is not %s or %s.\n",
                            Sid2UseridQuotaNameData,
                            Userid2SidQuotaNameData));
                FREE(index_root);
                *Tube = TRUE;
                return TRUE;
            }
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for quota file index\n"));
            need_write = TRUE;
        }

    } else if (FileNumber == SECURITY_TABLE_NUMBER) {

        // This index should be tubed if it an security index
        // but the index name is not SecurityIdIndexNameData
        // or SecurityDescriptorHashIndexNameData.

        // Furthermore, if the index name is SecurityIdIndexNameData,
        // the collation rule value should be COLLATION_ULONG.  If
        // the index name is SecurityDescriptorHashIndexNameData,
        // the collation rule value should be COLLATION_SECURITY_HASH.

        if (!index_name.Initialize(SecurityIdIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
            if (index_root->CollationRule != COLLATION_ULONG) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                             "%W%I64x%x%x",
                             &index_name,
                             FileNumber.GetLargeInteger(),
                             index_root->CollationRule,
                             COLLATION_ULONG
                             );

                index_root->CollationRule = COLLATION_ULONG;
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                 "%W%d", &index_name, FileNumber.GetLowPart());
                need_write = TRUE;
            }
            index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_4;
        } else {
            if (!index_name.Initialize(SecurityDescriptorHashIndexNameData)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
                if (index_root->CollationRule != COLLATION_SECURITY_HASH) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                                 "%W%I64x%x%x",
                                 &index_name,
                                 FileNumber.GetLargeInteger(),
                                 index_root->CollationRule,
                                 COLLATION_SECURITY_HASH
                                 );

                    index_root->CollationRule = COLLATION_SECURITY_HASH;
                    Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                     "%W%d", &index_name, FileNumber.GetLowPart());
                    need_write = TRUE;
                }
                index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_8;
            } else {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_NAME_FOR_SECURITY_FILE,
                             "%W%I64x",
                             RootIndex->GetName(),
                             FileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: index over security is not %s or %s.\n",
                            SecurityIdIndexNameData,
                            SecurityDescriptorHashIndexNameData));
                FREE(index_root);
                *Tube = TRUE;
                return TRUE;
            }
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for security file index\n"));
            need_write = TRUE;
        }

    } else if (FileNumber == ChkdskInfo->ReparseFileNumber) {

        // This index should be tubed if it a reparse point
        // index but the index name is not ReparseIndexNameData

        if (!index_name.Initialize(ReparseIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over reparse point is not %s.\n",
                             ReparseIndexNameData));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_ULONGS) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_ULONGS
                         );

            index_root->CollationRule = COLLATION_ULONGS;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        if (index_root->IndexedAttributeType != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for reparse point index\n"));
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_12;

    } else
        index_entry_type = INDEX_ENTRY_GENERIC_TYPE;

    if (FileNumber != ChkdskInfo->QuotaFileNumber &&
        FileNumber != ChkdskInfo->ObjectIdFileNumber &&
        FileNumber != ChkdskInfo->ReparseFileNumber &&
        FileNumber != SECURITY_TABLE_NUMBER) {

        // Make sure that the attribute that we're indexing over is
        // an indexable attribute.

        if (!AttributeDefTable->QueryIndex(
                index_root->IndexedAttributeType,
                &attr_def_index)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_ATTR_TYPE,
                         "%W%x%I64x",
                         RootIndex->GetName(),
                         index_root->IndexedAttributeType,
                         FileNumber.GetLargeInteger());

            *Tube = TRUE;
            FREE(index_root);
            return TRUE;
        }

        flags = AttributeDefTable->QueryFlags(attr_def_index);

        if (!(flags & ATTRIBUTE_DEF_MUST_BE_INDEXED) &&
            !(flags & ATTRIBUTE_DEF_INDEXABLE)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_NON_INDEXABLE_INDEX_ATTR_TYPE,
                         "%W%x%I64x",
                         RootIndex->GetName(),
                         index_root->IndexedAttributeType,
                         FileNumber.GetLargeInteger());

            *Tube = TRUE;
            FREE(index_root);
            return TRUE;
        }
    }

    //
    // Check that the ClustersPerIndexBuffer is correct
    //

    bytes_per_buffer = index_root->BytesPerIndexBuffer;
    if (bytes_per_buffer == 0 ||
        (bytes_per_buffer & (bytes_per_buffer - 1)) ||
        bytes_per_buffer > SMALL_INDEX_BUFFER_SIZE) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_BYTES_PER_INDEX_BUFFER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     bytes_per_buffer,
                     SMALL_INDEX_BUFFER_SIZE,
                     FileNumber.GetLargeInteger());

        index_root->BytesPerIndexBuffer = bytes_per_buffer = SMALL_INDEX_BUFFER_SIZE;
        need_write = TRUE;
    }
    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();
    DebugAssert(cluster_size != 0);

    if (cluster_size > bytes_per_buffer)
        clusters_per_index_buffer = bytes_per_buffer / NTFS_INDEX_BLOCK_SIZE;
    else
        clusters_per_index_buffer = bytes_per_buffer / cluster_size;

    if (index_root->ClustersPerIndexBuffer != clusters_per_index_buffer) {
        DebugAssert(clusters_per_index_buffer <= 0xFF);

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_CLUSTERS_PER_INDEX_BUFFER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     index_root->ClustersPerIndexBuffer,
                     clusters_per_index_buffer,
                     FileNumber.GetLargeInteger());

        index_root->ClustersPerIndexBuffer = (UCHAR)clusters_per_index_buffer;
        need_write = TRUE;
    }

    // Check out the index allocation.  Recover it.  Make sure
    // that the size is a multiple of bytesperindexbuffer.
    //

    if (IndexAllocation) {

        BOOLEAN     error = FALSE;

        if (IndexAllocation->QueryValueLength() % bytes_per_buffer != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_VALUE_LENGTH,
                         "%W%I64x%x%I64x",
                         RootIndex->GetName(),
                         IndexAllocation->QueryValueLength().GetLargeInteger(),
                         bytes_per_buffer,
                         FileNumber.GetLargeInteger());
            error = TRUE;

        } else if (IndexAllocation->QueryAllocatedLength() % bytes_per_buffer != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_ALLOC_LENGTH,
                         "%W%I64x%x%I64x",
                         RootIndex->GetName(),
                         IndexAllocation->QueryAllocatedLength().GetLargeInteger(),
                         bytes_per_buffer,
                         FileNumber.GetLargeInteger());
            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                             "%d%W",
                             FileNumber.GetLowPart(),
                             RootIndex->GetName());
            DebugPrintTrace(("UNTFS: Index allocation has incorrect length.\n"));

            if (!IndexAllocation->Resize(
                    (IndexAllocation->QueryValueLength()/bytes_per_buffer)*
                    bytes_per_buffer,
                    Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(index_root);
                return FALSE;
            }
        }

        if (!AllocationBitmap->Initialize(
                IndexAllocation->QueryValueLength()/bytes_per_buffer,
                TRUE)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(index_root);
            return FALSE;
        }
    }

    first_leaf_index_entry = (PINDEX_ENTRY)MALLOC(bytes_per_buffer);
    last_leaf_index_entry = (PINDEX_ENTRY)MALLOC(bytes_per_buffer);

    if (first_leaf_index_entry == NULL ||
        last_leaf_index_entry == NULL) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        FREE(first_leaf_index_entry);
        FREE(last_leaf_index_entry);
        FREE(index_root);
        return FALSE;
    }

    index_header = &(index_root->IndexHeader);
    index_block_length = (ULONG)(((PCHAR) index_root + root_length) -
                                 ((PCHAR) index_header));

    if (!TraverseIndexTree(index_header, index_block_length,
                           IndexAllocation, AllocationBitmap,
                           bytes_per_buffer, Tube, &changes,
                           FileNumber, RootIndex->GetName(), index_entry_type,
                           &attribute_recovered, Mft, BadClusters,
                           first_leaf_index_entry, last_leaf_index_entry, Order,
                           index_root->CollationRule,
                           FixLevel, Message, DiskErrorsFound)) {
        FREE(first_leaf_index_entry);
        FREE(last_leaf_index_entry);
        FREE(index_root);
        return FALSE;
    }

    FREE(first_leaf_index_entry);
    FREE(last_leaf_index_entry);

    if (*Tube) {
        FREE(index_root);
        return TRUE;
    }

    if (changes || need_write) {

        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                         "%d%W",
                         FileNumber.GetLowPart(),
                         RootIndex->GetName());

        if (!RootIndex->Write(index_root, 0, root_length, &num_bytes, NULL) ||
            num_bytes != root_length) {

            DebugAbort("Unwriteable resident attribute");
            FREE(index_root);
            return FALSE;
        }
    }


    if (index_header->FirstFreeByte != index_header->BytesAvailable) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ROOT_INDEX_HEADER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     index_header->FirstFreeByte,
                     index_header->BytesAvailable,
                     FileNumber.GetLargeInteger());

        DebugPrintTrace(("UNTFS: Index root has FirstFreeByte != BytesAvailable\n"));

        index_header->BytesAvailable = index_header->FirstFreeByte;

        if (!RootIndex->Write(index_root, 0, root_length, &num_bytes, NULL) ||
            num_bytes != root_length) {

            DebugAbort("Unwriteable resident attribute");
            FREE(index_root);
            return FALSE;
        }

        if (!RootIndex->Resize(index_header->BytesAvailable +
                               sizeof(INDEX_ROOT) - sizeof(INDEX_HEADER),
                               Mft->GetVolumeBitmap()) ) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(index_root);
            return FALSE;
        }
    }


    FREE(index_root);

    return TRUE;
}


BOOLEAN
NTFS_SA::TraverseIndexTree(
    IN OUT  PINDEX_HEADER       IndexHeader,
    IN      ULONG               IndexLength,
    IN OUT  PNTFS_ATTRIBUTE     IndexAllocation     OPTIONAL,
    IN OUT  PNTFS_BITMAP        AllocationBitmap    OPTIONAL,
    IN      ULONG               BytesPerBlock,
    OUT     PBOOLEAN            Tube,
    OUT     PBOOLEAN            Changes,
    IN      VCN                 FileNumber,
    IN      PCWSTRING           AttributeName,
    IN      INDEX_ENTRY_TYPE    IndexEntryType,
    IN OUT  PBOOLEAN            AttributeRecovered,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      PNUMBER_SET         BadClusters,
       OUT  PINDEX_ENTRY        FirstLeafIndexEntry,
       OUT  PINDEX_ENTRY        LastLeafIndexEntry,
    IN OUT  PLONG               Order,
    IN      ULONG               CollationRule,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound
    )
/*++

Routine Description:

    This routine traverses an index tree and verifies the entries while
    traversing.

Arguments:

    IndexHeader         - Supplies a pointer to the beginning of this index
                            block.
    IndexLength         - Supplies the length of this index block.
    IndexAllocation     - Supplies the index allocation attribute.
    AllocationBitmap    - Supplies the current in memory bitmap of used
                            index blocks.
    BytesPerBuffer      - Supplies the size of an index block within the
                            index allocation attribute.
    Tube                - Returns whether or not the whole index block
                            is invalid.
    Changes             - Returns whether or not changes were made to
                            the index block.
    FileNumber          - Supplies the frs number of the index to check.
    AttributeName       - Supplies the name of the index
    IndexEntryType      - Supplies the type of the index entry
    RecoveredAttribute  - Supplies whether or not RecoverAttribute has been called.
    Mft                 - Supplies a valid MFT.
    BadClusters         - Supplies the bad cluster list.
    FirstLeafIndexEntry - Returns the first leaf index entry below the current block
    LastLeafIndexEntry  - Returns the last leaf index entry below the current block
    Order               - Returns the sort order (-1, 0, 1) below the current block.
    CollationRule       - Supplies the rule used for collation.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PINDEX_ENTRY                p, pnext;
    PCHAR                       pend;
    ULONG                       first_free_byte;
    VCN                         down_pointer;
    ULONG                       clusters_per_block, cluster_size;
    PINDEX_ALLOCATION_BUFFER    down_block;
    PINDEX_HEADER               down_header;
    BOOLEAN                     tube, changes;
    ULONG                       num_bytes;
    UCHAR                       usa_check;
    BOOLEAN                     error;
    PINDEX_ENTRY                first_index_entry;
    PINDEX_ENTRY                last_index_entry;
    PINDEX_ENTRY                prev_index_entry = NULL;
    LONG                        order;


    *Tube = FALSE;
    *Changes = FALSE;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();
    clusters_per_block = (BytesPerBlock < cluster_size ?
                             BytesPerBlock / NTFS_INDEX_BLOCK_SIZE :
                             BytesPerBlock / cluster_size);

    // pend points past the end of the block.

    pend = (PCHAR) IndexHeader + IndexLength;


    // First make sure that the first entry is valid.

    if (sizeof(INDEX_HEADER) > IndexLength) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_LENGTH_TOO_SMALL,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexLength,
                     sizeof(INDEX_HEADER),
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    if (IndexHeader->FirstIndexEntry < sizeof(INDEX_HEADER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UNKNOWN_VCN_INDEX_ENTRY_OFFSET,
                     "%W%x%I64x",
                     AttributeName,
                     IndexHeader->FirstIndexEntry,
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    p = (PINDEX_ENTRY) ((PCHAR) IndexHeader + IndexHeader->FirstIndexEntry);

    if (pend < (PCHAR)p ||
        NTFS_INDEX_TREE::IsIndexEntryCorrupt(p,
                                             (ULONG)(pend - (PCHAR) p),
                                             Message,
                                             IndexEntryType)) {
        if (pend < (PCHAR)p) {
            Message->LogMsg(MSG_CHKLOG_NTFS_FIRST_INDEX_ENTRY_OFFSET_BEYOND_INDEX_LENGTH,
                         "%W%x%x%I64x",
                         AttributeName,
                         IndexHeader->FirstIndexEntry,
                         IndexLength,
                         FileNumber.GetLargeInteger());
        }

        *Tube = TRUE;
        return TRUE;
    }


    // Now make sure that the bytes available count is correct.

    if (IndexHeader->BytesAvailable != IndexLength) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_HEADER_BYTES_AVAILABLE,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexHeader->BytesAvailable,
                     IndexLength,
                     FileNumber.GetLargeInteger());

        *Changes = TRUE;
        IndexHeader->BytesAvailable = IndexLength;
        DebugPrintTrace(("UNTFS: Incorrect bytes available.\n"));
    }

    first_index_entry = (PINDEX_ENTRY)MALLOC(BytesPerBlock);
    last_index_entry = (PINDEX_ENTRY)MALLOC(BytesPerBlock);

    if (first_index_entry == NULL ||
        last_index_entry == NULL) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        FREE(first_index_entry);
        FREE(last_index_entry);
        return FALSE;
    }

    // Validate all of the entries in the tree.

    for (;;) {

        // If this has a VCN down pointer then recurse down the tree.

        if (p->Flags & INDEX_ENTRY_NODE) {

            down_pointer = GetDownpointer(p)/clusters_per_block;

            // Make sure that the index header is marked as a node.
            if (!(IndexHeader->Flags & INDEX_NODE)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_HEADER_NOT_MARKED_AS_INDEX_NODE,
                             "%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());

                *Changes = TRUE;
                IndexHeader->Flags |= INDEX_NODE;
            }


            if (!(down_block = (PINDEX_ALLOCATION_BUFFER)
                                MALLOC(BytesPerBlock))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(first_index_entry);
                FREE(last_index_entry);
                return FALSE;
            }

            error = FALSE;

            if (GetDownpointer(p) % clusters_per_block != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_DOWN_POINTER,
                             "%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!AllocationBitmap) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_ALLOC_BITMAP,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!AllocationBitmap->IsFree(down_pointer, 1)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_DOWN_POINTER_ALREADY_IN_USE,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IndexAllocation) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_INDEX_ALLOC,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IndexAllocation->Read(down_block,
                                              down_pointer*BytesPerBlock,
                                              BytesPerBlock,
                                              &num_bytes) &&
                       (*AttributeRecovered ||
                        (SET_TRUE(*AttributeRecovered) &&
                         !IndexAllocation->RecoverAttribute(Mft->GetVolumeBitmap(),
                                                            BadClusters)))) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_INDEX_BUFFER,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (num_bytes != BytesPerBlock) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_INDEX_BUFFER,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!(usa_check =
                           NTFS_SA::PostReadMultiSectorFixup(
                               down_block,
                               num_bytes,
                               IndexAllocation->GetDrive(),
                               down_block->IndexHeader.FirstFreeByte))) {

                error = TRUE;
            } else if (down_block->MultiSectorHeader.Signature[0] != 'I' ||
                       down_block->MultiSectorHeader.Signature[1] != 'N' ||
                       down_block->MultiSectorHeader.Signature[2] != 'D' ||
                       down_block->MultiSectorHeader.Signature[3] != 'X') {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_MULTI_SECTOR_HEADER_SIGNATURE);
                Message->Log("%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());
                Message->DumpDataToLog(down_block, sizeof(MULTI_SECTOR_HEADER));
                Message->Unlock();

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset <
                       FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, UpdateSequenceArray)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_BUFFER_USA_OFFSET_BELOW_MINIMUM,
                             "%W%I64x%x%x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             down_block->MultiSectorHeader.UpdateSequenceArrayOffset,
                             FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, UpdateSequenceArray),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->ThisVcn != GetDownpointer(p)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_DOWN_BLOCK,
                             "%W%I64x%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             down_block->ThisVcn.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (num_bytes%SEQUENCE_NUMBER_STRIDE != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_SIZE,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             num_bytes,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset%
                       sizeof(UPDATE_SEQUENCE_NUMBER) != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_USA_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->MultiSectorHeader.UpdateSequenceArrayOffset,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArraySize !=
                       num_bytes/SEQUENCE_NUMBER_STRIDE + 1) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_USA_SIZE,
                             "%W%I64x%x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->MultiSectorHeader.UpdateSequenceArraySize,
                             num_bytes/SEQUENCE_NUMBER_STRIDE + 1,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset +
                       down_block->MultiSectorHeader.UpdateSequenceArraySize*
                       sizeof(UPDATE_SEQUENCE_NUMBER) >
                       down_block->IndexHeader.FirstIndexEntry +
                       FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->IndexHeader.FirstIndexEntry,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IsQuadAligned(down_block->IndexHeader.FirstIndexEntry)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->IndexHeader.FirstIndexEntry,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else {

                // Compare this block's LSN against the largest so far.

                if (down_block->Lsn > LargestLsnEncountered) {
                    LargestLsnEncountered = down_block->Lsn;
                }


                AllocationBitmap->SetAllocated(down_pointer, 1);

                down_header = &(down_block->IndexHeader);

                if (!TraverseIndexTree(down_header,
                                       BytesPerBlock -
                                            (ULONG)((PCHAR) down_header -
                                             (PCHAR) down_block),
                                       IndexAllocation, AllocationBitmap,
                                       BytesPerBlock, &tube, &changes,
                                       FileNumber, AttributeName, IndexEntryType,
                                       AttributeRecovered, Mft, BadClusters,
                                       first_index_entry, last_index_entry,
                                       Order, CollationRule,
                                       FixLevel, Message, DiskErrorsFound)) {

                    FREE(first_index_entry);
                    FREE(last_index_entry);
                    FREE(down_block);
                    return FALSE;
                }

                if (tube || changes ||
                    usa_check == UpdateSequenceArrayCheckValueMinorError) {

                    if (tube || changes) {
                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         FileNumber.GetLowPart(),
                                         AttributeName);
                        *DiskErrorsFound = TRUE;
                    } else {
                        DebugPrintTrace(("UNTFS: Quietly fix up check value in VCN %d of\n"
                                         "indexed frs %d\n",
                                         down_pointer.GetLowPart(),
                                         FileNumber.GetLowPart()));
                    }

                    if (tube) {
                        *Order = 1; // must go thru sort
                        *Changes = TRUE;
                        AllocationBitmap->SetFree(down_pointer, 1);
                        GetDownpointer(p) = INVALID_VCN;
                        DebugPrintTrace(("UNTFS: 1 Index down pointer being set to invalid.\n"));
                    }

                    NTFS_SA::PreWriteMultiSectorFixup(down_block,
                                                      BytesPerBlock);


                    if (FixLevel != CheckOnly &&
                        !IndexAllocation->Write(down_block,
                                                down_pointer*BytesPerBlock,
                                                BytesPerBlock,
                                                &num_bytes,
                                                NULL)) {

                        DebugAbort("Can't write what was read");
                        FREE(first_index_entry);
                        FREE(last_index_entry);
                        FREE(down_block);
                        return FALSE;
                    }

                    NTFS_SA::PostReadMultiSectorFixup(down_block,
                                                      BytesPerBlock,
                                                      NULL);
                }
            }

            if (error) {

                PINDEX_ALLOCATION_BUFFER pBuffer;

                pBuffer = CONTAINING_RECORD( IndexHeader, INDEX_ALLOCATION_BUFFER, IndexHeader );

                *Changes = TRUE;

                DebugPrintTrace(("UNTFS: 2 Index down pointer (0x%I64x) in Block 0x%I64x being set to invalid.\n",
                                 GetDownpointer(p), pBuffer->ThisVcn));
                GetDownpointer(p) = INVALID_VCN;

                *Order = 1;     // must go thru sort
            }

            FREE(down_block);

            if (prev_index_entry) {
                if (*Order <= 0) {
                    order = CompareNtfsIndexEntries(prev_index_entry,
                                                    (GetDownpointer(p) == INVALID_VCN) ? p : first_index_entry,
                                                    CollationRule,
                                                    Mft->GetUpcaseTable());
                    if (order >= 0)
                        *Order = order;
                }
            } else {
                if (GetDownpointer(p) == INVALID_VCN) {
                    memcpy(FirstLeafIndexEntry, p, p->Length);
                } else {
                    memcpy(FirstLeafIndexEntry, first_index_entry, first_index_entry->Length);
                }
            }

            if (p->Flags & INDEX_ENTRY_END) {
                if (GetDownpointer(p) == INVALID_VCN) {
                    memcpy(LastLeafIndexEntry, p, p->Length);
                } else {
                    memcpy(LastLeafIndexEntry, last_index_entry, last_index_entry->Length);
                }
            } else if (*Order <= 0) {
                if (GetDownpointer(p) != INVALID_VCN) {
                    order = CompareNtfsIndexEntries(last_index_entry,
                                                    p,
                                                    CollationRule,
                                                    Mft->GetUpcaseTable());
                    if (order >= 0)
                        *Order = order;
                }
            }

        } else {

            // Make sure that the index header has this marked as a leaf.  If the block
            // is not consistent then the Sort routine for indices will detect that they're
            // unsorted.

            if (IndexHeader->Flags & INDEX_NODE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_HEADER_MARKED_AS_INDEX_NODE,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                *Changes = TRUE;
                IndexHeader->Flags &= ~INDEX_NODE;
            }

            if (prev_index_entry == NULL) {
                //
                // this should be the first leaf entry if there is
                // no previous entries and this is a leaf node.
                //
                memcpy(FirstLeafIndexEntry, p, p->Length);
            } else if (p->Flags & INDEX_ENTRY_END) {
                //
                // this should be the last leaf entry if it has the end flag
                //
                memcpy(LastLeafIndexEntry, prev_index_entry, prev_index_entry->Length);
            } else if (*Order <= 0) {
                order = CompareNtfsIndexEntries(prev_index_entry,
                                                p,
                                                CollationRule,
                                                Mft->GetUpcaseTable());
                if (order >= 0)
                    *Order = order;
            }
        }

        if (p->Flags & INDEX_ENTRY_END) {
            break;
        }

        // Make sure the next entry is not corrupt.  If it is then
        // truncate this one.  If we truncate a node, we have to
        // keep its downpointer.

        pnext = (PINDEX_ENTRY) ((PCHAR) p + p->Length);

        if (pend < (PCHAR) pnext ||
            NTFS_INDEX_TREE::IsIndexEntryCorrupt(pnext,
                                                 (ULONG)(pend - (PCHAR) pnext),
                                                 Message,
                                                 IndexEntryType)) {

            if (pend < (PCHAR)pnext) {
                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_BEYOND_INDEX_LENGTH,
                             "%W%x%x%I64x",
                             AttributeName,
                             p->Length,
                             pend-(PCHAR)p,
                             FileNumber.GetLargeInteger());
            }

            *Changes = TRUE;
            DebugPrintTrace(("UNTFS: Index entry is corrupt.\n"));
            if( p->Flags & INDEX_ENTRY_NODE ) {
                down_pointer = GetDownpointer(p);
            }

            memset(&(p->FileReference), 0, sizeof(FILE_REFERENCE));
            p->Length = NtfsIndexLeafEndEntrySize +
                        ((p->Flags & INDEX_ENTRY_NODE) ? sizeof(VCN) : 0);
            p->AttributeLength = 0;
            p->Flags |= INDEX_ENTRY_END;
            if( p->Flags & INDEX_ENTRY_NODE ) {
                GetDownpointer(p) = down_pointer;

                if (prev_index_entry == NULL) {
                    *Order = 1; // must go thru sort
                } else {
                    memcpy(LastLeafIndexEntry, last_index_entry, last_index_entry->Length);
                }

            } else {
                if (prev_index_entry == NULL) {
                    *Order = 1; // must go thru sort
                } else {
                    memcpy(LastLeafIndexEntry, prev_index_entry, prev_index_entry->Length);
                }
            }
            break;
        }

        prev_index_entry = p;
        p = pnext;
    }


    FREE(first_index_entry);
    FREE(last_index_entry);

    // Verify the first free byte.

    first_free_byte = (ULONG)((PCHAR) p - (PCHAR) IndexHeader) + p->Length;

    if (IndexHeader->FirstFreeByte != first_free_byte) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_HEADER_FIRST_FREE_BYTE,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexHeader->FirstFreeByte,
                     first_free_byte,
                     FileNumber.GetLargeInteger());

        DebugPrintTrace(("UNTFS: Index entry has invalid first free byte.\n"));
        *Changes = TRUE;
        IndexHeader->FirstFreeByte = first_free_byte;
    }

    return TRUE;
}


BOOLEAN
QueryFileNameFromIndex(
   IN PCFILE_NAME IndexValue,
   IN ULONG    ValueLength,
   OUT   PWSTRING FileName
   )
/*++

Routine Description:

   This routine returns a file name string for a given file name
   structure.

Arguments:

   IndexValue  - Supplies the file name structure.
   ValueLength - Supplies the number of bytes in the file name structure.
   FileName - Returns the file name string.

Return Value:

   FALSE - There is a corruption in the file name structure.
   TRUE  - Success.

--*/
{
    WSTR    string[256];
    UCHAR   i, len;

    if (sizeof(FILE_NAME) > ValueLength) {
        return FALSE;
    }

    len = IndexValue->FileNameLength;

    if (NtfsFileNameGetLength(IndexValue) > ValueLength) {
        return FALSE;
    }

    for (i = 0; i < len; i++) {
        string[i] = IndexValue->FileName[i];
    }
    string[i] = 0;

    return FileName->Initialize(string);
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN      PNTFS_MFT_INFO              MftInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    IN OUT  PULONG                      PercentDone,
    IN OUT  PBIG_INT                    NumFileNames,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    MftInfo             - Supplies the current mft info.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipEntriesScan     - Supplies if index entries checking should be skipped.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    ULONG                       new_percent;
    PNTFS_FRS_INFO              pfrsInfo;
    USHORT                      index_into_file_name;
    UCHAR                       file_name_flags;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

    while (index_entry = Index->GetNext(&depth, &error)) {

        new_percent = ((*NumFileNames*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
        if (new_percent != *PercentDone) {
            *PercentDone = new_percent;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", *PercentDone)) {
                return FALSE;
            }
        }

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        need_delete = FALSE;

        if (file_number >= ChkdskInfo->NumFiles) {
            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_BEYOND_MFT,
                             "%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_BEYOND_MFT);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        } else if (!MftInfo->IsInRange(file_number)) {
            continue;
        }

        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete) {

            if ((pfrsInfo = (PNTFS_FRS_INFO)MftInfo->QueryIndexEntryInfo(file_number)) == NULL) {
                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_OR_NON_BASE_FRS,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_OR_NON_BASE_FRS);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!need_delete &&
            !(NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo) == index_entry->FileReference)) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             index_entry->FileReference,
                             NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo));
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                Message->Log("%I64x%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             index_entry->FileReference,
                             NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo));
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // do we need to see if this is a file_name_index first?
        if (!need_delete &&
            !file_has_too_many_file_names &&
            NTFS_MFT_INFO::CompareFileName(pfrsInfo,
                                           index_entry->AttributeLength,
                                           file_name,
                                           &index_into_file_name) == 0) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(file_name,
                                       max(min(0x100, index_entry->AttributeLength),
                                           sizeof(FILE_NAME)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names) {

            file_name_flags = NTFS_MFT_INFO::QueryFlags(pfrsInfo, index_into_file_name);

            if (!NTFS_MFT_INFO::CompareDupInfo(pfrsInfo, file_name) ||
                file_name_flags != file_name->Flags) {

                // read in frs and fix the problem

                if (file_number == IndexFrs->QueryFileNumber()) {
                    pfrs = IndexFrs;
                } else {
                    if (!frs.Initialize(file_number, Mft)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!frs.Read()) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
                        return FALSE;
                    }

                    pfrs = &frs;
                }


                if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                p = &file_name->Info;
                q = &actual_dupinfo;
                dupinfo_match = TRUE;

                if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                    file_name_flags != file_name->Flags) {

                    if (file_number >= FIRST_USER_FILE_NUMBER) {

                        if (p->CreationTime != q->CreationTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->CreationTime, q->CreationTime));
                        }

                        if (p->LastModificationTime != q->LastModificationTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->LastModificationTime, q->LastModificationTime));
                        }

                        if (p->LastChangeTime != q->LastChangeTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->LastChangeTime, q->LastChangeTime));
                        }

                        if (p->AllocatedLength != q->AllocatedLength) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                        }

                        if (p->FileSize != q->FileSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                        }

                        if (p->FileAttributes != q->FileAttributes) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->FileAttributes, q->FileAttributes));
                        }

                        if (ChkdskInfo->major >= 2 &&
                            q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                            if (p->ReparsePointTag != q->ReparsePointTag) {
                                dupinfo_match = FALSE;
                                DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                                 file_number.GetLargeInteger(),
                                                 p->ReparsePointTag, q->ReparsePointTag));
                            }
                        } else {
                            if (p->PackedEaSize != q->PackedEaSize) {
                                dupinfo_match = FALSE;
                                DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                                 file_number.GetLargeInteger(),
                                                 p->PackedEaSize, q->PackedEaSize));
                            }
                        }

                        if (file_name->Flags != file_name_flags) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             file_name->Flags, file_name_flags));
                        }
                    } else {
                        dupinfo_match = FALSE;
                    }
                }

                if (!dupinfo_match) {

                    // Don't report duplicated information on system files.

                    if (file_number >= FIRST_USER_FILE_NUMBER) {
                        FileSystemConsistencyErrorsFound = TRUE;
                        if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                        }
                    }

                    if (FixLevel != CheckOnly) {
                        *Changes = TRUE;
                    }


                    memcpy(&file_name->Info, &actual_dupinfo, sizeof(DUPLICATED_INFORMATION));
                    file_name->Flags = file_name_flags;

                    if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;
                *NumFileNames += 1;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    IN OUT  PULONG                      PercentDone,
    IN OUT  PBIG_INT                    NumFileNames,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipEntriesScan,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipEntriesScan     - Supplies if index entries checking should be skipped.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_INDEX_TREE             indexMark;
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name, frs_file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    TLINK                       frsDataRec;
    PVOID                       pNode;
    USHORT                      frsDataRecordCount;
    BOOLEAN                     read_failure = TRUE;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    ULONG                       new_percent;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

  ProcessNextBlock:

    new_percent = (((*NumFileNames)*90) / ChkdskInfo->TotalNumFileNames).GetLowPart();
    if (new_percent != *PercentDone) {
        *PercentDone = new_percent;
        if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", *PercentDone)) {
            return FALSE;
        }
    }

    indexMark.CopyIterator(Index);

    if (index_entry = Index->GetNext(&depth, &error)) {

        frsDataRec.Initialize(FRS_DATA_RECORD_MAX_SIZE);

        frsDataRec.GetNextDataSlot().Set(index_entry->FileReference.LowPart,
                                (LONG) index_entry->FileReference.HighPart);

    } else {

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
        return TRUE;
    }

    while (index_entry = Index->GetNext(&depth, &error)) {

        frsDataRec.GetNextDataSlot().Set(index_entry->FileReference.LowPart,
                                (LONG) index_entry->FileReference.HighPart);

        if (frsDataRec.QueryMemberCount() >= FRS_DATA_RECORD_MAX_SIZE)
            break;

    }

    frsDataRecordCount = frsDataRec.QueryMemberCount();

    if (!SkipEntriesScan) {
        frsDataRec.Sort();

        if (!frs.Initialize((VCN)0, frsDataRecordCount, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        read_failure = !frs.ReadSet(&frsDataRec);
    }

    Index->CopyIterator(&indexMark);
    pNode = frsDataRec.GetFirst();

    while (frsDataRecordCount &&
           (index_entry = Index->GetNext(&depth, &error))) {

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        need_delete = FALSE;
        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete &&
            file_name_index &&
            SkipEntriesScan &&
            ChkdskInfo->NumFileNames[file_number.GetLowPart()] == 0) {

            // keep track of this frs number and verify it later

            ChkdskInfo->IndexEntriesToCheck.SetAllocated(file_number, 1);
            ChkdskInfo->IndexEntriesToCheckIsSet = TRUE;
            frsDataRecordCount--;
            continue;
        }

        if (!need_delete && !SkipEntriesScan) {
            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
                pNode = frsDataRec.GetNext(pNode);
            } else {
                if (!frs.Initialize()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (read_failure) {
                    frs.SetFrsData(file_number,
                                   (PFILE_RECORD_SEGMENT_HEADER)
                                   frsDataRec.GetBuffer(frsDataRec.GetSortedFirst()));
                    if (!frs.Read())
                        need_delete = TRUE;
                } else {
                    DebugAssert(file_number == frsDataRec.GetData(pNode));
                    frs.SetFrsData(frsDataRec.GetData(pNode),
                                   (PFILE_RECORD_SEGMENT_HEADER)
                                   frsDataRec.GetBuffer(pNode));
                    pNode = frsDataRec.GetNext(pNode);
                }

                if (!frs.IsInUse()) {

                    if (file_name_index) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_FRS,
                                     "%I64x%W%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     &entry_name,
                                     file_number.GetLargeInteger());
                    } else {

                        Message->Lock();
                        Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_FRS);
                        Message->Log("%I64x%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     file_number.GetLargeInteger());
                        Message->DumpDataToLog((PVOID)index_entry,
                                               max(min(0x100, index_entry->Length),
                                                   sizeof(INDEX_ENTRY)));
                        Message->Unlock();
                    }
                    need_delete = TRUE;
                }

                pfrs = &frs;
            }
        }
        frsDataRecordCount--;

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!SkipEntriesScan) {

            if (!need_delete && !pfrs->IsBase()) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }

            if (!need_delete &&
                !(pfrs->QuerySegmentReference() == index_entry->FileReference)) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                                 "%I64x%W%W%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 index_entry->FileReference,
                                 pfrs->QuerySegmentReference());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                    Message->Log("%I64x%W%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 index_entry->FileReference,
                                 pfrs->QuerySegmentReference());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }

            if (!need_delete &&
                file_name_index &&
                !file_has_too_many_file_names &&
                !pfrs->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                             ChkdskInfo,
                                             FixLevel, Message,
                                             DiskErrorsFound, FALSE)) {
                return FALSE;
            }

            // After verifying the file names we know that this FRS is
            // not a candidate for a missing data attribute if it has
            // its index bit set.

            if (!need_delete && pfrs->IsIndexPresent()) {
                ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);
            }

            // do we need to see if this is a file_name_index first?
            if (!need_delete &&
                !file_has_too_many_file_names &&
                !pfrs->QueryResidentAttribute(&attribute, &error,
                                              Index->QueryTypeCode(),
                                              file_name,
                                              index_entry->AttributeLength,
                                              Index->QueryCollationRule())) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog(file_name,
                                           max(min(0x100, index_entry->AttributeLength),
                                               sizeof(FILE_NAME)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            !SkipEntriesScan &&
            file_name_index &&
            !file_has_too_many_file_names) {

            if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            frs_file_name = (PFILE_NAME) attribute.GetResidentValue();
            DebugAssert(frs_file_name);


            p = &file_name->Info;
            q = &actual_dupinfo;
            dupinfo_match = TRUE;

            if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                frs_file_name->Flags != file_name->Flags) {

                if (file_number >= FIRST_USER_FILE_NUMBER) {

                    if (p->CreationTime != q->CreationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->CreationTime, q->CreationTime));
                    }

                    if (p->LastModificationTime != q->LastModificationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastModificationTime, q->LastModificationTime));
                    }

                    if (p->LastChangeTime != q->LastChangeTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastChangeTime, q->LastChangeTime));
                    }

                    if (p->AllocatedLength != q->AllocatedLength) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                    }

                    if (p->FileSize != q->FileSize) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                    }

                    if (p->FileAttributes != q->FileAttributes) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileAttributes, q->FileAttributes));
                    }

                    if (ChkdskInfo->major >= 2 &&
                        q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                        if (p->ReparsePointTag != q->ReparsePointTag) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->ReparsePointTag, q->ReparsePointTag));
                        }
                    } else {
                        if (p->PackedEaSize != q->PackedEaSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->PackedEaSize, q->PackedEaSize));
                        }
                    }

                    if (file_name->Flags != frs_file_name->Flags) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         file_name->Flags, frs_file_name->Flags));
                    }
                } else {
                    dupinfo_match = FALSE;
                }
            }

            if (!dupinfo_match) {

                // Don't report duplicated information on system files.

                if (file_number >= FIRST_USER_FILE_NUMBER) {
                    FileSystemConsistencyErrorsFound = TRUE;
                    if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                    }
                }


// Take out this message because it's annoying.
#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", file_number.GetLowPart());
#endif

                if (FixLevel != CheckOnly) {
                    *Changes = TRUE;
                }

                memcpy(&file_name->Info, &actual_dupinfo,
                       sizeof(DUPLICATED_INFORMATION));
                file_name->Flags = frs_file_name->Flags;

                if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (!(frs_file_name->ParentDirectory ==
                  file_name->ParentDirectory)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QuerySegmentReference(),
                             Index->GetName(),
                             &entry_name,
                             file_name->ParentDirectory,
                             file_number.GetLargeInteger());

                need_delete = TRUE;
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;
                *NumFileNames += 1;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }
    if (frsDataRecordCount == 0) {
        goto ProcessNextBlock;
    }

    DebugAssert(FALSE);
    return FALSE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex2(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name, frs_file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

    while (index_entry = Index->GetNext(&depth, &error)) {

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        if (ChkdskInfo->IndexEntriesToCheck.IsFree(file_number, 1))
            continue;

        need_delete = FALSE;
        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete) {
            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {
                if (!frs.Initialize(file_number, Mft)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (!frs.Read()) {
                    need_delete = TRUE;
                } else if (!frs.IsInUse()) {

                    if (file_name_index) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_FRS,
                                     "%I64x%W%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     &entry_name,
                                     file_number.GetLargeInteger());
                    } else {

                        Message->Lock();
                        Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_FRS);
                        Message->Log("%I64x%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     file_number.GetLargeInteger());
                        Message->DumpDataToLog((PVOID)index_entry,
                                               max(min(0x100, index_entry->Length),
                                                   sizeof(INDEX_ENTRY)));
                        Message->Unlock();
                    }
                    need_delete = TRUE;
                }
                pfrs = &frs;
            }
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!need_delete && !pfrs->IsBase()) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        if (!need_delete &&
            !(pfrs->QuerySegmentReference() == index_entry->FileReference)) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             index_entry->FileReference,
                             pfrs->QuerySegmentReference());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                Message->Log("%I64x%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             index_entry->FileReference,
                             pfrs->QuerySegmentReference());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !pfrs->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                         ChkdskInfo,
                                         FixLevel, Message,
                                         DiskErrorsFound, FALSE)) {

            return FALSE;
        }

        // After verifying the file names we know that this FRS is
        // not a candidate for a missing data attribute if it has
        // its index bit set.

        if (!need_delete && pfrs->IsIndexPresent()) {
            ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);
        }

        if (!need_delete &&
            !file_has_too_many_file_names &&
            !pfrs->QueryResidentAttribute(&attribute, &error,
                                          Index->QueryTypeCode(),
                                          file_name,
                                          index_entry->AttributeLength,
                                          Index->QueryCollationRule())) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(file_name,
                                       max(min(0x100, index_entry->AttributeLength),
                                           sizeof(FILE_NAME)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names) {

            if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            frs_file_name = (PFILE_NAME) attribute.GetResidentValue();
            DebugAssert(frs_file_name);


            p = &file_name->Info;
            q = &actual_dupinfo;
            dupinfo_match = TRUE;

            if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                frs_file_name->Flags != file_name->Flags) {

                if (file_number >= FIRST_USER_FILE_NUMBER) {

                    if (p->CreationTime != q->CreationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->CreationTime, q->CreationTime));
                    }

                    if (p->LastModificationTime != q->LastModificationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastModificationTime, q->LastModificationTime));
                    }

                    if (p->LastChangeTime != q->LastChangeTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastChangeTime, q->LastChangeTime));
                    }

                    if (p->AllocatedLength != q->AllocatedLength) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                    }

                    if (p->FileSize != q->FileSize) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                    }

                    if (p->FileAttributes != q->FileAttributes) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileAttributes, q->FileAttributes));
                    }

                    if (ChkdskInfo->major >= 2 &&
                        q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                        if (p->ReparsePointTag != q->ReparsePointTag) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->ReparsePointTag, q->ReparsePointTag));
                        }
                    } else {
                        if (p->PackedEaSize != q->PackedEaSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->PackedEaSize, q->PackedEaSize));
                        }
                    }

                    if (file_name->Flags != frs_file_name->Flags) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         file_name->Flags, frs_file_name->Flags));
                    }
                } else {
                    dupinfo_match = FALSE;
                }
            }

            if (!dupinfo_match) {

                // Don't report duplicated information on system files.

                if (file_number >= FIRST_USER_FILE_NUMBER) {
                    FileSystemConsistencyErrorsFound = TRUE;
                    if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                    }
                }


// Take out this message because it's annoying.
#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", file_number.GetLowPart());
#endif

                if (FixLevel != CheckOnly) {
                    *Changes = TRUE;
                }

                memcpy(&file_name->Info, &actual_dupinfo,
                       sizeof(DUPLICATED_INFORMATION));
                file_name->Flags = frs_file_name->Flags;

                if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (!(frs_file_name->ParentDirectory ==
                  file_name->ParentDirectory)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QuerySegmentReference(),
                             Index->GetName(),
                             &entry_name,
                             file_name->ParentDirectory,
                             file_number.GetLargeInteger());

                need_delete = TRUE;
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInObjIdIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given object id
    index and makes sure that they point to an appropriate file with
    the same object id.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    POBJID_INDEX_ENTRY_VALUE    objid_index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    DSTRING                     IndexName;
    NTFS_INDEX_TREE             IndexTree;
    BIG_INT                     i;
    PINDEX_ENTRY                NewEntry;
    NUMBER_SET                  DuplicateTest;
    BOOLEAN                     AlreadyExists;
    BOOLEAN                     need_save;
    OBJECT_ID                   ObjId;
    ULONG                       BytesRead;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // First make sure each entry in the index reference an unique frs
    //

    if (!DuplicateTest.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    *Changes = FALSE;
    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {
        objid_index_entry = (POBJID_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(objid_index_entry->SegmentReference.LowPart,
                        (LONG) objid_index_entry->SegmentReference.HighPart);

        if (DuplicateTest.CheckAndAdd(file_number, &AlreadyExists)) {
            if (AlreadyExists) {

               // another entry with same file number
               // so we remove this colliding entry

               *DiskErrorsFound = TRUE;
               errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

               Message->LogMsg(MSG_CHKLOG_NTFS_MULTIPLE_OBJID_INDEX_ENTRIES_WITH_SAME_FILE_NUMBER,
                            "%I64x%I64x",
                            IndexFrs->QueryFileNumber().GetLargeInteger(),
                            file_number.GetLargeInteger());

               Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                "%d%W",
                                IndexFrs->QueryFileNumber().GetLowPart(),
                                Index->GetName());

               if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                   !Index->DeleteCurrentEntry()) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
               }
               need_save = TRUE;
            }
        } else {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    DuplicateTest.RemoveAll();

    //
    // now make sure index entries point to an existing frs
    //

    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {

        objid_index_entry = (POBJID_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(objid_index_entry->SegmentReference.LowPart,
                        (LONG) objid_index_entry->SegmentReference.HighPart);

        need_delete = FALSE;

        if (ChkdskInfo->FilesWithObjectId.DoesIntersectSet(file_number, 1)) {

            // there is a corresponding file with an object id entry
            // check to make sure that the two object id's are equal

            ChkdskInfo->FilesWithObjectId.Remove(file_number, 1);

            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {

                MSGID   msgid;

                if (!frs.Initialize(file_number, Mft)) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                error = FALSE;
                if (!frs.Read()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_UNREADABLE_FRS;
                    error = TRUE;
                } else if (!frs.IsInUse()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NOT_INUSE_FRS;
                    error = TRUE;
                } else if (!frs.IsBase()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NON_BASE_FRS;
                    error = TRUE;
                }

                if (error) {
                   // something is not right
                   // the frs was readable & in use otherwise we wouldn't be here

                   *DiskErrorsFound = TRUE;
                   errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                   Message->LogMsg(msgid, "%I64x%I64x",
                                IndexFrs->QueryFileNumber().GetLargeInteger(),
                                file_number.GetLargeInteger());

                   Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                    "%d%W",
                                    IndexFrs->QueryFileNumber().GetLowPart(),
                                    Index->GetName());

                   if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                       !Index->DeleteCurrentEntry()) {
                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                   }
                   need_save = TRUE;
                   continue;
                }
                pfrs = &frs;
            }

            if (!pfrs->QueryAttribute(&attribute, &error, $OBJECT_ID) ||
                !attribute.Read(&ObjId, 0, sizeof(ObjId), &BytesRead) ||
                BytesRead != sizeof(ObjId)) {
                // previously exists attribute does not exists anymore
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (memcmp(&(objid_index_entry->key),
                       &ObjId, sizeof(OBJECT_ID)) != 0) {

                // Assume the object id stored with the index is incorrect.
                // We cannot just overwrite the incorrect values and write
                // out the entry as that may change the ordering of the index.
                // So, we delete the entry and insert it back later on

                if (!ChkdskInfo->FilesWithObjectId.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_HAS_INCORRECT_OBJID);
                Message->Log("%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(&(objid_index_entry->key), sizeof(OBJECT_ID));
                Message->Set(MSG_CHKLOG_NTFS_DIVIDER);
                Message->Log();
                Message->DumpDataToLog(&ObjId, sizeof(OBJECT_ID));
                Message->Unlock();

                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
                continue;
            }

            if (!(objid_index_entry->SegmentReference ==
                pfrs->QuerySegmentReference())) {
                // should correct index entry

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_HAS_INCORRECT_PARENT);
                Message->Log("%I64x%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             objid_index_entry->SegmentReference,
                             pfrs->QuerySegmentReference());
                Message->DumpDataToLog(&(objid_index_entry->key), sizeof(OBJECT_ID));
                Message->Unlock();

                Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                objid_index_entry->SegmentReference = pfrs->QuerySegmentReference();

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
            }
        } else {
            // the particular file does not have an object id entry
            // this index entry should be deleted

            *DiskErrorsFound = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->LogMsg(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NO_OBJID_FRS,
                         "%I64x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         file_number.GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                             "%d%W",
                             IndexFrs->QueryFileNumber().GetLowPart(),
                             Index->GetName());

            if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            need_save = TRUE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         pfrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    // Now loop thru the remainder of files with object id and insert
    // them into the object id index

    if (!IndexName.Initialize(ObjectIdIndexNameData) ||
        !IndexTree.Initialize( IndexFrs->GetDrive(),
                               QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               IndexFrs->GetUpcaseTable(),
                               IndexFrs->QuerySize()/2,
                               IndexFrs,
                               &IndexName ) ) {
        return FALSE;
    }
    if (!(NewEntry = (PINDEX_ENTRY)MALLOC(sizeof(INDEX_ENTRY) +
                                          sizeof(OBJID_INDEX_ENTRY_VALUE)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_save = FALSE;
    i = 0;
    while (i < ChkdskInfo->FilesWithObjectId.QueryCardinality()) {
        file_number = ChkdskInfo->FilesWithObjectId.QueryNumber(i);
        ChkdskInfo->FilesWithObjectId.Remove(file_number);
        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read() ||
            !frs.QueryAttribute(&attribute, &error, $OBJECT_ID) ||
            !attribute.Read(&ObjId, 0, sizeof(ObjId), &BytesRead) ||
            BytesRead != sizeof(ObjId)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(NewEntry);
            return FALSE;
        }

        memset((PVOID)NewEntry, 0, sizeof(INDEX_ENTRY) +
                                   sizeof(OBJID_INDEX_ENTRY_VALUE));
        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(OBJECT_ID);
        NewEntry->DataLength = sizeof(OBJID_INDEX_ENTRY_VALUE)-sizeof(OBJECT_ID);
        NewEntry->ReservedForZero = 0;
        NewEntry->Length = QuadAlign(sizeof(INDEX_ENTRY)+sizeof(OBJID_INDEX_ENTRY_VALUE));
        NewEntry->AttributeLength = sizeof(OBJECT_ID);
        NewEntry->Flags = 0;

        objid_index_entry = ((POBJID_INDEX_ENTRY_VALUE)GetIndexEntryValue(NewEntry));
        memcpy(&(objid_index_entry->key), &ObjId, sizeof(OBJECT_ID));
        objid_index_entry->SegmentReference = frs.QuerySegmentReference();
        memset(objid_index_entry->extraInfo, 0, sizeof(objid_index_entry->extraInfo));

        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (FixLevel != CheckOnly && SET_TRUE(*Changes)) {

            BOOLEAN     duplicate;

            if (!IndexTree.InsertEntry( NewEntry, TRUE, &duplicate )) {
                //FREE(NewEntry);
                if (duplicate) {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_DUPLICATE_OBJID);
                    Message->Log("%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog(&ObjId, sizeof(OBJECT_ID));
                    Message->Unlock();

                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_DUPLICATE_OBJID,
                                     "%d", file_number.GetLowPart());

                    if (!attribute.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(attribute.QueryTypeCode(),
                                                  attribute.GetName())) {
                        DebugPrintTrace(("UNTFS: Unable to purge object id attribute\n"));
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(NewEntry);
                        return FALSE;
                    }
                    if (!frs.Flush(Mft->GetVolumeBitmap())) {
                        DebugPrintTrace(("UNTFS: Unable to flush frs %d\n",
                                         frs.QueryFileNumber().GetLowPart()));
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(NewEntry);
                        return FALSE;
                    }
                } else {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_INSERT_INDEX_ENTRY);
                    FREE(NewEntry);
                    return FALSE;
                }
            } else {

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OBJID_INDEX_ENTRY,
                             "%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             file_number.GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
                need_save = TRUE;
            }
        } else {
            Message->DisplayMsg(MSG_CHK_NTFS_MISSING_DUPLICATE_OBJID,
                             "%d", file_number.GetLowPart());
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FixLevel == CheckOnly) {
        FREE(NewEntry);
        if (chkdskErrCouldNotFix)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        return TRUE;
    }

    if (need_save && !IndexTree.Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    FREE(NewEntry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInReparseIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given reparse point
    index and makes sure that they point to an appropriate file with
    the same tag.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    PREPARSE_INDEX_ENTRY_VALUE  reparse_index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    DSTRING                     IndexName;
    NTFS_INDEX_TREE             IndexTree;
    BIG_INT                     num_files;
    PINDEX_ENTRY                NewEntry;
    BOOLEAN                     need_save;
    REPARSE_DATA_BUFFER         reparse_point;
    ULONG                       BytesRead;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    NTFS_BITMAP                 filesWithReparsePoint;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    PCHAR                       timestr;
#endif

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                        "%s%s", "ValidateEntriesInReparsePoint: ", timestr);
#endif

    *Changes = FALSE;

    num_files = ChkdskInfo->FilesWithReparsePoint.QuerySize();

    //
    // make a copy FilesWithReparsePoint
    //
    if (!filesWithReparsePoint.Initialize(num_files, FALSE)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    for (file_number = 0; file_number < num_files; file_number += 1) {

        if (ChkdskInfo->FilesWithReparsePoint.IsFree(file_number, 1))
            continue;
        else
            filesWithReparsePoint.SetAllocated(file_number, 1);
    }

    //
    // make sure index entries point to an existing frs
    //
    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {

        reparse_index_entry = (PREPARSE_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(reparse_index_entry->SegmentReference.LowPart,
                        (LONG)reparse_index_entry->SegmentReference.HighPart);

        need_delete = FALSE;

        if (!filesWithReparsePoint.IsFree(file_number, 1)) {

            // there is a corresponding file with a reparse point entry
            // check to make sure that the two tags are equal

            filesWithReparsePoint.SetFree(file_number, 1);

            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {

                MSGID   msgid;

                if (!frs.Initialize(file_number, Mft)) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                error = FALSE;
                if (!frs.Read()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_UNREADABLE_FRS;
                    error = TRUE;
                } else if (!frs.IsInUse()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NOT_INUSE_FRS;
                    error = TRUE;
                } else if (!frs.IsBase()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NON_BASE_FRS;
                    error = TRUE;
                }

                if (error) {

                   // something is not right
                   // the frs was readable & in use otherwise we wouldn't be here

                   *DiskErrorsFound = TRUE;
                   errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                   Message->LogMsg(msgid, "%I64x%I64x",
                                IndexFrs->QueryFileNumber().GetLargeInteger(),
                                file_number.GetLargeInteger());

                   Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                    "%d%W",
                                    IndexFrs->QueryFileNumber().GetLowPart(),
                                    Index->GetName());

                   if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                       !Index->DeleteCurrentEntry()) {
                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                   }
                   need_save = TRUE;
                   continue;
                }
                pfrs = &frs;
            }

            if (!pfrs->QueryAttribute(&attribute, &error, $REPARSE_POINT) ||
                !attribute.Read(&reparse_point,
                                0,
                                FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                             GenericReparseBuffer.DataBuffer),
                                &BytesRead) ||
                BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)) {
                // previously exists attribute does not exists anymore
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            error = FALSE;

            if (reparse_index_entry->Tag != reparse_point.ReparseTag) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_HAS_INCORRECT_REPARSE_TAG,
                             "%I64x%x%x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             reparse_index_entry->Tag,
                             reparse_point.ReparseTag,
                             file_number.GetLargeInteger());
                error = TRUE;
            } else if (!(reparse_index_entry->SegmentReference ==
                         pfrs->QuerySegmentReference())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_HAS_INCORRECT_PARENT,
                             "%I64x%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             reparse_index_entry->SegmentReference,
                             pfrs->QuerySegmentReference(),
                             reparse_index_entry->Tag);
                error = TRUE;
            }

            if (error) {

                // Assume the reparse tag/SR stored with the index is incorrect.
                // We cannot just overwrite the incorrect values and write
                // out the entry as that may change the ordering of the index.
                // So, we delete the entry and insert it back later on

                filesWithReparsePoint.SetAllocated(file_number, 1);

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
                continue;
            }
        } else {
            // the particular file does not have a reparse point entry
            // this index entry should be deleted

            *DiskErrorsFound = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NO_REPARSE_FRS,
                         "%I64x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         file_number.GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                             "%d%W",
                             IndexFrs->QueryFileNumber().GetLowPart(),
                             Index->GetName());

            if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            need_save = TRUE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         pfrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    // Now loop thru the remainder of files with reparse point and insert
    // them into the reparse index

    if (!IndexName.Initialize(ReparseIndexNameData) ||
        !IndexTree.Initialize( IndexFrs->GetDrive(),
                               QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               IndexFrs->GetUpcaseTable(),
                               IndexFrs->QuerySize()/2,
                               IndexFrs,
                               &IndexName ) ) {
        return FALSE;
    }
    if (!(NewEntry = (PINDEX_ENTRY)MALLOC(sizeof(INDEX_ENTRY) +
                                          sizeof(REPARSE_INDEX_ENTRY_VALUE)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_save = FALSE;
    for (file_number = 0; file_number < num_files; file_number += 1) {

        if (filesWithReparsePoint.IsFree(file_number, 1))
            continue;

        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read() ||
            !frs.QueryAttribute(&attribute, &error, $REPARSE_POINT) ||
            !attribute.Read(&reparse_point,
                            0,
                            FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                         GenericReparseBuffer.DataBuffer),
                            &BytesRead) ||
            BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(NewEntry);
            return FALSE;
        }

        //
        // There is no data value.
        // The whole REPARSE_INDEX_ENTRY_VALUE is the index key
        //

        memset((PVOID)NewEntry, 0, sizeof(INDEX_ENTRY) +
                                   sizeof(REPARSE_INDEX_ENTRY_VALUE));
        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(REPARSE_INDEX_ENTRY_VALUE);
        NewEntry->DataLength = 0;
        NewEntry->ReservedForZero = 0;
        NewEntry->Length = QuadAlign(sizeof(INDEX_ENTRY)+sizeof(REPARSE_INDEX_ENTRY_VALUE));
        NewEntry->AttributeLength = sizeof(REPARSE_INDEX_ENTRY_VALUE);
        NewEntry->Flags = 0;

        reparse_index_entry = ((PREPARSE_INDEX_ENTRY_VALUE)GetIndexEntryValue(NewEntry));
        reparse_index_entry->Tag = reparse_point.ReparseTag;
        reparse_index_entry->SegmentReference = frs.QuerySegmentReference();

        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_REPARSE_INDEX_ENTRY,
                     "%I64x%I64x",
                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                     file_number.GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());

        if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
            !IndexTree.InsertEntry( NewEntry )) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_INSERT_INDEX_ENTRY);
            FREE(NewEntry);
            return FALSE;
        }
        need_save = TRUE;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FixLevel == CheckOnly) {
        FREE(NewEntry);
        if (chkdskErrCouldNotFix)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&time2);
        Message->Lock();
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        timestr = ctime(&time2);
        timestr[strlen(timestr)-1] = 0;
        Message->Display("%s%s", "After ValidateEntriesInReparsePoint: ", timestr);
        Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
        Message->Unlock();
#endif
        return TRUE;
    }

    if (need_save && !IndexTree.Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    FREE(NewEntry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&time2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After ValidateEntriesInReparsePoint: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    return TRUE;
}

BOOLEAN
RemoveBadLink(
        OUT  PNUMBER_SET             Orphans,
    IN      ULONG                   ParentFileNumber,
    IN      ULONG                   ChildFileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine removes all file name links between the given
    parent in child.  Neither the directory entries nor the
    file names are preserved.

Arguments:

    ParentFileNumber    - Supplies the parent file number.
    ChildFileNumber     - Supplies the child file number.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    parent_frs;
    NTFS_INDEX_TREE             index;
    NTFS_FILE_RECORD_SEGMENT    child_frs;
    PNTFS_FILE_RECORD_SEGMENT   pchild_frs;
    DSTRING                     index_name;
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attribute;
    ULONG                       i;
    PFILE_NAME                  file_name;
    ULONG                       attr_len;
    BOOLEAN                     success;

    if (ParentFileNumber == ROOT_FILE_NAME_INDEX_NUMBER &&
        ChildFileNumber == ROOT_FILE_NAME_INDEX_NUMBER) {

        return TRUE;
    }

    if (!parent_frs.Initialize(ParentFileNumber, Mft) ||
        !parent_frs.Read() ||
        !index_name.Initialize(FileNameIndexNameData) ||
        !index.Initialize(parent_frs.GetDrive(),
                          parent_frs.QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          parent_frs.QuerySize()/2,
                          &parent_frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ParentFileNumber == ChildFileNumber) {
        pchild_frs = &parent_frs;
    } else {

        pchild_frs = &child_frs;

        if (!pchild_frs->Initialize(ChildFileNumber, Mft) ||
            !pchild_frs->Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    i = 0;
    while (pchild_frs->QueryAttributeByOrdinal(&attribute, &error,
                                               $FILE_NAME, i)) {

        file_name = (PFILE_NAME) attribute.GetResidentValue();
        attr_len = attribute.QueryValueLength().GetLowPart();

        if (file_name->ParentDirectory.LowPart == ParentFileNumber) {

            if (!pchild_frs->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name, attr_len, &success) ||
                !success ||
                !index.DeleteEntry(attr_len, file_name, 0)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            i = 0;
        } else
            i++;
    }
    //
    // if nobody is referencing the child and the child is not the root,
    // then it becomes an orphan
    //
    if (pchild_frs->QueryReferenceCount() == 0 &&
        ChildFileNumber != ROOT_FILE_NAME_INDEX_NUMBER) {

        Message->LogMsg(MSG_CHKLOG_NTFS_ORPHAN_CREATED_ON_BREAKING_CYCLE,
                     "%x%x", ParentFileNumber, ChildFileNumber);

        Orphans->Add(ChildFileNumber);
    }

    if (error || FixLevel != CheckOnly) {
        if (error ||
            !index.Save(&parent_frs) ||
            !parent_frs.Flush(Mft->GetVolumeBitmap()) ||
            !pchild_frs->Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::RecoverOrphans(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PDIGRAPH                DirectoryDigraph,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BOOLEAN                 SkipCycleScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine recovers orphans into a subdirectory of the root
    subdirectory.  It also validates the existence of the file
    systems root directory which it expects to be supplied in the
    list of 'OrphanedDirectories'.

Arguments:

    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    DirectoryDigraph    - Supplies the directory digraph.
    Mft                 - Supplies the master file table.
    SkipCycleScan       - Supplies if cycles within directory tree should be checcked.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LIST                        bad_links;
    PITERATOR                   bad_links_iter;
    PDIGRAPH_EDGE               p;
    NUMBER_SET                  parents_of_root;
    ULONG                       i, n;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    NUMBER_SET                  orphans;
    PNUMBER_SET                 no_ref;
    ULONG                       cluster_size;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN                     completionStatus;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    // First make sure that the root directory is intact.

    if (!index_name.Initialize(FileNameIndexNameData) ||
        !root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) ||
        !root_frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    BOOLEAN error = FALSE;

    if (!root_frs.IsIndexPresent()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                     "%x", ROOT_FILE_NAME_INDEX_NUMBER);

        error = TRUE;
    } else if (!root_index.Initialize(_drive, QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      root_frs.QuerySize()/2,
                                      &root_frs,
                                      &index_name)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INVALID_ROOT_INDEX,
                     "%x%W", ROOT_FILE_NAME_INDEX_NUMBER, &index_name);

        error = TRUE;
    }

    if (error) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATING_ROOT_DIRECTORY);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!root_index.Initialize($FILE_NAME,
               _drive, QueryClusterFactor(),
               Mft->GetVolumeBitmap(),
               Mft->GetUpcaseTable(),
               COLLATION_FILE_NAME,
               SMALL_INDEX_BUFFER_SIZE,
               root_frs.QuerySize()/2,
               &index_name)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        ChkdskReport->NumIndices += 1;

        if (FixLevel != CheckOnly &&
            (!root_index.Save(&root_frs) ||
             !root_frs.Flush(Mft->GetVolumeBitmap()))) {

            DebugAbort("can't write");
            return FALSE;
        }
    }


    // Compute the list of orphans.  This is to include files with
    // no references whatsoever.

    if (!orphans.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    for (i = 0; i < ChkdskInfo->NumFiles; i++) {
        if (ChkdskInfo->NumFileNames[i] && !orphans.Add(i)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    no_ref = &(ChkdskInfo->FilesWithNoReferences);
    if (!no_ref->Remove(0, FIRST_USER_FILE_NUMBER) ||
        !orphans.Add(no_ref)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (orphans.QueryCardinality() != 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_ORPHANS);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        // Connect all possible orphans the easy way.  Adjust the
        // directory digraph accordingly.

        if (!ProperOrphanRecovery(&orphans, Mft, DirectoryDigraph,
                                  SkipCycleScan, ChkdskInfo, ChkdskReport,
                                  FixLevel, Message)) {
            return FALSE;
        }
    }


    // Construct a list with all of the links that introduce cycles
    // or point to the root.

    if (!SkipCycleScan) {

        if (!bad_links.Initialize() ||
            !DirectoryDigraph->EliminateCycles(&bad_links, &completionStatus) ||
            !(bad_links_iter = bad_links.QueryIterator()) ||
            !DirectoryDigraph->QueryParents(ROOT_FILE_NAME_INDEX_NUMBER,
                                            &parents_of_root)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!completionStatus) {
            Message->DisplayMsg(MSG_CHK_DIRECTORY_DEPTH_TOO_DEEP);
        }

        n = parents_of_root.QueryCardinality().GetLowPart();
        for (i = 0; i < n; i++) {

            if (!(p = NEW DIGRAPH_EDGE)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            p->Parent = parents_of_root.QueryNumber(i).GetLowPart();
            p->Child = ROOT_FILE_NAME_INDEX_NUMBER;

            if (!bad_links.Put(p)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        bad_links_iter->Reset();
        while (p = (PDIGRAPH_EDGE) bad_links_iter->GetNext()) {

            // Ignore links from the root to itself.

            if (p->Parent == ROOT_FILE_NAME_INDEX_NUMBER &&
                p->Child == ROOT_FILE_NAME_INDEX_NUMBER) {

                continue;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_CYCLES_IN_DIR_TREE,
                             "%d%d", p->Parent, p->Child);

            if (FixLevel == CheckOnly) {
                UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
                return TRUE;
            }

            if (!RemoveBadLink(&orphans, p->Parent, p->Child,
                                        Mft, FixLevel, Message)) {
                return FALSE;
            }
        }

        DELETE(bad_links_iter);
        bad_links.DeleteAllMembers();
    }


    // Recover the remaining orphans.

    if (!root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) ||
        !root_frs.Read() ||
        !root_index.Initialize(_drive, QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               Mft->GetUpcaseTable(),
                               root_frs.QuerySize()/2,
                               &root_frs,
                               &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (orphans.QueryCardinality() != 0 &&
        !OldOrphanRecovery(&orphans, ChkdskInfo, ChkdskReport, &root_frs,
                           &root_index, Mft, FixLevel, Message)) {

        return FALSE;
    }

    if (FixLevel != CheckOnly) {

        if (!root_index.Save(&root_frs) ||
            !root_frs.Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
ConnectFile(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   OrphanFile,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    OUT     PBOOLEAN                    Connected,
    IN      BOOLEAN                     RemoveCrookedLinks,
    IN      BOOLEAN                     SkipCycleScan,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine connects all possible file names contained in
    the orphan to their parents.  If any or all end up being
    connected before of after this call then *Connected will be
    set to TRUE.  If RemoveCrookedLinks is TRUE then this routine
    will delete any file names that cannot be connected to their
    parents.

Arguments:

    OrphanFile          - Supplies the file to connect.
    DirectoryDigraph    - Supplies the directory digraph for future
                            enhancements.
    Connected           - Returns whether or not the file could be
                            connected to at least one directory.
    RemoveCrookedLinks  - Supplies whether or not to remove file names
                            which cannot be connected to their parents.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                     index_name;
    NTFS_FILE_RECORD_SEGMENT    parent_file;
    PNTFS_FILE_RECORD_SEGMENT   pparent_file;
    NTFS_INDEX_TREE             parent_index;
    ULONG                       i;
    MFT_SEGMENT_REFERENCE       parent_seg_ref;
    VCN                         parent_file_number;
    DSTRING                     file_name_string;
    NTFS_ATTRIBUTE              file_name_attribute;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    PFILE_NAME                  file_name;
    MFT_SEGMENT_REFERENCE       seg_ref;
    BOOLEAN                     success;

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Iterate through all of the file name entries here.

    *Connected = FALSE;
    for (i = 0; OrphanFile->QueryAttributeByOrdinal(
                    &file_name_attribute, &error,
                    $FILE_NAME, i); i++) {

        file_name = (PFILE_NAME) file_name_attribute.GetResidentValue();
        DebugAssert(file_name);


        // Figure out who the claimed parent of the orphan is.

        parent_seg_ref = file_name->ParentDirectory;

        if (!file_name_string.Initialize(
                    file_name->FileName,
                    (ULONG) file_name->FileNameLength)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        parent_file_number.Set(parent_seg_ref.LowPart,
                               (LONG) parent_seg_ref.HighPart);

        if (parent_file_number == OrphanFile->QueryFileNumber()) {
            pparent_file = OrphanFile;
        } else {
            pparent_file = &parent_file;

            if (!pparent_file->Initialize(parent_file_number, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }


        // Determine whether or not the so-called parent is a real index.

        if ((pparent_file != OrphanFile && !pparent_file->Read()) ||
            !pparent_file->IsInUse() || !pparent_file->IsBase() ||
            (ChkdskInfo->major >= 2 && parent_file_number == EXTEND_TABLE_NUMBER) ||
            !(pparent_file->QuerySegmentReference() == parent_seg_ref) ||
            !pparent_file->QueryAttribute(&attribute, &error, $FILE_NAME) ||
            !parent_index.Initialize(OrphanFile->GetDrive(),
                                     OrphanFile->QueryClusterFactor(),
                                     Mft->GetVolumeBitmap(),
                                     pparent_file->GetUpcaseTable(),
                                     pparent_file->QuerySize()/2,
                                     pparent_file,
                                     &index_name) ||
            parent_index.QueryTypeCode() != $FILE_NAME) {

            if (RemoveCrookedLinks) {
                OrphanFile->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name,
                        file_name_attribute.QueryValueLength().GetLowPart(),
                        &success);

                OrphanFile->SetReferenceCount(
                        OrphanFile->QueryReferenceCount() + 1);

                i--;
            }

            continue;
        }


        // First make sure that the entry isn't already in there.

        if (parent_index.QueryFileReference(
                file_name_attribute.QueryValueLength().GetLowPart(),
                file_name, 0, &seg_ref, &error)) {

            // If the entry is there and points to this orphan
            // then the file is already connected.  Otherwise,
            // this file cannot be connected to the parent index
            // through this file name.  This file_name is then "crooked".

            if (seg_ref == OrphanFile->QuerySegmentReference()) {
                *Connected = TRUE;
            } else if (RemoveCrookedLinks) {

                OrphanFile->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name,
                        file_name_attribute.QueryValueLength().GetLowPart(),
                        &success);

                // Readjust the reference count post delete because
                // the file-name we deleted does not appear in any index.

                OrphanFile->SetReferenceCount(
                        OrphanFile->QueryReferenceCount() + 1);

                if (!OrphanFile->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                                       ChkdskInfo,
                                                       FixLevel, Message) ||
                    !OrphanFile->Flush(Mft->GetVolumeBitmap(),
                                       &parent_index)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i--;
            }

            continue;
        }


        // Now there is a parent directory so add this file name
        // into the index.

        Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_ORPHAN,
                            "%W%I64d%d", &file_name_string,
                            OrphanFile->QueryFileNumber().GetLargeInteger(),
                            pparent_file->QueryFileNumber().GetLowPart());

        if (FixLevel != CheckOnly) {

            BIG_INT         initial_size;
            BOOLEAN         error;
            NTFS_ATTRIBUTE  attrib;

            if (pparent_file->QueryAttribute(&attrib,
                                             &error,
                                             $INDEX_ALLOCATION,
                                             parent_index.GetName())) {
                initial_size = attrib.QueryAllocatedLength();
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else
                initial_size = 0;

            if (!parent_index.InsertEntry(
                    file_name_attribute.QueryValueLength().GetLowPart(),
                    file_name,
                    OrphanFile->QuerySegmentReference()) ||
                !OrphanFile->Flush(Mft->GetVolumeBitmap(),
                                   &parent_index) ||
                !parent_index.Save(pparent_file) ||
                !pparent_file->Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_RECOVER_ORPHAN);
            }

            if (pparent_file->QueryAttribute(&attrib,
                                             &error,
                                             $INDEX_ALLOCATION,
                                             parent_index.GetName())) {
                ChkdskReport->BytesInIndices +=
                    (attrib.QueryAllocatedLength() - initial_size);
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!SkipCycleScan) {
            DirectoryDigraph->AddEdge(pparent_file->QueryFileNumber().GetLowPart(),
                                      OrphanFile->QueryFileNumber().GetLowPart());
        }

        OrphanFile->SetReferenceCount(OrphanFile->QueryReferenceCount() + 1);

        *Connected = TRUE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::ProperOrphanRecovery(
    IN OUT  PNUMBER_SET             Orphans,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PDIGRAPH                DirectoryDigraph,
    IN      BOOLEAN                 SkipCycleScan,
    IN      PCNTFS_CHKDSK_INFO      ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine attempts to recover the given orphans where they
    belong.  All properly recovered orphans will be deleted from the
    orphans list.

Arguments:

    Orphans             - Supplies the list of orphans.
    Mft                 - Supplies the master file table.
    DirectoryDigraph    - Supplies the directory digraph for future
                            enhancement.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    BIG_INT                     i;
    BOOLEAN                     connected;

    i = 0;
    while (i < Orphans->QueryCardinality()) {

        // First read in the orphaned file.

        if (!orphan_file.Initialize(Orphans->QueryNumber(i), Mft) ||
            !orphan_file.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.VerifyAndFixFileNames(
                Mft->GetVolumeBitmap(), ChkdskInfo,
                FixLevel, Message)) {

            return FALSE;
        }

        if (!ConnectFile(&orphan_file, DirectoryDigraph,
                         &connected, FALSE, SkipCycleScan,
                         ChkdskInfo, ChkdskReport,
                         Mft, FixLevel, Message)) {

            return FALSE;
        }

        if (connected) {
            if (!Orphans->Remove(Orphans->QueryNumber(i))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // Go through the list of file names and delete those that
            // don't point anywhere.  Only do this one if in /F
            // mode.  Otherwise we see each orphan being recovered
            // twice.

            if (FixLevel != CheckOnly) {
                if (!ConnectFile(&orphan_file, DirectoryDigraph,
                                 &connected, TRUE, SkipCycleScan,
                                 ChkdskInfo, ChkdskReport,
                                 Mft, FixLevel, Message)) {

                    return FALSE;
                }
            }

        } else {
            i += 1;
        }

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_RECOVER_ORPHAN);
        }
    }

    return TRUE;
}


BOOLEAN
RecordParentPointers(
    IN      PCNUMBER_SET                Orphans,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    OUT     PDIGRAPH                    BackPointers
    )
/*++

Routine Description:

    This routine records the parent pointer information in the given
    digraph with (parent, source) edges.

Arguments:

    Orphans         - Supplies the list of orphans.
    ChkdskInfo      - Supplies the chkdsk information.
    Mft             - Supplies the MFT.
    BackPointers    - Returns the parent pointer relationships.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    ULONG                       i;
    PFILE_NAME                  file_name;
    ULONG                       parent_dir;
    ULONG                       file_number;

    if (!BackPointers->Initialize(ChkdskInfo->NumFiles)) {
        return FALSE;
    }

    for (i = 0; i < Orphans->QueryCardinality(); i++) {

        file_number = Orphans->QueryNumber(i).GetLowPart();

        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read()) {
            return FALSE;
        }

        // Only consider one file name per file for this
        // analysis.  This is because we don't ever want
        // to have file in multiple found directories.

        if (frs.QueryAttribute(&attribute, &error, $FILE_NAME)) {

            file_name = (PFILE_NAME) attribute.GetResidentValue();

            parent_dir = file_name->ParentDirectory.LowPart;

            if (parent_dir < ChkdskInfo->NumFiles &&
                file_name->ParentDirectory.HighPart == 0 &&
                !BackPointers->AddEdge(parent_dir, file_number)) {
                return FALSE;
            }

        } else if (error) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
CreateNtfsDirectory(
    IN OUT  PNTFS_INDEX_TREE            CurrentIndex,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   CurrentDirFile,
    IN      PCWSTRING                   FileName,
    IN      ULONG                       FileAttributes,
    OUT     PNTFS_INDEX_TREE            SubDirIndex,
    OUT     PNTFS_FILE_RECORD_SEGMENT   SubDirFile,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    OUT     PBOOLEAN                    OutOfDisk
    )
/*++

Routine Description:

    This routine creates a new subdirectory for a directory.

Arguments:

    CurrentIndex    - Supplies the index in which to insert the
                        new subdirectory entry.
    CurrentDirFile  - Supplies the FRS for the above index.
    FileName        - Supplies the name of the new directory.
    FileAttributes  - Supplies the FILE_xxx flags which should be set in the
                      standard information of this file record segment.
    SubDirIndex     - Returns the index of the new subdirectory.
    SubDirFile      - Returns the FRS of the new subdirectory.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.
    OutOfDisk       - Returns whether this routine ran out of disk
                        space or not.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                     dir_file_number;
    STANDARD_INFORMATION    standard_info;
    FILE_NAME               file_name[2];
    ULONG                   file_name_size;
    DSTRING                 index_name;
    ULONG                   cluster_size;

    *OutOfDisk = FALSE;

    // Create a new file for this directory.

    if (!Mft->AllocateFileRecordSegment(&dir_file_number, FALSE)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
        *OutOfDisk = TRUE;
        return TRUE;
    }

    if (!SubDirFile->Initialize(dir_file_number, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name->ParentDirectory = CurrentDirFile->QuerySegmentReference();
    file_name->FileNameLength = (UCHAR)FileName->QueryChCount();
    file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
    FileName->QueryWSTR(0, TO_END, file_name->FileName,
                        sizeof(FILE_NAME)/sizeof(WCHAR));
    file_name_size = FIELD_OFFSET(FILE_NAME, FileName) +
                     FileName->QueryChCount()*sizeof(WCHAR);

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;
    standard_info.FileAttributes = FileAttributes;

    if (!SubDirFile->Create(&standard_info) ||
        !SubDirFile->AddFileNameAttribute(file_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    cluster_size = Mft->QueryClusterFactor() * Mft->QuerySectorSize();

    if (!index_name.Initialize(FileNameIndexNameData) ||
        !SubDirIndex->Initialize($FILE_NAME,
             SubDirFile->GetDrive(),
             SubDirFile->QueryClusterFactor(),
             Mft->GetVolumeBitmap(),
             Mft->GetUpcaseTable(),
             COLLATION_FILE_NAME,
             CurrentIndex->QueryBufferSize(),
             SubDirFile->QuerySize()/2,
             &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Insert the found file into the root index.

    if (FixLevel != CheckOnly &&
        !CurrentIndex->InsertEntry(file_name_size, file_name,
                                   SubDirFile->QuerySegmentReference())) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

        Mft->GetMftBitmap()->SetFree(dir_file_number, 1);
        *OutOfDisk = TRUE;
        return TRUE;
    }

    SubDirFile->SetIndexPresent();

    return TRUE;
}


BOOLEAN
BuildOrphanSubDir(
    IN      ULONG                       DirNumber,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN      ULONG                       OldParentDir,
    IN OUT  PNUMBER_SET                 OrphansInDir,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN OUT  PNTFS_INDEX_TREE            FoundIndex,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FoundFrs,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    OUT     PBOOLEAN                    OutOfDisk
    )
/*++

Routine Description:

    This routine build orphan directory 'dir<DirNumber>.chk' to
    contain the entries listed in 'OrphansInDir' and then puts
    that directory in given found directory.

Arguments:

    DirNumber       - Supplies the number of the directory to add.
    ChkdskInfo      - Supplies the current chkdsk information.
    ChkdskReport    - Supplies the current chkdsk report to be updated
                        by this routine.
    OldParentDir    - Supplies the old directory file number.
    OrphansInDir    - Supplies the file numbers of the orphans to
                        add to the new directory.  Returns those
                        orphans that were not recovered.
    Mft             - Supplies the MFT.
    FoundIndex      - Supplies the index of the found.XXX directory.
    FoundFrs        - Supplies the frs of found.XXX
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.
    OutOfDisk       - Indicates out of disk space.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    dir_file;
    NTFS_INDEX_TREE             dir_index;
    DSTRING                     dir_name;
    ULONG                       i, j, current_orphan;
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    CHAR                        buf[20];
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    PFILE_NAME                  file_name;
    BOOLEAN                     success, connect;
    ULONG                       file_name_len;


    // First put together 'dir0000.chk' and add the entry to
    // found.000.

    sprintf(buf, "dir%04d.chk", DirNumber);
    if (!dir_name.Initialize(buf)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!CreateNtfsDirectory(FoundIndex, FoundFrs, &dir_name, 0, &dir_index,
                             &dir_file, Mft, FixLevel, Message, OutOfDisk)) {

        return FALSE;
    }

    if (*OutOfDisk == TRUE) {
        return TRUE;
    }

    ChkdskReport->NumIndices += 1;

    i = 0;
    while (i < OrphansInDir->QueryCardinality().GetLowPart()) {

        current_orphan = OrphansInDir->QueryNumber(i).GetLowPart();

        if (!orphan_file.Initialize(current_orphan, Mft) ||
            !orphan_file.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // Go through all of the file names and tube those
        // that are not pointing to the old parent dir.  Otherwise
        // tweek the entry to point back to the new directory.

        connect = FALSE;
        j = 0;
        while (orphan_file.QueryAttributeByOrdinal(&attribute, &error,
                                                   $FILE_NAME, j)) {

            file_name = (PFILE_NAME) attribute.GetResidentValue();
            file_name_len = attribute.QueryValueLength().GetLowPart();

            if (file_name->ParentDirectory.LowPart == OldParentDir &&
                file_name->ParentDirectory.HighPart == 0) {

                if (!orphan_file.DeleteResidentAttribute(
                       $FILE_NAME, NULL, file_name, file_name_len, &success) ||
                   !success) {

                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                orphan_file.SetReferenceCount(
                       orphan_file.QueryReferenceCount() + 1);

                file_name->ParentDirectory = dir_file.QuerySegmentReference();

                if (!attribute.InsertIntoFile(&orphan_file,
                                              Mft->GetVolumeBitmap())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                j = 0;  // reset ordinal as the insertion may have changed
                        // the ordering of the $FILE_NAME attributes

                if (FixLevel != CheckOnly) {
                    if (dir_index.InsertEntry(file_name_len, file_name,
                        orphan_file.QuerySegmentReference())) {

                        connect = TRUE;

                    } else {

                        // this one didn't connect, so destroy the
                        // file_name attribute.  Note that we have
                        // already adjusted the reference count so
                        // (unlike the parallel case in proper orphan
                        // recovery) we don't need to tweek it here.

                        orphan_file.DeleteResidentAttribute(
                            $FILE_NAME, NULL, file_name, file_name_len,
                            &success);
                    }

                } else {
                    connect = TRUE; // don't panic read-only chkdsk
                }
                continue;
            } else if (!(file_name->ParentDirectory ==
                        dir_file.QuerySegmentReference())) {
                if (!orphan_file.DeleteResidentAttribute(
                       $FILE_NAME, NULL, file_name, file_name_len, &success) ||
                   !success) {

                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                orphan_file.SetReferenceCount(
                       orphan_file.QueryReferenceCount() + 1);

                j = 0;
                continue;
            }
            j++;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel, Message,
                                               NULL, TRUE, TRUE)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap(), &dir_index)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If this one was connected then take it out of the list
        // of files that we're orphaned.  Otherwise just increment
        // the counter.

        if (connect) {
            if (!OrphansInDir->Remove(current_orphan)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else {
            i++;
        }
    }

    if (FixLevel != CheckOnly) {

        NTFS_ATTRIBUTE  attrib;
        BOOLEAN         error;

        if (!dir_index.Save(&dir_file) ||
            !dir_file.Flush(Mft->GetVolumeBitmap(), FoundIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

            *OutOfDisk = TRUE;

            return TRUE;
        }

        if (dir_file.QueryAttribute(&attrib,
                                    &error,
                                    $INDEX_ALLOCATION,
                                    dir_index.GetName())) {
            ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::OldOrphanRecovery(
    IN OUT  PNUMBER_SET                 Orphans,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   RootFrs,
    IN OUT  PNTFS_INDEX_TREE            RootIndex,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine recovers all of the orphans in the given list
    into a found.xxx directory.

Arguments:

    Orphans     - Supplies the list of orphans.
    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report to be updated
                    by this routine.
    RootFrs     - Supplies the root FRS.
    RootIndex   - Supplies the root index.
    Mft         - Supplies the master file table.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILE_NAME                   found_name[2];
    ULONG                       found_name_size;
    MFT_SEGMENT_REFERENCE       ref;
    BOOLEAN                     error;
    NTFS_FILE_RECORD_SEGMENT    found_directory;
    ULONG                       i;
    NTFS_INDEX_TREE             found_index;
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    DSTRING                     index_name;
    FILE_NAME                   orphan_file_name[2];
    ULONG                       next_dir_num;
    ULONG                       next_file_num;
    VCN                         file_number;
    DIGRAPH                     back_pointers;
    NUMBER_SET                  dir_candidates;
    NUMBER_SET                  orphans_in_dir;
    ULONG                       dir_num;
    DSTRING                     lost_and_found;
    BOOLEAN                     out_of_disk;
    CHAR                        buf[20];


    // Create the FOUND.XXX directory.

    for (i = 0; i < 1000; i++) {
        found_name->Flags = FILE_NAME_DOS | FILE_NAME_NTFS;
        found_name->ParentDirectory = RootFrs->QuerySegmentReference();
        found_name->FileName[0] = 'f';
        found_name->FileName[1] = 'o';
        found_name->FileName[2] = 'u';
        found_name->FileName[3] = 'n';
        found_name->FileName[4] = 'd';
        found_name->FileName[5] = '.';
        found_name->FileName[6] = USHORT(i/100 + '0');
        found_name->FileName[7] = USHORT((i/10)%10 + '0');
        found_name->FileName[8] = USHORT(i%10 + '0');
        found_name->FileNameLength = 9;

        found_name_size = NtfsFileNameGetLength(found_name);

        if (!RootIndex->QueryFileReference(found_name_size, found_name, 0,
                                           &ref, &error) && !error) {
            break;
        }
    }

    if (i == 1000) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
        return TRUE;
    }

    sprintf(buf, "found.%03d", i);
    if (!lost_and_found.Initialize(buf)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!CreateNtfsDirectory(RootIndex, RootFrs, &lost_and_found,
                             FAT_DIRENT_ATTR_HIDDEN | FAT_DIRENT_ATTR_SYSTEM,
                             &found_index, &found_directory, Mft, FixLevel,
                             Message, &out_of_disk)) {
        return FALSE;
    }

    if (out_of_disk) {
        return TRUE;
    }

    ChkdskReport->NumIndices += 1;

    // Record the parent pointer relationship of the orphans in a
    // digraph and then extract those parents who have more than
    // one child.

    if (!RecordParentPointers(Orphans, ChkdskInfo, Mft, &back_pointers) ||
        !back_pointers.QueryParentsWithChildren(&dir_candidates, 2)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Remove the root directory from consideration.  Since the
    // root directory exists any legitimate orphans should have
    // been properly recovered.  If a bunch point to the root
    // but couldn't be put into the root the just put them in
    // found.XXX, not a subdir thereof.

    dir_candidates.Remove(ROOT_FILE_NAME_INDEX_NUMBER);


    // Using the information just attained, put together some nice
    // found subdirectories for orphans with common parents.

    for (i = 0; i < dir_candidates.QueryCardinality(); i++) {

        dir_num = dir_candidates.QueryNumber(i).GetLowPart();

        if (!back_pointers.QueryChildren(dir_num, &orphans_in_dir) ||
            !Orphans->Remove(&orphans_in_dir)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!BuildOrphanSubDir(i, ChkdskInfo, ChkdskReport,
                               dir_num, &orphans_in_dir, Mft,
                               &found_index, &found_directory,
                               FixLevel, Message, &out_of_disk)) {
            return FALSE;
        }

        // Add back those orphans that were not recovered.

        if (!Orphans->Add(&orphans_in_dir)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (out_of_disk) {
            return TRUE;
        }
    }


    // Now go through all of the orphans that remain.

    for (next_dir_num = i, next_file_num = 0;
         Orphans->QueryCardinality() != 0 &&
         next_dir_num < 10000 && next_file_num < 10000;
         Orphans->Remove(file_number)) {

        file_number = Orphans->QueryNumber(0);

        if (!orphan_file.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.Read()) {
           continue;
        }

        if (!orphan_file.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel, Message)) {

            return FALSE;
        }

        // Delete all file name attributes on this file and set
        // the current reference count to 0.

        while (orphan_file.IsAttributePresent($FILE_NAME)) {
            if (!orphan_file.PurgeAttribute($FILE_NAME)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        orphan_file.SetReferenceCount(0);

        if (orphan_file.QueryFileNumber() >= FIRST_USER_FILE_NUMBER) {

            // Put a new file name attribute on the orphan in
            // order to link it to the found directory.

            orphan_file_name->ParentDirectory =
                    found_directory.QuerySegmentReference();
            orphan_file_name->Flags = FILE_NAME_DOS | FILE_NAME_NTFS;

            if (orphan_file.IsIndexPresent()) {
                orphan_file_name->FileName[0] = 'd';
                orphan_file_name->FileName[1] = 'i';
                orphan_file_name->FileName[2] = 'r';
                orphan_file_name->FileName[3] = USHORT(next_dir_num/1000 + '0');
                orphan_file_name->FileName[4] = USHORT((next_dir_num/100)%10 + '0');
                orphan_file_name->FileName[5] = USHORT((next_dir_num/10)%10 + '0');
                orphan_file_name->FileName[6] = USHORT(next_dir_num%10 + '0');
                orphan_file_name->FileName[7] = '.';
                orphan_file_name->FileName[8] = 'c';
                orphan_file_name->FileName[9] = 'h';
                orphan_file_name->FileName[10] = 'k';
                orphan_file_name->FileNameLength = 11;
                next_dir_num++;
            } else {
                orphan_file_name->FileName[0] = 'f';
                orphan_file_name->FileName[1] = 'i';
                orphan_file_name->FileName[2] = 'l';
                orphan_file_name->FileName[3] = 'e';
                orphan_file_name->FileName[4] = USHORT(next_file_num/1000 + '0');
                orphan_file_name->FileName[5] = USHORT((next_file_num/100)%10 + '0');
                orphan_file_name->FileName[6] = USHORT((next_file_num/10)%10 + '0');
                orphan_file_name->FileName[7] = USHORT(next_file_num%10 + '0');
                orphan_file_name->FileName[8] = '.';
                orphan_file_name->FileName[9] = 'c';
                orphan_file_name->FileName[10] = 'h';
                orphan_file_name->FileName[11] = 'k';
                orphan_file_name->FileNameLength = 12;
                next_file_num++;
            }

            if (!orphan_file.AddFileNameAttribute(orphan_file_name)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
                return TRUE;
            }

            if (FixLevel != CheckOnly &&
                !found_index.InsertEntry(
                        NtfsFileNameGetLength(orphan_file_name),
                        orphan_file_name,
                        orphan_file.QuerySegmentReference())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
                return TRUE;
            }
        }

        // Write out the newly found orphan.

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap(), &found_index)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
            return FALSE;
        }
    }


    if (next_dir_num == 10000 || next_file_num == 10000) {
        Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_ORPHANS);
    }


    // Flush out the found.

    if (FixLevel != CheckOnly) {

        NTFS_ATTRIBUTE  attrib;
        BOOLEAN         error;

        if (!found_index.Save(&found_directory) ||
            !found_directory.Flush(Mft->GetVolumeBitmap(), RootIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

            return TRUE;
        }

        if (found_directory.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           found_index.GetName())) {
            ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
ExtractExtendInfo(
    IN OUT  PNTFS_INDEX_TREE    Index,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine extracts the frs numbers for each of the corresponding
    files in the \$Extend directory.  It ignores file name that it does
    not recognize.

Arguments:

    Index       - Supplies the index to the $Extend directory.
    ChkdskInfo  - Supplies the current chkdsk information.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                     entry_name;
    PFILE_NAME                  file_name;
    DSTRING                     extend_filename;
    FSTRING                     expected_extend_filename;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;

    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {
        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);
        expected_extend_filename.Initialize(LQuotaFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->QuotaFileNumber.GetLowPart() ||
                ChkdskInfo->QuotaFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_QUOTA_FILE);
            } else {
                ChkdskInfo->QuotaFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LObjectIdFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->ObjectIdFileNumber.GetLowPart() ||
                ChkdskInfo->ObjectIdFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_OBJECTID_FILE);
            } else {
                ChkdskInfo->ObjectIdFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LUsnJournalFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->UsnJournalFileNumber.GetLowPart() ||
                ChkdskInfo->UsnJournalFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_USNJRNL_FILE);
            } else {
                ChkdskInfo->UsnJournalFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LReparseFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->ReparseFileNumber.GetLowPart() ||
                ChkdskInfo->ReparseFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_REPARSE_FILE);
            } else {
                ChkdskInfo->ReparseFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\largemcb.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LargeMcb.c

Abstract:

    The MCB routines provide support for maintaining an in-memory copy of
    the retrieval mapping information for a file.  The general idea is to
    have the file system lookup the retrieval mapping for a VBN once from
    the disk, add the mapping to the MCB structure, and then utilize the
    MCB to retrieve the mapping for subsequent accesses to the file.  A
    variable of type MCB is used to store the mapping information.

    The routines provided here allow the user to incrementally store some
    or all of the retrieval mapping for a file and to do so in any order.
    That is, the mapping can be inserted to the MCB structure all at once
    starting from the beginning and working to the end of the file, or it
    can be randomly scattered throughout the file.

    The package identifies each contiguous run of sectors mapping VBNs
    and LBNs indenpendent of the order they are added to the MCB
    structure.  For example a user can define a mapping between VBN
    sector 0 and LBN sector 107, and between VBN sector 2 and LBN sector
    109.  The mapping now contains two runs each one sector in length.
    Now if the user adds an additional mapping between VBN sector 1 and
    LBN sector 106 the MCB structure will contain only one run 3 sectors
    in length.

    Concurrent access to the MCB structure is control by this package.

    The following routines are provided by this package:

      o  FsRtlInitializeMcb - Initialize a new MCB structure.  There
         should be one MCB for every opened file.  Each MCB structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeMcb - Uninitialize an MCB structure.  This call
         is used to cleanup any anciallary structures allocated and
         maintained by the MCB.  After being uninitialized the MCB must
         again be initialized before it can be used by the system.

      o  FsRtlAddMcbEntry - This routine adds a new range of mappings
         between LBNs and VBNs to the MCB structure.

      o  FsRtlRemoveMcbEntry - This routines removes an existing range of
         mappings between LBNs and VBNs from the MCB structure.

      o  FsRtlLookupMcbEntry - This routine returns the LBN mapped to by
         a VBN, and indicates, in sectors, the length of the run.

      o  FsRtlLookupLastMcbEntry - This routine returns the mapping for
         the largest VBN stored in the structure.

      o  FsRtlNumberOfRunsInMcb - This routine tells the caller total
         number of discontiguous sectors runs stored in the MCB
         structure.

      o  FsRtlGetNextMcbEntry - This routine returns the the caller the
         starting VBN and LBN of a given run stored in the MCB structure.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


//
//  Retrieval mapping data structures.  The following two structure together
//  are used to map a Vbn to an Lbn.  It is layed out as follows:
//
//
//  MCB:
//      +----------------+----------------+
//      |    PairCount   |MaximumPairCount|
//      +----------------+----------------+
//      |     Mapping    |    PoolType    |
//      +----------------+----------------+
//
//
//  MAPPING:
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : 0
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : PairCount
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     |
//      +----------------+----------------+
//
//                                          : MaximumPairCount
//
//  The pairs from 0 to PairCount - 1 are valid.  Given an index between
//  0 and PairCount - 1 (inclusive) it represents the following Vbn
//  to Lbn mapping information
//
//
//                     { if Index == 0 then 0
//      StartingVbn   {
//                     { if Index <> 0 then NextVbn[i-1]
//
//
//      EndingVbn      = NextVbn[i] - 1
//
//
//      StartingLbn    = Lbn[i]
//
//
//  To compute the mapping of a Vbn to an Lbn the following algorithm
//  is used
//
//      1. search through the pairs until we find the slot "i" that contains
//         the Vbn we after.  Report an error if none if found.
//
//      2. Lbn = StartingLbn + (Vbn - StartingVbn);
//
//  A hole in the allocation (i.e., a sparse allocation) is represented by
//  an Lbn value of -1 (note that is is different than Mcb.c).
//

#define UNUSED_LBN                       ((LBN64)-1)

typedef struct _MAPPING {
    VBN     NextVbn;
    LBN64   Lbn;
} MAPPING;
typedef MAPPING *PMAPPING;

typedef struct _NONOPAQUE_MCB {
    PFAST_MUTEX FastMutex;
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PMAPPING Mapping;
} NONOPAQUE_MCB;
typedef NONOPAQUE_MCB *PNONOPAQUE_MCB;

C_ASSERT(sizeof(LARGE_MCB) >= sizeof(NONOPAQUE_MCB));

//
//  A macro to return the size, in bytes, of a retrieval mapping structure
//

#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)->MaximumPairCount))

//
//  The parts of a run can be computed as follows:
//
//
//                StartingVbn(MCB,I)           Mapping[I].NextVbn
//                       |                             |
//                       V                             V
//
//        Run-(I-1)---+ +---------Run-(I)-----------+ +---Run-(I+1)
//
//                       A                         A
//                       |                         |
//                 Mapping[I].Lbn            EndingLbn(MCB,I)
//

#define PreviousEndingVbn(MCB,I) (                      \
    (VBN)((I) == 0 ? 0xffffffff : EndingVbn(MCB,(I)-1)) \
)

#define StartingVbn(MCB,I) (                                \
    (VBN)((I) == 0 ? 0 : (((MCB)->Mapping))[(I)-1].NextVbn) \
)

#define EndingVbn(MCB,I) (                     \
    (VBN)((((MCB)->Mapping)[(I)].NextVbn) - 1) \
)

#define NextStartingVbn(MCB,I) (                                \
    (VBN)((I) >= (MCB)->PairCount ? 0 : StartingVbn(MCB,(I)+1)) \
)




#define PreviousEndingLbn(MCB,I) (                      \
    ((I) == 0 ? UNUSED_LBN : EndingLbn(MCB,(I)-1)) \
)

#define StartingLbn(MCB,I) (         \
    (((MCB)->Mapping)[(I)].Lbn) \
)

#define EndingLbn(MCB,I) (                                       \
    (StartingLbn(MCB,I) == UNUSED_LBN ?                     \
          UNUSED_LBN :                                           \
          ((MCB)->Mapping[(I)].Lbn +                             \
           (MCB)->Mapping[(I)].NextVbn - StartingVbn(MCB,I) - 1) \
         )                                                       \
)

#define NextStartingLbn(MCB,I) (                                             \
    ((I) >= (MCB)->PairCount - 1 ? UNUSED_LBN : StartingLbn(MCB,(I)+1)) \
)

#if 0
LBN
NextStartingLbn(
    PNONOPAQUE_MCB Mcb,
    ULONG I
    )
{
    if ( I >= Mcb->PairCount - 1 ) {
        return (LBN)UNUSED_LBN;
        }
    else {
        return StartingLbn(Mcb,I+1);
        }
}
#endif

#define SectorsWithinRun(MCB,I) (                      \
    (ULONG)(EndingVbn(MCB,I) - StartingVbn(MCB,I) + 1) \
)

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB OpaqueMcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    );

//
//  A private routine to search a mapping structure for a Vbn
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PNONOPAQUE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    );

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    );

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    );

//
//  Some private routines to handle common allocations.
//

PVOID
FsRtlAllocateFirstMapping (
    );

VOID
FsRtlFreeFirstMapping (
    IN PVOID Mapping
    );

PFAST_MUTEX
FsRtlAllocateFastMutex (
    );

VOID
FsRtlFreeFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlInitializeMcb)
#pragma alloc_text(PAGE, FsRtlUninitializeMcb)
#endif


//
//  Define a small cache of free mapping pairs structures and also the
//  initial size of the mapping pair
//

#define INITIAL_MAXIMUM_PAIR_COUNT       (15)

//
//  Some globals used with the first mapping allocation
//

#define FREE_FIRST_MAPPING_ARRAY_SIZE    (16)

PVOID FsRtlFreeFirstMappingArray[FREE_FIRST_MAPPING_ARRAY_SIZE];

UCHAR FsRtlFreeFirstMappingSize = 0;

ULONG FsRtlNetFirstMapping = 0;

//
//  Some globals used with the FastMutex allocation
//

#define FREE_FAST_MUTEX_ARRAY_SIZE      (16)

PFAST_MUTEX FsRtlFreeFastMutexArray[FREE_FAST_MUTEX_ARRAY_SIZE];

UCHAR FsRtlFreeFastMutexSize = 0;

ULONG FsRtlNetFastMutex = 0;

#if 0

//
//  The following few routines define the small mcb package which is
//  implemented behind everyones back as large mcbs.  The only funny
//  thing we really need to do here is to make sure that unused Lbns
//  get returned as 0 and not -1.  This is the result of an historical
//  difference between the original Mcb and LargeMcb packages.
//

VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    )
{
    PAGED_CODE();

    FsRtlInitializeLargeMcb( (PLARGE_MCB)Mcb,
                             PoolType );

    return;
}

VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    FsRtlUninitializeLargeMcb( (PLARGE_MCB)Mcb );

    return;
}

VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    )
{
   PAGED_CODE();

   FsRtlTruncateLargeMcb( (PLARGE_MCB)Mcb,
                          (LONGLONG)(Vbn) );

   return;
}

BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    )

{
    PAGED_CODE();

    return FsRtlAddLargeMcbEntry( (PLARGE_MCB)Mcb,
                                  (LONGLONG)(Vbn),
                                  (LONGLONG)(Lbn),
                                  (LONGLONG)(SectorCount) );
}

VOID
FsRtlRemoveMcbEntry (
    IN PMCB OpaqueMcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    )

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlRemoveMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb,
                                    Vbn,
                                    SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveMcbEntry -> VOID\n", 0 );
    }

    return;
}

BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

{
    BOOLEAN Results;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    Results = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));

    if (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }

    return Results;
}

BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    )

{
    BOOLEAN Results;
    LONGLONG LiVbn;
    LONGLONG LiLbn;

    PAGED_CODE();

    Results = FsRtlLookupLastLargeMcbEntry( (PLARGE_MCB)Mcb,
                                            &LiVbn,
                                            &LiLbn );

    *Vbn = ((ULONG)LiVbn);
    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));

    return Results;
}

ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    return FsRtlNumberOfRunsInLargeMcb( (PLARGE_MCB)Mcb );
}

BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    )

{
    BOOLEAN Results;
    LONGLONG LiVbn;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    PAGED_CODE();

    Results = FsRtlGetNextLargeMcbEntry( (PLARGE_MCB)Mcb,
                                         RunIndex,
                                         &LiVbn,
                                         &LiLbn,
                                         &LiSectorCount );

    *Vbn = ((ULONG)LiVbn);
    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
    *SectorCount = ((ULONG)LiSectorCount);

    return Results;
}
#endif


VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Mcb structure.  The caller must
    supply the memory for the Mcb structure.  This call must precede all
    other calls that set/query the Mcb structure.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal Mcb memory.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlInitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Preset the following fields to null so we know to deallocate them
    //  during an abnormal termination
    //

    Mcb->FastMutex = NULL;
    Mcb->Mapping = NULL;

    try {

        //
        //  Initialize the fields in the Mcb
        //

        Mcb->FastMutex = FsRtlAllocateFastMutex();

        ExInitializeFastMutex( Mcb->FastMutex );

        Mcb->PairCount = 0;
        Mcb->PoolType = PoolType;

        //
        //  Allocate a new buffer an initial size is one that will hold
        //  16 runs
        //

        if (PoolType == PagedPool) {

            Mcb->Mapping = FsRtlAllocateFirstMapping();

        } else {

            Mcb->Mapping = FsRtlAllocatePool( Mcb->PoolType, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
        }

        //**** RtlZeroMemory( Mcb->Mapping, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );

        Mcb->MaximumPairCount = INITIAL_MAXIMUM_PAIR_COUNT;

    } finally {

        //
        //  If this is an abnormal termination then we need to deallocate
        //  the FastMutex and/or mapping.
        //

        if (AbnormalTermination()) {

            if (Mcb->FastMutex != NULL) { FsRtlFreeFastMutex( Mcb->FastMutex ); }
        }

        DebugTrace(-1, Dbg, "FsRtlInitializeLargeMcb -> VOID\n", 0 );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine uninitializes an Mcb structure.  After calling this routine
    the input Mcb structure must be re-initialized before being used again.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to uninitialize.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlUninitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Protect against some user calling us to uninitialize an mcb twice
    //

    if (Mcb->FastMutex == NULL) {

        ASSERTMSG("Being called to uninitialize an Mcb that is already Uninitialized ", FALSE);

        return;
    }

    //
    //  Deallocate the FastMutex and mapping buffer
    //

    FsRtlFreeFastMutex( Mcb->FastMutex );

    Mcb->FastMutex = NULL;

    if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

        FsRtlFreeFirstMapping( Mcb->Mapping );

    } else {

        ExFreePool( Mcb->Mapping );
    }

    //
    //  Now zero our all of the fields in the Mcb
    //

    //**** Mcb->MaximumPairCount = 0;
    //**** Mcb->PairCount = 0;
    //**** Mcb->Mapping = NULL;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlUninitializeLargeMcb -> VOID\n", 0 );

    return;
}


VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to the specified Vbn.
    After calling this routine the Mcb will only contain mappings
    up to and not including the input vbn.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    LargeVbn - Specifies the last Vbn at which is no longer to be
      mapped.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                 ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                  (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlTruncateLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Do a quick test to see if we are truncating the entire Mcb.
        //

        if (Vbn == 0) {

            Mcb->PairCount = 0;

        } else if (Mcb->PairCount > 0) {

            //
            //  Now if the pair count is greater than zero then we will
            //  call the remove mcb entry routine to actually do the truncation
            //  for us.
            //

            FsRtlRemoveMcbEntryPrivate( Mcb, Vbn, 0xffffffff - Vbn );
        }

        //
        //  Now see if we can shrink the allocation for the mapping pairs.
        //  We'll shrink the mapping pair buffer if the new pair count will
        //  fit within a quarter of the current maximum pair count and the
        //  current maximum is greater than the initial pair count.
        //

        if ((Mcb->PairCount < (Mcb->MaximumPairCount / 4)) &&
            (Mcb->MaximumPairCount > INITIAL_MAXIMUM_PAIR_COUNT)) {

            ULONG NewMax;
            PMAPPING Mapping;

            //
            //  We need to allocate a new mapping so compute a new maximum pair
            //  count.  We'll allocate double the current pair count, but never
            //  less than the initial pair count.
            //

            NewMax = Mcb->PairCount * 2;
            if (NewMax < INITIAL_MAXIMUM_PAIR_COUNT) { NewMax = INITIAL_MAXIMUM_PAIR_COUNT; }

            Mapping = ExAllocatePool( Mcb->PoolType, sizeof(MAPPING) * NewMax );

            //
            //  Now check if we really got a new buffer
            //

            if (Mapping != NULL) {

                //
                //  Now copy over the old mapping to the new buffer
                //

                RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

                //
                //  Deallocate the old buffer
                //

                ExFreePool( Mcb->Mapping );

                //
                //  And set up the new buffer in the Mcb
                //

                Mcb->Mapping = Mapping;
                Mcb->MaximumPairCount = NewMax;
            }
        }

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlTruncateLargeMcb -> VOID\n", 0 );

    return;
}


BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeLbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine is used to add a new mapping of VBNs to LBNs to an existing
    Mcb. The information added will map

        Vbn to Lbn,

        Vbn+1 to Lbn+1,...

        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).

    The mapping for the VBNs must not already exist in the Mcb.  If the
    mapping continues a previous run, then this routine will actually coalesce
    them into 1 run.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

    An input Lbn value of zero is illegal (i.e., the Mcb structure will never
    map a Vbn to a zero Lbn value).

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.

    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.

    SectorCount - Supplies the size of the new mapping run (in sectors).

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new
        Vbns did not collide with existing Vbns), and FALSE otherwise.  If
        FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    LBN64 Lbn = (LargeLbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    ULONG Index;

    VBN LastVbn;

    BOOLEAN Result;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeSectorCount)->HighPart == 0);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlAddLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Lbn         = %I64x\n", Lbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        if (FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            ULONG EndVbn = Vbn + SectorCount - 1;
            ULONG EndIndex;

            //
            //  First check the case where we are adding to an existing mcb run
            //  and if so then we will modify the insertion to complete the run
            //
            //      --ExistingRun--|      ==becomes==>  --ExistingRun--|
            //              |--NewRun--|                               |---|
            //
            //      --ExistingRun----|    ==becomes==> a noop
            //          |--NewRun--|
            //

            if (StartingLbn(Mcb, Index) != UNUSED_LBN) {

                //
                //  Assert that the Lbn's line up between the new and existing run
                //

                ASSERT(Lbn == (StartingLbn(Mcb, Index) + (Vbn - StartingVbn(Mcb, Index))));

                //
                //  Check if the new run is contained in the existing run
                //

                if (EndVbn <= EndingVbn(Mcb, Index)) {

                    //
                    //  Do nothing because the run is contained within the existing run
                    //

                    try_return(Result = TRUE);
                }

                //
                //  Otherwise we will simply trim off the request for the new run
                //  to not overlap with the existing run
                //

                Vbn = NextStartingVbn(Mcb, Index);
                Lbn = EndingLbn(Mcb, Index) + 1;

                ASSERT(EndVbn >= Vbn);

                SectorCount = EndVbn - Vbn + 1;

            //
            //  At this point the new run start in a hole, now check that if
            //  crosses into a non hole and if so then adjust new run to fit
            //  in the hole
            //
            //
            //            |--ExistingRun--  ==becomes==>        |--ExistingRun--
            //      |--NewRun--|                          |--New|
            //

            } else if (FsRtlFindLargeIndex(Mcb, EndVbn, &EndIndex) && (Index == (EndIndex-1))) {

                //
                //  Assert that the Lbn's line up in the overlap
                //

                ASSERT( StartingLbn(Mcb, EndIndex) == Lbn + (StartingVbn(Mcb, EndIndex) - Vbn) );

                //
                //  Truncate the sector count to go up to but not include
                //  the existing run
                //

                SectorCount = StartingVbn(Mcb, EndIndex) - Vbn;
            }
        }

        //
        //  Find the index for the starting Vbn of our new run, if there isn't
        //  a hole found then index will be set to paircount.
        //

        if (((Index = Mcb->PairCount) == 0) ||
            (PreviousEndingVbn(Mcb,Index)+1 <= Vbn) ||
            !FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            //
            //  We didn't find a mapping, therefore this new mapping must
            //  go on at the end of the current mapping.
            //
            //  See if we can just grow the last mapping in the current mcb.
            //  We can grow the last entry if (1) the Vbns follow on, and (2)
            //  the Lbns follow on.  We can only grow the last mapping if the
            //  index is not 0.
            //

            if ((Index != 0) &&
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn) &&
                (PreviousEndingLbn(Mcb,Index) + 1 == Lbn)) {

                //
                //      --LastRun--|---NewRun--|
                //

                //
                //  Extend the last run in the mcb
                //

                DebugTrace( 0, Dbg, "Continuing last run\n", 0);

                (Mcb->Mapping)[Mcb->PairCount-1].NextVbn += SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  We couldn't grow the last mapping, now check to see if
            //  this is a continuation of the last Vbn (i.e., there isn't
            //  going to be a hole in the mapping).  Or if this is the first
            //  run in the mapping
            //

            if ((Vbn == 0) ||
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn)) {

                //
                //      --LastRun--||---NewRun--|
                //
                //      0:|--NewRun--|
                //

                //
                //  We only need to add one more run to the mcb, so make sure
                //  there is enough room for one.
                //

                DebugTrace( 0, Dbg, "Adding new contiguous last run\n", 0);

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index].Lbn = Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  If we reach this point then there is going to be a hole in the
            //  mapping. and the mapping gets appended to the end of the current
            //  allocation.  So need to make room for two more runs in the mcb.
            //

            //
            //      --LastRun--|   hole   |---NewRun--|
            //
            //      0:  hole  |--NewRun--|
            //

            DebugTrace( 0, Dbg, "Adding new noncontiguous last run\n", 0);

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            //
            //  Add the hole
            //

            (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            //
            //  Add the new mapping
            //

            (Mcb->Mapping)[Index+1].Lbn = Lbn;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

            try_return (Result = TRUE);
        }

        //
        //  We found an index for the Vbn therefore we must be trying
        //  to fill up a hole in the mcb.  So first we need to check to make
        //  sure there really is a hole to be filled
        //

        LastVbn = Vbn + SectorCount - 1;

        if ((StartingLbn(Mcb,Index) == UNUSED_LBN) &&
            (StartingVbn(Mcb,Index) <= Vbn) && (LastVbn <= EndingVbn(Mcb,Index))) {

            //
            //  The mapping fits in this hole, but now here are the following
            //  cases we must consider for the new mapping
            //

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                //  Leaves a hole are both ends
                //
                //  --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--
                //
                //  0:  hole  |--NewRun--|  hole  |--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at both ends\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Add the first hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  The second hole is already set up by the add entry call, because
                //  that call just shift over the original hole to that slot
                //

                try_return (Result = TRUE);
            }

            if ((StartingVbn(Mcb,Index) == Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                    //
                    //  Leaves a hole at the rear, and continues the earlier run
                    //
                    //  --PreviousRun--|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and continue\n", 0);

                    //
                    //  We just need to extend the previous run
                    //

                    (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the rear, and does not continue the
                    //  earlier run.  As occurs if index is zero.
                    //
                    //  --PreviousRun--||--NewRun--|  hole  |--FollowingRun--
                    //
                    //  0:|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index].Lbn = Lbn;
                    (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                    //
                    //  The hole is already set up by the add entry call, because
                    //  that call just shift over the original hole to that slot
                    //

                    try_return (Result = TRUE);
                }
            }

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn == EndingVbn(Mcb,Index))) {

                if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                    //
                    //  Leaves a hole at the front, and continues the following run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--|--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--|--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and continue\n", 0);

                    //
                    //  We just need to extend the following run
                    //

                    (Mcb->Mapping)[Index].NextVbn = Vbn;
                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the front, and does not continue the following
                    //  run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--||--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--||--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the hole
                    //

                    (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                    (Mcb->Mapping)[Index].NextVbn = Vbn;

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);
                }

            }

            if ((PreviousEndingLbn(Mcb,Index) + 1 == Lbn) &&
                (NextStartingLbn(Mcb,Index) == Lbn + SectorCount)) {

                //
                //  Leaves no holes, and continues both runs
                //
                //  --PreviousRun--|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues both runs\n", 0);

                //
                //  We need to collapse the current index and the following index
                //  but first we copy the NextVbn of the follwing run into
                //  the NextVbn field of the previous run to so it all becomes
                //  one run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index+1].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 2 );

                try_return (Result = TRUE);
            }

            if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                //
                //  Leaves no holes, and continues only following run
                //
                //  --PreviousRun--||--NewRun--|--FollowingRun--
                //
                //  0:|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues following\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  following run to meet up with the previous run
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                //
                //  Leaves no holes, and continues only earlier run
                //
                //  --PreviousRun--|--NewRun--||--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues earlier\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  previous run to meet up with the following run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            //
            //  Leaves no holes, and continues neither run
            //
            //      --PreviousRun--||--NewRun--||--FollowingRun--
            //
            //      0:|--NewRun--||--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues none\n", 0);

            (Mcb->Mapping)[Index].Lbn = Lbn;

            try_return (Result = TRUE);
        }

        //
        //  We tried to overwrite an existing mapping so we'll have to
        //  tell our caller that it's not possible
        //

        Result = FALSE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlAddLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine removes a mapping of VBNs to LBNs from an Mcb.  The mappings
    removed are for

        Vbn,

        Vbn+1, to

        Vbn+(SectorCount-1).

    The operation works even if the mapping for a Vbn in the specified range
    does not already exist in the Mcb.  If the specified range of Vbn includes
    the last mapped Vbn in the Mcb then the Mcb mapping shrinks accordingly.

    If pool is not available to store the information this routine will raise
    a status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    PAGED_CODE();

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);

    DebugTrace(+1, Dbg, "FsRtlRemoveLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb, Vbn, SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveLargeMcbEntry -> VOID\n", 0 );
    }

    return;
}


BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn OPTIONAL,
    OUT PLONGLONG LargeSectorCount OPTIONAL,
    OUT PLONGLONG LargeStartingLbn OPTIONAL,
    OUT PLONGLONG LargeCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (even if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    ULONG LocalIndex;

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                 ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                  (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    DebugTrace(+1, Dbg, "FsRtlLookupLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, "  LargeVbn.LowPart = %08lx\n", LargeVbn.LowPart );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        if (!FsRtlFindLargeIndex(Mcb, ((ULONG)LargeVbn), &LocalIndex)) {

            try_return (Result = FALSE);
        }

        //
        //  Compute the lbn for corresponding to the vbn, the value is the
        //  starting lbn of the run plus the number of sectors offset into the
        //  run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *(LargeLbn) = UNUSED_LBN;

            } else {

                *(LargeLbn) = StartingLbn(Mcb,LocalIndex) + (((ULONG)LargeVbn) - StartingVbn(Mcb,LocalIndex));
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors remaing in the run.
        //

        if (ARGUMENT_PRESENT(LargeSectorCount)) {

            *((PULONG)LargeSectorCount) = EndingVbn(Mcb,LocalIndex) - ((ULONG)LargeVbn) + 1;
        }

        //
        //  Compute the starting lbn for corresponding to the start of the run, the value is the
        //  starting lbn of the run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeStartingLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *(LargeStartingLbn) = UNUSED_LBN;

            } else {

                *(LargeStartingLbn) = StartingLbn(Mcb,LocalIndex);
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors in the run.
        //

        if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {

            *((PULONG)LargeCountFromStartingLbn) = EndingVbn(Mcb,LocalIndex) - StartingVbn(Mcb,LocalIndex) + 1;
        }

        //
        //  If the caller want to know the Index number, fill it in.
        //

        if (ARGUMENT_PRESENT(Index)) {

            *Index = LocalIndex;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLargeMcbEntry -> %08lx\n", Result );
    }

    if (ARGUMENT_PRESENT(LargeSectorCount)) {
        ((PLARGE_INTEGER)LargeSectorCount)->HighPart = 0;
    }

    if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {
        ((PLARGE_INTEGER)LargeCountFromStartingLbn)->HighPart = 0;
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntry, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Check to make sure there is at least one run in the mcb
        //

        if (Mcb->PairCount <= 0) {

            try_return (Result = FALSE);
        }

        //
        //  Return the last mapping of the last run
        //

        *(LargeLbn) = EndingLbn(Mcb,Mcb->PairCount-1);
        *((PULONG)LargeVbn) = EndingVbn(Mcb,Mcb->PairCount-1);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntry -> %08lx\n", Result );
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == 0xffffffff ? 0xffffffff : 0);

    return Result;
}


ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine returns to the its caller the number of distinct runs
    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted
    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3
    will have 3 runs, one for the first mapped sector, a second for the
    hole covering Vbns 1 and 2, and a third for Vbn 3.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

Return Value:

    ULONG - Returns the number of distinct runs mapped by the input Mcb.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    ULONG Count;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlNumberOfRunsInLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    Count = Mcb->PairCount;

    ExReleaseFastMutex( Mcb->FastMutex );

    DebugTrace(-1, Dbg, "FsRtlNumberOfRunsInLargeMcb -> %08lx\n", Count );

    return Count;
}


BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN ULONG RunIndex,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn,
    OUT PLONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine returns to its caller the Vbn, Lbn, and SectorCount for
    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,
    to construct to print out all of the runs in a a file is:

//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&Vbn,&Lbn,&Count); i++) {
//
//. .       // print out vbn, lbn, and count
//
//. .       }

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    RunIndex - Supplies the index of the run (zero based) to return to the
        caller.

    Vbn - Receives the starting Vbn of the returned run, or zero if the
        run does not exist.

    Lbn - Recieves the starting Lbn of the returned run, or zero if the
        run does not exist.

    SectorCount - Receives the number of sectors within the returned run,
        or zero if the run does not exist.

Return Value:

    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,
        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and
        SectorCount parameters receive zero.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " RunIndex = %08lx\n", RunIndex );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Make sure the run index is within range
        //

        if (RunIndex >= Mcb->PairCount) {

            try_return (Result = FALSE);
        }

        //
        //  Set the return variables
        //

        *((PULONG)LargeVbn) = StartingVbn(Mcb,RunIndex);
        *(LargeLbn) = StartingLbn(Mcb,RunIndex);
        *((PULONG)LargeSectorCount) = SectorsWithinRun(Mcb,RunIndex);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlGetNextLargeMcbEntry -> %08lx\n", Result );
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == 0xffffffff ? 0xffffffff : 0);
    ((PLARGE_INTEGER)LargeSectorCount)->HighPart = 0;

    return Result;
}


BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeAmount
    )

/*++

Routine Description:

    This routine is used to create a hole within an MCB, by shifting the
    mapping of Vbns.  All mappings above the input vbn are shifted by the
    amount specified and while keeping their current lbn value.  Pictorially
    we have as input the following MCB

        VBN :       LargeVbn-1 LargeVbn         N
            +-----------------+------------------+
        LBN :             X        Y

    And after the split we have

        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount
            +-----------------+.............+---------------------------+
        LBN :             X      UnusedLbn       Y

    When doing the split we have a few cases to consider.  They are:

    1. The input Vbn is beyond the last run.  In this case this operation
       is a noop.

    2. The input Vbn is within or adjacent to a existing run of unused Lbns.
       In this case we simply need to extend the size of the existing hole
       and shift succeeding runs.

    3. The input Vbn is between two existing runs, including the an input vbn
       value of zero.  In this case we need to add a new entry for the hole
       and shift succeeding runs.

    4. The input Vbn is within an existing run.  In this case we need to add
       two new entries to contain the split run and the hole.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn that is to be shifted.

    Amount - Supplies the amount to shift by.

Return Value:

    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.
        If FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Amount = ((ULONG)LargeAmount);

    ULONG Index;

    BOOLEAN Result;

    ULONG i;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeAmount)->HighPart == 0);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlSplitLargeMcb, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn    = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Amount = %08lx\n", Amount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  First lookup the index for the entry that we are going to split.
        //  If we can't find the entry then there is nothing to split.  This
        //  takes care of the case where the input vbn is beyond the last run
        //  in the mcb
        //

        if (!FsRtlFindLargeIndex( Mcb, Vbn, &Index)) {

            try_return(Result = FALSE);
        }

        //
        //  Now check if the input Vbn is within a hole
        //

        if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

            //
            //  Before: --PreviousRun--||--IndexHole--||--FollowingRun--
            //  After:  --PreviousRun--||----IndexHole----||--FollowingRun--
            //
            //      In this case the vbn is somewhere within the hole and we
            //      simply need to added the amount of each existing run
            //      beyond the hole.
            //

            //
            //  In this case there is really nothing to do here because the
            //  ending code will already shift the runs by proper amount
            //  starting at index
            //

            NOTHING;

        //
        //  Now check if the input vbn is between a hole and an existing run.
        //

        } else if ((StartingVbn(Mcb,Index) == Vbn) && (Index != 0) && (PreviousEndingLbn(Mcb,Index) == UNUSED_LBN)) {

            //
            //  Before: --Hole--||--IndexRun--
            //  After:  --Hole------||--IndexRun--
            //
            //      In this case the vbn points to the start of the existing
            //      run and we need to do the split between the hole and the
            //      existing run by simply adding the amount to each existing
            //      run beyond the hole.
            //

            //
            //  In this case we need to decement the index by 1 and then
            //  fall to the bottom code which will do the shifting for us
            //

            Index -= 1;

        //
        //  Now check if the input vbn is between two existing runs
        //

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Before: --PreviousRun--||--IndexRun--
            //  After:  --PreviousRun--||--NewHole--||--IndexRun--
            //
            //  Before: 0:|--IndexRun--
            //  After:  0:|--NewHole--||--IndexRun--
            //
            //      In this case the vbn points to the start of an existing
            //      run and the preceeding is either a real run or the start
            //      of mapping pairs We simply add a new entry for the hole
            //      and shift succeeding runs.
            //

            FsRtlAddLargeEntry( Mcb, Index, 1 );

            (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn + Amount;

            Index += 1;

        //
        //  Otherwise the input vbn is inside an existing run
        //

        } else {

            //
            //  Before: --IndexRun--
            //  After:  --SplitRun--||--NewHole--||--SplitRun--
            //
            //      In this case the vbn points within an existing run
            //      we need to add two new extries for hole and split
            //      run and shift succeeding runs
            //

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + Amount;

            (Mcb->Mapping)[Index+2].Lbn = (Mcb->Mapping)[Index+2].Lbn +
                                          StartingVbn(Mcb, Index+1) -
                                          StartingVbn(Mcb, Index);

            Index += 2;

        }

        //
        //  At this point we have completed most of the work we now need to
        //  shift existing runs from the index to the end of the mappings
        //  by the specified amount
        //

        for (i = Index; i < Mcb->PairCount; i += 1) {

            (Mcb->Mapping)[i].NextVbn += Amount;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlSplitLargeMcb -> %08lx\n", Result );
    }

    return Result;
}


//
//  Private support routine
//

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    )

/*++

Routine Description:

    This is the work routine for remove large mcb entry.  It does the work
    without taking out the mcb FastMutex.

Arguments:

    Mcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    ULONG Index;

    PAGED_CODE();

    //
    //  Do a quick test to see if we are wiping out the entire MCB.
    //

    if ((Vbn == 0) && (Mcb->PairCount > 0) && (SectorCount >= Mcb->Mapping[Mcb->PairCount-1].NextVbn)) {

        Mcb->PairCount = 0;

        return;
    }

    //
    //  While there is some more mapping to remove we'll continue
    //  with our main loop
    //

    while (SectorCount > 0) {

        //
        //  Locate the mapping for the vbn
        //

        if (!FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            DebugTrace( 0, Dbg, "FsRtlRemoveLargeMcbEntry, Cannot remove an unmapped Vbn = %08lx\n", Vbn );

            return;
        }

        //
        //  Now that we some something to remove the following cases must
        //  be considered
        //

        if ((StartingVbn(Mcb,Index) == Vbn) &&
            (EndingVbn(Mcb,Index) < Vbn + SectorCount)) {

            ULONG i;

            //
            //  Removes the entire run
            //

            //
            //  Update the amount to remove
            //

            i = SectorsWithinRun(Mcb,Index);
            Vbn += i;
            SectorCount -= i;

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            //
            //  Test for last run
            //

            } else if (Index == Mcb->PairCount - 1) {

                if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) ||
                    (Index == 0)) {

                    //
                    //  Previous is not hole, index is last run
                    //
                    //  --Previous--|  Hole
                    //
                    //  0:  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous not hole, index is last run\n", 0);

                    //
                    //  Just remove this entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index, 1);

                } else {

                    //
                    //  Previous is hole, index is last run
                    //
                    //  --Hole--|  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous hole, index is last run\n", 0);

                    //
                    //  Just remove this entry, and preceding entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index-1, 2);
                }

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous and following are not holes
                //
                //  --Previous--|  Hole  |--Following--
                //
                //  0:  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & Following not holes\n", 0);

                //
                //  Make this index a hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) == UNUSED_LBN)) {

                //
                //  Following is hole
                //
                //  --Previous--|  Hole  |--Hole--
                //
                //  0:  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Following is hole\n", 0);

                //
                //  Simply remove this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            } else if ((PreviousEndingLbn(Mcb,Index) == UNUSED_LBN) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous is hole\n", 0);

                //
                //  Mark current entry a hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;

                //
                //  Remove previous entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 1 );

            } else {

                //
                //  Previous and following are holes
                //
                //  --Hole--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & following are holes\n", 0);

                //
                //  Remove previous and this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 2 );
            }

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Removes first part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) {

                //
                //  Previous is not hole
                //
                //  --Previous--|  Hole  |--Index--||--Following--
                //
                //  0:  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Set the hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index+1].Lbn += SectorCount;

            } else {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is hole\n", 0);

                //
                //  Expand the preceding hole
                //

                (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index].Lbn += SectorCount;
            }

            //
            //  Update the amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;

        } else if (EndingVbn(Mcb,Index) < Vbn + SectorCount) {

            ULONG AmountToRemove;

            AmountToRemove = EndingVbn(Mcb,Index) - Vbn + 1;

            //
            //  Removes last part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if (Index == Mcb->PairCount - 1) {

                //
                //  Index is last run
                //
                //  --Previous--||--Index--|  Hole
                //
                //  0:|--Index--|  Hole
                //

                DebugTrace( 0, Dbg, "last part, Index is last run\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else if (NextStartingLbn(Mcb,Index) == UNUSED_LBN) {

                //
                //  Following is hole
                //
                //  --Previous--||--Index--|  Hole  |--Hole--
                //
                //  0:|--Index--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "last part, Following is hole\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else {

                //
                //  Following is not hole
                //
                //  --Previous--||--Index--|  Hole  |--Following--
                //
                //
                //  0:|--Index--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "last part, Following is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index+1, 1 );

                //
                //  Set the new hole
                //

                (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;
            }

            //
            //  Update amount to remove
            //

            Vbn += AmountToRemove;
            SectorCount -= AmountToRemove;

        } else {

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else {

                //
                //  Remove middle of run
                //
                //  --Previous--||--Index--|  Hole  |--Index--||--Following--
                //
                //  0:|--Index--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "Middle of run\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Set up the first remaining run
                //

                (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Set up the hole
                //

                (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  Set up the second remaining run
                //

                (Mcb->Mapping)[Index+2].Lbn += SectorsWithinRun(Mcb,Index) +
                                               SectorsWithinRun(Mcb,Index+1);
            }

            //
            //  Update amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;
        }
    }

    return;
}


//
//  Private routine
//

BOOLEAN
FsRtlFindLargeIndex (
    IN  PNONOPAQUE_MCB Mcb,
    IN  VBN Vbn,
    OUT PULONG Index
    )

/*++

Routine Description:

    This is a private routine that locates a mapping for a Vbn
    in a given mapping array

Arguments:

    Mcb - Supplies the mapping array to examine

    Vbn - Supplies the Vbn to look up

    Index - Receives the index within the mapping array of the mapping
        containing the Vbn.  If none if found then the index is set to
        PairCount.

Return Value:

    BOOLEAN - TRUE if Vbn is found and FALSE otherwise

--*/

{
    LONG MinIndex;
    LONG MaxIndex;
    LONG MidIndex;

    //
    //  We'll just do a binary search for the mapping entry.  Min and max
    //  are our search boundaries
    //

    MinIndex = 0;
    MaxIndex = Mcb->PairCount - 1;

    while (MinIndex <= MaxIndex) {

        //
        //  Compute the middle index to look at
        //

        MidIndex = ((MaxIndex + MinIndex) / 2);

        //
        //  check if the Vbn is less than the mapping at the mid index
        //

        if (Vbn < StartingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is less than the middle index so we need to drop
            //  the max down
            //

            MaxIndex = MidIndex - 1;

        //
        //  check if the Vbn is greater than the mapping at the mid index
        //

        } else if (Vbn > EndingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is greater than the middle index so we need to bring
            //  up the min
            //

            MinIndex = MidIndex + 1;

        //
        //  Otherwise we've found the index containing the Vbn so set the
        //  index and return TRUE.
        //

        } else {

            *Index = MidIndex;

            return TRUE;
        }
    }

    //
    //  A match wasn't found so set index to PairCount and return FALSE
    //

    *Index = Mcb->PairCount;

    return FALSE;
}


//
//  Private Routine
//

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    )

/*++

Routine Description:

    This routine takes a current Mcb and detemines if there is enough
    room to add the new mapping entries.  If there is not enough room
    it reallocates a new mcb buffer and copies over the current mapping.
    If also will spread out the current mappings to leave the specified
    index slots in the mapping unfilled.  For example, if WhereToAddIndex
    is equal to the current pair count then we don't need to make a hole
    in the mapping, but if the index is less than the current pair count
    then we'll need to slide some of the mappings down to make room
    at the specified index.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToAddIndex - Supplies the index of where the additional entries
        need to be made

    AmountToAdd - Supplies the number of additional entries needed in the
        mcb

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if the current buffer is large enough to hold
    //  the additional entries
    //

    if (Mcb->PairCount + AmountToAdd > Mcb->MaximumPairCount) {

        ULONG NewMax;
        PMAPPING Mapping;

        //
        //  We need to allocate a new mapping so compute a new maximum pair
        //  count.  We'll only be asked to grow by at most 2 at a time, so
        //  doubling will definitely make us large enough for the new amount.
        //  But we won't double without bounds we'll stop doubling if the
        //  pair count gets too high.
        //

        if (Mcb->MaximumPairCount < 2048) {

            NewMax = Mcb->MaximumPairCount * 2;

        } else {

            NewMax = Mcb->MaximumPairCount + 2048;
        }

        Mapping = FsRtlAllocatePool( Mcb->PoolType, sizeof(MAPPING)*NewMax );

        //**** RtlZeroMemory( Mapping, sizeof(MAPPING) * NewMax );

        //
        //  Now copy over the old mapping to the new buffer
        //

        RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

        //
        //  Deallocate the old buffer
        //

        if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

            { PVOID t = Mcb->Mapping; FsRtlFreeFirstMapping( t ); }

        } else {

            ExFreePool( Mcb->Mapping );
        }

        //
        //  And set up the new buffer in the Mcb
        //

        Mcb->Mapping = Mapping;
        Mcb->MaximumPairCount = NewMax;
    }

    //
    //  Now see if we need to shift some entries over according to the
    //  WhereToAddIndex value
    //

    if (WhereToAddIndex < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToAddIndex + AmountToAdd]),
                      &((Mcb->Mapping)[WhereToAddIndex]),
                      (Mcb->PairCount - WhereToAddIndex) * sizeof(MAPPING) );
    }

    //
    //  Now zero out the new additions
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[WhereToAddIndex]), sizeof(MAPPING) * AmountToAdd );

    //
    //  Now increment the PairCount
    //

    Mcb->PairCount += AmountToAdd;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    )

/*++

Routine Description:

    This routine takes a current Mcb and removes one or more entries.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToRemoveIndex - Supplies the index of the entries to remove

    AmountToRemove - Supplies the number of entries to remove

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if we need to shift everything down because the
    //  entries to remove do not include the last entry in the mcb
    //

    if (WhereToRemoveIndex + AmountToRemove < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToRemoveIndex]),
                      &((Mcb->Mapping)[WhereToRemoveIndex + AmountToRemove]),
                      (Mcb->PairCount - (WhereToRemoveIndex + AmountToRemove))
                                                           * sizeof(MAPPING) );
    }

    //
    //  Now zero out the entries beyond the part we just shifted down
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[Mcb->PairCount - AmountToRemove]), AmountToRemove * sizeof(MAPPING) );

    //
    //  Now decrement the PairCount
    //

    Mcb->PairCount -= AmountToRemove;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

PVOID
FsRtlAllocateFirstMapping(
    )

/*++

Routine Description:

    This routine will if possible allocate the first mapping from either
    a zone, a recent deallocated mapping, or pool.

Arguments:

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;
    PVOID Mapping;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFirstMapping += 1;

    if (FsRtlFreeFirstMappingSize > 0) {
        Mapping = FsRtlFreeFirstMappingArray[--FsRtlFreeFirstMappingSize];
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        Mapping = FsRtlAllocatePool( PagedPool, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
    }

    return Mapping;
}


//
//  Private Routine
//

VOID
FsRtlFreeFirstMapping(
    IN PVOID Mapping
    )

/*++

Routine Description:

    This routine will if possible allocate the first mapping from either
    a zone, a recent deallocated mapping, or pool.

Arguments:

    Mapping - The mapping to either free to zone, put on the recent
        deallocated list or free to pool.

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFirstMapping -= 1;

    if (FsRtlFreeFirstMappingSize < FREE_FIRST_MAPPING_ARRAY_SIZE) {
        FsRtlFreeFirstMappingArray[FsRtlFreeFirstMappingSize++] = Mapping;
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        ExFreePool( Mapping );
    }
}


//
//  Private Routine
//

PFAST_MUTEX
FsRtlAllocateFastMutex(
    )

/*++

Routine Description:

    This routine will if possible allocate the FastMutex from either
    a zone, a recent deallocated FastMutex, or pool.

Arguments:

Return Value:

    The FastMutex.

--*/

{
    KIRQL _SavedIrql;
    PFAST_MUTEX FastMutex;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFastMutex += 1;

    if (!ExIsFullZone(&FsRtlFastMutexZone)) {
        FastMutex = ExAllocateFromZone(&FsRtlFastMutexZone);
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else if (FsRtlFreeFastMutexSize > 0) {
        FastMutex = FsRtlFreeFastMutexArray[--FsRtlFreeFastMutexSize];
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        FastMutex = FsRtlAllocatePool( NonPagedPool, sizeof(FAST_MUTEX) );
    }

    return FastMutex;
}


//
//  Private Routine
//

VOID
FsRtlFreeFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This routine will if possible allocate the FastMutex from either
    a zone, a recent deallocated FastMutexs, or pool.

Arguments:

    Mapping - The FastMutex to either free to zone, put on the recent
        deallocated list or free to pool.

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFastMutex -= 1;

    if (ExIsObjectInFirstZoneSegment(&FsRtlFastMutexZone, FastMutex)) {
        ExFreeToZone(&FsRtlFastMutexZone, FastMutex);
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else if (FsRtlFreeFastMutexSize < FREE_FAST_MUTEX_ARRAY_SIZE) {
        FsRtlFreeFastMutexArray[FsRtlFreeFastMutexSize++] = FastMutex;
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        ExFreePool( FastMutex );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\mftfile.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    mftfile.hxx

Abstract:

    This module contains the member function definitions for the
    NTFS_MFT_FILE class.

Author:

    Bill McJohn (billmc) 22-June-91

Environment:

    ULIB, User Mode

Notes:

    The MFT and the Volume Bitmap:

        The Master File Table needs the bitmap to extend itself.  The
        volume bitmap can be passed in upon initialization, or it can
        be supplied (using SetVolumeBitmap) at any time.  However,
        until it is supplied, the Master File Table is unable to grow
        itself.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "mftfile.hxx"
#include "clusrun.hxx"
#include "cmem.hxx"
#include "indxtree.hxx"

#define LOGFILE_PLACEMENT_V1    1

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_MFT_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_MFT_FILE::~NTFS_MFT_FILE(
    )
{
    Destroy();
}


VOID
NTFS_MFT_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FirstLcn = 0;
    _VolumeBitmap = NULL;
}


VOID
NTFS_MFT_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MFT_FILE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FirstLcn = 0;
    _VolumeBitmap = NULL;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE Drive,
    IN      LCN Lcn,
    IN      ULONG ClusterFactor,
    IN      ULONG FrsSize,
    IN      BIG_INT VolumeSectors,
    IN OUT  PNTFS_BITMAP VolumeBitmap,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    Initialize an NTFS_MFT_FILE object.

Arguments:

    Drive           -- supplies the Drive on which the file table resides
    Lcn             -- supplies the logical cluster number of the master
                        file table entry which describes the master file
                        table itself.
    ClusterFactor   -- supplies the number of sectors per cluster.
    FrsSize         -- supplies the number of bytes per File Record
                        Segment in this MFT.
    VolumeSectors   -- supplies the number of volume sectors.
    VolumeBitmap    -- supplies the bitmap for the volume.  This parameter
                        may be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG MirroredClusters;
    ULONG ClusterSize;

    Destroy();

    DebugPtrAssert( Drive );

    _FirstLcn = Lcn;
    _VolumeBitmap = VolumeBitmap;

    ClusterSize = Drive->QuerySectorSize() * ClusterFactor;

    MirroredClusters = (REFLECTED_MFT_SEGMENTS * FrsSize + (ClusterSize - 1))
        / ClusterSize;

    if( !_MirrorMem.Initialize() ||
        !_MirrorClusterRun.Initialize( &_MirrorMem,
                                       Drive,
                                       0,
                                       ClusterFactor,
                                       MirroredClusters ) ) {

        DebugPrint( "Can't initialize MFT helper cluster run.\n" );
        Destroy();
        return FALSE;
    }

    if (!_Mft.Initialize(&_DataAttribute, &_MftBitmap, VolumeBitmap,
                         UpcaseTable, ClusterFactor, FrsSize,
                         Drive->QuerySectorSize(), VolumeSectors)) {

        return FALSE;
    }

    _Mft.DisableMethods();


    if (!NTFS_FILE_RECORD_SEGMENT::Initialize(Drive,
                                              Lcn,
                                              &_Mft) ) {

        Destroy();
        return FALSE;
    }



    return TRUE;
}


BOOLEAN
NTFS_MFT_FILE::Create(
    IN      ULONG                   InitialSize,
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    Create a new Master File Table for the volume.

Arguments:

    InitialSize         -- supplies the number of clusters to allocate
                            to the MFT we create.
    StandardInformation -- supplies a standard information structure for
                            the MFT's File Record Segment.
    VolumeBitmap        -- supplies the bitmap for the volume.

Return Value:

    TRUE upon successful completion.

Notes:

    The caller must first allocate a run of InitialSize clusters
    from the bitmap, and initialize the NTFS_MFT_FILE object
    with the starting cluster of that run.

--*/
{
    NTFS_EXTENT_LIST Extents;
    NTFS_ATTRIBUTE MftBitmapAttribute;
    LCN FirstLcnInMftBitmap;
    ULONG ClustersInMftBitmap;
    ULONG MftBitmapSize;
    ULONG ClusterSize;
    ULONG MftClusters;

    _Mft.DisableMethods();

    if( InitialSize < FIRST_USER_FILE_NUMBER ) {

        DebugPrint( "MFT Initial Size is too small.\n" );
        return FALSE;
    }


    // Set this object up as a File Record Segment:

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }


    // OK, set up the data attribute with the disk space supplied
    // by the caller.

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    MftClusters = (InitialSize * QuerySize() + (ClusterSize - 1)) / ClusterSize;

    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            _FirstLcn,
                            MftClusters ) ||
        !_DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    InitialSize * QuerySize(),
                                    InitialSize * QuerySize(),
                                    $DATA ) ||
        !_DataAttribute.Fill(0, 0) ||
        !_DataAttribute.InsertIntoFile( this,
                                        VolumeBitmap ) ) {

        return FALSE;
    }

    // Create an MFT Bitmap attribute.  Allocate a run on disk to
    // hold its initial size, and use that to set up a non-resident
    // attribute to hold it.  The initial size is at least 8k (to
    // allow some space for future growth.)
    //

    MftBitmapSize = (InitialSize + 7)/ 8;

    ClustersInMftBitmap = max((MftBitmapSize + (ClusterSize - 1))/ClusterSize,
                             /* MFT_BITMAP_INITIAL_SIZE/ClusterSize */ 0);

    if( !VolumeBitmap->AllocateClusters(
#if LOGFILE_PLACEMENT_V1    // initial location of MFT Bitmap
                                         _FirstLcn - ClustersInMftBitmap,
#else
                                         1,
#endif
                                         ClustersInMftBitmap,
                                         &FirstLcnInMftBitmap,
                                         1 ) ||
        !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            FirstLcnInMftBitmap,
                            ClustersInMftBitmap ) ||
        !MftBitmapAttribute.Initialize( GetDrive(),
                                        QueryClusterFactor(),
                                        &Extents,
                                        MftBitmapSize,
                                                                /* value length */
                                        /* ClustersInMftBitmap * ClusterSize,   */
                                        MftBitmapSize,          /* valid length */
                                        $BITMAP ) ||
        !MftBitmapAttribute.InsertIntoFile( this,
                                            VolumeBitmap ) ) {

        return FALSE;
    }

    // Create the MFT Bitmap.  Note that it is growable.

    if( !_MftBitmap.Initialize( InitialSize, TRUE ) ) {

        return FALSE;
    }

    // Mark the system files as in use.  Note that we've already
    // checked that InitialSize is at least FIRST_USER_FILE_NUMBER.

    _MftBitmap.SetAllocated( 0, FIRST_USER_FILE_NUMBER );

    _Mft.EnableMethods();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Read(
    )
/*++

Routine Description:

    This routine reads this FRS for the MFT and then proceeds
    to read the MFT bitmap.  If all goes well, the internal
    data attribute and MFT bitmap will be initialized.

    This method will return TRUE if and only if the base FRS for
    this MFT is correctly read in.  The MFT allocation methods will
    be enabled by this method if and only if MFT bitmap and the
    MFT data attribute are properly read in and initialized.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE  MftBitmapAttribute;
    BIG_INT         DataAttributeWrittenLength;
    BIG_INT         DataAttributeAllocatedLength;
    BIG_INT         NumberOfAllocatedFileRecordSegments,
                    NumberOfWrittenFileRecordSegments;
    ULONG           RequiredBitsInBitmap, PreferredBitsInBitmap;
    BOOLEAN         Error;

    _Mft.DisableMethods();

    if (!NTFS_FILE_RECORD_SEGMENT::Read()) {
        return FALSE;
    }

    _Mft.EnableMethods();

    // Make sure that we have the Data Attribute to play with.

    if (!QueryAttribute(&_DataAttribute, &Error, $DATA)) {

        _Mft.DisableMethods();
        return TRUE;
    }


    // The length of the bitmap depends on the allocated length of
    // the data attribute.

    _DataAttribute.QueryValueLength( &DataAttributeWrittenLength,
                                     &DataAttributeAllocatedLength );

    // A quick sanity check:
    //
    if( CompareGT(DataAttributeWrittenLength, DataAttributeAllocatedLength) ) {

        DebugAbort( "UNTFS: MFT Data attribute is corrupt.\n" );
        _Mft.DisableMethods();
        return TRUE;
    }

    NumberOfWrittenFileRecordSegments = DataAttributeWrittenLength / QuerySize();
    NumberOfAllocatedFileRecordSegments = DataAttributeAllocatedLength / QuerySize();

    DebugAssert( NumberOfWrittenFileRecordSegments.GetHighPart() == 0 );
    DebugAssert( NumberOfAllocatedFileRecordSegments.GetHighPart() == 0 );

    RequiredBitsInBitmap = NumberOfWrittenFileRecordSegments.GetLowPart();
    PreferredBitsInBitmap = NumberOfAllocatedFileRecordSegments.GetLowPart();

    // Create a bitmap, and get the MFT bitmap attribute through
    // which we read it, and read the bitmap.

    if( !_MftBitmap.Initialize( RequiredBitsInBitmap, TRUE ) ||
        !QueryAttribute( &MftBitmapAttribute, &Error, $BITMAP ) ||
        !_MftBitmap.Read( &MftBitmapAttribute ) ||
        !_MftBitmap.Resize( PreferredBitsInBitmap ) ) {

        DebugAbort( "Cannot read MFT Bitmap.\n" );
        _Mft.DisableMethods();
        return TRUE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Flush(
    )
/*++

Routine Description:

    This method flushes the MFT--re-inserts the DATA attribute (if
    necessary); writes the MFT bitmap, and writes the MFT's own
    File Record Segment.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will also write the volume bitmap and the mft mirror.
    It will resize the $DATA attributes on the bitmap and mirror files
    and write those FRS's, if necessary.

--*/
{
    NTFS_BITMAP_FILE BitmapFile;
    NTFS_REFLECTED_MASTER_FILE_TABLE MirrorFile;
    NTFS_INDEX_TREE RootIndex;
    NTFS_FILE_RECORD_SEGMENT RootIndexFrs;
    DSTRING FileNameIndexName;

    NTFS_ATTRIBUTE MftBitmapAttribute,
                   MirrorDataAttribute,
                   VolumeBitmapAttribute;

    LCN FirstMirrorLcn;
    BIG_INT OldValidLength;
    BOOLEAN Error;

    if( !_Mft.AreMethodsEnabled() ) {

        DebugAbort( "Tried to flush the MFT before enabling it.\n" );
        return FALSE;
    }


    // Ensure that the bitmap file and mirror file's $DATA attributes
    // are the correct sizes.  This will later allow us to write these
    // two constructs without affecting their respective FRS's.

    if( !BitmapFile.Initialize( &_Mft ) ||
        !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &VolumeBitmapAttribute,
                                    &Error,
                                    $DATA ) ||
        !_VolumeBitmap->CheckAttributeSize( &VolumeBitmapAttribute,
                                           _VolumeBitmap ) ||
        !MirrorFile.Initialize( &_Mft ) ||
        !MirrorFile.Read() ||
        !MirrorFile.QueryAttribute( &MirrorDataAttribute,
                                    &Error,
                                    $DATA ) ||
        !CheckMirrorSize( &MirrorDataAttribute,
                          TRUE,
                          _VolumeBitmap,
                          &FirstMirrorLcn ) ) {

        DebugPrint( "Cannot check size of bitmap & mirror attributes.\n" );
        return FALSE;
    }


    if( VolumeBitmapAttribute.IsStorageModified() &&
        ( !VolumeBitmapAttribute.InsertIntoFile( &BitmapFile,
                                                 _VolumeBitmap ) ||
          !BitmapFile.Flush( _VolumeBitmap ) ) ) {

        DebugPrint( "Cannot save volume bitmap attribute.\n" );
        return FALSE;
    }

    if( MirrorDataAttribute.IsStorageModified() &&
        ( !MirrorDataAttribute.InsertIntoFile( &MirrorFile, _VolumeBitmap ) ||
          !MirrorFile.Flush( _VolumeBitmap ) ) ) {

        DebugPrint( "Cannot save MFT mirror data attribute.\n" );
        return FALSE;
    }

    // Fetch the root index from its FRS.
    //
    if( !RootIndexFrs.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, this ) ||
        !RootIndexFrs.Read() ||
        !FileNameIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( GetDrive(),
                               QueryClusterFactor(),
                               _VolumeBitmap,
                               GetUpcaseTable(),
                               QuerySize()/2,
                               &RootIndexFrs,
                               &FileNameIndexName ) ) {

        return FALSE;
    }

    // Fetch the MFT Bitmap attribute.
    //
    if( !QueryAttribute( &MftBitmapAttribute, &Error, $BITMAP ) ) {

        DebugPrintTrace(( "UNTFS: Cannot fetch MFT bitmap attribute.\n" ));
        return FALSE;
    }

    // Write the bitmap once to make it the right size.  If
    // it grows while we're saving the MFT, we'll have to
    // write it again.
    //
    if( !_MftBitmap.Write( &MftBitmapAttribute, _VolumeBitmap ) ) {

        DebugPrintTrace(( "UNTFS: Cannot write the MFT bitmap.\n" ));
        return FALSE;
    }

    do {

        // Note that inserting an attribute into a file resets the
        // attribute's StorageModified flag.
        //
        if( MftBitmapAttribute.IsStorageModified() &&
            !MftBitmapAttribute.InsertIntoFile( this, NULL ) ) {

            DebugPrint( "UNTFS: Cannot save MFT bitmap attribute.\n" );
            return FALSE;
        }

        // Remember the bitmap size (which is equal to the number
        // of FRS's in the MFT).
        //
        OldValidLength = _DataAttribute.QueryValidDataLength();

        // Save the data attribute.
        //
        if( _DataAttribute.IsStorageModified() &&
            !_DataAttribute.InsertIntoFile(this, NULL) ) {

            DebugAbort( "UNTFS: Cannot save MFT's data attribute.\n" );
            return FALSE;
        }

        // Flush this FRS.
        //
        if( !NTFS_FILE_RECORD_SEGMENT::Flush( _VolumeBitmap, &RootIndex) ) {

            return FALSE;
        }

        // Write the bitmap again, in case it changed.
        //
        if( !_MftBitmap.Write( &MftBitmapAttribute, _VolumeBitmap ) ) {

            DebugPrintTrace(( "UNTFS: Cannot write the MFT bitmap.\n" ));
            return FALSE;
        }

        // If the MFT's Valid Data Length changed while we were
        // saving the data attribute and bitmap, we have to go
        // through this loop again.

    } while( OldValidLength != _DataAttribute.QueryValidDataLength() );

    // Save the root index:
    //
    if( !RootIndex.Save( &RootIndexFrs ) ||
        !RootIndexFrs.Flush( _VolumeBitmap ) ) {

        return FALSE;
    }

    if( !_VolumeBitmap->Write( &VolumeBitmapAttribute, NULL ) ||
        !WriteMirror( &MirrorDataAttribute ) ){

        DebugPrint( "Failed write of MFT Mirror or volume bitmap.\n" );
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_MFT_FILE::CheckMirrorSize(
    IN OUT PNTFS_ATTRIBUTE  MirrorDataAttribute,
    IN     BOOLEAN          Fix,
    IN OUT PNTFS_BITMAP     VolumeBitmap,
    OUT    PLCN             FirstLcn
    )
/*++

Routine Description:

    This method checks that the MFT Mirror $DATA attribute is the
    correct size and contiguous.  It can also be used to check these
    restrictions.

Arguments:

    MirrorDataAttribut  --  Supplies the MFT Mirror's $DATA attribute.
    Fix                 --  Supplies a flag which indicates that the
                            attribute should be reallocated if it is
                            the wrong size or not contiguous.
    VolumeBitmap        --  Supplies the volume bitmap (only required
                            if Fix is TRUE).
    FirstLcn            --  Receives the starting LCN of the mirror.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT RunLength;
    LCN     NewStartingLcn;
    ULONG   MirroredClusters;
    ULONG   ClusterSize;

    ClusterSize = QueryClusterFactor() * _Mft.QuerySectorSize();

    MirroredClusters = (REFLECTED_MFT_SEGMENTS * QuerySize() + (ClusterSize - 1))
         / ClusterSize;

    if( MirrorDataAttribute->QueryLcnFromVcn( 0, FirstLcn, &RunLength ) &&
        *FirstLcn != 0 &&
        *FirstLcn != LCN_NOT_PRESENT &&
        RunLength >= MirroredClusters ) {

        // Everything is perfect.

        return TRUE;
    }

    // Something is not perfect.

    if( Fix &&
        VolumeBitmap->AllocateClusters( QueryVolumeSectors()/
                                            QueryClusterFactor()/
                                            2,
                                        MirroredClusters,
                                        &NewStartingLcn ) &&
        MirrorDataAttribute->Resize( 0, VolumeBitmap ) &&
        MirrorDataAttribute->AddExtent( 0,
                                        NewStartingLcn,
                                        MirroredClusters ) ) {

        // It was broken, but now it's perfect.

        *FirstLcn = NewStartingLcn;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
NTFS_MFT_FILE::WriteMirror(
    IN OUT PNTFS_ATTRIBUTE  MirrorDataAttribute
    )
/*++

Routine Description:

    This method writes the MFT Mirror.  Note that it will fail if
    the mirror's $DATA attribute is not the correct size or is
    not contiguous.

Arguments:

    MirrorDataAttribute --  Supplies the MFT Mirror's $DATA attribute.

Return Value:

    TRUE upon successful completion.

Notes:

    This method copies whatever is _on disk_ in the MFT's data attribute
    to the mirror's data attribute.  Therefore, it should only be called
    after the MFT itself has been written.

--*/
{
    LCN FirstMirrorLcn;

    if( !CheckMirrorSize( MirrorDataAttribute,
                          FALSE,
                          NULL,
                          &FirstMirrorLcn ) ) {

        return FALSE;
    }

    _MirrorClusterRun.Relocate( _FirstLcn );

    if( !_MirrorClusterRun.Read() ) {

        return FALSE;
    }

    _MirrorClusterRun.Relocate( FirstMirrorLcn );

    if( !_MirrorClusterRun.Write() ) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\mft.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"


#include "mft.hxx"

#include "attrib.hxx"
#include "drive.hxx"
#include "frsstruc.hxx"
#include "hmem.hxx"
#include "numset.hxx"




DEFINE_CONSTRUCTOR( NTFS_MASTER_FILE_TABLE, OBJECT );

NTFS_MASTER_FILE_TABLE::~NTFS_MASTER_FILE_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_MASTER_FILE_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
    _MftBitmap = NULL;
    _VolumeBitmap = NULL;
    _BytesPerFrs = 0;
    _ClusterFactor = 0;
    _VolumeSectors = 0;
    _MethodsEnabled = FALSE;
    _ReadOnly = FALSE;
}


VOID
NTFS_MASTER_FILE_TABLE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
    _MftBitmap = NULL;
    _VolumeBitmap = NULL;
    _BytesPerFrs = 0;
    _ClusterFactor = 0;
    _VolumeSectors = 0;
    _MethodsEnabled = FALSE;
    _ReadOnly = FALSE;
}


BOOLEAN
NTFS_MASTER_FILE_TABLE::Initialize(
    IN OUT  PNTFS_ATTRIBUTE     DataAttribute,
    IN OUT  PNTFS_BITMAP        MftBitmap,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      ULONG               ClusterFactor,
    IN      ULONG               FrsSize,
    IN      ULONG               SectorSize,
    IN      BIG_INT             VolumeSectors,
    IN      BOOLEAN             ReadOnly
    )
/*++

Routine Description:

    Initialize an NTFS_MASTER_FILE_TABLE object.

Arguments:

    DataAttribute   - Supplies the DATA attribute for the MFT.
    MftBitmap       - Supplies the MFT Bitmap for the MFT.
    VolumeBitmap    - Suppleis the volume bitmap.
    UpcaseTable     - Supplies the volume bitmap.
    ClusterFactor   - Supplies the number of sectors per cluster.
    FrsSize         - Supplies the number of bytes per FRS.
    SectorSize      - Supplies the number of bytes per sector.
    VolumeSectors   - Supplies the number of volume sectors.
    ReadOnly        - Supplies whether or not this class is read only.

Return Value:

    TRUE upon successful completion.

Notes:

    Unless the Upcase table is supplied, FRS's initialized with this
    MFT will not be able to manipulate named attributes until the
    upcase table is set.

--*/
{
    Destroy();

    DebugAssert(DataAttribute);
    DebugAssert(MftBitmap);
    DebugAssert(ClusterFactor);
    DebugAssert(FrsSize);
    DebugAssert(SectorSize);

    _DataAttribute = DataAttribute;
    _MftBitmap = MftBitmap;
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;
    _ClusterFactor = ClusterFactor;
    _BytesPerFrs = FrsSize;
    _VolumeSectors = VolumeSectors;
    _MethodsEnabled = TRUE;
    _ReadOnly = ReadOnly;
    _SectorSize = SectorSize;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MASTER_FILE_TABLE::AllocateFileRecordSegment(
    OUT PVCN    FileNumber,
    IN  BOOLEAN IsMft
    )
/*++

Routine Description:

    Allocate a File Record Segment from the Master File Table.  If the
    allocation is being done for a user file, we make sure that the frs
    doesn't come from the first cluster of the mft's allocation.

Arguments:

    FileNumber  -- Returns the file number of the allocated segment.
    IsMft       -- supplies a flag which indicates, if TRUE, that
                   the allocation is being made on behalf of the
                   MFT itself.

Return Value:

    TRUE upon successful completion.

Notes:

    Any bad clusters discovered by this routine are added to the volume
    bitmap but not added to the bad clusters file.

--*/
{
    VCN                 vcn, reserved_vcn;
    BIG_INT             run_length;
    HMEM                hmem;
    NTFS_FRS_STRUCTURE  frs;
    NUMBER_SET          bad_cluster_list;
    BOOLEAN             reserve_allocated;
    ULONG               cluster_size;

    //
    // This should really be a VCN instead of a LARGE_INTEGER, but the
    // VCN causes the compiler to insert a reference to atexit(), which
    // we want to avoid. -mjb.
    //

    STATIC LARGE_INTEGER LastAllocatedVcn;

    DebugAssert(_MftBitmap);

    if (!_MethodsEnabled) {
        return FALSE;
    }

    cluster_size = QueryClusterFactor() * _SectorSize;

    if (LastAllocatedVcn * QueryFrsSize() < cluster_size) {

        LastAllocatedVcn.QuadPart = cluster_size / QueryFrsSize();
    }

    if( IsMft ) {

        // If the MFT has asked for a sector to be allocated,
        // we can't grow the MFT (since we're in the process
        // of saving it).  However, the reservation scheme
        // means that if we have allocated any FRS's to
        // clients other than the MFT itself, there will be
        // a free one in the bitmap, so we can just return
        // it.
        //
        return _MftBitmap->AllocateClusters(1, 1, FileNumber, 1);
    }


    // Grab a reserved VCN for the MFT.
    //
    reserve_allocated = _MftBitmap->AllocateClusters(1, 1, &reserved_vcn, 1);


    if (reserve_allocated &&
        _MftBitmap->AllocateClusters(LastAllocatedVcn, 1, FileNumber, 1)) {

        LastAllocatedVcn = FileNumber->GetLargeInteger();
        _MftBitmap->SetFree( reserved_vcn, 1 );
        return TRUE;
    }

    // Grow the data attribute (and the MFT Bitmap) to
    // include another File Record Segment.
    //
    if( !Extend(8) ) {

        return FALSE;
    }

    // If we didn't get a reserved vcn before, get it now.
    //
    if( !reserve_allocated &&
        !_MftBitmap->AllocateClusters(1, 1, &reserved_vcn, 1) ) {

        return FALSE;
    }

    // And now allocate the FRS we will return to the client.
    //
    if (!_MftBitmap->AllocateClusters(LastAllocatedVcn, 1, FileNumber, 1)) {

        return FALSE;
    }


    // Now read in the new FRS to make sure that it is good.
    // Since we won't be manipulating any named attributes, we can
    // pass in NULL for the upcase table.

    if (hmem.Initialize() &&
        bad_cluster_list.Initialize() &&
        frs.Initialize(&hmem, _DataAttribute, *FileNumber,
                       QueryClusterFactor(),
                       QueryVolumeSectors(),
                       QueryFrsSize(),
                       NULL)) {

        if (!frs.Read()) {

            vcn = (*FileNumber*QueryFrsSize() + (cluster_size - 1))/cluster_size;

            run_length = (QueryFrsSize() + (cluster_size - 1))/cluster_size;

            if (!_VolumeBitmap ||
                !_DataAttribute->Hotfix(vcn, run_length, _VolumeBitmap,
                                        &bad_cluster_list)) {

                return FALSE;
            }
        }
    }

    // Free the reserved FRS and return success.
    //
    _MftBitmap->SetFree( reserved_vcn, 1 );
    LastAllocatedVcn = FileNumber->GetLargeInteger();
    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MASTER_FILE_TABLE::Extend(
    IN  ULONG   NumberOfSegmentsToAdd
    )
/*++

Routine Description:

    This method grows the Master File Table.  It increases the
    size of the Data attribute (to hold more File Record Segments)
    and increases the size of the MFT Bitmap to match.

Arguments:

    NumberOfSegmentsToAdd   --  supplies the number of new File Record
                                Segments to add to the Master File Table.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT OldAllocatedLength, NumberOfSegments;
    ULONG   BytesToAdd;

    DebugAssert(_MftBitmap);
    DebugAssert(_DataAttribute);

    if (!_MethodsEnabled || !_VolumeBitmap) {
        return FALSE;
    }

    // Find out how big it already is, and how much bigger
    // it needs to be.

    OldAllocatedLength = _DataAttribute->QueryAllocatedLength();

    BytesToAdd = NumberOfSegmentsToAdd * _BytesPerFrs;

    // Resize the attribute.  Note that if Resize fails, it
    // leaves the attribute unaltered.
    //
    if (!_DataAttribute->Resize( OldAllocatedLength + BytesToAdd,
                                 _VolumeBitmap )) {

        return FALSE;
    }

    // If the MFT is not operating in read-only mode, fill the
    // new space with zeroes.
    //
    if (!_ReadOnly && !_DataAttribute->Fill( OldAllocatedLength, 0 ) ) {

        _DataAttribute->Resize( OldAllocatedLength, _VolumeBitmap );
        return FALSE;
    }

#if DBG
    {
        ULONG   cluster_size = QueryClusterFactor() * _SectorSize;
        BIG_INT allocated_clusters = (OldAllocatedLength + BytesToAdd - 1 + cluster_size)/cluster_size;

        DebugAssert( _DataAttribute->QueryAllocatedLength() ==
                     (allocated_clusters*cluster_size) );
    }
#endif

    // Grow the MFT Bitmap to cover the new size of the Data Attribute.
    // Note that NTFS_BITMAP::Resize will set the new bits free, which
    // is what I want.

    NumberOfSegments = _DataAttribute->QueryAllocatedLength() / _BytesPerFrs;

    if( !_MftBitmap->Resize( NumberOfSegments ) ) {

        // I couldn't expand the MFT Bitmap to cover the new space,
        // so I'll have to truncate the data attribute back down.

        _DataAttribute->Resize( OldAllocatedLength, _VolumeBitmap );
        return FALSE;
    }

    return TRUE;
}

BIG_INT
NTFS_MASTER_FILE_TABLE::QueryFrsCount(
    )
/*++

Routine Description:

    This routine returns the number of frs's in the MFT.

Arguments:

    None.

Return Value:

    The number of frs's.

--*/
{
    BIG_INT num_frs;

    num_frs = _DataAttribute->QueryValueLength() / _BytesPerFrs;

    return num_frs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\mftinfo.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    mftinfo.cxx

Abstract:

    This module contains the declarations for the NTFS_MFT_INFO
    class, which stores extracted information from the NTFS MFT.

Author:

    Daniel Chan (danielch) Oct 18, 1999

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "mftinfo.hxx"
#include "membmgr2.hxx"

//#define RUN_ON_W2K  1

#if defined(RUN_ON_W2K)
//
// This table is from Windows XP rtl\checksum.c
//
STATIC
ULONG32 RtlCrc32Table [] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

//
// This routine is from Windows XP rtl\checksum.c
//
ULONG32
FsRtlComputeCrc32(
    ULONG32 PartialCrc,
    PVOID   Buf,
    ULONG Length
    )

/*++

Routine Description:

    Compute the CRC32 as specified in in IS0 3309. See RFC-1662 and RFC-1952
    for implementation details and references.

    Pre- and post-conditioning (one's complement) is done by this function, so
    it should not be done by the caller. That is, do:

        Crc = RtlComputeCrc32 ( 0, buffer, length );

    instead of

        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length );

    or
        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length) ^ 0xffffffff;


Arguments:

    PartialCrc - A partially calculated CRC32.

    Buffer - The buffer you want to CRC.

    Length - The length of the buffer in bytes.

Return Value:

    The updated CRC32 value.

Environment:

    Kernel mode at IRQL of APC_LEVEL or below, User mode, or within
    the boot-loader.

--*/



{
    PUCHAR  Buffer = (PUCHAR)Buf;
    ULONG32 Crc;
    ULONG i;

    //
    // Compute the CRC32 checksum.
    //

    Crc = PartialCrc ^ 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = RtlCrc32Table [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}
#else

#define FsRtlComputeCrc32   RtlComputeCrc32

#endif


PNTFS_UPCASE_TABLE   NTFS_MFT_INFO::_upcase_table = NULL;
UCHAR                NTFS_MFT_INFO::_major = 0;
UCHAR                NTFS_MFT_INFO::_minor = 0;

DEFINE_CONSTRUCTOR( NTFS_MFT_INFO, OBJECT );

VOID
NTFS_MFT_INFO::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;
    _major = _minor = 0;
    _upcase_table = NULL;
    _max_mem_use = 0;
    _num_of_files = 0;
    _mft_info = NULL;
}

VOID
NTFS_MFT_INFO::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;
    _major = _minor = 0;
    _upcase_table = NULL;
    _max_mem_use = 0;
    _num_of_files = 0;
    FREE(_mft_info);
}

NTFS_MFT_INFO::~NTFS_MFT_INFO(
    )
/*++

Routine Description:

    This method un-initialize the class object.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    Destroy();
}

BOOLEAN
NTFS_MFT_INFO::Initialize(
    IN     BIG_INT              NumberOfFrs,
    IN     PNTFS_UPCASE_TABLE   UpcaseTable,
    IN     UCHAR                Major,
    IN     UCHAR                Minor,
    IN     ULONG64              MaxMemUse
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    FielName    --  Supplies the second name to compare.

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    ULONG   size;

    Destroy();

    _num_of_files = NumberOfFrs.GetLowPart();
    size = NumberOfFrs.GetLowPart()*sizeof(PVOID);
    _mft_info = (PVOID *)MALLOC(size);
    if (_mft_info) {
        if (!_mem_mgr.Initialize(MaxMemUse)) {
            FREE(_mft_info);
            return FALSE;
        }
        memset(_mft_info, 0, size);
        _upcase_table = UpcaseTable;
        _major = Major;
        _minor = Minor;
        _max_mem_use = MaxMemUse;
        return TRUE;
    }
    return FALSE;
}

BOOLEAN
NTFS_MFT_INFO::Initialize(
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    FielName    --  Supplies the second name to compare.

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    if (_mft_info == NULL)
        return FALSE;   // have not been initialize before

    if (!_mem_mgr.Initialize(_max_mem_use)) {
        return FALSE;
    }

    // prevent accidental use of stale pointers
    memset(_mft_info, 0, _num_of_files * sizeof(PVOID));

    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;

    return TRUE;
}

BOOLEAN
NTFS_MFT_INFO::CompareFileName(
    IN     PVOID                FrsInfo,
    IN     ULONG                ValueLength,
    IN     PFILE_NAME           FileName,
       OUT PUSHORT              FileNameIndex
    )
/*++

Routine Description:

    This method compares the signature computed from FileName against
    the signature stored in FrsInfo.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    ValueLength --  Supplies the length of the FileName (second name) value.
    FileName    --  Supplies the second name to compare.
    FileNameIndex -- Retrieves the index that matches the FileName & ValueLength

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    PNTFS_FRS_INFO          p = (PNTFS_FRS_INFO)FrsInfo;
    USHORT                  i, FileNameCount = p->NumberOfFileNames;
    FILE_NAME_SIGNATURE     signature;

    NTFS_MFT_INFO::ComputeFileNameSignature(ValueLength, FileName, signature);

    for (i=0; i<FileNameCount; i++) {
        if (memcmp(p->FileNameInfo[i].Signature,
                   signature,
                   sizeof(FILE_NAME_SIGNATURE)) == 0) {
            *FileNameIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
NTFS_MFT_INFO::ExtractIndexEntryInfo(
    IN     PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN     PMESSAGE                     Message,
    IN     BOOLEAN                      IgnoreFileName,
       OUT PBOOLEAN                     OutOfMemory
    )
/*++

Routine Description:

    This method extracts index entry information from the FRS.

Arguments:

    Frs       --  Supplies the file record segment to extract information from.
    Message   --  Supplies the outlet for message.

Returns:

    TRUE if successful
    FALSE if failure

--*/
{
    USHORT                     number_of_filenames;
    NTFS_ATTRIBUTE             attribute;
    BOOLEAN                    error;
    USHORT                     i;
    PNTFS_FRS_INFO             p;
    DUPLICATED_INFORMATION     dup_info;
    PFILE_NAME                 pFileName;

    CHAR                       x[50];


    *OutOfMemory = FALSE;

    number_of_filenames = 0;
    if (!IgnoreFileName) {
        for (i=0; Frs->QueryAttributeByOrdinal(&attribute,
                                               &error,
                                               $FILE_NAME,
                                               i); i++) {
            if (attribute.IsResident()) {
                number_of_filenames++;
            }
        }
        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (number_of_filenames) {

        p = (PNTFS_FRS_INFO) _mem_mgr.Allocate(sizeof(NTFS_FRS_INFO) +
                (number_of_filenames-1)*sizeof(_NTFS_FILE_NAME_INFO));
        if (p == NULL) {
            *OutOfMemory = TRUE;
            return FALSE;
        }

        p->SegmentReference = Frs->QuerySegmentReference();

        if (!Frs->QueryDuplicatedInformation(&dup_info)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        NTFS_MFT_INFO::ComputeDupInfoSignature(&dup_info, p->DupInfoSignature);
#if 0
        sprintf(x, "DI, %08d, %02x%02x%02x%02x%02x%02x\n",
               Frs->QueryFileNumber().GetLowPart(),
               p->DupInfoSignature[0],
               p->DupInfoSignature[1],
               p->DupInfoSignature[2],
               p->DupInfoSignature[3],
               p->DupInfoSignature[4],
               p->DupInfoSignature[5]);
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", x, " ");
#endif
        p->NumberOfFileNames = number_of_filenames;

        for (i=0; Frs->QueryAttributeByOrdinal(&attribute,
                                               &error,
                                               $FILE_NAME,
                                               i); i++) {
            if (attribute.IsResident()) {

                pFileName = (PFILE_NAME)attribute.GetResidentValue();
                DebugAssert(pFileName);
                DebugAssert(number_of_filenames);
                NTFS_MFT_INFO::ComputeFileNameSignature(
                    attribute.QueryValueLength().GetLowPart(),
                    pFileName,
                    p->FileNameInfo[--number_of_filenames].Signature);
                p->FileNameInfo[number_of_filenames].Flags = pFileName->Flags;
#if 0
                sprintf(x, "FN, %08d, %d: %02x%02x%02x%02x%02x%02x%02x\n",
                       Frs->QueryFileNumber().GetLowPart(),
                       number_of_filenames,
                       p->FileNameInfo[number_of_filenames].Signature[0],
                       p->FileNameInfo[number_of_filenames].Signature[1],
                       p->FileNameInfo[number_of_filenames].Signature[2],
                       p->FileNameInfo[number_of_filenames].Signature[3],
                       p->FileNameInfo[number_of_filenames].Signature[4],
                       p->FileNameInfo[number_of_filenames].Signature[5],
                       p->FileNameInfo[number_of_filenames].Signature[6]);
                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", x, " ");
#endif
            }
        }
    } else {
        p = (PNTFS_FRS_INFO)_mem_mgr.Allocate(sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO));
        if (p == NULL) {
            *OutOfMemory = TRUE;
            return FALSE;
        }

        p->SegmentReference = Frs->QuerySegmentReference();
        p->NumberOfFileNames = 0;
    }
    _mft_info[Frs->QueryFileNumber().GetLowPart()] = p;

    if (_min_file_number > Frs->QueryFileNumber())
        _min_file_number = Frs->QueryFileNumber();
    if (_max_file_number < Frs->QueryFileNumber())
        _max_file_number = Frs->QueryFileNumber();

    return TRUE;
}


VOID
NTFS_MFT_INFO::ComputeFileNameSignature(
    IN     ULONG                    ValueLength,
    IN     PFILE_NAME               FileName,
       OUT FILE_NAME_SIGNATURE      Signature
    )
/*++

Routine Description:

    This method computes a signature based on the given file name.

Arguments:

    ValueLength -- Supplies the length of the entire FileName value
    FileName  --  Supplies the file name
    Signature --  Returns the signature of the file name

Returns:

    N/A

--*/
{
    ULONG32     crc;

    crc = FsRtlComputeCrc32(0, &(FileName->FileNameLength), sizeof(FileName->FileNameLength));
    crc = FsRtlComputeCrc32(crc, &(FileName->Flags), sizeof(FileName->Flags));
    crc = FsRtlComputeCrc32(crc, &ValueLength, sizeof(ValueLength));
    crc = FsRtlComputeCrc32(crc, &(FileName->ParentDirectory), sizeof(FileName->ParentDirectory));
    crc = FsRtlComputeCrc32(crc, FileName->FileName, FileName->FileNameLength * sizeof(WCHAR));
    memset(Signature, 0, sizeof(FILE_NAME_SIGNATURE));
    memcpy(Signature, &crc, min(sizeof(crc), sizeof(FILE_NAME_SIGNATURE)));
}

VOID
NTFS_MFT_INFO::ComputeDupInfoSignature(
    IN     PDUPLICATED_INFORMATION      DupInfo,
       OUT DUP_INFO_SIGNATURE           Signature
    )
/*++

Routine Description:

    This method computes a signature based on the given duplicated information.

Arguments:

    DupInfo   --  Supplies the duplicated information.
    Signature --  Returns the signature of the duplicated information.

Returns:

    N/A

--*/
{
    ULONG32 crc;
    ULONG   len;

    //
    // make sure the first three fields are contiguous
    //
    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, CreationTime) == 0);

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastModificationTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, CreationTime) ==
           sizeof(DupInfo->CreationTime));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastChangeTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, LastModificationTime) ==
           sizeof(DupInfo->LastModificationTime));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastAccessTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, LastChangeTime) ==
           sizeof(DupInfo->LastChangeTime));

    len = FIELD_OFFSET(DUPLICATED_INFORMATION, LastAccessTime);
    crc = FsRtlComputeCrc32(0, DupInfo, len);

    //
    // make sure the fourth field and on are contiguous
    //
    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, FileSize) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, AllocatedLength) ==
           sizeof(DupInfo->AllocatedLength));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileSize) ==
           sizeof(DupInfo->FileSize));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) ==
           sizeof(DupInfo->FileAttributes));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, PackedEaSize) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) ==
           sizeof(DupInfo->FileAttributes));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, Reserved) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, PackedEaSize) ==
           sizeof(DupInfo->PackedEaSize));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) +
           sizeof(DupInfo->ReparsePointTag) == sizeof(DUPLICATED_INFORMATION));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, Reserved) +
           sizeof(DupInfo->Reserved) == sizeof(DUPLICATED_INFORMATION));

    len = FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) -
          FIELD_OFFSET(DUPLICATED_INFORMATION, AllocatedLength);
    if (_major >= 2 &&
        DupInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        len += sizeof(DupInfo->ReparsePointTag);
    } else {
        len += sizeof(DupInfo->PackedEaSize);
    }

    crc = FsRtlComputeCrc32(crc, &(DupInfo->AllocatedLength), len);
    memset(Signature, 0, sizeof(DUP_INFO_SIGNATURE));
    memcpy(Signature, &crc, min(sizeof(crc), sizeof(DUP_INFO_SIGNATURE)));
}


VOID
NTFS_MFT_INFO::UpdateRange(
    IN     VCN                  FileNumber
    )
/*++

Routine Description:

    This routine update the range of files that are covered by the object.


Arguments:

    FileNumber  - file number to include into the range.

Return Value:

    N/A

--*/
{
    if (_min_file_number > FileNumber)
        _min_file_number = FileNumber;
    if (_max_file_number < FileNumber)
        _max_file_number = FileNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\logfile.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    logfile.cxx

Abstract:

        This module contains the member function definitions for
    the NTFS_LOG_FILE class.

Author:

    Bill McJohn (billmc) 05-May-1992

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"

#include "ifssys.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "logfile.hxx"

#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_LOG_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

#define LOGFILE_PLACEMENT_V1    1

//
// These constants are used to determine the default log file size.
//

#define PrimaryLogFileGrowthRate     100           /* 1% of volume size */
#define SecondaryLogFileGrowthRate   200           /* 0.5% of volume size */

#define MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate (400UL*1024*1024)   // 400 MB

#define MaximumLogFileSize        MAXULONG      /* ~ 4 GB */
#define MaximumInitialLogFileSize 0x4000000    /* 64 MB */
#define MinimumLogFileSize        0x200000      /* 2 MB */
#define LogFileAlignmentMask      0x3FFF

VOID
NTFS_LOG_FILE::Construct(
        )
/*++

Routine Description:

    Worker function for the constructor.

Arguments:

        None.

Return Value:

        None.

--*/
{
}

UNTFS_EXPORT
NTFS_LOG_FILE::~NTFS_LOG_FILE(
    )
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_LOG_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes the log file object.

Arguments:

    Mft --  Supplies the volume MasterFileTable.

Return Value:

    TRUE upon successful completion.

--*/
{
    return( NTFS_FILE_RECORD_SEGMENT::Initialize( LOG_FILE_NUMBER,
                                                  Mft ) );

}



BOOLEAN
NTFS_LOG_FILE::Create(
    IN     PCSTANDARD_INFORMATION   StandardInformation,
    IN     LCN                      NearLcn,
    IN     ULONG                    InitialSize,
    IN OUT PNTFS_BITMAP             VolumeBitmap
    )
/*++

Routine Description:

    This method creates the Log File.  It allocates space for
    the $DATA attribute, fills it with LogFileFillCharacter
    (defined in logfile.hxx).

Arguments:

    StandardInformation --  Supplies the standard file information.
    NearLcn             --  Supplies an LCN near where the $DATA
                            attribute should be located.
    InitialSize         --  Supplies the initial size of the $DATA
                            attribute.  If the client passes in
                            zero, this routine will choose a default
                            size.
    VolumeBitmap        --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

--*/
{
    // If the client passed in zero for initial size, calculate
    // the default initial size.
    //
    if( InitialSize == 0 ) {

        InitialSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    // Create the FRS and add the data attribute.
    //
    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ||
        !CreateDataAttribute( NearLcn, InitialSize, VolumeBitmap )
        ) {

        return FALSE;
    }

    if (IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE)) {
        DebugPrintTrace(("UNTFS: Data attribute of logfile is too fragmented that an attribute list is formed\n"));
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_LOG_FILE::CreateDataAttribute(
    IN     LCN          NearLcn,
    IN     ULONG        InitialSize OPTIONAL,
    IN OUT PNTFS_BITMAP VolumeBitmap
    )
/*++

Routine Description:

    This methods creates the log file's $DATA attribute.

Arguments:

    NearLcn             --  Supplies an LCN near where the $DATA
                            attribute should be located.
    InitialSize         --  Supplies the initial size of the $DATA
                            attribute.  If the client passes in
                            zero, this routine will choose a default
                            size.
    VolumeBitmap        --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    This routine may not be multithread safe as it is calling
    SetNextAlloc() to be used by AddDataAttribute().

--*/
{
    ULONG   ClusterSize, ClustersInData;

    // If the client passed in zero for initial size, calculate
    // the default initial size.
    //
    if( InitialSize == 0 ) {

        InitialSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    // Make sure that the file size is a multiple of cluster size:
    //
    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    if( InitialSize % ClusterSize ) {

        ClustersInData = InitialSize / ClusterSize + 1;
        InitialSize = ClustersInData * ClusterSize;
    }
#if LOGFILE_PLACEMENT_V1

    else {
        ClustersInData = InitialSize / ClusterSize;
    }

    if (NearLcn != 0) {
        VolumeBitmap->SetNextAlloc(NearLcn - ClustersInData);
    }
#endif

    // Add the data attribute.
    //
    return( AddDataAttribute( InitialSize,
                              VolumeBitmap,
                              TRUE,
                              LogFileFillCharacter ) );

}


BOOLEAN
NTFS_LOG_FILE::MarkVolumeChecked(
    )
/*++

Routine Description:

    This method sets the signature in the log file to indicate
    that the volume has been checked.  This signature supports
    version 1.0 logfiles--ie. does not write the signature at
    the beginning of the second page, and does not record the
    greatest LSN.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    LSN     NullLsn;

    NullLsn.LowPart = 0;
    NullLsn.HighPart = 0;

    return( MarkVolumeChecked( FALSE, NullLsn ) );
}



BOOLEAN
NTFS_LOG_FILE::MarkVolumeChecked(
    BOOLEAN WriteSecondPage,
    LSN     GreatestLsn
    )
/*++

Routine Description:

    This method sets the signature in the log file to indicate
    that the volume has been checked.

Arguments:

    WriteSecondPage --  Supplies a flag which, if TRUE, indicates
                        that the checked signature should also be
                        written at the beginning of the second page
                        of the file, and the greatest LSN on the
                        volume should be recorded.

    GreatestLsn     --  Supplies the greatest LSN encountered on
                        the volume.  Ignored if WriteSecondPage is
                        FALSE.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    UCHAR Signature[LogFileSignatureLength];
    LSN SignatureAndLsn[2];
    ULONG BytesTransferred;
    BOOLEAN Error;
    ULONG i, PageSize;

    // Fetch the data attribute:
    //
    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ) {

        return FALSE;
    }

    // If the data attribute is resident, the volume is corrupt:
    //
    if( DataAttribute.IsResident() ) {

        DbgPrint( "UNTFS: Log File $DATA attribute is resident.\n" );
        return FALSE;
    }

    // Read the old signature--it's at offset zero in the $DATA
    // attribute, with a length of LogFileSignatureLength bytes.
    //
    if( !DataAttribute.Read( Signature,
                             0,
                             LogFileSignatureLength,
                             &BytesTransferred ) ||
        BytesTransferred != LogFileSignatureLength ) {

        DbgPrint( "UNTFS: Can't read log file signature.\n" );
        return FALSE;
    }

    if( !WriteSecondPage ) {

        DebugAssert(FALSE);

        // The client just wants the first signature.
        //
        memcpy( Signature,
                LOG_FILE_SIGNATURE_CHECKED,
                LogFileSignatureLength );

        if( !DataAttribute.Write( Signature,
                                  0,
                                  LogFileSignatureLength,
                                  &BytesTransferred,
                                  NULL ) ||
            BytesTransferred != LogFileSignatureLength ) {

            return FALSE;
        }

    } else {

        // The client wants us to write the signature and LSN at
        // the beginning of the first two pages.
        //
        PageSize = IFS_SYSTEM::QueryPageSize();

        if( PageSize == 0 ||
            CompareLT(DataAttribute.QueryValidDataLength(),
                      PageSize + sizeof( SignatureAndLsn )) ) {

            return FALSE;
        }

        memset( SignatureAndLsn, 0, sizeof(SignatureAndLsn) );

        memcpy( SignatureAndLsn,
                LOG_FILE_SIGNATURE_CHECKED,
                LogFileSignatureLength );

        SignatureAndLsn[1] = GreatestLsn;

        for( i = 0; i < 2; i++ ) {

            if( !DataAttribute.Write( SignatureAndLsn,
                                      PageSize * i,
                                      sizeof( SignatureAndLsn ),
                                      &BytesTransferred,
                                      NULL ) ||
                BytesTransferred != sizeof( SignatureAndLsn ) ) {

                DebugPrintTrace(("UNTFS: Unable to write out logfile signature & lsn\n"));
                return FALSE;
            }
        }
    }

    // Since we didn't modify the storage of the attribute, we don't
    // need to save it.
    //
    return TRUE;
}


BOOLEAN
NTFS_LOG_FILE::Reset(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method resets the Log File by filling it with
    the LogFileFillCharacter (0xFF).

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

    Note that, since the Log File's $DATA attribute is always
    non-resident and is never sparse, resetting the log file
    does not change the data attribute's Attribute Record or
    the Log File's File Record Segment

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    BOOLEAN Error;

    Message->DisplayMsg( MSG_CHK_NTFS_RESETTING_LOG_FILE );

    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ||
        !DataAttribute.Fill( 0, LogFileFillCharacter ) ) {

        Message->DisplayMsg( MSG_CHK_NO_MEMORY );
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_LOG_FILE::Resize(
    IN      BIG_INT         NewSize,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      BOOLEAN         GetWhatYouCan,
    OUT     PBOOLEAN        Changed,
    OUT     PBOOLEAN        LogFileGrew,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This method resizes an existing log file.  It does not change
    the value of the remaining contents.

Arguments:

    NewSize         --  Supplies the new size of the log file's data
                        attribute, in bytes.  Zero means resize to the
                        default size.
    VolumeBitmap    --  Supplies the bitmap for the volume on which
                        the log file resides.
    GetWhatYouCan   --  Supplies a flag that indicates the method
                        should allocate as much of the requested
                        space as possible; if this value is FALSE,
                        this method will fail if it cannot make the
                        log file the requested size.
    Changed         --  Receives TRUE if the log file's size was changed
                        by this operation.
    LogFileGrew     --  Receives TRUE if the log file was made larger
                        by this operation.
    Message         --  Supplies an outlet for messages.

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    BIG_INT OldSize;
    BOOLEAN Error;

    if (NewSize == 0) {

        NewSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    if (!QueryAttribute( &DataAttribute, &Error, $DATA )) {

        return FALSE;
    }

    if (NewSize == DataAttribute.QueryValueLength()) {

        *Changed = FALSE;
        return TRUE;
    }

    if (IsAttributeListPresent()) {
        Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST_PRESENT );
        return FALSE;
    }

    Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE );

    OldSize = DataAttribute.QueryValueLength();

    *LogFileGrew = (NewSize > OldSize);


#if 0   // fragment the disk for debugging purpose
    ULONG   i;
    for (i = 0; i < 0x1f400*8; i += 2) {
        if (VolumeBitmap->IsFree(i, 1))
            VolumeBitmap->SetAllocated(i, 1);
    }
#endif

    if( !DataAttribute.Resize( NewSize, VolumeBitmap )       ||
        !DataAttribute.Fill( OldSize, LogFileFillCharacter ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        *Changed = FALSE;
        return FALSE;
    }

    if (IsAttributeListPresent()) {

        Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST );

        if (!DataAttribute.Resize( OldSize, VolumeBitmap ) ||
            !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ||
            !PurgeAttributeList()) {

            *Changed = FALSE;
            return FALSE;
        }

    }

    *Changed = TRUE;
    return TRUE;
}


BOOLEAN
NTFS_LOG_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN OUT  PNTFS_CHKDSK_REPORT ChkdskReport,
    IN      FIX_LEVEL           FixLevel,
    IN      BOOLEAN             Resize,
    IN      ULONG               LogFileSize,
    IN OUT  PNUMBER_SET         BadClusters,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures the validity of the log file; it should have
    a valid file name and standard information, and its size should be
    within reasonable limits.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    ChkdskReport    - Supplies the current chkdsk report.
    FixLevel        - Supplies the fix up level.
    Resize          - Supplies a flag indicating whether the log file
                      should be resized.
    LogFileSize     - If Resize is set, then LogFileSize supplies the
                      new size of the logfile.  If zero, the logfile will be
                      resized to the default size.
    BadClusters     - Supplies the current list of bad clusters.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE  data_attribute;
    BIG_INT         old_size;
    BOOLEAN         error, has_external;
    ULONG           default_size, max_size;
    BIG_INT         freeSectorSize;
    BIG_INT         bytes_recovered;
    BIG_INT         bad_clusters_count;
    BOOLEAN         bad_clusters_found;

    // The logfile should not have an attribute list, and the data
    // attribute should be non-resident and of a reasonable size.
    //

    error = *Changes = has_external = FALSE;

    if (QueryAttribute(&data_attribute, &error, $DATA) &&
        !data_attribute.IsResident()) {

        // If the log file has an attribute list, resize the
        // data attribute to zero and recreate it to force
        // it to be non-external.
        //

        old_size = data_attribute.QueryValueLength();

        default_size = QueryDefaultSize(GetDrive(), QueryVolumeSectors());
        max_size = QueryMaximumSize(GetDrive(), QueryVolumeSectors());

        DebugAssert(data_attribute.QueryValueLength().GetHighPart() == 0);

        if (Resize) {
            if (LogFileSize > max_size) {

                Message->DisplayMsg( MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG );
                ChkdskReport->BytesLogFile = old_size;
                return TRUE;

            } else if (LogFileSize < MinimumLogFileSize) {

                Message->DisplayMsg( MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_SMALL );
                ChkdskReport->BytesLogFile = old_size;
                return TRUE;

            } else if (LogFileSize > old_size) {

                freeSectorSize = VolumeBitmap->QueryFreeClusters() * QueryClusterFactor();
                if (((LogFileSize-old_size-1)/GetDrive()->QuerySectorSize()+1) > freeSectorSize) {
                    Message->DisplayMsg(MSG_CHK_NTFS_OUT_OF_SPACE_FOR_SPECIFIED_LOGFILE_SIZE);
                    ChkdskReport->BytesLogFile = old_size;
                    return TRUE;
                }
            }
        } else {
            LogFileSize = default_size;
            if (old_size < MinimumLogFileSize) {

                Resize = TRUE;
                freeSectorSize = VolumeBitmap->QueryFreeClusters() * QueryClusterFactor();
                if (((LogFileSize-old_size-1)/GetDrive()->QuerySectorSize()+1) > freeSectorSize) {
                    Message->DisplayMsg(MSG_CHK_NTFS_OUT_OF_SPACE_TO_ENLARGE_LOGFILE_TO_DEFAULT_SIZE);
                    ChkdskReport->BytesLogFile = old_size;
                    return TRUE;
                }

            } else if (old_size > max_size) {

                Resize = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SIZE_TOO_BIG);
            }
        }

        bad_clusters_count = BadClusters->QueryCardinality();

        if (!data_attribute.RecoverAttribute(VolumeBitmap,
                                             BadClusters,
                                             &bytes_recovered)) {
            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }

        bad_clusters_found = (BadClusters->QueryCardinality() != bad_clusters_count);

        if (IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE)) {

            Message->DisplayMsg(MSG_CHK_NTFS_ATTR_LIST_IN_LOG_FILE);

            *Changes = TRUE;

            has_external = TRUE;

            bad_clusters_found = FALSE;

            if (FixLevel != CheckOnly &&
                (!data_attribute.Resize(0, VolumeBitmap) ||
                 !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
                 !Flush(VolumeBitmap, RootIndex) ||
                 !PurgeAttributeList() ||
                 !Flush(VolumeBitmap, RootIndex))) {

                // The log file is corrupt, and we can't fix it.
                //

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                return FALSE;
            }
        }

        if (has_external || Resize || bad_clusters_found) {

            //  The data attribute's size is out-of-bounds.  Resize it to
            //  the default size.
            //

            *Changes = TRUE;

            if (Resize) {
                Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE);
            }

            if (bad_clusters_found) {
                Message->DisplayMsg(MSG_CHK_NTFS_BAD_CLUSTERS_IN_LOG_FILE);
            }

            if (FixLevel != CheckOnly) {

#if 0   // fragment the disk for debugging purpose
                ULONG   i;
                for (i = 0; i < 0x1f400*8; i += 2) {
                    if (VolumeBitmap->IsFree(i, 1))
                        VolumeBitmap->SetAllocated(i, 1);
                }
#endif

                if (!data_attribute.Resize(LogFileSize, VolumeBitmap) ||
                    !data_attribute.Fill(0, LogFileFillCharacter) ||
                    !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
                    !Flush(VolumeBitmap, RootIndex)) {

                    if (has_external) {

                        // The log file is corrupt, and we can't fix it.
                        //

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                        return FALSE;

                    } else {

                        // Print a warning message, but still return success.
                        //

                        Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);

                        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
                        return TRUE;
                    }
                }

                if (IsAttributeListPresent()) {

                    if (old_size < MinimumLogFileSize)
                        old_size = MinimumLogFileSize;

                    Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST );

                    while (IsAttributeListPresent()) {

                        if (0 == old_size) {
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                            return FALSE;
                        }

                        if (!data_attribute.Resize( 0, VolumeBitmap ) ||
                            !data_attribute.InsertIntoFile( this, VolumeBitmap ) ||
                            !Flush(VolumeBitmap) ||
                            !PurgeAttributeList() ||
                            !data_attribute.Resize( old_size, VolumeBitmap ) ||
                            !data_attribute.Fill( old_size - 1, LogFileFillCharacter ) ||
                            !data_attribute.InsertIntoFile( this, VolumeBitmap )) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                            return FALSE;
                        }

                        old_size = old_size / 2;

                    }

                    if (!data_attribute.Fill(0, LogFileFillCharacter) ||
                        !Flush(VolumeBitmap, RootIndex)) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                        return FALSE;
                    }
                }
            }
        }

        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
        return TRUE;
    }

    if (error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OR_RESIDENT_DATA_ATTR_IN_LOG_FILE);

    *Changes = TRUE;

    Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_LOG_FILE);

    // Recreate the $DATA attribute.
    //

    if (FixLevel != CheckOnly) {

        // NTRAID#91401-2000/03/07 - danielch - Potential attribute list can be created here

        if (!CreateDataAttribute(0, 0, VolumeBitmap) ||
            !Flush(VolumeBitmap, RootIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
            return FALSE;
        }
    }

    if (QueryAttribute(&data_attribute, &error, $DATA)) {

        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
    } else {

        ChkdskReport->BytesLogFile = 0;
    }

    return TRUE;
}

ULONG
NTFS_LOG_FILE::QueryDefaultSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the appropriate default log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The appropriate default log file size for the drive.

--*/
{
    BIG_INT InitialSize, VolumeSize;
    ULONG   FinalSize;

    if (VolumeSectors.GetHighPart() != 0) {

        FinalSize = MaximumInitialLogFileSize;

    } else {

        VolumeSize = VolumeSectors * Drive->QuerySectorSize();

        if (VolumeSize <= (400UL * 1024UL * 1024UL)) {

            InitialSize = (VolumeSize / PrimaryLogFileGrowthRate);

            if (InitialSize < MinimumLogFileSize)
                InitialSize = MinimumLogFileSize;

        } else {

            VolumeSize = VolumeSize - MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate;

            InitialSize = VolumeSize/SecondaryLogFileGrowthRate +
                          MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate/
                          PrimaryLogFileGrowthRate;

            if (InitialSize > MaximumInitialLogFileSize)
                InitialSize = MaximumInitialLogFileSize;
        }

        FinalSize = (InitialSize + LogFileAlignmentMask).GetLowPart() & ~LogFileAlignmentMask;
    }

    return FinalSize;
}

ULONG
NTFS_LOG_FILE::QueryMinimumSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the minimum log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The minimum log file size for the drive.

--*/
{
    UNREFERENCED_PARAMETER(Drive);
    UNREFERENCED_PARAMETER(VolumeSectors);

    return MinimumLogFileSize;
}

ULONG
NTFS_LOG_FILE::QueryMaximumSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the maximum log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The maximum log file size for the drive.

--*/
{
    UNREFERENCED_PARAMETER(Drive);
    UNREFERENCED_PARAMETER(VolumeSectors);

    return MaximumLogFileSize;
}


BOOLEAN
NTFS_LOG_FILE::EnsureCleanShutdown(
    OUT PLSN        Lsn
    )
/*++

Routine Description:

    This method looks at the logfile to verify that the volume
    was shut down cleanly.  If we can't read the logfile well
    enough to say for sure, we assume that it was not shut down
    cleanly.

Arguments:

    Lsn         - Retrieves the last lsn in the restart area

Return Value:

    TRUE        - The volume was shut down cleanly.
    FALSE       - The volume was not shut down cleanly.

--*/
{
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     error;
    ULONG                       nbyte;
    PLFS_RESTART_PAGE_HEADER    header;
    PLFS_RESTART_AREA           restarea;
    PBYTE                       buf;
    BOOLEAN                     r = TRUE;

    // Read the logfile contents to make sure the volume was shut
    // down cleanly.  If it wasn't generate an error message for
    // the user and bail.  Also generate an error if the logfile's
    // data isn't big enough to contain an indication of whether it
    // was cleanly shut down or not.
    //

    if (!QueryAttribute(&attrib, &error, $DATA)) {

        DebugPrintTrace(("UNTFS: Could not query logfile data\n"));
        return FALSE;
    }

    if (attrib.QueryValueLength() < IFS_SYSTEM::QueryPageSize()) {

        DebugPrintTrace(("UNTFS: LogFile too small to hold restart area\n"));
        return FALSE;
    }

    if (NULL == (buf = NEW BYTE[IFS_SYSTEM::QueryPageSize()])) {

        DebugPrintTrace(("UNTFS: Out of memory\n"));
        return FALSE;
    }

    if (!attrib.Read(buf, 0, IFS_SYSTEM::QueryPageSize(), &nbyte) ||
        nbyte != IFS_SYSTEM::QueryPageSize()) {

        DebugPrintTrace(("UNTFS: Unable to read logfile\n"));
        delete[] buf;
        return FALSE;
    }

    header = PLFS_RESTART_PAGE_HEADER(buf);

    if (0xffff == header->RestartOffset) {

        DebugPrintTrace(("UNTFS: Invalid restart offset\n"));
        delete[] buf;
        return FALSE;
    }

    restarea = PLFS_RESTART_AREA(buf + header->RestartOffset);


    *Lsn = restarea->CurrentLsn;
    // DebugPrintTrace(("UNTFS: Lsn value %I64x at offset %x\n", *Lsn, header->RestartOffset));

    if (!(restarea->Flags & LFS_CLEAN_SHUTDOWN)) {
        DebugPrintTrace(("UNTFS: LFS_CLEAN_SHUTDOWN flag not on %x\n", restarea->Flags));
        // r = FALSE;
    }

    delete[] buf;

    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\indxtree.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    indxtree.cxx

Abstract:

    This module contains the member function definitions for the
    NTFS_INDEX_TREE class, which models index trees on an NTFS
    volume.

    An NTFS Index Tree consists of an index root and a set of
    index buffers.  The index root is stored as the value of
    an INDEX_ROOT attribute; the index buffers are part of the
    value of an INDEX_ALLOCATION attribute.

Author:

    Bill McJohn (billmc) 19-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "indxtree.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "ntfsbit.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"

CONST USHORT IndexEntryAttributeLength[] = { 4, 8, 12, 16 };

LONG
CompareNtfsFileNames(
    IN PCFILE_NAME          Name1,
    IN PCFILE_NAME          Name2,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This method compares two FILE_NAME structures according to the
    COLLATION_FILE_NAME collation rule.

Arguments:

    Name1       --  Supplies the first name to compare.
    Name2       --  Supplies the second name to compare.
    UpcaseTable --  Supplies the volume upcase table.

Returns:

    <0 if Name1 is less than Name2
    =0 if Name1 is equal to Name2
    >0 if Name1 is greater than Name2.

--*/
{
    LONG Result;

    Result = NtfsUpcaseCompare( NtfsFileNameGetName( Name1 ),
                                Name1->FileNameLength,
                                NtfsFileNameGetName( Name2 ),
                                Name2->FileNameLength,
                                UpcaseTable,
                                TRUE );

    return Result;
}

LONG
NtfsCollate(
    IN PCVOID               Value1,
    IN ULONG                Length1,
    IN PCVOID               Value2,
    IN ULONG                Length2,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This function compares two values according to an NTFS
    collation rule.

Arguments:

    Value1          --  Supplies the first value.
    Length1         --  Supplies the length of the first value.
    Value2          --  Supplies the second value.
    Length2         --  Supplies the length of the second value.
    CollationRule   --  Supplies the rule used for collation.
    UpcaseTable     --  Supplies the volume upcase table.  (May be NULL
                        if the collatio rule is not COLLATION_FILE_NAME).

Return Value:

    <0 if Entry1 is less than Entry2 by CollationRule
     0 if Entry1 is equal to Entry2 by CollationRule
    >0 if Entry1 is greater than Entry2 by CollationRule

Notes:

    The upcase table is only required for comparing file names.

    If two values are compared according to an unsupported collation
    rule, they are always treated as equal.

--*/
{
    LONG result;

    switch( CollationRule ) {

    case COLLATION_BINARY :

        // Binary collation of the values.
        //
        result = memcmp( Value1,
                         Value2,
                         MIN( Length1, Length2 ) );

        if( result != 0 ) {

            return result;

        } else {

            return( Length1 - Length2 );
        }

    case COLLATION_FILE_NAME :

        return CompareNtfsFileNames( (PFILE_NAME)Value1,
                                     (PFILE_NAME)Value2,
                                     UpcaseTable );


    case COLLATION_UNICODE_STRING :

        // unsupported collation rule.
        //
        return 0;

    case COLLATION_ULONG:

        // Unsigned long collation

        DebugAssert(Length1 == sizeof(ULONG));
        DebugAssert(Length1 == sizeof(ULONG));

        if (*(ULONG*)Value1 < *(ULONG *)Value2)
            return -1;
        else if (*(ULONG*)Value1 > *(ULONG *)Value2)
            return 1;
        else
            return 0;

    case COLLATION_SID:

        // SecurityId collation

        result = memcmp(&Length1, &Length2, sizeof(Length1));
        if (result != 0)
            return result;

        result = memcmp( Value1, Value2, Length1 );
        return result;

    case COLLATION_SECURITY_HASH: {

        // Security Hash (Hash key and SecurityId) Collation

        PSECURITY_HASH_KEY HashKey1 = (PSECURITY_HASH_KEY)Value1;
        PSECURITY_HASH_KEY HashKey2 = (PSECURITY_HASH_KEY)Value2;

        DebugAssert(Length1 == sizeof(SECURITY_HASH_KEY));
        DebugAssert(Length2 == sizeof(SECURITY_HASH_KEY));

        if (HashKey1->Hash < HashKey2->Hash)
            return -1;
        else if (HashKey1->Hash > HashKey2->Hash)
            return 1;
        else if (HashKey1->SecurityId < HashKey2->SecurityId)
            return -1;
        else if (HashKey1->SecurityId > HashKey2->SecurityId)
            return 1;
        else
            return 0;
    }

    case COLLATION_ULONGS: {
        PULONG pu1, pu2;
        ULONG count;

        result = 0;

        DebugAssert( (Length1 & 3) == 0 );
        DebugAssert( (Length2 & 3) == 0 );

        count = Length1;
        if (count != Length2) {
           result = -1;
           if (count > Length2) {
               count = Length2;
               result = 1;
           }
        }

        pu1 = (PULONG)Value1;
        pu2 = (PULONG)Value2;

        while (count > 0) {
           if (*pu1 > *pu2) {
               return 1;
           } else if (*(pu1++) < *(pu2++)) {
               return -1;
           }
           count -= 4;
        }
        return result;
    }

    default:

        DebugAbort( "Unsupported collation rule.\n" );
        return 0;
    }
}




LONG
CompareNtfsIndexEntries(
    IN PCINDEX_ENTRY    Entry1,
    IN PCINDEX_ENTRY    Entry2,
    IN COLLATION_RULE   CollationRule,
    IN PNTFS_UPCASE_TABLE UpcaseTable
    )
/*++

Routine Description:

    This global function is used to compare index entries.

Arguments:

    Entry1          --  Supplies the first entry to compare.
    Entry2          --  Supplies the second entry to compare.
    CollationRule   --  Supplies the rule used for collation.
    UpcaseTable     --  Supplies the volume upcase table.

Return Value:

    <0 if Entry1 is less than Entry2 by CollationRule
     0 if Entry1 is equal to Entry2 by CollationRule
    >0 if Entry1 is greater than Entry2 by CollationRule

Notes:

    The upcase table is only required for comparing file names.

--*/
{
    return NtfsCollate( GetIndexEntryValue( Entry1 ),
                        Entry1->AttributeLength,
                        GetIndexEntryValue( Entry2 ),
                        Entry2->AttributeLength,
                        CollationRule,
                        UpcaseTable );
}



DEFINE_EXPORTED_CONSTRUCTOR( NTFS_INDEX_TREE, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_INDEX_TREE::~NTFS_INDEX_TREE(
    )
{
    Destroy();
}

VOID
NTFS_INDEX_TREE::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Drive = NULL;
    _ClusterFactor = 0;
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _VolumeBitmap = NULL;
    _UpcaseTable = NULL;
    _AllocationAttribute = NULL;
    _IndexAllocationBitmap = NULL;
    _IndexRoot = NULL;
    _Name = NULL;

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentEntry = NULL;
    _CurrentBuffer = NULL;
    _CurrentKey = NULL;
    _CurrentKeyLength = 0;
}

VOID
NTFS_INDEX_TREE::Destroy(
    )
/*++

Routine Description:

    This method cleans up an NTFS_INDEX_TREE object in preparation
    for destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Drive = NULL;
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _VolumeBitmap = NULL;
    _UpcaseTable = NULL;

    DELETE( _AllocationAttribute );
    DELETE( _IndexAllocationBitmap );
    DELETE( _IndexRoot );
    DELETE( _Name );

    _IteratorState = INDEX_ITERATOR_RESET;

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );
    FREE( _CurrentKey );

    _CurrentKeyLength = 0;
}



UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Initialize(
    IN OUT PLOG_IO_DP_DRIVE             Drive,
    IN     ULONG                        ClusterFactor,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    IN     PNTFS_UPCASE_TABLE           UpcaseTable,
    IN     ULONG                        MaximumRootSize,
    IN     PNTFS_FILE_RECORD_SEGMENT    SourceFrs,
    IN     PCWSTRING                    IndexName
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_TREE based on
    attributes queried from a File Record Segment.

Arguments:

    Drive               --  supplies the drive on which the
                                index resides.
    ClusterFactor       --  supplies the cluster factor for the drive.
    VolumeBitmap        --  supplies the volume bitmap.
    MaximumRootSize     --  supplies the maximum length of the index root
    SourceFrs           --  supplies the File Record Segment that contains
                            this index.
    UpcaseTable         --  supplies the volume upcase table.
    IndexName           --  supplies the name for this index.  (May be NULL,
                            in which case the index has no name.)

Return Value:

    TRUE upon successful completion.

Notes:

    SourceFrs must have an $INDEX_ROOT attribute, or this method will
    fail.

    The index tree does not remember what File Record Segment it came
    from; it only uses the FRS as a place to get the index root and
    index allocation attributes.

    The volume upcase table is only required if the indexed attribute
    type code is $FILE_NAME.

--*/
{
    NTFS_ATTRIBUTE RootAttribute;
    NTFS_ATTRIBUTE BitmapAttribute;

    BIG_INT ValueLength;
    ULONG NumberOfBuffers;
    BOOLEAN Error;

    Destroy();

    DebugAssert(0 != ClusterFactor);

    if( !SourceFrs->QueryAttribute( &RootAttribute,
                                    &Error,
                                    $INDEX_ROOT,
                                    IndexName ) ||
        (_IndexRoot = NEW NTFS_INDEX_ROOT) == NULL ||
        !_IndexRoot->Initialize( &RootAttribute,
                                 UpcaseTable,
                                 MaximumRootSize ) ) {

        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;
    _ClustersPerBuffer = _IndexRoot->QueryClustersPerBuffer();
    _BufferSize = _IndexRoot->QueryBufferSize();
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;

    DebugAssert(0 != _BufferSize);

    if( RootAttribute.GetName() != NULL &&
        ( (_Name = NEW DSTRING) == NULL ||
          !_Name->Initialize( RootAttribute.GetName() ) ) ) {

        Destroy();
        return FALSE;
    }

    _IndexedAttributeType = _IndexRoot->QueryIndexedAttributeType();
    _CollationRule = _IndexRoot->QueryCollationRule();

    if( SourceFrs->IsAttributePresent( $INDEX_ALLOCATION, IndexName ) ) {

        if( (_AllocationAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
            !SourceFrs->QueryAttribute( _AllocationAttribute,
                                        &Error,
                                        $INDEX_ALLOCATION,
                                        IndexName ) ) {

            Destroy();
            return FALSE;
        }

        // Set (ie. initialize and read) the bitmap associated with
        // the index allocation attribute.  Note that the bitmap
        // attribute's value may be larger than necessary to cover
        // the allocation attribute because the bitmap attribute's
        // value always grows in increments of eight bytes.  However,
        // at this point, we don't care, since we only worry about
        // that when we grow the bitmap.

        _AllocationAttribute->QueryValueLength( &ValueLength );

        DebugAssert( ValueLength % _BufferSize == 0 );

        NumberOfBuffers = ValueLength.GetLowPart()/_BufferSize;


        if( (_IndexAllocationBitmap = NEW NTFS_BITMAP) == NULL ||
            !_IndexAllocationBitmap->Initialize( NumberOfBuffers, TRUE ) ||
            !SourceFrs->QueryAttribute( &BitmapAttribute,
                                        &Error,
                                        $BITMAP,
                                        IndexName ) ||
            !_IndexAllocationBitmap->Read( &BitmapAttribute ) ) {

            Destroy();
            return FALSE;
        }
    }

    // Set up the buffer to support iteration.  This buffer must be
    // big enough to hold the largest key value.  The size of an
    // index allocation buffer will suffice.

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentKeyMaxLength = _BufferSize;

    if( (_CurrentKey = MALLOC( _CurrentKeyMaxLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    _CurrentKeyLength = 0;

    if( !_CurrentEntryTrail.Initialize() ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Initialize(
    IN      ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      COLLATION_RULE      CollationRule,
    IN      ULONG               BufferSize,
    IN      ULONG               MaximumRootSize,
    IN      PCWSTRING           IndexName
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_TREE based on its basic
    information.  It is used when creating an index.

Arguments:

    Drive                   --  supplies the drive on which the
                                index resides.
    VolumeBitmap            --  supplies the volume bitmap
    UpcaseTable             --  supplies the volume upcase table.
    IndexedAttributeType    --  supplies the attribute type code of the
                                attribute which is used as the key for
                                this index.
    CollationRule           --  supplies the collation rule for this index.
    BufferSize              --  supplies the size of each Index Buffer in this index.
    MaximumRootSize         --  supplies the maximum length of the index root
    IndexName               --  supplies the name of this index.  (May be
                                NULL, in which case the index has no name.)

Return Value:

    TRUE upon successful completion.

    The volume upcase table is only required if the indexed attribute
    type code is $FILE_NAME.

--*/
{
    ULONG   ClusterSize;

    Destroy();

    DebugAssert(0 != ClusterFactor);
    DebugPtrAssert(Drive);

    _Drive = Drive;
    _BufferSize = BufferSize;
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;
    _ClusterFactor = ClusterFactor;

    ClusterSize = Drive->QuerySectorSize()*ClusterFactor;

    DebugAssert(ClusterSize <= 64 * 1024);

    _ClustersPerBuffer = BufferSize / ((BufferSize < ClusterSize) ?
                                       NTFS_INDEX_BLOCK_SIZE : ClusterSize);

    if( IndexName != NULL &&
        ( (_Name = NEW DSTRING) == NULL ||
          !_Name->Initialize( IndexName ) ) ) {

        Destroy();
        return FALSE;
    }

    _IndexedAttributeType = IndexedAttributeType;
    _CollationRule = CollationRule;

    _AllocationAttribute = NULL;
    _IndexAllocationBitmap = NULL;

    if( (_IndexRoot = NEW NTFS_INDEX_ROOT) == NULL ||
        !_IndexRoot->Initialize( IndexedAttributeType,
                                 CollationRule,
                                 UpcaseTable,
                                 _ClustersPerBuffer,
                                 BufferSize,
                                 MaximumRootSize ) ) {

        Destroy();
        return FALSE;
    }


    // Set up the buffer to support iteration.  This buffer must be
    // big enough to hold the largest key value.  The size of an
    // index allocation buffer will suffice.

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentKeyMaxLength = BufferSize;

    if( (_CurrentKey = MALLOC( _CurrentKeyMaxLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    _CurrentKeyLength = 0;

    if( !_CurrentEntryTrail.Initialize() ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::QueryFileReference(
    IN  ULONG                   KeyLength,
    IN  PVOID                   Key,
    IN  ULONG                   Ordinal,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PBOOLEAN                Error
    )
/*++

Routine Description:

    This method determines the file which contains the specified
    value of the indexed attribute.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to return (zero indicates
                            return the first matching entry).
    SegmentReference    --  receives a segment reference to the Base File
                            Record Segment of the file which contains the
                            supplied value of the indexed attribute.
    Error               --  receives an indication of whether an
                            error (e.g. out of memory) occurred.

Return Value:

    TRUE upon successful completion.  In this case, the state of
    *Error is undefined.

    If the method fails because of a resource problem, it returns FALSE
    and sets *Error to TRUE.  If it fails because the index
    is invalid or because the search value is not in the index, then
    it returns FALSE and sets *Error to TRUE.  In either case,
    the contents of SegmentReference are undefined.

--*/
{
    INTSTACK ParentTrail;
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PINDEX_ENTRY FoundEntry;
    BOOLEAN Result;

    if( FindEntry( KeyLength,
                   Key,
                   Ordinal,
                   &FoundEntry,
                   &ContainingBuffer,
                   &ParentTrail ) ) {

        memcpy( SegmentReference,
                &FoundEntry->FileReference,
                sizeof( MFT_SEGMENT_REFERENCE ) );

        *Error = FALSE;
        Result = TRUE;

    } else {

        *Error = (FoundEntry == NULL);
        Result = FALSE;
    }

    if( ContainingBuffer != NULL ) {

        DELETE( ContainingBuffer );
    }

    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::QueryEntry(
    IN  ULONG               KeyLength,
    IN  PVOID               Key,
    IN  ULONG               Ordinal,
         OUT PINDEX_ENTRY*               FoundEntry,
    OUT PNTFS_INDEX_BUFFER* ContainingBuffer,
    OUT PBOOLEAN            Error
    )
/*++

Routine Description:

    This method returns the index entry that matches the given key.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to return (zero indicates
                            return the first matching entry).
    FoundEntry          --  Receives a pointer to the located entry
                            (NULL indicates error).
    Error               --  receives an indication of whether an
                            error (e.g. out of memory) occurred.

Return Value:

    TRUE upon successful completion.  In this case, the state of
    *Error is undefined.

    If the method fails because of a resource problem, it returns FALSE
    and sets *Error to TRUE.  If it fails because the index
    is invalid or because the search value is not in the index, then
    it returns FALSE and sets *Error to TRUE.  In either case,
    the contents of SegmentReference are undefined.

--*/
{
    INTSTACK ParentTrail;
    BOOLEAN Result;

    if( FindEntry( KeyLength,
                   Key,
                   Ordinal,
                   FoundEntry,
                   ContainingBuffer,
                   &ParentTrail ) ) {

        *Error = FALSE;
        Result = TRUE;

    } else {

        *Error = (FoundEntry == NULL);
        Result = FALSE;
    }

    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::InsertEntry(
    IN  ULONG                   KeyLength,
    IN  PVOID                   KeyValue,
    IN  MFT_SEGMENT_REFERENCE   FileReference,
    IN  BOOLEAN                 NoDuplicates
    )
/*++

Routine Description:

    This method inserts a new entry into the index given its
    value and segment reference.

Arguments:

    KeyLength           --  supplies the length of the key, in bytes.
    KeyValue            --  supplies the key value.
    SegmentReference    --  supplies the segment reference to the file
                            which contains the indexed attribute with
                            this key value.
    NoDuplicates        --  Supplies a flag which, if TRUE, indicates
                            that InsertEntry should fail if a matching
                            entry is already present in the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    PINDEX_ENTRY NewEntry;
    USHORT EntryLength;
    BOOLEAN Result;

    // Compute the length of the new entry:

    EntryLength = (USHORT)QuadAlign( sizeof(INDEX_ENTRY) + KeyLength );

    if( (NewEntry = (PINDEX_ENTRY)MALLOC( EntryLength )) == NULL ) {

        return FALSE;
    }

    memset( NewEntry, 0, EntryLength );

    NewEntry->FileReference = FileReference;
    NewEntry->Length = EntryLength;
    NewEntry->AttributeLength = (USHORT) KeyLength;
    NewEntry->Flags = 0;

    memcpy( (PBYTE)NewEntry + sizeof( INDEX_HEADER ),
            KeyValue,
            KeyLength );

    Result = InsertEntry( NewEntry, NoDuplicates );

    FREE( NewEntry );

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  BOOLEAN         NoDuplicates,
    IN  PBOOLEAN        Duplicate
    )
/*++

Routine Description:

    This method adds an entry to the index.

Arguments:

    NewEntry            -- supplies the new entry to add to the index.
    NoDuplicates        --  Supplies a flag which, if TRUE, indicates
                            that InsertEntry should fail if a matching
                            entry is already present in the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    INTSTACK ParentTrail;

    PNTFS_INDEX_BUFFER ContainingBuffer;
    PINDEX_ENTRY FoundEntry;
    ULONG Ordinal;
    BOOLEAN Found;
    BOOLEAN Result;
    BOOLEAN dup;

    if (Duplicate == NULL)
        Duplicate = &dup;

    // First, find the spot in the tree where we want to insert the
    // new entry.
    //
    // If the client does not allow duplicates, search for the first
    // matching entry--if we find a match, refuse the insert; if we
    // don't, FindEntry will find the insertion point for us.
    //
    // If the client does allow duplicates, call FindEntry with
    // a value INDEX_SKIP, which indicates all matching entries
    // should be skipped.  Thus, the new entry will be inserted
    // after all matching entries.
    //
    Ordinal = NoDuplicates ? 0 : (INDEX_SKIP);

    Found = FindEntry( NewEntry->AttributeLength,
                       GetIndexEntryValue( NewEntry ),
                       Ordinal,
                       &FoundEntry,
                       &ContainingBuffer,
                       &ParentTrail );

    *Duplicate = Found;

    if( Found && NoDuplicates ) {

        // A matching entry already exists, and the client wants
        // to fail in that case.  So fail.
        //

        if ( ContainingBuffer )
            DELETE( ContainingBuffer );

        return FALSE;
    }

    DebugAssert( !Found );

    // Since no matching entry was found, FindEntry will
    // return a leaf entry as its insertion point.  This
    // makes this  code a lot easier, since we only need
    // to handle inserting a new leaf.
    //
    if( FoundEntry == NULL ) {

        // An error occurred trying to insert the entry.

        return FALSE;
    }

    if( ContainingBuffer == NULL ) {

        // The root is also a leaf (see comment above), so we'll
        // insert the new entry into it.

        return( InsertIntoRoot( NewEntry, FoundEntry ) );

    } else {

        // We've found a leaf buffer, so we'll insert the new
        // entry into it.

        Result = InsertIntoBuffer( ContainingBuffer,
                                   &ParentTrail,
                                   NewEntry,
                                   FoundEntry );

        DELETE( ContainingBuffer );
        return Result;
    }
}



BOOLEAN
NTFS_INDEX_TREE::DeleteEntry(
    IN  ULONG   KeyLength,
    IN  PVOID   Key,
    IN  ULONG   Ordinal
    )
/*++

Routine Description:

    This method deletes an entry from the index.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to delete (zero indicates
                            return the first matching entry).

Return Value:

    TRUE upon successful completion.

    If no matching entry is found, this method returns TRUE (without
    changing the index in any way).  However, if an error occurs while
    searching for matching entries, then the method returns FALSE.

--*/
{
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PINDEX_ENTRY FoundEntry;
    BOOLEAN Result;
    INTSTACK ParentTrail;

    // Locate the entry to remove.

    if( !FindEntry( KeyLength,
                    Key,
                    Ordinal,
                    &FoundEntry,
                    &ContainingBuffer,
                    &ParentTrail ) ) {

        // There is no matching entry in the tree, so we don't have
        // to bother.  If no error occurred, return TRUE; otherwise,
        // return FALSE.

        DELETE( ContainingBuffer );
        return( FoundEntry != NULL );
    }

    // Call the common delete helper--this will remove the target
    // entry and, if necessary, find a replacement for it.

    Result = RemoveEntry( FoundEntry,
                          ContainingBuffer,
                          &ParentTrail );

    DELETE( ContainingBuffer );
    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Save(
    IN OUT PNTFS_FILE_RECORD_SEGMENT TargetFrs
    )
/*++

Routine Description:

    This method saves the index.  The root is saved as an INDEX_ROOT
    attribute in the target File Record Segment; the index allocation
    (if any) is saved as an INDEX_ALLOCATION attribute.

Arguments:

    TargetFrs   --  supplies the File Record Segment in which to save
                    the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE RootAttribute;
    NTFS_ATTRIBUTE BitmapAttribute;

    BOOLEAN Error;

    DebugAssert( ( _IndexAllocationBitmap == NULL &&
                 _AllocationAttribute == NULL ) ||
               ( _IndexAllocationBitmap != NULL &&
                 _AllocationAttribute != NULL ) );



    // Fetch or create attributes for the Index Root and (if necessary)
    // the allocation bitmap.  If either is to be newly created, make
    // it resident with zero length (since writing it it resize it
    // appropriately).

    if( !TargetFrs->QueryAttribute( &RootAttribute,
                                    &Error,
                                    $INDEX_ROOT,
                                    _Name ) &&
        ( Error ||
          !RootAttribute.Initialize( _Drive,
                                       _ClusterFactor,
                                       NULL,
                                       0,
                                       $INDEX_ROOT,
                                       _Name ) ) ) {

        return FALSE;
    }

    if( _IndexAllocationBitmap != NULL &&
        !TargetFrs->QueryAttribute( &BitmapAttribute,
                                    &Error,
                                    $BITMAP,
                                    _Name ) &&
        ( Error ||
          !BitmapAttribute.Initialize( _Drive,
                                       _ClusterFactor,
                                       NULL,
                                       0,
                                       $BITMAP,
                                       _Name ))) {

        return FALSE;
    }

    // If this tree does not have an allocation attribute, purge
    // any existing stale allocation & bitmap attributes.
    //
    if( _AllocationAttribute == NULL &&
        (!TargetFrs->PurgeAttribute( $INDEX_ALLOCATION, _Name ) ||
         !TargetFrs->PurgeAttribute( $BITMAP, _Name )) ) {

        return FALSE;
    }


    // Now save the attributes that describe this tree.
    //
    if( !_IndexRoot->Write( &RootAttribute ) ||
        !RootAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap ) ) {

        return FALSE;
    }


    if( _AllocationAttribute == NULL ) {
        return TRUE;
    }

    if( !_IndexAllocationBitmap->Write( &BitmapAttribute, _VolumeBitmap )) {
        DebugPrint("UNTFS: Could not write index allocation bitmap\n");
        return FALSE;
    }

    if( !BitmapAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap )) {

        DebugPrint("UNTFS: Could not insert bitmap attribute\n");

        //  Try a second time after making sure the attribute is non-resident.
        //

        if( !BitmapAttribute.MakeNonresident( _VolumeBitmap ) ||
            !BitmapAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap )) {

            DebugPrint("UNTFS: Still could not insert bitmap attr.\n");
            return FALSE;
        }
    }

    if( !_AllocationAttribute->InsertIntoFile( TargetFrs, _VolumeBitmap )) {

        DebugPrintTrace(("UNTFS: Could not insert allocation attribute\n"));
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::IsBadlyOrdered(
    OUT PBOOLEAN    Error,
    IN  BOOLEAN     DuplicatesAllowed
    )
/*++

Routine Description:

    This method traverses the index tree to determine whether it
    is badly-ordered.  A tree is well-ordered if it entries are
    in correct lexical order, all leaves appear at the same depth,
    and the tree has no empty leaf index allocation buffers.

Arguments:

    Error             --  Receives TRUE if this method fails because of
                          an error.
    DuplicatesAllowed --  Supplies a flag which indicates, if TRUE,
                          that this index may have duplicate entries.
                          Otherwise, if duplicate entries exist, the
                          tree is badly ordered.

Return Value:

    TRUE if the tree is found to be badly ordered.  (In this case,
    *Error should be ignored.)

    If this method returns FALSE and *Error is FALSE, then the tree
    is well-ordered.  If *Error is TRUE, this method was unable to
    determine whether the tree is well-ordered.

--*/
{
    BOOLEAN LeafFound, Result, FirstEntry, PreviousWasNode;
    ULONG LeafDepth, CurrentDepth;
    PINDEX_ENTRY PreviousEntry;
    PINDEX_ENTRY CurrentEntry;

    DebugAssert( Error );

    // Allocate a buffer to hold the previous entry:

    if( (PreviousEntry =
            (PINDEX_ENTRY)MALLOC( QueryMaximumEntrySize() )) == NULL ) {

        *Error = TRUE;
        return FALSE;
    }

    ResetIterator();

    FirstEntry = TRUE;
    PreviousWasNode = FALSE;
    LeafFound = FALSE;
    Result = FALSE;
    *Error = FALSE;

    while( (CurrentEntry = (PINDEX_ENTRY)GetNext( &CurrentDepth, Error, FALSE )) != NULL &&
           !*Error &&
           !Result ) {

        // Compare the current entry to the previous entry.  If duplicates
        // are not allowed, the currrent entry must be strictly greater
        // than the previous; otherwise, it must be greater than or equal
        // to the previous.
        //
        if( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            if( FirstEntry ) {

                // This entry is the first in the index; don't compare
                // it to the previous entry.
                //
                FirstEntry = FALSE;

            } else if ( (!DuplicatesAllowed &&
                         CompareNtfsIndexEntries( CurrentEntry,
                                                  PreviousEntry,
                                                  _CollationRule,
                                                  _UpcaseTable ) <= 0 ) ||
                        (DuplicatesAllowed &&
                         CompareNtfsIndexEntries( CurrentEntry,
                                                  PreviousEntry,
                                                  _CollationRule,
                                                  _UpcaseTable ) < 0 ) ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_ORDER);
                    msg->Log("%x%x", PreviousEntry->Length, CurrentEntry->Length);
                    msg->DumpDataToLog(PreviousEntry, min(0x100, PreviousEntry->Length));
                    msg->Set(MSG_CHKLOG_NTFS_DIVIDER);
                    msg->Log();
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                // The tree is badly ordered.
                //
                Result = TRUE;
                break;
            }

        } else if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ) {

            // This is an end leaf entry.  If it's the first
            // entry in the tree and not in the root, then
            // it's in an empty index allocation buffer, which
            // means the tree is badly ordered.  Similarly, if
            // the previous entry was a node, then this entry is
            // in an empty index allocation block, which means
            // the tree is badly ordered.
            //

            if( FirstEntry && CurrentDepth != 0 ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_FIRST_INDEX_ENTRY_IS_LEAF_BUT_NOT_AT_ROOT);
                    msg->Log("%x", CurrentEntry->Length);
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                Result = TRUE;
                break;
            }

            if( PreviousWasNode ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_EMPTY_INDEX_BUFFER);
                    msg->Log("%x", CurrentEntry->Length);
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                Result = TRUE;
                break;
            }
        }

        if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ) {

            // This is a leaf.  See if it's at the same depth as
            // the other leaves we've seen so far.
            //
            if( !LeafFound ) {

                // This is the first leaf.  Record its depth.
                //


                LeafFound = TRUE;
                LeafDepth = CurrentDepth;

            } else {

                if( CurrentDepth != LeafDepth ) {

                    // The leaves are not all at the same depth,
                    // which means this tree is badly ordered.
                    //
                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->Lock();
                        msg->Set(MSG_CHKLOG_NTFS_LEAF_DEPTH_NOT_THE_SAME);
                        msg->Log("%x%x%x", LeafDepth, CurrentDepth, CurrentEntry->Length);
                        msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                        msg->Unlock();
                    }

                    Result = TRUE;
                    break;
                }
            }

            PreviousWasNode = FALSE;

        } else if( GetDownpointer(CurrentEntry) == INVALID_VCN ) {

            // This entry has an invalid downpointer, so the
            // index is badly ordered.
            //
            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INVALID_DOWN_POINTER);
                msg->Log("%x", CurrentEntry->Length);
                msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                msg->Unlock();
            }

            Result = TRUE;
            break;

        } else {

            // Remember that we just saw a node entry.
            //
            PreviousWasNode = TRUE;
        }

        // If the current entry isn't an END entry, copy it
        // into the previous entry buffer:
        //
        if( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            if( CurrentEntry->Length > QueryMaximumEntrySize() ) {

                // This entry is impossibly large, which means that the
                // index is corrupt.
                //
                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_TOO_LARGE);
                    msg->Log("%x%x",
                             CurrentEntry->Length,
                             QueryMaximumEntrySize());
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                *Error = TRUE;
                Result = FALSE;

            } else {

                memcpy( (PVOID) PreviousEntry,
                        (PVOID) CurrentEntry,
                        CurrentEntry->Length );
            }
        }
    }

    FREE( PreviousEntry );
    return Result;
}



VOID
NTFS_INDEX_TREE::FreeAllocation(
    )
/*++

Routine Description:

    This method frees the disk space associated with this index's
    Allocation Attribute.

Arguments:

    None.

Return Value:

    None.

Notes:

    This method may leave the tree in a corrupt state, since it
    truncates the allocation attribute to zero without cleaning
    up downpointers in the root.  Use with care.

--*/
{
    if( _AllocationAttribute != NULL ) {

        _AllocationAttribute->Resize( 0, _VolumeBitmap );
    }
}


BOOLEAN
NTFS_INDEX_TREE::UpdateFileName(
    IN PCFILE_NAME      Name,
    IN FILE_REFERENCE   FileReference
    )
/*++

Routine Description:

    This method updates the duplicated information in a file name
    index entry.

Arguments:

    Name            --  Supplies the file name structure with the new
                        duplicated information.
    FileReference   --  Supplies the file reference for the file to
                        which this name belongs.  (Note that this is
                        the base FRS for that file, not necessarily the
                        exact FRS that contains the name.)

Return Value:

    TRUE upon successful completion.

Notes:

    This operation is meaningless on an index that is not constructed
    over the $FILE_NAME attribute.

--*/
{
    INTSTACK ParentTrail;
    PINDEX_ENTRY FoundEntry;
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PFILE_NAME TargetName;
    BOOLEAN Result;

    DebugPtrAssert( Name );

    if( QueryIndexedAttributeType() != $FILE_NAME ||
        QueryCollationRule() != COLLATION_FILE_NAME ) {

        DebugAbort( "Updating file name in an index that isn't over $FILE_NAME.\n" );
        return FALSE;
    }

    // OK, find the entry that corresponds to the input.  Note that the
    // collation rule for File Names ignores everything but the actual
    // file name portion of the key value.

    if( !FindEntry( NtfsFileNameGetLength( Name ),
                    (PVOID)Name,
                    0,
                    &FoundEntry,
                    &ContainingBuffer,
                    &ParentTrail ) ) {

        // If FoundEntry is NULL, FindEntry failed because of an error;
        // otherwise, there is no matching entry in the index, which
        // means there's nothing to update.
        //

        DebugPrint( "UpdateFileName--index entry not found.\n" );
        Result = ( FoundEntry != NULL );

    } else {

        // We've found an entry.  As an extra sanity check, make sure
        // that the file reference for the found entry is the same as
        // the input file reference.

        if( memcmp( &(FoundEntry->FileReference),
                    &(FileReference),
                    sizeof( FILE_REFERENCE ) ) != 0 ) {

            DebugPrint( "File references don't match in UpdateFileName.\n" );
            Result = TRUE;

        } else {

            // Copy the duplicated information and update the file-name bits.
            //
            TargetName = (PFILE_NAME)(GetIndexEntryValue(FoundEntry));
            TargetName->Info = Name->Info;
            TargetName->Flags = Name->Flags;

            if( ContainingBuffer != NULL ) {

                // This entry is in a buffer, so we have to write the
                // buffer while we've still got it.
                //
                Result = ContainingBuffer->Write( _AllocationAttribute );

            } else {

                // This entry is in the root, so we're done.
                //
                Result = TRUE;
            }
        }
    }

    DELETE( ContainingBuffer );
    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::IsIndexEntryCorrupt(
    IN     PCINDEX_ENTRY       IndexEntry,
    IN     ULONG               MaximumLength,
    IN OUT PMESSAGE            Message,
    IN     INDEX_ENTRY_TYPE    IndexEntryType
    )
{
    ULONG   len;

    if (sizeof(INDEX_ENTRY) > MaximumLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_LENGTH,
                         "%x%x",
                         -1,
                         MaximumLength);
        }
        return TRUE;
    }

    if (IndexEntry->Length != QuadAlign(IndexEntry->Length) ||
        IndexEntry->Length > MaximumLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_LENGTH,
                         "%x%x",
                         IndexEntry->Length,
                         MaximumLength);
        }
        return TRUE;
    }

    len = ((IndexEntry->Flags & INDEX_ENTRY_NODE) ? sizeof(VCN) : 0) +
          ((IndexEntry->Flags & INDEX_ENTRY_END) ? 0 : IndexEntry->AttributeLength) +
          sizeof(INDEX_ENTRY);

    DebugAssert(INDEX_ENTRY_WITH_DATA_TYPE_4 == 0 &&
                INDEX_ENTRY_WITH_DATA_TYPE_8 == 1 &&
                INDEX_ENTRY_WITH_DATA_TYPE_12 == 2 &&
                INDEX_ENTRY_WITH_DATA_TYPE_16 == 3);

    switch (IndexEntryType) {
        case INDEX_ENTRY_WITH_DATA_TYPE_4:
        case INDEX_ENTRY_WITH_DATA_TYPE_8:
        case INDEX_ENTRY_WITH_DATA_TYPE_12:
        case INDEX_ENTRY_WITH_DATA_TYPE_16:
            if (!(IndexEntry->Flags & INDEX_ENTRY_END) &&
                IndexEntry->AttributeLength != IndexEntryAttributeLength[IndexEntryType]) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_ATTR_LENGTH,
                                 "%x%x%x",
                                 IndexEntryType,
                                 IndexEntry->AttributeLength,
                                 IndexEntryAttributeLength[IndexEntryType]);
                }

                return TRUE;
            }

            // fall through

        case INDEX_ENTRY_WITH_DATA_TYPE:
            if (QuadAlign(IndexEntry->DataOffset + IndexEntry->DataLength) >
                IndexEntry->Length) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_DATA_LENGTH,
                                 "%x%x%x",
                                 IndexEntry->DataOffset,
                                 IndexEntry->DataLength,
                                 IndexEntry->Length);
                }

                return TRUE;
            }

            len += IndexEntry->DataLength;

            // fall through

        case INDEX_ENTRY_WITH_FILE_NAME_TYPE:
            if (IndexEntry->Length != QuadAlign(len)) {

                if (Message) {
                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_MISALIGNED_INDEX_ENTRY_LENGTH);
                    Message->Log("%x", IndexEntryType);
                    Message->DumpDataToLog((PVOID)IndexEntry, sizeof(IndexEntry));
                    Message->Unlock();
                }

                return TRUE;
            } else
                return FALSE;
    }

    if (QuadAlign(len) > IndexEntry->Length) {

        if (Message) {
            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_TOO_SMALL);
            Message->Log("%x", IndexEntryType);
            Message->DumpDataToLog((PVOID)IndexEntry, sizeof(IndexEntry));
            Message->Unlock();
        }

        return TRUE;
    } else
        return FALSE;
}


BOOLEAN
NTFS_INDEX_TREE::ResetLsns(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method sets the LSN for each in-use index allocation
    block in the index tree to zero.

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    ULONG i, num_buffers, cluster_size;

    cluster_size = _ClusterFactor * _Drive->QuerySectorSize();

    if( _AllocationAttribute == NULL ) {

        // This tree has no index allocation buffers--there's
        // nothing to do.
        //
        return TRUE;
    }

    num_buffers = (_AllocationAttribute->QueryValueLength()/_BufferSize).GetLowPart();

    for( i = 0; i < num_buffers; i++ ) {

        VCN current_vcn;

        // Skip unused buffers.
        //
        if( _IndexAllocationBitmap->IsFree( i, 1 ) ) {

            continue;
        }

        // If we have a positive number for _ClustersPerBuffer, we want to
        // use that to compute the VCN (this is a backward compatibility mode).
        // More recently formatted filesystems will have 0 for _ClustersPerBuffer
        // and the VCN will be the block number (512-byte blocks), regardless of
        // how many clusters are in each buffer.
        //

        if (0 == _ClustersPerBuffer) {
            current_vcn = i * (_BufferSize / 512);
        } else {
            current_vcn = i * _ClustersPerBuffer;
        }

        // Initialize the buffer, read it, set its LSN, and write it.
        //
        if( !CurrentBuffer.Initialize( _Drive,
                                       current_vcn,
                                       cluster_size,
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable )   ||
            !CurrentBuffer.Read( _AllocationAttribute ) ||
            !CurrentBuffer.SetLsn( 0 )                  ||
            !CurrentBuffer.Write( _AllocationAttribute ) ) {

            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::FindHighestLsn(
    IN OUT  PMESSAGE    Message,
    OUT     PLSN        HighestLsn
    ) CONST
/*++

Routine Description:

    This method finds the highest LSN for any index block
    associated with this index.

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    BIG_INT BigZero;
    ULONG i, cluster_size, num_buffers;

    cluster_size = _ClusterFactor * _Drive->QuerySectorSize();

    BigZero = 0;
    *HighestLsn = BigZero.GetLargeInteger();

    if( _AllocationAttribute == NULL ) {

        // This tree has no index allocation buffers--there's
        // nothing to do.
        //
        return TRUE;
    }

    num_buffers = (_AllocationAttribute->QueryValueLength()/_BufferSize).GetLowPart();

    for( i = 0; i < num_buffers; i++ ) {

        VCN current_vcn;

        // Skip unused buffers.
        //
        if( _IndexAllocationBitmap->IsFree( i, 1 ) ) {

            continue;
        }

        if (0 == _ClustersPerBuffer) {
            current_vcn = i * (_BufferSize / 512);
        } else {
            current_vcn = i * _ClustersPerBuffer;
        }

        // Initialize and read the buffer
        //
        if( !CurrentBuffer.Initialize( _Drive,
                                       current_vcn,
                                       cluster_size,
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable )   ||
            !CurrentBuffer.Read( _AllocationAttribute ) ) {

            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }

        if( CurrentBuffer.QueryLsn() > *HighestLsn ) {

            *HighestLsn = CurrentBuffer.QueryLsn();
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_INDEX_TREE::FindEntry(
    IN  ULONG               KeyLength,
    IN  PVOID               KeyValue,
    IN  ULONG               Ordinal,
    OUT PINDEX_ENTRY*       FoundEntry,
    OUT PNTFS_INDEX_BUFFER* ContainingBuffer,
    OUT PINTSTACK           ParentTrail
    )
/*++

Routine Description:

    This method locates an entry (based on its key value) in
    the index tree.  If no matching entry is found, it locates
    the first leaf entry which is greater than the search value
    (i.e. the point at which the search value would be inserted
    into the tree).

Arguments:

    KeyLength           --  supplies the length, in bytes, of the
                            search value
    KeyValue            --  supplies the search value
    Ordinal             --  supplies the (zero-based) ordinal of the
                            matching entry to return.  (zero returns
                            the first matching value).

                            Note that a value of INDEX_SKIP skips
                            all matching entries.

    FoundEntry          --  Receives a pointer to the located entry
                            (NULL indicates error).
    ContainingBuffer    --  Receives a pointer to the index buffer
                            containing the returned entry (NULL if the
                            entry is in the root).
    ParentTrail         --  Receives the parent trail of ContainingBuffer
                            (ie. the VCNs of that buffer's ancestors).
                            If the entry is in the root, this object
                            may be left uninitialized.

Return Value:

    TRUE If a matching entry is found.

    FALSE if no matching entry was found.  If no error occurred, then
    *FoundEntry will point at the place in the tree where the search
    value would be inserted.

    If the method fails due to error, it returns FALSE and sets
    *FoundEntry to NULL.

    Note that if FindEntry does not find a matching entry, it will
    always return a leaf entry.

--*/
{
    PINDEX_ENTRY SearchEntry;
    VCN CurrentBufferVcn;
    PNTFS_INDEX_BUFFER CurrentBuffer;
    BOOLEAN Finished = FALSE;
    BOOLEAN Result = FALSE;
    USHORT SearchEntryLength;

    // Rig up an index-entry to pass to the index root and buffers:

    SearchEntryLength = (USHORT)QuadAlign( sizeof( INDEX_ENTRY ) + KeyLength );

    if( (SearchEntry = (PINDEX_ENTRY)MALLOC( SearchEntryLength )) == NULL ) {

        // Return the error.

        *FoundEntry = NULL;
        return FALSE;

    }

    SearchEntry->Length = SearchEntryLength;
    SearchEntry->AttributeLength = (USHORT)KeyLength;

    memcpy( GetIndexEntryValue( SearchEntry ),
            KeyValue,
            KeyLength );


    // See if the entry we want is in the index root:

    if( _IndexRoot->FindEntry( SearchEntry,
                               &Ordinal,
                               FoundEntry ) ) {

        // The desired entry is in the root.  *FoundEntry has been set
        // by the Index Root; fill in the other return parameters

        *ContainingBuffer = NULL;
        Result = TRUE;

    } else if ( *FoundEntry == NULL ) {

        // An error occurred trying to find the entry.

        *ContainingBuffer = NULL;
        Result = FALSE;

    } else if( !((*FoundEntry)->Flags & INDEX_ENTRY_NODE) ||
               GetDownpointer( *FoundEntry ) == INVALID_VCN ) {

        // The entry we want isn't in the root, and the root is a leaf,
        // so it's not in the tree.  Return the entry we did find, and
        // return 'not found' to the client.

        *ContainingBuffer = NULL;
        Result = FALSE;

    } else {

        // We didn't find the entry we want in the index root, and
        // the root is not a leaf, so we'll start looking through the
        // index allocation buffers.

        // First, we have to allocate an index allocation buffer
        // for our search.  If all goes well, we'll return this
        // buffer to the client.  Initialize the parent trail, but
        // leave it empty (indicating that we're at the root).

        if( !ParentTrail->Initialize() ||
            (CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ) {

            *FoundEntry = NULL;
        }

        if (_AllocationAttribute == NULL) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INDEX_ALLOC_DOES_NOT_EXIST);
            }

            *FoundEntry = NULL;
        }

        while( *FoundEntry != NULL && !Finished ) {

            DebugAssert( ((*FoundEntry)->Flags & INDEX_ENTRY_NODE) &&
                       GetDownpointer( *FoundEntry ) != INVALID_VCN );

            CurrentBufferVcn = GetDownpointer( *FoundEntry );

            if( !CurrentBuffer->Initialize( _Drive,
                                            CurrentBufferVcn,
                                            _ClusterFactor * _Drive->QuerySectorSize(),
                                            _ClustersPerBuffer,
                                            _BufferSize,
                                            _CollationRule,
                                            _UpcaseTable ) ||
                !CurrentBuffer->Read( _AllocationAttribute ) ) {

                *FoundEntry = NULL;

            } else if( CurrentBuffer->FindEntry( SearchEntry,
                                                 &Ordinal,
                                                 FoundEntry ) ) {

                // We found the entry we want.

                Finished = TRUE;
                Result = TRUE;

            } else if ( *FoundEntry != NULL &&
                        (!((*FoundEntry)->Flags & INDEX_ENTRY_NODE) ||
                         GetDownpointer( *FoundEntry ) == INVALID_VCN) ) {

                // This buffer is a leaf, so the entry we want isn't
                // to be found.  Instead, we'll return this entry, along
                // with a result of FALSE to indicate 'not found'.

                Finished = TRUE;
                Result = FALSE;

            } else {

                // We have to recurse down another level in the tree.
                // Add the current buffer's VCN to the parent trail.

                if( !ParentTrail->Push( CurrentBufferVcn ) ) {

                    // Error.  Drop out of the loop and into the error
                    // handling.

                    *FoundEntry = NULL;
                }
            }
        }

        if( *FoundEntry == NULL ) {

            // We're returning an error, so we have to clean up.

            DELETE( CurrentBuffer );
            CurrentBuffer = NULL;
            *ContainingBuffer = NULL;
            Result = FALSE;

        } else {

            // We're returning an entry--either the one the client
            // wants or the next leaf.  Either way, it's contained
            // in the current buffer, so we need to return that, too.

            *ContainingBuffer = CurrentBuffer;
        }
    }

    FREE( SearchEntry );

    return Result;
}

BOOLEAN
NTFS_INDEX_TREE::RemoveEntry(
    IN PINDEX_ENTRY         EntryToRemove,
    IN PNTFS_INDEX_BUFFER   ContainingBuffer,
    IN PINTSTACK            ParentTrail
    )
/*++

Routine Description:

    This method removes an entry from the tree.

Arguments:

    EntryToRemove       --  Supplies a pointer to the entry to be removed.
    ContainingBuffer    --  Supplies the buffer which contains this entry.
                            NULL if the entry is in the root.
    ParentTrail         --  Supplies the trail of ancestors of
                            ContainingBuffer, back to the root.
                            If ContainingBuffer is NULL, this object
                            may be uninitialized.

Return Value:

    TRUE upon successful completion.

Notes:

    If the removed entry does not have a downpointer, it is sufficient
    to simply rip it out.  If it does, we have to find a replacement
    for it.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    PINDEX_ENTRY ReplacementEntry, Successor;
    BOOLEAN Result, Error;


    BOOLEAN EmptyLeaf = FALSE;
    VCN EmptyLeafVcn;

    DebugAssert( !(EntryToRemove->Flags & INDEX_ENTRY_END ) );

    if( ContainingBuffer == NULL ) {

        // The entry we wish to delete is in the root.

        if( !(EntryToRemove->Flags & INDEX_ENTRY_NODE) ||
            GetDownpointer( EntryToRemove ) == INVALID_VCN ) {

            // It's a leaf entry, so we can just yank it.
            //
            _IndexRoot->RemoveEntry( EntryToRemove );
            Result = TRUE;

        } else {

            // Since the entry we want to remove has a downpointer,
            // we have to find a replacement for it.
            //
            // Allocate a buffer for the replacement entry.
            //
            if( (ReplacementEntry = (PINDEX_ENTRY)
                                    MALLOC( QueryMaximumEntrySize() ))
                == NULL ) {

                return FALSE;
            }

            Successor = GetNextEntry( EntryToRemove );

            if( QueryReplacementEntry( Successor,
                                       ReplacementEntry,
                                       &Error,
                                       &EmptyLeaf,
                                       &EmptyLeafVcn ) ) {

                // We've got a replacement.  It inherits the deleted
                // entry's downpointer.  Then we remove the deleted entry
                // and insert the replacement.

                // Note that QueryReplacementEntry always returns a
                // node entry (ie. INDEX_ENTRY_NODE is set in the flags
                // and the size includes the Downpointer VCN.)

                GetDownpointer( ReplacementEntry ) =
                                    GetDownpointer( EntryToRemove );

                _IndexRoot->RemoveEntry( EntryToRemove );

                Result = InsertIntoRoot( ReplacementEntry,
                                         EntryToRemove );

            } else if ( !Error ) {

                // There is no replacement for the current entry.
                // This means that the subtree rooted at its successor
                // is empty, and can be deleted, which in turn means
                // that the successor can just inherit the deleted
                // entry's downpointer.

                FreeChildren( Successor );

                GetDownpointer( Successor ) = GetDownpointer( EntryToRemove );

                _IndexRoot->RemoveEntry( EntryToRemove );

                Result = TRUE;

            } else {

                // an error has occurred.
                //
                Result = FALSE;
            }

            FREE( ReplacementEntry );
        }

    } else if( !(EntryToRemove->Flags & INDEX_ENTRY_NODE) ||
               GetDownpointer( EntryToRemove ) == INVALID_VCN ) {

        // The entry we wish to delete is a leaf, so we
        // can just yank it.
        //

        ContainingBuffer->RemoveEntry( EntryToRemove );
        Result = ContainingBuffer->Write( _AllocationAttribute );

        // Check to see if removing that entry made the leaf
        // empty.
        //
        if( ContainingBuffer->IsLeaf() && ContainingBuffer->IsEmpty() ) {

            EmptyLeaf = TRUE;
            EmptyLeafVcn = ContainingBuffer->QueryVcn();
        }

    } else {

        // The entry we wish to delete is in a node buffer, so we
        // have to find a replacement for it.
        //
        // Allocate a buffer for the replacement entry.

        if( (ReplacementEntry = (PINDEX_ENTRY)
                                MALLOC( QueryMaximumEntrySize() ))
            == NULL ) {

            return FALSE;
        }

        Successor = GetNextEntry( EntryToRemove );

        if( QueryReplacementEntry( Successor,
                                   ReplacementEntry,
                                   &Error,
                                   &EmptyLeaf,
                                   &EmptyLeafVcn ) ) {

            // We've got a replacement.  It inherits the deleted
            // entry's downpointer.  Then we remove the deleted entry
            // and insert the replacement.

            // Note that QueryReplacementEntry always returns a
            // node entry (ie. INDEX_ENTRY_NODE is set in the flags
            // and the size includes the Downpointer VCN.

            GetDownpointer( ReplacementEntry ) =
                                GetDownpointer( EntryToRemove );

            ContainingBuffer->RemoveEntry( EntryToRemove );

            // Note that InsertIntoBuffer will write ContainingBuffer.
            //
            Result = InsertIntoBuffer( ContainingBuffer,
                                       ParentTrail,
                                       ReplacementEntry,
                                       EntryToRemove );

        } else if ( !Error ) {

            // There is no replacement for the current entry.
            // This means that the subtree rooted at its successor
            // is empty, and can be deleted, which in turn means
            // that the successor can just inherit the deleted
            // entry's downpointer.

            FreeChildren( Successor );

            GetDownpointer( Successor ) = GetDownpointer( EntryToRemove );

            ContainingBuffer->RemoveEntry( EntryToRemove );

            Result = ContainingBuffer->Write( _AllocationAttribute );

        } else {

            // an error has occurred.

            Result = FALSE;
        }

        FREE( ReplacementEntry );
    }

    // If we have successfully deleted an entry, we must check
    // to see if we've created an empty leaf allocation buffer.
    // Note that this will collapse the tree, if appropriate.
    //
    if( EmptyLeaf ) {

        if (!FixupEmptyLeaf( EmptyLeafVcn ))
            Result = FALSE;
    }

    return Result;
}



BOOLEAN
NTFS_INDEX_TREE::QueryReplacementEntry(
    IN  PINDEX_ENTRY        Successor,
    OUT PINDEX_ENTRY        ReplacementEntry,
    OUT PBOOLEAN            Error,
    OUT PBOOLEAN            EmptyLeaf,
    OUT PVCN                EmptyLeafVcn
    )
/*++

Routine Description:

    This private method finds a replacement entry for a deleted
    entry, removes it from its current location in the tree, and
    copies it into the supplied replacement entry buffer.

Arguments:

    Successor           --  supplies the entry following the entry to be
                            replaced.
    ReplacementEntry    --  receives the replacement entry.
    Error               --  receives TRUE if an error occurs.
    EmptyLeaf           --  receives TRUE if this method creates an
                            empty leaf allocation block.  Undefined if
                            the method returns FALSE.
    EmptyLeafVcn        --  receives the VCN of the empty leaf if
                            *EmptyLeaf is set to TRUE.  Undefined if
                            the method returns FALSE.

Return Value:

    TRUE if a replacement entry was found without error.  FALSE if no
    replacement was found or if an error occurred.  (If an error is
    encountered, *Error is set to TRUE.)

Notes:

    The replacement entry is the first entry in the subtree rooted at
    Successor.  It is copied into the replacement buffer and then
    removed from its current location.

    This method assumes that Successor is an entry in a node block
    (which may be the index root), and that the tree is valid and
    consistent.

    If a replacement entry is returned, it will be a node entry (i.e.
    its length will be adjusted, if necessary, to include a downpointer).

    The ReplacementEntry buffer must be big enough to hold any index
    entry from this tree.

--*/
{
    PNTFS_INDEX_BUFFER CurrentBuffer;
    PNTFS_INDEX_BUFFER CandidateBuffer;
    VCN CurrentVcn;
    PINDEX_ENTRY CurrentEntry;
    PINDEX_ENTRY CandidateEntry;
    BOOLEAN LeafFound = FALSE;

    CandidateBuffer = NULL;
    CandidateEntry = NULL;
    *Error = FALSE;

    CurrentVcn = GetDownpointer( Successor );

    while( !*Error && !LeafFound ) {

        if( (CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ||
            !CurrentBuffer->Initialize( _Drive,
                                        CurrentVcn,
                                        _ClusterFactor * _Drive->QuerySectorSize(),
                                        _ClustersPerBuffer,
                                        _BufferSize,
                                        _CollationRule,
                                        _UpcaseTable ) ||
            !CurrentBuffer->Read( _AllocationAttribute ) ) {

            // An error has occurred.

            DELETE( CandidateBuffer );
            DELETE( CurrentBuffer );
            *Error = TRUE;
            return FALSE;
        }

        CurrentEntry = CurrentBuffer->GetFirstEntry();

        if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
            GetDownpointer( CurrentEntry ) == INVALID_VCN ) {

            // This buffer is a leaf, so we will terminate the
            // search on this iteration.

            LeafFound = TRUE;

        } else {

            // This buffer is a node, so we're interested in
            // the child of its first entry.  We need to grab
            // this information before we throw the current
            // buffer out.

            CurrentVcn = GetDownpointer( CurrentEntry );
        }

        if( !(CurrentEntry->Flags & INDEX_ENTRY_END ) ) {

            // This buffer is non-empty, so its first entry
            // could be used as the replacement entry.

            DELETE( CandidateBuffer );
            CandidateBuffer = CurrentBuffer;
            CurrentBuffer = NULL;

        } else {

            // This buffer is empty, so all we want from it is
            // the downpointer (if any) from its first entry,
            // and that we've already got.

            DELETE( CurrentBuffer );
        }
    }

    DebugAssert( CurrentBuffer == NULL );

    if( CandidateBuffer == NULL ) {

        *Error = FALSE;
        return FALSE;

    } else {

        CandidateEntry = CandidateBuffer->GetFirstEntry();

        DebugAssert( !(CandidateEntry->Flags & INDEX_ENTRY_END) );

        // Copy the candidate entry into the replacement entry
        // buffer.

        memcpy( ReplacementEntry,
                CandidateEntry,
                CandidateEntry->Length );

        if( !(CandidateEntry->Flags & INDEX_ENTRY_NODE ) ||
            GetDownpointer( CandidateEntry ) == INVALID_VCN ) {

            // The replacement entry we found doesn't have a downpointer;
            // increase its size to hold one.

            ReplacementEntry->Length += sizeof( VCN );
            ReplacementEntry->Flags |= INDEX_ENTRY_NODE;

        } else {

            // The replacement entry we found was a node entry, which
            // means that all its child buffers are empty.  Return them
            // to the free pool.

            FreeChildren( CandidateEntry );
        }

        // Expunge the replacement entry from its former location,
        // and then write that buffer.
        //
        CandidateBuffer->RemoveEntry( CandidateEntry );
        CandidateBuffer->Write( _AllocationAttribute );

        // Check to see if this action created an empty leaf.
        //
        if( CandidateBuffer->IsLeaf() && CandidateBuffer->IsEmpty() ) {

            *EmptyLeaf = TRUE;
            *EmptyLeafVcn = CandidateBuffer->QueryVcn();

        } else {

            *EmptyLeaf = FALSE;
        }

        // All's well that ends well.

        DELETE(CandidateBuffer);

        return TRUE;
    }
}


BOOLEAN
NTFS_INDEX_TREE::FixupEmptyLeaf(
    IN VCN  EmptyLeafVcn
    )
/*++

Routine Description:

    This method tidies up the tree if an empty leaf allocation
    buffer has been created.

Arguments:

    EmptyLeafVcn    --  supplies the VCN of the empty leaf.

Return Value:

    TRUE upon successful completion.

--*/
{
    INTSTACK ParentTrail;
    NTFS_INDEX_BUFFER CurrentBuffer;
    VCN CurrentVcn, ChildVcn;
    BIG_INT AllocationValueLength;
    BOOLEAN Error = FALSE;
    BOOLEAN Result, IsRoot;
    PINDEX_ENTRY CurrentEntry, PreviousEntry, MovedEntry;
    ULONG i, NumberOfBuffers;

    // Find the buffer in question, and construct its parent trail.
    // If the buffer isn't in the tree, don't worry about it.
    //
    if( !ParentTrail.Initialize() ) {

        return FALSE;
    }

    if( !FindBuffer( EmptyLeafVcn,
                     NULL,
                     &CurrentBuffer,
                     &ParentTrail,
                     &Error ) ) {

        return !Error;
    }

    DebugAssert( CurrentBuffer.QueryVcn() == EmptyLeafVcn );

    if( !CurrentBuffer.IsEmpty() || !CurrentBuffer.IsLeaf() ) {

        // This buffer is not an empty leaf, so there's nothing
        // to do.
        //
        return TRUE;
    }

    // Crawl up the parent trail until we find a non-empty node.
    //
    ChildVcn = CurrentBuffer.QueryVcn();

    while( ParentTrail.QuerySize() != 0 && CurrentBuffer.IsEmpty() ) {

        ChildVcn = CurrentBuffer.QueryVcn();

        if (ChildVcn != INVALID_VCN) {
            FreeIndexBuffer(ChildVcn);
        }

        CurrentVcn = ParentTrail.Look();
        ParentTrail.Pop();

        if( !CurrentBuffer.Initialize( _Drive,
                                       CurrentVcn,
                                       _ClusterFactor * _Drive->QuerySectorSize(),
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable ) ||
            !CurrentBuffer.Read( _AllocationAttribute ) ) {

            return FALSE;
        }
    }

    IsRoot = (CurrentBuffer.IsEmpty() && ParentTrail.QuerySize() == 0);
    if (IsRoot)
        ChildVcn = CurrentBuffer.QueryVcn();

    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            CurrentBuffer.GetFirstEntry();
    PreviousEntry = NULL;

    if( IsRoot && (CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        // This tree needs to be collapsed down to an
        // empty root.  Recreate the index root as an
        // empty leaf and free all the bits in the index
        // allocation bitmap.
        //
        _IndexRoot->Recreate( TRUE, 0 );

        _AllocationAttribute->QueryValueLength( &AllocationValueLength );

        NumberOfBuffers = AllocationValueLength.GetLowPart()/_BufferSize;

        for( i = 0; i < NumberOfBuffers; i++ ) {

            if (0 == _ClustersPerBuffer) {
                FreeIndexBuffer( i * (_BufferSize / 512) );
            } else {
                FreeIndexBuffer( i * _ClustersPerBuffer );
            }
        }

        return TRUE;
    }

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) &&
           ( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
             GetDownpointer( CurrentEntry ) != ChildVcn ) ) {

        PreviousEntry = CurrentEntry;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    if( GetDownpointer( CurrentEntry ) != ChildVcn ) {

        // Didn't find the parent entry, although this
        // buffer is in the parent trail.  Something is
        // corrupt.
        //
        return FALSE;
    }

    if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

        // Since we can't remove the end entry, we'll remove
        // its predecessor instead.  This means we have to
        // transfer the predecessor's downpointer to the end
        // entry.  (Note that this index block is not empty,
        // so the predecessor must exist.)
        //
        if( PreviousEntry == NULL ) {

            //
            // The CurrentBuffer is not empty so there must be a previous entry
            // If CurrentBuffer is empty, then this must be the root.  If it is
            // the root and it is empty, it would have been intercepted by the
            // empty root check earlier.  So, if it gets here, something is
            // wrong.

            return FALSE;
        }

        if( PreviousEntry->Flags & INDEX_ENTRY_NODE ) {

            GetDownpointer( CurrentEntry ) = GetDownpointer( PreviousEntry );

        } else {

            GetDownpointer( CurrentEntry ) = INVALID_VCN;
        }

        CurrentEntry = PreviousEntry;
    }

    // Copy the current entry into a temporary buffer
    // (stripping off its down-pointer, if any) and
    // delete it from the current buffer or root, as
    // appropriate.
    //
    MovedEntry = (PINDEX_ENTRY)MALLOC( CurrentEntry->Length );

    if( MovedEntry == NULL ) {

        return FALSE;
    }

    memcpy( MovedEntry,
            CurrentEntry,
            CurrentEntry->Length );

    if( MovedEntry->Flags & INDEX_ENTRY_NODE ) {

        if (ChildVcn != INVALID_VCN)
            FreeIndexBuffer( ChildVcn );

        MovedEntry->Flags &= ~INDEX_ENTRY_NODE;
        MovedEntry->Length -= sizeof( VCN );
    }

    if( IsRoot ) {

        _IndexRoot->RemoveEntry( CurrentEntry );

    } else {

        CurrentBuffer.RemoveEntry( CurrentEntry );
        CurrentBuffer.Write( _AllocationAttribute );
    }

    // Re-insert the entry into the tree.
    //
    Result = InsertEntry( MovedEntry, FALSE );

    FREE( MovedEntry );

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::FindBuffer(
    IN      VCN                 BufferVcn,
    IN      PNTFS_INDEX_BUFFER  ParentBuffer,
    OUT     PNTFS_INDEX_BUFFER  FoundBuffer,
    IN OUT  PINTSTACK           ParentTrail,
    OUT     PBOOLEAN            Error
    )
/*++

Routine Description:

    This method locates a buffer in the tree.

Arguments:

    BufferVcn       --  supplies the VCN of the desired buffer.
    ParentBuffer    --  supplies the buffer at which to begin the search.
                        If this parameter is NULL, the search starts
                        at the root.
    FoundBuffer     --  receives the buffer.
    ParentTrail     --  supplies the parent trail to ParentBuffer
                        (not including ParentBuffer itself).  Receives
                        the trail to the found buffer.  If the buffer
                        is not found, this object is restored to its
                        original state.
    Error           --  receives TRUE if the method fails because
                        of an error.  Undefined if the method succeeds.

Return Value:

    TRUE upon successful completion.  FoundBuffer is initialized to
    the desired buffer and read, and ParentTrail contains the trail
    to this buffer.

--*/
{
    NTFS_INDEX_BUFFER ChildBuffer;
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN IsRoot;

    IsRoot = ( ParentBuffer == NULL );

    // Spin through the entries in this block to see if one of
    // them is the parent of the buffer we want.
    //
    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            ParentBuffer->GetFirstEntry();

    while( ( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
             GetDownpointer( CurrentEntry ) != BufferVcn ) &&
           !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    if( (CurrentEntry->Flags & INDEX_ENTRY_NODE) &&
        GetDownpointer( CurrentEntry ) == BufferVcn ) {

        // We've found the one we want.  Add the current buffer (if any)
        // to the parent trail, initialize and read the child buffer,
        // and return.
        //
        if( !IsRoot && !ParentTrail->Push( ParentBuffer->QueryVcn() ) ) {

            *Error = TRUE;
            return FALSE;
        }

        if( !FoundBuffer->Initialize( _Drive,
                                      GetDownpointer( CurrentEntry ),
                                      _ClusterFactor * _Drive->QuerySectorSize(),
                                      _ClustersPerBuffer,
                                      _BufferSize,
                                      _CollationRule,
                                      _UpcaseTable ) ||
            !FoundBuffer->Read( _AllocationAttribute ) ) {

            *Error = TRUE;
            return FALSE;
        }

        DebugAssert( BufferVcn == FoundBuffer->QueryVcn() );
        return TRUE;
    }

    // This block is not the immediate parent of our desired
    // buffer.  Recurse into its children.
    //
    if( !IsRoot && !ParentTrail->Push( ParentBuffer->QueryVcn() ) ) {

        *Error = TRUE;
        return FALSE;
    }

    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            ParentBuffer->GetFirstEntry();

    while( TRUE ) {

        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            // Initialize and read the child buffer and
            // recurse into it.
            //
            if( !ChildBuffer.Initialize(_Drive,
                                        GetDownpointer( CurrentEntry ),
                                        _ClusterFactor * _Drive->QuerySectorSize(),
                                        _ClustersPerBuffer,
                                        _BufferSize,
                                        _CollationRule,
                                        _UpcaseTable ) ||
                 !ChildBuffer.Read( _AllocationAttribute ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( FindBuffer( BufferVcn,
                            &ChildBuffer,
                            FoundBuffer,
                            ParentTrail,
                            Error ) ) {

                // Found it in this subtree.
                //
                return TRUE;

            } else if ( *Error ) {

                return FALSE;
            }
        }

        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            break;
        }

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // This block is not an ancestor of the desired buffer.
    // Remove it from the parent trail (if it's a buffer ) and
    // report its failure.
    //
    if( !IsRoot ) {

        DebugAssert( ParentBuffer->QueryVcn() == ParentTrail->Look() );
        ParentTrail->Pop();
    }

    return FALSE;
}


BOOLEAN
NTFS_INDEX_TREE::InsertIntoRoot(
    PCINDEX_ENTRY   NewEntry,
    PINDEX_ENTRY    InsertionPoint
    )
/*++

Routine Description:

    This method attempts to insert an entry into the Index Root
    attribute.  If necessary, it will twiddle the index b-tree.

Arguments:

    NewEntry        --  supplies the new index entry
    InsertionPoint  --  supplies a pointer to the point in the root
                        where the entry should be inserted, if known.
                        This must be a pointer that was returned by a
                        call to _IndexRoot->FindEntry (with no intervening
                        inserts or deletes).  This parameter may be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER NewBuffer;
    INTSTACK ParentTrail;
    VCN NewBufferVcn;
    ULONG BytesToMove;
    PINDEX_ENTRY CurrentEntry;

    // Try the easy case--NTFS_INDEX_ROOT::InsertEntry will succeed
    // if there's room in the root for the new entry.

    if( _IndexRoot->InsertEntry( NewEntry, InsertionPoint ) ) {

        return TRUE;
    }

    //  We didn't get away with the easy case.  Instead, we have to
    //  push the entries that are currently in the index root down
    //  into an index allocation buffer.  Here's the plan:
    //
    //      If we don't have an allocation attribute, create one.
    //      Allocate a new index buffer.
    //      Create it as an empty buffer.  If the root is currently
    //          a leaf, this new buffer becomes a leaf; if not, not.
    //      Move all the index entries that are in the root to the
    //          new buffer
    //      Recreate the root as an empty node, and set the downpointer
    //          of its END entry to point at the new buffer.

    if( _AllocationAttribute == NULL &&
        !CreateAllocationAttribute() ) {

        // Can't create an allocation attribute.
        return FALSE;
    }


    // Allocate and initialize the new buffer.  Postpone creating it
    // until we know what to give it as an end-entry downpointer

    if( !AllocateIndexBuffer( &NewBufferVcn ) ) {

        return FALSE;
    }

    if( !NewBuffer.Initialize( _Drive,
                               NewBufferVcn,
                               _ClusterFactor * _Drive->QuerySectorSize(),
                               _ClustersPerBuffer,
                               _BufferSize,
                               _CollationRule,
                               _UpcaseTable ) ) {

        FreeIndexBuffer( NewBufferVcn );
    }


    // Now copy all the non-end entries from the index root to
    // the new buffer.

    BytesToMove = 0;

    CurrentEntry = _IndexRoot->GetFirstEntry();

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        BytesToMove += CurrentEntry->Length;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // OK, now we can create the new buffer and copy the entries into
    // it.

    if( CurrentEntry->Flags & INDEX_ENTRY_NODE &&
        GetDownpointer( CurrentEntry ) != INVALID_VCN ) {

        // Give the new buffer's end entry the downpointer from the
        // root's end entry.

        NewBuffer.Create( FALSE, GetDownpointer( CurrentEntry ) );

    } else {

        // The new buffer is a leaf.

        NewBuffer.Create( TRUE, 0 );
    }

    NewBuffer.InsertClump( BytesToMove,
                           _IndexRoot->GetFirstEntry() );

    NewBuffer.Write( _AllocationAttribute );


    // Recreate the index root as an empty node.  This will wipe out the
    // old end entry, which is OK.  (If it had a downpointer, we passed
    // that value to the new buffer's end entry; if not, then it didn't
    // have any interesting information.)

    _IndexRoot->Recreate( FALSE, NewBufferVcn );

    // Set up an empty stack for the parent trail (since the new
    // buffer's parent is the root) and insert the new entry into
    // the new leaf buffer.

    return( ParentTrail.Initialize() &&
            InsertIntoBuffer( &NewBuffer, &ParentTrail, NewEntry ) );
}


BOOLEAN
NTFS_INDEX_TREE::InsertIntoBuffer(
    IN OUT PNTFS_INDEX_BUFFER  TargetBuffer,
    IN OUT PINTSTACK           ParentTrail,
    IN     PCINDEX_ENTRY       NewEntry,
    IN     PINDEX_ENTRY        InsertionPoint
    )
/*++

Routine Description:

    This method attempts to insert an entry into an Index
    Allocation Buffer.  If necessary, it will split the buffer.

Arguments:

    TargetBuffer    --  supplies the buffer that will receive the
                        new entry.
    ParentTrail     --  supplies the parent trail (ie. stack of VCNs
                        of all buffers between here and root) of the
                        target buffer.  If this stack is empty, then
                        the parent of the buffer is the root.
    NewEntry        --  supplies the new index entry
    InsertionPoint  --  supplies a pointer to the point in the root
                        where the entry should be inserted, if known.
                        This must be a pointer that was returned by a
                        call to TargetBuffer->FindEntry (with no
                        intervening inserts or deletes).  This parameter
                        may be NULL.

Return Value:

    TRUE upon successful completion.

Notes:

    This method may consume ParentTrail.  The client should not rely
    on the state of ParentTrail after this method returns.

--*/
{
    PINDEX_ENTRY PromotionBuffer;
    PINDEX_ENTRY SplitPoint;
    NTFS_INDEX_BUFFER NewBuffer, ParentBuffer;
    VCN NewBufferVcn, ParentVcn;
    ULONG BytesToCopy, BytesToRemove;
    BOOLEAN Result;
    int CompareResult;

    // Try the easy way first--NTFS_INDEX_BUFFER will succeed if
    // there's enough room in the buffer to accept this entry.

    if( TargetBuffer->InsertEntry( NewEntry, InsertionPoint ) ) {

        return( TargetBuffer->Write( _AllocationAttribute ) );
    }

    //  We didn't get away with the easy case; instead, we have to
    //  split this index buffer.

    //  Allocate a new index allocation buffer.

    if( !AllocateIndexBuffer( &NewBufferVcn ) ) {

        return FALSE;
    }

    if( !NewBuffer.Initialize( _Drive,
                               NewBufferVcn,
                               _ClusterFactor * _Drive->QuerySectorSize(),
                               _ClustersPerBuffer,
                               _BufferSize,
                               _CollationRule,
                               _UpcaseTable ) ) {

        FreeIndexBuffer( NewBufferVcn );
        return FALSE;
    }

    // Find the split point in the buffer we want to split.  This
    // entry will be promoted into the parent; the entries after it
    // stay in this buffer, while the entries before it go into the
    // new buffer.  The new buffer will become the child of the promoted
    // entry.

    SplitPoint = TargetBuffer->FindSplitPoint();

    PromotionBuffer = (PINDEX_ENTRY)MALLOC( TargetBuffer->QuerySize() );

    if( PromotionBuffer == NULL ) {

        FreeIndexBuffer( NewBufferVcn );
        return FALSE;
    }

    memcpy( PromotionBuffer,
            SplitPoint,
            SplitPoint->Length );

    if( TargetBuffer->IsLeaf() ) {

        PromotionBuffer->Flags |= INDEX_ENTRY_NODE;
        PromotionBuffer->Length += sizeof(VCN);
        NewBuffer.Create( TRUE, 0 );

    } else {

        NewBuffer.Create( FALSE, GetDownpointer(PromotionBuffer) );
    }

    GetDownpointer( PromotionBuffer ) = NewBufferVcn;


    // OK, copy all the entries before the split point into the
    // new buffer.

    BytesToCopy = (ULONG)((PBYTE)SplitPoint - (PBYTE)(TargetBuffer->GetFirstEntry()));

    NewBuffer.InsertClump( BytesToCopy, TargetBuffer->GetFirstEntry() );


    //  Now shift the remaining entries down, and adjust the target
    //  buffer's FirstFreeByte field by the number of bytes we moved
    //  to the new buffer.

    BytesToRemove = BytesToCopy + SplitPoint->Length;

    TargetBuffer->RemoveClump( BytesToRemove );


    // Now we decide which buffer gets the new entry, and insert it.
    // If it's less than the promoted entry, it goes in the new buffer;
    // otherwise, it goes in the original buffer.

    CompareResult = CompareNtfsIndexEntries( NewEntry,
                                             PromotionBuffer,
                                             _CollationRule,
                                             _UpcaseTable );

    //
    // Either of the buffer should now be large enough for the new entry
    //

    if( CompareResult < 0 ) {

        if (!NewBuffer.InsertEntry( NewEntry )) {
            FREE(PromotionBuffer);
            DebugAbort("Unable to insert the new entry into the new buffer.\n");
            return FALSE;
        }

    } else {

        if (!TargetBuffer->InsertEntry( NewEntry )) {
            FREE(PromotionBuffer);
            DebugAbort("Unable to insert the new entry into the target buffer.\n");
            return FALSE;
        }
    }

    if (!TargetBuffer->Write( _AllocationAttribute ) ||
        !NewBuffer.Write( _AllocationAttribute )) {
        FREE(PromotionBuffer);
        DebugAbort("Unable to write out the contents of the buffers\n");
        return FALSE;
    }

    // OK, we've finished splitting everybody, so we are ready to
    // insert the promoted entry into the parent.

    if( ParentTrail->QuerySize() == 0 ) {

        // The parent of the target buffer is the root.

        Result = InsertIntoRoot( PromotionBuffer );

    } else {

        // The target buffer's parent is another buffer, and its
        // VCN is on top of the ParentTrail stack.  Get that VCN,
        // and then pop the stack so we can pass it to the parent
        // buffer.  (Popping it makes it the parent trail of the
        // parent buffer.)

        ParentVcn = ParentTrail->Look();
        ParentTrail->Pop();

        Result = ( ParentBuffer.Initialize( _Drive,
                                            ParentVcn,
                                            _ClusterFactor * _Drive->QuerySectorSize(),
                                            _ClustersPerBuffer,
                                            _BufferSize,
                                            _CollationRule,
                                            _UpcaseTable ) &&
                   ParentBuffer.Read( _AllocationAttribute ) &&
                   InsertIntoBuffer( &ParentBuffer,
                                     ParentTrail,
                                     PromotionBuffer ) );
    }

    FREE( PromotionBuffer );
    return Result;
}




BOOLEAN
NTFS_INDEX_TREE::AllocateIndexBuffer(
    OUT PVCN    NewBufferVcn
    )
/*++

Routine Description:

    This method allocates an index allocation buffer from the index
    allocation attribute.  It first checks the bitmap, to see if any
    are free; if there are none free in the bitmap, it adds a new
    index buffer to the end of the allocation attribute.

Arguments:

    NewBuffer   -- receives the VCN of the new buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT ValueLength;
    VCN NewBufferNumber;
    ULONG NumberOfBuffers;


    DebugPtrAssert( _AllocationAttribute != NULL &&
                  _IndexAllocationBitmap != NULL );

    _AllocationAttribute->QueryValueLength( &ValueLength );

    DebugAssert( ValueLength % _BufferSize == 0 );

    NumberOfBuffers = ValueLength.GetLowPart()/_BufferSize;

    // First, check the bitmap.  Allocate as close to the beginning
    // as possible (hence use 0 for the NearHere parameter).

    if( _IndexAllocationBitmap->AllocateClusters( 0,
                                                  1,
                                                  &NewBufferNumber ) ) {

        //  Found a free one in the bitmap--return it.

        DebugPrint( "Buffer allocated from index allocation bitmap.\n" );

        if (0 == _ClustersPerBuffer) {
            *NewBufferVcn = NewBufferNumber * (_BufferSize / 512) ;
        } else {
            *NewBufferVcn = NewBufferNumber * _ClustersPerBuffer;
        }
        return TRUE;
    }


    //  There are no free buffers in the index allocation attribute,
    //  so I have to add one.

    NewBufferNumber = NumberOfBuffers;
    NumberOfBuffers += 1;

    //  Grow the allocation attribute by one buffer:

    if( !_AllocationAttribute->Resize( ValueLength + _BufferSize, _VolumeBitmap ) ) {

        return FALSE;
    }


    //  Grow the index allocation bitmap (if necessary) to cover the
    //  current size of the index allocation attributes.

    if( !_IndexAllocationBitmap->Resize( NumberOfBuffers ) ) {

        //  Couldn't resize the bitmap--truncate the allocation attribute
        //  back to its original size and return failure.

        _AllocationAttribute->Resize( ValueLength, _VolumeBitmap );
        return FALSE;
    }

    //  Mark the new buffer as allocated and return it.

    _IndexAllocationBitmap->SetAllocated( NewBufferNumber, 1 );

    if (0 == _ClustersPerBuffer) {

        // The buffers are indexed by their block offset, where each block
        // in the allocation is 512 bytes.
        //

        *NewBufferVcn = NewBufferNumber * (_BufferSize / NTFS_INDEX_BLOCK_SIZE);

    } else {
        *NewBufferVcn = NewBufferNumber * _ClustersPerBuffer;
    }

    return TRUE;
}



VOID
NTFS_INDEX_TREE::FreeIndexBuffer(
    IN VCN BufferVcn
    )
/*++

Routine Description:

    This method adds a buffer, identified by VCN, to the free
    buffer list.

Arguments:

    BufferVcn   --  supplies the VCN of the buffer to free.

Return Value:

    None.

--*/
{
    if (0 == _ClustersPerBuffer) {
        _IndexAllocationBitmap->SetFree( BufferVcn, _BufferSize/512 );
    } else {
        _IndexAllocationBitmap->SetFree( BufferVcn/_ClustersPerBuffer, 1 );
    }
}



VOID
NTFS_INDEX_TREE::FreeChildren(
    IN PINDEX_ENTRY IndexEntry
    )
/*++

Routine Description:

Arguments:

    IndexEntry  -- supplies the entry whose children are to be marked as
                   free.

Return Value:

    None.

Notes:

    This method assumes that the tree is consistent.

    IndexEntry must be a node entry.

--*/
{
    VCN CurrentVcn;
    NTFS_INDEX_BUFFER ChildBuffer;
    PINDEX_ENTRY CurrentEntry;


    CurrentVcn = GetDownpointer( IndexEntry );

    if( !ChildBuffer.Initialize( _Drive,
                                 CurrentVcn,
                                 _ClusterFactor * _Drive->QuerySectorSize(),
                                 _ClustersPerBuffer,
                                 _BufferSize,
                                 _CollationRule,
                                 _UpcaseTable ) ||
        !ChildBuffer.Read( _AllocationAttribute ) ) {

        return;
    }

    // First, recurse into the children, if any.

    if( !ChildBuffer.IsLeaf() ) {

        CurrentEntry = ChildBuffer.GetFirstEntry();

        while( TRUE ) {

            FreeChildren( CurrentEntry );

            if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

                break;
            }

            CurrentEntry = GetNextEntry( CurrentEntry );
        }
    }

    // We've gotten rid of the children; add this buffer to the
    // free list.

    FreeIndexBuffer( CurrentVcn );

    return;
}



ULONG
NTFS_INDEX_TREE::QueryMaximumEntrySize(
    ) CONST
/*++

Routine Description:

    This method returns the maximum size buffer needed to hold an
    index entry from this index.

Arguments

    None.

Return Value:

    None.

Notes:

    The maximum entry size must be less than the buffer size for
    the allocation buffers in the tree (since an entry must fit
    into a buffer), so we'll return the index allocation buffer size.

--*/
{
    return( _BufferSize );
}



BOOLEAN
NTFS_INDEX_TREE::CreateAllocationAttribute(
    )
/*++

Routine Description:

    This method creates an allocation attribute.  This attribute is
    an empty, nonresident attribute.  This method also creates an
    index allocation bitmap associated with this index allocation
    attribute.

Arguments:

    None.

Return value:

    TRUE upon successful completion.  Note that if this method succeeds,
    the private member data _AllocationAttribute is set to point at the
    newly-created attribute and _IndexAllocationBitmap is set to point
    at the newly-created bitmap.

--*/
{
    PNTFS_ATTRIBUTE NewAttribute;
    PNTFS_BITMAP NewBitmap;
    NTFS_EXTENT_LIST Extents;

    DebugAssert(0 != _ClusterFactor);


    // Create an empty extent list.

    if( !Extents.Initialize( (ULONG)0, (ULONG)0 ) ) {

        return FALSE;
    }


    // Construct an index allocation attribute and initialize
    // it with this extent list.

    if( (NewAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
        !NewAttribute->Initialize( _Drive,
                                   _ClusterFactor,
                                   &Extents,
                                   0,
                                   0,
                                   $INDEX_ALLOCATION,
                                   _Name ) ) {

        DebugPrint( "CreateAllocationAttribute--Cannot create index allocation attribute.\n" );

        DELETE( NewAttribute );
        return FALSE;
    }

    // Create a new bitmap.  Initialize it to cover zero allocation units,
    // and indicate that it is growable.

    if( (NewBitmap = NEW NTFS_BITMAP) == NULL ||
        !NewBitmap->Initialize( 0, TRUE ) ) {

        DebugPrint( "CreateAllocationAttribute--Cannot create index allocation bitmap.\n" );

        DELETE( NewAttribute );
        DELETE( NewBitmap );
        return FALSE;
    }

    _AllocationAttribute = NewAttribute;
    _IndexAllocationBitmap = NewBitmap;

    return TRUE;
}



BOOLEAN
NTFS_INDEX_TREE::InvalidateIterator(
    )
/*++

Routine Description:

    This method sets the tree's associated iterator into the invalid
    state.  This means that instead of caching a pointer to the current
    entry and the buffer that contains it, the iterator caches the
    information necessary to locate the current entry.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    // If the iterator is already reset, invalid, deleted, or corrupt,
    // then this method is a no-op.  In particular, the state of the
    // iterator is unchanged.

    if( _IteratorState == INDEX_ITERATOR_RESET ||
        _IteratorState == INDEX_ITERATOR_INVALID ||
        _IteratorState == INDEX_ITERATOR_DELETED ||
        _IteratorState == INDEX_ITERATOR_CORRUPT ) {

        return TRUE;
    }

    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );

    // Clean up the current entry and current buffer pointers.
    //
    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_INVALID;

    return TRUE;
}


UNTFS_EXPORT
VOID
NTFS_INDEX_TREE::ResetIterator(
    )
/*++

Routine Description:

    This method sets the iterator into the RESET state, so that the
    next call to GetNext will return the first entry in the index.

Arguments:

    None.

Return value:

    None.

--*/
{
    // Clean up the current buffer and current entry pointers and
    // set the state appropriately.

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_RESET;

}


BOOLEAN
NTFS_INDEX_TREE::GetNextLeafEntry(
    )
/*++

Routine Description:

    This method is a helper function for GetNext.  It advances
    _CurrentEntry to the next leaf entry, adjusting the other
    private data as appropriate.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

Notes:

    This method should only be called if _CurrentEntry points at
    a valid node entry.

--*/
{
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _CurrentEntry->Flags & INDEX_ENTRY_NODE );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );


    while( _CurrentEntry->Flags & INDEX_ENTRY_NODE &&
           GetDownpointer( _CurrentEntry ) != INVALID_VCN ) {

        DebugPtrAssert( _AllocationAttribute );

        if( _CurrentBuffer == NULL &&
            (_CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ) {

            DebugAbort( "Can't construct index allocation buffer object.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        // If the current entry is in a buffer, record that buffer in
        // the trail before recursing into the child.

        if( !_IsCurrentEntryInRoot &&
            !_CurrentEntryTrail.Push( _CurrentBuffer->QueryVcn() ) ) {

            DebugAbort( "Parent Trail stack failure.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        // Initialize and read the child and take its first entry
        // for the current entry.

        if( !_CurrentBuffer->Initialize( _Drive,
                                         GetDownpointer( _CurrentEntry ),
                                         _ClusterFactor * _Drive->QuerySectorSize(),
                                         _ClustersPerBuffer,
                                         _BufferSize,
                                         _CollationRule,
                                         _UpcaseTable )) {

            DebugPrint("Can't init alloc buffer\n");
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        if (!_CurrentBuffer->Read( _AllocationAttribute ) ) {

            DebugPrint( "Can't read allocation buffer.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        _IsCurrentEntryInRoot = FALSE;
        _CurrentEntry = _CurrentBuffer->GetFirstEntry();
    }


    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::GetNextParent(
    )
/*++

Routine Description:

    This method is a helper function for GetNextUnfiltered.  It
    backtracks up the current entry's parent trail one level.

Arguments

    None.

Return Value:

    TRUE upon successful completion.  Private data for the iterator
    are adjusted appropriately.

Notes:

    This method should only be called if _CurrentEntry is valid.

--*/
{
    VCN CurrentVcn, ChildVcn;

    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( !_IsCurrentEntryInRoot ) {

        DebugPtrAssert( _CurrentBuffer );
        DebugPtrAssert( _AllocationAttribute );

        ChildVcn = _CurrentBuffer->QueryVcn();

        if( _CurrentEntryTrail.QuerySize() == 0 ) {

            // The parent of the current buffer is the root.

            _CurrentEntry = _IndexRoot->GetFirstEntry();
            _IsCurrentEntryInRoot = TRUE;

        } else {

            // Get the VCN of the current buffer's parent from the
            // trail, and then pop the trail to reflect the fact
            // that we're going up a level in the tree.

            CurrentVcn = _CurrentEntryTrail.Look();
            _CurrentEntryTrail.Pop();

            if( !_CurrentBuffer->Initialize( _Drive,
                                             CurrentVcn,
                                             _ClusterFactor * _Drive->QuerySectorSize(),
                                             _ClustersPerBuffer,
                                             _BufferSize,
                                             _CollationRule,
                                             _UpcaseTable ) ||
                !_CurrentBuffer->Read( _AllocationAttribute ) ) {

                DebugAbort( "Can't find read/initialize buffer.\n" );
                _CurrentEntry = NULL;
                _IteratorState = INDEX_ITERATOR_CORRUPT;
                return FALSE;
            }

            _CurrentEntry = _CurrentBuffer->GetFirstEntry();
            _IsCurrentEntryInRoot = FALSE;
        }

        // Spin through the entries in this block (whether the root
        // or a buffer) until we find the entry which is the parent
        // of our child, or run out of entries, or both.

        while( !(_CurrentEntry->Flags & INDEX_ENTRY_END) &&
               ( !(_CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
                 !(GetDownpointer( _CurrentEntry ) == ChildVcn) ) ) {

            _CurrentEntry = GetNextEntry( _CurrentEntry );
        }

        if( !(_CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
            !(GetDownpointer( _CurrentEntry ) == ChildVcn) ) {

            // Didn't find the parent.
            DebugAbort( "Can't find read/initialize buffer.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

    } else {

        // Trying to get the parent when we're already in the
        // root isn't very meaningful.
        //
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
PCINDEX_ENTRY
NTFS_INDEX_TREE::GetNext(
    OUT PULONG      Depth,
    OUT PBOOLEAN    Error,
    IN  BOOLEAN     FilterEndEntries
    )
/*++

Routine Description:

    This method bumps the iterator forward and gets the next entry.

Arguments:

    Depth               --  Receives the depth in the tree of the
                            returned entry; 0 indicates the root.
    Error               --  Receives TRUE if this method fails because
                            of error.
    FilterEndEntries    --  Supplies a flag which indicates whether
                            entries with the INDEX_ENTRY_END flag
                            should be filtered.  If this parameter is
                            TRUE, this method will not return such
                            entries to the client.

Return Value:

    Returns a pointer to the next entry, or NULL if there are no more
    or an error occurs.

    If this method returns a non-NULL pointer, the value of *Error should
    be ignored.

--*/
{
    PCINDEX_ENTRY Result;

    Result = GetNextUnfiltered( Depth, Error );

    if( FilterEndEntries ) {

        // The client doesn't want to see END entries; keep
        // trying until we find a non-end entry or run out.
        //
        while( Result != NULL && Result->Flags & INDEX_ENTRY_END ) {

            Result = GetNextUnfiltered( Depth, Error );
        }
    }

    return Result;

}

UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::CopyIterator(
    IN  PNTFS_INDEX_TREE    Index
    )
/*++

Routine Description:

    This method copies down the iterator state so that it can start at
    that state later on.  The size of the Buffer must be large enough
    to accomodate all the data.

    NOTE: This routine must be used in pairs due to the ReverseCopy trick.

Arguments:

    Index      --  Supplies the index to be copied.

Return Value:

    N/A

--*/
{
    DebugPtrAssert(Index);

    if ((_IteratorState = Index->_IteratorState) != INDEX_ITERATOR_RESET) {

        _Drive = Index->_Drive;
        _IsCurrentEntryInRoot = Index->_IsCurrentEntryInRoot;
        _CurrentKeyOrdinal = Index->_CurrentKeyOrdinal;
        _CurrentKeyLength = Index->_CurrentKeyLength;
        _CurrentKeyMaxLength = Index->_CurrentKeyMaxLength;

        if (Index->_CurrentBuffer) {
            if(_CurrentBuffer == NULL &&
               ((_CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL)) {
                Destroy();
                return FALSE;
            }
            if (!_CurrentBuffer->Copy(Index->_CurrentBuffer, _Drive)) {
                Destroy();
                return FALSE;
            }
            if (Index->_CurrentEntry) {
                _CurrentEntry = (PINDEX_ENTRY)
                                 ((PCHAR)Index->_CurrentEntry -
                                 (PCHAR)Index->_CurrentBuffer->GetData() +
                                 (PCHAR)_CurrentBuffer->GetData());
            }
        }

        if (Index->_CurrentKey) {
            if (_CurrentKey == NULL &&
                (_CurrentKey = MALLOC(_CurrentKeyMaxLength)) == NULL) {
                Destroy();
                return FALSE;
            }
            memcpy(_CurrentKey, Index->_CurrentKey, _CurrentKeyLength);
        }

        if (!_CurrentEntryTrail.Initialize() ||
            !_CurrentEntryTrail.ReverseCopy(&(Index->_CurrentEntryTrail))) {
            Destroy();
            return FALSE;
        }
    }
    return TRUE;
}


PCINDEX_ENTRY
NTFS_INDEX_TREE::GetNextUnfiltered(
    OUT PULONG      Depth,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This method bumps the iterator forward and gets the next entry.

Arguments:

    Depth    --  Receives the depth in the tree of the returned entry;
                 0 indicates the root.
    Error    --  Receives TRUE if this method fails because of error.

Return Value:

    Returns a pointer to the next entry, or NULL if there are no more
    or an error occurs.

    If this method returns a non-NULL pointer, the value of *Error should
    be ignored.

--*/
{
    DebugPtrAssert( Error );

    switch( _IteratorState ) {

    case INDEX_ITERATOR_CORRUPT :

        DebugPrint( "Index iterator is corrupt." );
        *Error = TRUE;
        return NULL;

    case INDEX_ITERATOR_RESET :


        // We want to get the first entry in the tree.  The easiest way
        // to do this is to start at the first entry in the root, drop
        // down to the the next leaf, and then bounce back up until
        // we find a non-end entry (which might be the leaf itself).
        // Since we're starting a search, reinitialize the parent
        // trail, too.
        //
        if( !_CurrentEntryTrail.Initialize() ) {

            DebugPrint( "UNTFS: Can't initialize intstack.\n" );
            *Error = TRUE;
            return NULL;
        }

        _CurrentEntry = _IndexRoot->GetFirstEntry();
        _IsCurrentEntryInRoot = TRUE;

        // If the current entry isn't a leaf, drop down 'til we
        // find a leaf entry.

        if( (_CurrentEntry->Flags & INDEX_ENTRY_NODE) &&
            GetDownpointer( _CurrentEntry ) != INVALID_VCN &&
            !GetNextLeafEntry()  ) {

            // GetNextLeafEntry cleans up the private data appropriately.
            *Error = TRUE;
            return NULL;
        }

        // We've got the first entry in the index--return it.
        // (Note that it may be an END entry).
        //
        _IteratorState = INDEX_ITERATOR_CURRENT;
        UpdateOrdinal();
        SaveCurrentKey();
        *Depth = QueryCurrentEntryDepth();
        *Error = FALSE;
        return _CurrentEntry;


    case INDEX_ITERATOR_INVALID :

        // We have the information necessary to find the current
        // entry, rather than the current entry itself.  Incrementing
        // _CurrentKeyOrdinal will give us the information needed
        // to find the next entry, and then we fall through into
        // the INDEX_ITERATOR_DELETED case.

        if( _CurrentEntry->Flags & INDEX_ENTRY_END ) {

            *Error = TRUE;
            return NULL;
        }

        _CurrentKeyOrdinal++;

        // Fall through to INDEX_ITERATOR_DELETED:

    case INDEX_ITERATOR_DELETED :

        // We have the information necessary to find the next entry,
        // so let's find it!
        //
        if( _CurrentKeyLength == 0 ) {

            *Error = TRUE;
            return NULL;
        }

        if( FindEntry( _CurrentKeyLength,
                       _CurrentKey,
                       _CurrentKeyOrdinal,
                       &_CurrentEntry,
                       &_CurrentBuffer,
                       &_CurrentEntryTrail ) ||
            _CurrentEntry != NULL ) {

            // We got an entry--return it.  Note that it
            // may be an END entry.
            //
            _IsCurrentEntryInRoot = (_CurrentBuffer == NULL);
            _IteratorState = INDEX_ITERATOR_CURRENT;
            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else {

            // An error occurred--this iterator is hosed.

            _IteratorState = INDEX_ITERATOR_CORRUPT;
            DELETE( _CurrentBuffer );
            *Error = TRUE;
            return NULL;
        }

    case INDEX_ITERATOR_CURRENT :

        // _CurrentEntry is valid.
        //
        if( !(_CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            // There are more entries in this block.  Move on
            // to the next one: if it's a node, get its first
            // descendant; otherwise, we'll take that entry
            // itself.
            //
            _CurrentEntry = GetNextEntry( _CurrentEntry );

            if( _CurrentEntry->Flags & INDEX_ENTRY_NODE &&
                GetDownpointer( _CurrentEntry ) != INVALID_VCN ) {

                // This entry is a node; we want to return
                // all its descendants before returning it.
                //
                if( !GetNextLeafEntry() ) {

                    // GetNextLeafEntry cleans up the
                    // private data as needed.
                    //
                    *Error = TRUE;
                    return NULL;
                }
            }

            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else if( !_IsCurrentEntryInRoot ) {

            // There are no more entries in this block,
            // so we should return the parent of this block.
            // Note that GetNextParent sets up the information
            // about depth.
            //
            if( !GetNextParent() ) {

                // GetNextParent cleans up the private data
                // if it fails.
                //
                *Error = TRUE;
                return NULL;
            }

            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else {

            // There are no more entries in this block, and
            // it's the root (so it doesn't have a parent).
            // We're done!
            //
            *Error = FALSE;
            return NULL;
        }
    }

    return NULL;  // Keep the compiler happy.
}



BOOLEAN
NTFS_INDEX_TREE::DeleteCurrentEntry(
    )
/*++

Routine Description:

    This method deletes the entry which is the iterator's current entry.
    It also adjusts the iterator so that the next call to GetNext will
    return the entry after the one that got deleted.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    BOOLEAN Result;

    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( _IteratorState != INDEX_ITERATOR_CURRENT ||
        _CurrentEntry->Flags & INDEX_ENTRY_END ) {

        return FALSE;
    }

    // The information we need to find the current entry again (which
    // is also the information we need to find the next entry after
    // we delete this entry) has been safely squirreled away by
    // GetNext.
    //
    // RemoveEntry requires the ContainingBuffer parameter to be
    // NULL if the target entry is in the root.

    if( _IsCurrentEntryInRoot ) {

        DELETE( _CurrentBuffer );
    }

    Result = RemoveEntry( _CurrentEntry,
                          _CurrentBuffer,
                          &_CurrentEntryTrail );

    // Note that RemoveEntry renders the current entry location
    // invalid.

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_DELETED;

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::WriteCurrentEntry(
    )
/*++

Routine Description:

    This method commits the current entry (and the index block containing
    it).  Note that it is provided for use at the client's risk.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( _IteratorState != INDEX_ITERATOR_CURRENT ) {

        return FALSE;
    }

    // If the current entry is in the root, then there's no work
    // to be done; any changes to the current entry will be written
    // to disk when the index tree is saved.
    //
    if( !_IsCurrentEntryInRoot ) {

        return( _CurrentBuffer->Write( _AllocationAttribute ) );
    }

    return TRUE;  // If the current entry is in the root then write
                  // is a no-op.
}


VOID
NTFS_INDEX_TREE::UpdateOrdinal(
    )
/*++

Routine Description:

    This method is called when a the iterator advances _CurrentEntry
    to the next entry, in order to determine the correct value of
    _CurrentKeyOrdinal.  If the key value of the new _CurrentEntry
    is the same as the saved value, then _CurrentKeyOrdinal is
    incremented; otherwise, it is set to zero.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugAssert( _CurrentEntry->AttributeLength <= _CurrentKeyMaxLength );
    DebugPtrAssert( _CurrentKey );
    DebugPtrAssert( _CurrentEntry );

    if( !(_CurrentEntry->Flags & INDEX_ENTRY_END) &&
        _CurrentKeyLength == _CurrentEntry->AttributeLength &&
        memcmp( _CurrentKey,
                GetIndexEntryValue( _CurrentEntry ),
                _CurrentEntry->AttributeLength ) == 0 ) {

        _CurrentKeyOrdinal += 1;

    } else {

        _CurrentKeyOrdinal = 0;
    }
}


VOID
NTFS_INDEX_TREE::SaveCurrentKey(
    )
/*++

Routine Description:

    This method squirrels away the information we need to find
    the current key.

Arguments:

    None.

Return value:

    None.
--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugAssert( _CurrentEntry->AttributeLength <= _CurrentKeyMaxLength );
    DebugPtrAssert( _CurrentKey );
    DebugPtrAssert( _CurrentEntry );

    if( _CurrentEntry->Flags & INDEX_ENTRY_END ) {

        _CurrentKeyLength = 0;

    } else {

        memcpy( _CurrentKey,
                GetIndexEntryValue( _CurrentEntry ),
                _CurrentEntry->AttributeLength );

        _CurrentKeyLength = _CurrentEntry->AttributeLength;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\mftref.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mftref.cxx

Abstract:

    This module contains the member function definitions for
    the NTFS_REFLECTED_MASTER_FILE_TABLE class.  This class
    models the backup copy of the Master File Table.

Author:

    Bill McJohn (billmc) 13-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "mftref.hxx"
#include "ifssys.hxx"
#include "numset.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_REFLECTED_MASTER_FILE_TABLE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_REFLECTED_MASTER_FILE_TABLE::~NTFS_REFLECTED_MASTER_FILE_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_REFLECTED_MASTER_FILE_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_REFLECTED_MASTER_FILE_TABLE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes a Master File Table Reflection object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Master File Table Reflection.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    return( NTFS_FILE_RECORD_SEGMENT::Initialize( MASTER_FILE_TABLE2_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats a Master File Table Reflection File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.
    VolumeBitmap        -- supplies the bitmap for the volume on
                            which this object resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN FirstLcn;
    BIG_INT Size;
    ULONG ReflectedMftClusters;
    ULONG cluster_size;

    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // The Master File Table Reflection has a data attribute whose value
    // consists of REFLECTED_MFT_SEGMENTS file record segments.  Create
    // merely allocates space for these clusters, it does not write them.

    cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    ReflectedMftClusters = (REFLECTED_MFT_SEGMENTS * QuerySize() + (cluster_size-1))
         / cluster_size;

    Size = ReflectedMftClusters * cluster_size;

    if( !VolumeBitmap->AllocateClusters( (QueryVolumeSectors()/2)/
                                                QueryClusterFactor(),
                                         ReflectedMftClusters,
                                         &FirstLcn ) ||
        !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            FirstLcn,
                            ReflectedMftClusters ) ||
        !DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    Size,
                                    Size,
                                    $DATA ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }


    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::VerifyAndFix(
    IN      PNTFS_ATTRIBUTE     MftData,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusters,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that this FRS's $DATA attribute is the
    appropriate length (from 1 to 3 clusters).  It also compares
    the data in these clusters with the first clusters of the
    $MftData attribute and prints a message if they are different.

    This routine does not actually write out the contents of these
    clusters because this is done by MFT_FILE::Flush()

Arguments:

    MftData      - Supplies the MFT $DATA attribute.
    VolumeBitmap - Supplies the volume bitmap.
    BadClusters  - Supplies the list of bad clusters.
    RootIndex    - Supplies the root index.
    Changes      - Returns whether or not changes were made.
    FixLevel     - Supplies the CHKDSK fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                mft_hmem, ref_hmem;
    SECRUN              mft_secrun, ref_secrun;
    LCN                 mft_lcn, ref_lcn;
    BIG_INT             run_length;
    ULONG               num_clusters;
    ULONG               num_sectors;
    ULONG               num_bytes, bytes_written;
    BOOLEAN             need_write;
    NTFS_ATTRIBUTE      data_attribute;
    NTFS_EXTENT_LIST    extents;
    BOOLEAN             error;


    *Changes = FALSE;

    // First read in the original stuff.

    num_sectors = (REFLECTED_MFT_SEGMENTS*QuerySize())/GetDrive()->QuerySectorSize();
    num_bytes = num_sectors * GetDrive()->QuerySectorSize();

    if (!MftData->QueryLcnFromVcn(0, &mft_lcn) ||
        !mft_hmem.Initialize() ||
        !mft_secrun.Initialize(&mft_hmem, GetDrive(),
                               mft_lcn*QueryClusterFactor(),
                               num_sectors) ||
        !mft_secrun.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_write = FALSE;


    // Query the $DATA attribute from this FRS.

    if (!QueryAttribute(&data_attribute, &error, $DATA) ||
        data_attribute.IsResident()) {

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OR_RESIDENT_DATA_ATTR_IN_MFT_MIRROR);

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);

        need_write = TRUE;

        if (!extents.Initialize(0, 0) ||
            !data_attribute.Initialize(GetDrive(), QueryClusterFactor(),
                                       &extents, 0, 0, $DATA)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
            return FALSE;
        }
    }


    // Make sure that the $DATA attribute is the right size.

    error = FALSE;

    if (need_write) {
        error = TRUE;
    } else if (!data_attribute.QueryLcnFromVcn(0, &ref_lcn, &run_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT_MIRROR);

        error = TRUE;
    } else if (ref_lcn == LCN_NOT_PRESENT) {

        Message->LogMsg(MSG_CHKLOG_NTFS_LCN_NOT_PRESENT_FOR_VCN_ZERO_OF_MFT_MIRROR);

        error = TRUE;
    } else if (run_length*QueryClusterFactor() < num_sectors) {

        Message->LogMsg(MSG_CHKLOG_NTFS_DISCONTIGUOUS_MFT_MIRROR);

        error = TRUE;
    } else if (data_attribute.QueryValueLength() < num_bytes) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_HAS_INVALID_VALUE_LENGTH,
                        "%I64x%x",
                        data_attribute.QueryValueLength().GetLargeInteger(),
                        num_bytes);

        error = TRUE;
    } else if (data_attribute.QueryValidDataLength() < num_bytes) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_HAS_INVALID_DATA_LENGTH,
                        "%I64x%x",
                        data_attribute.QueryValidDataLength().GetLargeInteger(),
                        num_bytes);

        error = TRUE;
    } else if (!ref_hmem.Initialize()) {

        error = TRUE;
    } else if (!ref_secrun.Initialize(&ref_hmem, GetDrive(),
                                      ref_lcn*QueryClusterFactor(),
                                      num_sectors)) {

        error = TRUE;
    } else if (!ref_secrun.Read()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_MFT_MIRROR,
                     "%I64x%x",
                     ref_lcn.GetLargeInteger(),
                     num_sectors);
        error = TRUE;
    }

    if (error) {

        if (!need_write) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        }

        need_write = TRUE;

        if (data_attribute.QueryLcnFromVcn(0, &ref_lcn, &run_length) &&
            ref_lcn != LCN_NOT_PRESENT &&
            !BadClusters->Add(ref_lcn, run_length)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

         num_clusters = (num_sectors+QueryClusterFactor()-1)/QueryClusterFactor();

        // the write below is just to change the valid data length and valid length
        // to the correct value.  The content we write is not of importance.

        if (!data_attribute.Hotfix(0, num_clusters, VolumeBitmap,
                                   BadClusters, TRUE) ||
            !data_attribute.Write(NULL,
                                  num_bytes,
                                  0,
                                  &bytes_written,
                                  NULL)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
            return FALSE;
        }

    } else if (memcmp(mft_hmem.GetBuf(), ref_hmem.GetBuf(),
                      REFLECTED_MFT_SEGMENTS*QuerySize())) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_DIFFERENT_FROM_MFT);

        if (!need_write) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        }

        need_write = TRUE;  // set the change status
    }

    if ((data_attribute.IsStorageModified() &&
         !data_attribute.InsertIntoFile(this, VolumeBitmap)) ||
        (need_write && FixLevel != CheckOnly &&
         !Flush(VolumeBitmap, RootIndex))) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
        return FALSE;
    }

    *Changes = need_write;

    return TRUE;
}


LCN
NTFS_REFLECTED_MASTER_FILE_TABLE::QueryFirstLcn(
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    The LCN of the first cluster of the Master File Table
    Reflection's $DATA attribute.

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    LCN             Result = 0;
    BOOLEAN         Error;

    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ||
        !DataAttribute.QueryLcnFromVcn( 0, &Result ) ) {

        Result = 0;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\ntfsbit.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    ntfsbit.cxx

Abstract:

    This module contains the declarations for NTFS_BITMAP,
    which models the bitmap of an NTFS volume, and MFT_BITMAP,
    which models the bitmap for the Master File Table.

Author:

    Bill McJohn (billmc) 17-June-91

Environment:

    ULIB, User Mode

Notes:

    This implementation only supports bitmaps which have a number
    of sectors which will fit in a ULONG.  The interface supports
    the 64-bit number of clusters, but Initialize will refuse to
    accept a number-of-clusters value which has a non-zero high part.

    If we rewrite BITVECTOR to accept 64-bit cluster numbers (or
    write a new one) this class could easily be fixed to support
    larger volumes.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "attrib.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BITMAP, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BITMAP::~NTFS_BITMAP(
            )
{
    Destroy();
}

VOID
NTFS_BITMAP::Construct(
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfClusters = 0;
    _BitmapSize = 0;
    _BitmapData = NULL;
    _NextAlloc = 0;
    _Mft = NULL;
    _ClusterFactor = 0;
    _Drive = NULL;
}

VOID
NTFS_BITMAP::Destroy(
    )
/*++

Routine Description:

    Worker method to prepare an object for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfClusters = 0;
    _BitmapSize = 0;
    FREE( _BitmapData );
    _NextAlloc = 0;
    _Mft = NULL;
}



UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::Initialize(
    IN BIG_INT NumberOfClusters,
    IN BOOLEAN IsGrowable,
    IN PLOG_IO_DP_DRIVE Drive,
    IN ULONG ClusterFactor
    )
/*++

Routine Description:

    This method initializes an NTFS_BITMAP object.

Arguments:

    NumberOfClusters    --  Supplies the number of allocation units
                            which the bitmap covers.
    IsGrowable          --  Supplies a flag indicating whether the
                            bitmap may grow (TRUE) or is of fixed size
                            (FALSE).

Return Value:

    TRUE upon successful completion.

Notes:

    The bitmap is initialized with all clusters within the range of
    NumberOfClusters marked as FREE.

--*/
{
    ULONG LowNumberOfClusters;

    Destroy();

    if( NumberOfClusters.GetHighPart() != 0 ) {

        DebugPrint( "bitmap.cxx:  cannot manage a volume of this size.\n" );
        return FALSE;
    }

    LowNumberOfClusters = NumberOfClusters.GetLowPart();

    _NumberOfClusters = NumberOfClusters;
    _IsGrowable = IsGrowable;

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;


    // Determine the size in bytes of the bitmap.  Note that this size
    // is quad-aligned.

    _BitmapSize = ( LowNumberOfClusters % 8 ) ?
                        ( LowNumberOfClusters/8 + 1 ) :
                        ( LowNumberOfClusters/8 );

    _BitmapSize = QuadAlign( max(_BitmapSize, 1) );


    // Allocate space for the bitvector and initialize it.

    if( (_BitmapData = MALLOC( _BitmapSize )) == NULL ||
        !_Bitmap.Initialize( _BitmapSize * 8,
                             RESET,
                             (PPT)_BitmapData ) ) {

        // Note that Destroy will clean up _BitmapData

        Destroy();
        return FALSE;
    }

    // If the bitmap is growable, then any padding bits are reset (free);
    // if it is fixed size, they are set (allocated).

    if( _IsGrowable ) {

        _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                          _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    } else {

        _Bitmap.SetBit( _NumberOfClusters.GetLowPart(),
                        _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );
    }

    // The bitmap is intialized with all clusters marked free.
    //
    SetFree( 0, _NumberOfClusters );

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::Write(
    IN OUT  PNTFS_ATTRIBUTE BitmapAttribute,
    IN OUT  PNTFS_BITMAP    VolumeBitmap
    )
/*++

Routine Description:

    This method writes the bitmap.

Arguments:

    BitmapAttribute -- supplies the attribute which describes the
                        bitmap's location on disk.
    VolumeBitmap    -- supplies the volume's bitmap for possible
                        allocation during write.

Return Value:

    TRUE upon successful completion.

Notes:

    The attribute will, if necessary, allocate space from the
    bitmap to write it.

--*/
{
    ULONG BytesWritten;

    DebugPtrAssert( _BitmapData );



    return( CheckAttributeSize( BitmapAttribute, VolumeBitmap ) &&
            BitmapAttribute->Write( _BitmapData,
                                    0,
                                    _BitmapSize,
                                    &BytesWritten,
                                    VolumeBitmap ) &&
            BytesWritten == _BitmapSize );
}

UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::IsFree(
    IN LCN Lcn,
    IN BIG_INT  RunLength
    ) CONST
/*++

Routine Description:

    This method determines whether the specified cluster run is
    marked as free in the bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run
    RunLength   -- supplies the length of the run

Return Value:

    TRUE if all clusters in the run are free in the bitmap.

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG i, CurrentLcn;


    if( Lcn < 0 ||
        Lcn + RunLength > _NumberOfClusters ) {

        return FALSE;
    }

    // Note that, since _NumberOfClusters is not greater than the
    // maximum ULONG, the high parts of Lcn and RunLength are
    // sure to be zero.

    for( i = 0, CurrentLcn = Lcn.GetLowPart();
         i < RunLength.GetLowPart();
         i++, CurrentLcn++ ) {

        if( _Bitmap.IsBitSet( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}

BIG_INT
NTFS_BITMAP::QueryFreeBlockSize(
    IN LCN Lcn
    ) CONST
/*++

Routine Description:

    This method determines the size of the free block starting at
    the given location.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run

Return Value:

    Number of contiguous free cluster

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG CurrentLcn;


    if( Lcn < 0 ||
        Lcn > _NumberOfClusters ) {

        return FALSE;
    }

    DebugAssert(Lcn.GetHighPart() == 0);
    DebugAssert(_NumberOfClusters.GetHighPart() == 0);

    for( CurrentLcn = Lcn.GetLowPart();
         CurrentLcn < _NumberOfClusters;
         CurrentLcn++ ) {

        if( _Bitmap.IsBitSet( CurrentLcn ) ) {

            return (CurrentLcn - Lcn.GetLowPart());
        }
    }

    return (CurrentLcn - Lcn.GetLowPart());
}

UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::IsAllocated(
    IN LCN Lcn,
    IN BIG_INT  RunLength
    ) CONST
/*++

Routine Description:

    This method determines whether the specified cluster run is
    marked as used in the bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run
    RunLength   -- supplies the length of the run

Return Value:

    TRUE if all clusters in the run are in use in the bitmap.

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG i, CurrentLcn;


    if( Lcn < 0 ||
        Lcn + RunLength > _NumberOfClusters ) {

        return FALSE;
    }

    // Note that, since _NumberOfClusters is not greater than the
    // maximum ULONG, the high parts of Lcn and RunLength are
    // sure to be zero.

    for( i = 0, CurrentLcn = Lcn.GetLowPart();
         i < RunLength.GetLowPart();
         i++, CurrentLcn++ ) {

        if( !_Bitmap.IsBitSet( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_BITMAP::AllocateClusters(
    IN  LCN     NearHere,
    IN  BIG_INT RunLength,
    OUT PLCN    FirstAllocatedLcn,
    IN  ULONG   AlignmentFactor
    )
/*++

Routine Description:

    This method finds a free run of sectors and marks it as allocated.

    If the bitmap being allocated from is the volume bitmap, this method
    will have a valid _Drive member.  In this case, it will attempt to
    verify that only usable clusters are allocated.  If _Mft is also
    set, any bad clusters found will be added to the bad cluster file.

Arguments:

    NearHere            -- supplies the LCN near which the caller would
                            like the space allocated.
    RunLength           -- supplies the number of clusters to be allocated
    FirstAllocatedLcn   -- receives the first LCN of the allocated run
    AlignmentFactor     -- supplies the alignment requirement for the
                            allocated run--it must start on a multiple
                            of AlignmentFactor.

Return Value:

    TRUE upon successful completion; FirstAllocatedLcn receives the
    LCN of the first cluster in the run.

--*/
{
    ULONG       current_lcn;
    LCN         first_allocated_lcn;
    ULONG       count;
    BOOLEAN     verify_each;

    NTFS_BAD_CLUSTER_FILE badclus;

    if (NearHere == 0) {
        NearHere = _NextAlloc;
    }

    if (NearHere + RunLength >  _NumberOfClusters) {
        NearHere = _NumberOfClusters/2;
    }

    if( RunLength.GetHighPart() != 0 ) {

        DebugAbort( "UNTFS: Trying to allocate too many sectors.\n" );
        return FALSE;
    }

    //
    // First we'll allocate a run and verify the whole thing at once.
    // If that fails we'll go through the bitmap again, verifying each
    // cluster.
    //

    verify_each = FALSE;

again:

    // Search forwards for a big enough block.

    count = RunLength.GetLowPart();
    for (current_lcn = NearHere.GetLowPart();
         count > 0 && current_lcn < _NumberOfClusters;
         current_lcn += 1) {

        if (IsFree(current_lcn, 1)) {

            if (count == RunLength.GetLowPart() && current_lcn%AlignmentFactor != 0) {
                continue;
            }

            if (verify_each && NULL != _Drive) {

                // Insure that this cluster is functional and can accept IO.

                if (!_Drive->Verify(current_lcn * _ClusterFactor,
                                    _ClusterFactor)) {

                    // This cluster is bad.  Set the bit in the bitmap so we
                    // won't waste time trying to allocate it again and start
                    // over.

                    SetAllocated(current_lcn, 1);
                    count = RunLength.GetLowPart();

                    // If the bad cluster file is available, add this lcn
                    // to it.

                    if (NULL != _Mft) {
                        if (!badclus.Initialize(_Mft) ||
                            !badclus.Read() ||
                            !badclus.Add(current_lcn) ||
                            !badclus.Flush(this)) {
                            DebugPrintTrace(("Unable to update bad cluster file.  Bad Cluster at: %x\n",
                                             current_lcn));
                        }
                    }

                    continue;
                }
            }

            count -= 1;

        } else {
            count = RunLength.GetLowPart();
        }
    }

    //
    // If the forward search succeeded then allocate and return the
    // result.
    //

    if (count == 0) {

        first_allocated_lcn = current_lcn - RunLength;

        if (NULL != _Drive && !_Drive->Verify(first_allocated_lcn * _ClusterFactor,
                                              RunLength * _ClusterFactor,
                                              NULL)) {

            if (verify_each) {

                // If we have been here before, then the whole block is bad as
                // Verify cannot tell which individual cluster is/are bad

                SetAllocated(first_allocated_lcn, RunLength);
                verify_each = FALSE;
                NearHere = first_allocated_lcn + RunLength;

                if (NULL != _Mft) {
                    if (!badclus.Initialize(_Mft) ||
                        !badclus.Read() ||
                        !badclus.AddRun(first_allocated_lcn, RunLength) ||
                        !badclus.Flush(this)) {
                        DebugPrintTrace(("Unable to update bad cluster file.\n"
                                         "Bad Cluster starts at %x%x with run length %x%x\n",
                                         first_allocated_lcn.GetHighPart(),
                                         first_allocated_lcn.GetLowPart(),
                                         RunLength.GetHighPart(),
                                         RunLength.GetLowPart()));
                    }
                }

                goto again;
            }

            //
            // Want to go through each cluster in the run we found and
            // figure out which ones are bad.
            //

            verify_each = TRUE;
            NearHere = first_allocated_lcn;
            goto again;
        }

        *FirstAllocatedLcn = first_allocated_lcn;
        SetAllocated(first_allocated_lcn, RunLength);
        _NextAlloc = first_allocated_lcn + RunLength;
        return TRUE;
    }

    //
    // We couldn't find any space by searching forwards, so let's
    // search backwards.
    //

    verify_each = FALSE;

again_backward:

    count = RunLength.GetLowPart();
    for (current_lcn = NearHere.GetLowPart() + RunLength.GetLowPart() - 1;
         count > 0 && current_lcn > 0; current_lcn -= 1) {

        if (IsFree(current_lcn, 1)) {

            if (count == RunLength.GetLowPart() &&
                (current_lcn - RunLength.GetLowPart() + 1)%AlignmentFactor != 0) {

                continue;
            }

            if (verify_each && NULL != _Drive) {

                // Insure that this cluster is functional and can accept IO.

                if (!_Drive->Verify(current_lcn * _ClusterFactor,
                                    _ClusterFactor)) {

                    // This cluster is bad.  Set the bit in the bitmap so we
                    // won't waste time trying to allocate it again and start
                    // over.

                    SetAllocated(current_lcn, 1);
                    count = RunLength.GetLowPart();

                    // If the bad cluster file is available, add this lcn
                    // to it.

                    if (NULL != _Mft) {
                        if (!badclus.Initialize(_Mft) ||
                            !badclus.Read() ||
                            !badclus.Add(current_lcn) ||
                            !badclus.Flush(this)) {
                            DebugPrintTrace(("Unable to update bad cluster file.  Bad Cluster at: %x\n",
                                             current_lcn));
                        }
                    }

                    continue;
                }
            }

            count -= 1;
        } else {

            count = RunLength.GetLowPart();
        }
    }

    if (count != 0) {
        return FALSE;
    }

    first_allocated_lcn = current_lcn + 1;

    if (NULL != _Drive && !_Drive->Verify(first_allocated_lcn * _ClusterFactor,
                                          RunLength * _ClusterFactor,
                                          NULL)) {

        if (verify_each) {

            // If we have been here before, then the whole block is bad as
            // Verify cannot tell which individual cluster is/are bad

            SetAllocated(first_allocated_lcn, RunLength);
            verify_each = FALSE;
            NearHere = first_allocated_lcn - RunLength;

            if (NULL != _Mft) {
                if (!badclus.Initialize(_Mft) ||
                    !badclus.Read() ||
                    !badclus.AddRun(first_allocated_lcn, RunLength) ||
                    !badclus.Flush(this)) {
                    DebugPrintTrace(("Unable to update bad cluster file.\n"
                                     "Bad Cluster starts at %x%x with run length %x%x\n",
                                     first_allocated_lcn.GetHighPart(),
                                     first_allocated_lcn.GetLowPart(),
                                     RunLength.GetHighPart(),
                                     RunLength.GetLowPart()));
                }
            }

            goto again_backward;
        }

        //
        // Want to go through each cluster in the run we found and
        // figure out which ones are bad.
        //

        verify_each = TRUE;
        NearHere = first_allocated_lcn + RunLength + 1;
        goto again_backward;
    }

    //
    // Since we had to search backwards, we don't want to start
    // our next search from here (and waste time searching forwards).
    // Instead, set the roving pointer to zero.
    //

    *FirstAllocatedLcn = first_allocated_lcn;
    SetAllocated(first_allocated_lcn, RunLength);
    _NextAlloc = 0;

    return TRUE;
}


BOOLEAN
NTFS_BITMAP::Resize(
    IN BIG_INT NewNumberOfClusters
    )
/*++

Routine Description:

    This method changes the number of allocation units that the bitmap
    covers.  It may either grow or shrink the bitmap.

Arguments:

    NewNumberOfClusters --  supplies the new number of allocation units
                            covered by this bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    The size (in bytes) of the bitmap is always kept quad-aligned, and
    any padding bits are reset.

--*/
{
    PVOID NewBitmapData;
    ULONG NewSize;
    LCN OldNumberOfClusters;


    DebugAssert( _IsGrowable );


    // Make sure that the number of clusters fits into a ULONG,
    // so we can continue to use BITVECTOR.

    if( NewNumberOfClusters.GetHighPart() != 0 ) {

        DebugPrint( "bitmap.cxx:  cannot manage a volume of this size.\n" );
        return FALSE;
    }

    // Compute the new size of the bitmap, in bytes.  Note that this
    // size is always quad-aligned (ie. a multiple of 8).

    NewSize = ( NewNumberOfClusters.GetLowPart() % 8 ) ?
                    ( NewNumberOfClusters.GetLowPart()/8 + 1) :
                    ( NewNumberOfClusters.GetLowPart()/8 );

    NewSize = QuadAlign( NewSize );

    if( NewSize == _BitmapSize ) {

        // The bitmap is already the right size, so it's just a matter
        // of diddling the private data.  Since padding in a growable
        // bitmap is always reset (free), the new space is by default
        // free.

        _NumberOfClusters = NewNumberOfClusters;
        return TRUE;
    }

    // The bitmap has changed size, so we need to allocate new memory
    // for it and copy it.

    if( (NewBitmapData = MALLOC( NewSize )) == NULL ) {

        return FALSE;
    }

    // Note that, if we supply the memory, BITVECTOR::Initialize
    // cannot fail, so we don't check its return value.

    _Bitmap.Initialize( NewSize * 8,
                        RESET,
                        (PPT)NewBitmapData );

    if( NewNumberOfClusters < _NumberOfClusters ) {

        // Copy the part of the old bitmap that we wish to
        // preserve into the new bitmap.

        memcpy( NewBitmapData,
                _BitmapData,
                NewSize );

    } else {

        // Copy the old bitmap into the new bitmap, and then
        // mark all the newly claimed space as unused.

        memcpy( NewBitmapData,
                _BitmapData,
                _BitmapSize );

        SetFree( _NumberOfClusters,
                 NewNumberOfClusters - _NumberOfClusters );
    }

    FREE( _BitmapData );
    _BitmapData = NewBitmapData;

    _BitmapSize = NewSize;
    _NumberOfClusters = NewNumberOfClusters;

    // Make sure the padding bits are reset.

    _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                      _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    return TRUE;
}


VOID
NTFS_BITMAP::SetGrowable(
    IN  BOOLEAN Growable
    )
/*++

Routine Description:

    This method changes whether the bitmap is growable or not.  This
    primarily effects the padding bits, if any, at the end of the bitmap.
    They are clear for growable bitmaps and set for non-growable ones.

Arguments:

    Growable -- Whether the bitmap should be growable.

Return Value:

    None.

--*/
{
    if (Growable) {

        _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                          _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );
    } else {

        _Bitmap.SetBit( _NumberOfClusters.GetLowPart(),
                        _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Pre-compiled header for untfs.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif

#include "untfs.hxx"
#include "attrcol.hxx"
#include "attrdef.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "attrrec.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "bootfile.hxx"
#include "clusrun.hxx"
#include "extents.hxx"
#include "frs.hxx"
#include "frsstruc.hxx"
#include "hackwc.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"
#include "logfile.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "mftinfo.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "ntfssa.hxx"
#include "ntfsvol.hxx"
#include "rafile.hxx"
#include "rasd.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "ifssys.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\rasd.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rasd.cxx

Abstract:

    This module implements the read ahead algorithm for the
    security descriptor verification stage of chkdsk.

Author:

    Daniel Chan (danielch) 09-Dec-98

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "rasd.hxx"

PNTFS_SA                    RA_PROCESS_SD::_sa;
ULONG64                     RA_PROCESS_SD::_total_number_of_frs;
PVCN                        RA_PROCESS_SD::_first_frs_number;
PULONG                      RA_PROCESS_SD::_number_of_frs_to_read;
PNTFS_FILE_RECORD_SEGMENT   RA_PROCESS_SD::_frs1;
PNTFS_FILE_RECORD_SEGMENT   RA_PROCESS_SD::_frs2;
HANDLE                      RA_PROCESS_SD::_read_ahead_event;
HANDLE                      RA_PROCESS_SD::_read_ready_event;
PNTFS_MASTER_FILE_TABLE     RA_PROCESS_SD::_mft;

DEFINE_EXPORTED_CONSTRUCTOR( RA_PROCESS_SD, OBJECT, UNTFS_EXPORT );

BOOLEAN
NTFS_SA::StartProcessingSD(
    IN      BIG_INT                  TotalNumberOfFrs,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE  Mft,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET              BadClusters,
    IN OUT  PULONG                   ErrFixedStatus,
    IN      BOOLEAN                  SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET              SidEntries,
    IN OUT  PNUMBER_SET              SidEntries2,
    IN OUT  PBOOLEAN                 HasErrors,
    IN      BOOLEAN                  SkipEntriesScan,
    IN OUT  PBOOLEAN                 ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine initializes all the synchronization objects,
    creates the read-ahead thread, and start the processing
    routine.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    RA_PROCESS_SD               ra_process_sd;
    HANDLE                      thread_handle;
    NTFS_FILE_RECORD_SEGMENT    frs1, frs2;
    HANDLE                      read_ahead_event;
    HANDLE                      read_ready_event;
    VCN                         first_frs_number;
    ULONG                       number_of_frs_to_read;
    BOOLEAN                     status;

    NTSTATUS                    ntstatus;
    LARGE_INTEGER               timeout;
    THREAD_BASIC_INFORMATION    basic_info;
    SYSTEM_BASIC_INFORMATION    system_basic_info;
    OBJECT_ATTRIBUTES           objAttr;


    if (TotalNumberOfFrs == 0)
        return TRUE;

    ntstatus = NtQuerySystemInformation(SystemBasicInformation,
                                        &system_basic_info,
                                        sizeof(system_basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        // assume single proc and proceed
        DebugPrintTrace(("UNTFS: Unable to determine number of processors.  Assume one.\n"));
        system_basic_info.NumberOfProcessors = 1;
    }

    if (system_basic_info.NumberOfProcessors == 1) {

        // if UP then use single thread approach

        return ProcessSD2(TotalNumberOfFrs,
                          FixLevel,
                          Mft,
                          ChkdskReport,
                          ChkdskInfo,
                          SecurityFrs,
                          BadClusters,
                          ErrFixedStatus,
                          SecurityDescriptorStreamPresent,
                          SidEntries,
                          SidEntries2,
                          HasErrors,
                          SkipEntriesScan,
                          ChkdskErrCouldNotFix,
                          Message);
    }

    // create the read ahead event which signals when the read ahead thread should start reading

    InitializeObjectAttributes(&objAttr,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    ntstatus = NtCreateEvent(&read_ahead_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        DebugPrintTrace(("UNTFS: Unable to create read ahead event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    // create the read ready event which signals when the read is completed

    ntstatus = NtCreateEvent(&read_ready_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);

        DebugPrintTrace(("UNTFS: Unable to create read ready event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    RA_PROCESS_SD::Initialize(this,
                              TotalNumberOfFrs,
                              &first_frs_number,
                              &number_of_frs_to_read,
                              &frs1,
                              &frs2,
                              read_ahead_event,
                              read_ready_event,
                              Mft);

    // create the read ahead thread

    ntstatus = RtlCreateUserThread(NtCurrentProcess(),
                                   NULL,
                                   FALSE,
                                   0,
                                   0,
                                   0,
                                   RA_PROCESS_SD::ProcessSDWrapper,
                                   &ra_process_sd,
                                   &thread_handle,
                                   NULL);

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);
        NtClose(read_ready_event);

        Message->DisplayMsg(MSG_CHK_UNABLE_TO_CREATE_THREAD, "%x", ntstatus);
        return FALSE;
    }

    status = ProcessSD(TotalNumberOfFrs,
                       &first_frs_number,
                       &number_of_frs_to_read,
                       &frs1,
                       &frs2,
                       read_ahead_event,
                       read_ready_event,
                       thread_handle,
                       FixLevel,
                       Mft,
                       ChkdskReport,
                       ChkdskInfo,
                       SecurityFrs,
                       BadClusters,
                       ErrFixedStatus,
                       SecurityDescriptorStreamPresent,
                       SidEntries,
                       SidEntries2,
                       HasErrors,
                       SkipEntriesScan,
                       ChkdskErrCouldNotFix,
                       Message);

    //
    // Clean up the read ahead thread if it is still alive
    //
    number_of_frs_to_read = 0;
    ntstatus = NtSetEvent(read_ahead_event, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // wait for the read ahead thread to terminate

    timeout.QuadPart = -2000000000;     // 200 seconds
    ntstatus = NtWaitForSingleObject(thread_handle, FALSE, &timeout);
    if (ntstatus != STATUS_WAIT_0) {
        DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // check the exit code of the read ahead thread

    ntstatus = NtQueryInformationThread(thread_handle,
                                        ThreadBasicInformation,
                                        &basic_info,
                                        sizeof(basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    if (!NT_SUCCESS(basic_info.ExitStatus)) {
        DebugPrintTrace(("Premature termination of files read ahead thread (%x)\n", basic_info.ExitStatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    NtClose(read_ahead_event);
    NtClose(read_ready_event);
    NtClose(thread_handle);

    return status;
}

UNTFS_EXPORT
RA_PROCESS_SD::~RA_PROCESS_SD(
)
{
    Destroy();
}

VOID
RA_PROCESS_SD::Construct(
)
{
}

VOID
RA_PROCESS_SD::Destroy(
)
{
}

NTSTATUS
RA_PROCESS_SD::ProcessSDWrapper(
    IN OUT PVOID      lpParameter
)
{
    return  RA_PROCESS_SD::GetSa()->SDReadAhead(RA_PROCESS_SD::GetTotalNumberOfFrs(),
                                                RA_PROCESS_SD::GetFirstFrsNumber(),
                                                RA_PROCESS_SD::GetNumberOfFrsToRead(),
                                                RA_PROCESS_SD::GetFrs1(),
                                                RA_PROCESS_SD::GetFrs2(),
                                                RA_PROCESS_SD::GetReadAheadEvent(),
                                                RA_PROCESS_SD::GetReadReadyEvent(),
                                                RA_PROCESS_SD::GetMft());
}

BOOLEAN
RA_PROCESS_SD::Initialize(
    IN      PNTFS_SA                    Sa,
    IN      BIG_INT                     TotalNumberOfFrs,
    IN      PVCN                        FirstFrsNumber,
    IN      PULONG                      NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs2,
    IN      HANDLE                      ReadAheadEvent,
    IN      HANDLE                      ReadReadyEvent,
    IN      PNTFS_MASTER_FILE_TABLE     Mft
)
{
    _sa = Sa;
    _total_number_of_frs = TotalNumberOfFrs.GetQuadPart();
    _first_frs_number = FirstFrsNumber;
    _number_of_frs_to_read = NumberOfFrsToRead;
    _frs1 = Frs1;
    _frs2 = Frs2;
    _read_ahead_event = ReadAheadEvent;
    _read_ready_event = ReadReadyEvent;
    _mft = Mft;

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessSD(
    IN      BIG_INT                   TotalNumberOfFrs,
       OUT  PVCN                      FirstFrsNumber,
       OUT  PULONG                    NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT Frs2,
    IN      HANDLE                    ReadAheadEvent,
       OUT  HANDLE                    ReadReadyEvent,
    IN      HANDLE                    ThreadHandle,
    IN      FIX_LEVEL                 FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE   Mft,
    IN OUT  PNTFS_CHKDSK_REPORT       ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO         ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET               BadClusters,
    IN OUT  PULONG                    ErrFixedStatus,
    IN      BOOLEAN                   SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET               SidEntries,
    IN OUT  PNUMBER_SET               SidEntries2,
    IN OUT  PBOOLEAN                  HasErrors,
    IN      BOOLEAN                   SkipEntriesScan,
    IN OUT  PBOOLEAN                  ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                  Message
)
/*++

Routine Description:

    This routine controls the read-ahead thread and
    checks the security descriptor or security id
    of each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    Frs1             - Supplies the shared frs object for read-ahead use.
    Frs2             - Supplies the shared frs object for read-ahead use.
    ReadAheadEvent   - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReadyEvent   - Supplies the event to tell this routine that data is ready.
    ThreadHandle     - Supplies the handle to the read-ahead thread.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                             diskHasErrors;
    BOOLEAN                             need_new;
    BOOLEAN                             has_security_descriptor_attribute;
    NTFS_ATTRIBUTE                      attrib;
    BOOLEAN                             error;
    ULONG                               length;
    PSECURITY_DESCRIPTOR                security;
    ULONG                               num_bytes;
    ULONG                               bytesWritten;
    PSTANDARD_INFORMATION2              standard_information2;
    ULONG                               securityId;

    VCN                                 i;
    BIG_INT                             time_to_read;
    PNTFS_FILE_RECORD_SEGMENT           frs, last_frs;
    BOOLEAN                             changes;

    BOOLEAN                             first_read;
    BOOLEAN                             read_status;
    ULONG                               percent_done;

    NTSTATUS                            ntstatus;
    THREAD_BASIC_INFORMATION            basic_info;
    LARGE_INTEGER                       timeout;

    *FirstFrsNumber = 0;
    if (TotalNumberOfFrs >= MFT_READ_CHUNK_SIZE)
        *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;
    else
        *NumberOfFrsToRead = TotalNumberOfFrs.GetLowPart();

    ntstatus = NtSetEvent(ReadAheadEvent, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        return FALSE;
    }

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    frs = Frs2;
    time_to_read = 0;
    timeout.QuadPart = -2000000000;     // 200 seconds

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i == (SECURITY_TABLE_NUMBER+1)) {
            frs = last_frs;
        }

        if (i == time_to_read) {

            BIG_INT     remaining_frs;
            ULONG       number_to_read;
            ULONG       exit_code;

            ntstatus = NtWaitForSingleObject(ReadReadyEvent, FALSE, &timeout);
            if (ntstatus != STATUS_WAIT_0) {
                DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
                return FALSE;
            }

            //
            // The advancing of frs number needs to keep in sync with that in FilesReadAhead
            //
            time_to_read += *NumberOfFrsToRead;
            *FirstFrsNumber = time_to_read;
            remaining_frs = TotalNumberOfFrs - time_to_read;

            if (remaining_frs.GetLowPart() < MFT_READ_CHUNK_SIZE &&
                remaining_frs.GetHighPart() == 0)
                *NumberOfFrsToRead = remaining_frs.GetLowPart();
            else
                *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;

            ntstatus = NtQueryInformationThread(ThreadHandle,
                                                ThreadBasicInformation,
                                                &basic_info,
                                                sizeof(basic_info),
                                                NULL);

            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (basic_info.ExitStatus != STATUS_PENDING && !NT_SUCCESS(basic_info.ExitStatus)) {
                DebugPrintTrace(("UNTFS: Premature termination of files read ahead thread (%x)\n",
                                 basic_info.ExitStatus));
                return FALSE;
            }

            ntstatus = NtSetEvent(ReadAheadEvent, NULL);
            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (frs == Frs2)  {
                frs = Frs1;
            } else {
                DebugAssert(frs == Frs1);
                frs = Frs2;
            }

            first_read = TRUE;
        }

        if (first_read) {
            first_read = FALSE;
            read_status = frs->ReadAgain(i);
        } else {
            if (!frs->Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            read_status = frs->ReadNext(i);
        }

        if (i == SECURITY_TABLE_NUMBER) {
            last_frs = frs;
            frs = SecurityFrs;
        } else {
            if (!read_status)
                continue;
        }

        if (Mft->GetMftBitmap()->IsFree(i, 1)) {
            continue;
        }

        if (!frs->IsInUse() || !frs->IsBase()) {
            continue;
        }

        if (SkipEntriesScan &&
            !ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1)) {
            diskHasErrors = FALSE;
            if (!frs->VerifyAndFixFileNames(Mft->GetMftBitmap(),
                                             ChkdskInfo,
                                             FixLevel,
                                             Message,
                                             &diskHasErrors,
                                             FALSE)) {
                return FALSE;
            } else if (diskHasErrors) {
                // no need to set hasErrors as this has nothing to do with security descriptor
                *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        need_new = has_security_descriptor_attribute = FALSE;

        if (frs->QueryAttribute(&attrib, &error, $SECURITY_DESCRIPTOR)) {

            // First recover this attribute to make sure that
            // everything is readable.

            if (FixLevel != CheckOnly) {
                attrib.RecoverAttribute(Mft->GetVolumeBitmap(), BadClusters);
            }

            // Read in the security descriptor and validate.

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.QueryValueLength().GetHighPart() != 0 ||
                !(security = (PSECURITY_DESCRIPTOR) MALLOC(length))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            error = FALSE;
            if (!attrib.Read(security, 0, length, &num_bytes)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_SECURITY_DESCRIPTOR,
                             "%x", i);

                error = TRUE;
            } else if (num_bytes != length) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_SECURITY_DESCRIPTOR,
                             "%x", i);

                error = TRUE;
            } else if (!IFS_SYSTEM::CheckValidSecurityDescriptor(length, (PISECURITY_DESCRIPTOR)security) ||
                       length < RtlLengthSecurityDescriptor(security)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_SECURITY_DESCRIPTOR_IN_FILE,
                             "%x", i);

                error = TRUE;
            }

            if (error) {

                if (!attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs->PurgeAttribute($SECURITY_DESCRIPTOR)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_new = TRUE;
            } else
                has_security_descriptor_attribute = TRUE;

            FREE(security);

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            need_new = (ChkdskInfo->major <= 1);
        }

        if (ChkdskInfo->major >= 2) {
            if (frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
                length = attrib.QueryValueLength().GetLowPart();
                if (length == sizeof(STANDARD_INFORMATION2)) {

                    if (!SecurityDescriptorStreamPresent)
                        continue;

                    if (!(standard_information2 =
                          (PSTANDARD_INFORMATION2)attrib.GetResidentValue())) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    securityId = standard_information2->SecurityId;

                    if (securityId == SECURITY_ID_INVALID)
                        continue;

                    if (has_security_descriptor_attribute ||
                        !SidEntries->DoesIntersectSet(securityId, 1)) {

                        standard_information2->SecurityId = SECURITY_ID_INVALID;
                        Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_ID,
                                            "%d", i);

                        *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (FixLevel != CheckOnly &&
                            (!attrib.Write((PVOID)standard_information2,
                                           0,
                                           sizeof(STANDARD_INFORMATION2),
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                             bytesWritten != sizeof(STANDARD_INFORMATION2))) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
                            !attrib.InsertIntoFile(frs, Mft->GetVolumeBitmap())) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly &&
                            !frs->Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", frs->QueryFileNumber().GetLowPart());
                            return FALSE;
                        }
                        continue;
                    } // if (!SidEntries->DoesIntersectSet(...
                    SidEntries2->Add(standard_information2->SecurityId);
                    continue;
                } // if (length == sizeof(STANDARD_INFORMATION2))
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                DebugPrint("Standard Information Missing\n");
                return FALSE;
            }
        }

        if (need_new) {

            Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_DESCRIPTOR,
                                "%d", i);

            *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (FixLevel != CheckOnly) {
                if (!frs->AddSecurityDescriptor(EditCannedSd,
                                                Mft->GetVolumeBitmap()) ||
                    !frs->Flush(Mft->GetVolumeBitmap())) {

                    *ChkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                                        "%d", i);
                }
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessSD2(
    IN      BIG_INT                   TotalNumberOfFrs,
    IN      FIX_LEVEL                 FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE   Mft,
    IN OUT  PNTFS_CHKDSK_REPORT       ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO         ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET               BadClusters,
    IN OUT  PULONG                    ErrFixedStatus,
    IN      BOOLEAN                   SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET               SidEntries,
    IN OUT  PNUMBER_SET               SidEntries2,
    IN OUT  PBOOLEAN                  HasErrors,
    IN      BOOLEAN                   SkipEntriesScan,
    IN OUT  PBOOLEAN                  ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                  Message
)
/*++

Routine Description:

    This routine checks the security descriptor or security id
    of each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                             diskHasErrors;
    BOOLEAN                             need_new;
    BOOLEAN                             has_security_descriptor_attribute;
    NTFS_ATTRIBUTE                      attrib;
    BOOLEAN                             error;
    ULONG                               length;
    PSECURITY_DESCRIPTOR                security;
    ULONG                               num_bytes;
    ULONG                               bytesWritten;
    PSTANDARD_INFORMATION2              standard_information2;
    ULONG                               securityId;

    VCN                                 i;
    PNTFS_FILE_RECORD_SEGMENT           frs;
    NTFS_FILE_RECORD_SEGMENT            myfrs;
    BOOLEAN                             changes;

    ULONG                               percent_done;


    DebugAssert(TotalNumberOfFrs.GetHighPart() == 0);

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {

            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = (TotalNumberOfFrs - i).GetLowPart();
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!myfrs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (i == SECURITY_TABLE_NUMBER) {
            frs = SecurityFrs;
            // no need to read the security frs as it's already initialized
            if (!myfrs.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            myfrs.ReadNext(i);      // dummy read
        } else {
            frs = &myfrs;
            if (!myfrs.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!myfrs.ReadNext(i))
                continue;
        }

        if (Mft->GetMftBitmap()->IsFree(i, 1)) {
            continue;
        }

        if (!frs->IsInUse() || !frs->IsBase()) {
            continue;
        }

        if (SkipEntriesScan &&
            !ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1)) {
            diskHasErrors = FALSE;
            if (!frs->VerifyAndFixFileNames(Mft->GetMftBitmap(),
                                             ChkdskInfo,
                                             FixLevel,
                                             Message,
                                             &diskHasErrors,
                                             FALSE)) {
                return FALSE;
            } else if (diskHasErrors) {
                // no need to set hasErrors as this has nothing to do with security descriptor
                *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        need_new = has_security_descriptor_attribute = FALSE;

        if (frs->QueryAttribute(&attrib, &error, $SECURITY_DESCRIPTOR)) {

            // First recover this attribute to make sure that
            // everything is readable.

            if (FixLevel != CheckOnly) {
                attrib.RecoverAttribute(Mft->GetVolumeBitmap(), BadClusters);
            }

            // Read in the security descriptor and validate.

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.QueryValueLength().GetHighPart() != 0 ||
                !(security = (PSECURITY_DESCRIPTOR) MALLOC(length))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!attrib.Read(security, 0, length, &num_bytes) ||
                num_bytes != length ||
                !IFS_SYSTEM::CheckValidSecurityDescriptor(length, (PISECURITY_DESCRIPTOR)security) ||
                length < RtlLengthSecurityDescriptor(security)) {

                if (!attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs->PurgeAttribute($SECURITY_DESCRIPTOR)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_new = TRUE;
            } else
                has_security_descriptor_attribute = TRUE;

            FREE(security);

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            need_new = (ChkdskInfo->major <= 1);
        }

        if (ChkdskInfo->major >= 2) {
            if (frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
                length = attrib.QueryValueLength().GetLowPart();
                if (length == sizeof(STANDARD_INFORMATION2)) {

                    if (!SecurityDescriptorStreamPresent)
                        continue;

                    if (!(standard_information2 =
                          (PSTANDARD_INFORMATION2)attrib.GetResidentValue())) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    securityId = standard_information2->SecurityId;

                    if (securityId == SECURITY_ID_INVALID)
                        continue;

                    if (has_security_descriptor_attribute ||
                        !SidEntries->DoesIntersectSet(securityId, 1)) {

                        standard_information2->SecurityId = SECURITY_ID_INVALID;
                        Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_ID,
                                            "%d", i);

                        *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (FixLevel != CheckOnly &&
                            (!attrib.Write((PVOID)standard_information2,
                                           0,
                                           sizeof(STANDARD_INFORMATION2),
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                             bytesWritten != sizeof(STANDARD_INFORMATION2))) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
                            !attrib.InsertIntoFile(frs, Mft->GetVolumeBitmap())) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly &&
                            !frs->Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", frs->QueryFileNumber().GetLowPart());
                            return FALSE;
                        }
                        continue;
                    } // if (!SidEntries->DoesIntersectSet(...
                    SidEntries2->Add(standard_information2->SecurityId);
                    continue;
                } // if (length == sizeof(STANDARD_INFORMATION2))
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                DebugPrint("Standard Information Missing\n");
                return FALSE;
            }
        }

        if (need_new) {

            Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_DESCRIPTOR, "%d", i);

            *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (FixLevel != CheckOnly) {
                if (!frs->AddSecurityDescriptor(EditCannedSd,
                                                Mft->GetVolumeBitmap()) ||
                    !frs->Flush(Mft->GetVolumeBitmap())) {

                    *ChkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                                        "%d", i);
                }
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
NTFS_SA::SDReadAhead(
    IN      BIG_INT                     TotalNumberOfFrs,
    IN      PVCN                        FirstFrsNumber,
    IN      PULONG                      NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs2,
       OUT  HANDLE                      ReadAhead,
    IN      HANDLE                      ReadReady,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft
)
/*++

Routine Description:

    This routine performs the read-ahead action.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    Frs1             - Supplies the shared frs object for read-ahead use.
    Frs2             - Supplies the shared frs object for read-ahead use.
    ReadAhead        - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReady        - Supplies the event to tell this routine that data is ready.
    Mft              - Supplies a valid MFT.

Return Value:

    STATUS_SUCCESS   - Success

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   frs = Frs2;
    NTSTATUS                    ntstatus;

    for(;;) {

        //
        // The advancing of frs number needs to keep in sync with that in ProcessFiles
        //

        ntstatus = NtWaitForSingleObject(ReadAhead, FALSE, NULL) ;
        if (ntstatus != STATUS_WAIT_0) {
            DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
            return ntstatus;
        }

        if (*NumberOfFrsToRead == 0)
            break;

        if (frs == Frs2) {
            frs = Frs1;
        } else {
            DebugAssert(frs == Frs1);
            frs = Frs2;
        }

        if (!frs->Initialize(*FirstFrsNumber,
                             *NumberOfFrsToRead,
                             Mft)) {
            DebugPrintTrace(("Out of Memory\n"));
            return STATUS_NO_MEMORY;
        }

        //
        // ignore the error as the main process will run into it again on ReadAgain()