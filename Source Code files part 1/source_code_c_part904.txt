ULT(pixSrc.pix.g,pixSrc.pix.a,Temp);
                sG = Temp;

                INT_MULT(pixSrc.pix.b,pixSrc.pix.a,Temp);
                sB = Temp;

                INT_MULT(pixSrc.pix.a,pixSrc.pix.a,Temp);
                sA = Temp;
            }
            break;
    
        case AC_DST_COLOR:
        case AC_ONE_MINUS_DST_COLOR:
        {    
            ALPHAPIX paltDst = pixDst;
            int Temp;
    
            if (BlendFunction.SourceBlend == AC_ONE_MINUS_DST_COLOR)
            {
                paltDst.pix.r  = 255 - pixDst.pix.r;
                paltDst.pix.g  = 255 - pixDst.pix.g;
                paltDst.pix.b  = 255 - pixDst.pix.b;
                paltDst.pix.a  = 255 - pixDst.pix.a;
            }

            INT_MULT(pixDst.pix.r,pixSrc.pix.r,Temp);
            sR = Temp;

            INT_MULT(pixDst.pix.g,pixSrc.pix.g,Temp);
            sG = Temp;
    
            INT_MULT(pixDst.pix.b,pixSrc.pix.b,Temp);
            sB = Temp;
    
            INT_MULT(pixDst.pix.a,pixSrc.pix.a,Temp);
            sA = Temp;
    
        }
        break;

        case AC_SRC_OVER:
        case AC_SRC_UNDER:

            WARNING("General blend doesn't operate on OVER and UNDER\n");
            break;

        default:
            RIP("Error in source alpha blend function\n");
        }
    
        //
        // destination blend
        //
    
        switch (BlendFunction.DestinationBlend)
        {
        case AC_ZERO:
            dR = 0;
            dG = 0;
            dB = 0;
            dA = 0;
            break;
    
        case AC_ONE:
            dR = pixDst.pix.r;
            dG = pixDst.pix.g;
            dB = pixDst.pix.b;
            dA = pixDst.pix.a;
            break;
    
        case AC_SRC_ALPHA:
        case AC_ONE_MINUS_SRC_ALPHA:
            {
                BYTE Alpha = pixSrc.pix.a;
                int Temp;

                if (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_ALPHA)
                {
                    Alpha = 255 - Alpha;
                }

                INT_MULT(pixDst.pix.r,Alpha,Temp);
                dR = Temp;

                INT_MULT(pixDst.pix.g,Alpha,Temp);
                dG = Temp;

                INT_MULT(pixDst.pix.b,Alpha,Temp);
                dB = Temp;

                INT_MULT(pixDst.pix.a,Alpha,Temp);
                dA = Temp;
            }
            break;
    
        case AC_SRC_COLOR:
        case AC_ONE_MINUS_SRC_COLOR:
        {    
            ALPHAPIX paltSrc = pixSrc;
            int Temp;
    
            if (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_COLOR)
            {
                paltSrc.pix.r = 255 - pixSrc.pix.r;
                paltSrc.pix.g = 255 - pixSrc.pix.g;
                paltSrc.pix.b = 255 - pixSrc.pix.b;
                paltSrc.pix.a = 255 - pixSrc.pix.a;
            }
    
            INT_MULT(pixDst.pix.r,paltSrc.pix.r,Temp);
            dR = Temp;

            INT_MULT(pixDst.pix.g,paltSrc.pix.g,Temp);
            dG = Temp; 

            INT_MULT(pixDst.pix.b,paltSrc.pix.b,Temp);
            dB = Temp; 

            INT_MULT(pixDst.pix.a,paltSrc.pix.a,Temp);
            dA = Temp; 
        }
        break;

        case AC_SRC_OVER:
        case AC_SRC_UNDER:

            WARNING("General blend doesn't operate on OVER and UNDER\n");
            break;

        default:
            RIP("Error in source alpha blend function\n");
    
        }
    
        pixRet.pix.r = sR + dR;
        pixRet.pix.g = sG + dG;
        pixRet.pix.b = sB + dB;
        pixRet.pix.a = sA + dA;

        *ppixDst = pixRet;

        ppixSrc++;
        ppixDst++;
    }
}

/**************************************************************************\
* vPixelOver
*   
*   optimized routine used when the blend function is SRC_OVER and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   none
*
* History:
*
*    1/23/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vPixelOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                pixDst = pixSrc;
            }
            else
            {
                //
                // Dst = Src + (1-SrcAlpha) * Dst
                //

                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);
                
                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;
                
                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;
                
                
                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;
                
                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#endif

/**************************************************************************\
* vPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*           (Blend)
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*           (Dissolve)
*           Src = Src * ConstAlpha
*           (Over)
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlendOrDissolveOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                //
                // Blend: D = sA * S + (1-sA) * D
                //
                // red and blue
                //
        
                ULONG uB00rr00bb = pixDst.ul & 0x00ff00ff;
                ULONG uF00rr00bb = pixSrc.ul & 0x00ff00ff;
        
                ULONG uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                                   (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;
        
                ULONG uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;
        
                ULONG uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;
        
                //
                // alpha and green
                //
        
                ULONG uB00aa00gg = (pixDst.ul >> 8) & 0xff00ff;
                ULONG uF00aa00gg = (pixSrc.ul >> 8) & 0xff00ff;
        
                ULONG uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                                   (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;
        
                ULONG uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;
        
                ULONG uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;
        
                pixDst.ul  = uD00rr00bb + uDaa00gg00;
            }
            else
            {
                //
                // disolve
                //

                ULONG ul_B_00AA00GG = (pixSrc.ul & 0xff00ff00) >> 8;
                ULONG ul_B_00RR00BB = (pixSrc.ul & 0x00ff00ff);
        
                ULONG ul_T_AAAAGGGG = ul_B_00AA00GG * ConstAlpha + 0x00800080;
                ULONG ul_T_RRRRBBBB = ul_B_00RR00BB * ConstAlpha + 0x00800080;
        
                ULONG ul_T_00AA00GG = (ul_T_AAAAGGGG & 0xFF00FF00) >> 8;
                ULONG ul_T_00RR00BB = (ul_T_RRRRBBBB & 0xFF00FF00) >> 8;
        
                ULONG ul_C_AA00GG00 = ((ul_T_AAAAGGGG + ul_T_00AA00GG) & 0xFF00FF00);
                ULONG ul_C_00RR00BB = ((ul_T_RRRRBBBB + ul_T_00RR00BB) & 0xFF00FF00) >> 8;
        
                pixSrc.ul = (ul_C_AA00GG00 | ul_C_00RR00BB);

                //
                // over
                //


                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;


                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#if !defined(_X86_)

/******************************Public*Routine******************************\
* vPixelBlend
*   
*   Blend function used then BlendFunction is SRC_OVER and 
*   SourceConstantAlpha != 255, and Src image does NOT have
*   it's own alpha channel. (assume 255)
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlend(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    PULONG   pulSrc = (PULONG)ppixSrc;
    PULONG   pulDst = (PULONG)ppixDst;
    PULONG   pulSrcEnd = pulSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pulSrc != pulSrcEnd)
    {
        ULONG ulDst = *pulDst;
        ULONG ulSrc = *pulSrc;
        ULONG uB00rr00bb = ulDst & 0x00ff00ff;
        ULONG uF00rr00bb = ulSrc & 0x00ff00ff;

        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB00aa00gg;
        ULONG uF00aa00gg;
        ULONG uMaaaagggg;
        ULONG uM00aa00gg;
        ULONG uDaa00gg00;

        //
        // red and blue
        //

        uB00rr00bb = ulDst & 0x00ff00ff;
        uF00rr00bb = ulSrc & 0x00ff00ff;

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // alpha and green
        //

        uB00aa00gg = (ulDst >> 8) & 0xff00ff;
        uF00aa00gg = (ulSrc >> 8) & 0xff00ff;

        uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                     (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;

        uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;

        uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;

        *pulDst = uD00rr00bb + uDaa00gg00;

        pulSrc++;
        pulDst++;
    }
}

#endif


#if defined(_X86_)

typedef unsigned __int64 QWORD;

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:

  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2.  Get (255 - alpha value) for each source pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand each byte in D1 into four words
	of an MMX register.  If at least four pixels can be done, do Step 4.  If not, jump over
	FourPixelsPerPass and finish doing two pixels at TwoPixelsLeft, Step 5.
  Step 4:
	FourPixelsPerPass
	Expand each byte in D2 into four words of an MMX register.  Multiply each byte
	of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate result
	of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the source pixels.  Store result
	over destination pixels.  Stay in FourPixelsPerPass loop until there are less than four pixels to do.
  Step 5:
    TwoPixelsLeft
	Do same as Step 4 above; but do not loop.
  Step 6:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelOver(
    ALPHAPIX       *pDst,
    ALPHAPIX       *pSrc,
	LONG			Width,
	BLENDFUNCTION	BlendFunction,
	PBYTE			pwrMask)
{
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;

	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// |  0  | 128 |  0  | 128 |  0  | 128 |  0  | 128 |
                                    //	This register never changes
        pxor		mm6, mm6		// |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
                                    //	This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
                                    // Step 3:
        movq		mm0, [esi]		// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        movq		mm2, [edi]		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
    
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
    
        dec			ecx
        jz			TwoPixelsLeft
    
    FourPixelsPerPass:				// Step 4:
        // Indenting indicates operations on the next set of pixels
        // Within this loop, instructions will pair as shown for the Pentium processor
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
    
        movq		mm0, [esi+8]	// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        add			esi, 8			// pSrc++;
    
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
    
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
    
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
                                    //	TDXx' = TX*DXx+128
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
    
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        movq		mm2, [edi+8]	// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi-8]
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movq		[edi], mm4
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
    
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        add			edi, 8			//	pDst++;
        
        dec			ecx
        jnz			FourPixelsPerPass
    
    TwoPixelsLeft:					// Step 5:
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
    
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi]
    
        movq		[edi], mm4
    
        add			edi, 8
        add			esi, 8
    
    OnePixelLeft:				    // Step 6:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
    
    Do1Pixel:						// make as a macro if used in asm file
                                    // T = 255-S1x
        movd		mm0, DWORD PTR[esi]		// |  0  |  0  |  0  |  0  | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  |  0  |  0  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  |  0  | 255 |  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movd		mm1, [edi]		// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm1, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm0, mm1		// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        movd        mm1, [esi]
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm1
        movd		[edi], mm0
        add			edi, 4			//	pDst++;
        add			esi, 4			//	pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/



/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:
	first,
  		pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
		pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
		pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
		pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
	then,
  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2, as one QWORD.  Expand S1 and S2 as four words into two MMX registers.
	Multiply each word in S1 and S2 by ConstAlpha.  Add 128 to each result of both pixels.  Copy the results
	of each pixel into an MMX register.  Shift each result of both pixels by 8.  Add the shifted results
	to the copied results.  Shift these results by 8.  Pack the results into one MMX register...this will
	be used later.
	Shift the packed results by 24 to get only the alpha value for each pixel.
  Step 4:
	Get (255 - new alpha value) for each pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand D1 and D2 as four words into two MMX registers.
	Multiply each byte of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate
	result of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the new source pixels saved from
	above.  Store result over destination pixels.  Stay in TwoPixelsAtOnceLoop loop until there is less than
	two pixels to do.
  Step 5:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelBlendOrDissolveOver(
    ALPHAPIX	  *pDst,
    ALPHAPIX	  *pSrc,
	LONG 	       Width,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;
	static QWORD Zeros = 0;
	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// This register never changes
        pxor		mm4, mm4		// This register never changes
    
        xor			eax, eax
        mov			al, ConstAlpha	
        movd		mm5, eax		// |		   |		   |		   |		CA |
        punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
        punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
                                    // This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
    TwoPixelsAtOnceLoop:			// Step 3:
        // Within this loop, instructions will pair as shown for the Pentium processor
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movq		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
    
        movq		mm1, mm0			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        punpckhbw	mm1, mm4			// |  0  | S2a |  0  | S2r |  0  | S2g |  0  | S2b |
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
    
        add			esi, 8			//	pSrc++;
        pmullw		mm1, mm5			// |	CA*S2a |	CA*S2r |	 CA*S2g |	CA*S2b |
    
        paddusw		mm1, mm7			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
    
                                    //	S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        movq		mm3, mm1			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        psrlw		mm1, 8				// |  S2a'>>8 |  S2r'>>8 |  S2g'>>8 |  S2b'>>8 |
    
                                    //	S1x" = (CA*S1x+128)>>8  S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        paddusw		mm1, mm3			// |  S2a"    |  S2r"    |  S2g"    |  S2b"    |
    
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
    
                                    //	SXx'" = ((CA*SXx+128)>>8)>>8)
        psrlw		mm1, 8				// |  S2a">>8 |  S2r">>8 |  S2g">>8 |  S2b">>8 |
        packuswb	mm0, mm1			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
    
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
                                    // Step 4:
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm1, mm0			// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |     0	   |     0	   |   255-S1a |   255-S1a |
    
        movq		mm2, [edi]			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpcklwd	mm0, mm0			// |   255-S1a |   255-S1a |   255-S1a |   255-S1a |
    
        movq		mm3, mm2			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1			// |     0	   |     0	   |   255-S2a |   255-S2a |
    
        punpcklwd	mm1, mm1			// |   255-S2a |   255-S2a |   255-S2a |   255-S2a |
    
        punpckhbw	mm3, mm4			// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
    
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpcklbw	mm2, mm4			// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm1, mm3			// |	T2*D2a |	T2*D2r |	 T2*D2g |	T2*D2b |
    
        add			edi, 8			//	pDst++;
        pmullw		mm0, mm2			// |	T1*D1a |	T1*D1r |	 T1*D1g |	T1*D1b |
    
        paddusw		mm0, mm7			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm1, mm7			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm3, mm1			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
                                    //  TDXx' = TX*DXx+128
        psrlw		mm1, 8				// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        movq		mm2, mm0			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        paddusw		mm1, mm3			// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        paddusw		mm0, mm2			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        psrlw		mm1, 8				// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        psrlw		mm0, 8				// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        packuswb	mm0, mm1		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
                                    //	SXx = SXx'"	TDXx = TDXx'"
        paddusb		mm0, mm6// |S2a+TD2a|S2r+TD2r|S2g+TD2g|S2b+TD2b|S1a+TD1a|S1r+TD1r|S1g+TD1g|S1b+TD1b|
    
        movq		[edi-8], mm0
    
        dec			ecx
        jnz			TwoPixelsAtOnceLoop
    
    OnePixelLeft:					// Step 5:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
        
    Do1Pixel:						// make as a macro if used in asm file
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movd		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
                                    //	 S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
                                    //	 S1x" = (CA*S1x+128)>>8 S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
        packuswb	mm0, mm0			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
    
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |  0  |  0  |  0  |  0  |  0  |  0  |255-S1a|255-S1a|
        punpckldq	mm0, mm0			// |    255-S1a|    255-S1a|    255-S1a|    255-S1a|
        movd		mm2, [edi]			// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm2, mm4			// |	   D1a |	   D1r |	   D1g |	   D1b |
                                    //	T = 255-S1x
        pmullw		mm0, mm2			// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm6  
        movd		[edi], mm0
        add			edi, 4			// pDst++;
        add			esi, 4			// pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

#endif











































/******************************Public*Routine******************************\
* AlphaScanLineBlend
*
*   Blends source and destionation surfaces one scan line at a time. 
*
*   Allocate a scan line buffer for xlate of src to 32BGRA if needed.
*   Allocate a scan line buffer for xlate of dst to 32BGRA if needed.
*   Blend scan line using blend function from pAlphaDispatch
*   Write scan line back to dst (if needed)
*      
* Arguments:
*   
*   pDst           - pointer to dst surface       
*   pDstRect       - Dst output rect
*   DeltaDst       - dst scan line delat
*   pSrc           - pointer to src surface
*   DeltaSrc       - src scan line delta      
*   pptlSrc        - src offset
*   pxloSrcTo32    - xlateobj from src to 32BGR
*   pxlo32ToDst    - xlateobj from 32BGR to dst
*   palDst         - destination palette
*   palSrc         - source palette
*   pAlphaDispatch - blend data and function pointers
*
* Return Value:
*
*   Status
*
* History:
*
*    10/14/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaScanLineBlend(
    PBYTE                    pDst,
    PRECTL                   pDstRect,
    ULONG                    DeltaDst,
    PBYTE                    pSrc,
    ULONG                    DeltaSrc,
    PPOINTL                  pptlSrc,
    PPALINFO                 ppalInfoDst,
    PPALINFO                 ppalInfoSrc,
    PALPHA_DISPATCH_FORMAT   pAlphaDispatch
    )
{
    //
    // get two scanlines of RGBA data, blend pixels, store
    //

    LONG     cx = pDstRect->right - pDstRect->left;
    LONG     cy = pDstRect->bottom - pDstRect->top;
    LONG     ScanBufferWidth = cx * 4;
    LONG     WriteMaskSize    = cx;
    LONG     AllocationSize = 0;
    ULONG    ulSrcBytesPerPixel = pAlphaDispatch->ulSrcBitsPerPixel/8;
    ULONG    ulDstBytesPerPixel = pAlphaDispatch->ulDstBitsPerPixel/8;
    PBYTE    pjSrcTempScanBuffer = NULL;
    PBYTE    pjDstTempScanBuffer = NULL;
    PBYTE    pjAlloc = NULL;
    PBYTE    pjDstTmp;
    PBYTE    pjSrcTmp;
    PBYTE    pWriteMask;

    //
    // calculate destination starting address
    //

    if (ulDstBytesPerPixel)
    {
        pjDstTmp = pDst + ulDstBytesPerPixel * pDstRect->left + DeltaDst * pDstRect->top;
    }
    else if (pAlphaDispatch->ulDstBitsPerPixel == 1)
    {
        pjDstTmp = pDst + pDstRect->left/8 + DeltaDst * pDstRect->top;
    }
    else
    {
        pjDstTmp = pDst + pDstRect->left/2 + DeltaDst * pDstRect->top;
    }

    //
    // calculate source starting address
    //

    if (ulSrcBytesPerPixel)
    {
        pjSrcTmp = pSrc + ulSrcBytesPerPixel * pptlSrc->x + DeltaSrc * pptlSrc->y;
    }
    else if (pAlphaDispatch->ulSrcBitsPerPixel == 1)
    {
        pjSrcTmp = pSrc + pptlSrc->x/8 + DeltaSrc * pptlSrc->y;
    }
    else
    {
        pjSrcTmp = pSrc + pptlSrc->x/2 + DeltaSrc * pptlSrc->y;
    }

    //
    // calculate size of needed scan line buffer
    //

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    AllocationSize += WriteMaskSize;

    //
    // allocate scan line buffer memory
    //

    pWriteMask = (PBYTE)LOCALALLOC(AllocationSize);

    if (pWriteMask == NULL)
    {
        return(FALSE);
    }

    PBYTE pjTemp = pWriteMask + WriteMaskSize;

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        pjSrcTempScanBuffer = pjTemp;
        pjTemp    += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        pjDstTempScanBuffer = pjTemp;
    }

    //
    // Blend scan lines
    //

    while (cy--)
    {
        PBYTE pjSource = pjSrcTmp;
        PBYTE pjDest   = pjDstTmp;

        //
        // get src scan line if needed
        //

        if (pjSrcTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadSrcAndConvert)(
                                (PULONG)pjSrcTempScanBuffer,
                                pjSrcTmp,
                                0,
                                cx,
                                (PVOID)ppalInfoSrc);

            pjSource = pjSrcTempScanBuffer;
        }

        //
        // get dst scan line if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadDstAndConvert)(
                                (PULONG)pjDstTempScanBuffer,
                                pjDstTmp,
                                0,
                                cx,
                                (PVOID)ppalInfoDst);

            pjDest = pjDstTempScanBuffer;
        }

        //
        // blend
        //

        memset(pWriteMask,1,WriteMaskSize);

        (*pAlphaDispatch->pfnGeneralBlend)(
                               (PALPHAPIX)pjDest,
                               (PALPHAPIX)pjSource,
                               cx,
                               pAlphaDispatch->BlendFunction,
                               pWriteMask
                               );

        //
        // write buffer back if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnConvertAndStore)(
                                pjDstTmp,
                                (PULONG)pjDstTempScanBuffer,
                                cx,
                                0,
                                (PVOID)ppalInfoDst,
                                pWriteMask
                                );
        }

        pjDstTmp += DeltaDst;
        pjSrcTmp += DeltaSrc;
    }

    //
    // free any temp buffer memory
    //

    LOCALFREE(pWriteMask);

    return(TRUE);
}

/**************************************************************************\
* bIsHalftonePalette
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsHalftonePalette(ULONG *pPalette)
{
    BOOL bRet = FALSE;

    if (pPalette)
    {
        ULONG ulIndex;


        for (ulIndex=0;ulIndex<256;ulIndex++)
        {
            ALPHAPIX Pix;
            BYTE     Temp;

            Pix.ul = aPalHalftone[ulIndex].ul;

            //
            // jsut store ht palette in rgbquad!!!
            //

            Temp = Pix.pix.r;
            Pix.pix.r = Pix.pix.b;
            Pix.pix.b = Temp;
            Pix.pix.a = 0;

            if ((pPalette[ulIndex] & 0x00ffffff) != Pix.ul)
            {
                break;
            }
        }
        if (ulIndex == 256)
        {
            bRet = TRUE;
        }
    }
    return(bRet);
}

/**************************************************************************\
* vInitializePalinfo
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bInitializePALINFO(
    PPALINFO ppalInfo
    )
{
    //
    // based on pmbi, set palette color flag and set translation
    // routines
    //

    BOOL        bRet = FALSE;
    PBITMAPINFO pbmi = ppalInfo->pBitmapInfo;

    if (pbmi == NULL)
    {
        return(FALSE);
    }

    PULONG pulColors = (PULONG)&pbmi->bmiColors[0];

    ppalInfo->pxlate332 = NULL;

    switch (pbmi->bmiHeader.biBitCount)
    {
    case 1:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 2;
            PBYTE pxlate = NULL;

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_1PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;
    case 4:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 16;
            PBYTE pxlate = NULL;

            if ((pbmi->bmiHeader.biClrUsed > 0) &&
                (pbmi->bmiHeader.biClrUsed < 16))
            {
               NumPalEntries = pbmi->bmiHeader.biClrUsed;
            }

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_4PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;

    case 8:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 256;
            PBYTE pxlate = NULL;

            if ((pbmi->bmiHeader.biClrUsed > 0) &&
                (pbmi->bmiHeader.biClrUsed < 256))
            {
               NumPalEntries = pbmi->bmiHeader.biClrUsed;
            }

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_8PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;

    case 16:

        //
        // look for 565 RGB or 555 RGB
        //

        if (
             (pulColors[0]   == 0xf800) &&
             (pulColors[1]   == 0x07e0) &&
             (pulColors[2]   == 0x001f)
           )
        {
            ppalInfo->flPal                  = XPAL_RGB16_565;
            bRet = TRUE;
        }
        else if (
                  (pulColors[0]  == 0x7c00) &&
                  (pulColors[1]  == 0x03e0) &&
                  (pulColors[2]  == 0x001f)
                )
        {
            ppalInfo->flPal                  = XPAL_RGB16_555;
            bRet = TRUE;
        }
        else
        {
            ppalInfo->flPal                  = XPAL_RGB16_555;
            bRet = TRUE;
        }

        break;

    case 24:
        ppalInfo->flPal                  = XPAL_RGB24;
        bRet = TRUE;
        break;

    case 32:
        if (
             (pbmi->bmiHeader.biCompression == BI_BGRA) ||   // NT 5 only
             (
               (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
               (
                 (pulColors[0]   == 0xff0000) &&
                 (pulColors[1]   == 0x00ff00) &&
                 (pulColors[2]   == 0x0000ff)
               ) ||
               (
                 (pulColors[0]   == 0) &&
                 (pulColors[1]   == 0) &&
                 (pulColors[2]   == 0)
               )
             )
           )

        {
            ppalInfo->flPal                  = XPAL_BGRA;
            bRet = TRUE;
        }
        else if (
                  (pbmi->bmiHeader.biCompression == BI_RGB) ||
                  (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
                  (
                    (pulColors[0]   == 0x0000ff) &&
                    (pulColors[1]   == 0x00ff00) &&
                    (pulColors[2]   == 0xff0000)
                  )
                )
        {
            ppalInfo->flPal                  = XPAL_RGB32;
            bRet = TRUE;
        }
        else
        {
            ppalInfo->flPal                  = XPAL_RGB32;
            bRet = TRUE;
        }
    }

    return(bRet);
}

/**************************************************************************\
* vCleanupPALINFO
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/13/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCleanupPALINFO(
    PPALINFO ppalInfo
    )
{
    if ((ppalInfo->pxlate332 != NULL) && 
        (ppalInfo->pxlate332 != gHalftoneColorXlate332))
    {
        LOCALFREE(ppalInfo->pxlate332);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tricalc.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

/******************************Public*Routine******************************\
* vHorizontalLine
*   
*   Record information for horizontal line.
*   Colors are recorded as fixed point 8.56
*
* Arguments:
*
*   pv1      - vertex 1
*   pv2      - vertex 2
*   ptData   - triangle data
*   ptridda  - dda data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0;
    LONG yIndex    = yPosition - ptData->y0;

    //
    // check if this line is whithin clipping in y
    //

    if (
         (yPosition >= ptData->rcl.top)   &&
         (yPosition < ptData->rcl.bottom)
       )
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv1->x;
            ptData->TriEdge[yIndex].llRed   = ((LONGLONG)pv1->Red)   << 48;
            ptData->TriEdge[yIndex].llGreen = ((LONGLONG)pv1->Green) << 48;
            ptData->TriEdge[yIndex].llBlue  = ((LONGLONG)pv1->Blue)  << 48;
            ptData->TriEdge[yIndex].llAlpha = ((LONGLONG)pv1->Alpha) << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv2->x;
            ptData->TriEdge[yIndex].llRed   = pv2->Red   << 48;
            ptData->TriEdge[yIndex].llGreen = pv2->Green << 48;
            ptData->TriEdge[yIndex].llBlue  = pv2->Blue  << 48;
            ptData->TriEdge[yIndex].llAlpha = pv2->Alpha << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x;
        }
    }
}

/******************************Public*Routine******************************\
* vEdgeDDA
*
*   Run line DDA down an edge of the triangle recording edge
*   position and color
*
* Arguments:
*
*   ptData  - triangle data
*   ptridda - line dda information
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONGLONG llRed    = ptridda->llRed;
    LONGLONG llGreen  = ptridda->llGreen;
    LONGLONG llBlue   = ptridda->llBlue;
    LONGLONG llAlpha  = ptridda->llAlpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    //
    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)
    //

    while (NumScanLines--)
    {
        //
        // check for and record left edge
        //

        if (yIndex >= 0)
        {
            if (L < ptData->TriEdge[yIndex].xLeft)
            {
                ptData->TriEdge[yIndex].xLeft   = L;
                ptData->TriEdge[yIndex].llRed   = llRed;
                ptData->TriEdge[yIndex].llGreen = llGreen;
                ptData->TriEdge[yIndex].llBlue  = llBlue;
                ptData->TriEdge[yIndex].llAlpha = llAlpha;
            }

            if (L > ptData->TriEdge[yIndex].xRight)
            {
                ptData->TriEdge[yIndex].xRight = L;
            }
        }

        //
        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR
        //

        yIndex++;

        L  += ptridda->dL;
        Rb -= ptridda->dR;

        //
        // inc color components by y and integer x components
        //

        llRed   += (ptridda->lldxyRed);
        llGreen += (ptridda->lldxyGreen);
        llBlue  += (ptridda->lldxyBlue);
        llAlpha += (ptridda->lldxyAlpha);

        //
        // check for DDA error term overflow, add one
        // more step in x and color if true, 
        // and correct error term
        //

        if (Rb < 0)
        {
            //
            // fraction step in x
            //

            L += ptridda->Linc;

            //
            // fraction step in color components
            //

            llRed   += ptData->lldRdX;
            llGreen += ptData->lldGdX;
            llBlue  += ptData->lldBdX;
            llAlpha += ptData->lldAdX;

            //
            // adjust error term
            //

            Rb += ptridda->dN;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*   calculate bounding line
*
* Arguments:
*
*   pv1    - vertex 1
*   pv2    - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.lldxyRed   = ptData->lldRdY;
    tridda.lldxyGreen = ptData->lldGdY;
    tridda.lldxyBlue  = ptData->lldBdY;
    tridda.lldxyAlpha = ptData->lldAdY;

    //
    // N0 = integer y starting location
    // M0 = integer x starting location
    // dN = integer delta y
    // dM = integer delta x
    //
    // Arrange lines, must run DDA in positive delta y.
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
    }

    //
    // caclulate initial color value at stating vertex
    //

    tridda.llRed   = ptData->lldRdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldRdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llRA;
    
    tridda.llGreen = ptData->lldGdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldGdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llGA;
 
    tridda.llBlue  = ptData->lldBdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldBdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llBA;
 
    tridda.llAlpha = ptData->lldAdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldAdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llAA;
                 
    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        LONGLONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line. Calc number of scan lines
        // and maximum y position
        //

        tridda.yIndex = tridda.N0 - ptData->y0;

        tridda.NumScanLines = tridda.dN;

        LONG NMax   = tridda.N0 + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
             (tridda.N0 > ptData->rcl.bottom) ||
             (NMax < ptData->rcl.top)
           )
        {
            //
            // nothing to draw
            // 

            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            //
            // clipped number of scan lines !!! only clipped against bottom, what about top !!!
            //

            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = tridda.C + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            //
            // negative divide
            //

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            //
            // dM = 0
            //

            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0    = tridda.j * tridda.dL;
        LongL = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);
        }
        else if (LongL < 0)
        {
            LONGLONG Q = ((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = (LONG)(l0 + Frac);
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx
        //

        tridda.lldxyRed   = tridda.lldxyRed   + (ptData->lldRdX * tridda.dL);
        tridda.lldxyGreen = tridda.lldxyGreen + (ptData->lldGdX * tridda.dL); 
        tridda.lldxyBlue  = tridda.lldxyBlue  + (ptData->lldBdX * tridda.dL);
        tridda.lldxyAlpha = tridda.lldxyAlpha + (ptData->lldAdX * tridda.dL);

        //
        // run edge dda
        //

        vEdgeDDA(ptData,&tridda);
    }
}

/**************************************************************************\
* bCalulateColorGradient
*
*   Calculate all color gradients    
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle verticies
*   ptData      - triangel data
*
* Return Value:
*   
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

BOOL
bCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    GRADSTRUCT g;
    LONGLONG d;
    LONG z;

    g.x1 = pv1->x;
    g.y1 = pv1->y;
    g.x2 = pv2->x;
    g.y2 = pv2->y;

    z = pv0->x;
    g.x1 -= z;
    g.x2 -= z;

    z = pv0->y;
    g.y1 -= z;
    g.y2 -= z;

    g.d  = g.x1 * g.y2 - g.x2 * g.y1;

    LONG tx = MIN(g.x1,0);
    LONG ty = MIN(g.y1,0);

    g.m = MIN(tx,g.x2) + MIN(ty,g.y2);

    d = (LONGLONG) ABS(g.d);
    g.Q = (LONGLONG)TWO_TO_THE_48TH / d;
    g.R = (LONGLONG)TWO_TO_THE_48TH % d;

    ptData->ptColorCalcOrg.x = pv0->x;
    ptData->ptColorCalcOrg.y = pv0->y;

    bDoGradient(  &ptData->lldRdX   // &A
                , &ptData->lldRdY   // &B
                , &ptData->llRA     // &C
                , pv0->Red          // R0
                , pv1->Red          // R1
                , pv2->Red          // R2
                , &g             );

    bDoGradient(  &ptData->lldGdX
                , &ptData->lldGdY
                , &ptData->llGA
                , pv0->Green
                , pv1->Green
                , pv2->Green
                , &g             );

    bDoGradient(  &ptData->lldBdX
                , &ptData->lldBdY
                , &ptData->llBA
                , pv0->Blue
                , pv1->Blue
                , pv2->Blue
                , &g             );


    bDoGradient(  &ptData->lldAdX
                , &ptData->lldAdY
                , &ptData->llAA
                , pv0->Alpha
                , pv1->Alpha
                , pv2->Alpha
                , &g             );

    return(TRUE);
}

/**************************************************************************\
* MDiv64
*   64 bit mul-div
*   
* Arguments:
*   
*   return = (a * b) / c
*
* Return Value:
*
*
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

LONGLONG 
MDiv64(
    LONGLONG a, 
    LONGLONG b, 
    LONGLONG c)
{
    LONGLONG Result;
    int isNegative=0;

    Result = 0;
    if (a != 0 && b != 0)
    {
        if (a < 0)
        {
            a = -a;
            isNegative = 1;
        }
        else if (b < 0)
        {
            b = -b;
            isNegative = 1;
        }
        a = a * b - (LONGLONG) isNegative;
        Result = a / c;
        if (isNegative)
        {
            Result = - Result - 1;
        }
    }
    return(Result);
}

/**************************************************************************\
* bDoGradient
*   
*   calc color gradient for one color
*   
* Arguments:
*   
*   pA
*   pB
*   pC
*   g0
*   g1
*   g2 
*   pg
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk   [kirko]
*
\**************************************************************************/

BOOL
bDoGradient(
    LONGLONG *pA,
    LONGLONG *pB,
    LONGLONG *pC,
    LONG g0,
    LONG g1,
    LONG g2,
    GRADSTRUCT *pg
    )
{
    BOOL bDiv(LONGLONG*, LONGLONG, LONG);
    LONGLONG a,b,c,d;

    g1 = g1 - g0;
    g2 = g2 - g0;

    a = g1 * pg->y2 - g2 * pg->y1;
    b = g2 * pg->x1 - g1 * pg->x2;
    d = pg->d;

    if (d < 0)
    {
        a = -a;
        b = -b;
        d = -d;
    }

    *pA = pg->Q * a + MDiv64(a, pg->R, d);
    *pB = pg->Q * b + MDiv64(b, pg->R, d);

    c = (d >> 1) + 1;
    a = c * pg->R - pg->m - 1;
    a /= d;
    a += c * pg->Q;
    a += pg->m;

    *pC = a + (((LONGLONG) g0) << 48);
    return(TRUE);
}

/**************************************************************************\
* lCalculateTriangleArea
*
* Arguments:
*
*  pv0    - vertex
*  pv1    - vertex 
*  pv2    - vertex 
*  ptData - triangle data
*   
* Return Value:
*
*    < 0 = negative area
*    0   = 0 area
*    > 0 = positive area
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

LONG
lCalculateTriangleArea(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG lRet;

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);

    if (Area == 0)
    {
        lRet = 0;
    }
    else if (Area > 0)
    {
        lRet = 1;

        if (ptData != NULL)
        {
            ptData->Area = Area;
        }
    }
    else
    {
        lRet = -1;
    }

    return(lRet);
}


/**************************************************************************\
* LIMIT_COLOR
*
*   Actual input colors are limited to 0x0000 - 0xff00
*       256 * (0x00 - 0xff)
*
* Arguments:
*   
*   pv - vertex
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define LIMIT_COLOR(pv)        \
                               \
    if (pv->Red > 0xff00)      \
    {                          \
        pv->Red = 0xff00;      \
    }                          \
                               \
    if (pv->Green > 0xff00)    \
    {                          \
        pv->Green = 0xff00;    \
    }                          \
                               \
    if (pv->Blue > 0xff00)     \
    {                          \
        pv->Blue = 0xff00;     \
    }                          


/**************************************************************************\
* bIsTriangleInBounds
*   
*   Is triangle inside bounding rect   
*
* Arguments:
*   
*   pInV0  - vertex 0 
*   pInV1  - vertex 1
*   pInV2  - vertex 2
*   ptData - triangle data
*
* Return Value:
*   
*   TRUE in any of the triangle is contained in bounding rect
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsTriangleInBounds(
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData
    )
{
    PRECTL prclClip = &ptData->rcl;

    RECTL  rclTri;

    rclTri.left   = MIN(pInV0->x,pInV1->x);
    rclTri.right  = MAX(pInV0->x,pInV1->x); 
    rclTri.top    = MIN(pInV0->y,pInV1->y);
    rclTri.bottom = MAX(pInV0->y,pInV1->y); 

    rclTri.left   = MIN(rclTri.left,pInV2->x); 
    rclTri.right  = MAX(rclTri.right,pInV2->x); 
    rclTri.top    = MIN(rclTri.top,pInV2->y); 
    rclTri.bottom = MAX(rclTri.bottom,pInV2->y); 

    if ((rclTri.left   >= prclClip->right) ||
        (rclTri.right  <= prclClip->left)  ||
        (rclTri.top    >= prclClip->bottom) ||
        (rclTri.bottom <= prclClip->top))
    {
        return(FALSE);
    }

    return(TRUE);
}

/**************************************************************************\
* bTriangleNeedSplit
*   determine whether triangle needs split
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle vertex
*
* Return Value:
*   
*   TRUE if triangle needs to be split
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleNeedsSplit(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2
    )
{
    //
    // calc dx,dy for each leg
    //

    LONG dx01 = ABS(pv0->x - pv1->x);
    LONG dy01 = ABS(pv0->y - pv1->y);

    LONG dx02 = ABS(pv0->x - pv2->x);
    LONG dy02 = ABS(pv0->y - pv2->y);

    LONG dx12 = ABS(pv1->x - pv2->x);
    LONG dy12 = ABS(pv1->y - pv2->y);

    //
    // if any length is longer than max, break triangle into two pieces
    // and call this routine for each
    //

    if ( 
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) || 
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        return(TRUE);
    }
    
    return(FALSE);
}

/**************************************************************************\
* bSplitTriangle
*   Determine is triangle must be split. 
*   Split triangle along longest edge
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle
*   pvNew       - new vertex
*   pGrad       - mesh
*
* Return Value:
*
*   TRUE if split, FALSE otherwise
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bSplitTriangle(
    PTRIVERTEX           pVert,
    PULONG               pFreeVert,
    PGRADIENT_TRIANGLE   pMesh,
    PULONG               pFreeMesh,
    PULONG               pRecurseLevel
    )
{
    BOOL bStatus = FALSE;

    ULONG CurrentMesh = (*pFreeMesh) - 1;

    ULONG ulTM0 = pMesh[CurrentMesh].Vertex1;
    ULONG ulTM1 = pMesh[CurrentMesh].Vertex2;
    ULONG ulTM2 = pMesh[CurrentMesh].Vertex3;

    PTRIVERTEX         pv0 = &pVert[ulTM0];
    PTRIVERTEX         pv1 = &pVert[ulTM1]; 
    PTRIVERTEX         pv2 = &pVert[ulTM2]; 

    PTRIVERTEX         pvT0 = pv0;
    PTRIVERTEX         pvT1 = pv1;
    PTRIVERTEX         pvT2 = pv2;

    TRIVERTEX          triNew;

    //
    // find longest edge
    //
    
    LONGLONG dx01 = ABS(pv0->x - pv1->x);
    LONGLONG dy01 = ABS(pv0->y - pv1->y);
    
    LONGLONG dx02 = ABS(pv0->x - pv2->x);
    LONGLONG dy02 = ABS(pv0->y - pv2->y);
    
    LONGLONG dx12 = ABS(pv1->x - pv2->x);
    LONGLONG dy12 = ABS(pv1->y - pv2->y);

    //
    // determine if triangle needs to be split
    //

    if ( 
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) || 
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        //
        // make sure this is a triangle
        //

        if (lCalculateTriangleArea(pv0,pv1,pv2,NULL) != 0)
        {
            //
            // Find longest edge, swap verticies so edge 0-1 is
            // longest.
            //
            
            LONGLONG d01Max = dx01 * dx01 + dy01 * dy01;
            LONGLONG d02Max = dx02 * dx02 + dy02 * dy02;
            LONGLONG d12Max = dx12 * dx12 + dy12 * dy12;

            if (d01Max > d02Max)
            {
                if (d01Max > d12Max)
                {
                    //
                    // d01 largest, default
                    //

                }
                else
                {
                    //
                    // d12 largest, swap 0 and 2
                    //
            
                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex1; 
                }
            }
            else
            {
                if (d02Max > d12Max)
                {
                    //
                    // d02 largest, swap 1,2
                    //
            
                    pvT1  = pv2;
                    pvT2  = pv1;
                    ulTM1 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex2; 
                }
                else
                {
                    //
                    // d12 largest, swap 0,2
                    //
            
                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex1; 
                }
            }
            
            //
            // 2 new triangles 0,2,N and 1,2,N  (float)
            //
            
            triNew.x = pvT0->x + ((pvT1->x - pvT0->x)/2);
            triNew.y = pvT0->y + ((pvT1->y - pvT0->y)/2);
        
            triNew.Red   = pvT0->Red   + ((pvT1->Red   - pvT0->Red  )/2);
            triNew.Green = pvT0->Green + ((pvT1->Green - pvT0->Green)/2);
            triNew.Blue  = pvT0->Blue  + ((pvT1->Blue  - pvT0->Blue )/2);
            triNew.Alpha = pvT0->Alpha + ((pvT1->Alpha - pvT0->Alpha)/2);
        
            //
            // add new entry to vertex array and two new entries to mesh array
            //
            // 0,2,New and 1,2,New
            //
    
            ULONG FreeVert = *pFreeVert;
            ULONG FreeMesh = *pFreeMesh;
    
            pVert[FreeVert] = triNew;
    
            pMesh[FreeMesh].Vertex1   = ulTM0;
            pMesh[FreeMesh].Vertex2   = ulTM2;
            pMesh[FreeMesh].Vertex3   = FreeVert;
    
            pMesh[FreeMesh+1].Vertex1 = ulTM1;
            pMesh[FreeMesh+1].Vertex2 = ulTM2;
            pMesh[FreeMesh+1].Vertex3 = FreeVert;
    
            pRecurseLevel[FreeMesh]   = 1;
            pRecurseLevel[FreeMesh+1] = 0;
    
            *pFreeMesh += 2;
            *pFreeVert += 1;
    
            bStatus = TRUE;
        }
        else
        {
            WARNING("bSplitTriangle:Error: triangle area = 0\n\n");
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* bCalculateAndDrawTriangle
*
*   if triangle is too largre, break it in into 2 triangles and call this
*   routine on each
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*   pSurfDst - destination surface
*   pInV0    - vertex
*   pInV1    - vertex
*   pInV2    - vertex
*   ptData   - triangle data
*   pfnG     - surface gradient draw routine
*
* Return Value:
*
*   status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateAndDrawTriangle(
    PDIBINFO        pDibDst,
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData,
    PFN_TRIFILL     pfnG
    )
{
    BOOL        bStatus = TRUE;
    LONG        index;
    LONG        lStatus;
    PTRIVERTEX  pv0 = pInV0;
    PTRIVERTEX  pv1 = pInV1;
    PTRIVERTEX  pv2 = pInV2;

    {
        PTRIVERTEX pvt;

        //
        // sort in y for line processing
        //

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        if (pv1->y > pv2->y)
        {
            SWAP_VERTEX(pv1,pv2,pvt);
        }

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }
    
        lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);
    
        //
        // if area is zero then this is a degenerate triangle
        //
    
        if (lStatus == 0)
        {
            return(FALSE);
        }
        else if (lStatus <0)
        {
            //
            // negative area, swap pv1 and pv2 and recalcualte
            //
    
            SWAP_VERTEX(pv1,pv2,pvt);

            lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);
    
            if (lStatus == 0)
            {
                return(FALSE);
            }
            else if (lStatus <0)
            {
                WARNING1("Triangle Area still negative after vertex swap\n");
                return(FALSE);
            }
        }
    
        //
        // calc min and max drawing y
        //
    
        ptData->y0   = MAX(pv0->y,ptData->rcl.top);
        LONG MaxY    = MAX(pv1->y,pv2->y);
        ptData->y1   = MIN(MaxY,ptData->rcl.bottom);
    
        {
            //
            // init ptdata
            //
    
            LONG lIndex;
    
            for (lIndex=0;lIndex<(ptData->y1-ptData->y0);lIndex++)
            {
                ptData->TriEdge[lIndex].xLeft  = LONG_MAX;
                ptData->TriEdge[lIndex].xRight = LONG_MIN;
            }
        }
    
        //
        // calculate color gradients for each color. There is a little redundant
        // work here with calculation of deltas. Should make this one call or
        // do it in place.
        //
    
        LIMIT_COLOR(pv0);
        LIMIT_COLOR(pv1);
        LIMIT_COLOR(pv2);
    
        bCalulateColorGradient(pv0,pv1,pv2,ptData);
    
        //
        // draw lines into data array
        //
    
        vCalculateLine(pv0,pv1,ptData);
        vCalculateLine(pv1,pv2,ptData);
        vCalculateLine(pv2,pv0,ptData);
    
        pfnG(pDibDst,ptData);
    }

    return(bStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\alphatran.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"

#if !(_WIN32_WINNT >= 0x500)

/******************************Public*Routine******************************\
* Routines to load a pixel and convert it to BGRA representaion for 
* blending operations
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert1ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    BYTE   SrcByte;
    LONG   cxUnalignedStart = 7 & (8 - (SrcX & 7));
    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    pSrcAddr = pSrcAddr + (SrcX >> 3);

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        LONG iDst = 7 - (SrcX & 0x07); 
        SrcByte = *pSrcAddr;
        pSrcAddr++;

        while (cxUnalignedStart--)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xFF000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 8)
    {
        SrcCx -= 8;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = (ppal[(SrcByte & 0x80) >> 7] | 0xff000000);
        *(pulDstAddr + 1) = (ppal[(SrcByte & 0x40) >> 6] | 0xff000000);
        *(pulDstAddr + 2) = (ppal[(SrcByte & 0x20) >> 5] | 0xff000000);
        *(pulDstAddr + 3) = (ppal[(SrcByte & 0x10) >> 4] | 0xff000000);
        *(pulDstAddr + 4) = (ppal[(SrcByte & 0x08) >> 3] | 0xff000000);
        *(pulDstAddr + 5) = (ppal[(SrcByte & 0x04) >> 2] | 0xff000000);
        *(pulDstAddr + 6) = (ppal[(SrcByte & 0x02) >> 1] | 0xff000000);
        *(pulDstAddr + 7) = (ppal[(SrcByte & 0x01) >> 0] | 0xff000000);

        pSrcAddr++;
        pulDstAddr+=8;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        BYTE SrcByte = *pSrcAddr;
        LONG iDst    = 7;

        while (SrcCx)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xff000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }
}

/**************************************************************************\
* vLoadAndConvert4ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert4ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    BYTE SrcByte;
    pSrcAddr = pSrcAddr + (SrcX >> 1);
    LONG cxUnalignedStart = 1 & (2 - (SrcX & 1));
    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte & 0x0f] | 0xff000000;
        pSrcAddr++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 2)
    {
        SrcCx -= 2;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = ppal[(SrcByte >> 4)  ] | 0xff000000;
        *(pulDstAddr + 1) = ppal[(SrcByte & 0x0f)] | 0xff000000;

        pSrcAddr++;
        pulDstAddr+=2;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte >> 4] | 0xff000000;
    }
}

/**************************************************************************\
* vLoadAndConvert8ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert8ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PBYTE pjSrc = pSrcAddr + SrcX;
    PBYTE pjEnd = pjSrc + SrcCx;

    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    while (pjSrc != pjEnd)
    {
        *pulDstAddr = ppal[*pjSrc] | 0xff000000;

        pulDstAddr++;
        pjSrc++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_565ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_565ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;

    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0xf800) >> 8);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x07e0) >> 3);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);
        pixOut.pix.a = 0xff;
        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_555ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_555ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0x7c00) >> 7);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x03e0) >> 2);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);

        pixOut.pix.a = 0xff;

        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert16BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert16BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ULONG ulTmp;

        ulTmp = *pusSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        ulTmp |= 0xff000000;

        *pulDstAddr = ulTmp;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB24ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB24ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.b = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.r = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB32ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB32ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = pixIn.pix.a;

        *pulDstAddr = pixOut.ul;

        pulSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert32BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert32BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ULONG ulTmp;

        ulTmp = *pulSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        *pulDstAddr = ulTmp;

        pulSrc++;
        pulDstAddr++;
    }
}

//
// 
// STORE ROUTINES  
// convert BGRA to RGB332, look up in table
//

#define PALETTE_MATCH(pixIn,ppalInfo)                         \
{                                                             \
    pixIn.ul = ppalInfo->pxlate332[                           \
                    ((pixIn.pix.r & 0xe0))      |             \
                    ((pixIn.pix.g & 0xe0) >> 3) |             \
                    ((pixIn.pix.b & 0xc0) >> 6)];             \
}                                                             \


/**************************************************************************\
* vConvertAndSaveBGRATo1
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo1(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = pDst + (DstX >> 3);
    LONG  iDst  = DstX & 7;

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        LONG iShift      = 7 - iDst;
        LONG cxUnaligned = iShift + 1;

        cxUnaligned = MIN(cxUnaligned,cx);
        cx -= cxUnaligned;

        while (cxUnaligned--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalInfo);

            pixIn.ul = pixIn.ul << iShift;

            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
        pjDst++;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 8)
    {
        ALPHAPIX  pixIn;
        BYTE DstByte;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte      = (BYTE)(pixIn.ul << 7);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 6);

        pixIn.ul = *(pulSrc+2);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 5);

        pixIn.ul = *(pulSrc+3);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+4);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 3);

        pixIn.ul = *(pulSrc+5);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 2);

        pixIn.ul = *(pulSrc+6);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 1);
                       
        pixIn.ul = *(pulSrc+7);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 0);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 8;
        cx -= 8;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE iShift = 7;
        BYTE DstByte = *pjDst;

        while (cx--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalInfo);

            pixIn.ul = pixIn.ul << iShift;
            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo4
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo4(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = pDst + (DstX >> 1);
    LONG  iDst  = DstX & 1;

    if (cx == 0)
    {
        return;
    }

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        PALETTE_MATCH(pixIn,ppalInfo);

        DstByte = (DstByte & 0xf0) | (BYTE)pixIn.ul;

        *pjDst = DstByte;
        pjDst++;
        pulSrc++;
        cx--;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 2)
    {
        BYTE DstByte;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte = (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte |= (BYTE)(pixIn.ul);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 2;
        cx -= 2;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE DstByte = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        PALETTE_MATCH(pixIn,ppalInfo);

        DstByte = (DstByte & 0x0f) | (BYTE)(pixIn.ul << 4);

        *pjDst = DstByte;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo8
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo8(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = (PBYTE)pDst + DstX;
    PBYTE pjEnd = pjDst + cx;

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

        if (*pWriteMask)
        {
            pixIn.ul = *pulSrc;
    
            PALETTE_MATCH(pixIn,ppalInfo);
    
            *pjDst = (BYTE)pixIn.ul;
        }

        pWriteMask++;
        pulSrc++;
        pjDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_565
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_565(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 8) |
                       ((pixIn.pix.g & 0xfc) << 3) |
                       ((pixIn.pix.b & 0xf8) >> 3);


        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_555
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_555(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 7) |
                       ((pixIn.pix.g & 0xf8) << 2) |
                       ((pixIn.pix.b & 0xf8) >> 3);

        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo16Bitfields
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo16Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul = pixIn.ul; // !!!

        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB24
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        *pjDst     = pixIn.pix.b;
        *(pjDst+1) = pixIn.pix.g;
        *(pjDst+2) = pixIn.pix.r;

        pulSrc++;
        pjDst+=3;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo32Bitfields
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo32Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul = pixIn.ul; // !!! 

        *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB32
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB32(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = 0;

        *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\dib.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#include <ddraw.h>
#include <ddrawp.h>
#include <ddrawi.h>



/*extern HRESULT DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);

extern HRESULT GetSurfaceFromDC(
        HDC hdc,
        LPDIRECTDRAWSURFACE *ppdds,
        HDC *phdcDriver) ;
*/
#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentImage;
extern PFNTRANSDIB gpfnTransparentDIBImage;

#if (_WIN32_WINNT == 0x400)

PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC = NULL;
PFN_GETSURFACEFROMDC pfnGetSurfaceDesc;

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/**************************************************************************\
*  Dprintf
*
*
* Arguments:
*
*   szFmt - format string and argrs
*
* Return Value:
*
*   none
*
* History:
*
*
\**************************************************************************/

VOID Dprintf( LPSTR szFmt, ... ) {
    TCHAR szMsg[80];
    DWORD cb;
    va_list marker;

    va_start( marker, szFmt );
    wvsprintf( szMsg, szFmt, marker );
    cb = lstrlen(szMsg);
    szMsg[cb++] = '\r';
    szMsg[cb++] = '\n';
    WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), szMsg, sizeof(TCHAR) * cb,
		&cb, NULL );

    va_end( marker );

    return;
}


/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;

    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            //WARNING ("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bFillBitmapInfoDirect
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
bFillBitmapInfoDirect(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ((hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL)
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 ) || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        bRet = TRUE;

        DeleteObject(hbm);
    }
    else
    {
        WARNING("bFillBitmapInfoDirect: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillBitmapInfoMemory
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillBitmapInfoMemory(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    if ( (hbm = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 )
           || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
         }

         bRet = TRUE;
    }
    else
    {
        WARNING("bFillBitmapInfoMemory: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillDIBSection
*
* Fill in the DIBSection structure for a memory dc
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillDIBSection(
    PDIBINFO pDibInfo)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;
    BOOL    bddraw = FALSE;
    DIBSECTION dib;

    if ( (hbm = (HBITMAP)GetCurrentObject(pDibInfo->hdc, OBJ_BITMAP)) != NULL )
    {
        GetObject (hbm, sizeof(DIBSECTION), &dib);

        //
        // it is a DIBSECTION
        //
        if ((pDibInfo->pvBits = dib.dsBm.bmBits) != NULL)
        {
             //
             // it is a DIBSection, now see if it might be a DD Surface (on WIn95)
             //
			    if (dib.dsBm.bmWidthBytes < dib.dsBm.bmWidth * dib.dsBm.bmBitsPixel/8)
             {
                HMODULE hddrawlib = GetModuleHandleA("ddraw");

                if (hddrawlib)
                {
                    Dprintf("GetModuleHandleA succeed\n");

                    hddrawlib = LoadLibrary (TEXT("ddraw.dll"));

                    Dprintf("LoadLibrary returns %x", hddrawlib);

                    if (hddrawlib)
                        pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(
                                                   hddrawlib, "GetSurfaceFromDC");
                }

                //
                // check if it is DIRECTDRAW surface
                //
                HDC hdcDevice;

                if (pfnGetSurfaceFromDC && (pfnGetSurfaceFromDC(pDibInfo->hdc, &pDibInfo->pdds, &hdcDevice) == DD_OK))
                {
                    bddraw = TRUE;

                    Dprintf("pfnGetSurfaceFromDC succeed\n");

                    //pdds->GetSurfaceDesc(&ddsd);
                    //
                    // we need to lock the surface here
                    //
                    if (pDibInfo->pdds->Lock((RECT *)&pDibInfo->rclBounds, &pDibInfo->ddsd, DDLOCK_SURFACEMEMORYPTR, NULL) == DD_OK)
                    {

                       pDibInfo->pvBits = pDibInfo->ddsd.lpSurface;
                       pDibInfo->pvBase = pDibInfo->ddsd.lpSurface;
                       pDibInfo->stride = pDibInfo->ddsd.lPitch;

                       pDibInfo->pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                       pDibInfo->pbmi->bmiHeader.biCompression = BI_RGB;
                       pDibInfo->pbmi->bmiHeader.biPlanes = 1;

                       pDibInfo->pbmi->bmiHeader.biWidth = pDibInfo->ddsd.dwWidth;
                       pDibInfo->pbmi->bmiHeader.biHeight = pDibInfo->ddsd.dwHeight;

                       switch (pDibInfo->ddsd.ddpfPixelFormat.dwRGBBitCount)
                       {
                          case DDBD_1:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 1;
                                     break;

                          case DDBD_4:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 4;
                                     break;

                          case DDBD_8:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 8;
                                     bFillColorTable (pDibInfo->hdc, 0, pDibInfo->pbmi);
                                     break;

                          case DDBD_16:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 16;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[0] = pDibInfo->ddsd.ddpfPixelFormat.dwRBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[1] = pDibInfo->ddsd.ddpfPixelFormat.dwGBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[2] = pDibInfo->ddsd.ddpfPixelFormat.dwBBitMask;
                                     break;

                          case DDBD_24:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 24;
                                     break;

                          case DDBD_32:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 32;
                                     break;
                          default:
                                     WARNING("bad bitformat for ddraw surface\n");
                       }

                       pDibInfo->rclClipDC.left = 0;
                       pDibInfo->rclClipDC.top =0;
                       pDibInfo->rclClipDC.right = pDibInfo->ddsd.dwWidth;
                       pDibInfo->rclClipDC.bottom = pDibInfo->ddsd.dwWidth;

                       bRet = TRUE;
                    }
               }

               if (hddrawlib)
               {
                   FreeLibrary(hddrawlib);
               }

             }

             Dprintf ("bddraw = %x\n", bddraw);

             #if 0
             if (bddraw)
             {
                 Dprintf("is a directdraw surf dsbm.bmbits = %x", pDibInfo->pvBits);
                 Dprintf("bmType=%x, bmWidthBytes = %x", dib.dsBm.bmType, dib.dsBm.bmWidthBytes);
                 Dprintf("bmWidth = %x, bmHeight = %x, bmPlanes = %x, bmBitsPixel = %x\n",
                          dib.dsBm.bmWidth, dib.dsBm.bmHeight, dib.dsBm.bmPlanes, dib.dsBm.bmBitsPixel);

                 Dprintf("dsBmh.biSize=%x, biWidth = %x, biHeight = %x\n",
                             dib.dsBmih.biSize, dib.dsBmih.biWidth, dib.dsBmih.biHeight);

                 Dprintf("dsBmh.biPlanes = %x, biBitCount = %x, biCompression = %x, biSizeImage = %x\n",
                          dib.dsBmih.biPlanes, dib.dsBmih.biBitCount, dib.dsBmih.biSizeImage);
             }
             #endif

             if (!bddraw)
             {
                 //
                 // If biHeight is positive, then the bitmap is a bottom-up DIB.
                 // If biHeight is negative, then the bitmap is a top-down DIB.
                 //

                 if ( dib.dsBmih.biHeight > 0 )
                 {
                     pDibInfo->pvBase  = (PVOID) (((int) dib.dsBm.bmBits) + (dib.dsBm.bmWidthBytes *
                                                             (dib.dsBm.bmHeight - 1)));
                     pDibInfo->stride = (ULONG) (-dib.dsBm.bmWidthBytes);
                 }
                 else
                 {
                     pDibInfo->pvBase  = dib.dsBm.bmBits;
                     pDibInfo->stride = dib.dsBm.bmWidthBytes;
                 }

                  //
                  // fill up the BITMAPINFOHEADER
                  //
                  pDibInfo->pbmi->bmiHeader = dib.dsBmih;

                  //
                  // fill up the color table
                  //
                  if ((pDibInfo->pbmi->bmiHeader.biBitCount <= 8) || ( pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
                  {
                      ULONG count = 1 << pDibInfo->pbmi->bmiHeader.biBitCount;

                      GetDIBits(pDibInfo->hdc, hbm, 0, pDibInfo->pbmi->bmiHeader.biHeight, NULL, pDibInfo->pbmi,
                                  DIB_RGB_COLORS);

                  }

                  //
                  // fill prcl
                  //
                  pDibInfo->rclClipDC.left   = 0;
                  pDibInfo->rclClipDC.top    = 0;
                  pDibInfo->rclClipDC.right  = dib.dsBm.bmWidth;
                  pDibInfo->rclClipDC.bottom = dib.dsBm.bmHeight;

                  if (pDibInfo->rclClipDC.bottom < 0)
                  {
                      pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                  }

                  bRet = TRUE;
             }

        }
        else
        {
            Dprintf("not a dibseciton");
        }
    }
    return(bRet);
}





/******************************Public*Routine******************************\
* bFillBimapInfo
*
* Fill up the BITMAPINFO structure based on the hdc passed in
* and fill up the window(if direct dc) or surface (if memory dc)
* rectangle.
*
* if it's a dibsection, convert DIBSECTION to BITMAPINFO
*
* Returns:
*   BOOLEAN
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bFillBitmapInfo(
    PDIBINFO pDibInfo

// HDC          hdc,
//    RECTL        *prcl,
//    PBITMAPINFO  pbmi,
//    PVOID        *ppvBits,
//    PVOID        *ppvBase,
//    LONG         *plStride
    )
{
    BOOL bRet = FALSE;

    {
       //
       // fill up a BITMAPINFO structure compatible with the
       // Destination DC and reduce ulWidth and ulHeight if
       // possible
       //
       if (GetObjectType(pDibInfo->hdc) == OBJ_DC)
       {
           //
           // get the destination bitmapinfo struct
           //
           if (bRet = bFillBitmapInfoDirect(pDibInfo->hdc, 0, pDibInfo->pbmi))
           {
              HWND hwnd = WindowFromDC(pDibInfo->hdc);

              if (hwnd)
              {
                  GetClientRect(hwnd,(RECT *)&pDibInfo->rclClipDC);
              }
           }
       }
       else if (GetObjectType(pDibInfo->hdc) == OBJ_MEMDC)
       {
           if (!(bRet = bFillDIBSection (pDibInfo)))
           {
               //
               // if the bitmap selected in the memory dc is NOT
               // a DIBSECTION, call bFillBitmapInfoMemory
               //

               if (bRet = bFillBitmapInfoMemory(pDibInfo->hdc, 0, pDibInfo->pbmi))
               {
                   pDibInfo->rclClipDC.left   = 0;
                   pDibInfo->rclClipDC.top    = 0;
                   pDibInfo->rclClipDC.right  = pDibInfo->pbmi->bmiHeader.biWidth;
                   pDibInfo->rclClipDC.bottom = pDibInfo->pbmi->bmiHeader.biHeight;

                   if (pDibInfo->rclClipDC.bottom < 0)
                   {
                       pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                   }
               }
           }

       }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bSameDIBformat
*
* Given two BITMAPINFO structs and compare if they are the same
*
* Returns:
*   VOID
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bSameDIBformat (
    PBITMAPINFO pbmiDst,
    PBITMAPINFO pbmiSrc)
{
    BOOL bRet = FALSE;

    if ((pbmiDst->bmiHeader.biBitCount == pbmiSrc->bmiHeader.biBitCount) &&
        (pbmiDst->bmiHeader.biCompression == pbmiSrc->bmiHeader.biCompression))
    {
        bRet = TRUE;

        //
        // compare bit Bitfields masks
        //
        if (pbmiDst->bmiHeader.biCompression == BI_BITFIELDS)
        {
           if ((*(DWORD *)&pbmiDst->bmiColors[0] != *(DWORD *)&pbmiSrc->bmiColors[0]) ||
               (*(DWORD *)&pbmiDst->bmiColors[1] != *(DWORD *)&pbmiSrc->bmiColors[1]) ||
               (*(DWORD *)&pbmiDst->bmiColors[2] != *(DWORD *)&pbmiSrc->bmiColors[2]))
           {
               bRet = FALSE;
           }
        }

        //
        // compare color table
        //
        if (pbmiDst->bmiHeader.biBitCount <= 8)
        {
            ULONG cColors = 1 << pbmiDst->bmiHeader.biBitCount;
            ULONG i;

            for (i = 0; i < cColors; i++)
            {
                if ((pbmiDst->bmiColors[i].rgbBlue != pbmiSrc->bmiColors[i].rgbBlue) ||
                    (pbmiDst->bmiColors[i].rgbGreen != pbmiSrc->bmiColors[i].rgbGreen) ||
                    (pbmiDst->bmiColors[i].rgbRed != pbmiSrc->bmiColors[i].rgbRed))

                {
                    return (FALSE);
                }
            }
        }
    }
    return (bRet);
}
/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB_RGB_COLORS dib section based on the given width/height and pbmi
*
* Returns:
*   Bitmap handle
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
HBITMAP CreateCompatibleDIB (
    HDC         hdc,
    ULONG       ulWidth,
    ULONG       ulHeight,
    PVOID       *ppvBits,
    PBITMAPINFO pbmi)
{
    HBITMAP hbm;

    //
    // Change bitmap size to match specified dimensions.
    //
    pbmi->bmiHeader.biWidth = ulWidth;
    pbmi->bmiHeader.biHeight = ulHeight;

    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        pbmi->bmiHeader.biSizeImage = 0;
    }
    else
    {
        if ( pbmi->bmiHeader.biBitCount == 16 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
        else if ( pbmi->bmiHeader.biBitCount == 32 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
        else
            pbmi->bmiHeader.biSizeImage = 0;
    }

    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbm = CreateDIBSection(hdc, (PBITMAPINFO)pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

    return (hbm);
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        WARNING("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************************************
* bSetupBitmapInfos
*
* Calls bFillBitmapInfo to fill the Dst and Src DIBINFO
*
* 4/4/97 -- by Lingyun Wang [lingyunw]
*******************************************************/
BOOL bSetupBitmapInfos(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc
    )
{
    BOOL bRet;

    bRet = bFillBitmapInfo (pDibInfoDst);

    //
    // fill up bitmapinfo if it is not coming from TransparentDIBits
    //

    if (bRet && (pDibInfoSrc != NULL))
    {
        if (pDibInfoSrc->hdc != NULL)
        {
            bRet = bFillBitmapInfo (pDibInfoSrc);
        }
        else
        {
            //
            // src is DIB
            //

            pDibInfoSrc->rclClipDC.left   = 0;
            pDibInfoSrc->rclClipDC.right  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            pDibInfoSrc->rclClipDC.top    = 0;
            pDibInfoSrc->rclClipDC.bottom = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            if (pDibInfoSrc->rclClipDC.bottom < 0)
            {
                pDibInfoSrc->rclClipDC.bottom = -pDibInfoSrc->rclClipDC.bottom;
            }

        }
    }

   return (bRet);

}


/******************************Public*Routine******************************\
* vCopyBitmapInfo
*
* Copy a BITMAPINFO stucture along with its bit masks or colortable
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vCopyBitmapInfo (
    PBITMAPINFO pbmiTo,
    PBITMAPINFO pbmiFrom
    )
{
    *pbmiTo = *pbmiFrom;

    //
    // copy BitFields masks
    //

    if (pbmiFrom->bmiHeader.biCompression == BI_BITFIELDS)
    {
        pbmiTo->bmiColors[0] = pbmiFrom->bmiColors[0];
        pbmiTo->bmiColors[1] = pbmiFrom->bmiColors[1];
        pbmiTo->bmiColors[2] = pbmiFrom->bmiColors[2];
    }
    else
    {
        //
        // copy color table
        //

        ULONG cMaxColors = 1 << pbmiFrom->bmiHeader.biBitCount;
        ULONG cColors = pbmiFrom->bmiHeader.biClrUsed;

        //
        // validate number of colors
        //

        if ((cColors == 0) || (cColors > cMaxColors))
        {
            cColors = cMaxColors;
        }

        if (cColors <= 256)
        {
           UINT i;

           for (i = 0; i < cColors; i++)
           {
               pbmiTo->bmiColors[i] = pbmiFrom->bmiColors[i];
           }
        }
    }

    return;
}

/**************************************************************************\
* vIndexToRGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/16/1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID vIndexToRGB (
     RGBQUAD *pIndex,
     RGBQUAD *pColors,
     ULONG   count)
{
    ULONG i;

    if (count > 256)
    {
        WARNING ("vIndexToRGB -- bad count\n");
        return;
    }

    for (i=0; i < count; i++)
    {
        pIndex[i] = pColors[((ULONG *)pIndex)[i]];
    }
    return;
}

#if 1

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    //
    // only called in DIB API case
    //

    if (pDibInfoSrc->hdc == NULL)
    {
        PBITMAPINFO pbmi = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);

        if (pbmi)
        {
            ZeroMemory (pbmi,sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
            vCopyBitmapInfo(pbmi, pDibInfoSrc->pbmi);

            HPALETTE hpalDC = (HPALETTE)GetCurrentObject(pDibInfoDst->hdc,OBJ_PAL);

            if (hpalDC)
            {
                USHORT usNumPaletteEntries = 0;
                DWORD numColors;
                DWORD bmiClrUsed = pDibInfoSrc->pbmi->bmiHeader.biClrUsed;

                int iRet = GetObject(hpalDC,2,&usNumPaletteEntries);

                if ((iRet != 0) && (usNumPaletteEntries != 0))
                {
                    switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                    {
                    case 1:
                        numColors = 2;
                        break;

                    case 4:
                        numColors = 16;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 16)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;

                    case 8:
                        numColors = 256;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 256)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;
                    default:
                        numColors = 0;
                    }

                    if (numColors != 0)
                    {
                        PALETTEENTRY *ppal = (PALETTEENTRY *)LOCALALLOC(sizeof(PALETTEENTRY) * usNumPaletteEntries);

                        if (ppal)
                        {
                            iRet = GetPaletteEntries(hpalDC,0,usNumPaletteEntries,ppal);

                            if (iRet == (int)usNumPaletteEntries)
                            {
                                ULONG   Index;

                                RGBQUAD *pRGB     = (RGBQUAD *)&pbmi->bmiColors[0];
                                PUSHORT pPalIndex = (PUSHORT)&pDibInfoSrc->pbmi->bmiColors[0];

                                //
                                // map PALETTEENTRY to RGBQUAD
                                //

                                for (Index=0;Index<numColors;Index++)
                                {
                                    ULONG CurIndex = pPalIndex[Index];

                                    if (CurIndex > usNumPaletteEntries)
                                    {
                                        CurIndex = CurIndex % usNumPaletteEntries;
                                    }

                                    pRGB[Index].rgbRed      = ppal[CurIndex].peRed;
                                    pRGB[Index].rgbGreen    = ppal[CurIndex].peGreen;
                                    pRGB[Index].rgbBlue     = ppal[CurIndex].peBlue;
                                    pRGB[Index].rgbReserved = ppal[CurIndex].peFlags;
                                }

                                //
                                // swap pbmi in pDibInfoSrc
                                //

                                LOCALFREE(pDibInfoSrc->pbmi);

                                pDibInfoSrc->pbmi = pbmi;
                            }

                            LOCALFREE(ppal);
                        }
                    }
                }
            }
        }
    }

}

#else

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    HDC         hdc = pDibInfoDst->hdc;
    HDC         hdcMem;
    ULONG       cx = 1 << pDibInfoSrc->pbmi->bmiHeader.biBitCount;
    HBITMAP     hbm;
    PULONG      pBits;
    ULONG       cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 2;
    PBITMAPINFO pbmi;
    ULONG       i;
    BYTE        pBytes[256];
    ULONG       ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
    HPALETTE    hpalDC;

    pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

    if (pbmi == NULL)
    {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
    }

    hdcMem = CreateCompatibleDC (hdc);

    if (hdcMem != NULL)
    {
        HPALETTE hpalDC = (HPALETTE)GetCurrentObject(hdc,OBJ_PAL);

        SelectPalette(hdcMem,hpalDC,TRUE);
        RealizePalette(hdcMem);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 256;
        pbmi->bmiHeader.biHeight          = 1;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        //
        // save the original width/height
        //

        ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
        ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

        pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
        pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

        //
        // create a dib using 32 format
        //

        hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (PVOID *)&pBits, NULL, 0);

        if ((hbm != NULL) && (SelectObject(hdcMem,hbm) != NULL))
        {
            //
            // init pBytes to array of each pixel
            //

            switch (cx)
            {
            case 256:
                for (i=0; i < cx; i++)
                {
                    pBytes[i] = (BYTE)i;
                }
                break;

            case 16:
                pBytes[0] = 0x01;
                pBytes[1] = 0x23;
                pBytes[2] = 0x45;
                pBytes[3] = 0x67;
                pBytes[4] = 0x89;
                pBytes[5] = 0xab;
                pBytes[6] = 0xcd;
                pBytes[7] = 0xef;
                break;

            case 2:
                pBytes[0] = 0x40;
                break;
            }

            ulWidthSrc  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            pDibInfoSrc->pbmi->bmiHeader.biWidth = cx;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;


            if (!SetDIBitsToDevice (hdcMem, 0, 0, cx, 1, 0, 0, 0, 1, pBytes, pDibInfoSrc->pbmi, DIB_PAL_COLORS))
            {
                 //Dprintf("fail to SetDIBitsTodevice HDC=%x\n",hdcMem);
            }


            for (i=0; i < cx; i++)
            {
                pDibInfoSrc->pbmi->bmiColors[i] = ((RGBQUAD *)pBits)[i];
                //Dprintf("i=%x, pBits[i]=%x", i, pBits[i]);
            }

            pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;


            pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
            pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

            pDibInfoSrc->iUsage = DIB_RGB_COLORS;
        }

        DeleteDC (hdcMem);

        if (hbm != NULL)
        {
            DeleteObject(hbm);
        }
    }
}

#endif


/**************************************************************************\
* bGetSrcDIBits:
*
*   Setup SRC DIB surface and retrieve the dibits.
*   Ported from kernel mode
*
* Arguments:
*
*   pDibInfoDst  - information on dest surface
*   pDibInfoSrc  - information on src surfcace
*   ulSourceType - type of src surface needed
*   ulTranColor  - transparent color for TransparentBlt
*
* Return Value:
*
*   Status
*
* History:
*
*    4/16/1997 - by Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetSrcDIBits(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    ULONG    ulSourceType,
    ULONG    ulTranColor
    )
{
    BOOL bRet  = TRUE;
    LONG DstCx = pDibInfoDst->rclBounds.right  - pDibInfoDst->rclBounds.left;
    LONG DstCy = pDibInfoDst->rclBounds.bottom - pDibInfoDst->rclBounds.top;

    LONG SrcCx = pDibInfoSrc->rclBounds.right  - pDibInfoSrc->rclBounds.left;
    LONG SrcCy = pDibInfoSrc->rclBounds.bottom - pDibInfoSrc->rclBounds.top;

    PVOID       pvBits  = pDibInfoSrc->pvBits;
    PBITMAPINFO pbmi    = NULL;
    HDC         hdcTemp = NULL;
    HBITMAP     hbm;

    LONG   SrcTrimLeft;
    LONG   SrcTrimRight;
    LONG   SrcTrimTop;
    LONG   SrcTrimBottom;

    BOOL bStretch = ((DstCx != SrcCx) || (DstCy != SrcCy));

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoDst->rclClipDC.left - pDibInfoDst->rclBoundsTrim.left;
        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
    }

    if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoDst->rclClipDC.top - pDibInfoDst->rclBoundsTrim.top;
        pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
    }

    if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoDst->rclBoundsTrim.right - pDibInfoDst->rclClipDC.right;
        pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
    }

    if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclClipDC.bottom;
        pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
    }

    //
    // does src need to be reduced because of dst
    //

    if (bStretch)
    {
        //
        // convert dst trim to src space and reduce src rect
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fDstToSrcX = (double)SrcCx / (double)DstCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fDstToSrcX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fDstToSrcX);

            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fDstToSrcY = (double)SrcCy / (double)DstCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fDstToSrcY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fDstToSrcY);

            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce src rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // Does src still exceed bounds
    //

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoSrc->rclClipDC.left - pDibInfoSrc->rclBoundsTrim.left;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclClipDC.left;
    }

    if (pDibInfoSrc->rclBoundsTrim.top < pDibInfoSrc->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoSrc->rclClipDC.top - pDibInfoSrc->rclBoundsTrim.top;
        pDibInfoSrc->rclBoundsTrim.top = pDibInfoSrc->rclClipDC.top;
    }

    if (pDibInfoSrc->rclBoundsTrim.right > pDibInfoSrc->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoSrc->rclBoundsTrim.right - pDibInfoSrc->rclClipDC.right;
        pDibInfoSrc->rclBoundsTrim.right = pDibInfoSrc->rclClipDC.right;
    }

    if (pDibInfoSrc->rclBoundsTrim.bottom > pDibInfoSrc->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclClipDC.bottom;
        pDibInfoSrc->rclBoundsTrim.bottom = pDibInfoSrc->rclClipDC.bottom;
    }

    //
    // does Dst need to be reduced because of Src
    //

    if (bStretch)
    {
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fSrcToDstX = (double)DstCx / (double)SrcCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fSrcToDstX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fSrcToDstX);

            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fSrcToDstY = (double)DstCy / (double)SrcCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fSrcToDstY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fSrcToDstY);

            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce dst rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // check for clipped out Dst and Src
    //

    if (
        (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclBoundsTrim.right)  &&
        (pDibInfoDst->rclBoundsTrim.top  < pDibInfoDst->rclBoundsTrim.bottom) &&
        (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclBoundsTrim.right)  &&
        (pDibInfoSrc->rclBoundsTrim.top  < pDibInfoSrc->rclBoundsTrim.bottom)
       )
    {
        //
        // allocate compatible DC and surface
        //

        hdcTemp = CreateCompatibleDC(pDibInfoSrc->hdc);

        if (hdcTemp)
        {
            //
            // copy pDibInfoSrc->pbmi into pbmi
            //

            if (!pDibInfoSrc->hdc)
            {
                ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
                pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

                if (pbmi != NULL)
                {
                    ZeroMemory (pbmi,cBytes);
                    vCopyBitmapInfo (pbmi, pDibInfoSrc->pbmi);
                }
                else
                {
                    WARNING("bGetSrcDIBits fail to alloc mem\n");
                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                //
                // create temp DIB size of dst rect
                //

                RECTL  rclDstCopy = {
                                     0,
                                     0,
                                     pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left,
                                     pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top
                                    };

                hbm = CreateCompatibleDIB(hdcTemp,
                                          rclDstCopy.right,
                                          rclDstCopy.bottom,
                                          &pDibInfoSrc->pvBits,
                                          pDibInfoSrc->pbmi);

                if (hbm)
                {
                    pDibInfoSrc->hDIB = hbm;

                    GetCompatibleDIBInfo (hbm, &pDibInfoSrc->pvBase, &pDibInfoSrc->stride);

                    HBITMAP hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

                    ULONG OldMode = SetStretchBltMode(hdcTemp,COLORONCOLOR);

                    //
                    // Stretch data into source temp DIB
                    //
                    //
                    // Blt data into source temp DIB
                    //

                    if (pDibInfoSrc->hdc)
                    {
                        StretchBlt (hdcTemp,
                             0,
                             0,
                             rclDstCopy.right,
                             rclDstCopy.bottom,
                             pDibInfoSrc->hdc,
                             pDibInfoSrc->rclBoundsTrim.left,
                             pDibInfoSrc->rclBoundsTrim.top,
                             pDibInfoSrc->rclBoundsTrim.right  - pDibInfoSrc->rclBoundsTrim.left,
                             pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclBoundsTrim.top,
                             SRCCOPY);
                    }
                    else
                    {

                        //
                        // adjust ySrc to be compatible
                        //

                        LONG cySrc = pDibInfoSrc->rclBoundsTrim.bottom-pDibInfoSrc->rclBoundsTrim.top;
                        LONG ySrc  = pDibInfoSrc->rclClipDC.bottom - pDibInfoSrc->rclBoundsTrim.top - cySrc;

                        StretchDIBits (hdcTemp,
                             0,
                             0,
                             rclDstCopy.right,
                             rclDstCopy.bottom,
                             pDibInfoSrc->rclBoundsTrim.left,
                             ySrc,
                             pDibInfoSrc->rclBoundsTrim.right-pDibInfoSrc->rclBoundsTrim.left,
                             cySrc,
                             pvBits,
                             pbmi,
                             DIB_RGB_COLORS,
                             SRCCOPY);
                    }

                    SetStretchBltMode(hdcTemp,OldMode);

                    SelectObject (hdcTemp, hbmDefault);

                    pDibInfoSrc->rclDIB = rclDstCopy;
                }
                else
                {
                    WARNING ("bGetSrcDIBits -- fail to createcompatibleDIB\n");
                    bRet = FALSE;
                }
            }
        }
        else
        {
            WARNING ("bGetSrcDIBits -- fail to createcompatibledc\n");
            bRet = FALSE;
        }
    }
    else
    {
        //
        // clipped out
        //

        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclBoundsTrim.right  = 0;
        pDibInfoDst->rclBoundsTrim.top  = pDibInfoDst->rclBoundsTrim.bottom = 0;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclBoundsTrim.right  = 0;
        pDibInfoSrc->rclBoundsTrim.top  = pDibInfoSrc->rclBoundsTrim.bottom = 0;
    }

    if (pbmi)
    {
        LOCALFREE (pbmi);
    }

    if (hdcTemp)
    {
        DeleteDC(hdcTemp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bGetDstDIBits
*
* Setup the destination DIB surface and retrieve the bits
*
* Ported from psSetupDstSurface
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-April-1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetDstDIBits
(
    PDIBINFO pDibInfoDst,
    BOOL    *pbReadable,
    FLONG    flCopyMode
)
{
    HDC  hdc  = pDibInfoDst->hdc;
    BOOL bRet = TRUE;

    //
    // try to clip to dst surface, dst should be clipped in all cases except
    // gradient fill
    //

    if (flCopyMode & (SOURCE_GRADIENT_RECT | SOURCE_GRADIENT_TRI))
    {
        //
        // trim destination bounds rect to surface bounds. Src rect must also
        // be trimmed by same amount (in src space)
        //

        if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
        {
            pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
        }

        if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
        {
            pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
        }

        if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
        {
            pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
        }

        if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
        {
            pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
        }

        //
        // set offset for gradient fill
        //

        pDibInfoDst->ptlGradOffset.x = 0;
        pDibInfoDst->ptlGradOffset.y = 0;

    }

    LONG DstCx = pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left;
    LONG DstCy = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top;

    *pbReadable = TRUE;

    if (!pDibInfoDst->pvBits)
    {

        if (pDibInfoDst->rclBounds.left > 0)
        {
            pDibInfoDst->ptlGradOffset.x = pDibInfoDst->rclBounds.left;
        }

        if (pDibInfoDst->rclBounds.top > 0)
        {
            pDibInfoDst->ptlGradOffset.y = pDibInfoDst->rclBounds.top;
        }

        //
        // allocate surface
        //

        HDC hdcTemp = CreateCompatibleDC (hdc);

        if (hdcTemp)
        {
            HBITMAP hbm = CreateCompatibleDIB (hdcTemp,
                                       DstCx,
                                       DstCy,
                                       &pDibInfoDst->pvBits,
                                       pDibInfoDst->pbmi);

            if (hbm != NULL)
            {
                pDibInfoDst->hDIB = hbm;
                GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

                HGDIOBJ hret = SelectObject(hdcTemp, hbm);

                if (hret != NULL)
                {
                    RECTL  rclCopy;

                    rclCopy.left   = 0;
                    rclCopy.right  = DstCx;
                    rclCopy.top    = 0;
                    rclCopy.bottom = DstCy;

                    //
                    // gradient rect does not need source bitmap data
                    //

                    if (flCopyMode != SOURCE_GRADIENT_RECT)
                    {
                        bRet = BitBlt(hdcTemp,
                                      0,
                                      0,
                                      DstCx,
                                      DstCy,
                                      pDibInfoDst->hdc,
                                      pDibInfoDst->rclBoundsTrim.left,
                                      pDibInfoDst->rclBoundsTrim.top,
                                      SRCCOPY);
                    }

                    //
                    // adjust dst rect
                    //

                    if (bRet)
                    {
                        pDibInfoDst->rclDIB = rclCopy;
                    }
                }
                else
                {
                    bRet = NULL;
                    WARNING ("bGetDstDIBits -- fail to select compatible DIB\n");
                }

                *pbReadable = bRet;
            }
            else
            {
                bRet = FALSE;
            }

            DeleteDC (hdcTemp);
        }
        else
        {
            WARNING ("bGetDstDIBits -- fail to createcompatibledc\n");
            bRet = FALSE;
        }
    }
    else
    {
        pDibInfoDst->rclDIB = pDibInfoDst->rclClipDC;
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* bDIBGetSrcDIBits
*
* Create or get the source dib bits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bDIBGetSrcDIBits (
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    FLONG    flSourceMode,
    ULONG    TransColor
    )
{

    if (pDibInfoSrc->iUsage == DIB_PAL_COLORS)
    {
        vMapPALtoRGB (pDibInfoDst, pDibInfoSrc, 0);
    }

    //pDibInfoSrc->rclDIB = pDibInfoSrc->rclClipDC;

    return (bGetSrcDIBits(pDibInfoDst,pDibInfoSrc,flSourceMode, TransColor));

}

/******************************Public*Routine******************************\
* bDIBInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bDIBInitDIBINFO(
          PBITMAPINFO  pbmi,
          CONST VOID * pvBits,
          int          x,
          int          y,
          int          cx,
          int          cy,
          PDIBINFO     pDibInfo)
{
    PVOID p;
    ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
    int bmWidthBytes;
    POINT lpPoints[2];

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    //
    // copy the input pbmi
    //

    vCopyBitmapInfo ((PBITMAPINFO)p, pbmi);

    pDibInfo->pbmi = (PBITMAPINFO)p;
    pDibInfo->hdc  = NULL;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    pDibInfo->pvBits    = (PVOID)pvBits;
    pDibInfo->iUsage    = DIB_RGB_COLORS;
    pDibInfo->pxlate332 = NULL;

    //
    // align width to WORD boundary
    //

    bmWidthBytes = ((pbmi->bmiHeader.biWidth*pbmi->bmiHeader.biBitCount + 15)>>4)<<1;

    if (pbmi->bmiHeader.biHeight > 0)
    {
        pDibInfo->pvBase  = (PBYTE)pDibInfo->pvBits + bmWidthBytes * (pbmi->bmiHeader.biHeight - 1);
        pDibInfo->stride  = (ULONG) (-bmWidthBytes);
    }
    else
    {
        pDibInfo->pvBase = pDibInfo->pvBits;
        pDibInfo->stride = bmWidthBytes;
    }

    pDibInfo->hDIB   = NULL;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bInitDIBINFO(
          HDC         hdc,
          int         x,
          int         y,
          int         cx,
          int         cy,
          PDIBINFO    pDibInfo)
{
    ULONG cBytes;
    PVOID p;
    POINT lpPoints[2];

    pDibInfo->hdc = hdc;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    //
    // setup rclBounds in device space
    //

    LPtoDP (hdc, (POINT *)&pDibInfo->rclBounds, 2);

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    //
    // Now operate in MM_TEXT mode
    //

    pDibInfo->Mapmode = SetMapMode(hdc,MM_TEXT);
    SetViewportOrgEx (hdc, 0, 0, &pDibInfo->ViewportOrg);
    SetWindowOrgEx (hdc, 0, 0, &pDibInfo->WindowOrg);


    pDibInfo->pvBits    = NULL;
    pDibInfo->pvBase    = NULL;
    pDibInfo->hDIB      = NULL;
    pDibInfo->iUsage    = DIB_RGB_COLORS;
    pDibInfo->pxlate332 = NULL;

    cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    pDibInfo->pbmi = (PBITMAPINFO)p;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bSendDIBInfo
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bSendDIBINFO(
    HDC      hdcDst,
    PDIBINFO pDibInfo
    )
{
    BOOL bRet = TRUE;

    if (pDibInfo->hDIB)
    {
        ULONG OldMode = SetStretchBltMode(hdcDst,COLORONCOLOR);

        bRet = SetDIBitsToDevice(hdcDst,
                                 pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.top,
                                 pDibInfo->rclBoundsTrim.right  - pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.bottom - pDibInfo->rclBoundsTrim.top,
                                 0,
                                 0,
                                 0,
                                 pDibInfo->rclDIB.bottom - pDibInfo->rclDIB.top,
                                 pDibInfo->pvBits,
                                 pDibInfo->pbmi,
                                 DIB_RGB_COLORS);

        SetStretchBltMode(hdcDst,OldMode);
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* vCleanupDIBInfo
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vCleanupDIBINFO (
     PDIBINFO pDibInfo)
{
    //
    // restore DC map modes
    //

    SetMapMode(pDibInfo->hdc,pDibInfo->Mapmode);
    SetViewportOrgEx (pDibInfo->hdc, pDibInfo->ViewportOrg.x, pDibInfo->ViewportOrg.y, NULL);
    SetWindowOrgEx (pDibInfo->hdc, pDibInfo->WindowOrg.x, pDibInfo->WindowOrg.y, NULL);

    if (pDibInfo->hDIB)
    {
        DeleteObject (pDibInfo->hDIB);
    }

    if (pDibInfo->pbmi)
    {
        LOCALFREE ((PVOID)pDibInfo->pbmi);
    }

    if ((pDibInfo->pxlate332) && (pDibInfo->pxlate332 != gHalftoneColorXlate332))
    {
        LOCALFREE(pDibInfo->pxlate332);
    }

    if (pDibInfo->pdds)
        pDibInfo->pdds->Unlock(pDibInfo->ddsd.lpSurface);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\gradrect.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

VOID
ImgFillMemoryULONG(
    PBYTE pDst,
    ULONG ulPat,
    ULONG cxBytes
    )
{
    PULONG pulDst = (PULONG)pDst;
    PULONG pulEnd = (PULONG)(pDst + ((cxBytes * 4)/4));
    while (pulDst != pulEnd)
    {
        *pulDst = ulPat;
        pulDst++;
    }
}

/**************************************************************************\
*
*   Dither information for 8bpp. This is customized for dithering to
*   the halftone palette [6,6,6] color cube.
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE gDitherMatrix16x16Halftone[256] = {
  3, 28,  9, 35,  4, 30, 11, 36,  3, 29, 10, 35,  5, 30, 11, 37,
 41, 16, 48, 22, 43, 17, 49, 24, 42, 16, 48, 22, 43, 18, 50, 24,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 32,  0, 26,  8, 34,  2, 27,
 44, 19, 38, 12, 46, 20, 40, 14, 45, 19, 38, 13, 46, 21, 40, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  6, 31, 12, 38,  4, 30, 10, 36,
 44, 18, 50, 24, 42, 16, 48, 23, 44, 18, 50, 25, 42, 17, 49, 23,
  8, 34,  2, 28,  7, 32,  0, 26,  9, 34,  2, 28,  7, 33,  1, 26,
 47, 21, 40, 15, 45, 20, 39, 13, 47, 22, 41, 15, 46, 20, 39, 14,
  3, 29,  9, 35,  5, 30, 11, 37,  3, 28,  9, 35,  4, 30, 11, 36,
 41, 16, 48, 22, 43, 17, 49, 24, 41, 15, 47, 22, 43, 17, 49, 23,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 31,  0, 25,  7, 33,  1, 27,
 45, 19, 38, 13, 46, 21, 40, 14, 44, 19, 38, 12, 46, 20, 39, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  5, 31, 11, 37,  3, 29, 10, 35,
 44, 18, 50, 25, 42, 17, 49, 23, 43, 18, 50, 24, 42, 16, 48, 23,
  9, 34,  2, 28,  7, 33,  1, 26,  8, 34,  2, 27,  7, 32,  0, 26,
 47, 21, 41, 15, 45, 20, 39, 13, 47, 21, 40, 15, 45, 19, 39, 13
 };

BYTE gDitherMatrix16x16Default[256] = {
    8, 72, 24, 88, 12, 76, 28, 92,  9, 73, 25, 89, 13, 77, 29, 93,
  104, 40,120, 56,108, 44,124, 60,105, 41,121, 57,109, 45,125, 61,
   16, 80,  0, 64, 20, 84,  4, 68, 17, 81,  1, 65, 21, 85,  5, 69,
  112, 48, 96, 32,116, 52,100, 36,113, 49, 97, 33,117, 53,101, 37,
   14, 78, 30, 94, 10, 74, 26, 90, 15, 79, 31, 95, 11, 75, 27, 91,
  110, 46,126, 62,106, 42,122, 58,111, 47,126, 63,107, 43,123, 59,
   22, 86,  6, 70, 18, 82,  2, 66, 23, 87,  7, 71, 19, 83,  3, 67,
  118, 54,102, 38,114, 50, 98, 34,119, 55,103, 39,115, 51, 99, 35,
    9, 73, 25, 89, 13, 77, 29, 93,  8, 72, 24, 88, 12, 76, 28, 92,
  105, 41,121, 57,109, 45,125, 61,104, 40,120, 56,108, 44,124, 60,
   17, 81,  1, 65, 21, 85,  5, 69, 16, 80,  0, 64, 20, 84,  4, 68,
  113, 49, 97, 33,117, 53,101, 37,112, 48, 96, 32,116, 52,100, 36,
   15, 79, 31, 95, 11, 75, 27, 91, 14, 78, 30, 94, 10, 74, 26, 90,
  111, 47,126, 63,107, 43,123, 59,110, 46,126, 62,106, 42,122, 58,
   23, 87,  7, 71, 19, 83,  3, 67, 22, 86,  6, 70, 18, 82,  2, 66,
  119, 55,103, 39,115, 51, 99, 35,118, 54,102, 38,114, 50, 98, 34
  };

/**************************************************************************\
* HalftoneSaturationTable
*
*   This table maps a 8 bit pixel plus a dither error term in the range
*   of 0 to 51 onto a 8 bit pixel. Overflow of up to 31 is considered
*   saturated (255+51 = 255). The level 51 (0x33) is used to map pixels
*   and error values to the halftone palette
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE HalftoneSaturationTable[256+64] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE DefaultSaturationTable[] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};


/**************************************************************************\
* vCalcRectOffsets
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/14/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcGradientRectOffsets(PGRADIENTRECTDATA pGradRect)
{
    LONG yScanTop     = MAX(pGradRect->rclClip.top,pGradRect->rclGradient.top);
    LONG yScanBottom  = MIN(pGradRect->rclClip.bottom,pGradRect->rclGradient.bottom);
    LONG yScanLeft    = MAX(pGradRect->rclClip.left,pGradRect->rclGradient.left);
    LONG yScanRight   = MIN(pGradRect->rclClip.right,pGradRect->rclGradient.right);

    //
    // calc actual widht, check for early out
    //

    pGradRect->ptDraw.x = yScanLeft;
    pGradRect->ptDraw.y = yScanTop;
    pGradRect->szDraw.cx = yScanRight  - yScanLeft;
    pGradRect->szDraw.cy = yScanBottom - yScanTop;

    LONG ltemp = pGradRect->rclClip.left - pGradRect->rclGradient.left;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->xScanAdjust  = ltemp;

    ltemp = pGradRect->rclClip.top  - pGradRect->rclGradient.top;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->yScanAdjust = ltemp;

    return((pGradRect->szDraw.cx > 0) && (pGradRect->szDraw.cy > 0));
}

/******************************Public*Routine******************************\
* vFillGRectDIB32BGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32BGRA(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;
    ULONG Alpha  = pgData->Alpha;


    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;
        LONG     dAlpha = pgData->dAdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
            Alpha  += dAlpha * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;
            Alpha += dAlpha;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;
        LONG     dAlpha = pgData->dAdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
            Alpha  +=  dAlpha * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = ((Alpha & 0x00ff0000) <<  8) |
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            ImgFillMemoryULONG(pDst,ul,pgData->szDraw.cx*4);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;
            Alpha += dAlpha;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;

    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX      + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            *pulDstX =
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            ImgFillMemoryULONG(pDst,ul,pgData->szDraw.cx*4);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB24RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB24RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE  pDst   = (PBYTE)pDibInfo->pvBase +
                                    lDelta * pgData->ptDraw.y +
                                    3 * pgData->ptDraw.x;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)LOCALALLOC(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            PBYTE  pDstX  =  pBuffer;
            PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

            while (pDstX != pLast)
            {
                *pDstX     =  (BYTE)(Blue  >> 16);
                *(pDstX+1) =  (BYTE)(Green >> 16);
                *(pDstX+2) =  (BYTE)(Red   >> 16);

                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;

                pDstX+=3;
            }

            //
            // Replicate the scan line. It would be much better to write the scan line
            // out to a memory buffer for drawing to a device surface!!!
            //

            while (cyClip--)
            {
                memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                pDst += lDelta;
            }

            LOCALFREE(pBuffer);
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;
            BYTE  jRed   = (BYTE)((Red   & 0x00ff0000) >> 16);
            BYTE  jGreen = (BYTE)((Green & 0x00ff0000) >> 16);
            BYTE  jBlue  = (BYTE)((Blue  & 0x00ff0000) >> 16);

            while (pTemp != pEnd)
            {
                *pTemp     = jBlue;
                *(pTemp+1) = jGreen;
                *(pTemp+2) = jRed;
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_565(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX       + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

            ULONG   iRed   = (((Red   >> 3) + ulDither) >> 16);
            ULONG   iGreen = (((Green >> 2) + ulDither) >> 16);
            ULONG   iBlue  = (((Blue  >> 3) + ulDither) >> 16);

            //
            // check for overflow
            //

            if ((iRed | iBlue) & 0x20)
            {
                if (iRed & 0x20)
                {
                    iRed = 0x1f;
                }

                if (iBlue & 0x20)
                {
                    iBlue = 0x1f;
                }
            }

            if (iGreen & 0x40)
            {
                iGreen = 0x3f;
            }

            *pusDstX = rgb565(iRed,iGreen,iBlue);

            pusDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_555(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{

    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX       + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

            ULONG   iRed   = (((Red   >> 3) + ulDither) >> 16);
            ULONG   iGreen = (((Green >> 3) + ulDither) >> 16);
            ULONG   iBlue  = (((Blue  >> 3) + ulDither) >> 16);

            //
            // check for overflow
            //

            if ((iRed | iBlue | iGreen) & 0x20)
            {
                if (iRed & 0x20)
                {
                    iRed = 0x1f;
                }

                if (iBlue & 0x20)
                {
                    iBlue = 0x1f;
                }

                if (iGreen & 0x20)
                {
                    iGreen = 0x1f;
                }
            }

            *pusDstX = rgb555(iRed,iGreen,iBlue);

            pusDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB8(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;
    PBYTE    pxlate = pDibInfo->pxlate332;

    //
    // either use default palette or halftone palette dither
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    if (pxlate == gHalftoneColorXlate332)
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight,pjDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x;
        pjDstScanRight = pjDstX + cxClip;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        while (pjDstX < pjDstScanRight)
        {
            //
            // calculate x component of dither
            //

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            BYTE jDitherMatrix = *(pDitherLevel + (((ULONG)pjDstX + xDitherOrg) & DITHER_8_MASK_X));

            iRed   = pSaturationTable[iRed   + jDitherMatrix];
            iGreen = pSaturationTable[iGreen + jDitherMatrix];
            iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            *pjDstX = jIndex;

            pjDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB4(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;
    PBYTE    pxlate           = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;

    //
    // get/build rgb555 to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/2;
        ixDst          = pgData->ptDraw.x;


        while (cx--)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = *(pDitherLevel + ((ixDst+xDitherOrg) & DITHER_8_MASK_X));

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            iRed   = pSaturationTable[iRed   + jDitherMatrix];
            iGreen = pSaturationTable[iGreen + jDitherMatrix];
            iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            if (ixDst & 1)
            {
                *pjDstX = (*pjDstX & 0xf0) | jIndex;
                pjDstX++;
            }
            else
            {
                *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
            }

            ixDst++;

            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vFillGRectDIB1(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
    LONG     yScan  = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;
    PBYTE    pxlate = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix = gDitherMatrix16x16Default;

    //
    // get/build rgb555 to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanLeft  = pgData->ptDraw.x;
        LONG    xScanRight = xScanLeft + cx;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/8;
        ixDst          = pgData->ptDraw.x & 7;

        while (xScanLeft < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            //
            // add dither and saturate. 1bpp non-optimized
            //

            iRed   = iRed   + jDitherMatrix;

            if (iRed >= 255)
            {
                iRed = 255;
            }
            else
            {
                iRed = 0;
            }

            iGreen = iGreen + jDitherMatrix;

            if (iGreen >= 255)
            {
                iGreen = 255;
            }
            else
            {
                iGreen = 0;
            }

            iBlue  = iBlue  + jDitherMatrix;

            if (iBlue >= 255)
            {
                iBlue = 255;
            }
            else
            {
                iBlue = 0;
            }

            BYTE  jIndex;

            //
            // pjVector is known to be identity, so could make new macro for
            // palette_match_1 if perf ever an issue
            //

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            LONG iShift  = 7 - ixDst;
            BYTE OrMask = 1 << iShift;
            BYTE AndMask  = ~OrMask;

            jIndex = jIndex << iShift;

            *pjDstX = (*pjDstX & AndMask) | jIndex;

            ixDst++;

            if (ixDst == 8)
            {
                ixDst = 0;
                pjDstX++;
            }

            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
            xScanLeft++;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* pfnGradientRectFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo - information about destination surface
*
* Return Value:
*
*   PFN_GRADRECT - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_GRADRECT
pfnGradientRectFillFunction(
    PDIBINFO pDibInfo
    )
{
    PFN_GRADRECT pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillGRectDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillGRectDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillGRectDIB16_555;
       }
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 8)
       )
    {
        pfnRet = vFillGRectDIB8;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 4)
       )
    {
        pfnRet = vFillGRectDIB4;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 1)
       )
    {
        pfnRet = vFillGRectDIB1;
    }

    return(pfnRet);
}


/**************************************************************************\
* DIBGradientRect
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBGradientRect(
    HDC            hdc,
    PTRIVERTEX     pVertex,
    ULONG          nVertex,
    PGRADIENT_RECT pMesh,
    ULONG          nMesh,
    ULONG          ulMode,
    PRECTL         prclPhysExt,
    PDIBINFO       pDibInfo,
    PPOINTL        pptlDitherOrg
    )
{
    BOOL          bStatus = TRUE;
    PFN_GRADRECT  pfnGradRect = NULL;
    ULONG         ulIndex;

    pfnGradRect = pfnGradientRectFillFunction(pDibInfo);

    if (pfnGradRect == NULL)
    {
        WARNING("DIBGradientRect:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // fake up scale !!!
    //

    for (ulIndex=0;ulIndex<nVertex;ulIndex++)
    {
        pVertex[ulIndex].x = pVertex[ulIndex].x * 16;
        pVertex[ulIndex].y = pVertex[ulIndex].y * 16;
    }

    //
    // limit rectangle output to clipped output
    //

    LONG dxRect = prclPhysExt->right  - prclPhysExt->left;
    LONG dyRect = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyRect > 0) && (dxRect > 0))
    {
        GRADIENTRECTDATA grData;

        //
        // clip output
        //

        grData.rclClip = *prclPhysExt;
        grData.ptDitherOrg = *pptlDitherOrg;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            ULONG ulRect0 = pMesh[ulIndex].UpperLeft;
            ULONG ulRect1 = pMesh[ulIndex].LowerRight;

            //
            // make sure index are in array
            //

            if (
                 (ulRect0 > nVertex) ||
                 (ulRect1 > nVertex)
               )
            {
                bStatus = FALSE;
                break;
            }

            TRIVERTEX  tvert0 = pVertex[ulRect0];
            TRIVERTEX  tvert1 = pVertex[ulRect1];
            PTRIVERTEX pv0 = &tvert0;
            PTRIVERTEX pv1 = &tvert1;
            PTRIVERTEX pvt;

            //
            // make sure rectangle endpoints are properly ordered
            //

            if (ulMode & GRADIENT_FILL_RECT_H)
            {
                if (pv0->x > pv1->x)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    //
                    // must swap y
                    //

                    LONG ltemp = pv1->y;
                    pv1->y = pv0->y;
                    pv0->y = ltemp;

                }
            }
            else
            {
                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }


                if (pv0->x > pv1->x)
                {
                    //
                    // must swap x
                    //

                    LONG ltemp = pv1->x;
                    pv1->x = pv0->x;
                    pv0->x = ltemp;
                }
            }

            //
            // gradient definition rectangle
            //

            grData.rclGradient.left   = pv0->x >> 4;
            grData.rclGradient.top    = pv0->y >> 4;

            grData.rclGradient.right  = pv1->x >> 4;
            grData.rclGradient.bottom = pv1->y >> 4;

            LONG dxGrad = grData.rclGradient.right  - grData.rclGradient.left;
            LONG dyGrad = grData.rclGradient.bottom - grData.rclGradient.top;

            //
            // make sure this is not an empty rectangle
            //

            if ((dxGrad > 0) && (dyGrad > 0))
            {
                grData.ulMode  = ulMode;

                //
                // calculate color gradients for x and y
                //

                grData.Red   = pv0->Red   << 8;
                grData.Green = pv0->Green << 8;
                grData.Blue  = pv0->Blue  << 8;
                grData.Alpha = pv0->Alpha << 8;

                if (ulMode & GRADIENT_FILL_RECT_H)
                {

                    grData.dRdY = 0;
                    grData.dGdY = 0;
                    grData.dBdY = 0;
                    grData.dAdY = 0;

                    LONG dRed   = (pv1->Red   << 8) - (pv0->Red   << 8);
                    LONG dGreen = (pv1->Green << 8) - (pv0->Green << 8);
                    LONG dBlue  = (pv1->Blue  << 8) - (pv0->Blue  << 8);
                    LONG dAlpha = (pv1->Alpha << 8) - (pv0->Alpha << 8);

                    grData.dRdX = dRed   / dxGrad;
                    grData.dGdX = dGreen / dxGrad;
                    grData.dBdX = dBlue  / dxGrad;
                    grData.dAdX = dAlpha / dxGrad;
                }
                else
                {

                    grData.dRdX = 0;
                    grData.dGdX = 0;
                    grData.dBdX = 0;
                    grData.dAdX = 0;

                    LONG dRed   = (pv1->Red   << 8) - (pv0->Red   << 8);
                    LONG dGreen = (pv1->Green << 8) - (pv0->Green << 8);
                    LONG dBlue  = (pv1->Blue  << 8) - (pv0->Blue  << 8);
                    LONG dAlpha = (pv1->Alpha << 8) - (pv0->Alpha << 8);

                    grData.dRdY = dRed   / dyGrad;
                    grData.dGdY = dGreen / dyGrad;
                    grData.dBdY = dBlue  / dyGrad;
                    grData.dAdY = dAlpha / dyGrad;
                }

                //
                // calculate common offsets
                //

                if (bCalcGradientRectOffsets(&grData))
                {
                    //
                    // call specific drawing routine if output
                    // not totally clipped
                    //

                    (*pfnGradRect)(pDibInfo,&grData);
                }
            }

        }
    }

    SetMapMode(hdc,OldMode);

    return(bStatus);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\tricalc.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

//
// temp global
//

HBITMAP hbmDefault;


#if DBG
ULONG   DbgRecord = 0;
#endif

/******************************Public*Routine******************************\
* vHorizontalLine
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0 >> 4;
    LONG yIndex    = yPosition - ptData->rcl.top;

    ptridda->L = ptridda->M0 >> 4;

    #if DBG
    if (DbgRecord >= 1)
    {
       DbgPrint("vCalculateLine:Horizontal Line: L = 0x%lx, yIndex = 0x%lx\n",ptridda->L,yIndex);
    }
    #endif


    if ((yPosition >= ptData->rcl.top) &&
       (yPosition < ptData->rcl.bottom))
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            // !!! is the check necessary? overlap from another
            // line segment.
            //

            ptData->TriEdge[yIndex].xLeft = pv1->x     >> 4;
            ptData->TriEdge[yIndex].Red   = pv1->Red   << 8;
            ptData->TriEdge[yIndex].Green = pv1->Green << 8;
            ptData->TriEdge[yIndex].Blue  = pv1->Blue  << 8;
            ptData->TriEdge[yIndex].Alpha = pv1->Alpha << 8;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x >> 4;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft = pv2->x     >> 4;
            ptData->TriEdge[yIndex].Red   = pv2->Red   << 8;
            ptData->TriEdge[yIndex].Green = pv2->Green << 8;
            ptData->TriEdge[yIndex].Blue  = pv2->Blue  << 8;
            ptData->TriEdge[yIndex].Alpha = pv2->Alpha << 8;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x >> 4;
        }
    }
}

/******************************Public*Routine******************************\
* vLeftEdgeDDA
*
*   Run line DDA down a left edge of the triangle recording left edge
*   position and color
*
* Arguments:
*
*   NumScanLines
*   yIndex
*   Red
*   Green
*   Blue
*   Alpha
*   L
*   Rb
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vLeftEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONG Red          = ptridda->Red;
    LONG Green        = ptridda->Green;
    LONG Blue         = ptridda->Blue;
    LONG Alpha        = ptridda->Alpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vLeftEdgeDDA:Scan yIndex = %li\n",yIndex);
    }
    #endif

    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)

    while (NumScanLines--)
    {

        #if DBG
        if (DbgRecord >= 3)
        {
            DbgPrint("vCalculateLine:Scan yIndex = %li\n",yIndex);
            DbgPrint("vCalculateLine:L           = %li\n",L);
            DbgPrint("vCalculateLine:Rb          = %li\n",Rb);
        }
        #endif

        // record left edge

        if (yIndex >= 0)
        {
            ptData->TriEdge[yIndex].xLeft = L;
            ptData->TriEdge[yIndex].Red   = Red;
            ptData->TriEdge[yIndex].Green = Green;
            ptData->TriEdge[yIndex].Blue  = Blue;
            ptData->TriEdge[yIndex].Alpha = Alpha;
        }

        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR

        yIndex++;
        L  += ptridda->dL;
        Rb -= ptridda->dR;

        // inc color components by y and integer x components

        Red   += (ptridda->dxyRed);
        Green += (ptridda->dxyGreen);
        Blue  += (ptridda->dxyBlue);
        Alpha += (ptridda->dxyAlpha);

        // check for DDA error term overflow, add one
        // more step in x if true, and correct error term

        if (Rb < 0)
        {
            // DDA

            L     += ptridda->Linc;
            Rb    += ptridda->dN;

            // inc color components

            Red   += ptData->dRdX;
            Green += ptData->dGdX;
            Blue  += ptData->dBdX;
            Alpha += ptData->dAdX;
        }
    }
}

/******************************Public*Routine******************************\
* vRightEdgeDDA
*
*   Run the line DDA along the right edge of the triangle recording right
*   edge position
*
* Arguments:
*
*   NumScanLines
*   yIndex
*   Red
*   Green
*   Blue
*   Alpha
*   L
*   Rb
*
* Return Value:
*
*   None
*
* History:
*
*    11/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vRightEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONG Red          = ptridda->Red;
    LONG Green        = ptridda->Green;
    LONG Blue         = ptridda->Blue;
    LONG Alpha        = ptridda->Alpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vRightEdgeDDA:Scan yIndex = %li\n",yIndex);
    }
    #endif

    while (ptridda->NumScanLines--)
    {
        #if DBG
        if (DbgRecord >= 3)
        {
            DbgPrint("vCalculateLine:Scan yIndex = %li\n",yIndex);
            DbgPrint("vCalculateLine:L           = %li\n",L);
            DbgPrint("vCalculateLine:Rb          = %li\n",Rb);
        }
        #endif

        // record left, right edge

        if (yIndex >= 0)
        {
            ptData->TriEdge[yIndex].xRight = L;
        }

        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR

        yIndex++;
        L  += ptridda->dL;
        Rb -= ptridda->dR;

        // inc color components by y and integer x components

        Red   += (ptridda->dxyRed);
        Green += (ptridda->dxyGreen);
        Blue  += (ptridda->dxyBlue);
        Alpha += (ptridda->dxyAlpha);

        // check for DDA error term overflow, add one
        // more step in x if true, and correct error term

        if (Rb < 0)
        {
            // DDA

            L     += ptridda->Linc;
            Rb    += ptridda->dN;

            // inc color components

            Red   += ptData->dRdX;
            Green += ptData->dGdX;
            Blue  += ptData->dBdX;
            Alpha += ptData->dAdX;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData,
    BOOL            bLeftEdge
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.dxyRed   = ptData->dRdY;
    tridda.dxyGreen = ptData->dGdY;
    tridda.dxyBlue  = ptData->dBdY;
    tridda.dxyAlpha = ptData->dAdY;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateLine:\n");
        DbgPrint("vCalculateLine:pv1.x    = %li, pv1.y = %li\n",pv1->x,pv1->y);
        DbgPrint("vCalculateLine:pv1->Red = 0x%lx, pv1->Green = 0x%lx, pv1->Blue = 0x%lx\n",
                            pv1->Red,pv1->Green,pv1->Blue);
        DbgPrint("vCalculateLine:pv2.x    = %li, pv2.y = %li\n",pv2->x,pv2->y);
        DbgPrint("vCalculateLine:pv2->Red = 0x%lx, pv2->Green = 0x%lx, pv2->Blue = 0x%lx\n",
                            pv2->Red,pv2->Green,pv2->Blue);
    }
    #endif

    //
    // Arrange lines, must run in positive delta y.
    // !!! what other effect of swap is there? !!!
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
        tridda.Red     = pv1->Red   << 8;
        tridda.Green   = pv1->Green << 8;
        tridda.Blue    = pv1->Blue  << 8;
        tridda.Alpha   = pv1->Alpha << 8;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
        tridda.Red      = pv2->Red   << 8;
        tridda.Green    = pv2->Green << 8;
        tridda.Blue     = pv2->Blue  << 8;
        tridda.Alpha    = pv2->Alpha << 8;
        tridda.dxyRed   = -tridda.dxyRed;
        tridda.dxyGreen = -tridda.dxyGreen;
        tridda.dxyBlue  = -tridda.dxyBlue;
        tridda.dxyAlpha = -tridda.dxyAlpha;
    }

    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        //
        // this is as cryptic as ASM at the moment
        //

        LONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line
        //

        tridda.yIndex = (tridda.N0 >> 4) - ptData->y0;

        tridda.NumScanLines = (tridda.dN >> 4);

        LONG NMax   = (tridda.N0 >> 4) + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
            ((tridda.N0 >> 4) > ptData->rcl.bottom) ||
            (NMax < ptData->rcl.top)
           )
        {
            // nothing to draw
            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0 >> 4;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = (tridda.C >> 4) + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            // negative divide

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            // dM = 0
            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0 = tridda.j * tridda.dL;
        LongL  = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);            // integer portion
        }
        else if (LongL < 0)
        {
            LONG Q = (LONG)((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = l0 + Frac;
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx !!! could it be more expensive !!!
        //

        if (tridda.dL != 0)
        {
            tridda.dxyRed   = tridda.dxyRed   + (LONG)((ptData->dRdXA * tridda.dL) / ptData->Area);
            tridda.dxyGreen = tridda.dxyGreen + (LONG)((ptData->dGdXA * tridda.dL) / ptData->Area);
            tridda.dxyBlue  = tridda.dxyBlue  + (LONG)((ptData->dBdXA * tridda.dL) / ptData->Area);
            tridda.dxyAlpha = tridda.dxyAlpha + (LONG)((ptData->dAdXA * tridda.dL) / ptData->Area);
        }

        #if DBG
        if (DbgRecord >= 1)
        {
            LONG CL = (LONG)tridda.C;
            LONG CH = (LONG)(tridda.C/4294967296);
            DbgPrint("vCalculateLine:Normal Line\n");
            DbgPrint("vCalculateLine:N0        = %li\n",tridda.N0);
            DbgPrint("vCalculateLine:dN        = %li\n",tridda.dN);
            DbgPrint("vCalculateLine:M0        = %li\n",tridda.M0);
            DbgPrint("vCalculateLine:dM        = %li\n",tridda.dM);
            DbgPrint("vCalculateLine:C         = %08lx %08lx\n",CH,CL);
            DbgPrint("vCalculateLine:Frac      = %li\n",Frac);
            DbgPrint("vCalculateLine:l0        = %li\n",l0);
            DbgPrint("vCalculateLine:L         = %li\n",tridda.L);
            DbgPrint("vCalculateLine:dL        = %li\n",tridda.dL);
            DbgPrint("vCalculateLine:R         = %li\n",tridda.R);
            DbgPrint("vCalculateLine:dR        = %li\n",tridda.dR);
            DbgPrint("vCalculateLine:Rb        = %li\n",tridda.Rb);
            DbgPrint("vCalculateLine:dxyRed    = 0x%lx\n",tridda.dxyRed);
            DbgPrint("vCalculateLine:dxyGreen  = 0x%lx\n",tridda.dxyGreen);
            DbgPrint("vCalculateLine:dxyBlue   = 0x%lx\n",tridda.dxyBlue);
            DbgPrint("vCalculateLine:dxyAlpha  = 0x%lx\n",tridda.dxyAlpha);


        }
        #endif

        //
        // left or right edge
        //

        if (bLeftEdge)
        {
            vLeftEdgeDDA(ptData,&tridda);
        }
        else
        {
            vRightEdgeDDA(ptData,&tridda);
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateColorGradient
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    LONG            C0,
    LONG            C1,
    LONG            C2,
    PLONGLONG       pArea,
    PLONGLONG       pGradXA,
    PLONG           pGradX,
    PLONG           pGradY
    )
{
    LONG dCdX = 0;
    LONG dCdY = 0;
    LONGLONG t1,t2,t3,tAll;

    C0 = C0 << 8;
    C1 = C1 << 8;
    C2 = C2 << 8;

    //
    // dY
    //

    t1   = - ((LONGLONG)C0 * (LONGLONG)(pv2->x - pv1->x));
    t2   = - ((LONGLONG)C1 * (LONGLONG)(pv0->x - pv2->x));
    t3   = - ((LONGLONG)C2 * (LONGLONG)(pv1->x - pv0->x));
    tAll = 16 * (t1 + t2 + t3);

    if (tAll > 0)
    {
        dCdY = (LONG)(tAll / *pArea);
    }
    else if (tAll < 0)
    {
        tAll = -tAll;
        dCdY = (LONG)((tAll - 1) / *pArea);
        dCdY = -(dCdY + 1);
    }

    *pGradY = dCdY;

    //
    // Divide by area to get single step x. Keep undivided
    // value around to calc multiple integer step in x
    //


    t1   = - ((LONGLONG)C0 * (LONGLONG)(pv2->y - pv1->y));
    t2   = - ((LONGLONG)C1 * (LONGLONG)(pv0->y - pv2->y));
    t3   = - ((LONGLONG)C2 * (LONGLONG)(pv1->y - pv0->y));
    tAll = t1;
    tAll += t2;
    tAll += t3;
    tAll *= 16;

    *pGradXA = tAll;

    dCdX = 0;

    if (tAll > 0)
    {
        dCdX = (LONG)(tAll / *pArea);
    }
    else if (tAll < 0)
    {
        tAll = -tAll;
        dCdX = (LONG)((tAll - 1) / *pArea);
        dCdX = -(dCdX + 1);
    }

    *pGradX = dCdX;
}

/******************************Public*Routine******************************\
* vCalculateTriangle
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateTriangle(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG index;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateTriangle:\n");
        DbgPrint("vCalculateTriangle:rcl = [%li,%li] to [%li,%li]\n",
                            ptData->rcl.left,
                            ptData->rcl.top,
                            ptData->rcl.right,
                            ptData->rcl.bottom
                            );
        DbgPrint("vCalculateTriangle:pv0.x = %li, pv0.y = %li\n",pv0->x,pv0->y);
        DbgPrint("vCalculateTriangle:pv0->Red = 0x%lx, pv0->Green = 0x%lx, pv0->Blue = 0x%lx\n",
                            pv0->Red,pv0->Green,pv0->Blue);
        DbgPrint("vCalculateTriangle:pv1.x = %li, pv1.y = %li\n",pv1->x,pv1->y);
        DbgPrint("vCalculateTriangle:pv1->Red = 0x%lx, pv1->Green = 0x%lx, pv1->Blue = 0x%lx\n",
                            pv1->Red,pv1->Green,pv1->Blue);
        DbgPrint("vCalculateTriangle:pv2.x = %li, pv2.y = %li\n",pv2->x,pv2->y);
        DbgPrint("vCalculateTriangle:pv2->Red = 0x%lx, pv2->Green = 0x%lx, pv2->Blue = 0x%lx\n",
                            pv2->Red,pv2->Green,pv2->Blue);

    }
    #endif

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);
    ptData->Area = Area;

    #if DBG
    if (DbgRecord >= 1)
    {
        LONG AreaL = (LONG)Area;
        LONG AreaH = (LONG)(Area/4294967296);
        DbgPrint("vCalculateTriangle:v12x = %lx\n",v12x);
        DbgPrint("vCalculateTriangle:v12y = %lx\n",v12y);
        DbgPrint("vCalculateTriangle:v02x = %lx\n",v02x);
        DbgPrint("vCalculateTriangle:v02y = %lx\n",v02y);
        DbgPrint("vCalculateTriangle:Area = %lx %lx\n",AreaH,AreaL);
    }
    #endif

    //
    // if area is zero then this is a degenerate triangle
    //

    if (Area == 0)
    {
        return(FALSE);
    }

    //
    // calc min and max drawing y
    //

    ptData->y0   = MAX((pv0->y >> 4),ptData->rcl.top);
    LONG MaxY    = (MAX(pv1->y,pv2->y)) >> 4;
    ptData->y1   = MIN(MaxY,ptData->rcl.bottom);

    //
    // calculate color gradients for each color. There is a little redundant
    // work here with calculation of deltas. Should make this one call or
    // do it in place.
    //

    vCalulateColorGradient(pv0,pv1,pv2,pv0->Red  ,pv1->Red  ,pv2->Red  ,&Area,&ptData->dRdXA,&ptData->dRdX,&ptData->dRdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Green,pv1->Green,pv2->Green,&Area,&ptData->dGdXA,&ptData->dGdX,&ptData->dGdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Blue ,pv1->Blue ,pv2->Blue ,&Area,&ptData->dBdXA,&ptData->dBdX,&ptData->dBdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Alpha,pv1->Alpha,pv2->Alpha,&Area,&ptData->dAdXA,&ptData->dAdX,&ptData->dAdY);

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateTriangle:dRdx = 0x%lx,dRdy = 0x%lx\n",ptData->dRdX,ptData->dRdY);
        DbgPrint("vCalculateTriangle:dGdx = 0x%lx,dGdy = 0x%lx\n",ptData->dGdX,ptData->dGdY);
        DbgPrint("vCalculateTriangle:dBdx = 0x%lx,dBdy = 0x%lx\n",ptData->dBdX,ptData->dBdY);
        DbgPrint("vCalculateTriangle:dAdx = 0x%lx,dAdy = 0x%lx\n",ptData->dAdX,ptData->dAdY);
    }
    #endif

    //
    // draw lines into data array
    //

    vCalculateLine(pv0,pv1,ptData,FALSE);
    vCalculateLine(pv1,pv2,ptData,(pv1->y > pv2->y));
    vCalculateLine(pv2,pv0,ptData,TRUE);

    return(TRUE);
}

/**************************************************************************\
* bCalculateTriangle
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
GetNearestEntry(
        PULONG   prgbIn,
        ULONG    ulNumEntries,
        ALPHAPIX MatchColor
        )
{
    LONG   lError = MAX_INT;
    ULONG  ulBest = 0;
    ULONG  ulIndex;
    LPRGBQUAD prgb = (LPRGBQUAD)prgbIn;

    for (ulIndex=0;ulIndex<ulNumEntries;ulIndex++)
    {
        LONG eRed   = (LONG)(MatchColor.pix.r - prgb->rgbRed);
        LONG eGreen = (LONG)(MatchColor.pix.g - prgb->rgbGreen);
        LONG eBlue  = (LONG)(MatchColor.pix.b - prgb->rgbBlue);

        eRed = eRed*eRed + eGreen*eGreen + eBlue*eBlue;

        if (eRed < lError)
        {
            lError = eRed;
            ulBest = ulIndex;
        }

        prgb++;
    }

    return((BYTE)ulBest);
}


/**************************************************************************\
* GenColorXform332
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/
PBYTE
pGenColorXform332(
    PULONG ppalIn,
    ULONG  ulNumEntries
    )
{
    ASSERTGDI((ppalIn != NULL),"pGenColorXform332 called with NULL input palette\n");
    ASSERTGDI((ulNumEntries <= 256),"pGenColorXform332 called with invalid ulNumEntries\n");

    if ((ppalIn == NULL) || (ulNumEntries > 256))
    {
        return(FALSE);
    }

    //
    // check for halftone palette
    //

    if (ulNumEntries == 256)
    {
        if (bIsHalftonePalette(ppalIn))
        {
            return(gHalftoneColorXlate332);
        }
    }

    //
    // allocate and generate color lookup table
    //

    PBYTE pxlate = (PBYTE)LOCALALLOC(256);

    if (pxlate)
    {
        PBYTE pXlateTable = pxlate;

        //
        // generate color xlate from RGB 332 to palette
        //
    
        BYTE Red[8]   = {0,37,73,110,146,183,219,255};
        BYTE Green[8] = {0,37,73,110,146,183,219,255};
        BYTE Blue[4]  = {0,85,171,255};
    
        //
        // ppalOut must be a 256 entry table
        //
    
        ULONG    ulB,ulG,ulR;
        ALPHAPIX Pixel;
    
        for (ulR = 0;ulR<8;ulR++)
        {
            Pixel.pix.r = Red[ulR];
    
            for (ulG = 0;ulG<8;ulG++)
            {
                Pixel.pix.g = Green[ulG];
    
                for (ulB = 0;ulB<4;ulB++)
                {
                    Pixel.pix.b = Blue[ulB];
                    *pXlateTable++ = GetNearestEntry(ppalIn,ulNumEntries,Pixel);
                }
            }
        }
    }

    return(pxlate);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\tran.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentBlt;
extern PFNTRANSDIB gpfnTransparentDIBits;

#if (_WIN32_WINNT == 0x400)
typedef struct _LOGPALETTE2
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[2];
} LOGPALETTE2;

typedef struct _LOGPALETTE16
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[16];
} LOGPALETTE16;

typedef struct _LOGPALETTE256
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

/******************************Public*Routine******************************\
* StartPixel
*    Give a scanline pointer and position of a pixel, return the byte address
* of where the pixel is at depending on the format
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
PBYTE StartPixel (
    PBYTE pjBits,
    ULONG xStart,
    ULONG iBitmapFormat
)
{
   PBYTE pjStart = pjBits;
    //
    // getting the starting pixel
    //
    switch (iBitmapFormat)
    {
      case 1:
          pjStart = pjBits + (xStart >> 3);
          break;

       case 4:
          pjStart = pjBits + (xStart >> 1);
          break;

       case 8:
          pjStart = pjBits + xStart;
          break;

       case 16:
          pjStart = pjBits + 2*xStart;
          break;

       case 24:
          pjStart = pjBits + 3*xStart;
          break;

       case 32:
          pjStart = pjBits+4*xStart;
          break;

       default:
           WARNING ("Startpixel -- bad iFormatSrc\n");
    }

    return (pjStart);
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy4
*
* Doing a transparent copy on two same size 4BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;

     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;

     BYTE   jSrc=0;
     BYTE   jDst=0;
     LONG   iSrc, iDst;


     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjSrcTemp = pjSrc;
         pjDstTemp = pjDst;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= jSrc & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (jSrc << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D1
*
* Doing a transparent copy from 4PP to 1BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 3);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE2 logPal2;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up our xlate table
     //
     logPal2.PalVersion    = 0x300;
     logPal2.PalNumEntries = 2;

     for (i = 0; i < 2; i++)
     {
         logPal2.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal2.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal2.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal2.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal2);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left & 0x07;

         pjDstTemp = pjDst;

         jDst = *pjDstTemp >> (8 - iDst);

         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             //
             // put one pixel in the dest
             //
             if (jSrc != TransColor)
             {
                jDst |= xlate[jSrc];  //0 OR 1
             }
             else
             {
                jDst |= 1-xlate[jSrc];
             }

             jDst <<1;
             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
          }

          if (iDst & 0x00000007)
          {
            // We need to build up the last pel correctly.

            BYTE jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	         *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
           }

           pjDst += pDibInfoDst->stride;
           pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D4
*
* Doing a transparent copy from 4PP to 4bpp non identity
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE16 logPal16;
     HPALETTE    hPal;
     LONG    i;
     ULONG   cxTemp;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up translate table
     //
     logPal16.PalVersion    = 0x300;
     logPal16.PalNumEntries = 16;

     for (i = 0; i < 16; i++)
     {
         logPal16.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal16.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal16.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal16.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal16);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= xlate[jSrc] & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D8
*
* Doing a transparent copy from 4PP to 8bpp
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc;
     LOGPALETTE256 logPal256;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     logPal256.PalVersion    = 0x300;
     logPal256.PalNumEntries = 256;

     for (i = 0; i < 256; i++)
     {
         logPal256.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal256.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal256.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal256.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal256);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);

         //Dprintf("i=%x, rgbColor = 0x%08x, xlate[i] = %x", i, rgbColor, xlate[i]);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 *pjDstTemp = xlate[jSrc];
             }

             pjDstTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D16
*
* Doing a transparent copy from 4BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
             }

             pjDstTemp += 2;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D24
*
* Doing a transparent copy from 4BPP to 24BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D32
*
* Doing a transparent copy from 4BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;
         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D16
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

            //
            // put one pixel in the dest
            //
            if (jSrc != (BYTE)TransColor)
            {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
            }

            pjDstTemp += 2;

         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D24
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D32
*
* Doing a transparent copy from 8BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}




/******************************Public*Routine******************************\
* vTransparentS8D1
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[32];
     INT     i, j;
     BYTE    pByteSrc[256];
     LONG    iDst;
     BYTE    jDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,pDibInfoSrc->iUsage);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     BYTE bTmp = 0;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iDst = pDibInfoDst->rclDIB.left & 0x07;

         jDst = *pjDstTemp >> (7 - iDst);

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             //
             // put one pixel in the dest
             //
             bTmp = pByte[jSrc >> 3];
             bTmp >>= 7 - (jSrc & 0x07);

             if (jSrc != TransColor)
             {
                jDst |= bTmp;
             }
             else
             {
                jDst |= 1-bTmp;
             }

             jDst <<= 1;

             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D4
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[128];
     INT     i, j;
     BYTE    xlate[256];
     BYTE    pByteSrc[256];
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     j = 0;
     for (i = 0; i < 128; i++)
     {
         xlate[j] = (pByte[i] & 0xF0) >> 4;
         xlate[j++] = pByte[i] & 0x0F;
     }

     BYTE jDst;

     while(cy--)
     {
         cxTemp = cx;

         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F);
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F);
                 }

                 *pjDstTemp = jDst;
                 jDst = 0;

                 pjDstTemp++;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F)<< 4;
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F) << 4;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
     LONG    cy = pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;

     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = *pjSrcTemp;
             }
             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     INT     i, j;
     BYTE    pByteSrc[256];
     PBYTE   pxlate;
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pxlate, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;


     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = pxlate[*pjSrcTemp];
             }

             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }

     DeleteObject (hbm);
     DeleteDC (hdc);
}



#if 0
/******************************Public*Routine******************************\
* vTransparentIdentityCopy16
*
* Doing a transparent copy on two same size 16BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PUSHORT   pusDst = (PUSHORT)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoDst->rclDIB.left;
     PUSHORT   pusSrc = (PUSHORT)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoSrc->rclDIB.left;
     LONG      cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG      cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PUSHORT   pusDstTemp;
     PUSHORT   pusSrcTemp;
     LONG      cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pusDstTemp = pusDst;
         pusSrcTemp = pusSrc;

         while (cxTemp--)
         {
             if (*pusSrcTemp != (USHORT)TransColor)
             {
                 *pusDstTemp = *pusSrcTemp;
             }

             pusDstTemp++;
             pusSrcTemp++;
         }

         pusDst = (PUSHORT)((PBYTE)pusDst + pDibInfoDst->stride);
         pusSrc = (PUSHORT)((PBYTE)pusSrc + pDibInfoSrc->stride);
     }
}

/******************************Public*Routine******************************\
* vTransparentIdentityCopy24
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left*3;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     ULONG   ulTemp;
     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
            ulTemp = (ULONG) *(pjSrcTemp + 2);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *(pjSrcTemp + 1);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *pjSrcTemp;

            if (ulTemp != TransColor)
            {
               *(pjDstTemp++) = (BYTE) ulTemp;
               *(pjDstTemp++) = (BYTE) (ulTemp >> 8);
               *(pjDstTemp++) = (BYTE) (ulTemp >> 16);
            }
            else
            {
                pjDstTemp += 3;
            }

            pjSrcTemp += 3;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentIdentityCopy32
*
* Doing a transparent copy on two same size 32BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PULONG   pulDst = (PULONG)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top)
                       + pDibInfoDst->rclDIB.left;
     PULONG   pulSrc = (PULONG)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top)
                       + pDibInfoSrc->rclDIB.left;
     LONG     cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG     cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PULONG   pulDstTemp;
     PULONG   pulSrcTemp;
     LONG     cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pulDstTemp = pulDst;
         pulSrcTemp = pulSrc;

         while (cxTemp--)
         {
             // mask off highest byte -- workaround Memphis problem
             if ((*pulSrcTemp & 0x00FFFFFF) != TransColor)
             {
                 *pulDstTemp = *pulSrcTemp;
             }

             pulDstTemp++;
             pulSrcTemp++;
         }

         pulDst = (PULONG)((PBYTE)pulDst + pDibInfoDst->stride);
         pulSrc = (PULONG)((PBYTE)pulSrc + pDibInfoSrc->stride);
     }
}
#endif

/******************************Public*Routine******************************\
* MapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* by creating a solid brush on the colorref, then PatBlt to a 1X1 DIB, the
* resulting pixel is the mapped transparent color
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD MapTransparentColor(
    PDIBINFO pDibInfo,
    COLORREF Color
    )
{
    HBRUSH hbr, hbrDefault;
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits = NULL;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfo->hdc);

    hbr = CreateSolidBrush (Color);

    //
    // save the original width/height
    //
    ulWidth = pDibInfo->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfo->pbmi->bmiHeader.biHeight;

    pDibInfo->pbmi->bmiHeader.biWidth = 1;
    pDibInfo->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfo->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm && hbr)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);
        hbrDefault = (HBRUSH)SelectObject (hdcTemp, hbr);

        PatBlt (hdcTemp, 0, 0, 1, 1, PATCOPY);

        SelectObject (hdcTemp, hbrDefault);
        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfo->pbmi->bmiHeader.biBitCount)
          {
          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfo->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfo->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteObject (hbr);
    DeleteObject(hdcTemp);

    return (trancolor);
}

/******************************Public*Routine******************************\
* DIBMapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* This is only for DIB_PAL_COLORS passed into transparentDIBits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD DIBMapTransparentColor(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    COLORREF Color
    )
{
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfoDst->hdc);

    //
    // save the original width/height
    //
    ulWidth = pDibInfoDst->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfoDst->pbmi->bmiHeader.biHeight;

    pDibInfoDst->pbmi->bmiHeader.biWidth = 1;
    pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

        StretchDIBits (hdcTemp,
                       0,
                       0,
                       1,
                       1,
                       0,
                       0,
                       1,
                       1,
                       &Color,
                       pDibInfoSrc->pbmi,
                       pDibInfoSrc->iUsage,
                       SRCCOPY);

        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfoDst->pbmi->bmiHeader.biBitCount)
          {
          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteObject(hdcTemp);

    return (trancolor);
}


/******************************Public*Routine******************************\
* vTransparentMapCopy
*
* Map the Dest surface to 32bpp and does transparent on to that
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentMapCopy (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
     HDC hdc = pDibInfoSrc->hdc;
     ULONG cxDst = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     ULONG cyDst = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     HBITMAP hbm;
     PVOID   pBits;
     ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
     PBITMAPINFO pbmi;
     PVOID p = LOCALALLOC(cBytes);

     if (!p)
     {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
     }

     ZeroMemory (p,cBytes);

     pbmi = (PBITMAPINFO)p;

     vCopyBitmapInfo (pbmi, pDibInfoDst->pbmi);

     hdc = CreateCompatibleDC (hdc);

     pbmi->bmiHeader.biBitCount = 32;

     // create a dib using 32 format
     hbm = CreateCompatibleDIB (hdc, cxDst, cyDst, &pBits, pbmi);

     SetDIBits (hdc, hbm, 0, cyDst, pDibInfoDst->pvBits, pDibInfoDst->pbmi, DIB_RGB_COLORS);

     vCopyBitmapInfo (pDibInfoDst->pbmi,pbmi);

     GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

     pDibInfoDst->pvBits = pBits;

     if (pDibInfoSrc->pbmi->bmiHeader.biBitCount == 8)
     {
         vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
     }
     else if (pDibInfoSrc->pbmi->bmiHeader.biBitCount == 4)
     {
         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
     }

     if (p)
     {
         LOCALFREE (p);
     }
}

/******************************Public*Routine******************************\
* ReadScanLine
*     read the scanline until it hits a transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG ReadScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  cx = xEnd-xStart;
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //
     iPos = xStart;

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return(0);

         } /*switch*/

         if (ulSrc == TransparentColor)
             bStop = TRUE;

         iPos++;
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* SkipScanLine
*     read the scanline until it hits a non-transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG SkipScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos = xStart;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return (0);

         } /*switch*/

         if (ulSrc != TransparentColor)
             bStop = TRUE;

         iPos++;   // move to the next pixel
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* VOID vTransparentCopyScan
*
* Read a scanline at a time and send the non-transparent pixel scans over
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vTransparentCopyScan (
    PDIBINFO  pDibInfoDst,
    PDIBINFO  pDibInfoSrc,
    ULONG     TransparentColor)
{
    ULONG xStart;
    ULONG cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
    ULONG cy =  pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
    ULONG xEnd;
    ULONG xSrc;
    ULONG ySrc = pDibInfoSrc->rclDIB.bottom;
    ULONG xDst;
    ULONG yDst = pDibInfoDst->rclBounds.top;
    ULONG xStop, xReStart;

    PBYTE pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoSrc->stride;

    //
    // we only allow 4bpp,8bpp src for now
    //

    if ((pDibInfoSrc->pbmi->bmiHeader.biBitCount != 4) ||
        (pDibInfoSrc->pbmi->bmiHeader.biBitCount != 8))
    return;

    while (cy--)
    {
       xStart = pDibInfoSrc->rclDIB.left;
       xEnd = xStart + cx;

       xSrc = pDibInfoSrc->rclDIB.left;
       xDst = pDibInfoDst->rclBounds.left;

       while (xStart < xEnd)
       {
           xStop = ReadScanLine((PBYTE)pjSrc,
                                 xStart,
                                 xEnd,
                                 pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                 TransparentColor);

           if (xStop-1 > xStart)
           {
               //
               // send the partial scan line over
               //
               StretchDIBits (
                          pDibInfoDst->hdc,
                          xDst,
                          yDst,
                          xStop-xStart-1, //width
                          1,
                          xSrc-1,
                          ySrc-1,
                          xStop-xStart-1,
                          1,
                          (PBYTE)pDibInfoSrc->pvBits,
                          pDibInfoSrc->pbmi,
                          DIB_RGB_COLORS,
                          SRCCOPY);

           }

           //get to the next non transparent pixel
           xReStart = SkipScanLine((PBYTE)pjSrc,
                                    xStop-1,
                                    xEnd,
                                    pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                    TransparentColor);

           xDst = xDst + xReStart-xStart;

           xSrc = xReStart;

           xStart = xReStart;
        }

        pjSrc += pDibInfoSrc->stride;

        ySrc--;
        yDst++;
     }
}


/******************************Public*Routine******************************\
* WinTransparentBlt
*
* Returns:
*   BOOL.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/


BOOL
WinTransparentBlt(
                 HDC   hdcDst,
                 int   xDst,
                 int   yDst,
                 int   cxDst,
                 int   cyDst,
                 HDC   hdcSrc,
                 int   xSrc,
                 int   ySrc,
                 int   cxSrc,
                 int   cySrc,
                 UINT  TransColor
                 )

{
    BOOL bRet = TRUE;
    DIBINFO DibInfoDst, DibInfoSrc;
    PDIBINFO pDibInfoDst, pDibInfoSrc;
    BOOL     bReadable;
    //
    // parameter checking
    //

    if (cxDst < 0 || cyDst < 0 || cxSrc < 0 || cySrc < 0)
    {
        WARNING("bad parameters\n");
        return (FALSE);
    }

    pDibInfoDst = &DibInfoDst;
    ZeroMemory (pDibInfoDst, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcDst, xDst, yDst, cxDst, cyDst, pDibInfoDst))
        return (FALSE);

    pDibInfoSrc = &DibInfoSrc;
    ZeroMemory (pDibInfoSrc, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcSrc, xSrc, ySrc, cxSrc, cySrc, pDibInfoSrc))
        return (FALSE);

    bRet = bSetupBitmapInfos (pDibInfoDst, pDibInfoSrc);

    if (bRet)
    {
       TransColor = MapTransparentColor (pDibInfoSrc, TransColor);

       bRet =  bGetSrcDIBits(pDibInfoDst, pDibInfoSrc, SOURCE_TRAN, TransColor);

       if (bRet)
       {
          bRet = bGetDstDIBits (pDibInfoDst, &bReadable, SOURCE_TRAN);

          if (bRet)
          {

             if (bReadable)
             {
                switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                {
                case 4:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4)
                     {
                         vTransparentS4D4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS4D8(pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                         vTransparentS4D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                         vTransparentS4D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {   //1
                         vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 8:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS8D8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                        vTransparentS8D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                        vTransparentS8D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                        vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {
                        //1, 4
                        vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                default:
                     WARNING ("src format not currently supported\n");
                     bRet = FALSE;
                     goto CleanUp;
                     break;
                }

                //
                // if we have created a temp destination DIB, send the final result to destination
                //

                bRet = bSendDIBINFO (hdcDst, pDibInfoDst);
             }
             else
             {
              //
              // non-readable dest surface
              //
              vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
             }
          }
          else
          {
              WARNING ("GetSrcDIBits failed\n");
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING ("GetDstDIBits failed \n");
        bRet = FALSE;
    }
    //
    // clean up
    //
CleanUp:
    vCleanupDIBINFO (pDibInfoDst);
    vCleanupDIBINFO (pDibInfoSrc);


    return (bRet);
}

/******************************Public*Routine******************************\
* WinTransparentDIBits
*
* Returns:
*   BOOL.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
WinTransparentDIBits(
                      HDC   hdcDst,
                      int   xDst,
                      int   yDst,
                      int   cxDst,
                      int   cyDst,
                      CONST VOID * lpBits,
                      CONST BITMAPINFO *lpBitsInfo,
                      UINT  iUsage,
                      int   xSrc,
                      int   ySrc,
                      int   cxSrc,
                      int   cySrc,
                      UINT  TransColor
                      )
{
    BOOL bRet = TRUE;
    DIBINFO DibInfoDst, DibInfoSrc;
    PDIBINFO pDibInfoDst, pDibInfoSrc;
    BOOL bReadable;

    //
    // parameter checking
    //

    if (cxDst < 0 || cyDst < 0)
    {
        WARNING("bad parameters\n");
        return (FALSE);
    }

    pDibInfoDst = &DibInfoDst;
    ZeroMemory (pDibInfoDst, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcDst, xDst, yDst, cxDst, cyDst, pDibInfoDst))
        return (FALSE);

    pDibInfoSrc = &DibInfoSrc;

    ZeroMemory (pDibInfoSrc, sizeof(DIBINFO));

    if (!bDIBInitDIBINFO ((PBITMAPINFO)lpBitsInfo, lpBits, xSrc, ySrc, cxSrc, cySrc, pDibInfoSrc))
        return (FALSE);

    pDibInfoSrc->iUsage = iUsage;

    bRet = bSetupBitmapInfos (pDibInfoDst, pDibInfoSrc);

    if (bRet)
    {
       // TransColor will only be index
       TransColor = TransColor & 0x00FF;

       bRet = bDIBGetSrcDIBits (pDibInfoDst, pDibInfoSrc, SOURCE_TRAN, TransColor);

       if (bRet)
       {
          bRet = bGetDstDIBits (pDibInfoDst, &bReadable, SOURCE_TRAN);

          if (bRet)
          {

             if (bReadable)
             {
                switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                {
                case 4:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4)
                     {
                         vTransparentS4D4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS4D8(pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                         vTransparentS4D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                         vTransparentS4D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {   //1
                         vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 8:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS8D8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                        vTransparentS8D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                        vTransparentS8D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                        vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {
                        //1, 4
                        vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                default:
                     WARNING ("BAD bitmap format\n");
                     bRet = FALSE;
                     goto CleanUp;
                     break;
                }

                //
                // if we have created a temp destination DIB, send the final result to destination
                //

                bRet = bSendDIBINFO (hdcDst, pDibInfoDst);
             }
             else
             {
                  //
                  // non-readable dest surface
                  //
                  vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
             }
          }
          else
          {
              WARNING ("GetSrcDIBits failed\n");
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING ("GetDstDIBits failed \n");
        bRet = FALSE;
    }

    //
    // clean up
    //
CleanUp:
    vCleanupDIBINFO (pDibInfoDst);
    vCleanupDIBINFO (pDibInfoSrc);

    return (bRet);
}
#endif

BOOL
TransparentBlt(
                 HDC   hdcDest,
                 int   DstX,
                 int   DstY,
                 int   DstCx,
                 int   DstCy,
                 HDC   hSrc,
                 int   SrcX,
                 int   SrcY,
                 int   SrcCx,
                 int   SrcCy,
                 UINT  Color
                 )
{
    BOOL bRet = FALSE;

    bRet = gpfnTransparentBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color
                      );

    return(bRet);
}


BOOL
TransparentDIBits(
    HDC         hdcDest,
    int         DstX,
    int         DstY,
    int         DstCx,
    int         DstCy,
    CONST VOID *lpBits,
    CONST BITMAPINFO *lpBitsInfo,
    UINT        iUsage,
    int         SrcX,
    int         SrcY,
    int         SrcCx,
    int         SrcCy,
    UINT        Color
    )
{
    BOOL bRet = FALSE;

    bRet = gpfnTransparentDIBits(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      lpBits,
                      lpBitsInfo,
                      iUsage,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color
                      );
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\dllinit.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

INT                gbCheckHandleLevel = 0;
OSVERSIONINFO    Win32VersionInformation;

PFNTRANSBLT gpfnTransparentBlt;
PFNTRANSDIB gpfnTransparentDIBits;
PFNGRFILL   gpfnGradientFill;
PFNALPHABLEND gpfnAlphaBlend;
PFNALPHADIB   gpfnAlphaDIB;
//PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC;

extern "C" {
BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext
    );
}


/*++

Routine Description:



Arguments



Return Value



--*/


BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS status = 0;
    INT i;
    BOOLEAN  fServer;
    PTEB pteb = NtCurrentTeb();
    BOOL bRet = TRUE;
    HMODULE hlib, hddrawlib;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // determine os version
        //

        Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);

        if (!GetVersionEx(&Win32VersionInformation))
        {
            //
            // default win95
            //

            Win32VersionInformation.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        }

        //
        // resolve API enrty points
        //

        #if !(_WIN32_WINNT >= 0x500)
        hlib=LoadLibrary (TEXT("gdi32.dll"));

        gpfnTransparentBlt = (PFNTRANSBLT)GetProcAddress (hlib, "GdiTransparentBlt");
        if (!gpfnTransparentBlt)
        {
            gpfnTransparentBlt = WinTransparentBlt;
        }

        gpfnTransparentDIBits = (PFNTRANSDIB)GetProcAddress (hlib, "GdiTransparentDIBits");
        if (!gpfnTransparentDIBits)
        {
            gpfnTransparentDIBits = WinTransparentDIBits;
        }

        gpfnGradientFill = (PFNGRFILL)GetProcAddress (hlib, "GdiGradientFill");
        if (!gpfnGradientFill)
        {
            gpfnGradientFill = WinGradientFill;
        }

        gpfnAlphaBlend = (PFNALPHABLEND)GetProcAddress (hlib, "GdiAlphaBlend");
        if (!gpfnAlphaBlend)
        {
            gpfnAlphaBlend = WinAlphaBlend;
        }

        gpfnAlphaDIB = (PFNALPHADIB)GetProcAddress (hlib, "GdiAlphaDIBBlend");
        if (!gpfnAlphaDIB)
        {
            gpfnAlphaDIB = WinAlphaDIBBlend;
        }

        FreeLibrary(hlib);

        //hddrawlib = GetModuleHandleA("ddraw");

        //pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(hddrawlib, "GetSurfaceFromDC");

        #else
            gpfnTransparentBlt = GdiTransparentBlt;
            gpfnTransparentDIBits = GdiTransparentDIBits;
            gpfnGradientFill = GdiGradientFill;
            gpfnAlphaBlend = GdiAlphaBlend;
            gpfnAlphaDIB = GdiAlphaDIBBlend;
        #endif

        #if 0
            gpfnAlphaDIB = WinAlphaDIBBlend;
            gpfnAlphaBlend = WinAlphaBlend;
            gpfnGradientFill = WinGradientFill;
            gpfnTransparentDIBits = WinTransparentDIBits;
            gpfnTransparentBlt = WinTransparentBlt;
        #endif

    case DLL_THREAD_ATTACH:
        break;

   case DLL_PROCESS_DETACH:
   case DLL_THREAD_DETACH:
        break;

    }

    return(bRet);

    pvDllHandle;
    pcontext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\dbgext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Created: 10-Sep-1993 08:36:42
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)                                                    \
try {                                                                           \
    char *pj = (char *)(src);                                                   \
/* if it is NTSD, don't want the trailing & */                                  \
    if ((lpExtensionApis->nSize < sizeof(WINDBG_EXTENSION_APIS)) &&             \
        (*pj == '&'))                                                           \
    {                                                                           \
        pj++;                                                                   \
    }                                                                           \
    *((ULONG *) &dst) = EvalExpression(pj);                                                   \
} except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?                    \
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {            \
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src); \
    return;                                                                     \
}

#define GetValue(dst,src)                                                       \
    GetAddress(dst,src)                                                         \
    if (TRUE || lpExtensionApis->nSize < sizeof(WINDBG_EXTENSION_APIS))                 \
    {                                                                           \
        move(dst,dst);                                                          \
    }

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)                                              \
try {                                                               \
    if (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))    \
    {                                                               \
        (*lpExtensionApis->lpReadProcessMemoryRoutine)(             \
             (DWORD) (src), &(dst), sizeof(dst), NULL);             \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), &(dst), sizeof(dst), NULL);\
    }                                                               \
                                                                    \
} except (EXCEPTION_EXECUTE_HANDLER) {                              \
    Print("exception in move()\n");                                 \
    return;                                                         \
}

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/

#define move2(dst, src,bytes)                                       \
try {                                                               \
    if (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))    \
    {                                                               \
        (*lpExtensionApis->lpReadProcessMemoryRoutine)(             \
             (DWORD) (src), (dst), (bytes), NULL);                  \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), (dst), (bytes), NULL);\
    }                                                               \
                                                                    \
} except (EXCEPTION_EXECUTE_HANDLER) {                              \
    Print("exception in move2()\n");                                \
    return;                                                         \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\image\tmp\trimesh.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

extern PFNGRFILL gpfnGradientFill;

#if !(_WIN32_WINNT >= 0x500)

/**************************************************************************\
*   gulDither32 - 4-4 dither matrix
*
*
* History:
*
*    1/31/1997 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG gulDither32[] =
{
    0x00000000,
    0x00008000,
    0x00002000,
    0x0000a000,

    0x0000c000,
    0x00004000,
    0x0000e000,
    0x00006000,

    0x00003000,
    0x0000b000,
    0x00001000,
    0x00009000,

    0x0000f000,
    0x00007000,
    0x0000d000,
    0x00005000
};

/******************************Public*Routine******************************\
* vFillTriDIBUnreadable
*
*   If a surface can't be read, draw triangle to a scan line, then call
*   SetDIBitsToDevice on each scan line
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vFillTriDIBUnreadable(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    LONG     cxClip = ptData->rcl.right - ptData->rcl.left;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    LONG     dAlpha = ptData->dAdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    ULONG    Alpha;
    BITMAPINFO bmi;

    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth           = cxClip;
    bmi.bmiHeader.biHeight          = 1;
    bmi.bmiHeader.biPlanes          = 1;
    bmi.bmiHeader.biBitCount        = 32;
    bmi.bmiHeader.biCompression     = BI_RGB;
    bmi.bmiHeader.biSizeImage       = 0;
    bmi.bmiHeader.biXPelsPerMeter   = 0;
    bmi.bmiHeader.biYPelsPerMeter   = 0;
    bmi.bmiHeader.biClrUsed         = 0;
    bmi.bmiHeader.biClrImportant    = 0;

    PBYTE pDst = (PBYTE)LOCALALLOC(4 * cxClip);

    if (pDst == NULL)
    {
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;
        LONG   xScanRight;
        LONG   xScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;
        Alpha = pEdge->Alpha;

        xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft  - ptData->rcl.left;
            pulDstScanRight   = (PULONG)pDst + xScanRight - ptData->rcl.left;

            //
            // skip span from left edge scan to left edge clip rect
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
                Alpha += dAlpha * GradientLeft;
            }

            //
            // fill span within clipping boundary
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                           ((Red   & 0x00ff0000)      ) |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
                Alpha += dAlpha;
            }

            //
            // write span to device
            //

            SetDIBitsToDevice(pDibInfo->hdc,
                              xScanLeft,
                              yScan,
                              xScanRight-xScanLeft,
                              1,
                              xScanLeft-ptData->rcl.left,
                              0,
                              0,
                              1,
                              pDst,
                              &bmi,
                              DIB_RGB_COLORS
                              );
        }

        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32BGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32BGRA(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    LONG     dAlpha = ptData->dAdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    ULONG    Alpha;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;
        Alpha = pEdge->Alpha;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX         = (PULONG)pDst + xScanLeft;
            pulDstScanRight = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
                Alpha += dAlpha * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                           ((Red   & 0x00ff0000)      ) |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
                Alpha += dAlpha;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // fill scan
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Red   & 0x00ff0000))       |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB24RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB24RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = (BYTE)((Blue  & 0x00ff0000) >> 16);
                *(pDstX+1) = (BYTE)((Green & 0x00ff0000) >> 16);
                *(pDstX+2) = (BYTE)((Red   & 0x00ff0000) >> 16);

                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_565(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PULONG   pulDither;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pusDstX           = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight   = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

                BYTE   iRed   = (BYTE)(((Red   >> 3) + ulDither) >> 16);
                BYTE   iGreen = (BYTE)(((Green >> 2) + ulDither) >> 16);
                BYTE   iBlue  = (BYTE)(((Blue  >> 3) + ulDither) >> 16);

                //
                // check for overflow
                //

                if (((iRed | iBlue) & 0xe0) || (iGreen & 0xc0))
                {
                    if (iRed & 0xe0)
                    {
                        iRed = 0x1f;
                    }

                    if (iBlue & 0xe0)
                    {
                        iBlue = 0x1f;
                    }

                    if (iGreen & 0xc0)
                    {
                        iGreen = 0x3f;
                    }
                }

                *pusDstX = rgb565(iRed,iGreen,iBlue);

                pusDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_555(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PULONG   pulDither;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pusDstX           = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight   = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

                BYTE   iRed   = (BYTE)(((Red   >> 3) + ulDither) >> 16);
                BYTE   iGreen = (BYTE)(((Green >> 3) + ulDither) >> 16);
                BYTE   iBlue  = (BYTE)(((Blue  >> 3) + ulDither) >> 16);

                //
                // check for overflow
                //

                if ((iRed | iBlue | iGreen) & 0xe0)
                {
                    if (iRed & 0xe0)
                    {
                        iRed = 0x1f;
                    }

                    if (iBlue & 0xe0)
                    {
                        iBlue = 0x1f;
                    }

                    if (iGreen & 0xe0)
                    {
                        iGreen = 0x1f;
                    }
                }

                *pusDstX = rgb555(iRed,iGreen,iBlue);

                pusDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB8(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pxlate = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    //
    // get/build rgb to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("vTriFillDIB8:Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // either use default palette or halftone palette dither
    //

    if (pxlate == gHalftoneColorXlate332)
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }


    //
    // scan from top to bottom of triangle scan lines
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight,pjDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + xScanLeft;
            pjDstScanRight    = pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // gradient fill scan with dither
            //

            while (pjDstX < pjDstScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + (((ULONG)pjDstX+xDitherOrg) & DITHER_8_MASK_X));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                iRed   = pSaturationTable[iRed   + jDitherMatrix];
                iGreen = pSaturationTable[iGreen + jDitherMatrix];
                iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                *pjDstX = jIndex;

                pjDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB4(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;
    PBYTE    pxlate           = pDibInfo->pxlate332;

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + (xScanLeft/2);
            iDstX             = xScanLeft & 1;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // fill scan line with dither
            //

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                iRed   = pSaturationTable[iRed   + jDitherMatrix];
                iGreen = pSaturationTable[iGreen + jDitherMatrix];
                iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write nibble
                //

                if (iDstX)
                {
                    iDstX = 0;
                    *pjDstX = (*pjDstX & 0xf0) | jIndex;
                    pjDstX++;
                }
                else
                {
                    *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
                    iDstX = 1;
                }

                xScanLeft++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB1(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pxlate        = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix = gDitherMatrix16x16Default;

    //
    // must have palette xlate
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        LONG    ScanRight;
        LONG    ScanLeft;
        LONG    xScan;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX         = pDst + (xScanLeft/8);
            iDstX          = xScanLeft & 7;

            //
            // skip clipped out portion of scan line whille
            // running color gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                //
                // add dither and saturate. 1bpp non-optimized
                //

                iRed   = iRed   + jDitherMatrix;

                if (iRed >= 255)
                {
                    iRed = 255;
                }
                else
                {
                    iRed = 0;
                }

                iGreen = iGreen + jDitherMatrix;

                if (iGreen >= 255)
                {
                    iGreen = 255;
                }
                else
                {
                    iGreen = 0;
                }

                iBlue  = iBlue  + jDitherMatrix;

                if (iBlue >= 255)
                {
                    iBlue = 255;
                }
                else
                {
                    iBlue = 0;
                }

                BYTE  jIndex;

                //
                // pjVector is known to be identity, so could make new macro for
                // palette_match_1 if perf ever an issue
                //

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write bit (!!! completely and totally non-optimized)
                //

                LONG iShift = 7 - iDstX;
                BYTE OrMask = 1 << iShift;
                BYTE AndMask  = ~OrMask;

                jIndex = jIndex << iShift;

                *pjDstX = (*pjDstX & AndMask) | jIndex;

                iDstX++;

                if (iDstX == 8)
                {
                    iDstX = 0;
                    pjDstX++;
                }

                xScanLeft++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* DIBTriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBTriangleMesh(
    HDC                hdc,
    PTRIVERTEX         pVertex,
    ULONG              nVertex,
    PGRADIENT_TRIANGLE pMesh,
    ULONG              nMesh,
    ULONG              ulMode,
    PRECTL             prclPhysExt,
    PDIBINFO           pDibInfo,
    PPOINTL            pptlDitherOrg,
    BOOL               bReadable
    )
{
    BOOL          bStatus = TRUE;
    RECTL         rclDst;
    RECTL         rclDstWk;
    ULONG         ulIndex;
    PTRIANGLEDATA ptData = NULL;
    PULONG        pulDIB = NULL;
    PFN_TRIFILL   pfnTriFill = NULL;

    pfnTriFill = pfnTriangleFillFunction(pDibInfo,bReadable);

    if (pfnTriFill == NULL)
    {
        WARNING("DIBTriangleMesh:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // fake up scale !!!
    //

    for (ulIndex=0;ulIndex<nVertex;ulIndex++)
    {
        pVertex[ulIndex].x = pVertex[ulIndex].x * 16;
        pVertex[ulIndex].y = pVertex[ulIndex].y * 16;
    }

    //
    // limit recorded triangle to clipped output
    //

    LONG   dxTri = prclPhysExt->right  - prclPhysExt->left;
    LONG   dyTri = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyTri > 0) && (dxTri > 0))
    {
        //
        // allocate structure to hold scan line data for all triangles
        // drawn during this call
        //

        ptData = (PTRIANGLEDATA)LOCALALLOC(sizeof(TRIANGLEDATA) + (dyTri-1) * sizeof(TRIEDGE));

        if (ptData != NULL)
        {
            //
            // draw each triangle
            //

            ptData->rcl      = *prclPhysExt;
            ptData->DrawMode = ulMode;
            ptData->ptDitherOrg = *pptlDitherOrg;

            for (ulIndex=0;ulIndex<nMesh;ulIndex++)
            {
                ULONG ulTri1 = pMesh[ulIndex].Vertex1;
                ULONG ulTri2 = pMesh[ulIndex].Vertex2;
                ULONG ulTri3 = pMesh[ulIndex].Vertex3;

                //
                // make sure index are in array
                //

                if (
                     (ulTri1 > nVertex) ||
                     (ulTri2 > nVertex) ||
                     (ulTri3 > nVertex)
                   )
                {
                    bStatus = FALSE;
                    break;
                }

                PTRIVERTEX pv0 = &pVertex[ulTri1];
                PTRIVERTEX pv1 = &pVertex[ulTri2];
                PTRIVERTEX pv2 = &pVertex[ulTri3];
                PTRIVERTEX pvt;

                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv1->y > pv2->y)
                {
                    SWAP_VERTEX(pv1,pv2,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv2->x > pv1->x)
                {
                    SWAP_VERTEX(pv1,pv2,pvt);
                }

                //
                // record triangle
                //

                bStatus = bCalculateTriangle(pv0,pv1,pv2,ptData);

                if (bStatus)
                {
                    //
                    // draw scan lines
                    //

                    (*pfnTriFill)(pDibInfo,ptData);
                }
            }
        }
        else
        {
            DbgPrint("DIBTriangleMesh:Failed alloc   \n");
            bStatus = FALSE;
        }

        //
        // cleanup
        //

        if (ptData)
        {
            LOCALFREE(ptData);
        }

        if (pulDIB)
        {
            LOCALFREE(pulDIB);
        }
    }

    SetMapMode(hdc,OldMode);

    return(bStatus);
}


/******************************Public*Routine******************************\
* vCalcMeshExtent
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalcMeshExtent(
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    RECTL       *prclExt
    )
{
    ULONG ulIndex;
    LONG xmin = MAX_INT;
    LONG xmax = MIN_INT;
    LONG ymin = MAX_INT;
    LONG ymax = MIN_INT;

    for (ulIndex = 0;ulIndex < nVertex;ulIndex++)
    {
        if (pVertex[ulIndex].x < xmin)
        {
            xmin = pVertex[ulIndex].x;
        }

        if (pVertex[ulIndex].x > xmax)
        {
            xmax = pVertex[ulIndex].x;
        }

        if (pVertex[ulIndex].y < ymin)
        {
            ymin = pVertex[ulIndex].y;
        }

        if (pVertex[ulIndex].y > ymax)
        {
            ymax = pVertex[ulIndex].y;
        }
    }

    prclExt->left   = xmin;
    prclExt->right  = xmax;
    prclExt->top    = ymin;
    prclExt->bottom = ymax;
}

/******************************Public*Routine******************************\
* bConvertVertexToPhysical
*   !!! slow way to convert.
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bConvertVertexToPhysical(
    HDC        hdc,
    PTRIVERTEX pVertex,
    ULONG      nVertex,
    PTRIVERTEX pPhysVert)
{
    ULONG ulIndex;

    for (ulIndex = 0;ulIndex<nVertex;ulIndex++)
    {
        POINT pt;

        pt.x = pVertex[ulIndex].x;
        pt.y = pVertex[ulIndex].y;

        if (!LPtoDP(hdc,&pt,1))
        {
            return(FALSE);
        }

        pPhysVert[ulIndex].x     = pt.x;
        pPhysVert[ulIndex].y     = pt.y;
        pPhysVert[ulIndex].Red   = pVertex[ulIndex].Red;
        pPhysVert[ulIndex].Green = pVertex[ulIndex].Green;
        pPhysVert[ulIndex].Blue  = pVertex[ulIndex].Blue;
        pPhysVert[ulIndex].Alpha = pVertex[ulIndex].Alpha;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bGetRectRegionFromDC
*
*   Use DCI to get the rectanglular region from a HDC. If the clipping is
*   more complex then 1 rectangle then return false.
*
* Arguments:
*
*   hdc     - destination DC
*   prcClip - Clip Rect, fill out if RECT clipping
*
* Return Value:
*
*   TRUE if clip rect was filled
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bGetRectRegionFromDC(
    HDC     hdc,
    PRECT   prcClip
    )
{
    //
    // visible region
    //

    BOOL      bRet = FALSE;
    DWORD     dwSize = 0;
    LPRGNDATA lpRgnData = NULL;

    //
    // init clip rect to NULL
    //

    dwSize = GetDCRegionData(hdc,dwSize,lpRgnData);

    if (dwSize)
    {
        lpRgnData = (LPRGNDATA)LOCALALLOC(dwSize);

        if (lpRgnData)
        {
            dwSize = GetDCRegionData(hdc,dwSize,lpRgnData);

            if (dwSize)
            {
                if (lpRgnData->rdh.nCount == 1)
                {
                    bRet   = TRUE;
                    *prcClip = lpRgnData->rdh.rcBound;
                }
            }
            LOCALFREE(lpRgnData);
        }
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* pfnTriangleFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo - information about destination surface
*
* Return Value:
*
*   PFN_TRIFILL - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_TRIFILL
pfnTriangleFillFunction(
    PDIBINFO pDibInfo,
    BOOL bReadable
    )
{
    PFN_TRIFILL pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (!bReadable)
    {
        pfnRet = vFillTriDIBUnreadable;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillTriDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillTriDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillTriDIB16_555;
       }
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 8)
    {
        pfnRet = vFillTriDIB8;
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 4)
    {
        pfnRet = vFillTriDIB4;
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 1)
    {
        pfnRet = vFillTriDIB1;
    }

    return(pfnRet);
}

/******************************Public*Routine******************************\
* WinTriangleMesh
*   win95 emulation
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinGradientFill(
    HDC         hdc,
    PTRIVERTEX  pLogVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{

    //
    // If the DC has a DIBSection selected, then draw direct to DIBSECTION.
    // else copy the rectangle needed from the dst to a 32bpp temp buffer,
    // draw into the buffer, then bitblt to dst.
    //
    // calc extents for drawing
    //
    // convert extents and points to physical
    //
    // if no global then
    //      create memory DC with dibsection of correct size
    // copy dst into dibsection (if can't make clipping)
    // draw physical into dibsection
    // copy dibsection to destination
    //

    PBYTE       pDIB;
    RECTL       rclPhysExt;
    RECTL       rclLogExt;
    PRECTL      prclClip;
    BOOL        bStatus = FALSE;
    PFN_TRIFILL pfnTriFill;
    DIBINFO     dibInfoDst;
    PALINFO     palDst;
    ULONG       ulDIBMode = SOURCE_GRADIENT_TRI;
    BOOL        bReadable;
    POINTL      ptlDitherOrg = {0,0};

    //
    // validate params and buffers
    //

    if (ulMode & (GRADIENT_FILL_RECT_H | GRADIENT_FILL_RECT_V))
    {
        //
        // if threre is only 1 rect, don't bother reading destination
        // bits
        //

        //
        // !!! make repeated calls in case nMesh != 1 to avoid
        // reading surface???
        //

        if (nMesh == 1)
        {
            ulDIBMode        = SOURCE_GRADIENT_RECT;
        }
    }
    else if (!(ulMode & GRADIENT_FILL_TRIANGLE))
    {
        WARNING("Invalid mode in call to GradientFill\n");
        // !!! set last error
        return(FALSE);
    }

    PTRIVERTEX  pPhysVertex = (PTRIVERTEX)LOCALALLOC(nVertex * sizeof(TRIVERTEX));

    if (pPhysVertex != NULL)
    {
        //
        // convert to physical
        //

        bStatus = bConvertVertexToPhysical(hdc,pLogVertex,nVertex,pPhysVertex);

        if (bStatus)
        {
            //
            // get logical extents
            //

            vCalcMeshExtent(pLogVertex,nVertex,&rclLogExt);

            //
            // convert to physical extents
            //

            rclPhysExt = rclLogExt;

            LPtoDP(hdc,(LPPOINT)&rclPhysExt,2);

            //
            // Set DIB information, convert to physical
            //

            bStatus = bInitDIBINFO(hdc,
                                rclLogExt.left,
                                rclLogExt.top,
                                rclLogExt.right  - rclLogExt.left,
                                rclLogExt.bottom - rclLogExt.top,
                                &dibInfoDst);

            if (bStatus)
            {
                //
                // get a destination DIB. For RECT Mode, the destination is not read.
                //

                bSetupBitmapInfos(&dibInfoDst, NULL);

                bStatus = bGetDstDIBits(&dibInfoDst, &bReadable,ulDIBMode);

                if (!((!bStatus) || (dibInfoDst.rclClipDC.left == dibInfoDst.rclClipDC.right)))
                {
                    ULONG ulIndex;

                    //
                    // if 1,4,8 format then allocate rgb332 to palette xlate
                    //

                    ULONG    BitCount = dibInfoDst.pbmi->bmiHeader.biBitCount;

                    if (BitCount <= 8)
                    {
                        ULONG    NumPalEntries;
                        PBYTE    pxlate = NULL;

                        switch (BitCount)
                        {
                        case 1:
                            NumPalEntries = 2;
                            break;

                        case 4:
                            NumPalEntries = 16;

                            if ((dibInfoDst.pbmi->bmiHeader.biClrUsed > 0) &&
                                (dibInfoDst.pbmi->bmiHeader.biClrUsed < 16))
                            {
                               NumPalEntries = dibInfoDst.pbmi->bmiHeader.biClrUsed;
                            }
                            break;
                        case 8:
                            NumPalEntries = 256;

                            if ((dibInfoDst.pbmi->bmiHeader.biClrUsed > 0) &&
                                (dibInfoDst.pbmi->bmiHeader.biClrUsed < 256))
                            {
                               NumPalEntries = dibInfoDst.pbmi->bmiHeader.biClrUsed;
                            }
                            break;
                        }

                        pxlate = pGenColorXform332((PULONG)(&dibInfoDst.pbmi->bmiColors[0]),NumPalEntries);

                        dibInfoDst.pxlate332 = pxlate;

                        if (pxlate == NULL)
                        {

                            WARNING("Failed to allocate xlate\n");
                            bStatus = FALSE;
                        }
                    }

                    if (bStatus)
                    {
                        if (dibInfoDst.hDIB)
                        {
                            //
                            // if temp surface has been allocated,
                            // subtract origin from points
                            //

                            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
                            {                                     
                                pPhysVertex[ulIndex].x -= dibInfoDst.ptlGradOffset.x;
                                pPhysVertex[ulIndex].y -= dibInfoDst.ptlGradOffset.y;
                            }

                            //
                            // clipping now in relation to temp DIB
                            //

                            rclPhysExt = dibInfoDst.rclDIB;

                            //
                            // adjust dither org
                            //

                            ptlDitherOrg.x = dibInfoDst.rclBounds.left;
                            ptlDitherOrg.y = dibInfoDst.rclBounds.top;
                        }
                        else
                        {
                            //
                            // clip extents to destination clip rect
                            //

                            if (rclPhysExt.left < dibInfoDst.rclClipDC.left)
                            {
                                rclPhysExt.left = dibInfoDst.rclClipDC.left;
                            }

                            if (rclPhysExt.right > dibInfoDst.rclClipDC.right)
                            {
                                rclPhysExt.right = dibInfoDst.rclClipDC.right;
                            }

                            if (rclPhysExt.top < dibInfoDst.rclClipDC.top)
                            {
                                rclPhysExt.top = dibInfoDst.rclClipDC.top;
                            }

                            if (rclPhysExt.bottom > dibInfoDst.rclClipDC.bottom)
                            {
                                rclPhysExt.bottom = dibInfoDst.rclClipDC.bottom;
                            }
                        }

                        if (
                             (ulMode &  (GRADIENT_FILL_RECT_H | GRADIENT_FILL_RECT_V))
                           )
                        {
                            //
                            // draw gradient rectangles
                            //

                            bStatus = DIBGradientRect(hdc,pPhysVertex,nVertex,(PGRADIENT_RECT)pMesh,nMesh,ulMode,&rclPhysExt,&dibInfoDst,&ptlDitherOrg);
                        }
                        else if (ulMode == GRADIENT_FILL_TRIANGLE)
                        {
                            //
                            // draw triangles
                            //

                            bStatus = DIBTriangleMesh(hdc,pPhysVertex,nVertex,(PGRADIENT_TRIANGLE)pMesh,nMesh,ulMode,&rclPhysExt,&dibInfoDst,&ptlDitherOrg,bReadable);
                        }

                        //
                        // copy output to final dest if needed
                        //

                        if (bStatus && bReadable)
                        {
                            bStatus = bSendDIBINFO (hdc,&dibInfoDst);
                        }
                    }
                }
            }

            vCleanupDIBINFO(&dibInfoDst);
        }

        LOCALFREE(pPhysVertex);
    }
    else
    {
        bStatus = FALSE;
    }

    //
    //
    //

    return(bStatus);
}

#endif

/******************************Public*Routine******************************\
* TriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GradientFill(
    HDC         hdc,
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{
    BOOL bRet;

    bRet = gpfnGradientFill(hdc,
                            pVertex,
                            nVertex,
                            pMesh,
                            nMesh,
                            ulMode
                            );
    return(bRet);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\exehdr.h ===
/******************************Module*Header*******************************\
* Module Name: exehdr.h
*
* (Brief description)
*
* Created: 08-May-1991 13:42:33
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*  Description
*
*      Data structure definitions for the DOS 4.0/Windows 2.0
*      executable file format.
*
*  Modification History
*
*      84/08/17        Pete Stewart    Initial version
*      84/10/17        Pete Stewart    Changed some constants to match OMF
*      84/10/23        Pete Stewart    Updates to match .EXE format revision
*      84/11/20        Pete Stewart    Substantial .EXE format revision
*      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
*      85/01/10        Steve Wood      Added resource definitions
*      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
*      85/03/07        Pete Stewart    Added movable entry count
*      85/04/01        Pete Stewart    Segment alignment field, error bit
*****
*	90/11/28   Lindsay Harris: copied & trimmed from DOS version
*****
*  Wed 08-May-1991 -by- Bodin Dresevic [BodinD]
* update:
*   made changes necessary to make the code portable, offsets et.c
*
\**************************************************************************/



#define EMAGIC          0x5A4D          // Old magic number
#define ENEWEXE         sizeof(struct exe_hdr)
                                        // Value of E_LFARLC for new .EXEs
#define ENEWHDR         0x003C          // Offset in old hdr. of ptr. to new
#define ERESWDS         0x0010          // No. of reserved words in header
#define ECP             0x0004          // Offset in struct of E_CP
#define ECBLP           0x0002          // Offset in struct of E_CBLP
#define EMINALLOC       0x000A          // Offset in struct of E_MINALLOC

#ifdef DEBUGOFFSETS

// this is the original definition of the structure that I used to compute
// the offsets given below, assuming that the 16 bit compiler puts no padding
// between the fields. It turns out that this assumption is correct
// so that when the file is written to the disk the fields are indeed
// laid out at the offsets computed below

typedef  struct exe_hdr                          // DOS 1, 2, 3 .EXE header
{
    unsigned short      e_magic;        // Magic number
    unsigned short      e_cblp;         // Bytes on last page of file
    unsigned short      e_cp;           // Pages in file
    unsigned short      e_crlc;         // Relocations
    unsigned short      e_cparhdr;      // Size of header in paragraphs
    unsigned short      e_minalloc;     // Minimum extra paragraphs needed
    unsigned short      e_maxalloc;     // Maximum extra paragraphs needed
    unsigned short      e_ss;           // Initial (relative) SS value
    unsigned short      e_sp;           // Initial SP value
    unsigned short      e_csum;         // Checksum
    unsigned short      e_ip;           // Initial IP value
    unsigned short      e_cs;           // Initial (relative) CS value
    unsigned short      e_lfarlc;       // File address of relocation table
    unsigned short      e_ovno;         // Overlay number
    unsigned short      e_res[ERESWDS]; // Reserved words
    long                e_lfanew;       // File address of new exe header
} EXE_HDR;

#endif // DEBUGOFFSETS

// the only structure fileds used by our code are

//    unsigned short      e_magic;        // Magic number
//    long                e_lfanew;       // File address of new exe header

// these are offsets how the fiels of this structure are laid out in the file

#define OFF_e_magic           0     // unsigned short Magic number
#define OFF_e_cblp            2     // unsigned short Bytes on last page of file
#define OFF_e_cp              4     // unsigned short Pages in file
#define OFF_e_crlc            6     // unsigned short Relocations
#define OFF_e_cparhdr         8     // unsigned short Size of header in paragraphs
#define OFF_e_minalloc        10    // unsigned short Minimum extra paragraphs needed
#define OFF_e_maxalloc        12    // unsigned short Maximum extra paragraphs needed
#define OFF_e_ss              14    // unsigned short Initial (relative) SS value
#define OFF_e_sp              16    // unsigned short Initial SP value
#define OFF_e_csum            18    // unsigned short Checksum
#define OFF_e_ip              20    // unsigned short Initial IP value
#define OFF_e_cs              22    // unsigned short Initial (relative) CS value
#define OFF_e_lfarlc          24    // unsigned short File address of relocation table
#define OFF_e_ovno            26    // unsigned short Overlay number
#define OFF_e_res             28    // unsigned short Reserved words, 16 of then 60 = 28 + 32
#define OFF_e_lfanew          60    // long           File address of new exe header

#define CJ_EXE_HDR            64

// ************** stuff associated with new exe hdr ********************

#define NEMAGIC         0x454E          // New magic number
#define NERESBYTES      0


#ifdef DEBUGOFFSETS


typedef  struct new_exe                          // New .EXE header
{
    unsigned short int  ne_magic;       // Magic number NE_MAGIC
    char                ne_ver;         // Version number
    char                ne_rev;         // Revision number
    unsigned short int  ne_enttab;      // Offset of Entry Table
    unsigned short int  ne_cbenttab;    // Number of bytes in Entry Table
    long                ne_crc;         // Checksum of whole file
    unsigned short int  ne_flags;       // Flag word
    unsigned short int  ne_autodata;    // Automatic data segment number
    unsigned short int  ne_heap;        // Initial heap allocation
    unsigned short int  ne_stack;       // Initial stack allocation
    long                ne_csip;        // Initial CS:IP setting
    long                ne_sssp;        // Initial SS:SP setting
    unsigned short int  ne_cseg;        // Count of file segments
    unsigned short int  ne_cmod;        // Entries in Module Reference Table
    unsigned short int  ne_cbnrestab;   // Size of non-resident name table
    unsigned short int  ne_segtab;      // Offset of Segment Table
    unsigned short int  ne_rsrctab;     // Offset of Resource Table
    unsigned short int  ne_restab;      // Offset of resident name table
    unsigned short int  ne_modtab;      // Offset of Module Reference Table
    unsigned short int  ne_imptab;      // Offset of Imported Names Table
    long                ne_nrestab;     // Offset of Non-resident Names Table
    unsigned short int  ne_cmovent;     // Count of movable entries
    unsigned short int  ne_align;       // Segment alignment shift count
    unsigned short int  ne_cres;        // Count of resource segments
    unsigned char	ne_exetyp;	// Target Operating system
    unsigned char	ne_flagsothers;	// Other .EXE flags
    unsigned short int  ne_pretthunks;  // offset to return thunks
    unsigned short int  ne_psegrefbytes;// offset to segment ref. bytes
    unsigned short int  ne_swaparea;    // Minimum code swap area size
    unsigned short int  ne_expver;      // Expected Windows version number
} NEW_EXE;

#endif // DEBUGOFFSETS


// the only structure fileds used by our code are

//    unsigned short int  ne_magic;       // Magic number NE_MAGIC
//    unsigned short int  ne_rsrctab;     // Offset of Resource Table
//    long                ne_restab;      // Offset of resident Names Table

// offsets from beg of the structure as the data is laid out on the disk

#define OFF_ne_magic        0     // unsigned short Magic number NE_MAGIC
#define OFF_ne_ver          2     // char           Version number
#define OFF_ne_rev          3     // char           Revision number
#define OFF_ne_enttab       4     // unsigned short Offset of Entry Table
#define OFF_ne_cbenttab     6     // unsigned short Number of bytes in Entry Table
#define OFF_ne_crc          8     // long           Checksum of whole file
#define OFF_ne_flags        12    // unsigned short Flag word
#define OFF_ne_autodata     14    // unsigned short Automatic data segment number
#define OFF_ne_heap         16    // unsigned short Initial heap allocation
#define OFF_ne_stack        18    // unsigned short Initial stack allocation
#define OFF_ne_csip         20    // long           Initial CS:IP setting
#define OFF_ne_sssp         24    // long           Initial SS:SP setting
#define OFF_ne_cseg         28    // unsigned short Count of file segments
#define OFF_ne_cmod         30    // unsigned short Entries in Module Reference Table
#define OFF_ne_cbnrestab    32    // unsigned short Size of non-resident name table
#define OFF_ne_segtab       34    // unsigned short Offset of Segment Table
#define OFF_ne_rsrctab      36    // unsigned short Offset of Resource Table
#define OFF_ne_restab       38    // unsigned short Offset of resident name table
#define OFF_ne_modtab       40    // unsigned short Offset of Module Reference Table
#define OFF_ne_imptab       42    // unsigned short Offset of Imported Names Table
#define OFF_ne_nrestab      44    // long           Offset of Non-resident Names Table
#define OFF_ne_cmovent      48    // unsigned short Count of movable entries
#define OFF_ne_align        50    // unsigned short Segment alignment shift count
#define OFF_ne_cres         52    // unsigned short Count of resource segments
#define OFF_ne_exetyp	    54    // unsigned char  Target Operating system
#define OFF_ne_flagsothers  55    // unsigned char  Other .EXE flags
#define OFF_ne_pretthunks   56    // unsigned short offset to return thunks
#define OFF_ne_psegrefbytes 58    // unsigned short offset to segment ref. bytes
#define OFF_ne_swaparea     60    // unsigned short Minimum code swap area size
#define OFF_ne_expver       62    // unsigned short Expected Windows version number


#define CJ_NEW_EXE          64

// Resource type or name string

typedef  struct rsrc_string
{
    char rs_len;            // number of bytes in string
    char rs_string[ 1 ];    // text of string
} RSRC_STRING;


// Resource type information block

#ifdef DEBUGOFFSETS

typedef struct rsrc_typeinfo
{
    unsigned short rt_id;
    unsigned short rt_nres;
    long           rt_proc;
} RSRC_TYPEINFO;

#endif // DEBUGOFFSETS

#define OFF_rt_id     0  //    unsigned short
#define OFF_rt_nres   2  //    unsigned short
#define OFF_rt_proc   4  //    long

#define CJ_TYPEINFO   8

// the only rt_id that we are interested in is the
// one for *.fnt files, RT_FNT, RT_FDIR for font directories
// and RT_PSZ, string resource with a *.ttf file name in an
// fot file. RT_DONTKNOW exhists in fon files but I do not
// know what it corresponds to

#define RT_FDIR     0x8007
#define RT_FNT      0X8008
#define RT_DONTKNOW 0x800h
#define RT_PSZ      0X80CC

// rn_id's that are allowed for certain types of rt_id's
// as I have found them in fot files [bodind]

#define RN_ID_FDIR  0x002c
#define RN_ID_PSZ   0x8001


#ifdef DEBUGOFFSETS

// Resource name information block

typedef struct rsrc_nameinfo
{
// The following two fields must be shifted left by the value of
// the rs_align field to compute their actual value.  This allows
// resources to be larger than 64k, but they do not need to be
// aligned on 512 byte boundaries, the way segments are

    unsigned short rn_offset;   // file offset to resource data
    unsigned short rn_length;   // length of resource data
    unsigned short rn_flags;    // resource flags
    unsigned short rn_id;       // resource name id
    unsigned short rn_handle;   // If loaded, then global handle
    unsigned short rn_usage;    // Initially zero.  Number of times
                                // the handle for this resource has
                                // been given out
} RSRC_NAMEINFO;

#endif // DEBUGOFFSETS


#define OFF_rn_offset   0        //  unsigned short
#define OFF_rn_length   2        //  unsigned short
#define OFF_rn_flags    4        //  unsigned short
#define OFF_rn_id       6        //  unsigned short
#define OFF_rn_handle   8        //  unsigned short
#define OFF_rn_usage    10       //  unsigned short

#define CJ_NAMEINFO   12


#define RSORDID     0x8000      // if high bit of ID set then integer id
                                // otherwise ID is offset of string from
                                // the beginning of the resource table

                                // Ideally these are the same as the
                                // corresponding segment flags
#define RNMOVE      0x0010      // Moveable resource
#define RNPURE      0x0020      // Pure (read-only) resource
#define RNPRELOAD   0x0040      // Preloaded resource
#define RNDISCARD   0x1000      // Discard bit for resource

#define RNLOADED    0x0004      // True if handler proc return handle

#ifdef DEBUGOFFSETS

// Resource table

typedef struct new_rsrc
{
    unsigned short rs_align;    // alignment shift count for resources
    RSRC_TYPEINFO  rs_typeinfo; // Really an array of these
} NEW_RSRC;

#endif // DEBUGOFFSETS

// Target operating systems:  Possible values of ne_exetyp field

#define NE_UNKNOWN	0	// Unknown (any "new-format" OS)
#define NE_OS2		1	// Microsoft/IBM OS/2 (default)
#define NE_WINDOWS	2	// Microsoft Windows
#define NE_DOS4 	3	// Microsoft MS-DOS 4.x
#define NE_DEV386	4	// Microsoft Windows 386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\hmgshare.h ===
/******************************Module*Header*******************************\
* Module Name: hmgshare.h
*
*   Define shared dc attributes
*
* Created: 13-Apr-1995
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

/******************************WOW64***NOTE********************************\
* Note: Win32k Memory shared with User-Mode and Wow64
*
* For Wow64 (Win32 apps on Win64) we build a 32-bit version
* of user32.dll & gdi32.dll which can run against the 64-bit kernel
* with no changes to the 64-bit kernel code.
*
* For the 32 on 64 bit dlls all data structures which are shared with
* win32k must be 64-bit. These data structures include the shared
* sections, as well as the GDI TEB Batch.
* These shared data structures are now declared so that they can be
* built as 32 bit in a 32 bit dll, 64 bit in a 64 bit dll, and now
* 64 bit in a 32 bit dll.
*
* The following rules should be followed when declaring
* shared data structures:
*
*     Pointers in shared data structures use the KPTR_MODIFIER in their
*     declaration.
*
*     Handles in shared data structures are declared KHxxx.
*
*     xxx_PTR changes to KERNEL_xxx_PTR.
*
*     Pointers to basic types are declared as KPxxx;
*
* Also on Wow64 every thread has both a 32-bit TEB and a 64-bit TEB.
* GetCurrentTeb() returns the current 32-bit TEB while the kernel
* will allways reference the 64-bit TEB.
*
* All client side references to shared data in the TEB should use
* the new GetCurrentTebShared() macro which returns the 64-bit TEB
* for Wow64 builds and returns GetCurrentTeb() for regular builds.
* The exception to this rule is LastErrorValue, which should allways
* be referenced through GetCurrentTeb().
*
* Ex:
*
* DECLARE_HANDLE(HFOO);
*
* typedef struct _MY_STRUCT * KPTR_MODIFIER   PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT *   pNext;
*     PMPTR                     pmptr;
*     HFOO                      hFoo;
*     UINT_PTR                  cb;
*     PBYTE                     pb;
*     PVOID                     pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
*
* Changes to:
*
*
* DECLARE_HANDLE(HFOO);
* DECLARE_KHANDLE(HFOO);
*
* typedef struct _MY_STRUCT *PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT * KPTR_MODIFIER   pNext;
*     PMPTR                     pmptr;
*     KHFOO                     hFoo;
*     KERNEL_UINT_PTR           cb;
*     KPBYTE                    pb;
*     KERNEL_PVOID              pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
\***************************************************************************/

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#include <w32wow64.h>

//Sundown: offsetof generates truncation warnings in 64bit environment
#undef offsetof
#define offsetof(c,f)      FIELD_OFFSET(c,f)

/*********************************Structure********************************\
*
* RGNATTR
*
* Description:
*
*   As an accelerator, this rectangular region is kept in the DC and
*   represents either a NULL region, a rectangular region, or hte bounding
*   box of a complex region. This can be used for a trivial reject clip test.
*
* Fields:
*
*   Flags  - state flags
*       NULLREGION      - drawing is allowed anywhere, no trivial clip
*       SIMPLEREGION    - Rect is the clip region
*       COMPLEXREGION   - Rect is the bounding box of a complex clip region
*       ERROR           - this information may not be used
*
*   LRFlags             - valid and dirty flags
*
*       Rect            - clip rectangle or bounding rectangle when in use
*
\**************************************************************************/

#endif  // GDIFLAGS_ONLY used for gdikdx

#define RREGION_INVALID ERROR

//
// ExtSelectClipRgn iMode extra flag for batching
//

#define REGION_NULL_HRGN 0X8000000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _RGNATTR
{
    ULONG  AttrFlags;
    ULONG  Flags;
    RECTL  Rect;
} RGNATTR,*PRGNATTR;

/*******************************STRUCTURE**********************************\
* BRUSHATTR
*
* Fields:
*
*   lbColor - Color from CreateSolidBrush
*   lflag   - Brush operation flags
*
*      CACHED             - Set only when brush is cached on PEB
*      TO_BE_DELETED      - Set only after DelteteBrush Called in kernel
*                           when reference count of brush > 1, this will
*                           cause the brush to be deleted via lazy delete
*                           when it is selected out later.
*      NEW_COLOR          - Set when color changes (retrieve cached brush)
*      ATTR_CANT_SELECT   - Set when user calls DeleteObject(hbrush),
*                           brush is marked so can't be seleced in user
*                           mode. Not deleted until kernel mode DeleteBrush.
*                           This is not currently implemented.
*
* History:
*
*    6-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

typedef struct _BRUSHATTR
{
    ULONG     AttrFlags;
    COLORREF  lbColor;
} BRUSHATTR,*PBRUSHATTR;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// Common flags for dealing with RGN/BRUSH ATTR memory
//

#define ATTR_CACHED             0x00000001
#define ATTR_TO_BE_DELETED      0x00000002
#define ATTR_NEW_COLOR          0x00000004
#define ATTR_CANT_SELECT        0x00000008
#define ATTR_RGN_VALID          0x00000010
#define ATTR_RGN_DIRTY          0x00000020

#ifndef GDIFLAGS_ONLY   // used for gdikdx

//
// Define a union so these objects can be managed together
//

typedef union _OBJECTATTR
{
    RGNATTR             Rgnattr;
    BRUSHATTR           Brushattr;
}OBJECTATTR,*POBJECTATTR;


/**************************************************************************\
 *
 * XFORM related structures and macros
 *
\**************************************************************************/

//
// These types are used to get things right when C code is passing C++
// defined transform data around.
//

typedef struct _MATRIX_S
{
    EFLOAT_S    efM11;
    EFLOAT_S    efM12;
    EFLOAT_S    efM21;
    EFLOAT_S    efM22;
    EFLOAT_S    efDx;
    EFLOAT_S    efDy;
    FIX         fxDx;
    FIX         fxDy;
    FLONG       flAccel;
} MATRIX_S;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// status and dirty flags
//

#define DIRTY_FILL              0x00000001
#define DIRTY_LINE              0x00000002
#define DIRTY_TEXT              0x00000004
#define DIRTY_BACKGROUND        0x00000008
#define DIRTY_CHARSET           0x00000010
#define SLOW_WIDTHS             0x00000020
#define DC_CACHED_TM_VALID      0x00000040
#define DISPLAY_DC              0x00000080
#define DIRTY_PTLCURRENT        0x00000100
#define DIRTY_PTFXCURRENT       0x00000200
#define DIRTY_STYLESTATE        0x00000400
#define DC_PLAYMETAFILE         0x00000800
#define DC_BRUSH_DIRTY          0x00001000      // cached brush
#define DC_PEN_DIRTY            0x00002000
#define DC_DIBSECTION           0x00004000
#define DC_LAST_CLIPRGN_VALID   0x00008000
#define DC_PRIMARY_DISPLAY      0x00010000
#define DIRTY_COLORTRANSFORM    0x00020000
#define ICM_BRUSH_TRANSLATED    0x00040000
#define ICM_PEN_TRANSLATED      0x00080000
#define DIRTY_COLORSPACE        0x00100000
#define BATCHED_DRAWING         0x00200000
#define BATCHED_TEXT            0x00400000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define CLEAR_CACHED_TEXT(pdcattr)  (pdcattr->ulDirty_ &= ~(SLOW_WIDTHS))


#define DIRTY_BRUSHES  (DIRTY_FILL+DIRTY_LINE+DIRTY_TEXT+DIRTY_BACKGROUND)


#define USER_XFORM_DIRTY(pdcattr) (pdcattr->flXform & (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED | WORLD_XFORM_CHANGED))

#endif  // GDIFLAGS_ONLY used for gdikdx


/**************************************************************************\
 *
 * ICM related structures and macros
 *
\**************************************************************************/

//
// ICM flags
//
// DC_ATTR.lIcmMode
//
// 0x0 000 0 0 00
//   |   | | |  + Current ICM Mode  (kernel/user)
//   |   | | + Requested ICM Mode   (kernel/user)
//   |   | + ICM Mode context       (user only)
//   |   + not used
//   + Destination color type       (kernel/user)

#define DC_ICM_USERMODE_FLAG         0x0000F000

//
// Current ICM mode flags.
//
#define DC_ICM_OFF                   0x00000000
#define DC_ICM_HOST                  0x00000001
#define DC_ICM_DEVICE                0x00000002
#define DC_ICM_OUTSIDEDC             0x00000004
#define DC_ICM_METAFILING_ON         0x00000008
#define DC_ICM_LAZY_CORRECTION       0x00000010 // alt mode (preserved through icm mode change)
#define DC_ICM_DEVICE_CALIBRATE      0x00000020 // alt mode (preserved through icm mode change)
#define DC_ICM_MODE_MASK             0x000000FF
#define DC_ICM_ALT_MODE_MASK         0x000000F0

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define ICM_MODE(x)         ((x) & DC_ICM_MODE_MASK)
#define ICM_ALT_MODE(x)     ((x) & DC_ICM_ALT_MODE_MASK)

#define IS_ICM_DEVICE(x)    ((x) & DC_ICM_DEVICE)
#define IS_ICM_HOST(x)      ((x) & DC_ICM_HOST)
#define IS_ICM_INSIDEDC(x)  ((x) & (DC_ICM_DEVICE|DC_ICM_HOST))
#define IS_ICM_OUTSIDEDC(x) ((x) & DC_ICM_OUTSIDEDC)
#define IS_ICM_ON(x)        ((x) & (DC_ICM_DEVICE|DC_ICM_HOST|DC_ICM_OUTSIDEDC))

#define IS_ICM_METAFILING_ON(x)    ((x) & DC_ICM_METAFILING_ON)
#define IS_ICM_LAZY_CORRECTION(x)  ((x) & DC_ICM_LAZY_CORRECTION)
#define IS_ICM_DEVICE_CALIBRATE(x) ((x) & DC_ICM_DEVICE_CALIBRATE)

#endif  // GDIFLAGS_ONLY used for gdikdx
//
// Request ICM mode flags
//
#define REQ_ICM_OFF                  0x00000000
#define REQ_ICM_HOST                 0x00000100
#define REQ_ICM_DEVICE               0x00000200
#define REQ_ICM_OUTSIDEDC            0x00000400

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define REQ_ICM_MODE(x)       ((x) & 0x00000F00)

#define IS_ICM_DEVICE_REQUESTED(x)  ((x) & REQ_ICM_DEVICE)

//
// Convert Request mode to current ICM mode flags.
//
#define ICM_REQ_TO_MODE(x) ((REQ_ICM_MODE((x))) >> 8)

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// Context mode for ICM.
//
#define CTX_ICM_HOST                 0x00001000 // Host ICM
#define CTX_ICM_DEVICE               0x00002000 // Device ICM
#define CTX_ICM_METAFILING_OUTSIDEDC 0x00004000 // Metfiling outside DC ICM mode
#define CTX_ICM_PROOFING             0x00008000 // Proofing mode

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define SET_HOST_ICM_DEVMODE(x)     ((x) |= CTX_ICM_HOST)
#define SET_DEVICE_ICM_DEVMODE(x)   ((x) |= CTX_ICM_DEVICE)
#define SET_ICM_PROOFING(x)         ((x) |= CTX_ICM_PROOFING)

#define CLEAR_ICM_PROOFING(x)       ((x) &= ~CTX_ICM_PROOFING)

#define IS_DEVICE_ICM_DEVMODE(x)    ((x) & CTX_ICM_DEVICE)
#define IS_ICM_PROOFING(x)          ((x) & CTX_ICM_PROOFING)

#endif  // GDIFLAGS_ONLY used for gdikdx
//
// Destination Color Type
//
#define DC_ICM_CMYK_COLOR            0x10000000
#define DC_ICM_RGB_COLOR             0x20000000
#define DC_ICM_COLORTYPE_MASK        0xF0000000


#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define DC_ICM_32BITS_COLOR         (DC_ICM_CMYK_COLOR)

#define IS_32BITS_COLOR(x) ((x) & DC_ICM_32BITS_COLOR)
#define IS_CMYK_COLOR(x)   ((x) & DC_ICM_CMYK_COLOR)

#define GET_COLORTYPE(x)   ((x) & DC_ICM_COLORTYPE_MASK)
#define CLEAR_COLORTYPE(x) ((x) &= ~DC_ICM_COLORTYPE_MASK)

/******************************Structure***********************************\
*
* DC_ATTR: This structure provides a common DC area visible both by in kernel
* and user mode. Since elements in the DC_ATTR are visible and modifiable
* in user-mode, data that must be kept safe must be stored in the kernel
* private DC structure.
*
\**************************************************************************/

typedef struct _DC_ATTR
{
    //
    // local dc info
    //

    KERNEL_PVOID pvLDC;

    //
    // General Purpose Dirty Flags for brushes, fonts, etc.
    //

    ULONG       ulDirty_;

    //
    // brush handle selected into DCATTR, not neccessarily selected
    // into DC
    //

    KHANDLE     hbrush;
    KHANDLE     hpen;

    //
    // *** Attribute Bundles ***
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crBackgroundClr;    // Set/GetBkColor
    ULONG       ulBackgroundClr;    // Set/GetBkColor client attr
    COLORREF    crForegroundClr;    // Set/GetTextColor
    ULONG       ulForegroundClr;    // Set/GetTextColor client attr

    //
    // *** DC Brush color
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crDCBrushClr;       // Set/GetDCBrushColor client attr
    ULONG       ulDCBrushClr;       // Set/GetDCBrushColor client attr
    COLORREF    crDCPenClr;         // Set/GetDCPenColor
    ULONG       ulDCPenClr;         // Set/GetDCPenColor client attr

    //
    // *** Misc. Attrs.
    //

    DWORD       iCS_CP;             // LOWORD: code page HIWORD charset
    int         iGraphicsMode;      // Set/GetGraphicsMode
    BYTE        jROP2;              // Set/GetROP2
    BYTE        jBkMode;            // TRANSPARENT/OPAQUE
    BYTE        jFillMode;          // ALTERNATE/WINDING
    BYTE        jStretchBltMode;    // BLACKONWHITE/WHITEONBLACK/
                                    //   COLORONCOLOR/HALFTONE
    POINTL      ptlCurrent;         // Current position in logical coordinates
                                    //   (invalid if DIRTY_PTLCURRENT set)
    POINTL      ptfxCurrent;        // Current position in device coordinates
                                    //   (invalid if DIRTY_PTFXCURRENT set)

    //
    // original values set by app
    //

    LONG        lBkMode;
    LONG        lFillMode;
    LONG        lStretchBltMode;

    FLONG       flFontMapper;           // Font mapper flags

    //
    // *** ICM attributes
    //

    LONG             lIcmMode;         // Currnt ICM mode (DC_ICM_xxxx)
    KHANDLE          hcmXform;         // Handle of Current Color Transform
    KHCOLORSPACE     hColorSpace;      // Handle of Source Color Space
    KERNEL_ULONG_PTR dwDIBColorSpace;  // Identifier of DIB Color Space Data (when DIB selected)
                                       // Sundown: dwDIBColorSpace actually takes a pointer in,
                                       //          change from DWORD to ULONG_PTR
    COLORREF         IcmBrushColor;    // ICM-ed color for the brush selected in this DCATTR (Solid or Hatch)
    COLORREF         IcmPenColor;      // ICM-ed color for the pen selected in this DCATTR
    KERNEL_PVOID     pvICM;            // Pointer to client-side ICM information

    //
    // *** Text attributes
    //

    FLONG       flTextAlign;
    LONG        lTextAlign;
    LONG        lTextExtra;         // Inter-character spacing
    LONG        lRelAbs;            // Moved over from client side
    LONG        lBreakExtra;
    LONG        cBreak;

    KHANDLE     hlfntNew;          // Log font selected into DC

    //
    // Transform data.
    //

    MATRIX_S    mxWtoD;                 // World to Device Transform.
    MATRIX_S    mxDtoW;                 // Device to World.
    MATRIX_S    mxWtoP;                 // World transform
    EFLOAT_S    efM11PtoD;              // efM11 of the Page transform
    EFLOAT_S    efM22PtoD;              // efM22 of the Page transform
    EFLOAT_S    efDxPtoD;               // efDx of the Page transform
    EFLOAT_S    efDyPtoD;               // efDy of the Page transform
    INT         iMapMode;               // Map mode
    DWORD       dwLayout;               // Layout orientation bits.
    LONG        lWindowOrgx;            // The logical x window origin.
    POINTL      ptlWindowOrg;           // Window origin.
    SIZEL       szlWindowExt;           // Window extents.
    POINTL      ptlViewportOrg;         // Viewport origin.
    SIZEL       szlViewportExt;         // Viewport extents.
    FLONG       flXform;                // Flags for transform component.
    SIZEL       szlVirtualDevicePixel;  // Virtual device size in pels.
    SIZEL       szlVirtualDeviceMm;     // Virtual device size in mm's.
    SIZEL       szlVirtualDevice;       // Virtual device size

    POINTL      ptlBrushOrigin;         // Alignment origin for brushes

    //
    // dc regions
    //

    RGNATTR     VisRectRegion;

} DC_ATTR,*PDC_ATTR;


//
// conditional system definitions
//

#if !defined(_NTOSP_) && !defined(_USERKDX_)
typedef struct _W32THREAD * KPTR_MODIFIER PW32THREAD;
typedef ULONG W32PID;
DECLARE_HANDLE(HOBJ);
DECLARE_KHANDLE(HOBJ);
#endif

/*****************************Struct***************************************\
*
* BASEOBJECT
*
* Description:
*
*   Each GDI object has a BASEOBJECT at the beggining of the object. This
*   enables fast references to the handle and back to the entry.
*
* Fields:
*
*   hHmgr           - object handle
*   ulShareCount    - the shared reference count on the object
*   cExclusiveLock  - object exclusive lock count
*   BaseFlags       - flags representing state of underlying memory
*   tid             - thread id of exclusive lock owner
*
* Note:
*
*   Most of the BASEOBJECT represents state logically associated with the
*   object.  When objects are swapped (for example, when doing a realloc
*   to grow the object), the BASEOBJECT is swapped to preserve the handle
*   and locking information.
*
*   However, the BaseFlags field was added as an optimization to allow
*   allocation from a "lookaside" list of preallocated objects.  The
*   BaseFlags field is metadata associated with the memory containing
*   an object; it is not associated with the object itself.
*
*   Current BASEOBJECT swapping code "unswaps" the BaseFlags so that it
*   always remains associated with the memory, not the object.
*
*   If flags are added to BaseFlags, they must not represent object state.
*   If it is necessary to add such flags, the BaseFlags field could be
*   reduced to a BYTE field and a new BYTE flags field can be added to
*   represent state that is associated with the object.
*
*   Currently, BASEOBJECT swapping code is in HmgSwapLockedHandleContents
*   and RGNOBJ::bSwap (hmgrapi.cxx and rgnobj.cxx, respectively).
*
\**************************************************************************/

// BASEOBJECT FLAGS

//
// Due to the read-modify-write cycle and the fact that the Alpha can
// load and store a minimum of 32bit values, setting BaseFlags requires
// an InterlockedCompareExchange loop so that it doesn't interfere with the
// cExclusiveLock.
//
// HMGR_LOOKASIDE_ALLOC_FLAG is a 'static' flag - it doesn't change after
// it is set on object allocation. If anyone adds a 'dynamic' flag they
// should probably restructure BASEOBJECT to use a DWORD for the BaseFlags and
// a DWORD for the cExclusiveLock.
//
// If anyone restructures BASEOBJECT they'll have to rewrite all the code
// that uses cExclusiveLock and BaseFlags.
// This includes:
// INC_EXCLUSIVE_REF_CNT and DEC_EXCLUSIVE_REF_CNT
// RGNOBJ::bSwap
//
// Also if anyone adds fields to BASEOBJECT they need to go and fix RGNOBJ::bSwap
// to also copy those fields.
//
//

#endif  // GDIFLAGS_ONLY used for gdikdx

#define HMGR_LOOKASIDE_ALLOC_FLAG       0x8000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _BASEOBJECT
{
    KHANDLE             hHmgr;
    ULONG               ulShareCount;
    USHORT              cExclusiveLock;
    USHORT              BaseFlags;
    PW32THREAD          Tid;
} BASEOBJECT, * KPTR_MODIFIER POBJ;

/*****************************Struct***************************************\
*
* OBJECTOWNER
*
* Description:
*
*   This object is used for shared and exclusive object ownership
*
* Fields for shared Object:
*
*   Pid   : 31
*   Lock  :  1
*
\**************************************************************************/

//
// The lock and the Pid share the same DWORD.
//
// It seems that this is safe from the word tearing problem on the Alpha architecture
// due to the fact that we always use the InterlockedCompareExchange loop for
// the Lock and we require that the lock is set when setting the Pid.
//

typedef struct _OBJECTOWNER_S
{
    ULONG   Lock:1;
    W32PID  Pid_Shifted:31;  // The lowest two bits of the PID are
                             // reserved for application use.  However,
                             // the second bit is used by the
                             // OBJECT_OWNER_xxxx constants and so we
                             // use 31 bits for the Pid_Shifted field.
                             // WARNING:  do not access this field directly,
                             // but rather via the macros below.
}OBJECTOWNER_S,*POBJECTOWNER_S;

#endif  // GDIFLAGS_ONLY used for gdikdx

// Note:  when accessing the Pid_Shifted field the compiler will shift the
// value by one bit to account for the field being only in the upper 31
// bits of the OBJECTOWNER_S structure.  For example, if the OBJECTOWNER_S
// is 8, the Pid_Shifted would be only 4.  However, since we are really
// interested in the upper 31 bits of the PID, this shifting is not
// appropriate (we need masking instead).  I'm not aware of any compiler
// primitives that will accomplish this and will use the macros below
// instead.

#define LOCK_MASK 0x00000001
#define PID_MASK  0xfffffffe

#define PID_BITS 0xfffffffc  // The actual bits used by the PID

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define OBJECTOWNER_PID(ObjectOwner)                                          \
    ((W32PID) ((ObjectOwner).ulObj & PID_MASK))

#define SET_OBJECTOWNER_PID(ObjectOwner, Pid)                                 \
    ((ObjectOwner).ulObj) = ((ObjectOwner).ulObj & LOCK_MASK) | ((Pid) & PID_MASK);

typedef union _OBJECTOWNER
{
    OBJECTOWNER_S   Share;
    ULONG           ulObj;
}OBJECTOWNER,*POBJECTOWNER;

typedef UCHAR OBJTYPE;

typedef union _EINFO
{
    POBJ      pobj;               // Pointer to object
    HOBJ     hFree;              // Next entry in free list
} EINFO;

#endif  // GDIFLAGS_ONLY used for gdikdx

/*****************************Struct***************************************\
*
* ENTRY
*
* Description:
*
*   This object is allocated for each entry in the handle manager and
*   keeps track of object owners, reference counts, pointers, and handle
*   objt and iuniq
*
* Fields:
*
*   einfo       - pointer to object or next free handle
*   ObjectOwner - lock object
*   ObjectInfo  - Object Type, Unique and flags
*   pUser       - Pointer to user-mode data
*
\**************************************************************************/

// entry.Flags flags

#define HMGR_ENTRY_UNDELETABLE  0x0001
#define HMGR_ENTRY_LAZY_DEL     0x0002
#define HMGR_ENTRY_INVALID_VIS    0x0004
#define HMGR_ENTRY_LOOKASIDE_ALLOC 0x0010

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _ENTRY
{
    EINFO       einfo;
    OBJECTOWNER ObjectOwner;
    USHORT      FullUnique;
    OBJTYPE     Objt;
    UCHAR       Flags;
    KERNEL_PVOID pUser;
} ENTRY, *PENTRY;

typedef union _PENTOBJ
{
    PENTRY pent;
    POBJ   pobj;
} PENTOBJ;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// status flags used by metafile in user and kernel
//

#define MRI_ERROR       0
#define MRI_NULLBOX     1
#define MRI_OK          2

/*******************************STRUCTURE**********************************\
* GDIHANDLECACHE
*
*   Cache common handle types, when a handle with user mode attributes is
*   deleted, an attempt is made to cache the handle on memory accessable
*   in user mode.
*
* Fields:
*
*   Lock - CompareExchange used to gain ownership
*   pCacheEntr[] - array of offsets to types
*   ulBuffer     - buffer for storage of all handle cache entries
*
*
* History:
*
*    30-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


//
// defined cached handle types
//

#define GDI_CACHED_HADNLE_TYPES 4

#define CACHE_BRUSH_ENTRIES  10
#define CACHE_PEN_ENTRIES     8
#define CACHE_REGION_ENTRIES  8
#define CACHE_LFONT_ENTRIES   1

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef enum _HANDLECACHETYPE
{
    BrushHandle,
    PenHandle,
    RegionHandle,
    LFontHandle
}HANDLECACHETYPE,*PHANDLECACHETYPE;



typedef struct _GDIHANDLECACHE
{
    KERNEL_PVOID    Lock;
    ULONG           ulNumHandles[GDI_CACHED_HADNLE_TYPES];
    KHANDLE         Handle[CACHE_BRUSH_ENTRIES  +
                           CACHE_PEN_ENTRIES    +
                           CACHE_REGION_ENTRIES +
                           CACHE_LFONT_ENTRIES];
}GDIHANDLECACHE,*PGDIHANDLECACHE;


/*********************************MACRO************************************\
*  Lock handle cache by placing -1 into lock variable using cmp-exchange
*
* Arguments:
*
*   p       - handle cache pointer
*   uLock   - Thread specific lock ID (TEB or THREAD)
*   bStatus - Lock status
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if defined(BUILD_WOW6432)
KERNEL_PVOID
InterlockedCompareExchangeKernelPointer(
     KERNEL_PVOID *Destination,
     KERNEL_PVOID Exchange,
     KERNEL_PVOID Compare
     );
#else
#define InterlockedCompareExchangeKernelPointer InterlockedCompareExchangePointer
#endif

#define LOCK_HANDLE_CACHE(p,uLock,bStatus)                  \
{                                                           \
    KERNEL_PVOID OldLock  = p->Lock;                        \
    bStatus = FALSE;                                        \
                                                            \
    if (OldLock ==      NULL)                               \
    {                                                       \
        if (InterlockedCompareExchangeKernelPointer(        \
                   &p->Lock,                                \
                   uLock,                                   \
                   OldLock) == OldLock)                     \
        {                                                   \
            bStatus = TRUE;                                 \
        }                                                   \
    }                                                       \
}


/*********************************MACRO************************************\
* unlock locked structure by writing null back to lock variable
*
* Arguments:
*
*   p - pointer to handle cache
*
* Return Value:
*
*   none
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if defined(BUILD_WOW6432) && defined(_X86_)

/* It is assumed that p->Lock will be updated atomically.  This is true for alpha,
   but it is not true for the 32bit x86 dll on wow64 since Lock is a 64bit quantity
   which requires 2 mov instructions.  So call InterlockedCompareExchangeKernelPointer
   to set it.
*/

#define UNLOCK_HANDLE_CACHE(p)                              \
   InterlockedCompareExchangeKernelPointer(&p->Lock, NULL, p->Lock);

#else

#define UNLOCK_HANDLE_CACHE(p)                              \
{                                                           \
    p->Lock = NULL;                                         \
}

#endif

#endif  // GDIFLAGS_ONLY used for gdikdx

/******************************Struct**************************************\
* CFONT
*
* Client side realized font.  Contains widths of all ANSI characters.
*
* We keep a free list of CFONT structures for fast allocation.  The
* reference count counts pointers to this structure from all LDC and
* LOCALFONT structures.  When this count hits zero, the CFONT is freed.
*
* The only "inactive" CFONTs that we keep around are those referenced by
* the LOCALFONT.
*
* (In the future we could expand this to contain UNICODE info as well.)
*
*  Mon 11-Jun-1995 00:36:14 -by- Gerrit van Wingerden [gerritv]
* Addapted for kernel mode
*  Sun 10-Jan-1993 00:36:14 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define CFONT_COMPLETE          0x0001
#define CFONT_EMPTY             0x0002
#define CFONT_DBCS              0x0004
#define CFONT_CACHED_METRICS    0x0008  // we have cached the metrics
#define CFONT_CACHED_AVE        0x0010  // we have cached the average width
#define CFONT_CACHED_WIDTHS     0x0020  // if off, no widths have been computed
#define CFONT_PUBLIC            0x0040  // if public font in public cache
#define CFONT_CACHED_RI         0x0080  // if off, RealizationInfo (RI) has not been cached

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define DEC_CFONT_REF(pcf)  {if (!((pcf)->fl & CFONT_PUBLIC)) --(pcf)->cRef;}
#define INC_CFONT_REF(pcf)  {ASSERTGDI(!((pcf)->fl & CFONT_PUBLIC),"pcfLocate - public font error\n");++(pcf)->cRef;}

typedef struct _CFONT * KPTR_MODIFIER PCFONT;
typedef struct _CFONT
{
    PCFONT          pcfNext;
    KHFONT          hf;
    ULONG           cRef;               // Count of all pointers to this CFONT.
    FLONG           fl;
    LONG            lHeight;            // Precomputed logical height.

// The following are keys to match when looking for a mapping.

    KHDC            hdc;                // HDC of realization.  0 for display.
    EFLOAT_S        efM11;              // efM11 of WtoD of DC of realization
    EFLOAT_S        efM22;              // efM22 of WtoD of DC of realization

    EFLOAT_S        efDtoWBaseline;     // Precomputed back transform.  (FXtoL)
    EFLOAT_S        efDtoWAscent;       // Precomputed back transform.  (FXtoL)

// various extra width info

    WIDTHDATA       wd;

// Font info flags.

    FLONG       flInfo;

// The width table.

    USHORT          sWidth[256];        // Widths in pels.

// other usefull cached info

    ULONG           ulAveWidth;         // bogus average used by USER
    TMW_INTERNAL    tmw;                // cached metrics

#ifdef LANGPACK
// RealizationInfo for this font
    REALIZATION_INFO ri ;
#endif

	LONG			timeStamp;			// to check if cached realization info is updated            			

} CFONT;

/*******************************STRUCTURE**********************************\
*
*   This structure controls the address for allocating and mapping the
*   global shared handle table and device caps (primary display) that
*   is mapped read-only into all user mode processes
*
* Fields:
*
*  aentryHmgr - Handle table
*  DevCaps    - Cached primary display device caps
*
\**************************************************************************/

#define MAX_PUBLIC_CFONT 16

typedef struct _GDI_SHARED_MEMORY
{
    ENTRY   aentryHmgr[MAX_HANDLE_COUNT];
    DEVCAPS DevCaps;
    ULONG   iDisplaySettingsUniqueness;
#ifdef LANGPACK
    DWORD   dwLpkShapingDLLs;
#endif
    CFONT   acfPublic[MAX_PUBLIC_CFONT];
    LONG	timeStamp;

} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

/***********************************Structure******************************\
*
* GDI TEB Batching
*
* Contains the data structures and constants used for the batching of
* GDI calls to avoid kernel mode transition costs.
*
* History:
*    20-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

typedef enum _BATCH_TYPE
{
    BatchTypePatBlt,
    BatchTypePolyPatBlt,
    BatchTypeTextOut,
    BatchTypeTextOutRect,
    BatchTypeSetBrushOrg,
    BatchTypeSelectClip,
    BatchTypeSelectFont,
    BatchTypeDeleteBrush,
    BatchTypeDeleteRegion
} BATCH_TYPE,*PBATCH_TYPE;

typedef struct _BATCHCOMMAND
{
    USHORT  Length;
    USHORT  Type;
}BATCHCOMMAND,*PBATCHCOMMAND;

typedef struct _BATCHDELETEBRUSH
{
    USHORT  Length;
    USHORT  Type;
    KHBRUSH hbrush;
}BATCHDELETEBRUSH,*PBATCHDELETEBRUSH;

typedef struct _BATCHDELETEREGION
{
    USHORT  Length;
    USHORT  Type;
    KHRGN   hregion;
}BATCHDELETEREGION,*PBATCHDELETEREGION;

typedef struct _BATCHSETBRUSHORG
{
    USHORT  Length;
    USHORT  Type;
    int     x;
    int     y;
}BATCHSETBRUSHORG,*PBATCHSETBRUSHORG;

typedef struct _BATCHPATBLT
{
    USHORT   Length;
    USHORT   Type;
    LONG     x;
    LONG     y;
    LONG     cx;
    LONG     cy;
    KHBRUSH  hbr;
    ULONG    rop4;
    ULONG    TextColor;
    ULONG    BackColor;
    COLORREF DCBrushColor;
    COLORREF IcmBrushColor;
    POINTL   ptlViewportOrg;
    ULONG    ulTextColor;
    ULONG    ulBackColor;
    ULONG    ulDCBrushColor;
}BATCHPATBLT,*PBATCHPATBLT;


typedef struct _BATCHPOLYPATBLT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   rop4;
    ULONG   Mode;
    ULONG   Count;
    ULONG   TextColor;
    ULONG   BackColor;
    COLORREF DCBrushColor;
    ULONG   ulTextColor;
    ULONG   ulBackColor;
    ULONG   ulDCBrushColor;
    POINTL   ptlViewportOrg;
    //
    // Variable length buffer for POLYPATBLT struct.  Must be naturally
    // aligned.
    //
    KERNEL_PVOID ulBuffer[1];
}BATCHPOLYPATBLT,*PBATCHPOLYPATBLT;

typedef struct _BATCHTEXTOUT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   TextColor;
    ULONG   BackColor;
    ULONG   BackMode;
    ULONG   ulTextColor;
    ULONG   ulBackColor;
    LONG    x;
    LONG    y;
    ULONG   fl;
    RECTL   rcl;
    DWORD   dwCodePage;
    ULONG   cChar;
    ULONG   PdxOffset;
    KHANDLE hlfntNew;
    UINT    flTextAlign;
    POINTL   ptlViewportOrg;

    //
    // variable length buffer for WCHAR and pdx data
    //

    ULONG   ulBuffer[1];
}BATCHTEXTOUT,*PBATCHTEXTOUT;

typedef struct _BATCHTEXTOUTRECT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   BackColor;
    ULONG   fl;
    RECTL   rcl;
    POINTL   ptlViewportOrg;
    ULONG   ulBackColor;
}BATCHTEXTOUTRECT,*PBATCHTEXTOUTRECT;

typedef struct _BATCHSELECTCLIP
{
    USHORT  Length;
    USHORT  Type;
    int     iMode;
    RECTL   rclClip;
}BATCHSELECTCLIP,*PBATCHSELECTCLIP;

typedef struct _BATCHSELECTFONT
{
    USHORT  Length;
    USHORT  Type;
    KHANDLE hFont;
}BATCHSELECTFONT,*PBATCHSELECTFONT;



//
// GDI_BATCH_BUFFER_SIZE is space (IN BYTES) in TEB allocated
// for GDI batching
//

#if defined(_GDIPLUS_)

    #define GDI_BATCH_SIZE 0

#else

    #define GDI_BATCH_SIZE 4 * GDI_BATCH_BUFFER_SIZE

#endif

//
// Image32 data
//

typedef enum _IMAGE_TYPE
{
    Image_Alpha,
    Image_AlphaDIB,
    Image_Transparent,
    Image_TransparentDIB,
    Image_Stretch,
    Image_StretchDIB
}IMAGE_TYPE,*PIMAGE_TYPE;

#endif  // GDIFLAGS_ONLY used for gdikdx

// these strings are included in both gre\mapfile.c and client\output.c
// so we put them here so that we can manage the changes from
// the unified place.

//
// This rubbish comment is in win95 sources. I leave it here for reference
// [bodind]
//

//
// this static data goes away as soon as we get the correct functionality in
// NLS. (its in build 162, use it in buid 163)
//

#define NCHARSETS      16
#define CHARSET_ARRAYS                                                      \
UINT nCharsets = NCHARSETS;                                                 \
UINT charsets[] = {                                                         \
      ANSI_CHARSET,   SHIFTJIS_CHARSET, HANGEUL_CHARSET, JOHAB_CHARSET,     \
      GB2312_CHARSET, CHINESEBIG5_CHARSET, HEBREW_CHARSET,                  \
      ARABIC_CHARSET, GREEK_CHARSET,       TURKISH_CHARSET,                 \
      BALTIC_CHARSET, EASTEUROPE_CHARSET,  RUSSIAN_CHARSET, THAI_CHARSET,   \
      VIETNAMESE_CHARSET, SYMBOL_CHARSET};                                  \
UINT codepages[] ={ 1252, 932, 949, 1361,                                   \
                    936,  950, 1255, 1256,                                  \
                    1253, 1254, 1257, 1250,                                 \
                    1251, 874 , 1258, 42};                                  \
DWORD fs[] = { FS_LATIN1,      FS_JISJAPAN,    FS_WANSUNG, FS_JOHAB,        \
               FS_CHINESESIMP, FS_CHINESETRAD, FS_HEBREW,  FS_ARABIC,       \
               FS_GREEK,       FS_TURKISH,     FS_BALTIC,  FS_LATIN2,       \
               FS_CYRILLIC,    FS_THAI,        FS_VIETNAMESE, FS_SYMBOL };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\fot16.h ===
/******************************Module*Header*******************************\
* Module Name: fot16.h
*
* structures for accessing font resources within 16 bit fon dlls
*
* Created: 08-May-1991 13:12:57
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

//
//   The main structure for manipulating the resource data.  One of these
//  is created when access is required to a resource,  and it is destroyed
//  when the resource is no longer required.


typedef  struct                 // wrd
{
    PVOID     pvView;           // view of the mapped *.fot file
    ULONG     cjView;           // size of the view

// stuff referring to general resources

    PTRDIFF   dpNewExe;     // Base address of new header in file
    ULONG     ulShift;      // Shift factor for resource info
    PTRDIFF   dpResTab;     // Offset in file of resource table (first RSRC_TYPEINFO struct)
    ULONG     cjResTab;     // Bytes  in file to store for above

// font directory location and size

    PBYTE pjHdr;
    ULONG cjHdr;

// ttf file name  location and size

    PSZ   pszNameTTF;
    ULONG cchNameTTF;

} WINRESDATA,  *PWINRESDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\fontcs.h ===
/******************************Module*Header*******************************\
* Module Name: fontcs.h
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#define FONT_SERVER_BUFFER_SIZE 0xFFF00

typedef double Align;

#define HEAP_RESERVE 0x100000
#define HEAP_COMMIT  0x10000
#define HEAP_FREE    0x1000

#define ROUNDUP(x,y) ((y)*(((x)+(y)-1)/(y)))

#define SBRK_ERR (char*)(-1)

typedef union _HEADER {
    struct {
        DWORD Tag;
        union _HEADER *pNext;
        unsigned cUnits;
        unsigned cUnused;
    };
    Align x;
} HEADER;

typedef union _HEAP_OBJECT {
    struct {
        unsigned  FreeAlign;
        unsigned  CommitAlign;
            char *pLinearBase;
        unsigned  iFree;
        unsigned  iUncommitted;
        unsigned  iUnreserved;
          HEADER *pFree;     // pointer to free HEADER block
          HEADER  AllocBase; // base HEADER structure for allocation
    };
    Align x;
} HEAP_OBJECT;

typedef enum _DRVPROCID {
    IdEnableDriver         =  0,
    IdEnablePDEV           =  1,
    IdDisablePDEV          =  2,
    IdCompletePDEV         =  3,
    IdQueryFont            =  4,
    IdQueryFontTree        =  5,
    IdQueryFontData        =  6,
    IdDestroyFont          =  7,
    IdQueryFontCaps        =  8,
    IdLoadFontFile         =  9,
    IdUnloadFontFile       = 10,
    IdQueryFontFile        = 11,
    IdQueryAdvanceWidths   = 12,
    IdFree                 = 13,
    IdQueryTrueTypeTable   = 14,
    IdQueryTrueTypeOutline = 15,
    IdGetTrueTypeFile      = 16,
    IdEscape               = 17
} DRVPROCID;

typedef enum _DRIVER_ID {
    BogusDriverId       =   0,
    TrueTypeDriverId    =   1,
    ATMDriverId         =   2
} DRIVER_ID;

typedef union _PROXYMSG {
    struct {
        DRIVER_ID DriverId;                     // 1=TrueType,2=ATM,...
        DRVPROCID ProcId;
         unsigned cjThis;                       // includes header
         struct {
             int bVerbose  : 1;                 // for debugging
             int bException: 1;
         } Flags;
        union {
            struct {
                         BOOL  ReturnValue   ;
                        ULONG  iEngineVersion;
                        ULONG  cj            ;
                DRVENABLEDATA *pded          ;
            } EnableDriver_;
            struct {
                  DHPDEV  ReturnValue   ;
                DEVMODEW *pdm           ;
                  LPWSTR  pwszLogAddress;
                   ULONG  cPat          ;
                   HSURF *phsurfPatterns;
                   ULONG  cjCaps        ;
                   ULONG *pGdiInfo      ;
                   ULONG  cjDevInfo     ;
                 DEVINFO *pdi           ;
                    HDEV  hdev          ;
                  LPWSTR  pwszDeviceName;
                  HANDLE  hDriver       ;
            } EnablePDEV_;
            struct {
                DHPDEV dhpdev;
            } DisablePDEV_;
            struct {
                DHPDEV dhpdev;
                  HDEV hdev  ;
            } CompletePDEV_;
            struct {
                IFIMETRICS *ReturnValue;
                    DHPDEV  dhpdev     ;
                     ULONG  iFile      ;
                     ULONG  iFace      ;
                     ULONG *pid        ;
            } QueryFont_;
            struct {
                 PVOID  ReturnValue ;
                DHPDEV  dhpdev      ;
                 ULONG  iFile       ;
                 ULONG  iFace       ;
                 ULONG  iMode       ;
                 ULONG *pid         ;
            } QueryFontTree_;
            struct {
                     LONG  ReturnValue;
                   DHPDEV  dhpdev     ;
                  FONTOBJ *pfo        ;
                    ULONG  iMode      ;
                   HGLYPH  hg         ;
                GLYPHDATA *pgd        ;
                    PVOID  pv         ;
                    ULONG  cjSize     ;
            } QueryFontData_;
            struct {
                FONTOBJ *pfo;
            } DestroyFont_;
            struct {
                 LONG  ReturnValue;
                ULONG  culCaps    ;
                ULONG *pulCaps    ;
            } QueryFontCaps_;
            struct {
                ULONG  ReturnValue;
                ULONG  cFiles     ;
                ULONG *piFile     ;
                PVOID *ppvView    ;
                ULONG *pcjView    ;
                DESIGNVECTOR *pdv ;
                ULONG  ulLangID   ;
            } LoadFontFile_;
            struct {
                 BOOL ReturnValue;
                ULONG iFile      ;
            } UnloadFontFile_;
            struct {
                 LONG  ReturnValue;
                ULONG  iFile      ;
                ULONG  ulMode     ;
                ULONG  cjBuf      ;
                ULONG *pulBuf     ;
            } QueryFontFile_;
            struct {
                   BOOL  ReturnValue;
                 DHPDEV  dhpdev     ;
                FONTOBJ *pfo        ;
                  ULONG  iMode      ;
                 HGLYPH *phg        ;
                  PVOID  pvWidths   ;
                  ULONG  cGlyphs    ;
            } QueryAdvanceWidths_;
            struct {
                PVOID pv;
                ULONG id;
            } Free_;
            struct {
                   LONG   ReturnValue;
                  ULONG   iFile      ;
                  ULONG   ulFont     ;
                  ULONG   ulTag      ;
                PTRDIFF   dpStart    ;
                  ULONG   cjBuf      ;
                   BYTE  *pjBuf      ;
                   BYTE **ppjTable   ;
                  ULONG  *pcjTable   ;
            } QueryTrueTypeTable_;
            struct {
                           LONG  ReturnValue ;
                         DHPDEV  dhpdev      ;
                        FONTOBJ *pfo         ;
                         HGLYPH  hglyph      ;
                           BOOL  bMetricsOnly;
                      GLYPHDATA *pgldt       ;
                          ULONG  cjBuf       ;
                TTPOLYGONHEADER *ppoly       ;
            } QueryTrueTypeOutline_;
            struct {
                PVOID  ReturnValue;
                ULONG  iFile      ;
                ULONG *pcj        ;
            } GetTrueTypeFile_;
            struct {
                    ULONG  ReturnValue;
                  SURFOBJ *pso        ;
                    ULONG  iEsc       ;
                    ULONG  cjIn       ;
                    PVOID  pvIn       ;
                    ULONG  cjOut      ;
                    PVOID  pvOut      ;
            } Escape_;
        };
         ULONG  LastError;
        USHORT  OemCodePage;
        USHORT  AnsiCodePage;
         PVOID  pToBeFreed;
         ULONG  idToBeFreed;
      unsigned  cjScratch;
          char *pScratch;
    };
    char InitialIdentifier[32];
    double x;       // forces double alignment of the entire PROXYMSG
} PROXYMSG;

typedef struct _FXOBJ {
    FONTOBJ fo;
    XFORML  xform;
    ULONG   i;
} FXOBJ;

//
// The STATE structure describes the state of the CLIENT SERVER mechanism
//

typedef struct _STATE {
    unsigned  SizeOfBuffer;   // size of user mode buffer = pMsg->cjThis
    DRIVER_ID DriverId;       // Identifies specific user mode driver
    PROXYMSG *pMsg;           // pointer to message buffer
    struct {
        unsigned DontCallServer : 1;
    } flags;
} STATE;

#define PSTATE(p) ((STATE*)(p)->pvConsumer)

#define UMFD_TAG 'dfmu'

typedef enum _PATH_PROC_TYPE {
      isMoveTo       = 0
    , isPolyLineTo   = 1
    , isPolyBezierTo = 2
    , isCloseFigure  = 3
} PATH_PROC_TYPE;

typedef union _PATH_RECORD {
    struct {
         union _PATH_RECORD *pNext;
             PATH_PROC_TYPE  Type;
                      ULONG  Count;
    };
    double x;
} PATH_RECORD;

//
// POINTFIX* POINTER_TO_FIRST_POINT(PATH_RECORD*)
//
// Returns a pointer to the first POINTFIX structure immediately
// following the PATH_RECORD structure
//

#define POINTER_TO_FIRST_POINT(p) ((POINTFIX*)((PATH_RECORD*)(p)+1))

typedef union _PATH_HEADER {
    struct {
        PATHOBJ  Object;
       PROXYMSG *pMsg;
       unsigned  BytesRemaining; // bytes available for allocation
    PATH_RECORD *pLast;          // pointer to last allocated record
    PATH_RECORD *pNext;          // pointer to next available address
    };
    double x;
} PATH_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\gdisplp.h ===
/******************************Module*Header*******************************\
* Module Name: gdisplp.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

#define GetPrinterDriver  GetPrinterDriverW

BOOL
WINAPI
AbortPrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
EndDocPrinter(
   HANDLE   hPrinter
);

typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;

typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;


BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);

#define OpenPrinter  OpenPrinterW

BOOL
WINAPI
ClosePrinter(
    HANDLE hPrinter
);

BOOL
WINAPI
EndPagePrinter(
   HANDLE   hPrinter
);

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

#define StartDocPrinter  StartDocPrinterW

BOOL
WINAPI
ResetPrinterW(
   HANDLE   hPrinter,
   LPVOID pDefault
);

#define ResetPrinter  ResetPrinterW

BOOL
WINAPI
StartPagePrinter(
    HANDLE  hPrinter
);


typedef struct _DRIVER_INFO_5W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    DWORD     dwDriverAttributes;       // driver attributes (like UMPD/KMPD)
    DWORD     dwConfigVersion;          // version number of the config file since reboot
    DWORD     dwDriverVersion;          // version number of the driver file since reboot
} DRIVER_INFO_5W, *PDRIVER_INFO_5W, *LPDRIVER_INFO_5W;

typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;

typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810
    LPWSTR    pEnvironment;       // Win32 x86
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;

typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;


typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR  pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;

typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;

typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;

typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;


#define PRINTER_ACCESS_USE          0x00000008
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\kdftdbg.h ===
/******************************Module*Header*******************************\
* Module Name: kdftdbg.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include <winfont.h>
#define WOW_EMBEDING 2

extern "C" VOID
vPrintFONTDIFF(
    FONTDIFF *pfd  ,
    CHAR     *psz      )
{
//
// This is where you put the code common to vDumpFONTDIFF and vPrintFONTDIFF
//

    dprintf("  ** %s **\n"                         , psz                 );
    dprintf("    jReserved1             %d\n"      , pfd->jReserved1     );
    dprintf("    jReserved2             %d\n"      , pfd->jReserved2     );
    dprintf("    jReserved3             %d\n"      , pfd->jReserved3     );
    dprintf("    bWeight                %d\n"      , pfd->bWeight        );
    dprintf("    usWinWeight            %d\n"      , pfd->usWinWeight    );
    dprintf("    fsSelection            %-#6x\n"   , pfd->fsSelection    );
    dprintf("    fwdAveCharWidth        %d\n"      , pfd->fwdAveCharWidth);
    dprintf("    fwdMaxCharInc          %d\n"      , pfd->fwdMaxCharInc  );
    dprintf("    ptlCaret               {%d,%d}\n" , pfd->ptlCaret.x
                                                  , pfd->ptlCaret.y     );
}

/******************************Public*Routine******************************\
* vPrintTEXTMETRICW
*
* History:
*  Tue 08-Dec-1992 11:41:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID
vPrintTEXTMETRICW(
    TEXTMETRICW *p    )
{
    dprintf("    tmHeight               = %d\n",    p->tmHeight           );
    dprintf("    tmAscent               = %d\n",    p->tmAscent           );
    dprintf("    tmDescent              = %d\n",    p->tmDescent          );
    dprintf("    tmInternalLeading      = %d\n",    p->tmInternalLeading  );
    dprintf("    tmExternalLeading      = %d\n",    p->tmExternalLeading  );
    dprintf("    tmAveCharWidth         = %d\n",    p->tmAveCharWidth     );
    dprintf("    tmMaxCharWidth         = %d\n",    p->tmMaxCharWidth     );
    dprintf("    tmWeight               = %d\n",    p->tmWeight           );
    dprintf("    tmOverhang             = %d\n",    p->tmOverhang         );
    dprintf("    tmDigitizedAspectX     = %d\n",    p->tmDigitizedAspectX );
    dprintf("    tmDigitizedAspectY     = %d\n",    p->tmDigitizedAspectY );
    dprintf("    tmFirstChar            = %-#6x\n", p->tmFirstChar        );
    dprintf("    tmLastChar             = %-#6x\n", p->tmLastChar         );
    dprintf("    tmDefaultChar          = %-#6x\n", p->tmDefaultChar      );
    dprintf("    tmBreakChar            = %-#6x\n", p->tmBreakChar        );
    dprintf("    tmItalic               = %-#4x\n", p->tmItalic           );
    dprintf("    tmUnderlined           = %-#4x\n", p->tmUnderlined       );
    dprintf("    tmStruckOut            = %-#4x\n", p->tmStruckOut        );
    dprintf("    tmPitchAndFamily       = %-#4x\n", p->tmPitchAndFamily   );
    dprintf("    tmCharSet              = %-#4x\n", p->tmCharSet          );
}


extern "C" VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi    )
{
//
// Convenient pointer to Panose number
//
    char *psz;

    PANOSE *ppan = &pifi->panose;

    PWSZ pwszFamilyName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFamilyName);
    PWSZ pwszStyleName  = (PWSZ)(((BYTE*) pifi) + pifi->dpwszStyleName );
    PWSZ pwszFaceName   = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFaceName  );
    PWSZ pwszUniqueName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszUniqueName);

    dprintf("    cjThis                 %-#8lx\n" , pifi->cjThis      );
    dprintf("    cjIfiExtra             %-#8lx\n" , pifi->cjIfiExtra  );
    dprintf("    pwszFamilyName         \"%ws\"\n", pwszFamilyName    );
    dprintf("    pwszStyleName          \"%ws\"\n", pwszStyleName     );
    dprintf("    pwszFaceName           \"%ws\"\n", pwszFaceName      );
    dprintf("    pwszUniqueName         \"%ws\"\n", pwszUniqueName    );
    dprintf("    dpFontSim              %-#8lx\n" , pifi->dpFontSim   );
    dprintf("    lEmbedId               %-#8lx\n" , pifi->lEmbedId    );
    dprintf("    lItalicAngle           %d\n"     , pifi->lItalicAngle);
    dprintf("    lCharBias              %d\n"     , pifi->lCharBias   );
    dprintf("    dpCharSets             %d\n"     , pifi->dpCharSets  );


    dprintf("    jWinCharSet            %04x\n"   , pifi->jWinCharSet          );
    switch (pifi->jWinCharSet)
    {
    case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
    case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
    case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
    case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
    case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
    case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
    case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
    case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
    case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
    case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
    case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
    case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
    case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
    case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
    case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
    case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
    case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
    case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
    default                 : psz = "UNKNOWN"              ; break;
    }
    dprintf("                             %s\n", psz);


    if (pifi->dpCharSets)
    {
        BYTE *pj  = (BYTE *)pifi + pifi->dpCharSets;
        BYTE *pjEnd = pj + 16;
        dprintf("    Supported Charsets: \n");

        for (; pj < pjEnd; pj++)
        {
            switch (*pj)
            {
            case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
            case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
            case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
            case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
            case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
            case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
            case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
            case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
            case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
            case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
            case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
            case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
            case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
            case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
            case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
            case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
            case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
            case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
            default                 : psz = "UNKNOWN"              ; break;
            }
            dprintf("                             0x%lx, %s\n", (DWORD)(*pj), psz);
        }
    }



    dprintf("    jWinPitchAndFamily     %04x\n"   , pifi->jWinPitchAndFamily   );
    switch (pifi->jWinPitchAndFamily & 0xF)
    {
    case DEFAULT_PITCH      : psz = "DEFAULT_PITCH";    break;
    case FIXED_PITCH        : psz = "FIXED_PITCH";      break;
    case VARIABLE_PITCH     : psz = "VARIABLE_PITCH";   break;
    default                 : psz = "UNKNOWN_PITCH";    break;
    }
    dprintf("                             %s | ", psz);
    switch (pifi->jWinPitchAndFamily & 0xF0)
    {
    case FF_DONTCARE    : psz = "FF_DONTCARE";      break;
    case FF_ROMAN       : psz = "FF_ROMAN";         break;
    case FF_SWISS       : psz = "FF_SWISS";         break;
    case FF_MODERN      : psz = "FF_MODERN";        break;
    case FF_SCRIPT      : psz = "FF_SCRIPT";        break;
    case FF_DECORATIVE  : psz = "FF_DECORATIVE";    break;
    default             : psz = "FF_UNKNOWN";       break;
    }
    dprintf("%s\n", psz);




    dprintf("    usWinWeight            %d\n"     , pifi->usWinWeight          );

    dprintf("    flInfo                 %-#8lx\n" , pifi->flInfo               );
    if (pifi->flInfo & FM_INFO_TECH_TRUETYPE)
        dprintf("                             FM_INFO_TECH_TRUETYPE\n");
    if (pifi->flInfo & FM_INFO_TECH_BITMAP)
        dprintf("                             FM_INFO_TECH_BITMAP\n");
    if (pifi->flInfo & FM_INFO_TECH_STROKE)
        dprintf("                             FM_INFO_TECH_STROKE\n");
    if (pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE)
        dprintf("                             FM_INFO_TECH_OUTLINE_NOT_TRUETYPE\n");
    if (pifi->flInfo & FM_INFO_ARB_XFORMS)
        dprintf("                             FM_INFO_ARB_XFORMS\n");
    if (pifi->flInfo & FM_INFO_1BPP)
        dprintf("                             FM_INFO_1BPP\n");
    if (pifi->flInfo & FM_INFO_4BPP)
        dprintf("                             FM_INFO_4BPP\n");
    if (pifi->flInfo & FM_INFO_8BPP)
        dprintf("                             FM_INFO_8BPP\n");
    if (pifi->flInfo & FM_INFO_16BPP)
        dprintf("                             FM_INFO_16BPP\n");
    if (pifi->flInfo & FM_INFO_24BPP)
        dprintf("                             FM_INFO_24BPP\n");
    if (pifi->flInfo & FM_INFO_32BPP)
        dprintf("                             FM_INFO_32BPP\n");
    if (pifi->flInfo & FM_INFO_INTEGER_WIDTH)
        dprintf("                             FM_INFO_INTEGER_WIDTH\n");
    if (pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
        dprintf("                             FM_INFO_CONSTANT_WIDTH\n");
    if (pifi->flInfo & FM_INFO_NOT_CONTIGUOUS)
        dprintf("                             FM_INFO_NOT_CONTIGUOUS\n");
    if (pifi->flInfo & FM_INFO_TECH_MM)
        dprintf("                             FM_INFO_TECH_MM\n");
    if (pifi->flInfo & FM_INFO_RETURNS_OUTLINES)
        dprintf("                             FM_INFO_RETURNS_OUTLINES\n");
    if (pifi->flInfo & FM_INFO_RETURNS_STROKES)
        dprintf("                             FM_INFO_RETURNS_STROKES\n");
    if (pifi->flInfo & FM_INFO_RETURNS_BITMAPS)
        dprintf("                             FM_INFO_RETURNS_BITMAPS\n");
    if (pifi->flInfo & FM_INFO_DSIG)
        dprintf("                             FM_INFO_DSIG\n");
    if (pifi->flInfo & FM_INFO_RIGHT_HANDED)
        dprintf("                             FM_INFO_RIGHT_HANDED\n");
    if (pifi->flInfo & FM_INFO_INTEGRAL_SCALING)
        dprintf("                             FM_INFO_INTEGRAL_SCALING\n");
    if (pifi->flInfo & FM_INFO_90DEGREE_ROTATIONS)
        dprintf("                             FM_INFO_90DEGREE_ROTATIONS\n");
    if (pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH)
        dprintf("                             FM_INFO_OPTICALLY_FIXED_PITCH\n");
    if (pifi->flInfo & FM_INFO_DO_NOT_ENUMERATE)
        dprintf("                             FM_INFO_DO_NOT_ENUMERATE\n");
    if (pifi->flInfo & FM_INFO_ISOTROPIC_SCALING_ONLY)
        dprintf("                             FM_INFO_ISOTROPIC_SCALING_ONLY\n");
    if (pifi->flInfo & FM_INFO_ANISOTROPIC_SCALING_ONLY)
        dprintf("                             FM_INFO_ANISOTROPIC_SCALING_ONLY\n");
    if (pifi->flInfo & FM_INFO_TECH_CFF)
        dprintf("                             FM_INFO_TECH_CFF\n");
    if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        dprintf("                             FM_INFO_FAMILY_EQUIV\n");
    if (pifi->flInfo & FM_INFO_IGNORE_TC_RA_ABLE)
        dprintf("                             FM_INFO_IGNORE_TC_RA_ABLE\n");



    dprintf("    fsSelection            %-#6lx\n" , pifi->fsSelection          );
    if (pifi->fsSelection & FM_SEL_ITALIC)
        dprintf("                             FM_SEL_ITALIC\n");
    if (pifi->fsSelection & FM_SEL_UNDERSCORE)
        dprintf("                             FM_SEL_UNDERSCORE\n");
    if (pifi->fsSelection & FM_SEL_NEGATIVE)
        dprintf("                             FM_SEL_NEGATIVE\n");
    if (pifi->fsSelection & FM_SEL_OUTLINED)
        dprintf("                             FM_SEL_OUTLINED\n");
    if (pifi->fsSelection & FM_SEL_STRIKEOUT)
        dprintf("                             FM_SEL_STRIKEOUT\n");
    if (pifi->fsSelection & FM_SEL_BOLD)
        dprintf("                             FM_SEL_BOLD\n");
    if (pifi->fsSelection & FM_SEL_REGULAR)
        dprintf("                             FM_SEL_REGULAR\n");

    dprintf("    fsType                 %-#6lx\n" , pifi->fsType               );
    if (pifi->fsType & FM_TYPE_LICENSED)
        dprintf("                             FM_TYPE_LICENSED\n");
    if (pifi->fsType & FM_READONLY_EMBED)
        dprintf("                             FM_READONLY_EMBED\n");
    if (pifi->fsType & FM_NO_EMBEDDING)
        dprintf("                             FM_NO_EMBEDDING\n");

    dprintf("    fwdUnitsPerEm          %d\n"     , pifi->fwdUnitsPerEm        );
    dprintf("    fwdLowestPPEm          %d\n"     , pifi->fwdLowestPPEm        );
    dprintf("    fwdWinAscender         %d\n"     , pifi->fwdWinAscender       );
    dprintf("    fwdWinDescender        %d\n"     , pifi->fwdWinDescender      );
    dprintf("    fwdMacAscender         %d\n"     , pifi->fwdMacAscender       );
    dprintf("    fwdMacDescender        %d\n"     , pifi->fwdMacDescender      );
    dprintf("    fwdMacLineGap          %d\n"     , pifi->fwdMacLineGap        );
    dprintf("    fwdTypoAscender        %d\n"     , pifi->fwdTypoAscender      );
    dprintf("    fwdTypoDescender       %d\n"     , pifi->fwdTypoDescender     );
    dprintf("    fwdTypoLineGap         %d\n"     , pifi->fwdTypoLineGap       );
    dprintf("    fwdAveCharWidth        %d\n"     , pifi->fwdAveCharWidth      );
    dprintf("    fwdMaxCharInc          %d\n"     , pifi->fwdMaxCharInc        );
    dprintf("    fwdCapHeight           %d\n"     , pifi->fwdCapHeight         );
    dprintf("    fwdXHeight             %d\n"     , pifi->fwdXHeight           );
    dprintf("    fwdSubscriptXSize      %d\n"     , pifi->fwdSubscriptXSize    );
    dprintf("    fwdSubscriptYSize      %d\n"     , pifi->fwdSubscriptYSize    );
    dprintf("    fwdSubscriptXOffset    %d\n"     , pifi->fwdSubscriptXOffset  );
    dprintf("    fwdSubscriptYOffset    %d\n"     , pifi->fwdSubscriptYOffset  );
    dprintf("    fwdSuperscriptXSize    %d\n"     , pifi->fwdSuperscriptXSize  );
    dprintf("    fwdSuperscriptYSize    %d\n"     , pifi->fwdSuperscriptYSize  );
    dprintf("    fwdSuperscriptXOffset  %d\n"     , pifi->fwdSuperscriptXOffset);
    dprintf("    fwdSuperscriptYOffset  %d\n"     , pifi->fwdSuperscriptYOffset);
    dprintf("    fwdUnderscoreSize      %d\n"     , pifi->fwdUnderscoreSize    );
    dprintf("    fwdUnderscorePosition  %d\n"     , pifi->fwdUnderscorePosition);
    dprintf("    fwdStrikeoutSize       %d\n"     , pifi->fwdStrikeoutSize     );
    dprintf("    fwdStrikeoutPosition   %d\n"     , pifi->fwdStrikeoutPosition );
    dprintf("    chFirstChar            %-#4x\n"  , (int) (BYTE) pifi->chFirstChar   );
    dprintf("    chLastChar             %-#4x\n"  , (int) (BYTE) pifi->chLastChar    );
    dprintf("    chDefaultChar          %-#4x\n"  , (int) (BYTE) pifi->chDefaultChar );
    dprintf("    chBreakChar            %-#4x\n"  , (int) (BYTE) pifi->chBreakChar   );
    dprintf("    wcFirsChar             %-#6x\n"  , pifi->wcFirstChar          );
    dprintf("    wcLastChar             %-#6x\n"  , pifi->wcLastChar           );
    dprintf("    wcDefaultChar          %-#6x\n"  , pifi->wcDefaultChar        );
    dprintf("    wcBreakChar            %-#6x\n"  , pifi->wcBreakChar          );
    dprintf("    ptlBaseline            {%ld,%ld}\n"  , pifi->ptlBaseline.x,
                                                   pifi->ptlBaseline.y        );
    dprintf("    ptlAspect              {%ld,%ld}\n"  , pifi->ptlAspect.x,
                                                   pifi->ptlAspect.y          );
    dprintf("    ptlCaret               {%ld,%ld}\n"  , pifi->ptlCaret.x,
                                                   pifi->ptlCaret.y           );
    dprintf("    rclFontBox             {%ld,%ld,%ld,%ld}\n",pifi->rclFontBox.left,
                                                      pifi->rclFontBox.top,
                                                      pifi->rclFontBox.right,
                                                      pifi->rclFontBox.bottom    );
    dprintf("    achVendId              \"%c%c%c%c\"\n",pifi->achVendId[0],
                                                   pifi->achVendId[1],
                                                   pifi->achVendId[2],
                                                   pifi->achVendId[3]         );
    dprintf("    cKerningPairs          %ld\n"     , pifi->cKerningPairs        );
    dprintf("    ulPanoseCulture        %-#8lx\n" , pifi->ulPanoseCulture);
    dprintf(
           "    panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight             );
    if (pifi->dpFontSim)
    {
        FONTSIM *pfs = (FONTSIM*) (((BYTE*) pifi) + pifi->dpFontSim);
        if (pfs->dpBold)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpBold),
                "BOLD SIMULATION"                );
        }
        if (pfs->dpItalic)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpItalic),
                "ITALIC SIMULATION"                );
        }
        if (pfs->dpBoldItalic)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic),
                "BOLD ITALIC SIMULATION"                );
        }
    }
    dprintf("\n\n");
}

extern "C" VOID vPrintLOGFONTW(LOGFONTW* plfw)
{
    char *psz;

    dprintf("    lfw.lfHeight              = %d\n",     plfw->lfHeight);
    dprintf("    lfw.lfWidth               = %d\n",     plfw->lfWidth);
    dprintf("    lfw.lfEscapement          = %d\n",     plfw->lfEscapement);
    dprintf("    lfw.lfOrientation         = %d\n",     plfw->lfOrientation);

    dprintf("    lfw.lfWeight              = %d = ",     plfw->lfWeight);
    switch (plfw->lfWeight)
    {
    case FW_DONTCARE    : psz = "FW_DONTCARE  "; break;
    case FW_THIN        : psz = "FW_THIN      "; break;
    case FW_EXTRALIGHT  : psz = "FW_EXTRALIGHT"; break;
    case FW_LIGHT       : psz = "FW_LIGHT     "; break;
    case FW_NORMAL      : psz = "FW_NORMAL    "; break;
    case FW_MEDIUM      : psz = "FW_MEDIUM    "; break;
    case FW_SEMIBOLD    : psz = "FW_SEMIBOLD  "; break;
    case FW_BOLD        : psz = "FW_BOLD      "; break;
    case FW_EXTRABOLD   : psz = "FW_EXTRABOLD "; break;
    case FW_HEAVY       : psz = "FW_HEAVY     "; break;
    default             : psz = "NON STANDARD "; break;
    }
    dprintf("%s\n",psz);

    dprintf("    lfw.lfItalic              = %-#8lx\n", plfw->lfItalic);
    dprintf("    lfw.lfUnderline           = %-#8lx\n", plfw->lfUnderline);
    dprintf("    lfw.lfStrikeOut           = %-#8lx\n", plfw->lfStrikeOut);

//
// lfCharSet
//
    dprintf("    lfw.lfCharSet             = %-#8lx = ", plfw->lfCharSet);
    switch (plfw->lfCharSet)
    {
    case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
    case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
    case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
    case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
    case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
    case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
    case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
    case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
    case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
    case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
    case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
    case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
    case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
    case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
    case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
    case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
    case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
    case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
    default                 : psz = "UNKNOWN"              ; break;
    }
    dprintf("%s\n", psz);

//
// lfOutPrecision
//
    dprintf("    lfw.lfOutPrecision        = %-#8lx = ", plfw->lfOutPrecision);
    switch (plfw->lfOutPrecision)
    {
    case OUT_DEFAULT_PRECIS     : psz = "OUT_DEFAULT_PRECIS";   break;
    case OUT_STRING_PRECIS      : psz = "OUT_STRING_PRECIS";    break;
    case OUT_CHARACTER_PRECIS   : psz = "OUT_CHARACTER_PRECIS"; break;
    case OUT_STROKE_PRECIS      : psz = "OUT_STROKE_PRECIS";    break;
    case OUT_TT_PRECIS          : psz = "OUT_TT_PRECIS";        break;
    case OUT_DEVICE_PRECIS      : psz = "OUT_DEVICE_PRECIS";    break;
    case OUT_RASTER_PRECIS      : psz = "OUT_RASTER_PRECIS";    break;
    case OUT_TT_ONLY_PRECIS     : psz = "OUT_TT_ONLY_PRECIS";   break;
    case OUT_OUTLINE_PRECIS     : psz = "OUT_OUTLINE_PRECIS";   break;
    default                     : psz = "UNKNOWN";              break;
    }
    dprintf("%s\n", psz);

//
// lfClipPrecision
//
    dprintf("    lfw.lfClipPrecision       = %-#8lx", plfw->lfClipPrecision);
    switch (plfw->lfClipPrecision & CLIP_MASK)
    {
    case CLIP_DEFAULT_PRECIS    : psz = "CLIP_DEFAULT_PRECIS";      break;
    case CLIP_CHARACTER_PRECIS  : psz = "CLIP_CHARACTER_PRECIS";    break;
    case CLIP_STROKE_PRECIS     : psz = "CLIP_STROKE_PRECIS";       break;
    default                     : psz = "UNKNOWN";                  break;
    }
    dprintf(" = %s\n", psz);
    if (plfw->lfClipPrecision & CLIP_LH_ANGLES)
    {
        dprintf("                                     CLIP_LH_ANGLES\n");
    }
    if (plfw->lfClipPrecision & CLIP_TT_ALWAYS)
    {
        dprintf("                                     CLIP_TT_ALWAYS\n");
    }
    if (plfw->lfClipPrecision & CLIP_EMBEDDED)
    {
        dprintf("                                     CLIP_EMBEDDED\n");
    }

//
// lfQuality
//
    dprintf("    lfw.lfQuality             = %-#8lx", plfw->lfQuality);
    switch (plfw->lfQuality)
    {
    case DEFAULT_QUALITY    : psz = "DEFAULT_QUALITY";  break;
    case DRAFT_QUALITY      : psz = "DRAFT_QUALITY";    break;
    case PROOF_QUALITY      : psz = "PROOF_QUALITY";    break;
    default                 : psz = "UNKNOWN";          break;
    }
    dprintf(" = %s\n", psz);

//
// lfPitchAndFamily
//
    dprintf("    lfw.lfPitchAndFamily      = %-#8lx", plfw->lfPitchAndFamily);
    switch (plfw->lfPitchAndFamily & 0xF0)
    {
    case FF_DONTCARE    : psz = "FF_DONTCARE";      break;
    case FF_ROMAN       : psz = "FF_ROMAN";         break;
    case FF_SWISS       : psz = "FF_SWISS";         break;
    case FF_MODERN      : psz = "FF_MODERN";        break;
    case FF_SCRIPT      : psz = "FF_SCRIPT";        break;
    case FF_DECORATIVE  : psz = "FF_DECORATIVE";    break;
    default             : psz = "FF_UNKNOWN";       break;
    }
    dprintf(" = %s | ", psz);
    switch (plfw->lfPitchAndFamily & 0xF)
    {
    case DEFAULT_PITCH      : psz = "DEFAULT_PITCH";    break;
    case FIXED_PITCH        : psz = "FIXED_PITCH";      break;
    case VARIABLE_PITCH     : psz = "VARIABLE_PITCH";   break;
    default                 : psz = "UNKNOWN_PITCH";    break;
    }
    dprintf("%s\n", psz);

//
// lfFaceName
//
    dprintf("    lfw.lfFaceName            = \"%ws\"\n",plfw->lfFaceName);
}

extern "C" VOID
vPrintENUMLOGFONTEXDVW(
    ENUMLOGFONTEXDVW *pelfw
    )
{
    vPrintLOGFONTW(&pelfw->elfEnumLogfontEx.elfLogFont);
    PANOSE *ppan;

    dprintf("    elfFullName   = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfFullName );
    dprintf("    elfStyle      = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfStyle    );
    dprintf("    elfScript     = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfScript   );

    // now print design vector if any...


}


/******************************Public*Routine******************************\
* vPrintFONTOBJ
*
* History:
*  Fri 18-Feb-1994 10:23:33 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFONTOBJ(FONTOBJ *pfo)
{
    FLONG fl = pfo->flFontType;

    dprintf("    iUniq       = %d\n", pfo->iUniq     );
    dprintf("    iFace       = %d\n", pfo->iFace     );
    dprintf("    cxMax       = %d\n", pfo->cxMax     );

    dprintf("    flFontType  = %x\n", fl             );
    if (fl & FO_TYPE_RASTER)
        dprintf("                    FO_TYPE_RASTER\n");
    if (fl & FO_TYPE_DEVICE)
        dprintf("                    FO_TYPE_DEVICE\n");
    if (fl & FO_TYPE_TRUETYPE)
        dprintf("                    FO_TYPE_TRUETYPE\n");
    if (fl & FO_SIM_BOLD)
        dprintf("                    FO_SIM_BOLD\n");
    if (fl & FO_SIM_ITALIC)
        dprintf("                    FO_SIM_ITALIC\n");
    if (fl & FO_EM_HEIGHT)
        dprintf("                    FO_EM_HEIGHT\n");

    dprintf("    iTTUniq     = %d\n", pfo->iTTUniq   );
    dprintf("    iFile       = %d\n", pfo->iFile     );
    dprintf(  "    sizLogResPpi= (%d,%d)\n"
           , pfo->sizLogResPpi.cx
           , pfo->sizLogResPpi.cy
        );
    dprintf("    ulStyleSize = %u\n", pfo->ulStyleSize);
    dprintf("    pvConsumer  = %-#8x\n", pfo->pvConsumer);
    dprintf("    pvProducer  = %-#8x\n", pfo->pvProducer);
}

/******************************Public*Routine******************************\
* vPrintEXTFONTOBJ
*
* History:
*  Fri 18-Feb-1994 11:19:44 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintEXTFONTOBJ(EXTFONTOBJ *pefo)
{
    vPrintFONTOBJ(&(pefo->fobj));
    dprintf("*** BEGIN GDI INTERNAL STRUCTURE ***\n");
}

/******************************Public*Routine******************************\
* vPrintFLOAT
*
* History:
*  Mon 29-Aug-1994 11:51:17 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFLOAT(FLOATL l_e)
{
    dprintf("%#+12.6f", l_e);
}

/******************************Public*Routine******************************\
* vPrintFD_XFORM(FD_XFORM
*
* History:
*  Mon 29-Aug-1994 11:50:52 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFD_XFORM(FD_XFORM *pfdx, char * psz)
{
    dprintf("%seXX = ",psz); vPrintFLOAT(pfdx->eXX); dprintf("\n");
    dprintf("%seXY = ",psz); vPrintFLOAT(pfdx->eXY); dprintf("\n");
    dprintf("%seYX = ",psz); vPrintFLOAT(pfdx->eYX); dprintf("\n");
    dprintf("%seYY = ",psz); vPrintFLOAT(pfdx->eYY); dprintf("\n");
}

/**********w********************Public*Routine******************************\
* vPrintFD_REALIZEEXTRA
*
* History:
*  Mon 29-Aug-1994 11:50:29 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//extern "C" VOID
//vPrintFD_REALIZEEXTRA(FD_REALIZEEXTRA *p, char *psz)
//{
//  dprintf("    fdxQuantized =\n",psz);
//  vPrintFD_XFORM(&(p->fdxQuantized), psz);
//  dprintf("%slExtLeading = %d\n", psz, p->lExtLeading);
//  dprintf("%salReserved = \n%s\t[%d]\n%s\t[%d]\n%s\t[%d]\n%s\t[%d]\n"
//      , psz
//      , psz
//      , p->alReserved[0]
//      , psz
//      , p->alReserved[1]
//      , psz
//      , p->alReserved[2]
//      , psz
//      , p->alReserved[3]
//      );
//}

/******************************Public*Routine******************************\
* vPrintEFLOAT
*
* History:
*  Mon 29-Aug-1994 11:49:57 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintEFLOAT(EFLOAT *pef)
{
    FLOATL l_e;

    pef->vEfToF(l_e);
    vPrintFLOAT(l_e);
}

/******************************Public*Routine******************************\
* vPrintFIX
*
* History:
*  Mon 29-Aug-1994 11:49:47 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFIX(FIX fx)
{
    dprintf("%-#x%x",fx>>4, fx & 0xf);
}

/******************************Public*Routine******************************\
* vPrintMATRIX
*
* History:
*  Mon 29-Aug-1994 11:49:27 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintMATRIX( MATRIX *pmx, char *psz)
{
    FLONG fl = pmx->flAccel;

    if (!psz) psz = "";

    dprintf("%sefM11 = ",psz); vPrintEFLOAT(&(pmx->efM11)); dprintf("\n");
    dprintf("%sefM12 = ",psz); vPrintEFLOAT(&(pmx->efM12)); dprintf("\n");
    dprintf("%sefM21 = ",psz); vPrintEFLOAT(&(pmx->efM21)); dprintf("\n");
    dprintf("%sefM22 = ",psz); vPrintEFLOAT(&(pmx->efM22)); dprintf("\n");
    dprintf("%sefDx  = ",psz); vPrintEFLOAT(&(pmx->efDx )); dprintf("\n");
    dprintf("%sefDy  = ",psz); vPrintEFLOAT(&(pmx->efDy )); dprintf("\n");
    dprintf("%sfxDx  = ",psz); vPrintFIX(pmx->fxDx); dprintf("\n");
    dprintf("%sfxDy  = ",psz); vPrintFIX(pmx->fxDy); dprintf("\n");

    dprintf("    flAccel = %-#8x\n", fl);

    if (fl & XFORM_SCALE)           dprintf("%sXFORM_SCALE\n"         ,psz);
    if (fl & XFORM_UNITY)           dprintf("%sXFORM_UNITY\n"         ,psz);
    if (fl & XFORM_Y_NEG)           dprintf("%sXFORM_Y_NEG\n"         ,psz);
    if (fl & XFORM_FORMAT_LTOFX)    dprintf("%sXFORM_FORMAT_LTOFX\n"  ,psz);
    if (fl & XFORM_FORMAT_FXTOL)    dprintf("%sXFORM_FORMAT_FXTOL\n"  ,psz);
    if (fl & XFORM_FORMAT_LTOL)     dprintf("%sXFORM_FORMAT_LTOL\n"   ,psz);
    if (fl & XFORM_NO_TRANSLATION)  dprintf("%sXFORM_NO_TRANSLATION\n",psz);
}

/******************************Public*Routine******************************\
* vPrintCACHE
*
* History:
*  Mon 29-Aug-1994 11:49:12 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintCACHE(CACHE *pc, char *psz)
{
    dprintf("%spgdNext            = %-#x\n", psz, pc->pgdNext     );
    dprintf("%spgdThreshold       = %-#x\n", psz, pc->pgdThreshold);
    dprintf("%spgdFirstBlockEnd   = %-#x\n", psz, pc->pjFirstBlockEnd );

    dprintf("%scjbbl        = %u\n", psz, pc->cjbbl);
    dprintf("%scBlocksMax   = %u\n", psz, pc->cBlocksMax);
    dprintf("%scBlocks      = %u\n", psz, pc->cBlocks);
    dprintf("%scGlyphs      = %u\n", psz, pc->cGlyphs);
    dprintf("%scMetrics     = %u\n", psz, pc->cMetrics);
    dprintf("%spbblBase     = %-#x\n", psz, pc->pbblBase);
    dprintf("%spbblCur      = %-#x\n", psz, pc->pbblCur);
    dprintf("%spgbNext      = %-#x\n", psz, pc->pgbNext);
    dprintf("%spgbThreshold = %-#x\n", psz, pc->pgbThreshold);

    dprintf("%spjAuxCacheMem= %-#x\n", psz, pc->pjAuxCacheMem);
    dprintf("%scjAuxCacheMem= %u\n"  , psz, pc->cjAuxCacheMem);
    dprintf("%scjGlyphMax   = %u\n"  , psz, pc->cjGlyphMax);
    dprintf("%sbSmallMetrics= %u\n" , psz, pc->bSmallMetrics);
}

/******************************Public*Routine******************************\
* vPrintflInfo
*
* History:
*  Mon 29-Aug-1994 11:51:48 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintflInfo(FLONG flInfo, char *psz)
{
    if (FM_INFO_TECH_TRUETYPE & flInfo)
        dprintf("%s  FM_INFO_TECH_TRUETYPE\n",psz);
    if (FM_INFO_TECH_BITMAP & flInfo)
        dprintf("%s  FM_INFO_TECH_BITMAP\n",psz);
    if (FM_INFO_TECH_STROKE & flInfo)
        dprintf("%s  FM_INFO_TECH_STROKE\n",psz);
    if (FM_INFO_TECH_OUTLINE_NOT_TRUETYPE & flInfo)
        dprintf("%s  FM_INFO__OUTLINE_NOT_TRUETYPE\n",psz);
    if (FM_INFO_ARB_XFORMS & flInfo)
        dprintf("%s  FM_INFO_ARB_XFORMS\n",psz);
    if (FM_INFO_1BPP & flInfo)
       dprintf("%s  FM_INFO_1BPP\n",psz);
    if (FM_INFO_4BPP & flInfo)
       dprintf("%s  FM_INFO_4BPP\n",psz);
    if (FM_INFO_8BPP & flInfo)
       dprintf("%s  FM_INFO_8BPP\n",psz);
    if (FM_INFO_16BPP & flInfo)
       dprintf("%s  FM_INFO_16BPP\n",psz);
    if (FM_INFO_24BPP & flInfo)
       dprintf("%s  FM_INFO_24BPP\n",psz);
    if (FM_INFO_32BPP & flInfo)
       dprintf("%s  FM_INFO_32BPP\n",psz);
    if (FM_INFO_INTEGER_WIDTH & flInfo)
       dprintf("%s  FM_INFO_INTEGER_WIDTH\n",psz);
    if (FM_INFO_CONSTANT_WIDTH & flInfo)
       dprintf("%s  FM_INFO_CONSTANT_WIDTH\n",psz);
    if (FM_INFO_NOT_CONTIGUOUS & flInfo)
       dprintf("%s  FM_INFO_NOT_CONTIGUOUS\n",psz);
    if (FM_INFO_TECH_MM & flInfo)
       dprintf("%s  FM_INFO_TECH_MM\n",psz);
    if (FM_INFO_RETURNS_OUTLINES & flInfo)
       dprintf("%s  FM_INFO_RETURNS_OUTLINES\n",psz);
    if (FM_INFO_RETURNS_STROKES & flInfo)
       dprintf("%s  FM_INFO_RETURNS_STROKES\n",psz);
    if (FM_INFO_RETURNS_BITMAPS & flInfo)
       dprintf("%s  FM_INFO_RETURNS_BITMAPS\n",psz);
    if (FM_INFO_DSIG & flInfo)
       dprintf("%s  FM_INFO_DSIG\n",psz);
    if (FM_INFO_RIGHT_HANDED & flInfo)
       dprintf("%s  FM_INFO_RIGHT_HANDED\n",psz);
    if (FM_INFO_INTEGRAL_SCALING & flInfo)
       dprintf("%s  FM_INFO_INTEGRAL_SCALING\n",psz);
    if (FM_INFO_90DEGREE_ROTATIONS & flInfo)
       dprintf("%s  FM_INFO_90DEGREE_ROTATIONS\n",psz);
    if (FM_INFO_OPTICALLY_FIXED_PITCH & flInfo)
       dprintf("%s  FM_INFO_OPTICALLY_FIXED_PITCH\n",psz);
    if (FM_INFO_DO_NOT_ENUMERATE & flInfo)
       dprintf("%s  INFO_DO_NOT_ENUMERATE\n",psz);
    if (FM_INFO_ISOTROPIC_SCALING_ONLY & flInfo)
       dprintf("%s  FM_INSOTROPIC_SCALING_ONLY\n",psz);
    if (FM_INFO_ANISOTROPIC_SCALING_ONLY & flInfo)
       dprintf("%s  FM_INFOSOTROPIC_SCALING_ONLY\n",psz);
    if (FM_INFO_TECH_CFF & flInfo)
       dprintf("%s  FM_INFO_TECH_CFF\n",psz);
    if (FM_INFO_FAMILY_EQUIV & flInfo)
       dprintf("%s  FM_INFO_FAMILY_EQUIV\n",psz);
}

/******************************Public*Routine******************************\
* vPrintRFONT
*
* History:
*  Fri 18-Feb-1994 11:26:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintRFONT(VOID *pvIn)
{
    RFONT *prf = (RFONT*) pvIn;

    vPrintEXTFONTOBJ((EXTFONTOBJ*) prf);
    dprintf("    iUnique     = %d\n", prf->iUnique);

    dprintf("    flType      = %d = ",prf->flType);

    if (prf->flType & ~(RFONT_TYPE_NOCACHE | RFONT_TYPE_MASK))
    {
        dprintf("ERROR!!! UNKNOWN TYPE\n");
    }
    else
    {
        if (prf->flType & RFONT_TYPE_NOCACHE)
        {
            dprintf("RFONT_TYPE_NOCACHE\n");
        }
        switch (prf->flType & RFONT_TYPE_MASK)
        {
        case RFONT_TYPE_HGLYPH:  dprintf("RFONT_TYPE_HGLYPH \n"); break;
        case RFONT_TYPE_UNICODE: dprintf("RFONT_TYPE_UNICODE\n"); break;
        default:                 dprintf("RFONT_TYPE_???????\n"); break;
        }
    }

    dprintf("    ulContent   = %d = ", prf->ulContent);
    switch (prf->ulContent)
    {
    case RFONT_CONTENT_METRICS: dprintf("RFONT_CONTENT_METRICS\n"); break;
    case RFONT_CONTENT_BITMAPS: dprintf("RFONT_CONTENT_BITMAPS\n"); break;
    case RFONT_CONTENT_PATHS:   dprintf("RFONT_CONTENT_PATHS\n"); break;
    default:                 dprintf("ERROR!!! UNKNOWN TYPE\n");
    }

    dprintf("    hdevProducer = %-#8x\n", prf->hdevProducer);
    dprintf("    bDeviceFont = %d\n", prf->bDeviceFont);
    dprintf("    hdevConsumer = %-#8x\n", prf->hdevConsumer);
    dprintf("    dhpdev =      %-#8x\n", prf->dhpdev);
    dprintf("    ppfe =        %-#8x\n", prf->ppfe);
    dprintf("    pPFF =        %-#8x\n", prf->pPFF);

    dprintf("    fdx  = \n");
    vPrintFD_XFORM(&(prf->fdx), "\t\t");
    dprintf("    cBitsPerPel = %d\n", prf->cBitsPerPel);

    dprintf("    mxWorldToDevice =\n");
    vPrintMATRIX(&(prf->mxWorldToDevice), "\t");

    dprintf("    iGraphicsMode = %d\n", prf->iGraphicsMode);

    {
        dprintf("    eptflNtoWScale = ");
        vPrintEFLOAT(&(prf->eptflNtoWScale.x));
        dprintf(", ");
        vPrintEFLOAT(&(prf->eptflNtoWScale.y));
        dprintf("\n");
    }

    dprintf("    bNtoWIdent =  %d\n", prf->bNtoWIdent);

    dprintf("    xoForDDI.pmx    = %-#8x\n", prf->xoForDDI.pmx);
    dprintf("    xoForDDI.ulMode = %u\n",    prf->xoForDDI.ulMode);

    dprintf("    mxForDDI =\n");
    vPrintMATRIX(&(prf->mxForDDI), "\t");
    dprintf("    flRealizedType =\n");
    if (prf->flRealizedType & SO_FLAG_DEFAULT_PLACEMENT)
        dprintf("\t\tSO_FLAG_DEFAULT_PLACEMENT\n");
    if (prf->flRealizedType & SO_HORIZONTAL)
        dprintf("\t\tSO_HORIZONTAL\n");
    if (prf->flRealizedType & SO_VERTICAL)
        dprintf("\t\tSO_VERTICAL\n");
    if (prf->flRealizedType & SO_REVERSED)
        dprintf("\t\tSO_REVERSED\n");
    if (prf->flRealizedType & SO_ZERO_BEARINGS)
        dprintf("\t\tSO_ZERO_BEARINGS\n");
    if (prf->flRealizedType & SO_CHAR_INC_EQUAL_BM_BASE)
        dprintf("\t\tSO_CHAR_INC_EQUAL_BM_BASE\n");
    if (prf->flRealizedType & SO_MAXEXT_EQUAL_BM_SIDE)
        dprintf("\t\tSO_MAXEXT_EQUAL_BM_SIDE\n");
    dprintf("    ptlUnderline1 = (%d,%d)\n"
        ,  prf->ptlUnderline1.x
        ,  prf->ptlUnderline1.y);
    dprintf("    ptlStrikeOut  = (%d,%d)\n"
      , prf->ptlStrikeOut.x
      , prf->ptlStrikeOut.y);
    dprintf("    ptlULThickness = (%d,%d)\n"
      , prf->ptlULThickness.x
      , prf->ptlULThickness.y);
    dprintf("    ptlSOThickness = (%d,%d)\n"
      , prf->ptlSOThickness.x
      , prf->ptlSOThickness.y);
    dprintf("    lCharInc       = %d\n", prf->lCharInc);
    dprintf("    fxMaxAscent    = "); vPrintFIX(prf->fxMaxAscent); dprintf("\n");
    dprintf("    fxMaxDescent   = "); vPrintFIX(prf->fxMaxDescent); dprintf("\n");
    dprintf("    fxMaxExtent    = "); vPrintFIX(prf->fxMaxExtent); dprintf("\n");
    dprintf("    cxMax          = %u\n", prf->cxMax);
    dprintf("    lMaxAscent     = %d\n", prf->lMaxAscent);
    dprintf("    lMaxHeight     = %d\n", prf->lMaxHeight);
    dprintf("    ulOrientation  = %u\n", prf->ulOrientation);

    dprintf("    pteUnitBase    = (");
        vPrintEFLOAT(&(prf->pteUnitBase.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitBase.y));
        dprintf(")\n");

    dprintf("    efWtoDBase     = ");
        vPrintEFLOAT(&(prf->efWtoDBase));
        dprintf("\n");

    dprintf("    efDtoWBase     = ");
        vPrintEFLOAT(&(prf->efDtoWBase));
        dprintf("\n");

    dprintf("    lAscent        = %d\n", prf->lAscent);

    dprintf("    pteUnitAscent  = (");
        vPrintEFLOAT(&(prf->pteUnitAscent.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitAscent.y));
        dprintf(")\n");

    dprintf("    efWtoDAscent   = ");
        vPrintEFLOAT(&(prf->efWtoDAscent));
        dprintf("\n");

    dprintf("    efDtoWAscent   = ");
        vPrintEFLOAT(&(prf->efDtoWAscent));
        dprintf("\n");

    dprintf("    lEscapement    = %d\n", prf->lEscapement);

    dprintf("    pteUnitEsc     = (");
        vPrintEFLOAT(&(prf->pteUnitEsc.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitEsc.y));
        dprintf(")\n");

    dprintf("    efWtoDEsc      = ");
        vPrintEFLOAT(&(prf->efWtoDEsc));
        dprintf("\n");

    dprintf("    efDtoWEsc      = ");
        vPrintEFLOAT(&(prf->efDtoWEsc));
        dprintf("\n");

    dprintf("    efEscToBase    = ");
        vPrintEFLOAT(&(prf->efEscToBase));
        dprintf("\n");

    dprintf("    efEscToAscent  = ");
        vPrintEFLOAT(&(prf->efEscToAscent));
        dprintf("\n");

    dprintf("    flInfo         =  %-#8lx\n" , prf->flInfo);

    vPrintflInfo(prf->flInfo, "\t\t");

    //dprintf("    wcDefault =      %u\n",  prf->wcDefault);
    dprintf("    hgDefault =      %-#x\n", prf->hgDefault);
    dprintf("    hgBreak   =      %-#x\n", prf->hgBreak);
    dprintf("    fxBreak   =      "); vPrintFIX(prf->fxBreak); dprintf("\n");
    dprintf("    pfdg      =      %-#x\n", prf->pfdg);
    dprintf("    wcgp      =      %-#x\n", prf->wcgp);
    dprintf("    cSelected =      %d\n",   prf->cSelected);
    dprintf("    rflPDEV.prfntPrev = %-#x\n", prf->rflPDEV.prfntPrev);
    dprintf("    rflPDEV.prfntNext = %-#x\n", prf->rflPDEV.prfntNext);
    dprintf("    rflPFF.prfntPrev  = %-#x\n", prf->rflPFF.prfntPrev);
    dprintf("    rflPFF.prfntNext  = %-#x\n", prf->rflPFF.prfntNext);
    dprintf("    cache =\n");
    vPrintCACHE(&(prf->cache),"\t");
    dprintf("    ptlSim       =   (%d,%d)\n", prf->ptlSim.x, prf->ptlSim.y);
    dprintf("    bNeededPaths =   %d\n", prf->bNeededPaths);

    dprintf("    reExtra =\n");
    //vPrintFD_REALIZEEXTRA(&(prf->reExtra),"\t\t");
    dprintf("    efDtoWBase_31   = "); vPrintEFLOAT(&(prf->efDtoWBase_31)); dprintf("\n");
    dprintf("    efDtoWAscent_31 = "); vPrintEFLOAT(&(prf->efDtoWAscent_31)); dprintf("\n");

}

/******************************Public*Routine******************************\
* vPrintPFT
*
* Print Physical Font Table
*
* History:
*  Mon 29-Aug-1994 10:26:56 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintPFT(PFT *pPFT)
{
    unsigned i;

    dprintf("\tpfhFamily         = %-#x\n", pPFT->pfhFamily);
    dprintf("\tpfhFace           = %-#x\n", pPFT->pfhFace  );
    dprintf("\tcBuckets          = %u\n",   pPFT->cBuckets);
    dprintf("\tcFiles            = %u\n",   pPFT->cFiles);
    for (i = 0; i < pPFT->cBuckets; i++)
    {
        PFF *pPFF = pPFT->apPFF[i];
        if (pPFF)
        {
            // print the head of the chain

            dprintf("\tapPFF[%u]  = %-#x\n", i, pPFF);
            while (pPFF)
            {
                // the colliding PFF pointers are printed
                // on subsequent lines and are indented
                // from the PFF pointer at the head of the list

                pPFF = pPFF->pPFFNext;
                dprintf("\t           = %-#x\n", pPFF);
            }
        }
    }
    dprintf("\n\n");
}

/******************************Public*Routine******************************\
* vPrintPFF
*
* Dumps the contents of a PFF object via the specified output routine.
*
* History:
*  05-May-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintPFF (VOID *pv)
{
    PFF *pPFF = (PFF*) pv;
    PFE **ppPFE, **ppPFE_;
    ULONG ul;

    ULONG ulMax = pPFF->cFonts;

    dprintf("    sizeofThis   = %u\n",   pPFF->sizeofThis);
    dprintf("    pPFFNext     = %-#x\n", pPFF->pPFFNext  );
    dprintf("    pPFFPrev     = %-#x\n", pPFF->pPFFPrev  );
    dprintf("   *pwszPathname_= \"%ws\"\n", pPFF->pwszPathname_);
    dprintf("    flState      = %-#x\n", pPFF->flState   );
    if (pPFF->flState & PFF_STATE_READY2DIE)
        dprintf("                   PFF_STATE_READY2DIE\n");
    if (pPFF->flState & PFF_STATE_PERMANENT_FONT)
        dprintf("                   PFF_STATE_PERMANENT_FONT\n");
    if (pPFF->flState & PFF_STATE_NETREMOTE_FONT)
        dprintf("                   PFF_STATE_NETREMOTE_FONT\n");
    if (pPFF->flState & PFF_STATE_DCREMOTE_FONT)
        dprintf("                   PFF_STATE_DCREMOTE_FONT\n");
    if (pPFF->flState & PFF_STATE_EUDC_FONT)
        dprintf("                   PFF_STATE_EUDC_FONT\n");
    if (pPFF->flState & ~(PFF_STATE_READY2DIE | PFF_STATE_PERMANENT_FONT | PFF_STATE_NETREMOTE_FONT | PFF_STATE_EUDC_FONT | PFF_STATE_MEMORY_FONT | PFF_STATE_DCREMOTE_FONT))
        dprintf("                   UNKNOWN FLAG\n");
    dprintf("    cLoaded      = %u\n"  , pPFF->cLoaded   );
    dprintf("    cNotEnum     = %u\n"  , pPFF->cNotEnum  );
    dprintf("    pPvtDataHead = %-#x\n", pPFF->pPvtDataHead);
    dprintf("    cRFONT       = %u\n"  , pPFF->cRFONT    );
    dprintf("    prfntList    = %-#x\n", pPFF->prfntList );
    dprintf("    hff          = %-#x\n", pPFF->hff       );
    if (pPFF->hff == 0)
        dprintf("                   DEVICE PFF\n");
    dprintf("    hdev         = %-#x\n", pPFF->hdev      );
//    dprintf("    dhpdev       = %-#x\n", pPFF->dhpdev    );
    dprintf("    pfhFace      = %-#x\n", pPFF->pfhFace   );
    dprintf("    pfhFamily    = %-#x\n", pPFF->pfhFamily );
    dprintf("    pPFT         = %-#x\n", pPFF->pPFT      );
    dprintf("    cFonts       = %u\n"  , pPFF->cFonts    );
    for (ppPFE  = (PFE **) &(pPFF->aulData[0]), ul = 0; ul < ulMax; ul++)
    {
        dprintf("    apPFE[%u]     = %-#x\n", ul, ppPFE[ul]);
    }
    //if (pPFF->cFonts > gulTableLimit)
    //    dprintf("Table exceeds set limit.  Edit gulTableLimit to change.\n");
}

/******************************Public*Routine******************************\
* vPrintWCRUN
*
* History:
*  Sat 31-Oct-1992 05:57:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintWCRUN(WCRUN *pwcr)
{
    DbgPrint("\n    vPrintWCRUN");
    DbgPrint("\n        pwcr    = %-#8lx", pwcr);
    DbgPrint("\n        cGlyphs = %d",     pwcr->cGlyphs);
    DbgPrint("\n        wcLow   = %-#6lx", pwcr->wcLow);
    DbgPrint("\n        phg     = %-#8lx", pwcr->phg);

    WCHAR   wc  = pwcr->wcLow;
    HGLYPH *phg = pwcr->phg;
    HGLYPH *phgSup = phg + pwcr->cGlyphs;

    if (phg)
    {
        for (;phg < phgSup; phg += 1, wc += 1)
        {
            DbgPrint("\n            %-#6lx  %-#8lx", wc, *phg);
        }
    }
    DbgPrint("\n");
}

/******************************Member*Function*****************************\
* RFONTOBJ::vPrintFD_GLYPHSET
*
* History:
*  Sat 31-Oct-1992 05:58:01 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID RFONTOBJ::vPrintFD_GLYPHSET()
{
    FD_GLYPHSET *pfdg = prfnt->pfdg;

    DbgPrint("\nRFONTOBJ::vPrintFD_GLYPHSET()");
    DbgPrint("\n    pfdg = %-#8lx", pfdg);
    if (pfdg == 0)
    {
        DbgPrint("\n");
        return;
    }

    DbgPrint("\n    cjThis           = %-#8lx", pfdg->cjThis);
    DbgPrint("\n    flAccel          = %-#8lx", pfdg->flAccel);
    DbgPrint("\n    cGlyphsSupported = %d",     pfdg->cGlyphsSupported);
    DbgPrint("\n    cRuns            = %d",     pfdg->cRuns);

    for (
        WCRUN *pwcr = pfdg->awcrun;
        pwcr < pfdg->awcrun + pfdg->cRuns;
        pwcr++
        )
    {
        vPrintWCRUN(pwcr);
    }
}

/******************************Public*Routine******************************\
* vPrintOUTLINETEXTMETRIC
*
* History:
*  Tue 08-Dec-1992 11:34:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID
vPrintOUTLINETEXTMETRICW(
    OUTLINETEXTMETRICW *p    )
{
    PANOSE *ppan = &(p->otmPanoseNumber);

    dprintf("    otmSize                = %d\n", p->otmSize                    );
    vPrintTEXTMETRICW(&(p->otmTextMetrics)                            );
    dprintf("    otmFiller              = %-#4x\n", p->otmFiller               );
    dprintf("    otmPanoseNumber        = {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight             );
    dprintf("    otmfsSelection         = %-#8lx\n", p->otmfsSelection         );
    dprintf("    otmfsType              = %-#8lx\n", p->otmfsType              );
    dprintf("    otmsCharSlopeRise      = %d\n"    , p->otmsCharSlopeRise      );
    dprintf("    otmsCharSlopeRun       = %d\n"    , p->otmsCharSlopeRun       );
    dprintf("    otmItalicAngle         = %d\n"    , p->otmItalicAngle         );
    dprintf("    otmEMSquare            = %d\n"    , p->otmEMSquare            );
    dprintf("    otmAscent              = %d\n"    , p->otmAscent              );
    dprintf("    otmDescent             = %d\n"    , p->otmDescent             );
    dprintf("    otmLineGap             = %d\n"    , p->otmLineGap             );
    dprintf("    otmsCapEmHeight        = %d\n"    , p->otmsCapEmHeight        );
    dprintf("    otmsXHeight            = %d\n"    , p->otmsXHeight            );
    dprintf("    otmrcFontBox           = %d %d %d %d\n"
                                                  , p->otmrcFontBox.left
                                                  , p->otmrcFontBox.top
                                                  , p->otmrcFontBox.right
                                                  , p->otmrcFontBox.bottom    );
    dprintf("    otmMacAscent           = %d\n"    , p->otmMacAscent           );
    dprintf("    otmMacDescent          = %d\n"    , p->otmMacDescent          );
    dprintf("    otmMacLineGap          = %d\n"    , p->otmMacLineGap          );
    dprintf("    otmusMinimumPPEM       = %d\n"    , p->otmusMinimumPPEM       );
    dprintf("    otmptSubscriptSize     = %d %d\n" , p->otmptSubscriptSize.x    , p->otmptSubscriptSize.y     );
    dprintf("    otmptSubscriptOffset   = %d %d\n" , p->otmptSubscriptOffset.x  , p->otmptSubscriptOffset.y   );
    dprintf("    otmptSuperscriptSize   = %d %d\n" , p->otmptSuperscriptSize.x  , p->otmptSuperscriptSize.y   );
    dprintf("    otmptSuperscriptOffset = %d %d\n" , p->otmptSuperscriptOffset.x, p->otmptSuperscriptOffset.y );
    dprintf("    otmsStrikeoutSize      = %d\n"    , p->otmsStrikeoutSize        );
    dprintf("    otmsStrikeoutPosition  = %d\n"    , p->otmsStrikeoutPosition    );
    dprintf("    otmsUnderscoreSize     = %d\n"    , p->otmsUnderscoreSize       );
    dprintf("    otmsUnderscorePosition = %d\n"    , p->otmsUnderscorePosition   );


    if (p->otmpFamilyName)
    {
        dprintf(
            "    otmpFamilyName         = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFamilyName)
            );
    }

    if (p->otmpFaceName)
    {
        dprintf(
            "    otmpFaceName           = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFaceName)
            );
    }

    if (p->otmpStyleName)
    {
        dprintf(
            "    otmpStyleName          = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpStyleName)
            );
    }

    if (p->otmpFullName)
    {
        dprintf(
            "    otmpFullName           = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFullName)
            );
    }
}

/******************************Public*Routine******************************\
* vPrintPFE                                                                *
*                                                                          *
* Dumps the contents of a PFE to a specified output routine.               *
*                                                                          *
* History:                                                                 *
*  Sat 06-Jun-1992 21:19:31 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/
#ifdef FONTLINK
extern "C" VOID vPrintQUICKLOOKUP(QUICKLOOKUP *pql)
{
    dprintf("    ql.wcLow  = %-#x\n" , pql->wcLow);
    dprintf("    ql.wcHigh = %-#x\n" , pql->wcHigh);
    dprintf("    ql.puiBits = %-#x\n", pql->puiBits);
}
#endif

extern "C" VOID vPrintPFE(VOID *pv)
{
    PFE *ppfe = (PFE*) pv;
    ULONG *pul = (ULONG *)pv;

    dprintf("    ppfe                 = %-#x\n",ppfe               );
    dprintf("    pPFF                 = %-#x\n",ppfe->pPFF                );
    dprintf("    iFont                = %-#x\n",ppfe->iFont               );
    dprintf("    flPFE                = %-#x\n", ppfe->flPFE              );
    if (ppfe->flPFE & PFE_DEVICEFONT)
    dprintf("                           PFE_DEVICE_FONT\n");
    if (ppfe->flPFE & PFE_DEADSTATE)
    dprintf("                           PFE_DEADSTATE\n");
    if (ppfe->flPFE & PFE_UFIMATCH)
    dprintf("                           PFE_UFIMATCH\n");
#ifdef FONTLINK
    if (ppfe->flPFE & PFE_EUDC)
    dprintf("                           PFE_EUDC\n");
#endif
    if (ppfe->flPFE & ~(PFE_DEVICEFONT | PFE_DEADSTATE
#ifdef FONTLINK
          | PFE_EUDC
#endif
        ))
    dprintf("                           UNKNOWN FLAGS\n");

    dprintf("    pfdg                 = %-#x\n",ppfe->pfdg                );
    dprintf("    idfdg                = %-#x\n",ppfe->idfdg               );
    dprintf("    pifi                 = %-#x\n",ppfe->pifi                );
    dprintf("    idifi                = %-#x\n",ppfe->idifi               );
    dprintf("    pkp                  = %-#x\n",ppfe->pkp                 );
    dprintf("    ckp                  = %-#x\n",ppfe->ckp                 );
    dprintf("    iOrientation         = %-#x\n",ppfe->iOrientation        );

    dprintf("    pgiset               = %-#x\n",ppfe->pgiset              );

    dprintf("    ulTimeStamp          = %-#x\n",ppfe->ulTimeStamp         );

#ifdef FONTLINK
    vPrintQUICKLOOKUP(&(ppfe->ql));
    dprintf("    appfeFaceName        = %-#x\n",ppfe->appfeFaceName);
    dprintf("    bVerticalFace        = %-#x\n",ppfe->bVerticalFace);
#endif
}

/******************************Public*Routine******************************\
* vPrintGLYPHPOS                                                           *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 11:10:03 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintGLYPHPOS(
    const GLYPHPOS *pgpos
  ,       char     *pszLeft
    )
{
    dprintf("%shg   = %-#x\n",   pszLeft, pgpos->hg);
    dprintf("%spgdf = %-#x\n",   pszLeft, pgpos->pgdf);
    dprintf("%sptl  = (%d,%d)\n",pszLeft, pgpos->ptl.x, pgpos->ptl.y);
}

/******************************Public*Routine******************************\
* vPrintESTROBJ                                                            *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 11:09:38 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintESTROBJ(
    ESTROBJ *pso    // pointer to the engine string object
  , PWSZ pwszCopy   // pointer to a copy of the original string
                    //   this is necessary for the extensions
    )
{
    unsigned i,j;
    static char pszBorder[] = "-----------------------------\n\n";

    dprintf("%s",pszBorder);
    dprintf("ESTROBJ located at %-#x\n", pso);
    dprintf("\tcGlyphs     = %d\n", pso->cGlyphs);

    dprintf("\tflAccel     = %-#x\n", pso->flAccel);
    if (SO_FLAG_DEFAULT_PLACEMENT & pso->flAccel)
        dprintf("\t\tSO_FLAG_DEFAULT_PLACEMENT\n");
    if (SO_HORIZONTAL & pso->flAccel)
        dprintf("\t\tSO_HORIZONTAL\n");
    if (SO_VERTICAL & pso->flAccel)
        dprintf("\t\tSO_VERTICAL\n");
    if (SO_REVERSED & pso->flAccel)
        dprintf("\t\tSO_REVERSED\n");
    if (SO_ZERO_BEARINGS & pso->flAccel)
        dprintf("\t\tSO_ZERO_BEARINGS\n");
    if (SO_CHAR_INC_EQUAL_BM_BASE & pso->flAccel)
        dprintf("\t\tSO_CHAR_INC_EQUAL_BM_BASE\n");
    if (SO_MAXEXT_EQUAL_BM_SIDE & pso->flAccel)
        dprintf("\t\tSO_MAXEXT_EQUAL_BM_SIDE\n");

    dprintf("\tulCharInc   = %u\n", pso->ulCharInc);
    dprintf(
           "\trclBkGround = {(%d,%d),(%d,%d)}\n"
      , pso->rclBkGround.left
      , pso->rclBkGround.top
      , pso->rclBkGround.right
      , pso->rclBkGround.bottom
      );
    dprintf("\tpgp         = %-#x\n", pso->pgp        );
    dprintf("\tpwszOrg     = %-#x\n", pso->pwszOrg    );
    if (pwszCopy)
        dprintf("\t              \"%ws\"\n", pwszCopy   );

    dprintf("*** BEGIN GDI EXTENSION ***\n");
    dprintf("\tcgposCopied = %u\n",   pso->cgposCopied);
    dprintf("\tprfo        = %-#x\n", pso->prfo       );
    dprintf("\tflTO        = %-#x\n", pso->flTO);
    if (TO_MEM_ALLOCATED & pso->flTO)
        dprintf("\t\tTO_MEM_ALLOCATED\n");
    if (TO_ALL_PTRS_VALID & pso->flTO)
        dprintf("\t\tTO_ALL_PTRS_VALID\n");
    if (TO_VALID & pso->flTO)
        dprintf("\t\tTO_VALID\n");
    if (TO_ESC_NOT_ORIENT & pso->flTO)
        dprintf("\t\tTO_ESC_NOT_ORIENT\n");
    if (TO_PWSZ_ALLOCATED & pso->flTO)
        dprintf("\t\tTO_PWSZ_ALLOCATED\n");
    if (TO_HIGHRESTEXT & pso->flTO)
        dprintf("\t\tTO_HIGHRESTEXT\n");

    dprintf("\tpgpos       = %-#x\n", pso->pgpos);

    dprintf(
           "\tptfxRef     = (%-#x,%-#x)\n"
      , pso->ptfxRef.x
      , pso->ptfxRef.y
        );
    dprintf(
        "\tptfxUpdate  = (%-#x,%-#x)\n"
      , pso->ptfxUpdate.x
      , pso->ptfxUpdate.y
        );
    dprintf(
        "\tptfxEscapement  = (%-#x,%-#x)\n"
      , pso->ptfxEscapement.x
      , pso->ptfxEscapement.y
        );
    dprintf("\trcfx        = {(%-#x,%-#x)\t(%-#x,%-#x)}\n"
      , pso->rcfx.xLeft
      , pso->rcfx.yTop
      , pso->rcfx.xRight
      , pso->rcfx.yBottom
        );
    dprintf("\tfxExtent    = %-#x\n", pso->fxExtent);
    dprintf("\tcExtraRects = %u\n", pso->cExtraRects);
    if (pso->cExtraRects > 3)
    {
        dprintf("\n\n\t!!! Wow that is a LOT of rectangles !!!\n\n");
        dprintf("\t    I will just print 3, if you don't mind...\n\n\n");
        pso->cExtraRects = 3;
    }

    if (pso->cExtraRects)
    {
        dprintf("\tarclExtra   =\n");
        for (i = 0; i < pso->cExtraRects; i++)
        {
            dprintf("                (%d,%d)\t(%d,%d)\n"
              ,  pso->arclExtra[i].left
              ,  pso->arclExtra[i].top
              ,  pso->arclExtra[i].right
              ,  pso->arclExtra[i].bottom
                );
        }
    }
    dprintf("%s",pszBorder);
}

/******************************Public*Routine******************************\
* vPrintGLYPHBITS                                                          *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 10:58:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintGLYPHBITS(
    GLYPHBITS *pgb,
    char      *pszLeft
    )
{
    BYTE *pj, *pjNext, *pjEnd;
    ptrdiff_t cjScan;


    static char *apszNibble[] =
    {
        "    ", "   *", "  * ", "  **"
      , " *  ", " * *", " ** ", " ***"
      , "*   ", "*  *", "* * ", "* **"
      , "**  ", "** *", "*** ", "****"
    };

    dprintf("%sptlOrigin = (%d,%d)\n"
          , pszLeft
          , pgb->ptlOrigin.x
          , pgb->ptlOrigin.y
                );
    dprintf("%ssizlBitmap = (%d,%d)\n"
          , pszLeft
          , pgb->sizlBitmap.cx
          , pgb->sizlBitmap.cy
            );


    pj     = pgb->aj;
    cjScan = ((ptrdiff_t) pgb->sizlBitmap.cx + 7)/8;
    pjNext = pj + cjScan;
    pjEnd  = pj + cjScan * (ptrdiff_t) pgb->sizlBitmap.cy;

    dprintf("\n\n");

    {
        ptrdiff_t i = cjScan;
        dprintf("%s+",pszLeft);
        while (i--)
            dprintf("--------");
        dprintf("+\n");
    }
    while (pj < pjEnd)
    {
        dprintf("%s|",pszLeft);
        while (pj < pjNext)
        {
            dprintf(
                "%s%s"
              , apszNibble[(*pj >> 4) & 0xf]
              , apszNibble[*pj & 0xf]
              );
              pj += 1;
        }
        pj = pjNext;
        pjNext += cjScan;
        dprintf("|\n");
    }

    {
        ptrdiff_t i = cjScan;
        dprintf("%s+",pszLeft);
        while (i--)
            dprintf("--------");
        dprintf("+\n");
    }
    dprintf("\n\n");
}

/******************************Public*Routine******************************\
* vPrintGLYPHDEF
*
* History:
*  Thu 24-Feb-1994 11:17:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintGLYPHDEF(
    GLYPHDEF *pgdf
  , char     *pszLeft
  )
{    dprintf("%s(pgb|ppo) = %-#x\n", pszLeft, pgdf->pgb);
}

/******************************Public*Routine******************************\
* vPrintGLYPHDATA
*
* History:
*  Tue 17-May-1994 10:24:32 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintGLYPHDATA(
    const GLYPHDATA *pgd
  ,       char     *pszLeft
    )
{
    dprintf("%sgdf           = %-#x\n", pszLeft, pgd->gdf);
    dprintf("%shg            = %-#x\n", pszLeft, pgd->hg);
    dprintf("%sptqD          = (%-#x.%08x,  %-#x.%08x)\n", pszLeft
     , pgd->ptqD.x.HighPart, pgd->ptqD.x.LowPart
     , pgd->ptqD.y.HighPart, pgd->ptqD.y.LowPart
    );
    dprintf("%sfxD           = %-#x\n", pszLeft, pgd->fxD);
    dprintf("%sfxA           = %-#x\n", pszLeft, pgd->fxA);
    dprintf("%sfxAB          = %-#x\n", pszLeft, pgd->fxAB);
    dprintf("%sfxInkTop      = %-#x\n", pszLeft, pgd->fxInkTop);
    dprintf("%sfxInkBottom   = %-#x\n", pszLeft, pgd->fxInkBottom);
    dprintf("%srclInk        = (%-#x, %-#x) (%-#x, %-#x) = (%d, %d) (%d, %d)\n"
        , pszLeft
        , pgd->rclInk.left,  pgd->rclInk.top
        , pgd->rclInk.right, pgd->rclInk.bottom
        , pgd->rclInk.left,  pgd->rclInk.top
        , pgd->rclInk.right, pgd->rclInk.bottom
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\mapfile.h ===
/******************************Module*Header*******************************\
* Module Name: mapfile.h
*
* Created: 26-Oct-1990 18:07:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/


// warning the first two fields of FILEVIEW and FONTFILE view must be
// the same so that they can be used in common routines

typedef struct _FILEVIEW {
    LARGE_INTEGER  LastWriteTime;   // time stamp
            PVOID  pvKView;         // for kernel mode font access
            PVOID  pvViewFD;        // font driver process view of file
            ULONG  cjView;          // size of font file view in bytes
             void *pSection;        // kernel mode pointer to the section object
            BOOL   bLastUpdated;    // Add this for the bug #383101
} FILEVIEW, *PFILEVIEW;

typedef struct _FONTFILEVIEW {
    FILEVIEW  fv;
      LPWSTR  pwszPath;            // path of the file
      SIZE_T  ulRegionSize;        // used by ZwFreeVirtualMemory
       ULONG  cKRefCount;          // kernel mode load count
       ULONG  cRefCountFD;         // font driver load count
       PVOID  SpoolerBase;         // base of spooler's view of spooler section
      W32PID  SpoolerPid;          // spooler pid
} FONTFILEVIEW, *PFONTFILEVIEW;

#define FONTFILEVIEW_bRemote(p) (((FONTFILEVIEW*)(p))->pwszPath==0)

//moved from "engine.h"

typedef struct tagDOWNLOADFONTHEADER
{
    ULONG   Type1ID;          // if non-zero then this is a remote Type1 font
    ULONG   NumFiles;
    ULONG   FileOffsets[1];
}DOWNLOADFONTHEADER,*PDOWNLOADFONTHEADER;


// file mapping


BOOL bMapFile(
        PWSTR pwszFileName,
    PFILEVIEW pfvw,
          INT iFileSize,
        BOOL *pbIsFAT
    );

VOID vUnmapFile( PFILEVIEW pfvw );

INT cComputeGlyphSet(
          WCHAR  *pwc,       // input buffer with a sorted array of cChar supported WCHAR's
           BYTE  *pj,        // input buffer with original ansi values
            INT   cChar,
            INT   cRuns,     // if nonzero, the same as return value
    FD_GLYPHSET  *pgset      // output buffer to be filled with cRanges runs
    );

INT cUnicodeRangesSupported(
      INT  cp,          // code page, not used for now, the default system code page is used
      INT  iFirstChar,  // first ansi char supported
      INT  cChar,       // # of ansi chars supported, cChar = iLastChar + 1 - iFirstChar
    WCHAR *pwc,         // input buffer with a sorted array of cChar supported WCHAR's
     BYTE *pj
    );

// size of glyphset with runs and glyph handles appended at the bottom

#define SZ_GLYPHSET(cRuns, cGlyphs) \
   (offsetof(FD_GLYPHSET,awcrun)    \
 + sizeof(WCRUN)*(cRuns)            \
 + sizeof(HGLYPH)*(cGlyphs))

//
// WINBUG #83140 2-7-2000 bhouse Investgate removal of vToUNICODEN macro
// Old Comment:
//   - bogus macro that we need to remove.
//

#define vToUNICODEN( pwszDst, cwch, pszSrc, cch )                               \
    {                                                                           \
        EngMultiByteToUnicodeN((LPWSTR)(pwszDst),(ULONG)((cwch)*sizeof(WCHAR)), \
               (PULONG)NULL,(PSZ)(pszSrc),(ULONG)(cch));                        \
        (pwszDst)[(cwch)-1] = 0;                                                \
    }


typedef struct _CP_GLYPHSET {
    UINT                 uiRefCount;      // Number of references to this FD_GLYPHSET
    UINT                 uiFirstChar;     // First char supported
    UINT                 uiLastChar;      // Last char supported
    BYTE                 jCharset;        // charset
    struct _CP_GLYPHSET *pcpNext;         // Next element in list
    FD_GLYPHSET          gset;            // The actual glyphset

} CP_GLYPHSET;


CP_GLYPHSET
*pcpComputeGlyphset(
    CP_GLYPHSET **pcpHead,
    UINT         uiFirst,
    UINT         uiLast,
    BYTE         jCharSet
    );

VOID
vUnloadGlyphset(
    CP_GLYPHSET **pcpHead,
    CP_GLYPHSET  *pcpTarget
    );


// needed in font substitutions

// FACE_CHARSET structure represents either value name or the value data
// of an entry in the font substitution section of "win.ini".

// this flag describes one of the old style entries where char set is not
// specified.

#define FJ_NOTSPECIFIED    1

// this flag indicates that the charset is not one of those that the
// system knows about. Could be garbage or application defined charset.

#define FJ_GARBAGECHARSET  2

typedef struct _FACE_CHARSET {
    WCHAR awch[LF_FACESIZE];
     BYTE jCharSet;
     BYTE fjFlags;
} FACE_CHARSET;


VOID vCheckCharSet(FACE_CHARSET *pfcs, const WCHAR * pwsz); // in mapfile.c


#define IS_DBCS_CHARSET(CharSet)  (((CharSet) == DBCS_CHARSET) ? TRUE : FALSE)

#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


#define IS_ANY_DBCS_CODEPAGE( CodePage ) (((CodePage) == 932) ? TRUE :    \
                                          ((CodePage) == 949) ? TRUE :    \
                                          ((CodePage) == 950) ? TRUE :    \
                                          ((CodePage) == 936) ? TRUE : FALSE )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\ht.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ht.h


Abstract:

    This module contains all the public defines, constants, structures and
    functions declarations for accessing the DLL.

Author:

    15-Jan-1991 Tue 21:13:21 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    29-Oct-1991 Tue 14:33:43 updated  -by-  Daniel Chou (danielc)

        1) Change HALFTONEPATTERN data structure.

            a) 'Flags' field from WORD to BYTE
            b) 'MaximumHTDensityIndex' from WORD to BYTE
            c) Change the field order.

        2) Remove ReferenceWhite/ReferenceBlack from HTCOLORADJUSTMENT data
           structure.

        3)

--*/

#ifndef _HT_
#define _HT_

//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif



#ifndef far
#define far
#endif

#ifndef FAR
#define FAR     far
#endif

typedef CHAR FAR                *LPCHAR;
typedef SHORT FAR               *LPSHORT;
typedef UINT FAR                *LPUINT;

//
// The DECI4/UDECI4 is a special number used in halftone DLL, this number
// just like regular short, unsigned short number, except it using lower
// four decimal digits as right side of the decimal point, that is
// 10000 is as 1.0000, and -12345 will be -1.2345.
//

typedef short               DECI4;
typedef unsigned short      UDECI4;
typedef DECI4 FAR           *PDECI4;
typedef UDECI4 FAR          *PUDECI4;

#define DECI4_0             (DECI4)0
#define DECI4_1             (DECI4)10000
#define DECI4_Neg1          (DECI4)-10000
#define UDECI4_0            (UDECI4)0
#define UDECI4_1            (UDECI4)10000


#define SIZE_BYTE           sizeof(BYTE)
#define SIZE_CHAR           sizeof(CHAR)
#define SIZE_WORD           sizeof(WORD)
#define SIZE_SHORT          sizeof(SHORT)
#define SIZE_LONG           sizeof(LONG)
#define SIZE_DWORD          sizeof(DWORD)
#define SIZE_UINT           sizeof(UINT)
#define SIZE_INT            sizeof(INT)
#define SIZE_UDECI4         sizeof(UDECI4)
#define SIZE_DECI4          sizeof(DECI4)

#define COUNT_ARRAY(array)  (sizeof(array) / sizeof(array[0]))

#define B_BITPOS(x)         ((BYTE)(1 << (x)))
#define W_BITPOS(x)         ((WORD)(1 << (x)))
#define DW_BITPOS(x)        ((DWORD)(1 << (x)))
#define BIT_IF(b,t)         (((t)) ? (b) : ((b)-(b)))
#define SET_BIT(x,b)        ((x) |= (b))
#define CLR_BIT(x,b)        ((x) &= ~(b))
#define INV_BIT(x,b)        ((x) ^= (b))
#define HAS_BIT(x,b)        ((x) & (b))


//
// The following are the error return values for the HTHalftoneBitmap() call.
//

#define HTERR_WRONG_VERSION_HTINITINFO      -1
#define HTERR_INSUFFICIENT_MEMORY           -2
#define HTERR_CANNOT_DEALLOCATE_MEMORY      -3
#define HTERR_COLORTABLE_TOO_BIG            -4
#define HTERR_QUERY_SRC_BITMAP_FAILED       -5
#define HTERR_QUERY_DEST_BITMAP_FAILED      -6
#define HTERR_QUERY_SRC_MASK_FAILED         -7
#define HTERR_SET_DEST_BITMAP_FAILED        -8
#define HTERR_INVALID_SRC_FORMAT            -9
#define HTERR_INVALID_SRC_MASK_FORMAT       -10
#define HTERR_INVALID_DEST_FORMAT           -11
#define HTERR_INVALID_DHI_POINTER           -12
#define HTERR_SRC_MASK_BITS_TOO_SMALL       -13
#define HTERR_INVALID_HTPATTERN_INDEX       -14
#define HTERR_INVALID_HALFTONE_PATTERN      -15
#define HTERR_HTPATTERN_SIZE_TOO_BIG        -16
#define HTERR_NO_SRC_COLORTRIAD             -17
#define HTERR_INVALID_COLOR_TABLE           -18
#define HTERR_INVALID_COLOR_TYPE            -29
#define HTERR_INVALID_COLOR_TABLE_SIZE      -20
#define HTERR_INVALID_PRIMARY_SIZE          -21
#define HTERR_INVALID_PRIMARY_VALUE_MAX     -22
#define HTERR_INVALID_PRIMARY_ORDER         -23
#define HTERR_INVALID_COLOR_ENTRY_SIZE      -24
#define HTERR_INVALID_FILL_SRC_FORMAT       -25
#define HTERR_INVALID_FILL_MODE_INDEX       -26
#define HTERR_INVALID_STDMONOPAT_INDEX      -27
#define HTERR_INVALID_DEVICE_RESOLUTION     -28
#define HTERR_INVALID_TONEMAP_VALUE         -29
#define HTERR_NO_TONEMAP_DATA               -30
#define HTERR_TONEMAP_VALUE_IS_SINGULAR     -31
#define HTERR_INVALID_BANDRECT              -32
#define HTERR_STRETCH_RATIO_TOO_BIG         -33
#define HTERR_CHB_INV_COLORTABLE_SIZE       -34
#define HTERR_HALFTONE_INTERRUPTTED         -35
#define HTERR_NO_SRC_HTSURFACEINFO          -36
#define HTERR_NO_DEST_HTSURFACEINFO         -37
#define HTERR_8BPP_PATSIZE_TOO_BIG          -38
#define HTERR_16BPP_555_PATSIZE_TOO_BIG     -39
#define HTERR_INVALID_ABINFO                -40
#define HTERR_INTERNAL_ERRORS_START         -10000


#define COLOR_TYPE_RGB          0
#define COLOR_TYPE_XYZ          1
#define COLOR_TYPE_YIQ          2
#define COLOR_TYPE_MAX          2

#define PRIMARY_ORDER_123       0
#define PRIMARY_ORDER_132       1
#define PRIMARY_ORDER_213       2
#define PRIMARY_ORDER_231       3
#define PRIMARY_ORDER_321       4
#define PRIMARY_ORDER_312       5
#define PRIMARY_ORDER_MAX       5

#define PRIMARY_ORDER_RGB       PRIMARY_ORDER_123
#define PRIMARY_ORDER_RBG       PRIMARY_ORDER_132
#define PRIMARY_ORDER_GRB       PRIMARY_ORDER_213
#define PRIMARY_ORDER_GBR       PRIMARY_ORDER_231
#define PRIMARY_ORDER_BGR       PRIMARY_ORDER_321
#define PRIMARY_ORDER_BRG       PRIMARY_ORDER_312

#define PRIMARY_ORDER_CMY       PRIMARY_ORDER_123
#define PRIMARY_ORDER_CYM       PRIMARY_ORDER_132
#define PRIMARY_ORDER_MCY       PRIMARY_ORDER_213
#define PRIMARY_ORDER_MYC       PRIMARY_ORDER_231
#define PRIMARY_ORDER_YMC       PRIMARY_ORDER_321
#define PRIMARY_ORDER_YCM       PRIMARY_ORDER_312

#define PRIMARY_ORDER_XYZ       PRIMARY_ORDER_123
#define PRIMARY_ORDER_XZY       PRIMARY_ORDER_132
#define PRIMARY_ORDER_YXZ       PRIMARY_ORDER_213
#define PRIMARY_ORDER_YZX       PRIMARY_ORDER_231
#define PRIMARY_ORDER_ZYX       PRIMARY_ORDER_321
#define PRIMARY_ORDER_ZXY       PRIMARY_ORDER_312

#define PRIMARY_ORDER_YIQ       PRIMARY_ORDER_123
#define PRIMARY_ORDER_YQI       PRIMARY_ORDER_132
#define PRIMARY_ORDER_IYQ       PRIMARY_ORDER_213
#define PRIMARY_ORDER_IQY       PRIMARY_ORDER_231
#define PRIMARY_ORDER_QIY       PRIMARY_ORDER_321
#define PRIMARY_ORDER_QYI       PRIMARY_ORDER_312

//
// COLORTRIAD
//
//  This data structure describe the source color informations
//
//  Type                - One of the following type may be specified.
//
//                          COLOR_TYPE_RGB  - primaries are RGB.
//                          COLOR_TYPE_XYZ  - primaries are CIE XYZ.
//                          COLOR_TYPE_YIQ  - primaries are NTSC YIQ.
//
//  BytesPerPrimary     - Specified how many bytes used per primary color, it
//                        must be one of the following
//
//                          1 - BYTE
//                          2 - WORD
//                          4 - DWORD
//
//                        All 3 primaries must be consecutive in memory.
//
//  BytesPerEntry       - Specified how many bytes used for color table entry,
//                        each entry specified 3 primaries colors.
//
//  PrimaryOrder        - The primaries order in the color table, it can be
//                        one of the defined PRIMARY_ORDER_abc, for each entry
//                        in the memory it defined as
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- highest memory location
//                                        ||
//                                        |+--- middle
//                                        |
//                                        +---- Lowest memory location
//
//                        All 3 primaries must be consecutive in memory.
//
//  PrimaryValueMax     - The maximum value for the primary color, this is used
//                        to nomalized the input colors, for example a 8-bit
//                        RGB color table will specified 255.
//
//  ColorTableEntries   - Total entries of the color table pointed by the
//                        pColorTable.
//
//  pColorTable         - Pointer to the start of color table, the size of the
//                        this color table must at least (BytesPerEntry *
//                        ColorTableEntries).
//
//                        If the first primary color in the color table entry
//                        is not at first byte of the pColorTable, then caller
//                        must specified the pColorTable at first primary
//                        color. (pColorTable += Offset(first primary).
//
//

typedef struct _COLORTRIAD {
    BYTE    Type;
    BYTE    BytesPerPrimary;
    BYTE    BytesPerEntry;
    BYTE    PrimaryOrder;
    LONG    PrimaryValueMax;
    DWORD   ColorTableEntries;
    LPVOID  pColorTable;
} COLORTRIAD, FAR *PCOLORTRIAD;


//
// HTSURFACEINFO
//
//  This data structure describe the the input/output surface in order for
//  halftone function to render the output, this data structure only used for
//  the memory device.
//
//  hSurface                - This is 32-bits handle which will be passed back
//                            to the caller's callback function.
//
//  Flags                   - One or more following flags may be defined
//
//                              HTSIF_SCANLINES_TOPDOWN
//
//                                  This flag is ignored
//
//  SurfaceFormat           - Following formats are defined
//
//                              BMF_1BPP
//
//                                  1-bit per pel format, this is the index
//                                  number (0 or 1) for the color table/palette.
//
//                              BMF_4BPP
//
//                                  4-bit per pel and pack two pels to a byte
//                                  starting from high nibble (bit 4-7) format,
//                                  this is the index number (0-7) for the
//                                  color table/palette. (ONLY LOW 3 bits of
//                                  the nibble is used)
//
//                              BMF_4BPP_VGA16
//
//                                  4-bit per pel and pack two pels to a byte
//                                  starting from high nibble (bit 4-7) format,
//                                  this is the index number (0-15) for the
//                                  standard VGA 16 colors table/palette.
//
//                                  The different from BMF_4BPP is this indices
//                                  are fixed to standard VGA 16 colors as
//
//                                      Index#  Colors      Lightness
//                                      ---------------------------------
//                                          0   Black         0%
//                                          1   Red          50%
//                                          2   Green        50%
//                                          3   Yellow       50%
//                                          4   Blue         50%
//                                          5   Magenata     50%
//                                          6   Cyan         50%
//                                          7   Gray         50%
//                                          8   Gray         75%
//                                          9   Red         100%
//                                         10   Green       100%
//                                         11   Yellow      100%
//                                         12   Blue        100%
//                                         13   Magenata    100%
//                                         14   Cyan        100%
//                                         15   White       100%
//
//                                  Notice that the color order is
//
//                                  Bit 2 = Blue, Bit 1 = Green, Bit 0 = Red
//
//                                  This format can only be used as destination
//                                  surface, when used as destination surface
//                                  the halftone dll automatically set it to
//                                  USE_ADDITIVE_PRIMS and set the primaries
//                                  order as PRIMARY_ORDER_BGR.
//
//                              BMF_8BPP
//
//                                  8-bit per pel format (1 byte each), this is
//                                  the index number (0-255) for the color
//                                  table/palette.  The format is not allowed
//                                  for the destination surface.
//
//                              BMF_8BPP_VGA256
//
//                                  8-bit per pel format (1 byte each), this is
//                                  the index number (0-255) for the color
//                                  table/palette.
//
//                                  The different from BMF_8BPP is this indices
//                                  are fixed to halftone special colors.
//
//                                  The color table (palette) is defined by
//                                  halftone.dll, the display should call
//                                  HT_Get8BPPFormatPalette() api call to get
//                                  the current palette used by the halftone.
//
//                                  The HT_GetBPPFormatPalette() will only need
//                                  to called once until next time the display
//                                  caliberation occurred.
//
//                                  Halftone.dll will not used all 256 colors
//                                  in the system palette, it will leave some
//                                  20 or more entries for the system colors.
//
//                              BMF_16BPP
//
//                                  16-bit per pel format (16 bits each), this
//                                  is the index number (0-65535) for the color
//                                  table/palette.  The format is not allowed
//                                  for the destination surface.
//
//                              BMF_16BPP_555
//
//                                  16-bit per pel format (only 15 bits used),
//                                  each primary occupy 5 bits, the layout of
//                                  bits as follow
//
//                                      bit 10-15   - Primary A
//                                      bit  5- 9   - Primary B
//                                      bit  0- 4   - Primary C
//
//                                  The order of the Primary A, B and C is
//                                  specfied by PRIMARY_ORDER_xxx.
//
//                                  for each primary there are 32 gradations,
//                                  and halftone.dll output is assume to be
//                                  linear. (non-gamma corrected), this format
//                                  only allowed for destination surface.
//
//                              BMF_24BPP
//
//                                  24-bit per pel format (8-bit per color),
//                                  the order of RGB color stored in the source
//                                  bitmap or color table.
//
//                              BMF_32BPP
//
//                                  Same as BMF_24BPP but with extra byte
//                                  packing, if the extra byte is packed at
//                                  begining (the first color is starting from
//                                  second byte of that 4 bytes) then caller
//                                  must set the pColorTable = pColorTable + 1
//                                  or set pPlane = pPlane + 1, to skip first
//                                  unused byte.
//
//                              NOTE: Allowed source formats are
//
//                                      1) BMF_1BPP
//                                      2) BMF_4BPP
//                                      3) BMF_8BPP
//                                      4) BMF_16BPP
//                                      5) BMF_24BPP
//                                      6) BMF_32BPP
//
//                                    Allowed destination formats are
//
//                                      1) BMF_1BPP
//                                      2) BMF_4BPP
//                                      3) BMF_4BPP_VGA16
//                                      4) BMF_8BPP_VGA256
//                                      5) BMF_16BPP_555
//
//                                    Any other mismatch cause error returned.
//
//  ScanLineAlignBytes      - Total bytes needed to aligned for each scan line
//                            in the surface bitmap, it can be any unsigned
//                            8-bit number, the common ones are defined as
//
//                                  BMF_ALIGN_BYTE      ( 8-bit aligned)
//                                  BMF_ALIGN_WORD      (16-bit aligned)
//                                  BMF_ALIGN_DWORD     (32-bit aligned)
//                                  BMF_ALIGN_QWORD     (64-bit aligned)
//
//  Width                   - The width of the surface in pels.
//
//  Height                  - The height of the surface in scan lines.
//
//  ScanLineDelta           - Specified scan lines Delta in bytes, this member
//                            indicate how many bytes to be added for advanced
//                            to next scan line
//
//  pPlane                  - This pointer points to the first scan line in
//                            the defined surface, Scan #0 that is.
//
//  pColorTriad             - Pointe to the COLORTRIAD data structure to
//                            specified the source color table, this pointer
//                            only examined by the halftone.dll for source
//                            surface.
//


#if !defined( BMF_DEVICE ) &&     \
    !defined( BMF_1BPP   ) &&     \
    !defined( BMF_4BPP   ) &&     \
    !defined( BMF_8BPP   ) &&     \
    !defined( BMF_16BPP  ) &&     \
    !defined( BMF_24BPP  ) &&     \
    !defined( BMF_32BPP  )

#define BMF_1BPP                        1
#define BMF_4BPP                        2
#define BMF_8BPP                        3
#define BMF_16BPP                       4
#define BMF_24BPP                       5
#define BMF_32BPP                       6

#endif

#define BMF_4BPP_VGA16                  255
#define BMF_8BPP_VGA256                 254
#define BMF_16BPP_555                   253
#define BMF_16BPP_565                   252
#define BMF_HT_LAST                     BMF_16BPP_565


//
// Following are common used alignment bytes for the bitmap
//

#define BMF_ALIGN_BYTE      1                   //  8 bits = 1 byte
#define BMF_ALIGN_WORD      2                   // 16 bits = 2 bytes
#define BMF_ALIGN_DWORD     4                   // 32 bits = 4 bytes
#define BMF_ALIGN_QWORD     8                   // 64 bits = 8 bytes





#define HTSIF_SCANLINES_TOPDOWN         W_BITPOS(0)


typedef struct _HTSURFACEINFO {
    ULONG_PTR   hSurface;
    WORD        Flags;
    BYTE        SurfaceFormat;
    BYTE        ScanLineAlignBytes;
    LONG        Width;
    LONG        Height;
    LONG        ScanLineDelta;
    LPBYTE      pPlane;
    PCOLORTRIAD pColorTriad;
    } HTSURFACEINFO;

typedef HTSURFACEINFO   FAR *PHTSURFACEINFO;


//
// HTCALLBACKPARAMS
//
//  This is structure is used durning the bitmap halftone process to obtains
//  the source or destination bitmap surface pointers.
//
//
//  hSurface                - This is the handle which passed to the
//                            halftone DLL, durning the HTHalftoneBitmap() call,
//                            (in HTSURFACEINFO data structure) it may be
//                            handle to source or destination depends on the
//                            nature of the callback.
//
//  CallBackMode            - Specified the nature of the callback.
//
//                              HTCALLBACK_QUERY_SRC
//
//                                  The callback is quering the source bitmap
//                                  pointer.
//
//                              HTCALLBACK_QUERY_SRC_MASK
//
//                                  The callback is quering the source mask
//                                  bitmap pointer.
//
//                              HTCALLBACK_QUERY_DEST
//
//                                  The callback is quering the destination
//                                  bitmap pointer(s).
//
//                              HTCALLBACK_SET_DEST
//
//                                  The callback is used to release halftoned
//                                  destination.   It will called in following
//                                  conditions:
//
//                                      1) Before HTCALLBACK_QUERY_DEST call
//                                         except for the very first query
//                                         destination.
//
//                                      2) After the halftone process is
//                                         completed.  This give the chance for
//                                         the caller to process the last
//                                         halftoned destination block.
//
//  SurfaceFormat           - This is the surface format specified in the
//                            original HTSURFACEINFO.
//
//  Flags                   - This is the copy of HTSURFACEINFO.Flags.
//
//  BytesPerScanLine        - This is the total bytes per scan line for the
//                            surface bitmap which computed by the halftone
//                            DLL according to the 'ScanLineAlignBytes' in the
//                            HTSURFACEINFO data structure, it can be used by
//                            the caller to calculate source/destination
//                            pointers information.
//
//  ScanStart               - Requested starting scan line number, the scan
//                            lines are number from 0 up, this number will
//                            guaranteed has following propertites:
//
//                              1) It always greater than or equal to zero.
//                              2) It will never greater than or equal to the
//                                 'height' field specified in the
//                                 HTSURFACEINFO.
//
//                                 NOTE: for banding destination surface it
//                                       will never greater than or equal to
//                                       the (rclBand.bottom - rclBand.top).
//
//                              3) The scan line number 0 always refer to the
//                                 physical lowest bitmap memory location
//                                 regardless HTSIF_SCANLINES_TOPDOWN flag set
//                                 or not, durning callback the caller only
//                                 need to compute array like bitmap buffer,
//                                 halftone DLL will compute the correct
//                                 ScanStart if the bitmap is not TOPDOWN.
//
//  ScanCount               - Total scan lines requested starting from
//                            ScanStart, this number will guaranteed has
//                            following propertites:
//
//                              1) It always greater than zero.
//                              2) Never greater then the MaximumQueryScanLines
//                                 specified for the surface (in HTSURFACEINFO
//                                 data structure).
//
//                                 NOTE: for banding destination surface it
//                                       will never greater than the
//                                       (rclBand.bottom - rclBand.top).
//
//                            NOTE: 1) ScanStart/ScanCount
//
//                                     If the flags HTSURFACEINFO data
//                                     structure HTSIF_SCANLINES_TOPDOWN is not
//                                     specified then halftone DLL automatically
//                                     calculate the correct ScanStart/ScanCount
//                                     for read/write the up-side-down bitmap.
//
//                                     For example:
//
//                                     If the surface bitmap is up-side-down
//                                     type DIB) and has 100 scan lines height
//                                     (scan line #99 is the top of the bitmap),
//                                     if halftone DLL need to get to scan line
//                                     10-14 (Start from scan line 10 and 5
//                                     lines) then halftone DLL will flip Y,
//                                     and passed ScanStart = 85 and ScanCount
//                                     = 5, but if the HTSIF_SCANLINES_TOPDOWN
//                                     flag is set (Non DIB type format) then
//                                     callback parameters will then be
//                                     ScanStart = 10 and ScanCount = 5.
//
//                                  2) The ScanStart for the callback function
//                                     always consider the lowest bitmap in the
//                                     memory as scan line 0, that is when
//                                     callback fucntion received control, it
//                                     only need to consider the ScanStart as
//                                     physical scan line location which the
//                                     Scan line #0 always starting from lowest
//                                     bitmap memory location.
//
//                                  3) The width of the destination buffer is
//                                     considered as 'Width' field specified
//                                     for the destination HTSURFACEINFO, if
//                                     destination is BANDed (horizontal or
//                                     vertical) then its width is computed as
//                                     Band.right - Band.left. and the result
//                                     always Band.left/Band.top aligned.
//
//                                  4) If caller return 'ScanCount' diff from
//                                     the one requested then caller must check
//
//                                      HTSIF_SCANLINES_TOPDOWN flag is SET
//
//                                          1. Process 'ScanStart' and
//                                             'ScanCount' fields as normal.
//
//                                          2. Set New ScanCount to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanCount)
//
//
//                                      HTSIF_SCANLINES_TOPDOWN flag is CLEAR
//
//                                          1. Re-compute 'ScanStart' before
//                                             compute pPlane as
//
//                                             ScanStart = ScanStart -
//                                                         (NewScanCount -
//                                                          RequsetedScanCount)
//
//                                          2. Process 'ScanStart' and
//                                             'ScanCount' fields as normal.
//
//                                          3. Set New ScanStart to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanStart)
//
//                                          4. Set New ScanCount to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanCount)
//
//                                      The returned new 'ScanCount' must not
//                                      greater then the 'RemainedSize' field.
//
//  MaximumQueryScanLines   - This is the copy of the MaximumQueryScanLines
//                            field from the HTSURFACEINFO data structure which
//                            passed to the the HT_HaltoneBitmap() calls.
//                            Depends on the nature of the callback, it may be
//                            source or destination.
//
//                            NOTE: for banding surface, it will be limited to
//                                  (rclBand.bottom - rclBand.top) if it is
//                                  greater than that number.
//
//  RemainedSize            - This field specified how many scan lines remained
//                            to be queried, the remainded scan lines are not
//                            include current call.
//
//  pPlane                  - pointer points to the begining of first plane of
//                            the surface.  If the callback is quering the
//                            source then this is the only pointer which need
//                            to be updated by the callback function.
//
//                              NOTE: The pPlane must points to the first byte
//                                    of the 'ScanStart' scan line number.
//
//  Field(s) returned from callback
//
//  1) HTCALLBACK_QUERY_SRC         - pPlane (Options: ScanStart/ScanCount)
//  2) HTCALLBACK_QUERY_SRC_MASK    - pPlane (Options: ScanStart/ScanCount)
//  2) HTCALLBACK_QUERY_DEST        - pPlane (Options: ScanStart/ScanCount)
//  4) HTCALLBACK_SET_DEST          - none.
//


#define HTCALLBACK_QUERY_SRC            0
#define HTCALLBACK_QUERY_SRC_MASK       1
#define HTCALLBACK_QUERY_DEST           2
#define HTCALLBACK_SET_DEST             3
#define HTCALLBACK_MODE_MAX             HTCALLBACK_SET_DEST

typedef struct _HTCALLBACKPARAMS {
    ULONG_PTR    hSurface;
    BYTE        CallBackMode;
    BYTE        SurfaceFormat;
    WORD        Flags;
    LONG        BytesPerScanLine;
    LONG        ScanStart;
    WORD        ScanCount;
    WORD        MaximumQueryScanLines;
    LONG        RemainedSize;
    LPBYTE      pPlane;
    } HTCALLBACKPARAMS;

typedef HTCALLBACKPARAMS    FAR *PHTCALLBACKPARAMS;


//
// _HTCALLBACKFUNC
//
//  The callback function is used to obtain the source and/destination bitmap
//  surface durning the halftone process, the halftone DLL will using call
//  back function is following sequences.
//
//      1) Callback to obtain block of the source bitmap, it depensds on
//         the maximum query scan lines limit by the caller. (in HTSURFACEINFO)
//
//      3) Callback to obtain block of the destination bitmap, it depends on
//         the maximum query scan lines limit by the caller. (in HTSURFACEINFO)
//
//      4) Repeat 1), 2), 3) until destination maximum queried scan lines are
//         processed then callback to the caller to release the processed
//         destination.
//
//      5) Repat 1), 2), 3) and 4) unitil all source/destination scan lines are
//         processed.
//
//  The return value of the callback is a boolean value, if false the halftone
//  processed is interrupted and an erro code is returned, if callback function
//  return true then halftone DLL assume that all queried scan lines are
//  reachable by the return pointer (in the HTCALLBACKPARAMS data structure).
//
//  NOTE: 1) If the callback function query for 100 lines and return value is
//           ture then there must all 100 scan lines can be accessable by the
//           halftone dll through the pointer(s).
//
//        2) If the caller has all the bitmap in the memory it should set the
//           maximum query scan lines count to the bitmap height to reduced the
//           callback calls.
//
//        3) If the caller do not need to released the halftoned destination
//           then it should not set the HTCBPF_NEED_SET_DEST_CALLBACK flag
//           to reduces callback calls.
//
// The callback function must be
//
//  1) Must return a 16-bit 'BOOLEAN' (TRUE/FALSE)
//  2) Must 32-bit far function
//  3) _loadds if you using your data segment at all from callback fuction
//

typedef BOOL (APIENTRY *_HTCALLBACKFUNC)(PHTCALLBACKPARAMS pHTCBParams);
#define HTCALLBACKFUNCTION  BOOL APIENTRY


//
// HALFTONEPATTERN
//
//  The HALFTONEPATTERN data structure is used to describe the halftone
//  pattern which will be used by a particular device, if the device choosed
//  to used halftone DLL's default pattern then following data structure will
//  be automatically calculated by the halftone DLL.
//
//  Flags                   - Various halftone flags for the cell, can be one
//                            of the following:
//
//  Width                   - Specified the width of the pattern in pels, this
//                            field must not greater than MAX_HTPATTERN_WIDTH.
//
//  Height                  - Specified the Width of the pattern in scan line,
//                            this field only must not greater than
//                            MAX_HTPATTERN_HEIGHT.
//
//  pHTPatA
//  pHTPatB
//  pHTPatC                 - Specified caller defined pattern. The data items
//                            points by these pointer must have minimum of
//                            (Width * Height) bytes.
//
//                            These are the pointers to BYTE array contains
//                            threshold data, the size of the array must be
//                            'Width * Height' in bytes.  The data in the
//                            array should range from 1 to 255, a zero (0)
//                            indicate the pixel location is ignored.
//
//                            All thresholds values are indicate additive
//                            intensities, a zero indicate black pixel always.
//                            a 255 threshold value indicate the pixel always
//                            turn on to white.
//
//                            Halftone DLL use this thresholds array with
//                            device X, Y, PEL resolution and specified input/
//                            output relationship to compute color
//                            transformation
//


#define MAX_HTPATTERN_WIDTH         256
#define MAX_HTPATTERN_HEIGHT        256

//
// Following are the predefined halftone pattern sizes for 'HTPatternIndex'
//

#define HTPAT_SIZE_2x2              0
#define HTPAT_SIZE_2x2_M            1
#define HTPAT_SIZE_4x4              2
#define HTPAT_SIZE_4x4_M            3
#define HTPAT_SIZE_6x6              4
#define HTPAT_SIZE_6x6_M            5
#define HTPAT_SIZE_8x8              6
#define HTPAT_SIZE_8x8_M            7
#define HTPAT_SIZE_10x10            8
#define HTPAT_SIZE_10x10_M          9
#define HTPAT_SIZE_12x12            10
#define HTPAT_SIZE_12x12_M          11
#define HTPAT_SIZE_14x14            12
#define HTPAT_SIZE_14x14_M          13
#define HTPAT_SIZE_16x16            14
#define HTPAT_SIZE_16x16_M          15
#define HTPAT_SIZE_SUPERCELL        16
#define HTPAT_SIZE_SUPERCELL_M      17
#define HTPAT_SIZE_USER             18
#define HTPAT_SIZE_MAX_INDEX        HTPAT_SIZE_USER
#define HTPAT_SIZE_DEFAULT          HTPAT_SIZE_SUPERCELL_M


typedef struct _HALFTONEPATTERN {
    WORD    cbSize;
    WORD    Flags;
    WORD    Width;
    WORD    Height;
    LPBYTE  pHTPatA;
    LPBYTE  pHTPatB;
    LPBYTE  pHTPatC;
    } HALFTONEPATTERN, FAR *PHALFTONEPATTERN;


//
// CIECOORD
//
//  This data structure defined a C.I.E color space coordinate point, the
//  coordinate is in DECI4 format.
//
//  x   - x coordinate in C.I.E color space
//
//  y   - y coordinate in C.I.E color space.
//
//  Y   - The liminance for the color
//
//

#define CIE_x_MIN   (UDECI4)10
#define CIE_x_MAX   (UDECI4)8000
#define CIE_y_MIN   (UDECI4)10
#define CIE_y_MAX   (UDECI4)8500

typedef struct _CIECOORD {
    UDECI4  x;
    UDECI4  y;
    UDECI4  Y;
    } CIECOORD;

typedef CIECOORD FAR *PCIECOORD;


//
// CIEINFO
//
//  This data structure describe the red, green, blue, cyan, magenta, yellow
//  and alignment white coordinate in the C.I.E color space plus the Luminance
//  factor, these are used to calculate the C.I.E. transform matrix and its
//  inversion.
//
//  Red             - Red primary color in CIRCOORD format.
//
//  Green           - Green primary color in CIRCOORD format.
//
//  Blue            - Blue primary color in CIRCOORD format.
//
//  Cyan            - Cyan primary color in CIRCOORD format.
//
//  Magenta         - Magenta primary color in CIRCOORD format.
//
//  Yellow          - Yellow primary color in CIRCOORD format.
//
//  AlignmentWhite  - Alignment white in CIECOORD format.
//


typedef struct _CIEINFO {
    CIECOORD    Red;
    CIECOORD    Green;
    CIECOORD    Blue;
    CIECOORD    Cyan;
    CIECOORD    Magenta;
    CIECOORD    Yellow;
    CIECOORD    AlignmentWhite;
    } CIEINFO;

typedef CIEINFO FAR *PCIEINFO;

//
// SOLIDDYESINFO
//
//  This data structure specified device cyan, magenta and yellow dyes
//  concentration.
//
//  MagentaInCyanDye    - Mangenta component proportion in Cyan dye.
//
//  YellowInCyanDye     - Yellow component proportion in Cyan dye.
//
//  CyanInMagentaDye    - Cyan component proportion in Magenta dye.
//
//  YellowInMagentaDye  - Yellow component proportion in Magenta dye.
//
//  CyanInYellowDye     - Yellow component proportion in Cyan dye.
//
//  MagentaInYellowDye  - Magenta component proportion in Cyan dye.
//
//      NOTE: all fields in this data structure is UDECI4 number, range from
//            UDECI4_0 to UDECI_4, ie,; 0.0 to 1.0, this a inpurity proportion
//            percentge in primary dye, for example a MagentaInCyanDye=1200
//            mean a 0.12% of magenta component is in device Cyan dye.
//

typedef struct _SOLIDDYESINFO {
    UDECI4  MagentaInCyanDye;
    UDECI4  YellowInCyanDye;
    UDECI4  CyanInMagentaDye;
    UDECI4  YellowInMagentaDye;
    UDECI4  CyanInYellowDye;
    UDECI4  MagentaInYellowDye;
    } SOLIDDYESINFO, FAR *PSOLIDDYESINFO;


//
// HTCOLORADJUSTMENT
//
//  This data structure is a collection of the device color adjustments, it
//  can be changed at any calls.
//
//  Flags                       - CLRADJF_NEGATIVE
//
//                                  Produced negative picture
//
//                                CLRADJF_LOG_FILTER
//
//                                  Specified a relative logarithm should
//                                  used to calculate the final density.
//
//  IlluminantIndex             - Specified the default illuminant of the light
//                                source which the object will be view under.
//                                The predefined value has ILLUMINANT_xxxx
//                                form.
//
//  RedPowerGamma               - The n-th power applied to the red color
//                                before any other color tramsformations,
//                                this is an UDECI4 value.
//
//                                  For example if the RED = 0.8 (DECI4=8000)
//                                  and the RedPowerGammaAdjustment = 0.7823
//                                  (DECI4 = 7823) then the red is equal to
//
//                                         0.7823
//                                      0.8        = 0.8398
//
//  GreenPowerGamma             - The n-th power applied to the green color
//                                before any other color transformations, this
//                                is an UDECI4 value.
//
//  BluePowerGamma              - The n-th power applied to the blue color
//                                before any other color transformations, this
//                                is an UDECI4 value.
//
//                      NOTE: RedPowerGamma/GreenPowerGamma/BluePoweGamma are
//                            UDECI4 values and range from 100 to 65535 if any
//                            one of these values is less than 100 (0.01) then
//                            halftone dll automatically set all power gamma
//                            adjustments to selected default.
//
//  ReferenceBlack              - The black shadow reference for the colors
//                                passed to the halftone dll,  if a color's
//                                lightness is darker than the reference black
//                                then halftone dll will treated as completed
//                                blackness and render it with device maximum
//                                density.
//
//  ReferenceWhite              - The white hightlight reference for the colors
//                                passed to the halftone dll, if a color's
//                                lightness is lighter than the reference white
//                                then halftone will treated as a specular
//                                hightlight and redner with device maximum
//                                intensity.
//
//                      NOTE:   ReferenceBlack Range:  0.0000 - 0.4000
//                              ReferenceWhite Range:  0.6000 - 1.0000
//
//  Contrast                    - Primary color contrast adjustment, this is
//                                a SHORT number range from -100 to 100, this
//                                is the black to white ratio, -100 is the
//                                lowest contrast, 100 is the highest and 0
//                                indicate no adjustment.
//
//  Brightness                  - The brightness adjustment, this is a SHORT
//                                number range from -100 to 100, the brightness
//                                is adjusted by apply to change the overall
//                                saturations for the image, -100 is lowest
//                                brightness, 100 is the hightest and a zero
//                                indicate no adjustment.
//
//  Colorfulness                - The primary color are so adjusted that it
//                                will either toward or away from black/white
//                                colors, this is a SHORT number range from
//                                -100 to 100.  -100 has less colorful, 100 is
//                                most colorfull, and a zero indicate no
//                                adjustment.
//
//  RedGreenTint                - Tint adjustment between Red/Green primary
//                                color, the value is a SHORT range from -100
//                                to 100, it adjust color toward Red if number
//                                is positive, adjust toward Green if number
//                                is negative, and a zero indicate no
//                                adjustment.
//
//  NOTE: For Contrast/Brightness/Colorfulness/RedGreenTint adjustments, if its
//        value is outside of the range (-100 to 100) then halftone DLL
//        automatically set its to selected default value.
//

#ifndef _WINGDI_

// in WinGDI.H
//
// The following are predefined alignment white for 'IlluminantIndex'.
//
// If ILLUMINANT_DEFAULT is specified
//
//  1) if pDeviceCIEInfo is NULL or pDeviceCIEInfo->Red.x eqaul to 0 then
//     halftone DLL automatically choosed approx. illuminant for the output
//     device.
//
//  2) if pDeviceCIEInfo is NOT null and pDeviceCIEInf->Red.x not equal to 0
//     then the 'White' field is used as illuminant alignment white.
//
// If other ILLUMINANT_xxxx is specified it will be used as alignment white
// even pDeviceCIEInfo is not null.
//
// If the IlluminantIndex is > ILLUMINANT_MAX_INDEX then halftone DLL will
// automatically choosed approx. illuminant even pDeviceCIEInfo is not NULL.
//

#define ILLUMINANT_DEVICE_DEFAULT   0
#define ILLUMINANT_A                1
#define ILLUMINANT_B                2
#define ILLUMINANT_C                3
#define ILLUMINANT_D50              4
#define ILLUMINANT_D55              5
#define ILLUMINANT_D65              6
#define ILLUMINANT_D75              7
#define ILLUMINANT_F2               8
#define ILLUMINANT_MAX_INDEX        ILLUMINANT_F2

#define ILLUMINANT_TUNGSTEN         ILLUMINANT_A
#define ILLUMINANT_DAYLIGHT         ILLUMINANT_C
#define ILLUMINANT_FLUORESCENT      ILLUMINANT_F2
#define ILLUMINANT_NTSC             ILLUMINANT_C

#endif


#define MIN_COLOR_ADJ               COLOR_ADJ_MIN
#define MAX_COLOR_ADJ               COLOR_ADJ_MAX
#define MIN_POWER_GAMMA             RGB_GAMMA_MIN

#define NTSC_POWER_GAMMA            (UDECI4)22000

//
// The following is the default value
//


#define REFLECT_DENSITY_DEFAULT     REFLECT_DENSITY_LOG
#define ILLUMINANT_DEFAULT          0
#define HT_DEF_RGB_GAMMA            UDECI4_1
#define REFERENCE_WHITE_DEFAULT     UDECI4_1
#define REFERENCE_BLACK_DEFAULT     UDECI4_0
#define CONTRAST_ADJ_DEFAULT        0
#define BRIGHTNESS_ADJ_DEFAULT      0
#define COLORFULNESS_ADJ_DEFAULT    0
#define REDGREENTINT_ADJ_DEFAULT    0


#define CLRADJF_NEGATIVE            CA_NEGATIVE
#define CLRADJF_LOG_FILTER          CA_LOG_FILTER

#define CLRADJF_FLAGS_MASK          (CLRADJF_NEGATIVE       |   \
                                     CLRADJF_LOG_FILTER)

#ifndef _WINGDI_

//
// In WinGDI.H
//

#define REFERENCE_WHITE_MIN         (UDECI4)6000
#define REFERENCE_WHITE_MAX         UDECI4_1

#define REFERENCE_BLACK_MIN         UDECI4_0
#define REFERENCE_BLACK_MAX         (UDECI4)4000

typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, FAR *LPCOLORADJUSTMENT;

#endif

#define HTCOLORADJUSTMENT COLORADJUSTMENT
typedef HTCOLORADJUSTMENT *PHTCOLORADJUSTMENT;

//
// HTINITINFO
//
//  This data structure is a collection of the device characteristics and
//  will used by the halftone DLL to carry out the color composition for the
//  designated device.
//
//  Version                 - Specified the version number of HTINITINFO data
//                            structure. for this version it should set to the
//                            HTINITINFO_VERSION
//
//  Flags                   - Various flag defined the initialization
//                            requirements.
//
//                              HIF_SQUARE_DEVICE_PEL
//
//                                  Specified that the device pel is square
//                                  rather then round object.  this only make
//                                  differences when the field
//                                  'PelResolutionRatio' is greater than 0.01
//                                  and it is not 1.0000.
//
//                              HIF_HAS_BLACK_DYE
//
//                                  Indicate the device has separate black dye
//                                  instead of mix cyan/magenta/yellow dyes to
//                                  procduced black, this flag will be ignored
//                                  if HIF_ADDITIVE_PRIMS is defined.
//
//                              HIF_ADDITIVE_PRIMS
//
//                                  Specified that final device primaries are
//                                  additively, that is adding device primaries
//                                  will produce lighter result. (this is true
//                                  for monitor devices and certainly false for
//                                  the reflect devices such as printers).
//
//                              HIF_USE_8BPP_BITMASK
//
//                                  Specified use CMYBitMask8BPP field is used,
//                                  when destination surface is BMF_8BPP_VGA256
//                                  see CMYBitMask8BPP field for more detail
//
//                              HIF_INVERT_8BPP_BITMASK_IDX
//                                  Render the 8bpp mask mode with inversion of
//                                  its indices.  This is implemented for fix
//                                  Windows GDI rop problem, it will render as
//                                  RGB additive indices.  The caller must
//                                  do a inversion of final image's Indices
//                                  (Idx = ~Idx or Idx ^= 0xFF) to get the
//                                  correct CMY332 data.   When this bit is
//                                  set, the HT_Get8BPPMaskPalette must have
//                                  its pPaletteEntry[0] Initialized to as
//
//                                      pPaletteEntry[0].peRed   = 'R';
//                                      pPaletteEntry[0].peGreen = 'G';
//                                      pPaletteEntry[0].peBlue  = 'B';
//                                      pPaletteEntry[0].peFlags = '0';
//
//                                  to indicate that a RGB indices inverted
//                                  palette should be returned and not the
//                                  standard CMY palette (Index 0 is white and
//                                  Index 255 is black).
//
//                                  The inverted palette has is first entry as
//                                  BLACK and last entry as WHITE
//
//                                      pPaletteEntry[0].peRed   = 0x00;
//                                      pPaletteEntry[0].peGreen = 0x00;
//                                      pPaletteEntry[0].peBlue  = 0x00;
//                                      pPaletteEntry[0].peFlags = 0x00;
//
//                                  Notice that this setting WILL NOT work on
//                                  earlier version of halftone (Windows 2000
//                                  and earlier), so the caller must check the
//                                  OS version or check the returned palette
//                                  to ensure that first palette entry is
//                                  BLACk rather than WHITE.   If first
//                                  entries is WHITE after initialized to
//                                  'R', 'G', 'B', '0' then this is a older
//                                  version of system that does not recongnized
//                                  the initialzed value. In this case the
//                                  caller should not invert (Idx ^= 0xFF) the
//                                  halftoned imaged indices when render it
//                                  to the devices, because the halftone
//                                  images in this case is CMY based already.
//
//
//  HTPatternIndex          - Default halftone pattern index number, the
//                            indices is predefine as HTPAT_SIZE_xxxx, this
//                            field only used if pHTalftonePattern pointer is
//                            not NULL.
//
//  DevicePowerGamma        - This field is used to adjust halftone pattern
//                            cell's gamma, the gamma applied to all the rgb
//                            colors, see gamma description in
//                            HTCOLORADJUSTMENT above.
//
//  HTCallBackFunction      - a 32-bit pointer to the caller supplied callback
//                            function which used by the halftone DLL to
//                            obtained the source/destination bitmap pointer
//                            durning the halftone process, if this pointer is
//                            NULL then halftone dll assume that caller does
//                            not need any callback and generate an error if a
//                            callback is needed.
//
//  pHalftonePattern        - pointer to HALFTONEPATTERN data structure, see
//                            descriptions above, if this pointer is NULL then
//                            halftone using HTPatternIndex field to select
//                            default halftone dll's pattern.
//
//  pInputRGBInfo           - Specified input's rgb color' coordinates within
//                            the C.I.E. color spaces.  If this pointer is NULL
//                            or pInputRGBInfo->Red.x is 0 (UDECI4_0) then it
//                            default using NTSC standard to convert the input
//                            colors.
//
//  pDeviceCIEInfo          - Specified device primary color coordinates within
//                            the C.I.E. color space, see CIEINFO data
//                            structure, if the pointer is NULL or
//                            pDeviceCIEInfo->Red.x is 0 (UDECI4_0) then
//                            halftone DLL choose the default for the output
//                            device.
//
//  pDeviceSolidDyesInfo    - Specified device solid dyes concentrations, this
//                            field will be ignored if HIF_ADDITIVE_PRIMS flag
//                            is defined, if HIF_ADDITIVE_PRIMS is not set and
//                            this pointer is NULL then halftone dll choose
//                            approximate default for the output device.
//
//  DeviceResXDPI           - Specified the device horizontal (x direction)
//                            resolution in 'dots per inch' measurement.
//
//  DeviceResYDPI           - Specified the device vertical (y direction)
//                            resolution in 'dots per inch' measurement.
//
//  DevicePelsDPI           - Specified the device pel/dot/nozzle diameter
//                            (if rounded) or width/height (if squared) in
//                            'dots per inch' measurement.
//
//                            This value is measure as if each pel only touch
//                            each other at edge of the pel.
//
//                            If this value is 0, then it assume that each
//                            device pel is rectangular shape and has
//                            DeviceResXDPI in X direction and DeviceResYDPI
//                            in Y direction.
//
//  DefHTColorAdjustment    - Specified the default color adjustment for
//                            this device.  see HTCOLORADJUSTMENT data
//                            structure above for detail.
//
//  DeviceRGamma
//  DeviceGGamma
//  DeviceBGamma            - Red, Green, Blue gammas for the device
//
//  CMYBitMask8BPP          - only used for the BMF_8BPP_VGA256 destination
//                            surface.  It indicate the how the device surface
//                            color are translated, when HTF_USE_8BPP_BITMASK
//                            bit is turn on, this byte is the CYAN. MAGENTA
//                            YELLOW dye levels indicator.
//
//                            This byte indicate how many levels for each cyan,
//                            magenta and yellow color, and this is how the
//                            halftone write to the destination surface.
//
//
//                              Bit     7 6 5 4 3 2 1 0
//                                      |   | |   | | |
//                                      +---+ +---+ +=+
//                                        |     |    |
//                                        |     |    +-- Yellow 0-3 (4 levels)
//                                        |     |
//                                        |     +-- Magenta 0-7 (8 levels)
//                                        |
//                                        +-- Cyan 0-7 (8 levels)
//
//
//                             The maximum in the bits configuration is 3:3:2,
//                             Other invalid combination generate different
//                             output as
//
//                              0   - Indicate a gray scale output, the output
//                                    byte is a 0-255 of 256 levels gray
//
//                              1   - a 5x5x5 cube output, each cyan, magenta
//                                    and yellow color are 0-4 of 5 levels and
//                                    each color is in 25% increment.
//
//                              2   - a 6x6x6 cube output, each cyan, magenta
//                                    and yellow color are 0-5 of 6 levels and
//                                    each color is in 20% increment.
//
//                              Other value that have 0 level in one of cyan,
//                              magenta or yellow will generate an error.
//
//                              To obtain a palette for each of configuration
//                              you can call HT_Get8BPPMaskPalette()
//


#define HTINITINFO_VERSION2         (DWORD)0x48546902   // 'HTi\02'
#define HTINITINFO_VERSION          (DWORD)0x48546903   // 'HTi\03'

#define HTINITINFO_V3_CB_EXTRA      8


#define HIF_SQUARE_DEVICE_PEL       0x0001
#define HIF_HAS_BLACK_DYE           0x0002
#define HIF_ADDITIVE_PRIMS          0x0004
#define HIF_USE_8BPP_BITMASK        0x0008
#define HIF_INK_HIGH_ABSORPTION     0x0010
#define HIF_INK_ABSORPTION_INDICES  0x0060
#define HIF_DO_DEVCLR_XFORM         0x0080
#define HIF_USED_BY_DDI             0x0100
#define HIF_PRINT_DRAFT_MODE        0x0200
#define HIF_INVERT_8BPP_BITMASK_IDX 0x0400

#define HIF_BIT_MASK                (HIF_SQUARE_DEVICE_PEL          |   \
                                     HIF_HAS_BLACK_DYE              |   \
                                     HIF_ADDITIVE_PRIMS             |   \
                                     HIF_USE_8BPP_BITMASK           |   \
                                     HIF_INK_HIGH_ABSORPTION        |   \
                                     HIF_INK_ABSORPTION_INDICES     |   \
                                     HIF_DO_DEVCLR_XFORM            |   \
                                     HIF_PRINT_DRAFT_MODE           |   \
                                     HIF_INVERT_8BPP_BITMASK_IDX)

#define HIF_INK_ABSORPTION_IDX0     0x0000
#define HIF_INK_ABSORPTION_IDX1     0x0020
#define HIF_INK_ABSORPTION_IDX2     0x0040
#define HIF_INK_ABSORPTION_IDX3     0x0060

#define HIF_HIGHEST_INK_ABSORPTION  (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX3)
#define HIF_HIGHER_INK_ABSORPTION   (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX2)
#define HIF_HIGH_INK_ABSORPTION     (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX1)
#define HIF_NORMAL_INK_ABSORPTION   HIF_INK_ABSORPTION_IDX0
#define HIF_LOW_INK_ABSORPTION      (HIF_INK_ABSORPTION_IDX1)
#define HIF_LOWER_INK_ABSORPTION    (HIF_INK_ABSORPTION_IDX2)
#define HIF_LOWEST_INK_ABSORPTION   (HIF_INK_ABSORPTION_IDX3)


#define HTBITMASKPALRGB_DW          (DWORD)'0BGR'
#define SET_HTBITMASKPAL2RGB(pPal)  (*((LPDWORD)(pPal)) = HTBITMASKPALRGB_DW)
#define IS_HTBITMASKPALRGB(pPal)    (*((LPDWORD)(pPal)) == (DWORD)0)


//
// This defined the minimum acceptable device resolutions
//

#define MIN_DEVICE_DPI              12

typedef struct _HTINITINFO {
    DWORD               Version;
    WORD                Flags;
    WORD                HTPatternIndex;
    _HTCALLBACKFUNC     HTCallBackFunction;
    PHALFTONEPATTERN    pHalftonePattern;
    PCIEINFO            pInputRGBInfo;
    PCIEINFO            pDeviceCIEInfo;
    PSOLIDDYESINFO      pDeviceSolidDyesInfo;
    UDECI4              DevicePowerGamma;
    WORD                DeviceResXDPI;
    WORD                DeviceResYDPI;
    WORD                DevicePelsDPI;
    HTCOLORADJUSTMENT   DefHTColorAdjustment;
    UDECI4              DeviceRGamma;
    UDECI4              DeviceGGamma;
    UDECI4              DeviceBGamma;
    BYTE                CMYBitMask8BPP;
    BYTE                bReserved;
    } HTINITINFO, FAR *PHTINITINFO;

//
// BITBLTPARAMS
//
//  This data structure is used when calling the HT_HalftoneBitmap(), it
//  defined where to halftone from the source bitmap to the destination
//  bitmap.
//
//  Flags           - Various flags defined how the source, destination and
//                    source mask should be calculated.
//
//                      BBPF_HAS_DEST_CLIPRECT
//
//                          Indicate that there is a clipping
//                          rectangle for the destination and it is
//                          specified by DestClipXLeft, DestClipXRight,
//                          DestClipYTop and DestClipYBottom
//
//                      BBPF_USE_ADDITIVE_PRIMS
//
//                          Specified if the halftone result will be
//                          using Red/Green/Blue primary color or
//                          using Cyan/Magenta/Yellow primary color, depends
//                          on the destination surface format as
//
//                          BMF_1BPP:
//
//                                  Additive Prims: 0=Black, 1=White
//                              Substractive Prims: 0=White, 1=Black
//
//                          BMF_4BPP_VGA16:
//
//                              Always using RED, GREEN, BLUE primaries, and
//                              ignored this flag.
//
//                          BMF_4BPP:
//
//                                  Additive Prims: RED, GREEN. BLUE
//                              Substractive Prims: CYAN, MAGENTA, YELLOW
//
//                              The order of the RGB, or CMY is specified by
//                              DestPrimaryOrder field. (see below)
//
//                          BMF_8BPP_VGA256:
//                          BMF_16BPP_555:
//                          BMF_16BPP_565:
//                          BMF_24BPP:
//                          BMF_32BPP:
//
//                              Always using RED, GREEN, BLUE primaries, and
//                              ignored this flag.
//
//                      BBPF_NEGATIVE_DEST
//
//                          Invert the final destination surface, so
//                          after the halftone it just the negative
//                          result from the source.
//
//                      BBPF_INVERT_SRC_MASK
//
//                          Invert the source mask bits before using
//                          it, this in effect make mask bit 0 (off)
//                          for copy the source and mask bit 1 (on)
//                          for preserved the destination.
//
//                      BBPF_HAS_BANDRECT
//
//                          Set to specified that rclBand RECTL data structrue
//                          should be used to compute for the caller's
//                          destination bitmap buffer.
//
//                          If this flag is not set then halftone dll assumed
//                          the caller's bitmap buffer is same width/height
//                          as specified in the destination HTSURFACEINFO.
//
//                      BBPF_BW_ONLY
//
//                          Produced monochrome version of the output even the
//                          destination is the color device.
//
//                      BBPF_TILE_SRC
//
//                          Tilt the source to destination and source bitmap
//                          when this bit is set the source mask is ignored.
//
//                      BBPF_ICM_ON
//
//                          When set, the halftone will use the input color
//                          directly without any modification
//
//                      BBPF_NO_ANTIALIASING
//
//                          Turn off anti-aliasing when halftone
//
//
//  DestPrimaryOrder- Specified destination primary color order, it can be
//                    either PRIMARY_ORDER_RGB or PRIMARY_ORDER_CMY group, it
//                    depends on the surface format has following meaning.
//
//                      BMF_1BPP:
//
//                          This field is ignored.
//
//                      BMF_4BPP_VGA16:
//
//                          This field automatically set to PRIMARY_ORDER_BGR
//                          by the halftone DLL.
//
//                      BMF_4BPP:
//
//                          for each byte there are two indices entries, and
//                          for each nibble has following meaning, notice that
//                          bit 3/7 always set to 0, the index number only
//                          range from 0 to 7.
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0/4
//                                        ||
//                                        |+--- bit 1/5
//                                        |
//                                        +---- bit 2/7
//
//                      BMF_8BPP_VGA256:
//
//                          This field is ignored, the palette entries and its
//                          order is defined by halftone DLL at run time, the
//                          caller should get the palette for the VGA256
//                          surface through HT_Get8BPPFormatPalette() API call.
//
//                      BMF_16BPP_555:
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0-4   (5 bits)
//                                        ||
//                                        |+--- bit 5-9   (5 bits)
//                                        |
//                                        +---- bit 10-14 (5 bits)
//
//                      BMF_16BPP_565:
//
//                          This field is ignored, it alway assume BGR as
//                          shown below
//
//                          PRIMARY_ORDER_BGR
//                                        |||
//                                        ||+-- bit 0-4   (5 bits)
//                                        ||
//                                        |+--- bit 5-10  (6 bits)
//                                        |
//                                        +---- bit 11-15 (5 bits)
//
//                      BMF_24BPP:
//
//                          This field is ignored, it alway assume BGR as
//                          shown below
//
//                          PRIMARY_ORDER_BGR
//                                        |||
//                                        ||+-- bit 0-7   (8 bits)
//                                        ||
//                                        |+--- bit 8-15  (8 bits)
//                                        |
//                                        +---- bit 16-23 (8 bits)
//
//                      BMF_32BPP:
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0-7   (8 bits)
//                                        ||
//                                        |+--- bit 8-15  (8 bits)
//                                        |
//                                        +---- bit 16-23 (8 bits)
//
//
//  rclSrc          - RECTL data structure defined the source rectangle area
//                    to be bitblt from, fields in this data structure are
//                    relative to the source HTSURFACEINFO's width/height.
//
//  rclDest         - RECTL data structure defined the destination rectangle
//                    area to be bitblt to, fields in this data structure are
//                    relative to the destination HTSURFACEINFO's width/height.
//
//  rclClip         - RECTL data structure defined the destination clipping
//                    rectangle area, fields in this data structure are
//                    relative to the destination HTSURFACEINFO's width/height.
//
//  rclBand         - RECTL data structure defined the device banding rectangle
//                    area, fields in this data structure are relative to the
//                    destination HTSURFACEINFO's width/height.
//
//                    This RECTL only used if BBPF_HAS_BANDRECT flag is set,
//                    when this flag is set, halftone DLL will automatically
//                    clipped the destination to this rectangle area and
//                    copied this rectangle to the output buffer with rclBand's
//                    left/top aligned to the buffer's physical origin.  The
//                    destination's buffer (bitmap) must the format specified
//                    in the destination HTSURFACEINFO.
//
//                    If rclBand rectangle is larger than the logical destination
//                    surface size (destination HTSURFACEINFO), halftone dll
//                    still move the the band's left/top location to the 0/0
//                    origin and extra width/height is remain unchanged.
//
//                    The rclBand normally is used for device which does not
//                    have enough memory to hold all the destination surface
//                    at one time, it just like to repeatly using same buffer
//                    to temporary holding the halftone results.
//
//                    The rclBand's left/top/right/bottom may not be negative
//                    numbers.
//
//  ptlSrcMask      - a POINTL data structure to specified the logical
//                    coordinate of starting point for the source mask bitmap,
//                    this field only used if a HTSURFACEINFO for the source
//                    mask is passed.
//
//                    This source mask bitmap must always monochrome and its
//                    width/height must
//
//                      Width  >= ptlSrcMask.x + source surface width.
//                      Height >= ptlSrcMask.y + source surface height;
//
//
//  NOTE:   1) all RECTL data structure are left/top inclusive and right/bottom
//             exclusive.
//
//          2) if rclSrc rectangle is not will ordered it specified the source
//             should be inverted before process for not ordered directions.
//
//          3) if rclDest rectangle is not will ordered it specified the
//             destination should be inverted after process for not ordered
//             directions.
//
//          4) if BBPF_HAS_DEST_CLIPRECT flag is set and rclClip is not well
//             ordered or its left equal to its right, or its top equal to its
//             bottom, then all destination are clipped, destination will not
//             be updated that is.
//
//          5) if BBPF_HAS_BANDRECT flag is set and rclBand is not well orderd
//             or it left eqaul to its right, or its top eqaul to its bottom,
//             then a HTERR_INVALID_BANDRECT is returned.
//
//

//
// ABIF_USE_CONST_ALPHA_VALUE   - The ConstAlphaValue field is used
// ABIF_DSTPAL_IS_RGRBUAD       - The pDstPal Pointed to RGBQUAD structure
//                                array rather PALETTEENTRY array
// ABIF_SRC_ALPHA_IS_PREMUL     - In 32bpp per-pixel alpha blending the
//                                source RGB already pre-multiply with its
//                                per-pixel alpha value
// ABIF_BLEND_DEST_ALPHA        - Only valid if source and destination
//                                both are 32bpp and per-pixel alpha is used
//                                d = s + (1 - s) * d
//


#define ABIF_USE_CONST_ALPHA_VALUE      0x01
#define ABIF_DSTPAL_IS_RGBQUAD          0x02
#define ABIF_SRC_ALPHA_IS_PREMUL        0x04
#define ABIF_BLEND_DEST_ALPHA           0x08

typedef struct _ABINFO {
    BYTE            Flags;
    BYTE            ConstAlphaValue;
    WORD            cDstPal;
    LPPALETTEENTRY  pDstPal;
    } ABINFO, *PABINFO;


#define BBPF_HAS_DEST_CLIPRECT      0x0001
#define BBPF_USE_ADDITIVE_PRIMS     0x0002
#define BBPF_NEGATIVE_DEST          0x0004
#define BBPF_INVERT_SRC_MASK        0x0008
#define BBPF_HAS_BANDRECT           0x0010
#define BBPF_BW_ONLY                0x0020
#define BBPF_TILE_SRC               0x0040
#define BBPF_ICM_ON                 0x0080
#define BBPF_NO_ANTIALIASING        0x0100
#define BBPF_DO_ALPHA_BLEND         0x0200

typedef struct _BITBLTPARAMS {
    WORD    Flags;
    BYTE    bReserved;
    BYTE    DestPrimaryOrder;
    PABINFO pABInfo;
    RECTL   rclSrc;
    RECTL   rclDest;
    RECTL   rclClip;
    RECTL   rclBand;
    POINTL  ptlBrushOrg;
    POINTL  ptlSrcMask;
    LPVOID  pBBData;
    } BITBLTPARAMS, FAR *PBITBLTPARAMS;



//
// DEVICEHALFTONEINFO
//
//  This data structure is passed for every HT_xxx api calls except the
//  HT_CreateDeviceHalftoneInfo() which return the pointer to this data
//  structure.  It is used to identify the device color characteristics
//  durning the halftone process.
//
//  DeviceOwnData       - this field will initially set to NULL, and will be
//                        used by the caller to stored useful information
//                        such as handle/pointer.
//
//  cxPattern           - width of the halftone pattern in pels
//
//  cyPattern           - height of the halftone pattern in pels.
//
//  HTColorAdjustment   - Current default color adjustment, if an halftone
//                        APIs required a PHTCOLORADJUSTMENT parameter and its
//                        passed as NULL pointer then default color adjustment
//                        is taken from here, the caller can change the
//                        HTCOLORADJUSTMENT data structure to affect all the
//                        color adjustment on this device.
//

typedef struct _DEVICEHALFTONEINFO {
    ULONG_PTR           DeviceOwnData;
    WORD                cxPattern;
    WORD                cyPattern;
    HTCOLORADJUSTMENT   HTColorAdjustment;
    } DEVICEHALFTONEINFO;

typedef DEVICEHALFTONEINFO  FAR *PDEVICEHALFTONEINFO;
typedef PDEVICEHALFTONEINFO FAR *PPDEVICEHALFTONEINFO;


//
// CHBINFO
//
//  This data structure is one of the parameter passed to the halftone entry
//  point HT_CreateHalftoneBrush();
//
//  Flags                   - one or more following flags can be defined
//
//                              CHBF_BW_ONLY
//
//                                  Create only black/white even the device is
//                                  color.
//
//                              CHBF_USE_ADDITIVE_PRIMS
//
//
//                                  Specified if the halftone result will be
//                                  using Red/Green/Blue primary color or using
//                                  Cyan/Magenta/Yellow primary color, depends
//                                  on the destination surface format as
//
//                                  BMF_1BPP:
//
//                                          Additive Prims: 0=Black, 1=White
//                                      Substractive Prims: 0=White, 1=Black
//
//                                  BMF_4BPP_VGA16:
//                                  BMF_8BPP_VGA256:
//                                  BMF_16BPP_555:
//                                  BMF_24BPP:
//
//                                      Always using RED, GREEN, BLUE primaries
//                                      and this flag is ignored.
//
//                                  BMF_4BPP:
//
//                                      Additive Prims: RED, GREEN. BLUE
//                                  Substractive Prims: CYAN, MAGENTA, YELLOW
//
//                                  The order of the RGB, or CMY is specified
//                                  by DestPrimaryOrder field. (see below)
//
//                              CHBF_NEGATIVE_BRUSH
//
//                                  Create the negative version of the brush.
//
//
//  DestSurfaceFormat       - One of the following can be specified,
//
//                              BMF_1BPP, BMF_4BPP, BMF_4BPP_VGA16,
//                              BMF_8BPP_VGA256, BMF_16BPP_555.
//
//                              for VGA16, VGA256, 16BPP_555  surface format
//                              see HTSURFACEINFO for descriptions.
//
//  DestScanLineAlignBytes  - Alignment bytes needed for each output pattern
//                            scan line, some common ones are
//
//                              BMF_ALIGN_BYTE      ( 8-bit aligned)
//                              BMF_ALIGN_WORD      (16-bit aligned)
//                              BMF_ALIGN_DWORD     (32-bit aligned)
//                              BMF_ALIGN_QWORD     (64-bit aligned)
//
//  DestPrimaryOrder        - Specified destination primary color order, it can
//                            be either PRIMARY_ORDER_RGB or PRIMARY_ORDER_CMY
//                            group, it depends on the surface format has
//                            following meaning.
//
//                              BMF_1BPP:
//
//                                  This field is ignored.
//
//
//                              BMF_4BPP_VGA16:
//
//                                  This field automatically set to
//                                  PRIMARY_ORDER_BGR by the halftone DLL.
//
//                              BMF_4BPP:
//
//                                  for each byte there are two indices
//                                  entries, and for each nibble has following
//                                  meaning, notice that bit 3/7 always set to
//                                  0, the index number only range from 0 to 7.
//
//                                      PRIMARY_ORDER_abc
//                                                    |||
//                                                    ||+-- bit 0/4
//                                                    ||
//                                                    |+--- bit 1/5
//                                                    |
//                                                    +---- bit 2/7
//
//
//                              BMF_8BPP_VGA256:
//
//                                  This field is ignored, the palette entries
//                                  and its order is defined by halftone DLL
//                                  at run time, the caller should get the
//                                  palette for the VGA256 surface through
//                                  HT_Get8BPPFormatPalette() API call.
//
//                              BMF_16BPP_555:
//
//                                  PRIMARY_ORDER_abc
//                                                |||
//                                                ||+-- bit 0-4   (5 bits)
//                                                ||
//                                                |+--- bit 5-9   (5 bits)
//                                                |
//                                                +---- bit 10-15 (5 bits)
//
//
//


#define CHBF_BW_ONLY                    0x01
#define CHBF_USE_ADDITIVE_PRIMS         0x02
#define CHBF_NEGATIVE_BRUSH             0x04
#define CHBF_BOTTOMUP_BRUSH             0x08
#define CHBF_ICM_ON                     0x10


typedef struct _CHBINFO {
    BYTE        Flags;
    BYTE        DestSurfaceFormat;
    BYTE        DestScanLineAlignBytes;
    BYTE        DestPrimaryOrder;
    } CHBINFO;



//
// STDMONOPATTERN
//
//  This data structure is used when calling the HT_CreateStdMonoPattern().
//
//  Flags               - One or more following flags may be defined
//
//                          SMP_TOPDOWN
//
//                              Specified that first scan line of the pattern
//                              bitmap will be the viewing top, if this flag
//                              is not defined then the last scan line is the
//                              viewing top.
//
//                          SMP_0_IS_BLACK
//
//                              specified that the in the bitmap a bit value
//                              0 = black and bit value 1=white, if this flag
//                              is not defined then bit value 0=white and
//                              bit value 1=black.
//
//  ScanLineAlignBytes  - Alignment bytes needed for each output pattern scan
//                        line, some common ones are
//
//                          BMF_ALIGN_BYTE      ( 8-bit aligned)
//                          BMF_ALIGN_WORD      (16-bit aligned)
//                          BMF_ALIGN_DWORD     (32-bit aligned)
//                          BMF_ALIGN_QWORD     (64-bit aligned)
//
//  PatternIndex        - Specified the pattern index number, this has the
//                        predefined value as HT_STDMONOPAT_xxxx.  If a invalid
//                        index number is passed then it return an error
//                        HTERR_INVALID_STDMONOPAT_INDEX is returned.
//
//  LineWidth           - This field only applied to the pattern which has
//                        lines in them, the value range from 0-255 (byte) and
//                        it repesent as LineWidth/1000 of inch, for example
//                        a 3 indicate 3/1000 = 0.003 inch width, if this value
//                        is less than the device minimum pel size, it will
//                        default to the 1 pel, the maximum is 255/1000 = 0.255
//                        inch width.
//
//                        If a zero is specified then it halftone will using
//                        default line width settting.
//
//  LinesPerInch        - This field only applied to the pattern wich has lines
//                        in them, the value range from 0 to 255 (byte). The
//                        LinesPerInch is calculated in the perpendicular
//                        direction of two parallel lines, the distances
//                        between two parallel lines that is.
//
//                        If a zero is specified then it halftone will using
//                        default line per inch setting.
//
//  BytesPerScanLine    - If will be filled by halftone dll to specified the
//                        size in bytes for each scan line in the pattern.
//
//  cxPels              - It will be filled by halftone dll of the final
//                        pattern's width in pel.
//
//  cyPels              - It will be filled by halftone dll of the final
//                        pattern's height in scan line.
//
//  pPattern            - Specified the memory location where the pattern will
//                        be stored, if this field is NULL then it will fill in
//                        the width/height fields.
//
//




#define HT_SMP_HORZ_LINE                0
#define HT_SMP_VERT_LINE                1
#define HT_SMP_HORZ_VERT_CROSS          2
#define HT_SMP_DIAG_15_LINE_UP          3
#define HT_SMP_DIAG_15_LINE_DOWN        4
#define HT_SMP_DIAG_15_CROSS            5
#define HT_SMP_DIAG_30_LINE_UP          6
#define HT_SMP_DIAG_30_LINE_DOWN        7
#define HT_SMP_DIAG_30_CROSS            8
#define HT_SMP_DIAG_45_LINE_UP          9
#define HT_SMP_DIAG_45_LINE_DOWN        10
#define HT_SMP_DIAG_45_CROSS            11
#define HT_SMP_DIAG_60_LINE_UP          12
#define HT_SMP_DIAG_60_LINE_DOWN        13
#define HT_SMP_DIAG_60_CROSS            14
#define HT_SMP_DIAG_75_LINE_UP          15
#define HT_SMP_DIAG_75_LINE_DOWN        16
#define HT_SMP_DIAG_75_CROSS            17

#define HT_SMP_PERCENT_SCREEN_START     (HT_SMP_DIAG_75_CROSS + 1)
#define HT_SMP_PERCENT_SCREEN(x)        (x + HT_SMP_PERCENT_SCREEN_START)

#define HT_SMP_MAX_INDEX                HT_SMP_PERCENT_SCREEN(100)


#define SMP_TOPDOWN             W_BITPOS(0)
#define SMP_0_IS_BLACK          W_BITPOS(1)


typedef struct _STDMONOPATTERN {
    WORD    Flags;
    BYTE    ScanLineAlignBytes;
    BYTE    PatternIndex;
    BYTE    LineWidth;
    BYTE    LinesPerInch;
    WORD    BytesPerScanLine;
    WORD    cxPels;
    WORD    cyPels;
    LPBYTE  pPattern;
    } STDMONOPATTERN;

typedef STDMONOPATTERN FAR *PSTDMONOPATTERN;


//
// Following is used in ConvertColorTable
//


#define CCTF_BW_ONLY        0x0001
#define CCTF_NEGATIVE       0x0002
#define CCTF_ICM_ON         0x0004


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                                                          //
// Exposed Halftone DLL APIs                                                //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifndef _HTAPI_ENTRY_

LONG
APIENTRY
HT_CreateDeviceHalftoneInfo(
    PHTINITINFO             pHTInitInfo,
    PPDEVICEHALFTONEINFO    ppDeviceHalftoneInfo
    );

BOOL
APIENTRY
HT_DestroyDeviceHalftoneInfo(
    PDEVICEHALFTONEINFO     pDeviceHalftoneInfo
    );

LONG
APIENTRY
HT_CreateHalftoneBrush(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    CHBINFO             CHBInfo,
    LPVOID              pOutputBuffer
    );

#ifndef _WINDDI_

LONG
APIENTRY
HT_ComputeRGBGammaTable(
    WORD    GammaTableEntries,
    WORD    GammaTableType,
    UDECI4  RedGamma,
    UDECI4  GreenGamma,
    UDECI4  BlueGamma,
    LPBYTE  pGammaTable
    );

LONG
APIENTRY
HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    );

LONG
APIENTRY
HT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    );

#endif

LONG
APIENTRY
HT_CreateStandardMonoPattern(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PSTDMONOPATTERN     pStdMonoPattern
    );


LONG
APIENTRY
HT_HalftoneBitmap(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PHTSURFACEINFO      pSourceHTSurfaceInfo,
    PHTSURFACEINFO      pSourceMaskHTSurfaceInfo,
    PHTSURFACEINFO      pDestinationHTSurfaceInfo,
    PBITBLTPARAMS       pBitbltParams
    );

#endif  // _HTAPI_ENTRY_
#endif  // _HT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\ntgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdi.h
*
* Structures defining kernel-mode entry points for GDI.
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// Trace creation of all GDI SURFACE objects
#define TRACE_SURFACE_ALLOCS    (DBG || 1)


// PRIVATE

W32KAPI BOOL     APIENTRY NtGdiInit();
W32KAPI int      APIENTRY NtGdiSetDIBitsToDeviceInternal(IN HDC hdcDest,IN int xDst,IN int yDst,IN DWORD cx,IN DWORD cy,
                                                         IN int xSrc,IN int ySrc,IN DWORD iStartScan,IN DWORD cNumScan,
                                                         IN LPBYTE pInitBits,IN LPBITMAPINFO pbmi,IN DWORD iUsage,
                                                         IN UINT cjMaxBits,IN UINT cjMaxInfo,IN BOOL bTransformCoordinates,
                                                         IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGetFontResourceInfoInternalW(IN LPWSTR pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN UINT cjIn,
                                                            OUT LPDWORD pdwBytes,OUT LPVOID pvBuf,IN DWORD iType);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesW(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesWInternal(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode, BOOL bSubset);
W32KAPI HPALETTE APIENTRY NtGdiCreatePaletteInternal(IN LPLOGPALETTE pLogPal,IN UINT cEntries);
W32KAPI BOOL     APIENTRY NtGdiArcInternal(IN ARCTYPE arctype,IN HDC hdc,IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,
                                           IN int y3,IN int x4,IN int y4);
W32KAPI int      APIENTRY NtGdiStretchDIBitsInternal(IN HDC hdc,IN int xDst,IN int yDst,IN int cxDst,IN int cyDst,IN int xSrc,
                                                     IN int ySrc,IN int cxSrc,IN int cySrc,IN LPBYTE pjInit,IN LPBITMAPINFO pbmi,
                                                     IN DWORD dwUsage,IN DWORD dwRop4,IN UINT cjMaxInfo,IN UINT cjMaxBits,IN HANDLE hcmXform);
W32KAPI ULONG    APIENTRY NtGdiGetOutlineTextMetricsInternalW(IN HDC hdc,IN ULONG cjotm,OUT OUTLINETEXTMETRICW *potmw,
                                                              OUT TMDIFF *ptmd);
W32KAPI BOOL     APIENTRY NtGdiGetAndSetDCDword(IN HDC hdc,IN UINT u,IN DWORD dwIn,OUT DWORD *pdwResult);
W32KAPI HANDLE   APIENTRY NtGdiGetDCObject(IN HDC hdc,IN int itype);
W32KAPI HDC      APIENTRY NtGdiGetDCforBitmap(IN HBITMAP hsurf);

W32KAPI BOOL     APIENTRY NtGdiGetMonitorID(IN HDC hdc, IN DWORD dwSize, OUT LPWSTR pszMonitorID);

// flags returned from GetUFI and passed to GetUFIBits
#define FL_UFI_PRIVATEFONT      1
#define FL_UFI_DESIGNVECTOR_PFF 2
#define FL_UFI_MEMORYFONT       4

W32KAPI INT      APIENTRY NtGdiGetLinkedUFIs(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufiLinkedUFIs,IN INT BufferSize);
W32KAPI BOOL     APIENTRY NtGdiSetLinkedUFIs(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufiLinks,IN ULONG uNumUFIs);
W32KAPI BOOL     APIENTRY NtGdiGetUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl);
W32KAPI BOOL     APIENTRY NtGdiForceUFIMapping(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufi);
W32KAPI BOOL     APIENTRY NtGdiGetUFIPathname(IN PUNIVERSAL_FONT_ID pufi,OUT ULONG* pcwc,OUT LPWSTR pwszPathname,
                                              OUT ULONG* pcNumFiles, IN FLONG fl, OUT BOOL *pbMemFont, OUT ULONG *pcjView,
                                              OUT PVOID pvView, OUT BOOL  *pbTTC, OUT ULONG *piTTC);
W32KAPI BOOL     APIENTRY NtGdiAddRemoteFontToDC(IN HDC hdc,IN PVOID pvBuffer, IN ULONG cjBuffer,IN PUNIVERSAL_FONT_ID pufi);
W32KAPI HANDLE   APIENTRY NtGdiAddFontMemResourceEx(IN PVOID pvBuffer,IN DWORD cjBuffer,IN DESIGNVECTOR *pdv,IN ULONG cjDV,
                                                    OUT DWORD *pNumFonts);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontMemResourceEx(IN HANDLE hMMFont);
W32KAPI BOOL     APIENTRY NtGdiUnmapMemFont(IN PVOID pvView);
W32KAPI BOOL     APIENTRY NtGdiRemoveMergeFont(IN HDC hdc,IN UNIVERSAL_FONT_ID *pufi);
W32KAPI BOOL     APIENTRY NtGdiAnyLinkedFonts();

// local printing with embedded fonts

W32KAPI BOOL     APIENTRY NtGdiGetEmbUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl, OUT KERNEL_PVOID *embFontID);
W32KAPI ULONG   APIENTRY  NtGdiGetEmbedFonts();
W32KAPI BOOL    APIENTRY  NtGdiChangeGhostFont(IN KERNEL_PVOID *pfontID, IN BOOL bLoad);
W32KAPI BOOL    APIENTRY  NtGdiAddEmbFontToDC(IN HDC hdc, IN VOID **pFontID);

W32KAPI BOOL     APIENTRY NtGdiFontIsLinked(IN HDC hdc);
W32KAPI ULONG_PTR APIENTRY NtGdiPolyPolyDraw(IN HDC hdc,IN PPOINT ppt,IN PULONG pcpt,IN ULONG ccpt,IN int iFunc);
W32KAPI LONG     APIENTRY NtGdiDoPalette(IN HPALETTE hpal,IN WORD iStart,IN WORD cEntries,IN PALETTEENTRY *pPalEntries,
                                         IN DWORD iFunc,IN BOOL bInbound);
W32KAPI BOOL     APIENTRY NtGdiComputeXformCoefficients(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetWidthTable(IN HDC hdc,IN ULONG cSpecial,IN WCHAR *pwc,IN ULONG cwc,OUT USHORT *psWidth,
                                             OUT WIDTHDATA *pwd, OUT FLONG *pflInfo);
W32KAPI int      APIENTRY NtGdiDescribePixelFormat(IN HDC hdc,IN int ipfd,IN UINT cjpfd,OUT PPIXELFORMATDESCRIPTOR ppfd);
W32KAPI BOOL     APIENTRY NtGdiSetPixelFormat(IN HDC hdc,IN int ipfd);
W32KAPI BOOL     APIENTRY NtGdiSwapBuffers(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiSetupPublicCFONT(IN HDC hdc,IN HFONT hf,IN ULONG ulAve);


W32KAPI DWORD  APIENTRY NtGdiDxgGenericThunk(IN ULONG_PTR ulIndex,
                                             IN ULONG_PTR ulHandle,
                                             IN OUT SIZE_T *pdwSizeOfPtr1,
                                             IN OUT PVOID pvPtr1,
                                             IN OUT SIZE_T *pdwSizeOfPtr2,
                                             IN OUT PVOID pvPtr2);
W32KAPI DWORD    APIENTRY NtGdiDdAddAttachedSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached,
                                                    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);
W32KAPI BOOL     APIENTRY NtGdiDdAttachSurface(IN HANDLE  hSurfaceFrom, IN HANDLE  hSurfaceTo);
W32KAPI DWORD    APIENTRY NtGdiDdBlt(IN HANDLE hSurfaceDest,IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateSurface(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdColorControl(IN HANDLE hSurface,IN OUT PDD_COLORCONTROLDATA puColorControlData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateDirectDrawObject(IN HDC hdc);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurface(IN HANDLE hDirectDraw,IN HANDLE* hSurface,
                                               IN OUT DDSURFACEDESC* puSurfaceDescription,
                                               IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
                                               IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                               IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
                                               IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                               OUT HANDLE* puhSurface);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateSurfaceObject(IN HANDLE hDirectDrawLocal,IN HANDLE hSurface,IN PDD_SURFACE_LOCAL puSurfaceLocal,
                                                     IN PDD_SURFACE_MORE puSurfaceMore, IN PDD_SURFACE_GLOBAL puSurfaceGlobal,IN BOOL bComplete);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteSurfaceObject(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteDirectDrawObject(HANDLE hDirectDrawLocal);
W32KAPI DWORD    APIENTRY NtGdiDdDestroySurface(IN HANDLE hSurface, IN BOOL bRealDestroy);
W32KAPI DWORD    APIENTRY NtGdiDdFlip(IN HANDLE hSurfaceCurrent,IN HANDLE hSurfaceTarget,IN HANDLE hSurfaceCurrentLeft,IN HANDLE hSurfaceTargetLeft,IN OUT PDD_FLIPDATA puFlipData);
W32KAPI DWORD    APIENTRY NtGdiDdGetAvailDriverMemory(IN HANDLE hDirectDraw, IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);
W32KAPI DWORD    APIENTRY NtGdiDdGetBltStatus(IN HANDLE hSurface,IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);
W32KAPI HDC      APIENTRY NtGdiDdGetDC(IN HANDLE hSurface,IN PALETTEENTRY* puColorTable);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverInfo(IN HANDLE hDirectDraw, IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);
W32KAPI DWORD    APIENTRY NtGdiDdGetFlipStatus(IN HANDLE hSurface,IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDdGetScanLine(IN HANDLE hDirectDraw, IN OUT PDD_GETSCANLINEDATA puGetScanLineData);
W32KAPI DWORD    APIENTRY NtGdiDdSetExclusiveMode(IN HANDLE hDirectDraw,IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);
W32KAPI DWORD    APIENTRY NtGdiDdFlipToGDISurface(IN HANDLE hDirectDraw,IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdLock(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData,IN HDC hdcClip);
W32KAPI BOOL     APIENTRY NtGdiDdQueryDirectDrawObject(IN HANDLE,OUT PDD_HALINFO,DWORD*,OUT LPD3DNTHAL_CALLBACKS,OUT LPD3DNTHAL_GLOBALDRIVERDATA,OUT PDD_D3DBUFCALLBACKS,OUT LPDDSURFACEDESC,OUT DWORD*,OUT VIDEOMEMORY*,OUT DWORD*,OUT DWORD*);
W32KAPI BOOL     APIENTRY NtGdiDdReenableDirectDrawObject(IN HANDLE hDirectDrawLocal,IN OUT BOOL* pubNewMode);
W32KAPI BOOL     APIENTRY NtGdiDdReleaseDC(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdResetVisrgn(IN HANDLE hSurface,IN HWND hwnd);
W32KAPI DWORD    APIENTRY NtGdiDdSetColorKey(IN HANDLE hSurface,IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);
W32KAPI DWORD    APIENTRY NtGdiDdSetOverlayPosition(IN HANDLE hSurfaceSource,IN HANDLE hSurfaceDestination,
                                                    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);
W32KAPI VOID     APIENTRY NtGdiDdUnattachSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached);
W32KAPI DWORD    APIENTRY NtGdiDdUnlock(IN HANDLE hSurface,IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdUpdateOverlay(IN HANDLE hSurfaceDestination, IN HANDLE hSurfaceSource,
                                               IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);
W32KAPI DWORD    APIENTRY NtGdiDdWaitForVerticalBlank(IN HANDLE hDirectDraw,IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);
W32KAPI HANDLE   APIENTRY NtGdiDdGetDxHandle(IN HANDLE hDirectDraw,IN HANDLE hSurface,IN BOOL bRelease);
W32KAPI BOOL     APIENTRY NtGdiDdSetGammaRamp(IN HANDLE hDirectDraw,IN HDC hdc,IN LPVOID lpGammaRamp);


W32KAPI DWORD    APIENTRY NtGdiDdLockD3D(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData);
W32KAPI DWORD    APIENTRY NtGdiDdUnlockD3D(IN HANDLE hSurface, IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdCreateD3DBuffer(HANDLE hDirectDraw, HANDLE* hSurface, IN OUT DDSURFACEDESC* puSurfaceDescription,
                                                 IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData, IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                                 IN OUT DD_SURFACE_MORE* puSurfaceMoreData, IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                                 IN OUT HANDLE* puhSurface);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateD3DBuffer(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyD3DBuffer(IN HANDLE hSurface);
W32KAPI DWORD    APIENTRY NtGdiD3dContextCreate(IN HANDLE hDirectDrawLocal,IN HANDLE hSurfColor,IN HANDLE hSurfZ,
                                                IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroy(LPD3DNTHAL_CONTEXTDESTROYDATA);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroyAll(OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

W32KAPI DWORD    APIENTRY NtGdiD3dValidateTextureStageState(IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);
W32KAPI DWORD    APIENTRY NtGdiD3dDrawPrimitives2(IN HANDLE hCmdBuf, IN HANDLE hVBuf, IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                                                  IN OUT FLATPTR* pfpVidMemCmd, IN OUT DWORD* pdwSizeCmd, IN OUT FLATPTR* pfpVidMemVtx,
                                                  IN OUT DWORD* pdwSizeVtx);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverState(IN OUT PDD_GETDRIVERSTATEDATA pdata);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurfaceEx(IN HANDLE hDirectDraw, IN HANDLE hSurface,IN DWORD dwSurfaceHandle);
W32KAPI DWORD    APIENTRY NtGdiDvpCanCreateVideoPort(IN HANDLE hDirectDraw, IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpColorControl(IN HANDLE hVideoPort,IN OUT PDD_VPORTCOLORDATA puVPortColorData);
W32KAPI HANDLE   APIENTRY NtGdiDvpCreateVideoPort(IN HANDLE hDirectDraw,IN OUT PDD_CREATEVPORTDATA puCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpDestroyVideoPort(IN HANDLE hVideoPort,IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpFlipVideoPort(IN HANDLE hVideoPort,IN HANDLE hDDSurfaceCurrent,IN HANDLE hDDSurfaceTarget,
                                                IN OUT PDD_FLIPVPORTDATA puFlipVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortBandwidth(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortField(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortFlipStatus(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortInputFormats(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortLine(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortOutputFormats(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortConnectInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoSignalStatus(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData);
W32KAPI DWORD    APIENTRY NtGdiDvpUpdateVideoPort(IN HANDLE hVideoPort, IN HANDLE* phSurfaceVideo,IN HANDLE* phSurfaceVbi,IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpWaitForVideoPortSync(IN HANDLE hVideoPort,IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData);
W32KAPI DWORD    APIENTRY NtGdiDvpAcquireNotification(IN HANDLE hVideoPort,IN OUT HANDLE* hEvent,IN LPDDVIDEOPORTNOTIFY pNotify);
W32KAPI DWORD    APIENTRY NtGdiDvpReleaseNotification(IN HANDLE hVideoPort,IN HANDLE hEvent);

W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompGuids(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompFormats(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompBuffInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);
W32KAPI DWORD    APIENTRY NtGdiDdGetInternalMoCompInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateMoComp(IN HANDLE hDirectDraw,IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyMoComp(IN HANDLE hMoComp,IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdBeginMoCompFrame(IN HANDLE hMoComp, IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdEndMoCompFrame(IN HANDLE hMoComp,IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdRenderMoComp(IN HANDLE hMoComp,IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdQueryMoCompStatus(IN OUT HANDLE hMoComp,IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

W32KAPI DWORD    APIENTRY NtGdiDdAlphaBlt(IN HANDLE hSurfaceDest, IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);

// Image32

W32KAPI BOOL     APIENTRY NtGdiAlphaBlend(IN HDC hdcDst, IN LONG DstX,IN LONG DstY,IN LONG DstCx,IN LONG DstCy,IN HDC hdcSrc,
                                          IN LONG SrcX,IN LONG SrcY, IN LONG SrcCx, IN LONG SrcCy, IN BLENDFUNCTION BlendFunction,
                                          IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGradientFill(IN HDC hdc,IN PTRIVERTEX pVertex,IN ULONG uVertex,IN PVOID pMesh,IN ULONG uMesh,IN ULONG ulMode);

// icm (Image Color Matching)
W32KAPI BOOL     APIENTRY NtGdiSetIcmMode(IN HDC hdc,IN ULONG nCommand,IN ULONG ulMode);

#define ICM_SET_MODE             1
#define ICM_SET_CALIBRATE_MODE   2
#define ICM_SET_COLOR_MODE       3
#define ICM_CHECK_COLOR_MODE     4

typedef struct _LOGCOLORSPACEEXW
{
    LOGCOLORSPACEW lcsColorSpace;
    DWORD          dwFlags;
} LOGCOLORSPACEEXW, *PLOGCOLORSPACEEXW;

#define LCSEX_ANSICREATED    0x0001 // Created by CreateColorSpaceA()
#define LCSEX_TEMPPROFILE    0x0002 // Color profile is temporary file

W32KAPI HANDLE   APIENTRY NtGdiCreateColorSpace(IN PLOGCOLORSPACEEXW pLogColorSpace);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorSpace(IN HANDLE hColorSpace);
W32KAPI BOOL     APIENTRY NtGdiSetColorSpace(IN HDC hdc,IN HCOLORSPACE hColorSpace);

W32KAPI HANDLE   APIENTRY NtGdiCreateColorTransform(IN HDC hdc,IN LPLOGCOLORSPACEW pLogColorSpaceW,IN PVOID pvSrcProfile,
                                                    IN ULONG cjSrcProfile,IN PVOID pvDestProfile, IN ULONG cjDestProfile,
                                                    IN PVOID pvTargetProfile, IN ULONG cjTargetProfile);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorTransform(IN HDC hdc, IN HANDLE hColorTransform);
W32KAPI BOOL     APIENTRY NtGdiCheckBitmapBits(IN HDC hdc,IN HANDLE hColorTransform,IN PVOID pvBits, IN ULONG bmFormat,
                                               IN DWORD dwWidth, IN DWORD dwHeight,IN DWORD dwStride,OUT PBYTE paResults);

W32KAPI ULONG    APIENTRY NtGdiColorCorrectPalette(IN HDC hdc,IN HPALETTE hpal,IN ULONG FirstEntry,IN ULONG NumberOfEntries,
                                                   IN OUT PALETTEENTRY *ppalEntry,IN ULONG);

W32KAPI ULONG_PTR APIENTRY NtGdiGetColorSpaceforBitmap(IN HBITMAP hsurf);

typedef enum _COLORPALETTEINFO
{
    ColorPaletteQuery,
    ColorPaletteSet
} COLORPALETTEINFO, *PCOLORPALETTEINFO;

W32KAPI BOOL     APIENTRY NtGdiGetDeviceGammaRamp(IN HDC hdc, OUT LPVOID lpGammaRamp);
W32KAPI BOOL     APIENTRY NtGdiSetDeviceGammaRamp(IN HDC hdc, IN LPVOID  lpGammaRamp);

W32KAPI BOOL     APIENTRY NtGdiIcmBrushInfo(IN HDC hdc,IN HBRUSH hbrush,IN OUT PBITMAPINFO pbmiDIB, IN OUT PVOID pvBits,
                                            IN OUT ULONG *pulBits, OUT DWORD *piUsage, OUT BOOL *pbAlreadyTran, IN ULONG Command);

typedef enum _ICM_DIB_INFO_CMD
{
    IcmQueryBrush,
    IcmSetBrush
} ICM_DIB_INFO, *PICM_DIB_INFO;

// PUBLIC

W32KAPI VOID     APIENTRY NtGdiFlush();
W32KAPI HDC      APIENTRY NtGdiCreateMetafileDC(IN HDC hdc);

W32KAPI BOOL     APIENTRY NtGdiMakeInfoDC(IN HDC hdc, IN BOOL bSet);
W32KAPI HANDLE   APIENTRY NtGdiCreateClientObj(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiDeleteClientObj(IN HANDLE h);

W32KAPI LONG     APIENTRY NtGdiGetBitmapBits(IN HBITMAP hbm, IN ULONG cjMax, OUT PBYTE pjOut);

W32KAPI BOOL     APIENTRY NtGdiDeleteObjectApp(IN HANDLE hobj);
W32KAPI int      APIENTRY NtGdiGetPath(IN HDC hdc, OUT LPPOINT pptlBuf, OUT LPBYTE pjTypes,IN int cptBuf);

W32KAPI HDC      APIENTRY NtGdiCreateCompatibleDC(IN HDC hdc);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBitmapInternal(IN HDC hdc,IN INT cx,IN INT cy, IN DWORD fInit, IN LPBYTE pjInit,
                                                      IN LPBITMAPINFO pbmi, IN DWORD iUsage,IN UINT cjMaxInitInfo,
                                                      IN UINT cjMaxBits, IN FLONG f, IN HANDLE hcmXform);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBSection(IN HDC hdc,IN HANDLE hSectionApp,IN DWORD dwOffset, IN LPBITMAPINFO pbmi,
                                                IN DWORD iUsage,IN UINT cjHeader,IN FLONG fl, IN ULONG_PTR dwColorSpace,
                                                OUT PVOID *ppvBits);

W32KAPI HBRUSH   APIENTRY NtGdiCreateSolidBrush(IN COLORREF cr, IN HBRUSH hbr);
W32KAPI HBRUSH   APIENTRY NtGdiCreateDIBBrush(IN PVOID pv, IN FLONG fl, IN UINT  cj, IN BOOL  b8X8, IN BOOL bPen,
                                              IN PVOID pClient);
W32KAPI HBRUSH   APIENTRY NtGdiCreatePatternBrushInternal(IN HBITMAP hbm,IN BOOL bPen,IN BOOL b8X8);
W32KAPI HBRUSH   APIENTRY NtGdiCreateHatchBrushInternal(IN ULONG ulStyle,IN COLORREF clrr,IN BOOL bPen);

W32KAPI HPEN     APIENTRY NtGdiExtCreatePen(IN ULONG flPenStyle, IN ULONG ulWidth, IN ULONG iBrushStyle,
                                            IN ULONG ulColor, IN ULONG_PTR  lClientHatch, IN ULONG_PTR   lHatch,
                                            IN ULONG cstyle, IN PULONG pulStyle, IN ULONG cjDIB, IN BOOL bOldStylePen,
                                            IN HBRUSH hbrush);
W32KAPI HRGN     APIENTRY NtGdiCreateEllipticRgn(IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRoundRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom,
                                                  IN int xWidth, IN int yHeight);
W32KAPI HANDLE   APIENTRY NtGdiCreateServerMetaFile(IN DWORD iType, IN ULONG cjData, IN LPBYTE pjData, IN DWORD mm,
                                                    IN DWORD xExt, IN DWORD yExt);
W32KAPI HRGN     APIENTRY NtGdiExtCreateRegion(IN LPXFORM px, IN DWORD cj, IN LPRGNDATA prgn);
W32KAPI ULONG    APIENTRY NtGdiMakeFontDir(IN FLONG flEmbed,OUT PBYTE pjFontDir,IN unsigned cjFontDir, IN LPWSTR pwszPathname, IN unsigned cjPathname);

W32KAPI BOOL     APIENTRY NtGdiPolyDraw(IN HDC hdc,IN LPPOINT ppt,IN LPBYTE pjAttr,IN ULONG cpt);
W32KAPI BOOL     APIENTRY NtGdiPolyTextOutW(IN HDC hdc,IN POLYTEXTW *pptw,IN UINT cStr,IN DWORD dwCodePage);

W32KAPI ULONG    APIENTRY NtGdiGetServerMetaFileBits(IN HANDLE hmo, IN ULONG cbData, OUT LPBYTE lpClientData,OUT PDWORD piType,
                                                     OUT PDWORD pmm, OUT PDWORD pxExt, OUT PDWORD pyExt);
W32KAPI BOOL     APIENTRY NtGdiEqualRgn(IN HRGN hrgn1,IN HRGN hrgn2);
W32KAPI BOOL     APIENTRY NtGdiGetBitmapDimension(IN HBITMAP hbm, OUT LPSIZE psize);
W32KAPI UINT     APIENTRY NtGdiGetNearestPaletteIndex(IN HPALETTE hpal,IN COLORREF crColor);
W32KAPI BOOL     APIENTRY NtGdiPtVisible(IN HDC hdc,IN int x,IN int y);
W32KAPI BOOL     APIENTRY NtGdiRectVisible(IN HDC hdc,IN LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontResourceW(IN WCHAR *pwszFiles, IN ULONG cwc,IN ULONG cFiles, IN ULONG fl,
                                                   IN DWORD dwPidTid,IN DESIGNVECTOR *pdv);
W32KAPI BOOL     APIENTRY NtGdiResizePalette(IN HPALETTE hpal,IN UINT cEntry);
W32KAPI BOOL     APIENTRY NtGdiSetBitmapDimension(IN HBITMAP hbm,IN int cx,IN int cy,OUT LPSIZE  psizeOut);
W32KAPI int      APIENTRY NtGdiOffsetClipRgn(IN HDC hdc,IN int x,IN int y);
W32KAPI int      APIENTRY NtGdiSetMetaRgn(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetTextJustification(IN HDC hdc, IN int lBreakExtra,IN int cBreak);
W32KAPI int      APIENTRY NtGdiGetAppClipBox(IN HDC hdc,OUT LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtentExW(IN HDC hdc, IN LPWSTR lpwsz, IN ULONG cwc,IN ULONG dxMax,
                                                OUT ULONG *pcCh,OUT PULONG pdxOut,OUT LPSIZE psize,IN FLONG fl);
W32KAPI BOOL     APIENTRY NtGdiGetCharABCWidthsW(IN HDC hdc,IN UINT wchFirst,IN ULONG cwch,IN PWCHAR pwch,
                                                 IN FLONG fl,OUT PVOID pvBuf);
W32KAPI DWORD    APIENTRY NtGdiGetCharacterPlacementW(IN HDC hdc,IN LPWSTR pwsz,IN int nCount, IN int nMaxExtent,
                                                      IN OUT LPGCP_RESULTSW pgcpw, IN DWORD dwFlags);
W32KAPI BOOL     APIENTRY NtGdiAngleArc(IN HDC hdc,IN int x,IN int y, IN DWORD dwRadius,IN DWORD dwStartAngle, IN DWORD dwSweepAngle);
W32KAPI BOOL     APIENTRY NtGdiBeginPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSelectClipPath(IN HDC hdc, IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiCloseFigure(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokeAndFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokePath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiWidenPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFlattenPath(IN HDC hdc);
W32KAPI HRGN     APIENTRY NtGdiPathToRegion(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetMiterLimit(IN HDC hdc,IN DWORD dwNew,IN OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiSetFontXform(IN HDC hdc,IN DWORD dwxScale,IN DWORD dwyScale);
W32KAPI BOOL     APIENTRY NtGdiGetMiterLimit(IN HDC hdc,OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiEllipse(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRectangle(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRoundRect(IN HDC hdc, IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,IN int y3);
W32KAPI BOOL     APIENTRY NtGdiPlgBlt(IN HDC hdcTrg,IN LPPOINT pptlTrg,IN HDC hdcSrc,IN int xSrc, IN int ySrc,
                                      IN int cxSrc, IN int cySrc,IN HBITMAP hbmMask,IN int xMask, IN int yMask, IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiMaskBlt(IN HDC hdc,IN int xDst,IN int yDst,IN int cx,IN int cy,IN HDC hdcSrc,IN int xSrc,
                                       IN int ySrc, IN HBITMAP hbmMask, IN int xMask,IN int yMask,IN DWORD dwRop4,IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiExtFloodFill(IN HDC hdc,IN INT x,IN INT y, IN COLORREF crColor,IN UINT iFillType);
W32KAPI BOOL     APIENTRY NtGdiFillRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush);
W32KAPI BOOL     APIENTRY NtGdiFrameRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush,IN int xWidth,IN int yHeight);
W32KAPI COLORREF APIENTRY NtGdiSetPixel(IN HDC hdcDst, IN int x, IN int y, IN COLORREF crColor);
W32KAPI DWORD    APIENTRY NtGdiGetPixel(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiStartPage(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPage(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiStartDoc(IN HDC hdc,IN DOCINFOW *pdi,OUT BOOL *pbBanding, IN INT iJob);
W32KAPI BOOL     APIENTRY NtGdiEndDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiUpdateColors(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthW(IN HDC hdc,IN UINT wcFirst,IN UINT cwc,IN PWCHAR pwc,
                                             IN FLONG fl,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthInfo(IN HDC hdc,OUT PCHWIDTHINFO pChWidthInfo);
W32KAPI int      APIENTRY NtGdiDrawEscape(IN HDC hdc,IN int iEsc,IN int cjIn, IN LPSTR pjIn);
W32KAPI int      APIENTRY NtGdiExtEscape(IN HDC hdc,IN PWCHAR pDriver,IN int nDriver,IN int iEsc, IN int cjIn, IN LPSTR pjIn,
                                         IN int cjOut, OUT LPSTR pjOut);
W32KAPI ULONG    APIENTRY NtGdiGetFontData(IN HDC hdc,IN DWORD dwTable,IN DWORD dwOffset,OUT PVOID  pvBuf,IN ULONG cjBuf);
W32KAPI ULONG    APIENTRY NtGdiGetGlyphOutline(IN HDC hdc, IN WCHAR wch, IN UINT iFormat, OUT LPGLYPHMETRICS pgm,
                                               IN ULONG cjBuf,OUT PVOID pvBuf, IN LPMAT2 pmat2, IN BOOL bIgnoreRotation);
W32KAPI BOOL     APIENTRY NtGdiGetETM(IN HDC hdc,OUT EXTTEXTMETRIC *petm);
W32KAPI BOOL     APIENTRY NtGdiGetRasterizerCaps(OUT LPRASTERIZER_STATUS praststat, IN ULONG cjBytes);
W32KAPI ULONG    APIENTRY NtGdiGetKerningPairs(IN HDC hdc,IN ULONG cPairs,OUT KERNINGPAIR *pkpDst);
W32KAPI BOOL     APIENTRY NtGdiMonoBitmap(IN HBITMAP hbm);
W32KAPI HBITMAP  APIENTRY NtGdiGetObjectBitmapHandle(IN HBRUSH hbr,OUT UINT *piUsage);
W32KAPI ULONG    APIENTRY NtGdiEnumObjects(IN HDC hdc,IN int iObjectType,IN ULONG cjBuf,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiResetDC(IN HDC hdc, IN LPDEVMODEW pdm,OUT PBOOL pbBanding,IN VOID *pDriverInfo2, OUT VOID *ppUMdhpdev);
W32KAPI DWORD    APIENTRY NtGdiSetBoundsRect(IN HDC hdc,IN LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiGetColorAdjustment(IN HDC hdc,OUT PCOLORADJUSTMENT pcaOut);
W32KAPI BOOL     APIENTRY NtGdiSetColorAdjustment(IN HDC hdc, IN PCOLORADJUSTMENT pca);
W32KAPI BOOL     APIENTRY NtGdiCancelDC(IN HDC hdc);
W32KAPI HDC      APIENTRY NtGdiOpenDCW(IN PUNICODE_STRING pustrDevice, IN DEVMODEW *pdm, IN PUNICODE_STRING pustrLogAddr,
                                       IN ULONG iType, IN HANDLE hspool, IN VOID *pDriverInfo2, OUT VOID *pUMdhpdev);
W32KAPI BOOL     APIENTRY NtGdiGetDCDword( IN HDC hdc, IN UINT u, OUT DWORD *Result);
W32KAPI BOOL     APIENTRY NtGdiGetDCPoint(IN HDC hdc,IN UINT iPoint,OUT PPOINTL pptOut);
W32KAPI BOOL     APIENTRY NtGdiScaleViewportExtEx(IN HDC hdc, IN int xNum, IN int xDenom, IN int yNum,
                                                  IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiScaleWindowExtEx(IN HDC hdc, IN int xNum,IN int xDenom, IN int yNum, IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiSetVirtualResolution(IN HDC hdc, IN int cxVirtualDevicePixel,IN int cyVirtualDevicePixel,
                                                    IN int cxVirtualDeviceMm, IN int cyVirtualDeviceMm);
W32KAPI BOOL     APIENTRY NtGdiSetSizeDevice(IN HDC hdc, IN int cxVirtualDevice,IN int cyVirtualDevice);
W32KAPI BOOL     APIENTRY NtGdiGetTransform(IN HDC hdc, IN DWORD iXform, OUT LPXFORM pxf);
W32KAPI BOOL     APIENTRY NtGdiModifyWorldTransform(IN HDC hdc, IN LPXFORM pxf,IN DWORD iXform);
W32KAPI BOOL     APIENTRY NtGdiCombineTransform(OUT LPXFORM pxfDst,IN LPXFORM pxfSrc1,IN LPXFORM pxfSrc2);
W32KAPI BOOL     APIENTRY NtGdiTransformPoints(IN HDC hdc,IN PPOINT pptIn,OUT PPOINT pptOut, IN int c,IN int iMode);
W32KAPI LONG     APIENTRY NtGdiConvertMetafileRect(IN HDC hdc,IN OUT PRECTL prect);

W32KAPI int      APIENTRY NtGdiGetTextCharsetInfo(IN HDC hdc, OUT LPFONTSIGNATURE lpSig, IN DWORD dwFlags);

W32KAPI BOOL     APIENTRY NtGdiDoBanding(IN HDC hdc, IN BOOL bStart, OUT POINTL *pptl, OUT PSIZE pSize);
W32KAPI ULONG    APIENTRY NtGdiGetPerBandInfo( IN HDC hdc, IN OUT PERBANDINFO *ppbi);

#define GS_NUM_OBJS_ALL    0
#define GS_HANDOBJ_CURRENT 1
#define GS_HANDOBJ_MAX     2
#define GS_HANDOBJ_ALLOC   3
#define GS_LOOKASIDE_INFO  4
W32KAPI NTSTATUS APIENTRY NtGdiGetStats(IN HANDLE hProcess,IN int iIndex, IN int iPidType, OUT PVOID pResults,IN UINT cjResultSize);

//API's used by USER
W32KAPI BOOL     APIENTRY NtGdiSetMagicColors(IN HDC hdc,IN PALETTEENTRY peMagic,IN ULONG Index);

W32KAPI HBRUSH   APIENTRY NtGdiSelectBrush(IN HDC hdc,IN HBRUSH hbrush);
W32KAPI HPEN     APIENTRY NtGdiSelectPen(IN HDC hdc,IN HPEN hpen);
W32KAPI HBITMAP  APIENTRY NtGdiSelectBitmap(IN HDC hdc,IN HBITMAP hbm);
W32KAPI HFONT    APIENTRY NtGdiSelectFont(IN HDC hdc, IN HFONT hf);

W32KAPI int      APIENTRY NtGdiExtSelectClipRgn(IN HDC hdc, IN HRGN hrgn, IN int iMode);

W32KAPI HPEN     APIENTRY NtGdiCreatePen(IN int iPenStyle, IN int iPenWidth, IN COLORREF cr, IN HBRUSH hbr);

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifndef _WINDOWBLT_NOTIFICATION_
#define _WINDOWBLT_NOTIFICATION_
#endif
#ifdef _WINDOWBLT_NOTIFICATION_
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor, IN FLONG fl);
#else
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor);
#endif
W32KAPI BOOL     APIENTRY NtGdiTileBitBlt(IN HDC hdcDst,IN RECTL * prectDst, IN HDC hdcSrc, IN RECTL * prectSrc, IN POINTL * pptlOrigin,
                                      IN DWORD rop4, IN DWORD crBackColor);

W32KAPI BOOL     APIENTRY NtGdiTransparentBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                              IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                              IN COLORREF TransColor);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtent(IN HDC hdc, IN LPWSTR lpwsz, IN int cwc, OUT LPSIZE psize, IN UINT flOpts);
W32KAPI BOOL     APIENTRY NtGdiGetTextMetricsW(IN HDC hdc, OUT TMW_INTERNAL * ptm, IN ULONG cj);
W32KAPI int      APIENTRY NtGdiGetTextFaceW(IN HDC hdc, IN int cChar, OUT LPWSTR pszOut, IN BOOL bAliasName);
W32KAPI int      APIENTRY NtGdiGetRandomRgn(IN HDC hdc, IN HRGN hrgn, IN int iRgn);
W32KAPI BOOL     APIENTRY NtGdiExtTextOutW(IN HDC hdc, IN int x, IN int y, IN UINT flOpts, IN LPRECT prcl, IN LPWSTR pwsz,
                                           IN int cwc, IN LPINT pdx, IN DWORD dwCodePage);
W32KAPI int      APIENTRY NtGdiIntersectClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiPatBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx,IN int cy, IN DWORD rop4);
typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;
W32KAPI BOOL     APIENTRY NtGdiPolyPatBlt(IN HDC hdc,IN DWORD rop4, IN PPOLYPATBLT pPoly, IN DWORD Count, IN DWORD Mode);

W32KAPI BOOL     APIENTRY NtGdiUnrealizeObject(IN HANDLE h);
W32KAPI HANDLE   APIENTRY NtGdiGetStockObject(IN int iObject);
W32KAPI HBITMAP  APIENTRY NtGdiCreateCompatibleBitmap(IN HDC hdc,IN int cx,IN int cy);
W32KAPI BOOL     APIENTRY NtGdiLineTo(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiMoveTo(IN HDC hdc,IN int x,IN int y,OUT LPPOINT pptOut);
W32KAPI int      APIENTRY NtGdiExtGetObjectW(IN HANDLE h,IN int cj,OUT LPVOID pvOut);
W32KAPI int      APIENTRY NtGdiGetDeviceCaps(IN HDC hdc, IN int i);
W32KAPI BOOL     APIENTRY NtGdiGetDeviceCapsAll (IN HDC hdc, OUT PDEVCAPS pDevCaps);
W32KAPI BOOL     APIENTRY NtGdiStretchBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                          IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                          IN DWORD dwRop,IN DWORD dwBackColor);
W32KAPI BOOL     APIENTRY NtGdiSetBrushOrg(IN HDC hdc,IN int x, IN int y, OUT LPPOINT pptOut);
W32KAPI HBITMAP  APIENTRY NtGdiCreateBitmap(IN int cx, IN int cy, IN UINT cPlanes, IN UINT cBPP, OUT LPBYTE pjInit);
W32KAPI HPALETTE APIENTRY NtGdiCreateHalftonePalette(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiRestoreDC(IN HDC hdc,IN int iLevel);
W32KAPI int      APIENTRY NtGdiExcludeClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI int      APIENTRY NtGdiSaveDC(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiCombineRgn(IN HRGN hrgnDst,IN HRGN hrgnSrc1, IN HRGN hrgnSrc2,IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiSetRectRgn(IN HRGN hrgn,IN int xLeft,IN int  yTop, IN int xRight,IN int yBottom);
W32KAPI LONG     APIENTRY NtGdiSetBitmapBits(IN HBITMAP hbm,IN ULONG cj,IN PBYTE pjInit);

W32KAPI int      APIENTRY NtGdiGetDIBitsInternal(IN HDC hdc, IN HBITMAP hbm, IN UINT iStartScan,IN UINT cScans,
                                                 OUT LPBYTE pBits, IN OUT LPBITMAPINFO pbmi, IN UINT iUsage,
                                                 IN UINT cjMaxBits, IN UINT cjMaxInfo);
W32KAPI int      APIENTRY NtGdiOffsetRgn(IN HRGN hrgn,IN int cx,IN int  cy);
W32KAPI int      APIENTRY NtGdiGetRgnBox(IN HRGN hrgn, OUT LPRECT prcOut);
W32KAPI BOOL     APIENTRY NtGdiRectInRegion(IN HRGN hrgn, OUT LPRECT prcl);
W32KAPI DWORD    APIENTRY NtGdiGetBoundsRect(IN HDC hdc, OUT LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiPtInRegion(IN HRGN hrgn,IN int x,IN int y);
W32KAPI COLORREF APIENTRY NtGdiGetNearestColor(IN HDC hdc, IN COLORREF cr);
W32KAPI UINT     APIENTRY NtGdiGetSystemPaletteUse(IN HDC hdc);
W32KAPI UINT     APIENTRY NtGdiSetSystemPaletteUse(IN HDC hdc, IN UINT ui);
W32KAPI DWORD    APIENTRY NtGdiGetRegionData(IN HRGN hrgn,IN DWORD nCount, OUT LPRGNDATA lpRgnData);
W32KAPI BOOL     APIENTRY NtGdiInvertRgn(IN HDC hdc, IN HRGN hrgn);

// MISC FONT API's

int     W32KAPI  APIENTRY NtGdiAddFontResourceW(IN WCHAR *pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN FLONG f,
                                                IN DWORD dwPidTid, IN DESIGNVECTOR *pdv);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN ENUMLOGFONTEXDVW *pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG  fl, IN PVOID pvCliData);
#else
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN LPEXTLOGFONTW pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG fl, IN PVOID pvCliData);
#endif

W32KAPI ULONG    APIENTRY NtGdiSetFontEnumeration(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiEnumFontClose(IN ULONG_PTR idEnum);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI BOOL     APIENTRY NtGdiEnumFontChunk(IN HDC hdc,IN ULONG_PTR idEnum,IN ULONG cefdw,
                                             OUT ULONG *pcefdw,OUT PENUMFONTDATAW pefdw);
#endif
W32KAPI ULONG_PTR  APIENTRY NtGdiEnumFontOpen(IN HDC hdc, IN ULONG iEnumType, IN FLONG flWin31Compat, IN ULONG cwchMax,
                                              IN LPWSTR pwszFaceName, IN ULONG lfCharSet, OUT ULONG *pulCount);

#define TYPE_ENUMFONTS          1
#define TYPE_ENUMFONTFAMILIES   2
#define TYPE_ENUMFONTFAMILIESEX 3

W32KAPI INT      APIENTRY NtGdiQueryFonts(OUT PUNIVERSAL_FONT_ID pufiFontList,IN ULONG nBufferSize,
                                          OUT PLARGE_INTEGER pTimeStamp );

// Console API

W32KAPI BOOL     APIENTRY NtGdiConsoleTextOut(IN HDC hdc, IN POLYTEXTW *lpto,IN UINT nStrings, IN RECTL *prclBounds);
W32KAPI NTSTATUS APIENTRY NtGdiFullscreenControl(IN FULLSCREENCONTROL FullscreenCommand, IN PVOID FullscreenInput,
                                                 IN DWORD FullscreenInputLength, OUT PVOID FullscreenOutput,
                                                 IN OUT PULONG FullscreenOutputLength);


// needed for win95 functionality

W32KAPI DWORD    NtGdiGetCharSet(IN HDC hdc);

// needed for fontlinking

W32KAPI BOOL APIENTRY  NtGdiEnableEudc(IN BOOL);
W32KAPI BOOL APIENTRY  NtGdiEudcLoadUnloadLink(IN LPCWSTR pBaseFaceName, IN UINT cwcBaseFaceName, IN LPCWSTR pEudcFontPath,
                                               IN UINT cwcEudcFontPath, IN INT iPriority, IN INT iFontLinkType, IN BOOL bLoadLin);
W32KAPI UINT APIENTRY  NtGdiGetStringBitmapW(IN HDC hdc, IN LPWSTR pwsz, IN UINT cwc, OUT BYTE *lpSB, IN UINT cj);
W32KAPI ULONG APIENTRY NtGdiGetEudcTimeStampEx(IN LPWSTR lpBaseFaceName,IN ULONG cwcBaseFaceName,IN BOOL bSystemTimeStamp);
W32KAPI ULONG APIENTRY NtGdiQueryFontAssocInfo(IN HDC hdc);

#if (_WIN32_WINNT >= 0x0500)
W32KAPI DWORD NtGdiGetFontUnicodeRanges(IN HDC hdc, OUT LPGLYPHSET pgs);
#endif

#ifdef LANGPACK
W32KAPI BOOL NtGdiGetRealizationInfo(IN HDC hdc, OUT PREALIZATION_INFO pri, IN HFONT hf);
#endif

typedef struct tagDOWNLOADDESIGNVECTOR {
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR      dv;
} DOWNLOADDESIGNVECTOR;

W32KAPI BOOL NtGdiAddRemoteMMInstanceToDC(IN HDC hdc,IN DOWNLOADDESIGNVECTOR *pddv,IN ULONG cjDDV);

// user-mode printer support

W32KAPI BOOL APIENTRY NtGdiUnloadPrinterDriver(IN LPWSTR pDriverName,IN ULONG cbDriverName);
W32KAPI BOOL APIENTRY NtGdiEngAssociateSurface(IN HSURF  hsurf,IN HDEV hdev,IN FLONG  flHooks);
W32KAPI BOOL APIENTRY NtGdiEngEraseSurface(IN SURFOBJ *pso,IN RECTL *prcl,IN ULONG iColor);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateBitmap(IN SIZEL sizl,IN LONG lWidth,IN ULONG iFormat,IN FLONG fl,IN PVOID pvBits);
W32KAPI BOOL APIENTRY NtGdiEngDeleteSurface(IN HSURF hsurf);
W32KAPI SURFOBJ* APIENTRY NtGdiEngLockSurface(IN HSURF hsurf);
W32KAPI VOID APIENTRY NtGdiEngUnlockSurface(IN SURFOBJ *);
W32KAPI BOOL APIENTRY NtGdiEngMarkBandingSurface(HSURF hsurf);
W32KAPI HSURF APIENTRY NtGdiEngCreateDeviceSurface(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateDeviceBitmap(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);

W32KAPI BOOL APIENTRY NtGdiEngCopyBits(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                       IN RECTL *prclDst,IN POINTL *pptlSrc);
W32KAPI BOOL APIENTRY NtGdiEngStretchBlt(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,
                                         IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlHTOrg, IN RECTL *prclDest,
                                         IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI BOOL APIENTRY NtGdiEngBitBlt(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                     IN RECTL *prclDst,IN POINTL *pptlSrc,IN POINTL *pptlMask,IN BRUSHOBJ *pbo,IN POINTL *pptlBrush,
                                     IN ROP4 rop4);
W32KAPI BOOL APIENTRY NtGdiEngPlgBlt(IN SURFOBJ *psoTrg,IN SURFOBJ *psoSrc, IN SURFOBJ *psoMsk, IN CLIPOBJ *pco,
                                     IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg, IN POINTFIX *pptfxDest,
                                     IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI HPALETTE APIENTRY NtGdiEngCreatePalette(IN ULONG iMode, IN ULONG cColors, IN ULONG *pulColors, IN FLONG flRed,
                                                IN FLONG flGreen, IN FLONG flBlue);
W32KAPI BOOL APIENTRY NtGdiEngDeletePalette(IN HPALETTE hPal);
W32KAPI BOOL APIENTRY NtGdiEngStrokePath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco, IN XFORMOBJ *pxo,
                                         IN BRUSHOBJ *pbo,IN POINTL *pptlBrushOrg,IN LINEATTRS *plineattrs,MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN BRUSHOBJ *pbo,
                                       IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngStrokeAndFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN XFORMOBJ *pxo,
                                                IN BRUSHOBJ *pboStroke,IN LINEATTRS *plineattrs,IN BRUSHOBJ *pboFill,
                                                IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngPaint(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN POINTL *pptlBrushOrg, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngLineTo(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN LONG x1, IN LONG y1,
                                     IN LONG x2, IN LONG y2, IN RECTL *prclBounds, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngAlphaBlend(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, XLATEOBJ *pxlo,IN RECTL *prclDest,
                                         IN RECTL *prclSrc,IN BLENDOBJ *pBlendObj);
W32KAPI BOOL APIENTRY NtGdiEngGradientFill(IN SURFOBJ *psoDest,IN CLIPOBJ *pco, IN XLATEOBJ *pxlo, TRIVERTEX *pVertex,
                                           IN ULONG nVertex, IN PVOID pMesh, IN ULONG nMesh, IN RECTL *prclExtents,
                                           IN POINTL *pptlDitherOrg, IN ULONG ulMode);
W32KAPI BOOL APIENTRY NtGdiEngTransparentBlt(IN SURFOBJ *psoDst, IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, IN XLATEOBJ *pxlo,
                                             IN RECTL *prclDst, IN RECTL *prclSrc, IN ULONG iTransColor, ULONG ulReserved);
W32KAPI BOOL APIENTRY NtGdiEngTextOut(IN SURFOBJ *pso,IN STROBJ *pstro, IN FONTOBJ *pfo, IN CLIPOBJ *pco, IN RECTL *prclExtra,
                                      IN RECTL *prclOpaque, IN BRUSHOBJ *pboFore, IN BRUSHOBJ *pboOpaque, IN POINTL *pptlOrg,
                                      IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngStretchBltROP(IN SURFOBJ *psoTrg, IN SURFOBJ *psoSrc, IN SURFOBJ *psoMask, IN CLIPOBJ *pco,
                                            IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg,
                                            IN RECTL *prclTrg, IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode,
                                            IN BRUSHOBJ *pbo, IN ROP4 rop4);

W32KAPI ULONG APIENTRY NtGdiXLATEOBJ_cGetPalette(IN XLATEOBJ *pxlo, IN ULONG iPal, IN ULONG cPal, OUT ULONG *pPal);

W32KAPI ULONG    APIENTRY NtGdiCLIPOBJ_cEnumStart(IN CLIPOBJ *pco, IN BOOL bAll, IN ULONG iType, IN ULONG iDirection, IN ULONG cLimit);
W32KAPI BOOL     APIENTRY NtGdiCLIPOBJ_bEnum(IN CLIPOBJ *pco, IN ULONG cj, OUT ULONG *pul);
W32KAPI PATHOBJ* APIENTRY NtGdiCLIPOBJ_ppoGetPath(IN CLIPOBJ *pco);
W32KAPI CLIPOBJ* APIENTRY NtGdiEngCreateClip();
W32KAPI VOID     APIENTRY NtGdiEngDeleteClip(IN CLIPOBJ*pco);

W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvAllocRbrush(IN BRUSHOBJ *pbo,IN ULONG cj);
W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvGetRbrush(IN BRUSHOBJ *pbo);
W32KAPI ULONG    APIENTRY NtGdiBRUSHOBJ_ulGetBrushColor(IN BRUSHOBJ *pbo);
W32KAPI HANDLE   APIENTRY NtGdiBRUSHOBJ_hGetColorTransform(IN BRUSHOBJ *pbo);

W32KAPI BOOL     APIENTRY NtGdiXFORMOBJ_bApplyXform(IN XFORMOBJ *pxo, IN ULONG iMode, IN ULONG cPoints, IN PVOID pvIn, OUT PVOID pvOut);
W32KAPI ULONG    APIENTRY NtGdiXFORMOBJ_iGetXform(IN XFORMOBJ *pxo, OUT XFORML *pxform);

W32KAPI VOID     APIENTRY NtGdiFONTOBJ_vGetInfo(IN FONTOBJ *pfo, IN ULONG cjSize, OUT FONTINFO *pfi);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetGlyphs(IN FONTOBJ *pfo, IN ULONG iMode, IN ULONG cGlyph, IN HGLYPH *phg, OUT PVOID *ppvGlyph);
W32KAPI XFORMOBJ*  APIENTRY NtGdiFONTOBJ_pxoGetXform(IN FONTOBJ *pfo);
W32KAPI IFIMETRICS* APIENTRY NtGdiFONTOBJ_pifi(IN FONTOBJ *pfo);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiFONTOBJ_pfdg(IN FONTOBJ *pfo);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetAllGlyphHandles(IN FONTOBJ *pfo, OUT HGLYPH *phg);
W32KAPI PVOID    APIENTRY  NtGdiFONTOBJ_pvTrueTypeFontFile(IN FONTOBJ *pfo, OUT ULONG *pcjFile);
W32KAPI PFD_GLYPHATTR APIENTRY NtGdiFONTOBJ_pQueryGlyphAttrs(IN FONTOBJ *pfo, IN ULONG iMode);

W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnum(IN STROBJ *pstro, OUT ULONG *pc, OUT PGLYPHPOS *ppgpos);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnumPositionsOnly(IN STROBJ *pstro,ULONG *pc,OUT PGLYPHPOS *ppgpos);
W32KAPI VOID     APIENTRY NtGdiSTROBJ_vEnumStart(IN STROBJ *pstro);
W32KAPI DWORD    APIENTRY NtGdiSTROBJ_dwGetCodePage(IN STROBJ *pstro);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bGetAdvanceWidths(IN STROBJ*pstro, IN ULONG iFirst, IN ULONG c, OUT POINTQF*pptqD);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiEngComputeGlyphSet(IN INT nCodePage, IN INT nFirstChar, IN INT cChars);

W32KAPI ULONG    APIENTRY NtGdiXLATEOBJ_iXlate(IN XLATEOBJ *pxlo, IN ULONG iColor);
W32KAPI HANDLE   APIENTRY NtGdiXLATEOBJ_hGetColorTransform(IN XLATEOBJ *pxlo);

W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vGetBounds(IN PATHOBJ *ppo, OUT PRECTFX prectfx);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnum(IN PATHOBJ *ppo, OUT PATHDATA  *ppd);  
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStart(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiEngDeletePath(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStartClipLines(IN PATHOBJ *ppo, IN CLIPOBJ *pco, IN SURFOBJ *pso, IN LINEATTRS *pla);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnumClipLines(IN PATHOBJ *ppo, IN ULONG cb, OUT CLIPLINE *pcl);

W32KAPI BOOL     APIENTRY NtGdiEngCheckAbort(IN SURFOBJ *pso);
W32KAPI DHPDEV            NtGdiGetDhpdev(IN HDEV hdev);

W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPFormatPalette(OUT LPPALETTEENTRY pPaletteEntry, IN USHORT RedGamma,
                                                       IN USHORT GreenGamma, IN USHORT BlueGamma);
W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPMaskPalette(OUT LPPALETTEENTRY pPaletteEntry, IN BOOL Use8BPPMaskPal,
                                                     IN BYTE CMYMask, IN USHORT RedGamma, IN USHORT GreenGamma, IN USHORT BlueGamma);

W32KAPI BOOL              NtGdiUpdateTransform(IN HDC hdc);

W32KAPI DWORD    APIENTRY NtGdiSetLayout(IN HDC hdc, IN LONG wox, IN DWORD dwLayout);
W32KAPI BOOL     APIENTRY NtGdiMirrorWindowOrg(IN HDC hdc);
W32KAPI LONG     APIENTRY NtGdiGetDeviceWidth(IN HDC hdc);

W32KAPI BOOL              NtGdiSetPUMPDOBJ(IN HUMPD humpd, IN BOOL bStoreID, OUT HUMPD *phumpd, OUT BOOL *pbWOW64);
W32KAPI BOOL              NtGdiBRUSHOBJ_DeleteRbrush(IN BRUSHOBJ *pbo, IN BRUSHOBJ *pboB);
W32KAPI BOOL              NtGdiUMPDEngFreeUserMem(IN KERNEL_PVOID *ppv);
W32KAPI HBITMAP APIENTRY NtGdiSetBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBITMAP APIENTRY NtGdiClearBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiSetBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiClearBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);

// Private draw stream interface

W32KAPI BOOL APIENTRY NtGdiDrawStream(IN HDC, IN ULONG, IN VOID *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\stdcall.inc ===
;****************************Public Macro************************************
;
;   ComposeInst Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
;
;       This macro simply concatenates all arguments into one string.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
; Module Name: stdcall.inc
;
; Copyright (c) 1991-1999 Microsoft Corporation
;****************************************************************************
  
;
;****************************************************************************

ComposeInst macro   Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
        &Inst   &p1&p2&p3&p4&p5&p6&p7&p8&p9
endm

;****************************Public Macro************************************
;
;   CountArg    cCount,ArgList
;
;       This macro count the number of arguments in the ArgList and returns
;       the value in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

CountArg    macro   cCount,ArgList

        cCount = 0

        irp arg,<ArgList>
            cCount = cCount+1
        endm
endm

;****************************Public Macro************************************
;
;   RevPush     ArgList,cCount
;
;       This macro pushes the arguments in ArgList in the reverse order
;       and returns the number of arguments in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

RevPush macro   ArgList,cCount
        Local   index,x

        CountArg cCount,<ArgList>

        index  = cCount
        rept    cCount
            x = 0
            irp arg,<ArgList>
                x = x+1
                ife index-x
                    push    arg
                    exitm
                endif
            endm
            index = index-1
        endm
endm

;****************************Public Macro************************************
;
;   The following sections contain calling-convention related macros for:
;
;   PUBLICP     Func,N
;       to define a public label
;
;   EXTRNP      Func,N
;       to define a external near label
;
;   LABELP      Func,N
;       to label an address as a routine entry point
;
;   cProc       Func,N,ArgList
;       to declare a routine header
;
;   ProcName    Name,Func,N
;       to rename a function Func to Name. Using it in conjunction with
;       normal function declaration (with the new name) will solve an error
;       caused by a long parameter list routine that exhausts page width.
;
;   cRet        Func
;       to return from Func routines (declared with cProc or ProcName.)
;
;   endProc     Func
;       to declare the end of routine (declared with cProc or ProcName.)
;
;   endMod      Func
;       to declare the end of module with an entry point at Func (declared
;       with cProc or ProcName.)
;
;   cCall       Func,ArgList
;       to call to a routine--Func--with the arguments pushed on the stack
;
;   ptrCall     Func,ArgList
;       to call through a pointer with the arguments pushed on the stack
;
;   MovAddr     dest,Func,n
;       to move the address of the routine--Func--into dest.
;
;   Note that for the standard calling convention all the function names,
;   Func, are automatically converted to Func@N where N is the number of
;   bytes in the argument list.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

IFNDEF  DOS_PLATFORM
IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for C calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif

endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   ; STD_CALL

ELSE

IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for Pascal calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

cCall   macro   Func,ArgList
        irp arg,<ArgList>
            push    arg
        endm

        call    &Func
endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   : ~STD_CALL
ENDIF   ; DOS_PLATFORM

IFDEF STD_CALL
;****************************************************************************
;
;   This section is used exclusively for the standard calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        ifb    <N>
            public      &Func&@0
        else
            public      &Func&@&N
        endif
endm

EXTRNP  macro   Func,N

        ifb    <N>
            extrn       &Func&@0:NEAR
        else
            extrn       &Func&@&N:NEAR
        endif
endm

LABELP  macro   Func,N

        ifb    <N>
            &Func&@0    LABEL   NEAR
        else
            &Func&@&N   LABEL   NEAR
        endif
endm

ProcName macro  Name,Func,N

        ifb <N>
            cByte&Func   EQU     0
            &Name        EQU     <&Func&@0>
        else
            cByte&Func   EQU     N
            &Name        EQU     <&Func&@&N>
        endif
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret     cByte&Func

endm


endProc macro   Func

        xxx&Func   endp

endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        call    &Func
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        ComposeInst <call>,&Func,<@>,%(Bytes)
endm

MovAddr macro   dest,addr,n

        ComposeInst <mov >,dest,<,offset FLAT:>,addr,<@>,n
endm

ENDIF   ;STD_CALL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\xfflags.h ===
/******************************Module*Header*******************************\
* Module Name: xfflags.h
*
* Shared flags for use in client and server side transform code.
*
* Created: 3-Aug-1992 22:34:23
* Author: Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#ifndef INC_XFFLAGS
#define INC_XFFLAGS


#define XFORM_SCALE             1   // off-diagonal are 0
#define XFORM_UNITY             2   // diagonal are 1s, off-diagonal are 0
                                    // will be set only if XFORM_SCALE is set
#define XFORM_Y_NEG             4   // M22 is negative.  Will be set only if
                                    // XFORM_SCALE|XFORM_UNITY are set
#define XFORM_FORMAT_LTOFX      8   // transform from LONG to FIX format
#define XFORM_FORMAT_FXTOL     16   // transform from FIX to LONG format
#define XFORM_FORMAT_LTOL      32   // transform from LONG to LONG format
#define XFORM_NO_TRANSLATION   64   // no translations

#define MATRIX_SET_IDENTITY     1
#define MATRIX_SET              2
#define MATRIX_MODIFY           3



#define METAFILE_TO_WORLD_IDENTITY       0x00000001L
#define WORLD_TO_PAGE_IDENTITY	         0x00000002L
#define DEVICE_TO_PAGE_INVALID	         0x00000008L
#define DEVICE_TO_WORLD_INVALID          0x00000010L
#define WORLD_TRANSFORM_SET              0x00000020L
#define POSITIVE_Y_IS_UP                 0x00000040L
#define INVALIDATE_ATTRIBUTES            0x00000080L
#define PTOD_EFM11_NEGATIVE              0x00000100L
#define PTOD_EFM22_NEGATIVE              0x00000200L
#define ISO_OR_ANISO_MAP_MODE            0x00000400L
#define PAGE_TO_DEVICE_IDENTITY          0x00000800L
#define PAGE_TO_DEVICE_SCALE_IDENTITY    0x00001000L
#define PAGE_XLATE_CHANGED               0x00002000L
#define PAGE_EXTENTS_CHANGED             0x00004000L
#define WORLD_XFORM_CHANGED              0x00008000L


#endif  // #ifndef INC_XFFLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\umpd.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpd.cxx

Abstract:

    User-mode printer driver support

Environment:

        Windows NT 5.0

Revision History:

        07/8/97 -lingyunw-
                Created it.

--*/

#ifndef __UMPD__
#define __UMPD__

#define INDEX_UMPDDrvEnableDriver       INDEX_LAST+1

#define INDEX_LoadUMPrinterDrv          INDEX_LAST+2        // used for WOW64, spooler calls
#define INDEX_UnloadUMPrinterDrv        INDEX_LAST+3
#define INDEX_UMDriverFN                INDEX_LAST+4
#define INDEX_DocumentEvent             INDEX_LAST+5
#define INDEX_StartDocPrinterW          INDEX_LAST+6
#define INDEX_StartPagePrinter          INDEX_LAST+7
#define INDEX_EndPagePrinter            INDEX_LAST+8
#define INDEX_EndDocPrinter             INDEX_LAST+9
#define INDEX_AbortPrinter              INDEX_LAST+10
#define INDEX_ResetPrinterW             INDEX_LAST+11
#define INDEX_QueryColorProfile         INDEX_LAST+12

#define INDEX_UMPDAllocUserMem          INDEX_LAST+13     // used for WOW64, large bitmaps
#define INDEX_UMPDCopyMemory            INDEX_LAST+14
#define INDEX_UMPDFreeMemory            INDEX_LAST+15
#define INDEX_UMPDEngFreeUserMem        INDEX_LAST+16


typedef struct _HPRINTERLIST
{
    struct _HPRINTERLIST  *pNext;
    DWORD                 clientPid;
    DWORD                 hPrinter32;
    HANDLE                hPrinter64;
}HPRINTERLIST, *PHPRINTERLIST;

typedef struct _UMPD {
    DWORD               dwSignature;        // data structure signature
    struct _UMPD *      pNext;             // linked list pointer
    PDRIVER_INFO_2W     pDriverInfo2;       // pointer to driver info
    HINSTANCE           hInst;              // instance handle to user-mode printer driver module
    DWORD               dwFlags;            // misc. flags
    BOOL                bArtificialIncrement; // indicates if the ref cnt has been bumped up to
                                          // defer unloading
    DWORD               dwDriverVersion;    // version number of the loaded driver
    INT                 iRefCount;          // reference count

    struct ProxyPort *  pp;                 // UMPD proxy server
    KERNEL_PVOID        umpdCookie;         // cookie returned back from proxy
    
    
    PHPRINTERLIST       pHandleList;        // list of hPrinter's opened on the proxy server


    PFN                 apfn[INDEX_LAST];   // driver function table
} UMPD, *PUMPD;


typedef struct _UMDHPDEV {

    PUMPD  pUMPD;
    DHPDEV dhpdev;

//    HDC    hdc;          // the printer DC that's associated with the pdev
//    PBYTE  pvEMF;        // the pointer to the emf if we are playing the emf on the hdc
//    PBYTE  pvCurrentRecord; // the pointer to the current emf record if we are playing emf

} UMDHPDEV, *PUMDHPDEV;

typedef KERNEL_PVOID   KERNEL_PUMDHPDEV;

typedef struct
{
    UMTHDR          umthdr;
    HUMPD           humpd;
} UMPDTHDR;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    cookie;
}  DRVDRIVERFNINPUT, *PDRVDRIVERFNINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    PWSTR   pwszDriver;
}  DRVENABLEDRIVERINPUT, *PDRVENABLEDRIVERINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    KERNEL_PVOID umpdCookie;
    PDEVMODEW   pdm;
    PWSTR       pLogAddress;
    ULONG       cPatterns;
    HSURF       *phsurfPatterns;
    ULONG       cjCaps;
    ULONG       *pdevcaps;
    ULONG       cjDevInfo;
    DEVINFO     *pDevInfo;
    HDEV        hdev;
    PWSTR       pDeviceName;
    HANDLE      hPrinter;
    BOOL        bWOW64;
    DWORD       clientPid;
#if defined(_WIN64)
    ULONG       cxHTPat;
    ULONG       cyHTPat;
    LPBYTE      pHTPatA, pHTPatB, pHTPatC;
    BOOL        bHTPatA, bHTPatB, bHTPatC;
#endif
}  DRVENABLEPDEVINPUT, *PDRVENABLEPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdev;
    HDEV    hdev;
}  DRVCOMPLETEPDEVINPUT, *PDRVCOMPLETEPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdevOld;
    DHPDEV  dhpdevNew;
}  DRVRESETPDEVINPUT, *PDRVRESETPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdev;
}  DHPDEVINPUT, *PDHPDEVINPUT;

//
// Note: can't pass kernel pointers over to client side.
//

typedef struct _DRVESCAPEINPUT
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    ULONG       iEsc;
    ULONG       cjIn;
    PVOID       pvIn;
    ULONG       cjOut;
    PVOID       pvOut;
} DRVESCAPEINPUT, *PDRVESCAPEINPUT;

typedef struct _DRVDRAWESCAPEINPUT
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    ULONG       iEsc;
    CLIPOBJ     *pco;
    RECTL       *prcl;
    ULONG       cjIn;
    PVOID       pvIn;
} DRVDRAWESCAPEINPUT, *PDRVDRAWESCAPEINPUT;


typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    CLIPOBJ    *pco;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrushOrg;
    POINTL     ptlBrushOrg;
    MIX        mix;
}  DRVPAINTINPUT, *PDRVPAINTINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    CLIPOBJ    *pco;
    BRUSHOBJ   *pbo;
    LONG       x1;
    LONG       y1;
    LONG       x2;
    LONG       y2;
    RECTL      *prclBounds;
    MIX        mix;
}  DRVLINETOINPUT, *PDRVLINETOINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoSrc;
    SURFOBJ    *psoMask;
    CLIPOBJ    *pco;
    XLATEOBJ   *pxlo;
    RECTL      *prclTrg;
    POINTL     *pptlSrc;
    POINTL     *pptlMask;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrush;
    ROP4       rop4;
}  DRVBITBLTINPUT, *PDRVBITBLTINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoSrc;
    CLIPOBJ    *pco;
    XLATEOBJ   *pxlo;
    RECTL      *prclTrg;
    POINTL     *pptlSrc;
}  DRVCOPYBITSINPUT, *PDRVCOPYBITSINPUT;


typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    SURFOBJ         *psoMask;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    COLORADJUSTMENT *pca;
    POINTL          *pptlHTOrg;
    RECTL           *prclTrg;
    RECTL           *prclSrc;
    POINTL          *pptlMask;
    ULONG           iMode;
    BRUSHOBJ        *pbo;
    ROP4            rop4;
}  DRVSTRETCHBLTINPUT, *PDRVSTRETCHBLTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    SURFOBJ         *psoMask;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    COLORADJUSTMENT *pca;
    POINTL          *pptlBrushOrg;
    POINTFIX        *pptfx;
    RECTL           *prcl;
    POINTL          *pptl;
    ULONG           iMode;
}  DRVPLGBLTINPUT, *PDRVPLGBLTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    RECTL           *prclDest;
    RECTL           *prclSrc;
    BLENDOBJ        *pBlendObj;
}  ALPHAINPUT, *PALPHAINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    RECTL           *prclDst;
    RECTL           *prclSrc;
    ULONG           TransColor;
    UINT            ulReserved;
}  TRANSPARENTINPUT, *PTRANSPARENTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    TRIVERTEX       *pVertex;
    ULONG           nVertex;
    PVOID           pMesh;
    ULONG           nMesh;
    RECTL           *prclExtents;
    POINTL          *pptlDitherOrg;
    ULONG           ulMode;
}  GRADIENTINPUT, *PGRADIENTINPUT;


typedef struct
{
    UMPDTHDR  umpdthdr;
    SURFOBJ *pso;
    PWSTR   pwszDocName;
    DWORD   dwJobId;
}  DRVSTARTDOCINPUT, *PDRVSTARTDOCINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    FLONG    fl;
}  DRVENDDOCINPUT, *PDRVENDDOCINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
}  SURFOBJINPUT, *PSURFOBJINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    POINTL   *pptl;
}  DRVBANDINGINPUT, *PDRVBANDINGINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    PERBANDINFO *pbi;
}  DRVPERBANDINPUT, *PDRVPERBANDINPUT;


typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoPat;
    SURFOBJ    *psoMsk;
    BRUSHOBJ   *pbo;
    XLATEOBJ   *pxlo;
    ULONG      iHatch;
}  DRVREALIZEBRUSHINPUT, *PDRVREALIZEBRUSHINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    PATHOBJ    *ppo;
    CLIPOBJ    *pco;
    XFORMOBJ   *pxo;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrushOrg;
    LINEATTRS  *plineattrs;
    BRUSHOBJ   *pboFill;
    MIX        mix;
    FLONG      flOptions;
}  STORKEANDFILLINPUT, *PSTROKEANDFILLINPUT;

typedef struct
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    STROBJ      *pstro;
    FONTOBJ     *pfo;
    CLIPOBJ     *pco;
    RECTL       *prclExtra;
    RECTL       *prclOpaque;
    BRUSHOBJ    *pboFore;
    BRUSHOBJ    *pboOpaque;
    POINTL      *pptlOrg;
    MIX         mix;
}  TEXTOUTINPUT, *PTEXTOUTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV      dhpdev;
    ULONG_PTR   iFile;
    ULONG       iFace;
    ULONG       iMode;
    ULONG       *pid;
    ULONG       cjMaxData;
    PVOID       pv;
}  QUERYFONTINPUT, *PQUERYFONTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    HGLYPH    hg;
    GLYPHDATA *pgd;
    PVOID     pv;
    ULONG     cjSize;
}  QUERYFONTDATAINPUT, *PQUERYFONTDATAINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    HGLYPH    *phg;
    PVOID     pvWidths;
    ULONG     cGlyphs;
}  QUERYADVWIDTHSINPUT, *PQUERYADVWIDTHSINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
} GETGLYPHMODEINPUT, *PGETGLYPHMODEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    SURFOBJ   *pso;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    ULONG     cjIn;
    PVOID     pvIn;
    ULONG     cjOut;
    PVOID     pvOut;
} FONTMANAGEMENTINPUT, *PFONTMANAGEMENTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    ULONG     iMode;
    ULONG     rgb;
    ULONG     *pul;
} DRVDITHERCOLORINPUT, *PDRVDITHERCOLORINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    PVOID     pv;
    ULONG     id;
} DRVFREEINPUT, *PDRVFREEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    DHSURF    dhsurf;
} DRVDELETEDEVBITMAP, *PDRVDELETEDEVBITMAP;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    HANDLE    hcmXform;
} DRVICMDELETECOLOR, *PDRVICMDELETECOLOR;

typedef struct
{
    UMPDTHDR           umpdthdr;
    DHPDEV           dhpdev;
    LPLOGCOLORSPACEW pLogColorSpace;
    PVOID            pvSourceProfile;
    ULONG            cjSourceProfile;
    PVOID            pvDestProfile;
    ULONG            cjDestProfile;
    PVOID            pvTargetProfile;
    ULONG            cjTargetProfile;
    DWORD            dwReserved;
} DRVICMCREATECOLORINPUT, *PDRVICMCREATECOLORINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    HANDLE    hColorTransform;
    SURFOBJ   *pso;
    PBYTE     paResults;
} DRVICMCHECKBITMAPINPUT, *PDRVICMCHECKBITMAPINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    XLATEOBJ   *pxlo;
    XFORMOBJ   *pxo;
    ULONG      iType;
    ULONG      cjIn;
    PVOID      pvIn;
    ULONG      cjOut;
    PVOID      pvOut;
}  DRVQUERYDEVICEINPUT, *PDRVQUERYDEVICEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    ULONG       cjSize;
} UMPDALLOCUSERMEMINPUT, *PUMPDALLOCUSERMEMINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    pvSrc;
    KERNEL_PVOID    pvDest;
    ULONG           cjSize;
}  UMPDCOPYMEMINPUT, *PUMPDCOPYMEMINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    pvTrg;
    KERNEL_PVOID    pvSrc;
    KERNEL_PVOID    pvMsk;
}  UMPDFREEMEMINPUT, *PUMPDFREEMEMINPUT;

#endif // __UMPD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\array.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    array.cxx

Abstract:

    This file contains Array class implementation.

Author:

    Jason Hartman (JasonHa) 2000-12-28

Environment:

    User Mode

--*/

#include "precomp.hxx"



template <class T>
Array<T>::Array(
    SIZE_T StartLength
    )
{
    Init();
    Expand(StartLength);
    return;
}


template <class T>
Array<T>::Array(
    T *Data,
    SIZE_T Count
    )
{
    Init();
    Set(Data, Count);
    return;
}


template <class T>
SIZE_T
Array<T>::Expand(
    SIZE_T NewLength
    )
{
    if (NewLength > Length)
    {
        if (NewLength <= Size)
        {
            RtlZeroMemory(Buffer+Length, sizeof(T)*(NewLength-Length));
            Length = NewLength;
        }
        else
        {
            if (hHeap == NULL)
            {
                hHeap = GetProcessHeap();
            }

            if (hHeap != NULL)
            {
                T *NewBuffer;

                NewBuffer = (T *) ((Buffer == NULL) ?
                                   HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(T)*NewLength):
                                   HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, Buffer, sizeof(T)*NewLength));

                if (NewBuffer != NULL)
                {
                    Buffer = NewBuffer;
                    Size = HeapSize(hHeap, 0, Buffer) / sizeof(T);
                    Length = NewLength;
                }
            }

        }
    }

    return Length;
}


template <class T>
void
Array<T>::Set(
    T *Data,
    SIZE_T Count,
    SIZE_T Start
    )
{
    if (Count+Start > Expand(Count+Start)) return;

    RtlCopyMemory(Buffer+Start, Data, sizeof(T)*Count);

    return;
}



template class Array<BOOL>;
template class Array<CHAR>;
template class Array<ULONG>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\inc\winres.h ===
/******************************Module*Header*******************************\
* Module Name: winres.h
*
* structures for accessing font resources within 16 bit fon dlls
*
* Created: 08-May-1991 13:12:57
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

//
//   The main structure for manipulating the resource data.  One of these
//  is created when access is required to a resource,  and it is destroyed
//  when the resource is no longer required.


typedef  struct                 // wrd
{
    PVOID     pvView;           // view of the mapped *.fon file
    ULONG     cjView;           // size of the view

// stuff referring to general resources

    PTRDIFF   dpNewExe;     // Base address of new header in file
    ULONG     ulShift;      // Shift factor for resource info
    PTRDIFF   dpResTab;     // Offset in file of resource table (first RSRC_TYPEINFO struct)
    ULONG     cjResTab;     // Bytes  in file to store for above

// stuff referring to font resources specifically

    ULONG     cFntRes;          // # of font resources in a file
    PTRDIFF   dpFntTab;         // File location of first RSRC_NAMEINFO corresponding to an *.fnt resource
    PTRDIFF   dpFdirRes;        // File location of first RSRC_NAMEINFO corresponding to an FONTDIR resource

} WINRESDATA,  *PWINRESDATA;

//  Bit fields for use with status above.


#define WRD_NOTHING     0x0000  // Unitialised state
#define WRD_FOPEN       0x0001  // File is open
#define WRD_RESDATOK        0x0002  // Resource data available ???


//  The structure passed to,  and filled in by, vGetFontRes().  Contains
//  information about a specific resource type & name.


typedef  struct _RES_ELEM       // re
{
    PVOID   pvResData;      // Address of data
    PTRDIFF dpResData;      // offset of the data above, not used for fon32
    ULONG   cjResData;      // Resource size
    PBYTE   pjFaceName;     // Face name from the font directory
} RES_ELEM, *PRES_ELEM;



//  Function Prototypes

BOOL   bInitWinResData
(
    PVOID pvView,
    ULONG cjView,
    PWINRESDATA pwrd
);

BOOL bGetFntResource
(
    PWINRESDATA pwrd,
    ULONG       iRes,
    PRES_ELEM   pre
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\dcexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: dcexts.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"


// class DC    
#define GetDCField(field)                   \
        GetDCSubField(#field, field)

#define GetDCSubField(field,local)          \
        GetFieldData(offDC, GDIType(DC), field, sizeof(local), &local)

#define GetDCOffset(field)                  \
        GetFieldOffset(GDIType(DC), #field, &offset)

#define GetDCFieldAndOffset(field)          \
    do {                                    \
        GetDCField(field);                  \
        GetDCOffset(field);                 \
    } while (0)

// _DC_ATTR
#define GetDCATTRField(field)               \
        GetDCATTRSubField(#field, field)

#define GetDCATTRSubField(field,local)      \
        GetFieldData(offDCATTR, GDIType(_DC_ATTR), field, sizeof(local), &local)

#define GetDCATTROffset(field)              \
        GetFieldOffset(GDIType(_DC_ATTR), #field, &offset)

#define GetDCATTRFieldAndOffset(field)      \
    do {                                    \
        GetDCATTRField(field);              \
        GetDCATTROffset(field);             \
    } while (0)

// DCLEVEL
#define GetDCLEVELField(field)              \
        GetDCLEVELSubField(#field, field)

#define GetDCLEVELSubField(field,local)     \
        GetFieldData(offDCLEVEL, GDIType(DCLEVEL), field, sizeof(local), &local)

#define GetDCLEVELOffset(field)             \
        GetFieldOffset(GDIType(DCLEVEL), #field, &offset)

#define GetDCLEVELFieldAndOffset(field)     \
    do {                                    \
        GetDCLEVELField(field);             \
        GetDCLEVELOffset(field);            \
    } while (0)


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCGeneral
*
\**************************************************************************/
void vDumpDCgeneral(ULONG64 offDC)
{
#define     DPRINTDCPP(aa,bb)   \
            DPRINTPP(aa,bb,offDC)
#define     DPRINTDCPX(aa,bb)   \
            DPRINTPX(aa,bb,offDC)
#define     DPRINTDCPS(bb)   \
            DPRINTPS(bb,offDC)

#define GetERECTLvalues {   \
        GetFieldData(percl, "ERECTL", "left", sizeof(left), &left);         \
        GetFieldData(percl, "ERECTL", "top", sizeof(top), &top);            \
        GetFieldData(percl, "ERECTL", "right", sizeof(right), &right);      \
        GetFieldData(percl, "ERECTL", "bottom", sizeof(bottom), &bottom);   \
}

    ULONG64     ppdev_, dhpdev_;
    ULONG64     hdcNext_, hdcPrev_;
    ULONG64     prgnAPI_, prgnVis_, prgnRao_;
    ULONG64     psurfInfo_, pDCAttr, ebrushobj;
    ULONG64     hlfntCur_, prfnt_, pPFFList;
    ULONG64     percl;
    SHORT       ipfdDevMax_;
    FSHORT      fs_;
    POINTL      ptlFillOrigin_;
    FLONG       flGraphicsCaps_,flSimulationFlags_;
    LONG        lEscapement_, left, right, top, bottom;
    ULONG       ulCopyCount_, offset;
    DCTYPE      dctp_;
    FLAGDEF     *pfd;

    GetDCFieldAndOffset(ppdev_);
    DPRINTDCPP( ppdev_,          "ppdev_             " );

    GetDCFieldAndOffset(dhpdev_);
    DPRINTDCPP( dhpdev_,         "dhpdev_            " );

    GetDCFieldAndOffset(flGraphicsCaps_);
    DPRINTDCPX( flGraphicsCaps_, "flGraphicsCaps_    " );
    for (pfd = afdGInfo; pfd->psz; pfd++)
        if (pfd->fl & flGraphicsCaps_) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            flGraphicsCaps_ &= ~pfd->fl;
        }
    if (flGraphicsCaps_) dprintf(" \t\t\t%-#x BAD FLAGS\n", flGraphicsCaps_);
    
    GetDCFieldAndOffset(hdcNext_);
    DPRINTDCPP( hdcNext_,        "hdcNext_           " );

    GetDCFieldAndOffset(hdcPrev_);
    DPRINTDCPP( hdcPrev_,        "hdcPrev_           " );
    
    GetDCOffset(erclClip_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclClip            " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );
    
    GetDCOffset(erclWindow_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclWindow          " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );
    
    GetDCOffset(erclBounds_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclBounds_         " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );

    GetDCOffset(erclBoundsApp_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclBoundsApp_      " );
    dprintf("%d %d %d %d\n", left, top, right, bottom);

    GetDCFieldAndOffset(prgnAPI_);
    DPRINTDCPP( prgnAPI_,        "prgnAPI_           " );

    GetDCFieldAndOffset(prgnVis_);
    DPRINTDCPP( prgnVis_,        "prgnVis_           " );
    
    GetDCFieldAndOffset(prgnRao_);
    DPRINTDCPP( prgnRao_,        "prgnRao_           " );
    
    GetDCFieldAndOffset(ipfdDevMax_);
    DPRINTDCPS( "ipfdDevMax_\n" );
    
    GetDCFieldAndOffset(ptlFillOrigin_);
    DPRINTDCPS( "ptlFillOrigin       " );
    dprintf("%d %d\n", ptlFillOrigin_.x, ptlFillOrigin_.y);
    
    GetDCOffset(eboFill_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboFill_\n");
    
    GetDCOffset(eboLine_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboLine_\n");
    
    GetDCOffset(eboText_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboText_\n");
    
    GetDCOffset(eboBackground_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboBackground_\n");
    
    GetDCFieldAndOffset(hlfntCur_);
    DPRINTDCPP( hlfntCur_,       "hlfntCur_          " );

    GetDCFieldAndOffset(flSimulationFlags_);
    DPRINTDCPX( flSimulationFlags_, "flSimulationFlags_ " );
    for (pfd = afdTSIM; pfd->psz; pfd++)
        if (pfd->fl & flSimulationFlags_) {
            dprintf(" \t\t\t\t%s\n", pfd->psz);
            flSimulationFlags_ &= ~pfd->fl;
        }
    if (flSimulationFlags_) dprintf(" \t\t\t%-#x BAD FLAGS\n", flSimulationFlags_);
    
    GetDCFieldAndOffset(lEscapement_);
    DPRINTDCPS("lEscapement_        " );
    dprintf( "%d\n", lEscapement_ );

    GetDCFieldAndOffset(prfnt_);
    DPRINTDCPP( prfnt_,          "prfnt_             " );

    GetDCFieldAndOffset(pPFFList);
    DPRINTDCPP( pPFFList,        "pPFFList           " );

    GetDCOffset(co_);
    DPRINTDCPS("co_                 " );
    dprintf("!gdikdx.dco %p\n", offDC + offset);

    GetDCFieldAndOffset(pDCAttr);
    DPRINTDCPP( pDCAttr,         "pDCAttr            " );

    GetDCOffset(dcattr);
    DPRINTDCPS( "dcattr              " );
    dprintf("!gdikdx.dca %p\n", offDC + offset);

    GetDCOffset(dclevel);
    DPRINTDCPS( "dclevel             " );
    dprintf("!gdikdx.dcl %p\n", offDC + offset);

    GetDCFieldAndOffset(ulCopyCount_);
    DPRINTDCPS( "ulCopyCount_        " );
    dprintf("%u\n" , ulCopyCount_);

    GetDCFieldAndOffset(psurfInfo_);
    DPRINTDCPP( psurfInfo_,      "pSurfInfo          " );

    GetDCFieldAndOffset(dctp_);                
    DPRINTDCPS( "dctp_               " );
    dprintf("%d %s\n", dctp_, pszDCTYPE(dctp_));

    GetDCFieldAndOffset(fs_);
    DPRINTDCPX( fs_,            "fs_                " );
    for (pfd = afdDCfs; pfd->psz; pfd++)
        if (pfd->fl & fs_) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            fs_ &= ~pfd->fl;
        }
    if (fs_)
        dprintf(" \t\t\t%-#x BAD FLAGS\n", fs_);
    
    dprintf("\n");

#undef GetERECTLvalues
    
    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDC_ATTR
*
\**************************************************************************/
void vDumpDC_ATTR(ULONG64 offDCATTR)
{
#define     DPRINTDCATTRPP(aa,bb)  \
            DPRINTPP(aa,bb,offDCATTR)
#define     DPRINTDCATTRPX(aa,bb)  \
            DPRINTPX(aa,bb,offDCATTR)
#define     DPRINTDCATTRPS(bb)  \
            DPRINTPS(bb,offDCATTR)
#define     DPRINTDCATTRPD(aa,bb)  \
            DPRINTPD(aa,bb,offDCATTR)

    ULONG64     pvLDC, hbrush, hcmXform, hColorSpace, hlfntNew, pvisrectrgn;
    ULONG       ulDirty_, offset, Flags;
    DWORD       crBackgroundClr, crForegroundClr, iCS_CP, IcmBrushColor, IcmPenColor, dwLayout;
    ULONG       ulBackgroundClr, ulForegroundClr;
    LONG        lIcmMode,lBkMode, lFillMode, lStretchBltMode, lTextAlign, lTextExtra, lRelAbs, lBreakExtra, cBreak, lWindowOrgx;
    FLONG       flTextAlign, flFontMapper, flXform;
    BYTE        jROP2, jBkMode, jFillMode, jStretchBltMode;
    POINTL      ptlCurrent, ptfxCurrent, ptlWindowOrg, ptlViewportOrg, ptlBrushOrigin;
    SIZEL       szlWindowExt, szlViewportExt, szlVirtualDevicePixel,szlVirtualDeviceMm;
    int         iGraphicsMode;
    INT         iMapMode;
    LONG        left, top, right, bottom;
    FLAGDEF     *pfd;
    char        ach[128], *psz = ach;
    
    if (offDCATTR)
    {
        dprintf("\nDC_ATTR\n address\n -------\n");
        
        GetDCATTRFieldAndOffset(pvLDC);
        DPRINTDCATTRPP(pvLDC, " pvLDC               ");

        GetDCATTRFieldAndOffset(ulDirty_);
        dprintf("[%x]", offDCATTR + offset);
        dprintf(" ulDirty_              %-#x\n",ulDirty_);
        for (pfd=afdDirty; pfd->psz; pfd++)
            if (ulDirty_ & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                ulDirty_ &= ~pfd->fl;
            }
        if (ulDirty_)
            dprintf("\t\t\t\t? %-#x\tBAD FLAGS\n", ulDirty_);
        
        //
        // hbrush
        //
        GetDCATTRFieldAndOffset(hbrush);
        DPRINTDCATTRPP(hbrush, "hbrush                 ");
    
        GetDCATTRFieldAndOffset(crBackgroundClr);
        DPRINTDCATTRPX(crBackgroundClr, "crBackgroundClr        ");
    
        GetDCATTRFieldAndOffset(ulBackgroundClr);
        DPRINTDCATTRPX(ulBackgroundClr, "ulBackgroundClr        ");
    
        GetDCATTRFieldAndOffset(crForegroundClr);
        DPRINTDCATTRPX(crForegroundClr, "crForegroundClr        ");
    
        GetDCATTRFieldAndOffset(ulForegroundClr);
        DPRINTDCATTRPX(ulForegroundClr, "ulForegroundClr        ");
    
        GetDCATTRFieldAndOffset(iCS_CP);
        DPRINTDCATTRPX(iCS_CP, "iCS_CP                 ");
    
        GetDCATTRFieldAndOffset(iGraphicsMode);
        dprintf("[%p] iGraphicsMode           %d= %s\n",
                offDCATTR + offset, iGraphicsMode, pszGraphicsMode(iGraphicsMode));
    
        GetDCATTRFieldAndOffset(jROP2);
        dprintf("[%p] jROP2                   %d= %s\n",
                offDCATTR + offset, jROP2, pszROP2(jROP2));
    
        GetDCATTRFieldAndOffset(jBkMode);
        dprintf("[%p] jBkMode                 %d= %s\n",
                offDCATTR + offset, jBkMode, pszBkMode(jBkMode));
    
        // jFillMode
        GetDCATTRFieldAndOffset(jFillMode);
        switch (jFillMode) {
            case ALTERNATE: psz = "ALTERNATE"; break;
            case WINDING  : psz = "WINDING"  ; break;
            default       : psz = "?FILLMODE"; break;
        }
        dprintf("[%p] jFillMode               %d = %s\n", offDCATTR + offset, jFillMode, psz);
        
        // jStretchBltMode
        GetDCATTRFieldAndOffset(jStretchBltMode);
        switch (jStretchBltMode) {
            case BLACKONWHITE: psz = "BLACKONWHITE"; break;
            case WHITEONBLACK: psz = "WHITEONBLACK"; break;
            case COLORONCOLOR: psz = "COLORONCOLOR"; break;
            case HALFTONE    : psz = "HALFTONE"    ; break;
            default          : psz = "?STRETCHMODE"; break;
        }
        dprintf("[%p] jStretchBltMode         %d = %s\n", offDCATTR + offset, jStretchBltMode, psz);
        
        //
        // ICM
        //
    
        GetDCATTRFieldAndOffset(lIcmMode);
        DPRINTDCATTRPX(lIcmMode, "lIcmMode               ");
    
        GetDCATTRFieldAndOffset(hcmXform);
        DPRINTDCATTRPP(hcmXform, "hcmXform               ");
    
        GetDCATTRFieldAndOffset(hColorSpace);
        DPRINTDCATTRPP(hColorSpace, "hColorSpace            ");
    
        GetDCATTRFieldAndOffset(IcmBrushColor);
        DPRINTDCATTRPX(IcmBrushColor, "IcmBrushColor          ");
    
        GetDCATTRFieldAndOffset(IcmPenColor);
        DPRINTDCATTRPX(IcmPenColor, "IcmPenColor            ");
        
        GetDCATTRFieldAndOffset(ptlCurrent);
        dprintf("[%p] ptlCurrent              %d %d\n", offDCATTR + offset, ptlCurrent.x, ptlCurrent.y);
    
        GetDCATTRFieldAndOffset(ptfxCurrent);
        dprintf("[%p] ptfxCurrent             %-#x %-#x\n", offDCATTR + offset, ptfxCurrent.x, ptfxCurrent.y);
        
        GetDCATTRFieldAndOffset(lBkMode);
        dprintf("[%p] lBkMode                 %d = %s\n",
                offDCATTR + offset, lBkMode, pszBkMode(lBkMode));
        
        GetDCATTRFieldAndOffset(lFillMode);
        switch (lFillMode) {
            case ALTERNATE: psz = "ALTERNATE"; break;
            case WINDING  : psz = "WINDING"  ; break;
            default       : psz = "?"        ; break;
        }
        dprintf("[%p] lFillMode               %d = %s\n", offDCATTR + offset, lFillMode, psz);
    
        GetDCATTRFieldAndOffset(lStretchBltMode);
        switch (lStretchBltMode) {
            case BLACKONWHITE: psz = "BLACKONWHITE"; break;
            case WHITEONBLACK: psz = "WHITEONBLACK"; break;
            case COLORONCOLOR: psz = "COLORONCOLOR"; break;
            case HALFTONE    : psz = "HALFTONE"    ; break;
            default          : psz = "?"           ; break;
        }
        dprintf("[%p] lStretchBltMode         %d = %s\n", offDCATTR + offset, lStretchBltMode, psz);
    
        GetDCATTRFieldAndOffset(flTextAlign);
        DPRINTDCATTRPS("flTextAlign             ");
        dprintf("%-#x = %s | %s | %s\n", flTextAlign, pszTA_U(flTextAlign), pszTA_H(flTextAlign), pszTA_V(flTextAlign));
    
        GetDCATTRFieldAndOffset(lTextAlign);
        DPRINTDCATTRPS("lTextAlign              ");
        dprintf("%-#x = %s | %s | %s\n", lTextAlign, pszTA_U(lTextAlign), pszTA_H(lTextAlign), pszTA_V(lTextAlign));
    
        GetDCATTRFieldAndOffset(lTextExtra);
        DPRINTDCATTRPD(lTextExtra, "lTextExtra             ");
        
        GetDCATTRFieldAndOffset(lRelAbs);
        DPRINTDCATTRPD(lRelAbs, "lRelAbs                ");

        GetDCATTRFieldAndOffset(lBreakExtra);
        DPRINTDCATTRPD(lBreakExtra, "lBreakExtra            ");

        GetDCATTRFieldAndOffset(cBreak);
        DPRINTDCATTRPD(cBreak, "cBreak                 ");

        GetDCATTRFieldAndOffset(hlfntNew);
        DPRINTDCATTRPP(hlfntNew, "hlfntNew               ");
        
        GetDCATTRFieldAndOffset(iMapMode);
        DPRINTDCATTRPX(iMapMode,"iMapMode               ");
        dprintf("\t\t\t\t%s\n",pszMapMode(iMapMode));
    
        GetDCATTRFieldAndOffset(flFontMapper);
        DPRINTDCATTRPX(flFontMapper, "flFontMapper           ");    

        GetDCATTRFieldAndOffset(dwLayout);
        DPRINTDCATTRPD(dwLayout, "dwLayout               ");

        GetDCATTRFieldAndOffset(lWindowOrgx);
        DPRINTDCATTRPD(lWindowOrgx, "lWindowOrgx            ");

        GetDCATTRFieldAndOffset(ptlWindowOrg);
        dprintf("[%p] ptlWindowOrg            %d %d\n",
                offDCATTR + offset, ptlWindowOrg.x, ptlWindowOrg.y);
    
        GetDCATTRFieldAndOffset(szlWindowExt);
        dprintf("[%p] szlWindowExt            %d %d\n",
                offDCATTR + offset, szlWindowExt.cx, szlWindowExt.cy);
    
        GetDCATTRFieldAndOffset(ptlViewportOrg);
        dprintf("[%p] ptlViewportOrg          %d %d\n",
                offDCATTR + offset, ptlViewportOrg.x, ptlViewportOrg.y);
    
        GetDCATTRFieldAndOffset(szlViewportExt);
        dprintf("[%p] szlViewportExt          %d %d\n",
                offDCATTR + offset, szlViewportExt.cx, szlViewportExt.cy);
    
        GetDCATTRFieldAndOffset(flXform);
        DPRINTDCATTRPX(flXform, "flXform                ");
        for (pfd = afdflx; pfd->psz; pfd++) {
            if (flXform & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                flXform &= ~pfd->fl;
            }
        }
        if (flXform)
            dprintf("\t\t\t\t%-#x bad flags\n", flXform);
    
        GetDCATTROffset(mxWtoD);
        dprintf("[%p] mxWorldToDevice         !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        GetDCATTROffset(mxDtoW);
        dprintf("[%p] mxDeviceToWorld         !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        GetDCATTROffset(mxWtoP);
        dprintf("[%p] mxWorldToPage           !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        
        GetDCATTRFieldAndOffset(szlVirtualDevicePixel);
        dprintf("[%p] szlVirtualDevicePixel   %d %d\n",
            offDCATTR + offset, szlVirtualDevicePixel.cx, szlVirtualDevicePixel.cy);
     
        GetDCATTRFieldAndOffset(szlVirtualDeviceMm);
        dprintf("[%p] szlVirtualDeviceMm      %d %d\n",
            offDCATTR + offset, szlVirtualDeviceMm.cx, szlVirtualDeviceMm.cy);     
     
        GetDCATTRFieldAndOffset(ptlBrushOrigin);
        dprintf("[%p] ptlBrushOrigin\t     %d %d\n",
            offDCATTR + offset, ptlBrushOrigin.x, ptlBrushOrigin.y);   
   
        GetDCATTROffset(VisRectRegion);
        pvisrectrgn = offDCATTR + offset;
        dprintf("[%p] VisRectRegion", pvisrectrgn);
        
        GetFieldData(pvisrectrgn, "_RGNATTR", "Flags", sizeof(Flags), &Flags);
        if (Flags & ATTR_RGN_VALID)
        {
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.left", sizeof(left), &left);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.top", sizeof(top), &top);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.right", sizeof(right), &right);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.bottom", sizeof(bottom), &bottom);
            dprintf("                        %d %d %d %d", left, top, right, bottom);
        }
        else
           dprintf("           INVALID");
        dprintf("\n");
    }
    else
        dprintf("Address of _DC_ATTR is NULL.\n");

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCLEVEL
*
* Routine Description:
*
* Arguments:
*
* Return Value:
*
\**************************************************************************/
void vDumpDCLEVEL(ULONG64 offDCLEVEL)
{
#define     DPRINTDCLEVELPP(aa,bb)  \
            DPRINTPP(aa,bb,offDCLEVEL)
#define     DPRINTDCLEVELPX(aa,bb)  \
            DPRINTPX(aa,bb,offDCLEVEL)
#define     DPRINTDCLEVELPS(bb)  \
            DPRINTPS(bb,offDCLEVEL)
#define     DPRINTDCLEVELPD(aa,bb)  \
            DPRINTPD(aa,bb,offDCLEVEL)
    
    ULONG64     pSurface, hpal, ppal, hdcSave, pbrFill, pbrLine, hpath, pColorSpace;
    ULONG64     prgnClip, prgnMeta;
    ULONG64     pfield;
    FLONG       flPath, flFontState, fl, flbrush;
    LONG        lSaveDepth, lIcmMode;
    SIZEL       sizl;
    ULONG       offset;
    FLAGDEF     *pfd;


    dprintf("\nDCLEVEL @ %p\n address\n -------\n", offDCLEVEL);

    GetDCLEVELFieldAndOffset(pSurface);
    DPRINTDCLEVELPP( pSurface,           "pSurface        " );

    GetDCLEVELFieldAndOffset(hpal);
    DPRINTDCLEVELPP( hpal,               "hpal            " );

    GetDCLEVELFieldAndOffset(ppal);
    DPRINTDCLEVELPP( ppal,               "ppal            " );

    GetDCLEVELFieldAndOffset(sizl);
    DPRINTDCLEVELPS("sizl             " );
      dprintf("%d %d\n", sizl.cx, sizl.cy);

    GetDCLEVELFieldAndOffset(lSaveDepth);
    DPRINTDCLEVELPX(lSaveDepth,         "lSaveDepth      ");

    GetDCLEVELFieldAndOffset(hdcSave);
    DPRINTDCLEVELPP( hdcSave,            "hdcSave         " );

    GetDCLEVELFieldAndOffset(pbrFill);
    DPRINTDCLEVELPP( pbrFill,            "pbrFill         " );

    GetDCLEVELFieldAndOffset(pbrLine);
    DPRINTDCLEVELPP( pbrLine,            "pbrLine         " );

    GetDCLEVELFieldAndOffset(hpath);
    DPRINTDCLEVELPP( hpath,              "hpath           " );

    GetDCLEVELFieldAndOffset(pColorSpace);
    DPRINTDCLEVELPP( pColorSpace,        "pColorSpace     " );

    GetDCLEVELFieldAndOffset(lIcmMode);
    DPRINTDCLEVELPP( lIcmMode,           "lIcmMode        " );

// flPath
    GetDCLEVELFieldAndOffset(flPath);
    DPRINTDCLEVELPP( flPath,             "flPath          " );
    for (pfd = afdDCPATH; pfd->psz; pfd++)
        if (flPath & pfd->fl) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            flPath &= ~pfd->fl;
        }
    if (flPath)
        dprintf("\t\t\t\t%-#x bad flags\n", flPath);

// laPath

    GetDCLEVELOffset(laPath);
    pfield = offDCLEVEL + offset;
    DPRINTDCLEVELPS("laPath           ");
    dprintf("!gdikdx.la %p\n", pfield);

    GetDCLEVELFieldAndOffset(prgnClip);
    DPRINTDCLEVELPP( prgnClip,           "prgnClip        " );

    GetDCLEVELFieldAndOffset(prgnMeta);
    DPRINTDCLEVELPP( prgnMeta,           "prgnMeta        " );

// ca

    GetDCLEVELOffset(ca);
    pfield = offDCLEVEL + offset;
    dprintf("[%p] ca               !gdikdx.ca %p\n", pfield, pfield);

// flFontState

    GetDCLEVELFieldAndOffset(flFontState);
    DPRINTDCLEVELPS("flFontState      ");
    if (!flFontState)
        dprintf("0\n");
    else
    {
        for (pfd = afdFS2; pfd->psz; pfd++) {
            if (flFontState & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                flFontState &= ~pfd->fl;
            }
        }
        if (flFontState)
            dprintf("\t\t\t\t%-#x bad flags\n", flFontState);
    }

    GetDCLEVELOffset(ufi);
    pfield = offDCLEVEL + offset;
    DPRINTDCLEVELPS("ufi");
    dprintf("\n");

    GetDCLEVELFieldAndOffset(fl);
    DPRINTDCLEVELPX( fl,                 "fl              " );
    if (fl == DC_FL_PAL_BACK)
        dprintf("\t\t\t\t\tDC_FL_PAL_BACK\n");
    else if (fl != 0)
        dprintf("\t\t\t\tbad flags\n");

    GetDCLEVELFieldAndOffset(flbrush);
    DPRINTDCLEVELPX( flbrush,            "flbrush         " );

    GetDCLEVELOffset(mxWorldToDevice);
    DPRINTDCLEVELPS("mxWorldToDevice\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);

    
    GetDCLEVELOffset(mxDeviceToWorld);
    DPRINTDCLEVELPS("mxDeviceToWorld\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);

    GetDCLEVELOffset(mxWorldToPage);
    DPRINTDCLEVELPS("mxWorldToPage\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);
    
    dprintf("\n");
    return;

/*    #define M3(aa,bb) \
        dprintf("[%x] %s%-#x\n", &(pdclSrc->##aa), (bb), pdcl->##aa)
    #define M2(aa,bb) \
        dprintf("[%x] %s", &(pdclSrc->##aa), (bb))

    FLAGDEF *pfd;
    FLONG fl;
    LONG l;
    CHAR ach[128], *psz;


    GetDCLEVELFieldAndOffset(efM11PtoD);
    sprintEFLOAT( ach, pdcl->efM11PtoD );
    M2( efM11PtoD,  "efM11PtoD      ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM22PtoD );
    M2( efM22PtoD,  "efM22PtoD      ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efDxPtoD );
    M2( efDxPtoD,   "efDxPtoD       ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efDyPtoD );
    M2( efDyPtoD,   "efDyPtoD       ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM11_TWIPS );
    M2( efM11_TWIPS,"efM11_TWIPS    ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM22_TWIPS );
    M2( efM22_TWIPS,"efM22_TWIPS    ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efPr11 );
    M2( efPr11,     "efPr11         ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efPr22 );
    M2( efPr22,     "efPr22         ");
    dprintf("%s\n", ach);

    #undef M2
    #undef M3
*/
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCFontInfo
*
\**************************************************************************/
void vDumpDCFontInfo(ULONG64 offDC)
{
    ULONG64     prfnt_, hlfntCur_, pDCAttr, offDCLEVEL;
    FLONG       flFontState, fl, flFontMapper, flXform;
    INT         iMapMode;
    ULONG       offset;
    FLAGDEF     *pfd;

    dprintf("\n");

    GetDCFieldAndOffset(prfnt_);
    dprintf("[%p] prfnt_           %p\t(!gdikdx.fo -f %p)\n",
        offDC + offset, prfnt_, prfnt_);

    GetDCFieldAndOffset(hlfntCur_);
    dprintf("[%p] hlfntCur_        %p", offDC + offset, hlfntCur_);
    if (hlfntCur_)
        vDumpHFONT(hlfntCur_);
    else
        dprintf("\n");
    
    GetDCField(pDCAttr);
    if (pDCAttr)
    {
        ULONG64  offDCATTR, hlfntNew;
        int      iGraphicsMode;
        LONG     lBkMode, lTextAlign, lTextExtra, lBreakExtra, cBreak;

        offDCATTR = pDCAttr;
        GetDCATTRFieldAndOffset(hlfntNew);
        dprintf("[%p] hlfntNew         %p", offDCATTR + offset, hlfntNew);
    
        if (hlfntNew != hlfntCur_)
            vDumpHFONT(hlfntNew);
        else
            dprintf(" (same as hlfntCur_)\n");
        
        // iGraphicsMode

        GetDCATTRFieldAndOffset(iGraphicsMode);
        dprintf("[%p] iGraphicsMode    %d = %s\n",
            offDCATTR + offset,
            iGraphicsMode,
            pszGraphicsMode(iGraphicsMode)
            );

        // lBkMode

        GetDCATTRFieldAndOffset(lBkMode);
        dprintf("[%p] lBkMode          %d = %s\n",
            offDCATTR + offset, lBkMode, pszBkMode(lBkMode));
        
        // lTextAlign

        GetDCATTRFieldAndOffset(lTextAlign);
        dprintf("[%p] lTextAlign       %d =",
                offDCATTR + offset, lTextAlign);
        dprintf(" %s | %s | %s\n",
            pszTA_U(lTextAlign),
            pszTA_H(lTextAlign),pszTA_V(lTextAlign));

        GetDCATTRFieldAndOffset(lTextExtra);
        dprintf("[%p] lTextExtra       %d\n",
            offDCATTR + offset, lTextExtra);

        GetDCATTRFieldAndOffset(lBreakExtra);
        dprintf("[%p] lBreakExtra      %d\n",
            offDCATTR + offset, lBreakExtra);

        GetDCATTRFieldAndOffset(cBreak);
        dprintf("[%p] cBreak           %d\n",
            offDCATTR + offset, cBreak);

        GetDCATTRFieldAndOffset(flFontMapper);
        dprintf("[%p] flFontMapper     %-#x",
            offDCATTR + offset, flFontMapper);
        if (flFontMapper == ASPECT_FILTERING)
            dprintf(" = ASPECT_FILTERING");
        else if (flFontMapper != 0)
            dprintf(" = ?");
        dprintf("\n");
        
        GetDCATTRFieldAndOffset(iMapMode);
        dprintf("[%p] iMapMode         %d = %s\n",
            offDCATTR + offset,
            iMapMode,
            pszMapMode(iMapMode)
            );
    
        GetDCATTRFieldAndOffset(flXform);
        dprintf("[%p] flXform          %-#x\n", offDCATTR + offset, flXform);
        for (pfd = afdflx; pfd->psz; pfd++)
            if (flXform & pfd->fl) dprintf("\t\t\t\t%s\n", pfd->psz);
    }
    else
        dprintf("pdc->pDCAttr == 0\n");
        
    GetDCOffset(dclevel);
    offDCLEVEL= offDC + offset;
    GetDCLEVELField(flFontState);
    dprintf("[%p] flFontState      %-#x", offDCLEVEL, flFontState);
    for (pfd = afdDCFS; pfd->psz; pfd++) {
        if (pfd->fl & flFontState) {
            dprintf(" = %s", pfd->psz);
        }        
    }
    dprintf("\n");
    
    GetDCLEVELOffset(mxWorldToDevice);
    dprintf("[%p] mxWorldToDevice\n", offDCLEVEL + offset);
    
    dprintf("\n");
       
    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dca
*
\**************************************************************************/

DECLARE_API( dca )
{
    PARSE_POINTER(dca_help);  
    vDumpDC_ATTR(arg);
    
    EXIT_API(S_OK);

dca_help:
    dprintf("Usage: dca [-?] DC_ATTR pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dcl
*
\**************************************************************************/

DECLARE_API( dcl )
{
    PARSE_POINTER(dcl_help);
    vDumpDCLEVEL(arg);

    EXIT_API(S_OK);

dcl_help:
    dprintf("Usage: dcl [-?] DCLEVEL pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   hdc
*
\**************************************************************************/

DECLARE_API( hdc )
{
    HRESULT hr;
    ULONG64 addrDC;
    BOOL    General =FALSE;
    BOOL    DCLevel =FALSE;
    BOOL    DCAttr  =FALSE;
    BOOL    FontInfo=FALSE;
    
    PARSE_POINTER(hdc_help);
    hr = GetObjectAddress(Client,arg,&addrDC,DC_TYPE,TRUE,TRUE);

    if(ntok<2) {
      General=TRUE;
    } else {
      if(parse_iFindSwitch(tokens, ntok, 'g')!=-1) {General=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 'l')!=-1) {DCLevel=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 't')!=-1) {DCAttr=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {FontInfo=TRUE;}
    }
    if(!(General||DCLevel||DCAttr||FontInfo)) {General=TRUE;}

    if (hr == S_OK && addrDC)
    {
        dprintf("\nDC @ 0x%p\n address\n -------\n", addrDC);

    // general info
        if (General)
            vDumpDCgeneral(addrDC);

    // dcattr
        if (DCAttr)
        {
            ULONG64     addrDCAttr;
            ULONG       error;

            if (error = GetFieldData(addrDC, GDIType(DC), "pDCAttr", sizeof(addrDCAttr), &addrDCAttr))
            {
                dprintf("Unable to get pDCAttr\n");
                dprintf("  (GetFieldData returned %s)\n", pszWinDbgError(error));
            }
            else
            {
                vDumpDC_ATTR(addrDCAttr);
            }
        }

    // dclevel
        if (DCLevel)
        {
            ULONG   offDCLevel;
            GetFieldOffset(GDIType(DC), "dclevel", &offDCLevel);
            vDumpDCLEVEL(addrDC + offDCLevel);
        }

    // font information
        if (FontInfo)
            vDumpDCFontInfo(addrDC);
    }

    EXIT_API(S_OK);

hdc_help:
    dprintf("Usage: hdc [-?] [-g] [-l] [-t] [-f] handle\n"
            " -? help\n"
            " -g general\n"
            " -l dclevel\n"
            " -t dcattr\n"
            " -f font information\n");
    EXIT_API(S_OK);

}



/**************************************************************************\
* DC (ddc) Fields
\**************************************************************************/

PCSTR   DCAttribFields[] = {
    "dcattr.*",                 // "dcattr.ptlBrushOrigin",
    "pDCAttr",
    // Extended
    "ptlFillOrigin_",
    NULL
};

PCSTR   DCDrawFields[] = {
    "pDCAttr",
    "dclevel.hpath",
    "dclevel.flPath",
    // Extended
    "dclevel.laPath",
    NULL
};

PCSTR   DCFontFields[] = {
    "prfnt_",
    "pDCAttr",
    NULL
};

PCSTR   DCGeneralFields[] = {
    "hHmgr",
    "pDCAttr",
    "dclevel.",
    "dclevel.pSurface",
    "dctp_",
    "prgnVis_",
    "dclevel.prgnClip",
    "dclevel.prgnMeta",
    "prgnAPI_",
    "prgnRao_",
    "dclevel.sizl",
    "erclClip_",
    "eptlOrigin_",
    "erclWindow_",
    "erclBounds_",
    // Extended
    "fs_",
    "dhpdev_",
    "ppdev_",
    "hsemDcDevLock_",
    "flGraphicsCaps_",
    "flGraphicsCaps2_",
    "hdcPrev_",
    "hdcNext_",
    "hlfntCur_",
    "prfnt_",
    NULL
};

PCSTR   DCLevelFields[] = {
    "dclevel.*",
    NULL
};

PCSTR   DCSavedFields[] = {
    "dclevel.hdcSave",
    "dclevel.lSaveDepth",
    // Extended
    "dclevel.hpal",
    "dclevel.ppal",
    "pDCAttr",  //dprintf("\thlfntNew   =     0x%08lx\n", pdcattr->hlfntNew);
    "dclevel.flFontState", //afdDCFS
    "fs_",  // afdDCFS
    NULL
};

PCSTR   DCTextFields[] = {
    "pDCAttr",
    NULL
};

PCSTR   DCXformFields[] = {
    "dclevel.mxWorldToDevice.",
    "dclevel.mxDeviceToWorld.",
    "dclevel.mxWorldToPage.",
    // Extended
    "dclevel.mxWorldToDevice",
    NULL
};

/******************************Public*Routine******************************\
* DC (ddc)
*
* Debugger extension to dump a DC.
*
* History:
*  10-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Made it to work in the kernel.
*
*  22-Dec-2000 -by- Jason Hartman [jasonha]
* Rewrote for type knowledgable debugger.
*
\**************************************************************************/
DECLARE_API( ddc  )
{
    BEGIN_API( ddc );

    HRESULT         hr = S_OK;
    ULONG64         DCAddr;
    DEBUG_VALUE     Arg;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    BOOL    BadSwitch = FALSE;
    BOOL    DumpAll = FALSE;
    BOOL    bAttrib = FALSE;
    BOOL    bDraw   = FALSE;
    BOOL    bExtend = FALSE;
    BOOL    bFont   = FALSE;
    BOOL    bGeneral= FALSE;
    BOOL    bLevel  = FALSE;
    BOOL    bSaved  = FALSE;
    BOOL    bText   = FALSE;
    BOOL    bXform  = FALSE;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (tolower(*args))
            {
                case 'a': bAttrib = TRUE; break;
                case 'd': bDraw = TRUE; break;
                case 'e': bExtend = TRUE; break;
                case 'f': bFont = TRUE; break;
                case 'g': bGeneral = TRUE; break;
                case 'l': bLevel = TRUE; break;
                case 's': bSaved = TRUE; break;
                case 't': bText = TRUE; break;
                case 'v': DumpAll = TRUE; break;
                case 'x': bXform = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: hdc [-?adefgstvx] <HDC | DC Addr>\n"
                      "\n"
                      "a - DC_ATTR\n"
                      "d - Drawing attributes\n"
                      "e - Extended info\n"
                      "f - Font data\n\n"
                      "g - General data (default)\n"
                      "l - DCLEVEL\n"
                      "s - Saved data\n"
                      "t - Text attributes\n"
                      "v - Verbose mode (print everything)\n"
                      "x - Transform data\n");

        return S_OK;
    }


    hr = GetTypeId(Client, "DC", &TypeId, &Module);

    if (hr != S_OK)
    {
        OutCtl.OutErr("Error getting type info for %s (%s).\n",
                      GDIType(DC), pszHRESULT(hr));
    }
    else if ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
             Arg.I64 == 0)
    {
        if (hr == S_OK)
        {
            OutCtl.Output("Expression %s evalated to zero.\n", args);
        }
        else
        {
            OutCtl.OutErr("Evaluate(%s) returned %s.\n", args, pszHRESULT(hr));
        }
    }
    else
    {
        hr = GetObjectAddress(Client, Arg.I64, &DCAddr, DC_TYPE, TRUE, TRUE);

        if (hr != S_OK || DCAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             DCAddrFromHmgr;

            DCAddr = Arg.I64;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(DCAddr, Module, TypeId, 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of DC::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HDC nor valid DC address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &DCAddrFromHmgr,
                                     DC_TYPE, TRUE, FALSE) == S_OK &&
                    DCAddrFromHmgr != DCAddr)
                {
                    OutCtl.OutWarn("\tNote: DC may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        //
        // If nothing was specified, dump main section
        //

        if (!(bAttrib || bDraw || bFont || bSaved || bText || bXform))
        {
            bGeneral = TRUE;
        }

        if (hr == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (DumpAll)
            {
                TypeReader.ExcludeMarked();

                // Don't recurse for big sub structures
                TypeReader.MarkField("dclevel.*");
                TypeReader.MarkField("dcattr.*");
                TypeReader.MarkField("co_.*");
                TypeReader.MarkField("eboFill_.*");
                TypeReader.MarkField("eboLine_.*");
                TypeReader.MarkField("eboText_.*");
                TypeReader.MarkField("eboBackground_.*");
            }
            else
            {
                TypeReader.IncludeMarked();

                if (bAttrib)
                {
                    TypeReader.MarkFields(DCAttribFields, bExtend ? -1 : 2);
                }

                if (bDraw)
                {
                    TypeReader.MarkFields(DCDrawFields, bExtend ? -1 : 3);
                }

                if (bFont)
                {
                    TypeReader.MarkFields(DCFontFields);
                }

                if (bGeneral)
                {
                    TypeReader.MarkFields(DCGeneralFields, bExtend ? -1 : 14);
                }

                if (bLevel)
                {
                    TypeReader.MarkFields(DCLevelFields);
                }

                if (bSaved)
                {
                    TypeReader.MarkFields(DCSavedFields, bExtend ? -1 : 2);
                }

                if (bText)
                {
                    TypeReader.MarkFields(DCTextFields);
                }

                if (bXform)
                {
                    TypeReader.MarkFields(DCXformFields, bExtend ? -1 : 3);
                }
            }

            OutCtl.Output(" DC @ 0x%p:\n", DCAddr);

            hr = TypeReader.OutputVirtual(Module, TypeId, DCAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for DC returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}



/******************************Public*Routine******************************\
* DCLIST
*
*   List DC and brief info
*
\**************************************************************************/

PCSTR   DCListFields[] = {
    "hHmgr",
    "dhpdev_",
    "ppdev_",
    "dclevel.pSurface",
    NULL
};

DECLARE_API( dclist )
{
    BEGIN_API( dclist );

    HRESULT hr;
    HRESULT hrMask;
    ULONG64 index;
    ULONG64 gcMaxHmgr;
    ULONG64 DCAddr;
    BOOL    BadSwitch = FALSE;
    BOOL    DumpBaseObject = FALSE;
    BOOL    DumpUserFields = FALSE;

    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'b': DumpBaseObject = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        if (*args == '?')
        {
            OutCtl.Output("Lists all DCs and a few basic members.\n"
                          "\n");
        }

        OutCtl.Output("Usage: dclist [-?b] [<Member List>]\n"
                      "\n"
                      "   b - Dump BASEOBJECT information\n"
                      "\n"
                      "   Member List - Space seperated list of other SURFACE members\n"
                      "                 to be included in the dump\n");

        return S_OK;
    }

    if ((hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        OutCtl.OutErr("Unable to get sizeof GDI handle table. HRESULT %s\n", pszHRESULT(hr));
        return hr;
    }

    gcMaxHmgr = (ULONG64)(ULONG)gcMaxHmgr;

    OutCtl.Output("Searching 0x%I64x handle entries for DCs.\n", gcMaxHmgr);

    OutputFilter    OutFilter(Client);
    OutputState     OutState(Client, FALSE);
    OutputControl   OutCtlToFilter;
    ULONG64         Module;
    ULONG           TypeId;
    ULONG           OutputMask;

    if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL, &OutFilter)) == S_OK &&
        (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                DEBUG_OUTCTL_NOT_LOGGED,
                                OutState.Client)) == S_OK &&
        (hr = GetTypeId(Client, "DC", &TypeId, &Module)) == S_OK)
    {
        TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToFilter);

        TypeReader.SelectMarks(1);
        TypeReader.IncludeMarked();
        if (DumpBaseObject) TypeReader.MarkFields(BaseObjectFields);

        // Add user specified fields to dump list
        PSTR    MemberList = NULL;
        CHAR   *pBOF = (CHAR *)args;

        if (iscsymf(*pBOF))
        {
            MemberList = (PSTR) HeapAlloc(GetProcessHeap(), 0, strlen(pBOF)+1);

            if (MemberList != NULL)
            {
                strcpy(MemberList, pBOF);
                pBOF = MemberList;

                DumpUserFields = TRUE;

                while (iscsymf(*pBOF))
                {
                    CHAR   *pEOF = pBOF;
                    CHAR    EOFChar;

                    // Get member
                    do {
                         pEOF++;
                    } while (iscsym(*pEOF) || *pEOF == '.' || *pEOF == '*');
                    EOFChar = *pEOF;
                    *pEOF = '\0';
                    TypeReader.MarkField(pBOF);

                    // Advance to next
                    if (EOFChar != '\0')
                    {
                        do
                        {
                            pEOF++;
                        } while (isspace(*pEOF));
                    }

                    pBOF = pEOF;
                }
            }
            else
            {
                OutCtl.OutErr("Error: Couldn't allocate memory for Member List.\n");
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK && *pBOF != '\0')
        {
            OutCtl.OutErr("Error: \"%s\" is not a valid member list.\n", pBOF);
            hr = E_INVALIDARG;
        }

        if (hr == S_OK)
        {
            // Setup default dump specifications
            TypeReader.SelectMarks(0);
            TypeReader.IncludeMarked();
            TypeReader.MarkFields(DCListFields);

            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "hHmgr ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "DC_TYPE : ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " dhpdev_ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " ppdev_ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " dclevel DCLEVEL ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " pSurface ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "(null)", "(null)    ");

            OutCtl.Output(" &DC        HDC        dhpdev_    ppdev_     pSurface");
            if (DumpBaseObject) OutCtl.Output(" \tBASEOBJECT");
            if (DumpUserFields) OutCtl.Output(" %s", args);
            OutCtl.Output("\n");

            for (index = 0;
                 index < gcMaxHmgr;
                 index++)
            {
                if (OutCtl.GetInterrupt() == S_OK)
                {
                    OutCtl.OutWarn("User aborted search:\n"
                                   "  0x%I64x entries were checked.\n"
                                   "  0x%I64x entries remain.\n",
                                   index, gcMaxHmgr - index);
                    break;
                }

                // Turn off error and verbose messages for this call to
                // GetObjectAddress since it will spew for non-DCs.
                if ((hrMask = Client->GetOutputMask(&OutputMask)) == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    hrMask = Client->SetOutputMask(OutputMask & ~(DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE));
                }

                hr = GetObjectAddress(Client, index, &DCAddr, DC_TYPE, FALSE, FALSE);

                // Restore mask
                if (hrMask == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    Client->SetOutputMask(OutputMask);
                }

                if (hr != S_OK || DCAddr == 0) continue;

                OutCtl.Output(" 0x%p ", DCAddr);

                OutFilter.DiscardOutput();


                hr = TypeReader.OutputVirtual(Module, TypeId, DCAddr,
                                              DEBUG_OUTTYPE_NO_OFFSET |
                                              DEBUG_OUTTYPE_COMPACT_OUTPUT);

                if (hr == S_OK)
                {
                    if (DumpBaseObject || DumpUserFields)
                    {
                        OutCtlToFilter.Output("  \t");
                        TypeReader.SelectMarks(1);
                        TypeReader.OutputVirtual(Module, TypeId, DCAddr,
                                                 DEBUG_OUTTYPE_NO_OFFSET |
                                                 DEBUG_OUTTYPE_COMPACT_OUTPUT);
                        TypeReader.SelectMarks(0);
                    }

                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    OutCtl.Output("\n");
                }
                else
                {
                    OutCtl.Output("0x????%4.4I64x  ** failed to read DC **\n", index);
                }
            }
        }

        if (MemberList != NULL)
        {
            HeapFree(GetProcessHeap(), 0, MemberList);
        }
    }
    else
    {
        OutCtl.OutErr(" Output state/control setup returned %s.\n",
                      pszHRESULT(hr));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\basictypes.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    basictypes.cxx

Abstract:

    This file contains output routines for primitive types.

Author:

    Jason Hartman (JasonHa) 2000-12-18

Environment:

    User Mode

--*/

#include "precomp.hxx"


typedef struct {
    PCSTR               Type;
    ULONG               TypeId;
    FN_OutputKnownType *OutFunc;
} KnownType;

typedef struct {
    ULONG64     Module;
    ULONG       NumTypes;
    ULONG       TypesReady;     // Types for which GetTypeId has succeeded
    ULONG       TypesNotReady;  // Types for which GetTypeId hasn't been tried
    KnownType  *Types;
} KnownModuleTypes;


ULONG               BTModules = 0;
KnownModuleTypes    BTModule[4];

HANDLE              BTHeap;


FN_OutputKnownType OutputPOINTFIX;
FN_OutputKnownType OutputPOINTL;
FN_OutputKnownType OutputRECTFX;
FN_OutputKnownType OutputRECTL;
FN_OutputKnownType OutputSIZE;

KnownType   BTTypes[] = {
    {"_EFLOAT",     0, OutputEFLOAT_S},
    {"EFLOAT",      0, OutputEFLOAT_S},
    {"_EFLOAT_S",   0, OutputEFLOAT_S},
    {"EFLOAT_S",    0, OutputEFLOAT_S},
    {"_POINTFIX",   0, OutputPOINTFIX},
    {"POINTFIX",    0, OutputPOINTFIX},
    {"_POINTL",     0, OutputPOINTL},
    {"POINTL",      0, OutputPOINTL},
    {"EPOINTL",     0, OutputPOINTL},
    {"tagPOINT",    0, OutputPOINTL},
    {"POINT",       0, OutputPOINTL},
    {"_RECTFX",     0, OutputRECTFX},
    {"RECTFX",      0, OutputRECTFX},
    {"_RECTL",      0, OutputRECTL},
    {"RECTL",       0, OutputRECTL},
    {"ERECTL",      0, OutputRECTL},
    {"tagRECT",     0, OutputRECTL},
    {"RECT",        0, OutputRECTL},
    {"tagSIZE",     0, OutputSIZE},
    {"SIZE",        0, OutputSIZE},
    {"SIZEL",       0, OutputSIZE},
};

KnownModuleTypes    BTTemplate = { 0, lengthof(BTTypes), 0, 0, BTTypes };


/**************************************************************************\
*
* Routine Name:
*
*   BasicTypesInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
BasicTypesInit(
    PDEBUG_CLIENT Client
    )
{
    BasicTypesExit();
    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   BasicTypesExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
BasicTypesExit(
    )
{
    while (BTModules > 0)
    {
        BTModules--;

        HeapFree(BTHeap, 0, BTModule[BTModules].Types);
        BTModule[BTModules].Types = NULL;
        BTModule[BTModules].Module = 0;
    }

}


/**************************************************************************\
*
* Routine Name:
*
*   FindKnownType
*
* Routine Description:
*
*   Finds known type entry is type is one of the GDI primitive types.
*
\**************************************************************************/

KnownType *
FindKnownType(
    PDEBUG_CLIENT Client,
    ULONG64 Module,
    ULONG TypeId)
{
    BOOL        FoundType = FALSE;
    ULONG       ModIndex;

    for (ModIndex = 0; ModIndex < BTModules; ModIndex++)
    {
        if (BTModule[ModIndex].Module == Module)
        {
            break;
        }
    }

    // Allocate a new module type list if current module isn't found.
    if (ModIndex == BTModules &&
        BTModules < lengthof(BTModule))
    {
        SIZE_T  TemplateSize;

        if (BTHeap == NULL)
        {
            BTHeap = GetProcessHeap();
            if (BTHeap == NULL) return NULL;
        }

        TemplateSize = BTTemplate.NumTypes * sizeof(KnownType);

        BTModule[BTModules].Types = (KnownType *)HeapAlloc(BTHeap, 0, TemplateSize);

        if (BTModule[BTModules].Types != NULL)
        {
            BTModule[BTModules].Module = Module;
            BTModule[BTModules].NumTypes = BTTemplate.NumTypes;
            BTModule[BTModules].TypesReady = 0;
            BTModule[BTModules].TypesNotReady = BTModule[BTModules].NumTypes;
            RtlCopyMemory(BTModule[BTModules].Types, BTTemplate.Types, TemplateSize);

            BTModules++;
        }
    }

    if (ModIndex < BTModules)
    {
        KnownType      *Type;
        KnownType      *TypeLast;
        PDEBUG_SYMBOLS  Symbols;

        Type = BTModule[ModIndex].Types;

        // Search ready list
        TypeLast = Type + BTModule[ModIndex].TypesReady;

        while (Type < TypeLast)
        {
            if (Type->TypeId == TypeId) return Type;
            Type++;
        }

        // Initialize and search not ready list
        if (Client != NULL &&
            Client->QueryInterface(__uuidof(IDebugSymbols),
                                   (void **)&Symbols) == S_OK)
        {
            // Type is at beginning of not ready list;
            TypeLast = Type + BTModule[ModIndex].TypesNotReady;

            while (Type < TypeLast)
            {
                BTModule[ModIndex].TypesNotReady--;

                if (Symbols->GetTypeId(Module, Type->Type, &Type->TypeId) == S_OK)
                {
                    BTModule[ModIndex].TypesReady++;
                    if (Type->TypeId == TypeId) return Type;

                    Type++;
                }
                else
                {
                    // TypeLast to last entry of not ready list
                    TypeLast--;

                    if (Type < TypeLast)
                    {
                        // Swap last not ready entry with this failed type
                        // This entry will then be in failed list
                        KnownType TempKT = *Type;

                        *Type = *TypeLast;
                        *TypeLast = TempKT;
                    }
                }
            }

            Symbols->Release();
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Routine Name:
*
*   IsKnownType
*
* Routine Description:
*
*   Checks if specified type one of the GDI primitive types.
*
\**************************************************************************/

BOOL
IsKnownType(
    PDEBUG_CLIENT Client,
    ULONG64 Module,
    ULONG TypeId)
{
    return (FindKnownType(Client, Module, TypeId) != NULL);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputKnownType
*
* Routine Description:
*
*   Output GDI primitive type at specified offset.
*
* Arguments:
*
*   
*
* Return Value:
*
*   S_OK if everything succeeded.
*
\**************************************************************************/

HRESULT
OutputKnownType(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    ULONG64 Offset,
    ULONG Flags)
{
    HRESULT         hr = S_OK;
    OutputControl   NoOutput;
    KnownType      *Type;

    if (OutCtl == NULL) OutCtl = &NoOutput;

    Type = FindKnownType(Client, Module, TypeId);

    if (Type != NULL)
    {
        OutputReader    TypeReader;
        OutputState     OutState(Client, FALSE);
        PSTR            TypeDump;

        if (Offset == 0)
        {
            OutCtl->Output("%s", Type->Type);
        }
        else if ((hr = OutState.Setup(0, &TypeReader)) == S_OK &&
                 (hr = OutState.OutputTypeVirtual(Offset,
                                                  Module,
                                                  TypeId,
                                                  Flags)) == S_OK &&
                 (hr = TypeReader.GetOutputCopy(&TypeDump)) == S_OK)
        {
            if (TypeDump != NULL)
            {
                hr = Type->OutFunc(Client, OutCtl,
                                   Module, TypeId,
                                   TypeDump,
                                   Flags,
                                   NULL);

                TypeReader.FreeOutputCopy(TypeDump);
            }
        }
    }
    else
    {
        OutCtl->OutVerb("TypeId %lu in 0x%p is unknown GDI primitve.\n",
                        TypeId, Module);
        hr = S_FALSE;
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFIXDec
*
* Routine Description:
*
*   Outputs a FIX in dotted Decimal format (##+#/16)
*
\**************************************************************************/

HRESULT
OutputFIXDec(
    OutputControl *OutCtl,
    PDEBUG_VALUE Fix
    )
{
    return OutCtl->Output(((Fix->Type != DEBUG_VALUE_INT32) ? "?" :
                          "%ld+%ld/16"), ((LONG)Fix->I32) >> 4, Fix->I32 & 0x0000000F);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFIXHex
*
* Routine Description:
*
*   Outputs a FIX in dotted Hex format (0x#######.#)
*
\**************************************************************************/

HRESULT
OutputFIXHex(
    OutputControl *OutCtl,
    PDEBUG_VALUE Fix
    )
{
    return OutCtl->Output(((Fix->Type != DEBUG_VALUE_INT32) ? "?" :
                          "0x%lx.%lx"), Fix->I32 >> 4, Fix->I32 & 0x0000000F);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputPOINTFIX
*
* Routine Description:
*
*   Outputs a POINTFIX
*
\**************************************************************************/

HRESULT
OutputPOINTFIX(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         x, y;

    if (Parser.LookFor(&x, "x", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&y, "y", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }

    OutCtl->Output("(");
    OutputFIXHex(OutCtl, &x);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &y);
    OutCtl->Output(")   (");
    OutputFIXDec(OutCtl, &x);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &y);
    hr = OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputPOINTL
*
* Routine Description:
*
*   Outputs a POINTL
*
\**************************************************************************/

HRESULT
OutputPOINTL(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    OutCtl->Output("(");
    if (Parser.LookFor(NULL, "x") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "y") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputRECTFX
*
* Routine Description:
*
*   Outputs a RECTFX
*
\**************************************************************************/

HRESULT
OutputRECTFX(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         xLeft, xRight;
    DEBUG_VALUE         yTop, yBottom;
    PCSTR               pszValue;

    if (Parser.LookFor(&xLeft, "xLeft", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&yTop, "yTop", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&xRight, "xRight", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&yBottom, "yBottom", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }

    OutCtl->Output("(");
    OutputFIXHex(OutCtl, &xLeft);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &yTop);
    OutCtl->Output(")-(");
    OutputFIXHex(OutCtl, &xRight);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &yBottom);
    OutCtl->Output(")   (");
    OutputFIXDec(OutCtl, &xLeft);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &yTop);
    OutCtl->Output(")-(");
    OutputFIXDec(OutCtl, &xRight);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &yBottom);
    hr = OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputRECTL
*
* Routine Description:
*
*   Outputs a RECTL
*
\**************************************************************************/

HRESULT
OutputRECTL(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    OutCtl->Output("(");
    if (Parser.LookFor(NULL, "left") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "top") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(") - (");
    if (Parser.LookFor(NULL, "right") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "bottom") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputSIZE
*
* Routine Description:
*
*   Outputs a SIZE
*
\**************************************************************************/

HRESULT
OutputSIZE(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    if (Parser.LookFor(NULL, "cx") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(" x ");
    if (Parser.LookFor(NULL, "cy") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }

    return hr;
}


#if 0
// Template for known type output routines

/**************************************************************************\
*
* Routine Name:
*
*   _KnownType_
*
* Routine Description:
*
*   Output a _KnownType_
*
\**************************************************************************/

HRESULT
Output_KnownType_(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\callback.cxx ===
/******************************Module*Header*******************************\
* Module Name: callback.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"


BOOL        gbCallbacksPrintNewline = FALSE;
int         gCallbacksPrintNameWidth = -1;
NTSTATUS    gCallbackReturnValue = STATUS_SUCCESS;


ULONG FieldCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (gbCallbacksPrintNewline) dprintf("\n");
    dprintf(" ** FieldCallback(%lx, %lx) **\n", pField, UserContext);
    if (pField)
    {
        dprintf(" Field:\n");
        dprintf("  fName        : %s\n", pField->fName);
        dprintf("  printName    : %s\n", pField->printName);
        dprintf("  size         : %d\n", pField->size);
        dprintf("  fOptions     : %#x\n", pField->fOptions);
        dprintf("  address      : %#I64x\n", pField->address);
        dprintf("  fieldCallBack: %lx\n", pField->fieldCallBack);
    }
    if (UserContext)
    {
        dprintf(" UserContext:  ???\n");
    }

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* PrintName
*
*   Prints the field name or print name if callbacks are supposed to.
*
\**************************************************************************/

VOID PrintName(PFIELD_INFO pField)
{
    if (pField)
    {
        if (gCallbacksPrintNameWidth >= 0)
        {
            if (pField->printName)
            {
                dprintf("%*s", gCallbacksPrintNameWidth, pField->printName);
            }
            else if (pField->fName)
            {
                dprintf("%*s", gCallbacksPrintNameWidth, pField->fName);
            }
        }
        else
        {
            if (pField->fOptions & DBG_DUMP_FIELD_NO_PRINT)
            {
                if (pField->printName)
                {
                    dprintf("  +0x___ %s ", pField->printName);
                }
                else if (pField->fName)
                {
                    dprintf("  +0x___ %s ", pField->fName);
                }
            }
        }
    }
}


/**************************************************************************\
*
* NextItemCallbackInit
*
*   Specify printing and validation info to NextItemCallbacks.
*
\**************************************************************************/

BOOL    PrintItemHeader = FALSE;
char    szItemHeader[512] = "";
ULONG64 LastItemExpected = 0;
BOOL    FoundLastItemExpected = FALSE;

void NextItemCallbackInit(
    const char *pszPrintHeader,
    ULONG64 LastItemAddr
    )
{
    if (pszPrintHeader != NULL)
    {
        strncpy(szItemHeader, pszPrintHeader, sizeof(szItemHeader));
        szItemHeader[sizeof(szItemHeader)-1] = 0;
        PrintItemHeader = TRUE;
    }
    else
    {
        PrintItemHeader = FALSE;
    }

    LastItemExpected = LastItemAddr;
    FoundLastItemExpected = (LastItemExpected == 0);
}


/**************************************************************************\
*
* LastCallbackItemFound
*
*   Returns TRUE if address specified in NextItemCallbackInit was found.
*   Note: Always returns TRUE if 0 was specified for address.
*
\**************************************************************************/

BOOL LastCallbackItemFound()
{
    return FoundLastItemExpected;
}


/**************************************************************************\
*
* NextItemCallback
*
*   Use with linked list dumping when initial address is the first item's.
*
\**************************************************************************/

ULONG NextItemCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 NextAddr = 0;

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: NextItemCallback was given NULL pField.\n");
    }
    else
    {
        if (pField->address == 0)
            return STATUS_UNSUCCESSFUL;

        if (LastItemExpected != 0)
        {
            if (FoundLastItemExpected)
            {
                dprintf(" * Error: Next item is beyond last expected @ %#p\n", LastItemExpected);
            }
            else if (LastItemExpected == pField->address)
            {
                FoundLastItemExpected = TRUE;
            }
        }

        if (PrintItemHeader)
        {
            dprintf(szItemHeader);
            dprintf("%#p\n", pField->address);
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* PointerToNextItemCallback
*
*   Use with linked list dumping when initial address is a pointer to type.
*
\**************************************************************************/

ULONG PointerToNextItemCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 NextAddr = 0;

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: PointerToNextItemCallback was given NULL pField.\n");
    }
    else
    {
        if (pField->address == 0)
            return STATUS_UNSUCCESSFUL;

        if (!ReadPointer(pField->address, &NextAddr) || NextAddr == 0)
            return STATUS_UNSUCCESSFUL;

        if (LastItemExpected != 0)
        {
            if (FoundLastItemExpected)
            {
                dprintf(" * Error: Next item is beyond last expected @ %#p\n", LastItemExpected);
            }
            else if (LastItemExpected == NextAddr)
            {
                FoundLastItemExpected = TRUE;
            }
        }

        if (PrintItemHeader)
        {
            dprintf(szItemHeader);
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* ArrayCallback
*
*   Use with array dumping.
*
\**************************************************************************/

ULONG ArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    static PFIELD_INFO  ArrayField = NULL;
    static ULONG        ArrayIndex = 0;
    static ULONG        ArrayIndexWidth;

    if (pField != ArrayField || pField->size <= ArrayIndex)
    {
        ArrayField = pField;

        if (ArrayIndex != 0 && gbVerbose)
        {
            dprintf("Warning: Beginning new array w/o completing last.\n");
        }
        ArrayIndex = 0;
    }

    if (ArrayIndex == 0)
    {
        ULONG i = pField->size-1;
        ArrayIndexWidth = 1;
        dprintf("Idx");
        while (i /= 10)
        {
            dprintf(" ");
            ArrayIndexWidth++;
        }

        PrintName(pField);
    }

    dprintf("\n[%*u]", ArrayIndexWidth, ArrayIndex++);

    // If we hit the end of an array,
    // prepare for a new array.
    if (pField->size == ArrayIndex)
    {
        ArrayField = NULL;
        ArrayIndex = 0;
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* NewlineCallback
*
*   To be used with DBG_DUMP_COMPACT_OUT as default callback.
*
\**************************************************************************/

ULONG NewlineCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    dprintf("\n");

    if (!gbCallbacksPrintNewline && gbVerbose)
    {
        dprintf(" Note: NewlineCallback called, but gbCallbacksPrintNewline is FALSE.\n");
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* AddressPrintCallback
*
*   Useful with DBG_DUMP_FIELD_RETURN_ADDRESS when the field is 
*   a large embedded structure you don't want to print.
*
\**************************************************************************/

ULONG AddressPrintCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: AddressPrintCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose) dprintf(" (pField->size = %d) ", pField->size);
        dprintf("%#p", pField->address);
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* Basic Type Callbacks:
*   BOOL, BYTE, CHAR, DecimalCHAR, DecimalUCHAR,
*   DWORD, LONG, SHORT, WORD, ULONG, USHORT
*
\**************************************************************************/

ULONG BOOLCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%s", ((BOOL)pField->address) ? "TRUE" : "FALSE");
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG BYTECallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%2.2X", (BYTE)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG CHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("'%c'", (CHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DecimalCHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%d", (CHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DecimalUCHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%u", (UCHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DWORDCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%8.8lX", (DWORD)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG LONGCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%ld", (LONG)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG WORDCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%4.4X", (WORD)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG SHORTCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%d", (SHORT)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG ULONGCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%lu", (ULONG)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG USHORTCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%u", (USHORT)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}


/**************************************************************************\
*
* EnumCallback
*
*   Specify ENUMDEF * in SYM_DUMP_PARAM.Context field
*
*   Note: Only one Enum/FlagCallback can be specified per FIELD_INFO array.
*
\**************************************************************************/

ULONG EnumCallback(
    PFIELD_INFO pField,
    ENUMDEF *pEnumDef
    )
{
    if (pField == NULL || pEnumDef == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: EnumCallback had NULL parameter.\n");
        return STATUS_UNSUCCESSFUL;
    }

    PrintName(pField);

    if (!gbCallbacksPrintNewline &&
        !(pField->fOptions & DBG_DUMP_FIELD_NO_PRINT))
    {
        dprintf("     ");
    }

    dprintf(" ");
    if (! bPrintEnum(pEnumDef, (ULONG)pField->address))
    {
        dprintf("Unknown Value");
        if (pField->fOptions & DBG_DUMP_FIELD_NO_PRINT)
        {
            dprintf(": %lu", (ULONG)pField->address);
        }
    }
    dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* FlagCallback
*
*   Specify FLAGDEF * in SYM_DUMP_PARAM.Context field
*
*   Note: Only one Enum/FlagCallback can be specified per FIELD_INFO array.
*
\**************************************************************************/

ULONG FlagCallback(
    PFIELD_INFO pField,
    FLAGDEF *pFlagDef
    )
{
    ULONG64 UnknownFlags;

    PrintName(pField);

    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL || pFlagDef == NULL)
    {
        dprintf("Error: FlagCallback had NULL parameter.\n");
        return STATUS_UNSUCCESSFUL;
    }

    UnknownFlags = flPrintFlags(pFlagDef, pField->address);
    if (UnknownFlags)
    {
        if (UnknownFlags != pField->address) dprintf("\n");
        dprintf("      Uknown flags: 0x%lx", UnknownFlags);
    }
    dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* POINTLCallback
*
\**************************************************************************/

ULONG POINTLCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: POINTLCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: POINTLCallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!_POINTL))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("(%d,%d)",
                    (LONG)ReadField(x),
                    (LONG)ReadField(y));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* RECTLCallback
*
\**************************************************************************/

ULONG RECTLCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: RECTLCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: RECTLCallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!_RECTL))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("(%d,%d) - (%d,%d)",
                    (LONG)ReadField(left),
                    (LONG)ReadField(top),
                    (LONG)ReadField(right),
                    (LONG)ReadField(bottom));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* SIZECallback
*
\**************************************************************************/

ULONG SIZECallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: SIZECallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: SIZECallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!tagSIZE))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("%d x %d",
                    (LONG)ReadField(cx),
                    (LONG)ReadField(cy));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* SIZELCallback
*
\**************************************************************************/

ULONG SIZELCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    return SIZECallback(pField, UserContext);
}


/**************************************************************************\
*
* PrintDEVMODEList
*
\**************************************************************************/

ULONG PrintDEVMODEList(
    ULONG64 DevModeListAddr,
    ULONG   DevModeListSize
    )
{
    ULONG64 DevModeEnd;
    ULONG   error = 0;

    #define DEVMODE_DMDRIVEREXTRA       0
    #define DEVMODE_DMSIZE              1
    #define DEVMODE_DMPELSWIDTH         2
    #define DEVMODE_DMPELSHEIGHT        3
    #define DEVMODE_DMBITSPERPEL        4
    #define DEVMODE_DMDISPLAYFREQUENCY  5

    FIELD_INFO  DevModeFields[] = {
        { DbgStr("dmDriverExtra"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmSize"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmPelsWidth"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmPelsHeight"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmBitsPerPel"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmDisplayFrequency"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };
    SYM_DUMP_PARAM DevModeSym = {
        sizeof(SYM_DUMP_PARAM), DbgStr(GDIType(_devicemodeW)), DBG_DUMP_NO_PRINT, DevModeListAddr,
        NULL, NULL, NULL, sizeof(DevModeFields)/sizeof(DevModeFields[0]), DevModeFields
    };

    DevModeEnd = DevModeSym.addr + DevModeListSize;
    while ((DevModeSym.addr < DevModeEnd) && 
           !(error = Ioctl( IG_DUMP_SYMBOL_INFO, &DevModeSym, DevModeSym.size )))
    {
        dprintf("\t %4d x %4d %2d %3d\n",
                (DWORD)DevModeFields[DEVMODE_DMPELSWIDTH].address,
                (DWORD)DevModeFields[DEVMODE_DMPELSHEIGHT].address,
                (DWORD)DevModeFields[DEVMODE_DMBITSPERPEL].address,
                (DWORD)DevModeFields[DEVMODE_DMDISPLAYFREQUENCY].address);

        DevModeSym.addr += DevModeFields[DEVMODE_DMDRIVEREXTRA].address + DevModeFields[DEVMODE_DMSIZE].address;
    }

    return error;
}


/**************************************************************************\
*
* DEVMODECallback
*
\**************************************************************************/

ULONG DEVMODECallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    PrintName(pField);

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf(" Error: DEVMODEListCallback was given NULL pField.\n");
    }
    else if (pField->address)
    {
        ULONG error;

        if (error = PrintDEVMODEList(pField->address, 1))
        {
            dprintf("  PrintDEVMODEList returned %s in DEVMODECallback\n", pszWinDbgError(error));
        }
    }
    else
    {
        dprintf(" DEVMODE address is NULL\n");
    }

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* DEVMODEListCallback and SizeDEVMODEListCallback
*
*   Make sure these are always called in conjuction with
*   SizeDEVMODEListCallback before DEVMODEListCallback.
*
\**************************************************************************/

ULONG   cbDevModeList = -1;

ULONG SizeDEVMODEListCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL)
    {
        dprintf("Error: SizeDEVMODEListCallback was given NULL pField.\n");
    }
    else
    {
        if (cbDevModeList != -1)
        {
            dprintf(" Warning: cbDevModeList (%d) was not clear before call to SizeDEVMODEListCallback\n", cbDevModeList);
        }

        cbDevModeList = (ULONG)pField->address;
    }

    return STATUS_SUCCESS;
}

ULONG DEVMODEListCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    PrintName(pField);

    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL)
    {
        dprintf(" Error: DEVMODEListCallback was given NULL pField.\n");
    }
    else if (cbDevModeList == -1)
    {
        dprintf(" Error: cbDevModeList has not been set properly.\n");
    }
    else if (pField->address)
    {
        ULONG error;

        if (error = PrintDEVMODEList(pField->address, cbDevModeList))
        {
            dprintf("  PrintDEVMODEList returned %s in DEVMODEListCallback\n", pszWinDbgError(error));
        }
    }
    else if (cbDevModeList != 0)
    {
        dprintf(" DEVMODE list size (%d) is non-zero, but DEVMODE list address is NULL.\n", cbDevModeList);
    }

    cbDevModeList = -1;

    return gCallbackReturnValue;
}



/**************************************************************************\
*
* PrintAString
*
*   Reads and prints a char string at given target address.
*
*   Returns address just past end of string or address of read failure.
*
\**************************************************************************/

ULONG64 PrintAString(
    ULONG64 StringAddr
    )
{
    CHAR    Char;
    ULONG   cbRead;

    if (StringAddr != 0)
    {
        while (ReadMemory(StringAddr, &Char, sizeof(Char), &cbRead) &&
               cbRead == sizeof(Char) &&
               (StringAddr+=sizeof(Char)) &&
               Char != 0)
        {
            dprintf("%hc", Char);
        }
    }

    return StringAddr;
}


/**************************************************************************\
*
* PrintWString
*
*   Reads and prints a two-byte char string at given target address.
*
*   Returns address just past end of string or address of read failure.
*
\**************************************************************************/

ULONG64 PrintWString(
    ULONG64 StringAddr
    )
{
    WCHAR   Char;
    ULONG   cbRead;

    if (StringAddr != 0)
    {
        while (ReadMemory(StringAddr, &Char, sizeof(Char), &cbRead) &&
               cbRead == sizeof(Char) &&
               (StringAddr+=sizeof(Char)) &&
               Char != 0)
        {
            dprintf("%lc", Char);
        }
    }

    return StringAddr;
}



/**************************************************************************\
*
* String printing callbacks
*
*   To be used when DBG_DUMP_FIELD_xxx_STRING flags can't be used.
*
\**************************************************************************/

/**************************************************************************\
*
* ACharArrayCallback callback for an array of chars
*
*   Use DBG_DUMP_FIELD_RETURN_ADDRESS flag
*
\**************************************************************************/

ULONG ACharArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: ACharArrayCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose && pField->size == 0)
            dprintf("\n Note: ACharArrayCallback was given zero length array.\n");

        if (pField->address)
        {
            if (pField->size < sizeof(szBuffer))
            {
                if (!ReadMemory(pField->address, szBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    szBuffer[min(cbRead,sizeof(szBuffer)-sizeof(CHAR))/sizeof(CHAR)] = (CHAR) 0;
                    dprintf(" \"%hs\"", szBuffer);
                }
            }
            else
            {
                PCHAR  pszBuffer = (PCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pField->size+sizeof(CHAR));

                if (pszBuffer == NULL)
                {
                    dprintf(" Buffer allocation failed - single-byte string @ %#p", pField->address);
                }
                else if (!ReadMemory(pField->address, szBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    dprintf(" \"%hs\"", szBuffer);
                }
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WCharArrayCallback callback for an array of two-byte chars
*
*   Use DBG_DUMP_FIELD_RETURN_ADDRESS flag
*
\**************************************************************************/

ULONG WCharArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    WCHAR   wszBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: WStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose && pField->size == 0)
            dprintf("\n Note: WCharArrayCallback was given zero length array.\n");

        if (pField->address)
        {
            if (pField->size < sizeof(wszBuffer))
            {
                if (!ReadMemory(pField->address, wszBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    wszBuffer[min(cbRead,sizeof(wszBuffer)-sizeof(WCHAR))/sizeof(WCHAR)] = (WCHAR) 0;
                    dprintf(" \"%ls\"", wszBuffer);
                }
            }
            else
            {
                PWCHAR  pwszBuffer = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pField->size+sizeof(WCHAR));

                if (pwszBuffer == NULL)
                {
                    dprintf(" Buffer allocation failed - wide string @ %#p", pField->address);
                }
                else if (!ReadMemory(pField->address, wszBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    dprintf(" \"%ls\"", wszBuffer);
                }
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* AStringCallback callback for a pointer to char string
*
\**************************************************************************/

ULONG AStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: AStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: AStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: AStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using ACharArrayCallback?\n");
        }

        if (pField->address)
        {
            dprintf(" \"");
            PrintAString(pField->address);
            dprintf("\"");
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WStringCallback callback for a pointer to two-byte char string
*
\**************************************************************************/

ULONG WStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: WStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: WStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: WStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using WCharArrayCallback?\n");
        }

        if (pField->address)
        {
            dprintf(" \"");
            PrintWString(pField->address);
            dprintf("\"");
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* AMultiStringCallback callback for a pointer to several char
*   strings one after another.
*
\**************************************************************************/

ULONG AMultiStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: AMultiStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: AMultiStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: AMulitStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using ACharArrayCallback?\n");
        }

        if (pField->address)
        {
            ULONG64 PrevAddr = NULL;
            ULONG64 CurAddr = pField->address;
            CHAR    Char;
            ULONG   cbRead;

            while (CurAddr != PrevAddr &&
                   ReadMemory(CurAddr, &Char, sizeof(Char), &cbRead) &&
                   cbRead == sizeof(Char) &&
                   Char != 0)
            {
                PrevAddr = CurAddr;

                dprintf("\n\t\"");
                CurAddr = PrintAString(CurAddr);
                dprintf("\"");
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WMultiStringCallback callback for a pointer to several two-byte char
*   strings one after another.
*
\**************************************************************************/

ULONG WMultiStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: WMultiStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: WMultiStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: WMulitStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using WCharArrayCallback?\n");
        }

        if (pField->address)
        {
            ULONG64 PrevAddr = NULL;
            ULONG64 CurAddr = pField->address;
            WCHAR   Char;
            ULONG   cbRead;

            while (CurAddr != PrevAddr &&
                   ReadMemory(CurAddr, &Char, sizeof(Char), &cbRead) &&
                   cbRead == sizeof(Char) &&
                   Char != 0)
            {
                PrevAddr = CurAddr;

                dprintf("\n\t\"");
                CurAddr = PrintWString(CurAddr);
                dprintf("\"");
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\ddiexts.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ddiexts.cxx

Abstract:

    This file contains the DDI related extensions.

Author:

    Jason Hartman (JasonHa) 2000-11-01

Environment:

    User Mode

--*/

#include "precomp.hxx"


/******************************Public*Routine******************************\
* BLENDOBJ
*
\**************************************************************************/
DECLARE_API( blendobj )
{
    return ExtDumpType(Client, "blendobj", "BLENDOBJ", args);
}


/******************************Public*Routine******************************\
* BRUSHOBJ
*
\**************************************************************************/
DECLARE_API( brushobj )
{
    return ExtDumpType(Client, "brushobj", "BRUSHOBJ", args);
}


/******************************Public*Routine******************************\
* CLIPOBJ
*
\**************************************************************************/
DECLARE_API( clipobj )
{
    return ExtDumpType(Client, "clipobj", "CLIPOBJ", args);
}


/******************************Public*Routine******************************\
* LINEATTRS
*
\**************************************************************************/
DECLARE_API( lineattrs )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Offset;

    BEGIN_API( lineattrs );

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT64, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        if (hr != S_OK)
        {
            OutCtl.OutErr("Evaluate '%s' returned %s.\n",
                          args,
                          pszHRESULT(hr));
        }
        OutCtl.Output("Usage: lineattrs [-?] <LINEATTRS Addr>\n");
    }
    else
    {
        OutputFilter    OutFilter(Client);
        OutputState     OutState(Client, FALSE);

        if (hr == S_OK &&
            (hr = OutState.Setup(0, &OutFilter)) == S_OK &&
            (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                    DEBUG_OUTCTL_NOT_LOGGED |
                                    DEBUG_OUTCTL_OVERRIDE_MASK,
                                    OutState.Client)) == S_OK)

        {
            hr = DumpType(Client,
                          "_LINEATTRS",
                          Offset.I64,
                          DEBUG_OUTTYPE_DEFAULT,
                          &OutCtl);

            OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);

            if (hr == S_OK)
            {
                // Determine if FLOAT_LONG unions contain
                // FLOATL's or LONG's.
                if (OutFilter.Query("LA_GEOMETRIC") == S_OK)
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "l");
                }
                else
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "e");
                }

                OutFilter.OutputText();
            }
            else
            {
                OutCtl.OutErr("Type Dump for LINEATTRS returned %s.\n", pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.OutErr("Type Dump setup for LINEATTRS returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* PATHOBJ
*
\**************************************************************************/
DECLARE_API( pathobj )
{
    return ExtDumpType(Client, "pathobj", "PATHOBJ", args);
}


/******************************Public*Routine******************************\
* SURFOBJ
*
\**************************************************************************/
DECLARE_API( surfobj )
{
    BEGIN_API( surfobj );

    HRESULT             hr = S_OK;
    DEBUG_VALUE         Arg;
    DEBUG_VALUE         Offset;
    TypeOutputParser    TypeParser(Client);
    OutputState         OutState(Client);

    OutputControl       OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: surfobj [-?] <HSURF | SURFOBJ Addr>\n");
    }
    else if ((hr = OutState.Setup(0, &TypeParser)) == S_OK)
    {
        ULONG64             SurfAddr;
        ULONG64             SurfObjAddr = 0;
        DEBUG_VALUE         SurfObjHandle;
        BOOL                SurfObjHandleChecked = FALSE;

        hr = GetObjectAddress(Client, Arg.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

        if (hr != S_OK || SurfAddr == 0)
        {
            // Invalid handle try argument as a SURFOBJ address
            SurfObjAddr = Arg.I64;

            // Try to read hsurf from SURFOBJ
            if ((hr = OutState.OutputTypeVirtual(SurfObjAddr, GDIType(_SURFOBJ), 0)) != S_OK ||
                (hr = TypeParser.Get(&SurfObjHandle, "hsurf", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of SURFOBJ's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFOBJ address\n", Arg.I64);
            }
        }

        if (hr == S_OK)
        {
            PDEBUG_SYMBOLS  Symbols;

            ULONG64 SurfModule = 0;
            ULONG   SurfTypeId = 0;
            ULONG   BaseObjTypeId = 0;
            ULONG   SurfObjOffset = 0;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                // Try to read SURFOBJ offset from SURFACE type, but
                // if that fails assume it is directly after BASEOBJECT.
                if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                    (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                {
                    if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                    {
                        hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                    }
                }

                Symbols->Release();
            }

            if (SurfObjAddr != 0)
            {
                // If we were given a address, check hsurf validity.
                // hsurf value (SurfObjHandle) is retrieved above.

                hr = GetObjectAddress(Client, SurfObjHandle.I64, &SurfAddr,
                                      SURF_TYPE, TRUE, FALSE);

                if (hr != S_OK || SurfAddr == 0)
                {
                    OutCtl.OutWarn(" SURFOBJ's hsurf is not valid.\n");
                }
                else if (SurfObjOffset != 0 &&
                         SurfObjAddr != SurfAddr + SurfObjOffset)
                {
                    OutCtl.OutWarn(" SURFOBJ's hsurf may not be valid.\n");
                }
                else
                {
                    ULONG64 SurfaceHandle;
                    hr = GetObjectHandle(Client, SurfAddr, &SurfaceHandle, FALSE);

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("Unable to get contents of surface handle\n");
                        OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    }
                    else if (SurfaceHandle != SurfObjHandle.I64)
                    {
                        OutCtl.OutWarn(" Surface has an invalid handle.\n");
                    }
                }
            }
            else
            {
                // If we were given a handle,
                // compute SURFOBJ address.
                if (SurfObjOffset != 0)
                {
                    SurfObjAddr = SurfAddr + SurfObjOffset;

                    // Try to read hsurf from SURFOBJ
                    if ((hr = OutState.OutputTypeVirtual(SurfObjAddr, GDIType(_SURFOBJ), 0)) != S_OK ||
                        (hr = TypeParser.Get(&SurfObjHandle, "hsurf", DEBUG_VALUE_INT64)) != S_OK)
                    {
                        OutCtl.OutErr("Unable to get contents of SURFOBJ's handle\n");
                        OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    }
                    else if (SurfObjHandle.I64 != Arg.I64)
                    {
                        OutCtl.OutWarn(" SURFOBJ's hsurf is not valid.\n");
                    }
                }
            }

            if (SurfObjAddr != 0)
            {
                hr = DumpType(Client, "_SURFOBJ", SurfObjAddr);

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump for %s returned %s.\n", GDIType(_SURFOBJ), pszHRESULT(hr));
                }
            }
        }
    }
    else
    {
        OutCtl.OutErr("Couldn't setup type reader, %s.\n", pszHRESULT(hr));
    }

    return hr;
}


/******************************Public*Routine******************************\
* WNDOBJ
*
\**************************************************************************/
DECLARE_API( wndobj )
{
    return ExtDumpType(Client, "wndobj", "WNDOBJ", args);
}


/******************************Public*Routine******************************\
* XLATEOBJ
*
\**************************************************************************/
DECLARE_API( xlateobj )
{
    return ExtDumpType(Client, "xlateobj", "XLATEOBJ", args);
}


/******************************Public*Routine******************************\
* DEVMODEA
*
\**************************************************************************/
DECLARE_API( devmodea )
{
    return ExtDumpType(Client, "devmodea", "_devicemodeA", args);
}


/******************************Public*Routine******************************\
* DEVMODEW
*
\**************************************************************************/
DECLARE_API( devmodew )
{
    return ExtDumpType(Client, "devmodeW", "_devicemodeW", args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\dbgkdext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)						\
    *((ULONG_PTR *) &dst) = GetExpression(src);

#define GetValue(dst,src)						\
    GetAddress(dst,src) 						\
    move(dst,dst);

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)							\
    ReadMemory((ULONG_PTR) (src), &(dst), sizeof(dst), NULL)

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/
#define move2(dst, src, size)						\
    ReadMemory((ULONG_PTR) (src), (dst), (size), NULL)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\ddexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: ddexts.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"



/******************************Public*Routine******************************\
* vPrintDDSURFACE
*
* Print out DirectDraw surface contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#define DDSURFACE_LOCKS             0x00000001
#define DDSURFACE_PUBLIC            0x00000002
#define DDSURFACE_PRIVATE           0x00000004
#define DDSURFACE_DDNEXT            0x00000008

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDSURFACE(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char eSurface[sizeof(EDD_SURFACE)];
    char AttachList[sizeof(DD_ATTACHLIST)];
    EDD_SURFACE *peSurface;
    ULONG ul;
    FLAGDEF *pfd;
    PDD_ATTACHLIST pAttach;

Next_Surface:

    move2(eSurface, pvServer, sizeof(EDD_SURFACE));

    dprintf("EDD_SURFACE structure at 0x%p:\n", pvServer);

    peSurface =  (EDD_SURFACE *)eSurface;

    if (fl & DDSURFACE_PUBLIC)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("PDD_SURFACE_GLOBAL     lpGbl              0x%lx\n", peSurface->lpGbl);
        dprintf("PDD_SURFACE_MORE       lpMore             0x%lx\n", peSurface->lpSurfMore);

        ul = peSurface->dwFlags;
        dprintf("DWORD                  dwFlags            0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDRAWISURF; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        ul = peSurface->ddsCaps.dwCaps;
        dprintf("DWORD                  ddsCaps.dwCaps     0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSCAPS; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        ul = peSurface->ddsCapsEx.dwCaps2;
        dprintf("DWORD                  ddsCapsEx.dwCaps2  0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSCAPS2; pfd->psz; pfd++)
            if (ul & pfd->fl)
               dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("DWORD                  dwSurfaceHandle    0x%lx\n", peSurface->dwSurfaceHandle);

        dprintf("DDCOLORKEY ddckCKSrcBlt/Overlay           0x%lx:0x%lx\n", peSurface->ddckCKSrcOverlay.dwColorSpaceHighValue,
                                                                           peSurface->ddckCKSrcOverlay.dwColorSpaceLowValue);
        dprintf("DDCOLORKEY ddckCKDestBlt/Overlay          0x%lx:0x%lx\n", peSurface->ddckCKDestOverlay.dwColorSpaceHighValue,
                                                                           peSurface->ddckCKDestOverlay.dwColorSpaceLowValue);
        dprintf("PDD_ATTACHLIST         lpAttachList       0x%lx\n", peSurface->lpAttachList);

//CHECKLOOP
        for (pAttach = peSurface->lpAttachList;
             pAttach != NULL;
             pAttach = pAttach->lpLink)
        {
            move2(AttachList, pAttach, sizeof(DD_ATTACHLIST));
            pAttach = (PDD_ATTACHLIST) AttachList;

            dprintf("  EDD_SURFACE*\t\t\t0x%lx\n", pedFromLp(pAttach->lpAttached));

            if (pAttach->lpLink == pAttach)
            {
                dprintf("  !!! Endless lpAttachList loop\n");
                break;
            }

            if (CheckControlC())
                return;
        }
        dprintf("PDD_ATTACHLIST         lpAttachListFrom   0x%lx\n", peSurface->lpAttachListFrom);

//CHECKLOOP
        for (pAttach = peSurface->lpAttachListFrom;
             pAttach != NULL;
             pAttach = pAttach->lpLink)
        {
            move2(AttachList, pAttach, sizeof(DD_ATTACHLIST));
            pAttach = (PDD_ATTACHLIST) AttachList;

            dprintf("  EDD_SURFACE*\t\t\t0x%lx\n", pedFromLp(pAttach->lpAttached));

            if (pAttach->lpLink == pAttach)
            {
                dprintf("  !!! Endless lpAttachListFrom loop\n");
                break;
            }

            if (CheckControlC())
                return;
        }

        dprintf("DWORD                  dwMipMapCount      0x%lx\n", peSurface->dwMipMapCount);
        dprintf("EDD_VIDEOPORT*         peVideoPort        0x%lx\n",
            peSurface->lpVideoPort != NULL ? pedFromLp(peSurface->lpVideoPort) : 0);
        dprintf("HBITMAP                hbmGdi             0x%lx\n", peSurface->hbmGdi);
        dprintf("DWORD                  dwOverlayFlags     0x%lx\n", peSurface->dwOverlayFlags);
        dprintf("DWORD                  dwBlockSizeX       0x%lx\n", peSurface->dwBlockSizeX);
        dprintf("DWORD                  dwBlockSizeY       0x%lx\n", peSurface->dwBlockSizeY);
        dprintf("FLATPTR                fpVidMem           0x%lx\n", peSurface->fpVidMem);
        dprintf("LONG                   lPitch             0x%lx\n", peSurface->lPitch);
        dprintf("LONG                   xHint              0x%lx\n", peSurface->xHint);
        dprintf("LONG                   yHint              0x%lx\n", peSurface->yHint);
        dprintf("DWORD                  wWidth             0x%lx\n", peSurface->wWidth);
        dprintf("DWORD                  wHeight            0x%lx\n", peSurface->wHeight);
        dprintf("DWORD         (global) dwReserved1        0x%lx\n", peSurface->DD_SURFACE_GLOBAL::dwReserved1);
        dprintf("DWORD          (local) dwReserved1        0x%lx\n", peSurface->DD_SURFACE_LOCAL::dwReserved1);
        dprintf("DDPIXELFORMAT          ddpfSurface\n");
        dprintf("  DWORD dwSize (should be 0x20)           0x%lx\n", peSurface->ddpfSurface.dwSize);

        ul = peSurface->ddpfSurface.dwFlags;
        dprintf("  DWORD dwFlags                           0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDPIXELFORMAT; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("  DWORD dwFourCC                          0x%lx\n", peSurface->ddpfSurface.dwFourCC);
        dprintf("  DWORD dwRGB/YUV/ZBuffer/AlphaBitCount   0x%lx\n", peSurface->ddpfSurface.dwRGBBitCount);
        dprintf("  DWORD dwRBitMask/dwYBitMask             0x%lx\n", peSurface->ddpfSurface.dwRBitMask);
        dprintf("  DWORD dwGBitMask/dwUBitMask             0x%lx\n", peSurface->ddpfSurface.dwGBitMask);
        dprintf("  DWORD dwBBitMask/dwVBitMask             0x%lx\n", peSurface->ddpfSurface.dwBBitMask);
        dprintf("  DWORD dwRGB/YUVAlphaBitMask             0x%lx\n", peSurface->ddpfSurface.dwRGBAlphaBitMask);
    }
    if (fl & DDSURFACE_PRIVATE)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("EDD_SURFACE*           peSurface_DdNext   0x%lx\n", peSurface->peSurface_DdNext);
        dprintf("EDD_SURFACE*           peSurface_LockNext 0x%lx\n", peSurface->peSurface_PrimaryLockNext);
        dprintf("EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal 0x%lx\n", peSurface->peDirectDrawGlobal);
        dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal  0x%lx\n", peSurface->peDirectDrawLocal);


        ul = peSurface->fl;
        dprintf("FLONG                  fl                 0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSURFACEFL; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("ULONG                  iVisRgnUniqueness  0x%lx\n", peSurface->iVisRgnUniqueness);
        dprintf("BOOL                   bLost              %s\n",
            peSurface->bLost ? "TRUE" : "FALSE");
        dprintf("HANDLE                 hSecure            0x%lx\n", peSurface->hSecure);
        dprintf("ERECTL                 rclLock:           (%li, %li, %li, %li)\n",
            peSurface->rclLock.left,  peSurface->rclLock.top,
            peSurface->rclLock.right, peSurface->rclLock.bottom);
    }

    if (fl & DDSURFACE_LOCKS)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("ULONG                  cLocks             0x%lx\n", peSurface->cLocks);
        dprintf("HDC                    hdc                0x%lx\n", peSurface->hdc);
    }

    if (fl & DDSURFACE_DDNEXT)
    {
        if (CheckControlC())
            return;

        pvServer = peSurface->peSurface_DdNext;
        if (pvServer != NULL)
            goto Next_Surface;
    }

}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddsurface  )
*
* Dumps a DirectDraw surface structure.
*
\**************************************************************************/

DECLARE_API( dddsurface  )
{
    dprintf("Extension 'dddsurface' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddsurface;

    PARSE_ARGUMENTS(dddsurface_help);
    if(ntok<1) { goto dddsurface_help; }


    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddsurface_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) {
      fl |= (DDSURFACE_PRIVATE | DDSURFACE_PUBLIC | DDSURFACE_LOCKS);
    }
    if(parse_iFindSwitch(tokens, ntok, 'r')!=-1) { fl |= DDSURFACE_PRIVATE; }
    if(parse_iFindSwitch(tokens, ntok, 'u')!=-1) { fl |= DDSURFACE_PUBLIC; }
    if(parse_iFindSwitch(tokens, ntok, 'l')!=-1) { fl |= DDSURFACE_LOCKS; }
    if(parse_iFindSwitch(tokens, ntok, 'n')!=-1) { fl |= DDSURFACE_DDNEXT; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddsurface_help; }

    ddsurface = GetExpression(tokens[tok_pos]);

    if (fl == 0) {
      fl |= (DDSURFACE_PRIVATE | DDSURFACE_PUBLIC | DDSURFACE_LOCKS);
    }

    vPrintDDSURFACE((PVOID)ddsurface, fl);
    return;

dddsurface_help:
    dprintf("Usage: dddsurface [-?haruln] ddsurface");
    dprintf(" a - all info\n");
    dprintf(" r - private info\n");
    dprintf(" u - public info\n");
    dprintf(" l - locks\n");
    dprintf(" n - all surfaces in DdNext link\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* vPrintDDLOCAL
*
* Print out DirectDraw local object contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDLOCAL(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char pbr[sizeof(EDD_DIRECTDRAW_LOCAL)];
    EDD_DIRECTDRAW_LOCAL * peDirectDrawLocal;

    move2(pbr, pvServer, sizeof(EDD_DIRECTDRAW_LOCAL));

    dprintf("EDD_DIRECTDRAW_LOCAL structure at 0x%p:\n",pvServer);

    peDirectDrawLocal =  (EDD_DIRECTDRAW_LOCAL *)pbr;

    dprintf("--------------------------------------------------\n");
    dprintf("FLATPTR                fpProcess           0x%lx\n", peDirectDrawLocal->fpProcess);
    dprintf("--------------------------------------------------\n");
    dprintf("EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal  0x%lx\n", peDirectDrawLocal->peDirectDrawGlobal);
    dprintf("EDD_SURFACE*           peSurface_DdList    0x%lx\n", peDirectDrawLocal->peSurface_DdList);
    dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocalNext 0x%lx\n", peDirectDrawLocal->peDirectDrawLocalNext);
    dprintf("FLONG                  fl                  0x%lx\n", peDirectDrawLocal->fl);
    dprintf("HANDLE                 UniqueProcess       0x%lx\n", peDirectDrawLocal->UniqueProcess);
    dprintf("PEPROCESS              Process             0x%lx\n", peDirectDrawLocal->Process);
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddlocal  )
*
\**************************************************************************/

DECLARE_API( dddlocal  )
{
    dprintf("Extension 'dddlocal' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddlocal;

    PARSE_ARGUMENTS(dddlocal_help);
    if(ntok<1) { goto dddlocal_help; }

    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddlocal_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { fl |= 0; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddlocal_help; }
    ddlocal = GetExpression(tokens[tok_pos]);

    vPrintDDLOCAL((PVOID)ddlocal, fl);

    return;

dddlocal_help:
    dprintf("dddlocal [-?] [-h] [-a]\n\n");
    dprintf(" a - all info\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* vPrintDDGLOBAL
*
* Print out DirectDraw global object contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDGLOBAL(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char pbr[sizeof(EDD_DIRECTDRAW_GLOBAL) + 100];
    EDD_DIRECTDRAW_GLOBAL * peDirectDrawGlobal;

    move2(pbr, pvServer, sizeof(EDD_DIRECTDRAW_GLOBAL));

    dprintf("EDD_DIRECTDRAW_GLOBAL structure at 0x%p:\n", pvServer);

    peDirectDrawGlobal =  (EDD_DIRECTDRAW_GLOBAL *)pbr;

    dprintf("--------------------------------------------------\n");
    dprintf("VOID*                  dhpdev              0x%lx\n", peDirectDrawGlobal->dhpdev);
    dprintf("DWORD                  dwReserved1         0x%lx\n", peDirectDrawGlobal->dwReserved1);
    dprintf("DWORD                  dwReserved2         0x%lx\n", peDirectDrawGlobal->dwReserved2);
    dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocalList 0x%lx\n", peDirectDrawGlobal->peDirectDrawLocalList);
    dprintf("EDD_SURFACE*           peSurface_LockList  0x%lx\n", peDirectDrawGlobal->peSurface_PrimaryLockList);
    dprintf("FLONG                  fl                  0x%lx\n", peDirectDrawGlobal->fl);
    dprintf("ULONG                  cSurfaceLocks       0x%lx\n", peDirectDrawGlobal->cSurfaceLocks);
    dprintf("ULONG                  cSurfaceAliasedLocks 0x%lx\n", peDirectDrawGlobal->cSurfaceAliasedLocks);
    dprintf("PKEVENT                pAssertModeEvent    0x%lx\n", peDirectDrawGlobal->pAssertModeEvent);
    dprintf("LONGLONG               llAssertModeTimeout 0x%lx\n", (DWORD) peDirectDrawGlobal->llAssertModeTimeout);
    dprintf("EDD_SURFACE*           peSurfaceCurrent    0x%lx\n", peDirectDrawGlobal->peSurfaceCurrent);
    dprintf("EDD_SURFACE*           peSurfacePrimary    0x%lx\n", peDirectDrawGlobal->peSurfacePrimary);
    dprintf("BOOL                   bSuspended          0x%lx\n", peDirectDrawGlobal->bSuspended);
    dprintf("HDEV                   hdev                0x%lx\n", peDirectDrawGlobal->hdev);
    dprintf("LONG                   cDriverReferences   0x%lx\n", peDirectDrawGlobal->cDriverReferences);
    dprintf("DWORD                  dwNumHeaps          0x%lx\n", peDirectDrawGlobal->dwNumHeaps);
    dprintf("VIDEOMEMORY*           pvmList             0x%lx\n", peDirectDrawGlobal->pvmList);
    dprintf("DWORD                  dwNumFourCC         0x%lx\n", peDirectDrawGlobal->dwNumFourCC);
    dprintf("DWORD*                 pdwFourCC           0x%lx\n", peDirectDrawGlobal->pdwFourCC);
    dprintf("DD_HALINFO             HalInfo\n");
    dprintf("DD_CALLBACKS           CallBacks\n");
    dprintf("DD_SURFACECALLBACKS    SurfaceCallBacks\n");
    dprintf("DD_PALETTECALLBACKS    PaletteCallBacks\n");
    dprintf("RECTL                  rclBounds           (%ld, %ld), (%ld, %ld)\n",
        peDirectDrawGlobal->rclBounds.left,  peDirectDrawGlobal->rclBounds.top,
        peDirectDrawGlobal->rclBounds.right, peDirectDrawGlobal->rclBounds.bottom);
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddglobal  )
*
\**************************************************************************/

DECLARE_API( dddglobal  )
{
    dprintf("Extension 'dddglobal' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddglobal;

    PARSE_ARGUMENTS(dddglobal_help);
    if(ntok<1) { goto dddglobal_help; }

    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddglobal_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { fl |= 0; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddglobal_help; }
    ddglobal = GetExpression(tokens[tok_pos]);

    vPrintDDGLOBAL((PVOID)ddglobal, fl);
    return;

dddglobal_help:
    dprintf("dddglobal [-?] [-h] [-a]\n\n");
    dprintf(" a - all info\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


char *pszDdTypes[] = {
"DD_DEF_TYPE       ",
"DD_DIRECTDRAW_TYPE",
"DD_SURFACE_TYPE   ",
"D3D_HANDLE_TYPE   ",
"DD_VIDEOPORT_TYPE ",
"DD_MOTIONCOMP_TYPE",
"TOTALS            ",
"DEF               "
};

#define DD_TOTAL_TYPE (DD_MAX_TYPE+1)

/******************************Public*Routine******************************\
* DECLARE_API( dumpdd  )
*
* Dumps the count of handles in DdHmgr for each object type.
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dumpdd  )
{
    dprintf("Extension 'dumpdd' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PENTRY pent;
    ULONG gcMaxHmgr;
    ULONG gcSizeHmgr;
    ULONG ulLoop;    // loop variable
    ULONG objt;
    ULONG pulCount[DD_MAX_TYPE + 2];
    ULONG cUnknown = 0;
    ULONG cUnknownSize = 0;
    ULONG cUnused = 0;
    ENTRY entry;
    ULONG HmgCurrentNumberOfObjects[DD_MAX_TYPE + 2] = {0};
    ULONG HmgMaximumNumberOfObjects[DD_MAX_TYPE + 2] = {0};
    ULONG HmgNumberOfObjectsAllocated[DD_MAX_TYPE + 2] = {0};
    ULONG HmgCurrentNumberOfHandles[DD_MAX_TYPE + 2] = {0};
    ULONG HmgMaximumNumberOfHandles[DD_MAX_TYPE + 2] = {0};
    ULONG HmgNumberOfHandlesAllocated[DD_MAX_TYPE + 2] = {0};

    PARSE_ARGUMENTS(dumpdd_help);

    // Get the pointers and counts from win32k

    GetValue (pent, "win32k!gpentDdHmgr");
    GetValue (gcMaxHmgr, "win32k!gcMaxDdHmgr");
    GetValue (gcSizeHmgr, "win32k!gcSizeDdHmgr");


    dprintf("Max handles out so far %lu\n", gcMaxHmgr - DD_HMGR_HANDLE_BASE);

    if (pent == NULL || gcMaxHmgr == 0)
    {
        dprintf("terminating: pent = %lx, gcMaxDdHmgr = %lx\n",pent,gcMaxHmgr);
        return;
    }

// Print out the amount reserved and committed, note we assume a 4K page size

    dprintf("Total allocated for DdHmgr %lu (%d handles)\n", gcSizeHmgr * sizeof(ENTRY), gcSizeHmgr);


//CHECKLOOP
    for (ulLoop = 0; ulLoop <= DD_TOTAL_TYPE; ulLoop++)
    {
        pulCount[ulLoop] = 0;
    }


//CHECKLOOP
    for (ulLoop = DD_HMGR_HANDLE_BASE; ulLoop < gcMaxHmgr; ulLoop++)
    {
        move (entry, &(pent[ulLoop]));

        objt = (ULONG) entry.Objt;

        if (objt == DD_DEF_TYPE)
        {
            cUnused++;
        }
        if (objt > DD_MAX_TYPE)
        {
            cUnknown++;
        }
        else
        {
            pulCount[objt]++;
        }
        if (CheckControlC())
           return;
    }
    dprintf("ulLoop=%d, gcMaxDdHmgr=%d\n", ulLoop, gcMaxHmgr);

    dprintf("%8s%17s\n","TYPE","Current");

    // init the totals

    pulCount[DD_TOTAL_TYPE]                           = 0;
    HmgMaximumNumberOfHandles[DD_TOTAL_TYPE]          = 0;

    // now go through printing each line and accumulating totals

    for (ulLoop = 0; ulLoop <= DD_MAX_TYPE; ulLoop++)
    {
        dprintf("%s%4lu\n",
            pszDdTypes[ulLoop],
            pulCount[ulLoop]);

        if (ulLoop != DD_DEF_TYPE)
        {
            pulCount[DD_TOTAL_TYPE]                    += pulCount[ulLoop];
        }

        if (CheckControlC())
            return;
    }

    dprintf("%s%4lu\n", pszDdTypes[DD_TOTAL_TYPE],
                        pulCount[DD_TOTAL_TYPE]);

    dprintf ("\ncUnused objects %lu\n", cUnused);
    dprintf("cUnknown objects %lu\n",cUnknown);
    return;

dumpdd_help:
    dprintf("Usage: dumpdd [-?]\n");
    dprintf("dumpdd displays the amount of each type of object in the ddraw handle manager\n");
    dprintf("-? produces this help\ndumpdd ignores all other arguments\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

char *pszDdTypes2[] = {
"DEF",
"DDRAW",
"SURF",
"D3DH",
"VPE",
"MOCOMP"
};

/******************************Public*Routine******************************\
* DECLARE_API( dumpddobj  )
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dumpddobj  )
{
    dprintf("Extension 'dumpddobj' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PENTRY pent;
    ULONG gcMaxHmgr;
    ULONG ulLoop;
    ENTRY entry;
    LONG  Pid = PID_ALL;
    LONG  Type = TYPE_ALL;
    BOOL  bCheckLock = FALSE;
    BOOL  bSummary = FALSE;
    int   i;

    PARSE_ARGUMENTS(dumpddobj_help);
    if(ntok<1) {
      goto dumpddobj_help;
    }

    //find valid tokens - ignore the rest
    bCheckLock = (parse_iFindSwitch(tokens, ntok, 'l') >= 0);
    bSummary = (parse_iFindSwitch(tokens, ntok, 's') >= 0);
    tok_pos = parse_iFindSwitch(tokens, ntok, 'p');
    if(tok_pos>=0) {
      tok_pos++;
      if((tok_pos+1)>=ntok) {
        goto dumpddobj_help;               //-p requires a pid and it can't be the last arg
      }
      Pid = (LONG)GetExpression(tokens[tok_pos]);
    }

    //find first non-switch token not preceeded by a -p
    tok_pos = -1;
    do {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'p')));
    if(tok_pos==-1) {
      goto dumpddobj_help;
    }


//CHECKLOOP
    for (Type = 0; Type <= DD_MAX_TYPE; ++Type) {
      if(parse_iIsToken(tokens, tok_pos, pszDdTypes2[Type])) {
        break;
      }
    }

    if (Type > DD_MAX_TYPE) {
      goto dumpddobj_help;
    }
    //
    // Get the pointers and counts from win32k
    //

    GetValue(pent, "win32k!gpentDdHmgr");
    GetValue(gcMaxHmgr, "win32k!gcMaxDdHmgr");

    if (pent == NULL || gcMaxHmgr == 0)
    {
        dprintf("terminating: pent = %lx, gcMaxDdHmgr = %lx\n",pent,gcMaxHmgr);
        return;
    }

    //
    // dprintf out the amount reserved and committed, note we assume a 4K page size
    //

    dprintf("object list for %s type objects",Type == TYPE_ALL ? "ALL" : pszDdTypes2[Type]);
    if (Pid == PID_ALL)
    {
        dprintf(" owned by ALL PIDs\n");
    }
    else
    {
        dprintf(" owned by PID 0x%lx\n",Pid);
    }

    if(!bSummary) {
      dprintf("%4s, %8s, %6s, %6s, %4s, %8s, %8s, %6s, %6s, %8s,%9s\n",
           "I","handle","Lock","sCount","pid","pv","objt","unique","Flags","pUser","Tlock");

      dprintf("--------------------------------------------------------------------------------------------\n");
    }

    {
        LONG ObjCount = 0;
        LONG ObjArray[DD_MAX_TYPE+1];
        for(i=0;i<=DD_MAX_TYPE;i++) {
          ObjArray[i]=0;
        }

//CHECKLOOP
        for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
        {
            LONG  objt;
            LONG  ThisPid;

            move(entry, &(pent[ulLoop]));
            objt = entry.Objt;
            ThisPid = OBJECTOWNER_PID(entry.ObjectOwner);

            if (
                 ((objt == Type) || (Type == TYPE_ALL)) &&
                 ((ThisPid == Pid) || (Pid == PID_ALL)) &&
                 ((!bCheckLock) || (entry.ObjectOwner.Share.Lock))
               )
            {

                ObjCount++;

                if (!bSummary)
                {
                    BASEOBJECT baseObj;
            move(baseObj, entry.einfo.pobj);

                    dprintf("%4lx, %8lx, %6lx, %6lx, %4lx, %8lx, %8s, %6lx, %6lx, %08x, %08lx\n",
                        ulLoop,
                        DD_MAKE_HMGR_HANDLE(ulLoop,entry.FullUnique),
                        (entry.ObjectOwner.Share.Lock != 0),
                        baseObj.ulShareCount,
                        OBJECTOWNER_PID(entry.ObjectOwner),
                        entry.einfo,
                        pszDdTypes2[entry.Objt],
                        entry.FullUnique,
                        entry.Flags,
                        entry.pUser,
                        entry.pUser);
                }
                else
                {
                    ObjArray[entry.Objt]++;
                }

            }

            if (CheckControlC())
                return;
        }

        if(bSummary && (Type==TYPE_ALL)) {
          for(i=0;i<=DD_MAX_TYPE; i++) {
            if(ObjArray[i]>0) {
              dprintf("%s\t%ld\n", pszDdTypes2[i], ObjArray[i]);
            }
          }
        }
        dprintf("Total objects = %li\n",ObjCount);
    }

    return;

dumpddobj_help:
  dprintf("Usage: dumpddobj [-?] [-p pid] [-l] [-s] object_type\n");
  dprintf("-l check lock\n");
  dprintf("-s summary\n");
  dprintf("\nThe -s option combined with the DEF object type will produce"
          " a list of the totals for each object type\n");

  dprintf("\nValid object_type values are:\n");
  for(i=0;i<=DD_MAX_TYPE;i++) {
    dprintf("%s\n", pszDdTypes2[i]);
  }
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* DECLARE_API( dddh  )
*
* Debugger extension to dump a handle.
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dddh  )
{
    dprintf("Extension 'dddh' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    HOBJ    ho;                             // dump this handle
    PENTRY  pent;                           // base address of hmgr entries
    ENTRY   ent;                            // copy of handle entry
    BASEOBJECT obj;
    ULONG   ulTemp;
    int     iRet;

    PARSE_POINTER(dddh_help);
    ho = (HOBJ)arg;
// Get argument (handle to dump).

    dprintf("--------------------------------------------------\n");
    dprintf("Entry from ghmgr for handle 0x%08lx:\n", ho        );

// Dereference the handle via the engine's handle manager.

    GetAddress(pent, "win32k!gpentDdHmgr");

    dprintf("&pent = %lx\n",pent);

    GetValue(pent, "win32k!gpentDdHmgr");

    dprintf("pent = %lx\n",pent);

    iRet = move(ent,  &(pent[DdHmgIfromH((ULONG_PTR) ho)]));

    dprintf("move() = %lx\n",iRet);

// dprintf the entry.
    BASEOBJECT baseObj;
    move(baseObj, ent.einfo.pobj);

    dprintf("    pobj/hfree  = 0x%08lx\n"  , ent.einfo.pobj);
    dprintf("    ObjectOwner = 0x%08lx\n"  , ent.ObjectOwner.ulObj);
    dprintf("    pidOwner    = 0x%x\n"     , OBJECTOWNER_PID(ent.ObjectOwner));
    dprintf("    ShareCount  = 0x%x\n"     , baseObj.ulShareCount);
    dprintf("    lock        = %s\n"       , ent.ObjectOwner.Share.Lock ? "LOCKED" : "UNLOCKED");
    dprintf("    puser       = 0x%x\n"     , ent.pUser);
    dprintf("    objt        = 0x%hx\n"    , ent.Objt);
    dprintf("    usUnique    = 0x%hx\n"    , ent.FullUnique);
    dprintf("    fsHmgr      = 0x%hx\n"    , ent.Flags);

// If it has an object we get the lock counts and tid owner.

    if (ent.Objt != DD_DEF_TYPE)
    {
        if (ent.einfo.pobj != NULL)
        {
            move(obj,ent.einfo.pobj);
            dprintf("    hHmgr       = 0x%08lx\n"  , obj.hHmgr);
            dprintf("    cExcluLock  = 0x%08lx\n"    , obj.cExclusiveLock);
            dprintf("    tid         = 0x%08lx\n"    , obj.Tid);
        }
        else
        {
            dprintf("It has a NULL pointer\n");
        }
    }

    ulTemp = (ULONG) ent.Objt;

    switch(ulTemp)
    {
    case DD_DEF_TYPE:
        dprintf("This is DD_DEF_TYPE\n");
        break;

    case DD_DIRECTDRAW_TYPE:
        dprintf("This is DD_DIRECTDRAW_TYPE\n");
        break;

    case DD_SURFACE_TYPE:
        dprintf("This is DD_SURFACE_TYPE\n");
        break;

    case D3D_HANDLE_TYPE:
        dprintf("This is D3D_HANDLE_TYPE\n");
        break;

    case DD_VIDEOPORT_TYPE:
        dprintf("This is DD_VIDEOPORT_TYPE\n");
        break;

    case DD_MOTIONCOMP_TYPE:
        dprintf("This is DD_MOTIONCOMP_TYPE\n");
        break;
    
    default:
            dprintf("This is of unknown type - an error\n");
    }
    dprintf("--------------------------------------------------\n");

  return;

dddh_help:
  dprintf("Usage: dddh [-?] object_handle\n");
  dprintf("-? displays this help\n");
  dprintf("object_handle must be in hexadecimal\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* DECLARE_API( dddht  )
*
* Debugger extension to dump a handle type.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dddht  )
{
    dprintf("Extension 'dddht' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    DWORD dwHandle;

    PARSE_POINTER(dddht_help);
    dwHandle = (DWORD)arg;

    // Get argument (handle to dump).
    dprintf("Handle: %lx\n",dwHandle);
    dprintf("\tIndex | UNIQUE | SRV TYPE\n");
    dprintf("\t %.4x |   %.2x   | %.6s (%2x)\n",
           DdHmgIfromH(dwHandle),
           (dwHandle & DD_UNIQUE_MASK) >> DD_UNIQUE_SHIFT,
           pszDdTypes[DdHmgObjtype(dwHandle)], DdHmgObjtype(dwHandle));

    return;

dddht_help:
  dprintf("Usage: dddht [-?] object_handle\n");
  dprintf("-? displays this help\n");
  dprintf("object_handle must be in hexadecimal\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\debug.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.cxx

Abstract:

    This file contains debug routines to debug extenstion problems.

Author:

    JasonHa

--*/


#include <precomp.hxx>


#if DBG

const char NoIndent[] = "";

void
vPrintNativeFieldInfo(
    PFIELD_INFO pFI,
    const char *pszIndent)
{
    if (!pFI) return;

    DbgPrint("  %sPUCHAR  fName     = \"%s\"\n", pszIndent, pFI->fName);
    DbgPrint("  %sPUCHAR  printName = \"%s\"\n", pszIndent, pFI->printName);
    DbgPrint("  %sULONG   size      = 0x%x\n", pszIndent, pFI->size);
    DbgPrint("  %sULONG   fOptions  = 0x%08x\n", pszIndent, pFI->fOptions);
    DbgPrint("  %sULONG64 address   = 0x%I64x\n", pszIndent, pFI->address);
    DbgPrint("  %sPVOID   fieldCallBack = 0x%p\n", pszIndent, pFI->fieldCallBack);
}


void
vPrintNativeSymDumpParam(
    PSYM_DUMP_PARAM pSDP,
    BOOL bDumpFields,
    const char *pszIndent)
{
    if (!pSDP) return;

    char    pszNextIndent[80];
    _snprintf(pszNextIndent, sizeof(pszNextIndent), "%s  ", pszIndent);

    DbgPrint("  %sULONG               size     = 0x%x\n", pszIndent, pSDP->size);
    DbgPrint("  %sPUCHAR              sName    = \"%s\"\n", pszIndent, pSDP->sName);
    DbgPrint("  %sULONG               Options  = 0x%08x\n", pszIndent, pSDP->Options);
    DbgPrint("  %sULONG64             addr     = 0x%I64x\n", pszIndent, pSDP->addr);
    DbgPrint("  %sPFIELD_INFO         listLink = 0x%p\n", pszIndent, pSDP->listLink);
    DbgPrint("  %sPVOID               Context  = 0x%p\n", pszIndent, pSDP->Context);
    DbgPrint("  %sPSYM_DUMP_FIELD_CALLBACK CallbackRoutine = 0x%p\n", pszIndent, pSDP->CallbackRoutine);
    DbgPrint("  %sULONG               nFields  = %d\n", pszIndent, pSDP->nFields);
    DbgPrint("  %sPFIELD_INFO         Fields   = 0x%p\n", pszIndent, pSDP->Fields);

    if (bDumpFields && pSDP->Fields)
    {
        for (ULONG nField = 0; nField < pSDP->nFields; nField++)
        {
            DbgPrint("  %sFIELD_INFO          Fields[%d] = {\n", pszIndent, nField);
            vPrintNativeFieldInfo(&pSDP->Fields[nField], pszNextIndent);
            DbgPrint("  %s}\n", pszIndent);
        }
    }
}

#endif  DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\event.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    event.cxx

Abstract:

    This file contains the routines to track and handle
    debugger events.

Author:

    Jason Hartman (JasonHa) 2000-11-20

Environment:

    User Mode

--*/

#include "precomp.hxx"

BOOL gbSymbolsNotLoaded = TRUE;

ULONG UniqueTargetState = INVALID_UNIQUE_STATE;

#if DBG && 0
ULONG
DbgEventPrint(
    IN PCHAR Format,
    ...
    )
{
    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("Event: ", -1, 0, Format, arglist);
}

#else
#define DbgEventPrint
#endif

typedef struct {
    PDEBUG_CLIENT   Client;
    BOOL            ParamsRead;
} MonitorThreadParams;


DWORD WINAPI EventMonitorThread(MonitorThreadParams *);


class EventMonitorCallbacks : public DebugBaseEventCallbacks
{
private:
    ULONG           RefCount;

public:

    EventMonitorCallbacks()
    {
        RefCount = 1;
    }

    // IUnknown
    STDMETHOD_(ULONG, AddRef)(
        THIS
        )
    {
        RefCount++;

        return RefCount;
    }

    STDMETHOD_(ULONG, Release)(
        THIS
        )
    {
        RefCount--;

        if (RefCount == 0)
        {
            delete this;
            return 0;
        }

        return RefCount;
    }


    // IDebugEventCallbacks.
    
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        )
    {
        DbgEventPrint("GetInterestMask\n");

        if (Mask != NULL)
        {
            *Mask = DEBUG_EVENT_SESSION_STATUS |
                    DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
                    DEBUG_EVENT_CHANGE_ENGINE_STATE |
                    DEBUG_EVENT_CHANGE_SYMBOL_STATE |
                    DEBUG_EVENT_UNLOAD_MODULE;
        }

        return S_OK;
    }

    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        )
    {
        DbgEventPrint("BP\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        )
    {
        DbgEventPrint("Exception\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        )
    {
        DbgEventPrint("CreateThread\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        )
    {
        DbgEventPrint("ExitThread\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        )
    {
        DbgEventPrint("CreateProcess\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        )
    {
        DbgEventPrint("ExitProcess\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        )
    {
        DbgEventPrint("LoadModule:\n"
                      "  ModuleName: %s\n"
                      "  ImageName: %s\n"
                      "  BaseOffset: %I64x\n",
                      ModuleName, ImageName, BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        )
    {
        // Don't use Image base name for now - Debugger bug
        //DbgEventPrint("UnloadModule %s @ %I64x\n", ImageBaseName, BaseOffset);
        DbgEventPrint("UnloadModule ? @ %I64x\n", BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        )
    {
        DbgEventPrint("SystemError(%lu, %lu)\n", Error, Level);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        )
    {
        DbgEventPrint("SessionStatus(%lu)\n", Status);
        if (Status == DEBUG_SESSION_ACTIVE) DbgEventPrint("DEBUG_SESSION_ACTIVE\n");
        if (Status == DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE) DbgEventPrint("DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE\n");
        if (Status == DEBUG_SESSION_END_SESSION_ACTIVE_DETACH) DbgEventPrint("DEBUG_SESSION_END_SESSION_ACTIVE_DETACH\n");
        if (Status == DEBUG_SESSION_END_SESSION_PASSIVE) DbgEventPrint("DEBUG_SESSION_END_SESSION_PASSIVE\n");
        if (Status == DEBUG_SESSION_END) DbgEventPrint("DEBUG_SESSION_END\n");
        if (Status == DEBUG_SESSION_REBOOT) DbgEventPrint("DEBUG_SESSION_REBOOT\n");
        if (Status == DEBUG_SESSION_HIBERNATE) DbgEventPrint("DEBUG_SESSION_HIBERNATE\n");
        if (Status == DEBUG_SESSION_FAILURE) DbgEventPrint("DEBUG_SESSION_FAILURE\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        DbgEventPrint("ChangeDebuggeeState(0x%lx, 0x%I64x)\n", Flags, Argument);
        if (Flags == DEBUG_CDS_ALL)
        {
            DbgEventPrint("DEBUG_CDS_ALL\n");
            UniqueTargetState++;
        }
        else
        {
            if (Flags & DEBUG_CDS_REGISTERS) DbgEventPrint("DEBUG_CDS_REGISTERS\n");
            if (Flags & DEBUG_CDS_DATA)
            {
                DbgEventPrint("DEBUG_CDS_DATA\n");
                UniqueTargetState++;
            }
        }
        if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        return S_OK;
    }

    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        //DbgEventPrint("ChangeEngineState(0x%lx, 0x%I64x)\n", Flags, Argument);
        if (Flags == DEBUG_CES_ALL)
        {
            DbgEventPrint("DEBUG_CES_ALL\n");
            UniqueTargetState++;
            if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        }
        else
        {
            if (Flags & DEBUG_CES_CURRENT_THREAD) DbgEventPrint("DEBUG_CES_CURRENT_THREAD\n");
            if (Flags & DEBUG_CES_EFFECTIVE_PROCESSOR) DbgEventPrint("DEBUG_CES_EFFECTIVE_PROCESSOR\n");
            if (Flags & DEBUG_CES_BREAKPOINTS) DbgEventPrint("DEBUG_CES_BREAKPOINTS\n");
            if (Flags & DEBUG_CES_CODE_LEVEL) DbgEventPrint("DEBUG_CES_CODE_LEVEL\n");
            if (Flags & DEBUG_CES_EXECUTION_STATUS)
            {
                DbgEventPrint("DEBUG_CES_EXECUTION_STATUS\n");
                switch (Argument & DEBUG_STATUS_MASK)
                {
                    case DEBUG_STATUS_NO_CHANGE: DbgPrint("Exec Status: DEBUG_STATUS_NO_CHANGE\n"); break;
                    case DEBUG_STATUS_GO: DbgPrint("Exec Status: DEBUG_STATUS_GO\n"); break;
                    case DEBUG_STATUS_GO_HANDLED: DbgPrint("Exec Status: DEBUG_STATUS_GO_HANDLED\n"); break;
                    case DEBUG_STATUS_GO_NOT_HANDLED: DbgPrint("Exec Status: DEBUG_STATUS_GO_NOT_HANDLED\n"); break;
                    case DEBUG_STATUS_STEP_OVER: DbgPrint("Exec Status: DEBUG_STATUS_STEP_OVER\n"); break;
                    case DEBUG_STATUS_STEP_INTO: DbgPrint("Exec Status: DEBUG_STATUS_STEP_INTO\n"); break;
                    case DEBUG_STATUS_BREAK: DbgPrint("Exec Status: DEBUG_STATUS_BREAK\n"); break;
                    case DEBUG_STATUS_NO_DEBUGGEE: DbgPrint("Exec Status: DEBUG_STATUS_NO_DEBUGGEE\n"); break;
                    case DEBUG_STATUS_STEP_BRANCH: DbgPrint("Exec Status: DEBUG_STATUS_STEP_BRANCH\n"); break;
                    case DEBUG_STATUS_IGNORE_EVENT: DbgPrint("Exec Status: DEBUG_STATUS_IGNORE_EVENT\n"); break;
                    default: DbgPrint("Exec Status: Unknown\n"); break;
                }
                if (Argument & DEBUG_STATUS_INSIDE_WAIT) DbgPrint("Exec Status: DEBUG_STATUS_INSIDE_WAIT\n");
                if ((Argument & DEBUG_STATUS_MASK) != DEBUG_STATUS_NO_CHANGE)
                {
                    UniqueTargetState++;
                    if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
                }
            }
            if (Flags & DEBUG_CES_ENGINE_OPTIONS) DbgEventPrint("DEBUG_CES_ENGINE_OPTIONS\n");
            if (Flags & DEBUG_CES_LOG_FILE) DbgEventPrint("DEBUG_CES_LOG_FILE\n");
            //if (Flags & DEBUG_CES_RADIX) DbgEventPrint("DEBUG_CES_RADIX\n");
            if (Flags & DEBUG_CES_EVENT_FILTERS) DbgEventPrint("DEBUG_CES_EVENT_FILTERS\n");
            if (Flags & DEBUG_CES_PROCESS_OPTIONS) DbgEventPrint("DEBUG_CES_PROCESS_OPTIONS\n");
            if (Flags & DEBUG_CES_EXTENSIONS) DbgEventPrint("DEBUG_CES_EXTENSIONS\n");
        }
        return S_OK;
    }

    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        DbgEventPrint("ChangeSymbolState(0x%lx, 0x%I64x)\n", Flags, Argument);
        gbSymbolsNotLoaded = gbSymbolsNotLoaded || (Flags & DEBUG_CSS_UNLOADS);
        UniqueTargetState++;
        if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        return S_OK;
    }
};

typedef enum {
    NO_DISPATCHING,
    NEED_DISPATCH,
    DISPATCHED
} MonitorState;

LONG            g_MonitorState = NO_DISPATCHING;
PDEBUG_CLIENT   g_pMonitorClient = NULL;
BOOL            g_MonitorThreadSet = FALSE;

DWORD
WINAPI
EventMonitorThread(
    MonitorThreadParams *Params
    )
{
    HRESULT                 hr = S_OK;
    PDEBUG_CLIENT           Client;
    MonitorThreadParams     ParamCopy;
    HMODULE                 hModule = NULL;
    TCHAR                   ModulePath[256];

    if (Params != NULL && Params->Client != NULL)
    {
        ASSERTMSG("EventMonitorThread not started with NEED_DISPATCH.\n", g_MonitorState == NEED_DISPATCH);

        if (GetModuleFileName(ghDllInst, ModulePath, sizeof(ModulePath)/sizeof(TCHAR)) == 0)
        {
            DbgPrint("EventMonitorThread failed to get Module path.\n");
            hr = S_FALSE;
        }
        else
        {
            // LoadLibrary so we have a reference while this thread lives
            hModule = LoadLibrary(ModulePath);

            if (hModule != ghDllInst)
            {
                DbgPrint("EventMonitorThread retrieving an hModule different from ghDllInst.\n");
                hr = S_FALSE;
            }
        }

        if (hr == S_OK)
        {
            Params->Client->AddRef();

            ParamCopy = *Params;
            Params->ParamsRead = TRUE;
            Params = &ParamCopy;

            hr = Params->Client->CreateClient(&Client);
            DbgPrint("EventMonitorThread created client %p.\n", Client);

            Params->Client->Release();

            if (hr == S_OK)
            {
                EventMonitorCallbacks  *EventMonitor = new EventMonitorCallbacks;

                if (EventMonitor != NULL)
                {
                    hr = Client->SetEventCallbacks(EventMonitor);

                    if (hr == S_OK)
                    {
                        // Pass monitoring client back to caller.
                        Client->AddRef();
                        if (InterlockedCompareExchangePointer((PVOID*)&g_pMonitorClient, Client, NULL) == NULL &&
                            InterlockedCompareExchange(&g_MonitorState, DISPATCHED, NEED_DISPATCH) == NEED_DISPATCH)
                        {
                            DbgPrint("EventMonitorThread dispatching for client %p.\n", Client);
                            UniqueTargetState++;
                            hr = Client->DispatchCallbacks(INFINITE);
                        }
                        else
                        {
                            // Another EventMonitorThread has already started or
                            // ReleaseEventCallbacks has already been called; so,
                            // release this client and
                            // NULL global monitor client if we set it
                            DbgPrint("EventMonitorThread exiting instead of dispatching for client %p.\n", Client);
                            InterlockedCompareExchangePointer((PVOID*)&g_pMonitorClient, NULL, Client);
                            Client->Release();
                        }
                    }
                    else
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("EventMonitorThread callbacks setup failed, %s.\n", pszHRESULT(hr));
                    }

                    EventMonitor->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                Client->Release();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DbgPrint("EventMonitorThread calling ExitThread().\n");

    FreeLibraryAndExitThread(hModule, (DWORD)hr);
}


void
ReleaseEventCallbacks(
    PDEBUG_CLIENT Client
    )
{
    if (g_MonitorThreadSet)
    {
        if (InterlockedExchange(&g_MonitorState, NO_DISPATCHING) == DISPATCHED)
        {
            PDEBUG_CLIENT   pMonitorClient;
            
            pMonitorClient = (PDEBUG_CLIENT)InterlockedExchangePointer((PVOID *)&g_pMonitorClient, NULL);

            ASSERTMSG("g_MonitorState shows g_pMonitorClient should be set.\n", pMonitorClient != NULL);

            if (Client == NULL)
            {
                if (GetDebugClient(&Client) != S_OK)
                {
                    Client = pMonitorClient;
                    Client->AddRef();
                }
            }
            else
            {
                Client->AddRef();
            }

            Client->ExitDispatch(pMonitorClient);
            pMonitorClient->Release();
            Client->Release();
        }

        g_MonitorThreadSet = FALSE;
    }
}


HRESULT
SetEventCallbacks(
    PDEBUG_CLIENT Client
    )
{
    HRESULT hr = S_FALSE;

    if (!g_MonitorThreadSet)
    {
        MonitorThreadParams  NewThreadParams = { Client, FALSE };
        HANDLE  hThread;
        DWORD   ThreadID;
        LONG    PrevMonitorState;

        PrevMonitorState = InterlockedExchange(&g_MonitorState, NEED_DISPATCH);
        ASSERTMSG("Previous EventMonitor thread was never shutdown properly.\n", PrevMonitorState != DISPATCHED);
        ASSERTMSG("Previous EventMonitor thread never completed setup.\n", PrevMonitorState != NEED_DISPATCH);

        g_pMonitorClient = NULL;

        hThread = CreateThread(NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)EventMonitorThread,
                               &NewThreadParams,
                               0,
                               &ThreadID);

        if (hThread)
        {
            // Default ExitCode to STILL_ACTIVE since it doesn't matter
            // if the Params were read before we started checking.
            DWORD ExitCode = STILL_ACTIVE;

            while (!NewThreadParams.ParamsRead)
            {
                ExitCode = 0;
                if (!GetExitCodeThread(hThread, &ExitCode))
                    DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                if (ExitCode != STILL_ACTIVE)
                {
                    break;
                }

                SleepEx(10, TRUE);
            }

            if (ExitCode == STILL_ACTIVE)
            {
                hr = S_OK;
                g_MonitorThreadSet = TRUE;
            }

            CloseHandle(hThread);
        }
    }

    return hr;
}


HRESULT
EventCallbacksReady(
    PDEBUG_CLIENT Client
    )
{
    return (g_MonitorThreadSet && g_MonitorState == DISPATCHED) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\dumpers.cxx ===
/******************************Module*Header*******************************\
* Module Name: dumpers.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// A resonable count limit for scans and walls
#define COUNT_LIMIT 0x07ffffff

/**************************************************************************\
*
*   class ScanDumper
*
\**************************************************************************/

const FIELD_INFO ScanFieldsInit[SCAN_FIELDS_LENGTH] = {
    { DbgStr("cWalls"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("yTop"),       NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("yBottom"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("ai_x[0]"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL },
};
const SYM_DUMP_PARAM ScanSymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SCAN)), DBG_DUMP_NO_PRINT, 0,
    NULL, NULL, NULL, SCAN_FIELDS_LENGTH, NULL
};
const FIELD_INFO WallFieldsInit[1] = {
    { DbgStr("x"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, LeftWallCallback },
};
const SYM_DUMP_PARAM WallSymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(_INDEX_LONG)), DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY, 0,
    NULL, NULL, NULL, 1, NULL
};
const SYM_DUMP_PARAM cWalls2SymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr("ULONG"), DBG_DUMP_NO_PRINT | DBG_DUMP_ADDRESS_AT_END | DBG_DUMP_COPY_TYPE_DATA, 0,
    NULL, NULL, NULL, 0, NULL
};


/**************************************************************************\
*
*   ScanDumper::ScanDumper
*
\**************************************************************************/
ScanDumper::ScanDumper(
    ULONG64 HeadScanAddr,
    ULONG64 TailScanAddr,
    ULONG   ScanCount,
    ULONG64 AllocationBase,
    ULONG64 AllocationLimit,
    ULONG   Flags
    )
{
    block = 0;
    Top = POS_INFINITY;
    Bottom = NEG_INFINITY;
    FirstScanAddr = HeadScanAddr;
    LastScanAddr = TailScanAddr;
    ScanLimit = ScanCount ? ScanCount : COUNT_LIMIT;
    AddressBase = AllocationBase;
    AddressLimit = AllocationLimit;
    PrintBlocks = (Flags & SCAN_DUMPER_NO_PRINT) == 0;
    ForceDump = (Flags & SCAN_DUMPER_FORCE) != 0; 
    Reverse = (Flags & SCAN_DUMPER_FROM_TAIL) != 0; 

    // Enable to print a . after each right wall is 
    // processed when block printing is disabled.
    PrintProgress = FALSE;
    ProgressCount = 0;

    RtlCopyMemory(ScanFields, ScanFieldsInit, sizeof(ScanFields));
    RtlCopyMemory(&ScanSym, &ScanSymInit, sizeof(ScanSym));
    ScanSym.Fields = ScanFields;

    ListWallSize.fOptions = 0;
    ListWallSize.fieldCallBack = WallArrayEntryCallback;

    RtlCopyMemory(WallFields, WallFieldsInit, sizeof(WallFields));
    RtlCopyMemory(&WallSym, &WallSymInit, sizeof(WallSym));
    WallSym.listLink = &ListWallSize;
    WallSym.Fields = WallFields;

    RtlCopyMemory(&cWalls2Sym, &cWalls2SymInit, sizeof(cWalls2Sym));

    Valid = TRUE;

    // Get basic scan structure information
    ScanSize = GetTypeSize(GDIType(SCAN));

    if (1)
    {
        cWallsSize = GetTypeSize("ULONG");
        IXSize = GetTypeSize(GDIType(_INDEX_LONG));
    }
    else
    {
        ULONG error;

        error = Ioctl(IG_DUMP_SYMBOL_INFO, &ScanSym, ScanSym.size);

        if (error)
        {
            dprintf("  SCAN type info Ioctl returned %s\n", pszWinDbgError(error));
        }

        cWallsSize = ScanFields[SCAN_CWALLS].size;
        IXSize = ScanFields[SCAN_AI_X_ADDR].size;
    }

    if (Reverse && cWallsSize != GetTypeSize("ULONG"))
    {
        dprintf(" * Error: sizeof(SCAN::cWalls) != sizeof(ULONG)\n"
                "     => From tail scan dumping won't work.\n");
        Reverse = FALSE;
    }

    if (Reverse)
    {
        scan = ScanCount;
        NegativeScanCount = (ScanCount == 0);
        ScanAddr = TailScanAddr;
    }
    else
    {
        scan = -1;
        NegativeScanCount = FALSE;
        ScanAddr = HeadScanAddr;
    }

    // Will DumpScans work?
    CanDump = (ScanSize != 0) && (cWallsSize != 0) && (IXSize != 0);
}


/**************************************************************************\
*
*   ScanDumper::DumpScans
*
\**************************************************************************/
BOOL
ScanDumper::DumpScans(
    ULONG Count
    )
{
    ULONG64 NextScanAddr;
    ULONG   cWalls1, cWalls2;
    ULONG   error;

    if (!CanDump)
    {
        dprintf(" An error occured in this extension preventing DumpScans from working.\n");
        return FALSE;
    }

    if (! Count && PrintBlocks)
    {
        dprintf("\tNo scans to dump.\n");
    }

    if (Count > 100)
    {
        PrintProgress = TRUE;
        ProgressCount = 0;
    }

    while (Count-- && !CheckControlC())
    {
        cWalls1 = cWalls2 = 0;

        if (Reverse)
        {
            if (!NT_SUCCESS(ValidateAddress(ScanAddr, "End of ScanAddr", SCAN_VALID_AT_END)))
            {
                if (!ForceDump) break;
            }

            cWalls2Sym.addr = ScanAddr;
            cWalls2Sym.Context = &cWalls2;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &cWalls2Sym, cWalls2Sym.size);
            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }

            ScanAddr -= cWalls2 * IXSize + ScanSize;
        }

        if (gbVerbose)
        {
            dprintf(" Examining scan %d @ %#p\n", scan+(Reverse?-1:+1), ScanAddr);
        }

        if (!NT_SUCCESS(ValidateAddress(ScanAddr, "ScanAddr", SCAN_VALID_AT_START)))
        {
            if (!ForceDump) break;
        }

        ScanSym.addr = ScanAddr;
        error = Ioctl(IG_DUMP_SYMBOL_INFO, &ScanSym, ScanSym.size);

        if (error)
        {
            dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
            break;
        }

        cWalls1 = (ULONG)ScanFields[SCAN_CWALLS].address;

        // Update Top and Bottom information
        if (!ScanAdvance((LONG)ScanFields[SCAN_YTOP].address, (LONG)ScanFields[SCAN_YBOTTOM].address, Reverse ? cWalls2 : cWalls1))
        {
            if (!ForceDump) break;
        }


        // Read cWalls2 if we don't know it.
        if (!Reverse)
        {
            NextScanAddr = ScanAddr + ScanSize + cWalls1 * IXSize;

            if (!NT_SUCCESS(ValidateAddress(NextScanAddr, "End of Wall array", SCAN_VALID_AT_END | SCAN_VALID_NO_ERROR_PRINT)))
            {
                dprintf(" * End of Wall array @ %#p, length %u, at scan %d lies outside valid scan range\n", NextScanAddr, cWalls1, scan);
                if (!ForceDump) break;
            }

            cWalls2Sym.addr = NextScanAddr;
            cWalls2Sym.Context = &cWalls2;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &cWalls2Sym, cWalls2Sym.size);
            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }
        }

        // Check cWalls against cWalls2
        if (cWalls1 != cWalls2)
        {
            dprintf(" * cWalls (%u) != cWalls2 (%u) at scan %d\n", cWalls1, cWalls2, scan);
            Valid = FALSE;
            if (!ForceDump) break;
        }

        // cWalls is set by ScanAdvance
        if (cWalls != 0)
        {
            WallSym.Context = (PVOID)this;
            WallSym.addr = ScanFields[SCAN_AI_X_ADDR].address;
            ListWallSize.size = cWalls;
            WallFields[0].fieldCallBack = LeftWallCallback;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &WallSym, WallSym.size);

            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }

            if (!Valid && !ForceDump) break;
        }

        if (!Reverse)
        {
            if (!NT_SUCCESS(ValidateAddress(NextScanAddr, "Next ScanAddr", SCAN_VALID_AT_END)))
            {
                if (!ForceDump) break;
            }

            ScanAddr = NextScanAddr;
        }
    }

    return Valid;
}


/**************************************************************************\
*
*   ScanDumper::NextScan
*
\**************************************************************************/
BOOL
ScanDumper::NextScan(
    LONG NextTop,
    LONG NextBottom,
    ULONG NumWalls
    )
{
    LONG PrevBottom = Bottom;
    BOOL bRet = TRUE;

    scan++;

    if (scan < 0 || (ULONG)scan >= ScanLimit)
    {
        dprintf(" * Scan count %d is not in range 1 to %u\n", scan+1, ScanLimit);
        Valid = FALSE;
        bRet = FALSE;
    }

    wall = 0;
    PrevRight = NEG_INFINITY;

    cWalls = NumWalls;

    Top = NextTop;
    Bottom = NextBottom;

    if ((bRet || ForceDump) && Top < PrevBottom)
    {
        dprintf(" * Scan %d top (%d) < prev bottom (%d)\n",
                scan, Top, PrevBottom);
        Valid = FALSE;
        bRet = FALSE;
    }

    if (gbVerbose)
    {
        dprintf(" * Scan %d covers from %d to %d and has %u walls.\n", scan, Top, Bottom, cWalls);
    }

    if ((bRet || ForceDump) && Bottom < Top)
    {
        dprintf(" * Scan %d bottom (%d) < top (%d)\n",
                scan, Bottom, Top);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls > COUNT_LIMIT)
    {
        dprintf(" * cWalls (%u) is suspiciously long at scan %d\n", cWalls, scan);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls == 0 && PrintBlocks)
    {
        dprintf("\tNULL Scans from %d to %d.\n", Top, Bottom);
    }

    return bRet;
}


/**************************************************************************\
*
*   ScanDumper::PrevScan
*
\**************************************************************************/
BOOL
ScanDumper::PrevScan(
    LONG PrevTop,
    LONG PrevBottom,
    ULONG NumWalls
    )
{
    LONG NextTop = Top;
    BOOL bRet = TRUE;

    scan--;

    if (NegativeScanCount)
    {
        if (-scan < 1 || (ULONG)-scan > ScanLimit)
        {
            dprintf(" * Scan count %u is not in range 1 to %u\n", -scan, ScanLimit);
            Valid = FALSE;
            bRet = FALSE;
        }
    }
    else
    {
        if (scan < 0 || (ULONG)scan >= ScanLimit)
        {
            dprintf(" * Scan count %u is not in range 1 to %u\n", scan+1, ScanLimit);
            Valid = FALSE;
            bRet = FALSE;
        }
    }

    wall = 0;
    PrevRight = NEG_INFINITY;

    cWalls = NumWalls;

    Top = PrevTop;
    Bottom = PrevBottom;

    if ((bRet || ForceDump) && Bottom > NextTop)
    {
        dprintf(" * Scan %d bottom (%d) > next top (%d)\n",
                scan, Bottom, NextTop);
        Valid = FALSE;
        bRet = FALSE;
    }

    if (gbVerbose)
    {
        dprintf(" * Scan %d covers from %d to %d and has %u walls.\n", scan, Top, Bottom, cWalls);
    }

    if ((bRet || ForceDump) && Bottom < Top)
    {
        dprintf(" * Scan %d bottom (%d) < top (%d)\n",
                scan, Bottom, Top);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls > COUNT_LIMIT)
    {
        dprintf(" * cWalls (%u) is suspiciously long at scan %d\n", cWalls, scan);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls == 0 && PrintBlocks)
    {
        dprintf("\tNULL Scans from %d to %d.\n", Top, Bottom);
    }

    return bRet;
}


/**************************************************************************\
*
*   ScanDumper::NextLeftWall
*
\**************************************************************************/
ULONG
ScanDumper::NextLeftWall(
    LONG NextLeft
    )
{
    ULONG Status = STATUS_SUCCESS;

    if (wall > cWalls)
    {
        dprintf(" * More walls (%u) than expected (%u).\n", wall, cWalls);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    Left = NextLeft;

    if (Left <= PrevRight)
    {
        dprintf(" * Left wall %d (%d) <= previous right (%d) @ scan %d\n",
                wall, Left, PrevRight, scan);
        Valid = FALSE;
        Status = STATUS_UNSUCCESSFUL;
    }

    wall++;

    return Status;
}


/**************************************************************************\
*
*   ScanDumper::NextRightWall
*
\**************************************************************************/
ULONG ScanDumper::NextRightWall(
    LONG Right
    )
{
    ULONG Status = STATUS_SUCCESS;

    if (wall > cWalls)
    {
        dprintf(" * More walls (%u) than expected (%u).\n", wall, cWalls);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    if (Right <= Left)
    {
        dprintf(" * Right wall %d (%d) <= left (%d) @ scan %d\n",
                wall, Right, Left, scan);
        Valid = FALSE;
        Status = STATUS_UNSUCCESSFUL;
    }

    if (PrintBlocks)
    {
        dprintf("\tRectangle #%d  (%d,%d) - (%d,%d)\n",
                block, Left, Top, Right, Bottom);
    }
    else if (PrintProgress)
    {
        dprintf(".");
        if ((ProgressCount++ % 60) == 0)
        {
            dprintf("\n");
        }
    }

    wall++;
    block++;
    PrevRight = Right;

    return Status;
}


/**************************************************************************\
*
*   ScanDumper::ValidateAddress
*
\**************************************************************************/
ULONG ScanDumper::ValidateAddress(
    ULONG64     Address,
    const char *pszAddrName,
    ULONG       Flags
    )
{
    if (pszAddrName == NULL)
    {
        pszAddrName = "address";
    }

    if (gbVerbose)
    {
        dprintf(" Validating %s %#p\n", pszAddrName, Address);
    }

    // Check allocation limits
    if (Address < AddressBase)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is before address base %#p\n", pszAddrName, Address, AddressBase);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }
    if (Address > AddressLimit)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is beyond address limit %#p\n", pszAddrName, Address, AddressLimit);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    // Check head and tail limits
    if (Address < FirstScanAddr)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is before head address %#p\n", pszAddrName, Address, FirstScanAddr);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }
    if (Address > LastScanAddr)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p beyond tail address %#p\n", pszAddrName, Address, LastScanAddr);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    // Check end edge limits
    if (! (Flags & SCAN_VALID_AT_END))
    {
        if (Address == AddressLimit)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at address limit %#p\n", pszAddrName, Address, AddressLimit);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
        if (Address == LastScanAddr)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at tail address %#p\n", pszAddrName, Address, LastScanAddr);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
    }

    // Check start edge limits
    if (! (Flags & SCAN_VALID_AT_START))
    {
        if (Address == AddressBase)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at address base %#p\n", pszAddrName, Address, AddressBase);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
        if (Address == FirstScanAddr)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at head address %#p\n", pszAddrName, Address, FirstScanAddr);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
*   ScanDumper callback interfaces
*
\**************************************************************************/
ULONG
WallArrayEntryCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pScanDumper == NULL || pField == NULL)
    {
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->ValidateAddress(pField->address, "Wall @", SCAN_VALID_EXCLUSIVE);
}


ULONG
LeftWallCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pField == NULL)
    {
        dprintf(" * Error: LeftWallCallback was given NULL pField.\n");
        return STATUS_UNSUCCESSFUL;
    }

    pField->fieldCallBack = RightWallCallback;

    if (pScanDumper == NULL)
    {
        dprintf(" * Error: LeftWallCallback was given NULL pScanDumper.\n");
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->NextLeftWall((LONG)pField->address);
}


ULONG
RightWallCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pField == NULL)
    {
        dprintf(" * Error: RightWallCallback was given NULL pField.\n");
        return STATUS_UNSUCCESSFUL;
    }

    pField->fieldCallBack = LeftWallCallback;

    if (pScanDumper == NULL)
    {
        dprintf(" * Error: RightWallCallback was given NULL pScanDumper.\n");
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->NextRightWall((LONG)pField->address);
}



template <class T, int Spec>
PrintfTypeFormat<T,Spec>::PrintfTypeFormat() : PrintfFormat()
{
    ComposeFormat();
}

template <class T, int Spec>
void PrintfTypeFormat<T,Spec>::ComposeFormat()
{
    int pos = 0;

    Format[pos++] = '%';

    if (Width != -1)          
    {          
        int stored = _snprintf(&Format[pos], sizeof(Format)-5-pos, "%d", Width);
        if (stored > 0)
        {
            pos += stored;
        }
    }

    if (Spec & (PRINT_FORMAT_CHARACTER | PRINT_FORMAT_STRING))
    {
        if (Spec & PRINT_FORMAT_1BYTE)
        {
            Format[pos++] = 'h';
        }
        else if (Spec & PRINT_FORMAT_2BYTES)
        {
            Format[pos++] = 'l';
        }
        else
        {
            ExtWarn("Warning: Unknown character print size specification.\n");
        }

        if (Spec & PRINT_FORMAT_CHARACTER)
        {
            Format[pos++] = 'c';
        }
        else
        {
            Format[pos++] = 's';
        }
    }
    else if (Spec & PRINT_FORMAT_POINTER)
    {
        Format[pos++] = 'p';
    }
    else
    {
        if (Spec & PRINT_FORMAT_1BYTE)
        {
        }
        else if (Spec & PRINT_FORMAT_2BYTES)
        {
            Format[pos++] = 'h';
        }
        else if (Spec & PRINT_FORMAT_4BYTES)
        {
            Format[pos++] = 'l';
        }
        else if (Spec & PRINT_FORMAT_8BYTES)
        {
            Format[pos++] = 'I';
            Format[pos++] = '6';
            Format[pos++] = '4';
        }
        else
        {
            ExtWarn("Warning: Unknown print format size specification.\n");
        }

        if (Spec & PRINT_FORMAT_HEX)
        {
            Format[pos++] = 'x';
        }
        else if (Spec & PRINT_FORMAT_SIGNED)
        {
            Format[pos++] = 'd';
        }
        else if (Spec & PRINT_FORMAT_UNSIGNED)
        {
            Format[pos++] = 'u';
        }
        else
        {
            ExtErr("Error: Unknown print format specification.\n");
            Format[0] = 0;
            return;
        }
    }

    Format[pos] = 0;

    IsDirty = FALSE;
}


template <class T, int PrintSpec>
BOOL
ArrayDumper<T, PrintSpec>::ReadArray(
    const char * SymbolName
    )
{
    DEBUG_VALUE Addr;
    ULONG   error;

    ULONG   ArraySize;
    ULONG   ArrayLength;
    ULONG   EntrySize;

    DbgPrint("ReadArray called for %s\n", SymbolName);

    Length = 0;

    if (!GetArrayDimensions(Client, SymbolName, NULL, &ArraySize, &ArrayLength, &EntrySize) ||
        !(ArraySize > 0 && ArrayLength > 0 && EntrySize > 0)
        )
    {
        ExtErr("GetArrayDimensions failed or returned a zero value dimension for\n\t%s.\n", SymbolName);
        ExtVerb("ArraySize: %u  ArrayLength: %u  EntrySize: %u.\n",
                ArraySize, ArrayLength, EntrySize);
        return FALSE;
    }

    if (EntrySize != sizeof(T))
    {
        ExtErr("Error: %s has entries of size %u not %u as expected.\n",
                SymbolName, EntrySize, sizeof(T));
        return FALSE;
    }

    if (S_OK == g_pExtControl->Evaluate(SymbolName, DEBUG_VALUE_INT64, &Addr, NULL))
    {
        if (Addr.I64 != 0)
        {
            HANDLE hHeap = GetProcessHeap();

            if (ArrayBuffer == NULL || ArrayLength > HeapSize(hHeap, 0, ArrayBuffer))
            {
                T *NewBuffer;

                NewBuffer = (T *) ((ArrayBuffer == NULL) ?
                                   HeapAlloc(hHeap, 0, ArraySize):
                                   HeapReAlloc(hHeap, 0, ArrayBuffer, ArraySize));

                if (NewBuffer == NULL)
                {
                    ExtErr("Buffer alloc failed.\n");
                    return FALSE;
                }
                ArrayBuffer = NewBuffer;
            }

            
            if (S_OK == g_pExtData->ReadVirtual(Addr.I64, ArrayBuffer, ArraySize, NULL))
            {
                Length = ArrayLength;

                return TRUE;
            }

            ExtErr("ReadMemory at %p for %u bytes failed.\n", Addr.I64, ArrayLength);
        }
        else
        {
            ExtWarn("Symbol %s evaluated to zero.\n", SymbolName);
        }
    }
    else
    {
        ExtErr("Couldn't evalutate: %s\n", SymbolName);
    }

    return FALSE;
}



template class PrintfTypeFormat<FormatTemplate(BYTE)>;
template class PrintfTypeFormat<FormatTemplate(WORD)>;
template class PrintfTypeFormat<FormatTemplate(DWORD)>;
template class PrintfTypeFormat<FormatTemplate(DWORD64)>;

template class PrintfTypeFormat<FormatTemplate(CHAR)>;
template class PrintfTypeFormat<FormatTemplate(WCHAR)>;

template class PrintfTypeFormat<FormatTemplate(SHORT)>;
template class PrintfTypeFormat<FormatTemplate(LONG)>;
template class PrintfTypeFormat<FormatTemplate(LONG64)>;

template class PrintfTypeFormat<FormatTemplate(USHORT)>;
template class PrintfTypeFormat<FormatTemplate(ULONG)>;
template class PrintfTypeFormat<FormatTemplate(ULONG64)>;

template class PrintfTypeFormat<ULONG64, PRINT_FORMAT_POINTER>;

template class PrintfTypeFormat<char [], PRINT_FORMAT_STRING>;
template class PrintfTypeFormat<char [], PRINT_FORMAT_WSTRING>;


template class ArrayDumper<FormatTemplate(ULONG)>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\extapi.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    extapi.cxx

Abstract:

    This file contains the generic routines and initialization code
    used by the debugger extensions routines.

Author:

    Jason Hartman (JasonHa) 2000-08-18

Environment:

    User Mode

--*/

#include "precomp.hxx"

const BOOL ClientInitialized = FALSE;

PDEBUG_ADVANCED         g_pExtAdvanced;
PDEBUG_CLIENT           g_pExtClient;
PDEBUG_CONTROL          g_pExtControl;
PDEBUG_DATA_SPACES      g_pExtData;
PDEBUG_REGISTERS        g_pExtRegisters;
PDEBUG_SYMBOLS          g_pExtSymbols;
PDEBUG_SYMBOL_GROUP     g_pExtSymbolGroup;
PDEBUG_SYSTEM_OBJECTS   g_pExtSystem;


#define REF_LIMIT   100
LONG    ExtRefCount = 0;
BOOL    ExtReady = FALSE;

#define MAX_NAME                 2048


DefOutputCallbacks   *g_pDefOutputCallbacks = NULL;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Hr;
    LONG    RefCheck;
    
    // Have to have a client to start with;)
    if (Client == NULL)
    {
        return S_FALSE;
    }

    RefCheck  = InterlockedIncrement(&ExtRefCount);

    if (RefCheck > REF_LIMIT)
    {
        DbgPrint("ExtQuery has calls exceeding limit.\n");
        InterlockedDecrement(&ExtRefCount);
        return S_FALSE;
    }

    if (RefCheck > 1)
    {
        // Wait until original refencer completes setup.
        //
        // If ExtRefCount drops below RefCheck then the
        //   original referencer failed as well as any
        //   waiters who started after us.
        while (!ExtReady && ExtRefCount >= RefCheck)
            Sleep(10);

        if (ExtReady)
        {
            // Make sure the clients match
            if (g_pExtClient != Client)
            {
                InterlockedDecrement(&ExtRefCount);
                return S_FALSE;
            }
            return S_OK;
        }
    }

    // Prepare to query interfaces.
    // Make sure no one is currently cleaning up.
    while (ExtReady)
    {
        Sleep(10);
    }

    if ((Hr = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_pExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_pExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_pExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_pExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_pExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = g_pExtSymbols->CreateSymbolGroup(&g_pExtSymbolGroup)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_pExtSystem)) != S_OK)
    {
        goto Fail;
    }

    // If symbols state has changed, make sure GDI symbols are loaded.
    if (gbSymbolsNotLoaded)
    {
        SymbolLoad(Client);
    }

    g_pExtClient = Client;

    ExtReady = TRUE;
    
    return S_OK;

Fail:
    ExtRelease(TRUE);
    InterlockedDecrement(&ExtRefCount);

    return Hr;
}


// Cleans up all debugger interfaces when there are no more references.
// A cleanup will be forced if Cleanup is TRUE.
void
ExtRelease(BOOL Cleanup)
{
    // Don't decrement the count when forcing cleanup.
    if (Cleanup || InterlockedDecrement(&ExtRefCount) < 1)
    {
        DbgPrint("Cleaning up interfaces.\n");

        EXT_RELEASE(g_pExtAdvanced);
        EXT_RELEASE(g_pExtControl);
        EXT_RELEASE(g_pExtData);
        EXT_RELEASE(g_pExtRegisters);
        EXT_RELEASE(g_pExtSymbols);
        EXT_RELEASE(g_pExtSystem);
        g_pExtClient = NULL;
        ExtReady = FALSE;
    }

    return;
}


// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}


// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}


// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}


// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}



ExtApiClass::ExtApiClass(
    PDEBUG_CLIENT DbgClient
    )
{
    Client = DbgClient ? DbgClient : g_pExtClient;

    if (Client != NULL)
    {
        Client->AddRef();
    }
    else
    {
        if (GetDebugClient(&Client) != S_OK)
        {
            DbgPrint("Error: Client creation failed.\n");
            return;
        }
    }

    if (ExtQuery(Client) != S_OK)
    {
        DbgPrint("Error: Interface queries failed.\n");
        EXT_RELEASE(Client);
    }
}


ExtApiClass::~ExtApiClass()
{
    if (Client)
    {
        ExtRelease();
        EXT_RELEASE(Client);
    }
}




HRESULT
ReadSymbolData(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Symbol,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG SizeRead
    )
{
    HRESULT hr;
    ULONG64 Module;
    ULONG64 Offset;
    ULONG   TypeId;
    ULONG   TypeSize;

    if (Buffer != NULL)
    {
        RtlZeroMemory(Buffer, BufferSize);
    }

    if (SizeRead != NULL)
    {
        *SizeRead = 0;
    }

    if (Client == NULL)
    {
        return E_POINTER;
    }

    OutputControl   OutCtl(Client);
    PDEBUG_SYMBOLS  Symbols;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Symbols->GetOffsetByName(Symbol, &Offset)) == S_OK)
    {
        if ((hr = Symbols->GetSymbolTypeId(Symbol, &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &TypeSize)) == S_OK)
        {
            BufferSize = min(BufferSize, TypeSize);

            if (SessionId == CURRENT_SESSION)
            {
                hr = Symbols->ReadTypedDataVirtual(Offset, Module, TypeId, Buffer, BufferSize, SizeRead);
            }
            else
            {
                ULONG64 OffsetPhys;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             Offset,
                                             &OffsetPhys)) == S_OK)
                {
                    hr = Symbols->ReadTypedDataPhysical(OffsetPhys, Module, TypeId, Buffer, BufferSize, SizeRead);
                }
            }
        }
        else
        {
            OutCtl.OutErr("Couldn't get type info for %s; result 0x%lx.\n", Symbol, hr);
        }
    }
    else
    {
        OutCtl.OutErr("Couldn't get offset of %s; result 0x%lx.\n", Symbol, hr);
    }

    Symbols->Release();

    return hr;
}


const CHAR szNULL[] = "(null)";
DEBUG_VALUE DbgValNULL = { 0, DEBUG_VALUE_INT64 };

HRESULT
Evaluate(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Expression,
    IN ULONG DesiredType,
    IN ULONG Radix,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex,
    OUT OPTIONAL PULONG StartIndex,
    OUT OPTIONAL FLONG Flags
    )
{
    HRESULT         hr = S_FALSE;
    PDEBUG_CONTROL  Control;
    PSTR            pStr;
    BOOL            FoundNULL = FALSE;
    ULONG           OrgRadix;
    CHAR            EvalBuffer[128];
    ULONG           EvalLen;

    if (RemainderIndex != NULL) *RemainderIndex = 0;
    if (StartIndex != NULL) *StartIndex = 0;

    if (Expression == NULL ||
        Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    pStr = (PSTR)Expression;

    while (*pStr != '\n' && (isspace(*pStr) || (*pStr != '-' && ispunct(*pStr))))
    {
        if (_strnicmp(pStr, szNULL, sizeof(szNULL)-1) == 0)
        {
            FoundNULL = TRUE;
            break;
        }

        pStr++;
    }

    if (FoundNULL)
    {
        hr = Control->CoerceValue(&DbgValNULL,
                                  (DesiredType == DEBUG_VALUE_INVALID) ?
                                  DEBUG_VALUE_INT64 : DesiredType,
                                  Value);
        EvalLen = sizeof(szNULL)-1;
    }
    else
    {
        // Find expression string and only text revalent
        // to evalutating that expression.
        //
        // Otherwise IDebugControl::Evaluate will spend
        // too much time looking up values that are not
        // really part of the expression.
        //
        // IDebugControl::Evaluate also doesn't handle
        // binary strings well.  We expect binary strings
        // to be followed by a non-binary value enclosed
        // in parenthesis.  Just use that value.

        char *psz;
        int i = 0;

        while (pStr[i] != '\0' &&
               (pStr[i] == '0' || pStr[i] == '1'))
        {
            i++;
        }

        if (i &&
            pStr[i] == ' ' &&
            pStr[i+1] == '(' &&
            isdigit(pStr[i+2]))
        {
            pStr += i + 1;
        }

        psz = pStr;
        i = 0;

        if (Flags & EVALUATE_COMPACT_EXPR)
        {
            while ((i < sizeof(EvalBuffer)-1) &&
                   *psz != '\0' && !isspace(*psz))
            {
                EvalBuffer[i++] = *psz++;
            }
        }
        else
        {
            do
            {
                while ((i < sizeof(EvalBuffer)-1) &&
                       *psz != '\0' && !isspace(*psz))
                {
                    EvalBuffer[i++] = *psz++;
                }
                while ((i < sizeof(EvalBuffer)-1) &&
                    (*psz == ' ' || *psz == '\t'))
                {
                    EvalBuffer[i++] = *psz++;
                }
            } while ((i < sizeof(EvalBuffer)-1) &&
                     (ispunct(*psz) && *psz != '-' && *psz != '_' &&
                      !(psz[0] == '-' && psz[1] == '>')));

            // Remove any trailing whitespace
            while (i > 0 && isspace(EvalBuffer[i-1])) i--;
        }

        EvalBuffer[i] = '\0';

        if (Radix == 0 ||
                 ((hr = Control->GetRadix(&OrgRadix)) == S_OK &&
                  (hr = Control->SetRadix(Radix)) == S_OK)
            )
        {
//            DbgPrint("Calling Eval(%s) --\n", EvalBuffer);
            hr = Control->Evaluate(EvalBuffer, 
                                   DesiredType,
                                   Value,
                                   &EvalLen);
//            DbgPrint("-- Eval returned\n");

            if (Radix != 0)
            {
                Control->SetRadix(OrgRadix);
            }

            if (hr == S_OK &&
                Flags & EVALUATE_COMPACT_EXPR &&
                EvalLen != i)
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DbgPrint("Can't setup new radix, %lu, for Evaluate.\n", Radix);
        }
    }

    Control->Release();

    if (hr == S_OK)
    {
        if (RemainderIndex != NULL)
        {
            *RemainderIndex = (ULONG)(pStr - Expression) + EvalLen;
        }

        if (StartIndex != NULL)
        {
            *StartIndex = (ULONG)(pStr - Expression);
        }
    }

    return hr;
}



HRESULT
ReadPointerPhysical(
    PDEBUG_CLIENT Client,
    ULONG64 Offset,
    PULONG64 Ptr
    )
{
    HRESULT             hr;
    PDEBUG_CONTROL      Control;
    PDEBUG_DATA_SPACES  Data;
    DEBUG_VALUE         PtrVal;
    ULONG               BytesRead;

    if (Ptr != NULL) *Ptr = 0;

    if (Client == NULL) return E_INVALIDARG;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Client->Release();
        return hr;
    }

    if (Control->IsPointer64Bit() == S_OK)
    {
        Control->Output(DEBUG_OUTPUT_VERBOSE, "Read64PointerPhysical(0x%p)\n", Offset);

        hr = Data->ReadPhysical(Offset,
                                &PtrVal.I64,
                                sizeof(PtrVal.I64),
                                &BytesRead);
        if (hr == S_OK &&
            BytesRead != sizeof(PtrVal.I64))
        {
            Control->Output(DEBUG_OUTPUT_VERBOSE,
                            "ReadPhysicalPointer only read %lu bytes not %lu.\n",
                            BytesRead, sizeof(PtrVal.I64));
            hr = S_FALSE;
        }

        if (hr == S_OK) Control->Output(DEBUG_OUTPUT_VERBOSE, " read 0x%p\n", PtrVal.I64);
    }
    else
    {
        Control->Output(DEBUG_OUTPUT_VERBOSE, "Read32PointerPhysical(0x%p)\n", Offset);

        hr = Data->ReadPhysical(Offset,
                                &PtrVal.I32,
                                sizeof(PtrVal.I32),
                                &BytesRead);
        if (hr == S_OK)
        {
            if (BytesRead != sizeof(PtrVal.I32))
            {
                Control->Output(DEBUG_OUTPUT_VERBOSE,
                                "ReadPhysicalPointer only read %lu bytes not %lu.\n",
                                BytesRead, sizeof(PtrVal.I32));
                hr = S_FALSE;
            }
            else
            {
                Control->Output(DEBUG_OUTPUT_VERBOSE, " read 0x%p", PtrVal.I64);

                PtrVal.I64 = DEBUG_EXTEND64(PtrVal.I32);

                Control->Output(DEBUG_OUTPUT_VERBOSE, " -> 0x%I64x\n", PtrVal.I64);
            }
        }
    }

    if (hr == S_OK && Ptr != NULL)
    {
        *Ptr = PtrVal.I64;
    }

    Data->Release();
    Control->Release();

    return hr;
}


HRESULT
GetTypeId(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Type,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;

    if (Client == NULL || Type == NULL || TypeId == NULL)
    {
        return E_INVALIDARG;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if (strchr(Type, '!') == NULL &&
        Type_Module.Base != 0 &&
        (hr = Symbols->GetTypeId(Type_Module.Base, Type, TypeId)) == S_OK)
    {
        if (Module != NULL)
        {
            *Module = Type_Module.Base;
        }
    }
    else
    {
        hr = Symbols->GetSymbolTypeId(Type, TypeId, Module);
    }

    Symbols->Release();

    return hr;
}


HRESULT
GetBasicTypeSize(
    IN PCSTR Type,
    OUT PULONG Size
    )
{
    HRESULT hr;
    ULONG   Bytes = 0;

    static CHAR PointerBase[] = "Ptr";
    static CHAR Char[] = "Char";
    static CHAR IntBase[] = "Int";

    if (_strnicmp(Type, PointerBase, sizeof(PointerBase)) == 0)
    {
        Bytes = strtoul(Type+sizeof(PointerBase), NULL, 10) / 8;
    }
    else
    {
        // Remove U indicating unsigned
        if (*Type == 'U')
        {
            Type++;
        }

        if (_strnicmp(Type, Char, sizeof(Char)) == 0)
        {
            Bytes = 1;
        }
        else if (_strnicmp(Type, IntBase, sizeof(IntBase)) == 0)
        {
            PCHAR   NextChar;
            Bytes = strtoul(Type+sizeof(IntBase), &NextChar, 10);
            if (NextChar == NULL ||
                toupper(*NextChar) != 'B')
            {
                Bytes = 0;
            }
        }
    }

    if (Bytes != 0)
    {
        hr = S_OK;
        if (Size != NULL)
        {
            *Size = Bytes;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


HRESULT
GetFieldSize(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PCSTR FieldPath,
    OUT PULONG pSize,
    OUT OPTIONAL PULONG pLength,
    OUT OPTIONAL PULONG pEntrySize
    )
{
    HRESULT             hr;
    PDEBUG_CONTROL      Control;
    PDEBUG_SYMBOLS      Symbols;

    if (pSize != NULL) *pSize = 0;
    if (pLength != NULL) *pLength = 0;
    if (pEntrySize != NULL) *pEntrySize = 0;

    if (Client == NULL ||
        FieldPath == NULL ||
        !iscsymf(*FieldPath))
    {
        return E_INVALIDARG;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Client->Release();
        return hr;
    }

    OutputReader    OutReader;
    OutputState     OutState(Client, FALSE);
    PSTR            TypeLayout;
    PSTR            Field;
    SIZE_T          FieldLen;
    CHAR            FieldCopy[80];
    PCSTR           SubFieldPath;
    ULONG           Size, ArrayLen = 0;

    if ((hr = OutState.Setup(0, &OutReader)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(0,
                                         Module,
                                         TypeId,
                                         DEBUG_OUTTYPE_NO_INDENT |
                                         DEBUG_OUTTYPE_NO_OFFSET |
                                         DEBUG_OUTTYPE_COMPACT_OUTPUT)) == S_OK &&
        (hr = OutReader.GetOutputCopy(&TypeLayout)) == S_OK)
    {
        SubFieldPath = strchr(FieldPath, '.');

        if (SubFieldPath != NULL)
        {
            FieldLen = SubFieldPath - FieldPath - 1;
            SubFieldPath++;

            if (FieldLen + 1 > sizeof(FieldCopy))
            {
                Field = (PSTR)HeapAlloc(GetProcessHeap(), 0, FieldLen + 1);
                if (Field == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                Field = FieldCopy;
            }

            if (hr == S_OK)
            {
                RtlCopyMemory(Field, FieldPath, FieldLen);
                Field[FieldLen] = '\0';
            }
        }
        else
        {
            Field = (PSTR)FieldPath;
        }

        if (hr == S_OK)
        {
            PSTR    pStr = TypeLayout;
            BOOL    FieldFound = FALSE;

            while (!FieldFound && pStr != NULL)
            {
                pStr = strstr(pStr, Field);
                if (pStr != NULL)
                {
                    // Check Field is bounded by non-symbol characters
                    BOOL FieldStart = (pStr-1 < TypeLayout) || (!__iscsym(*(pStr-1)));

                    // Advance search location
                    pStr += strlen(Field);

                    if (FieldStart && !__iscsym(*pStr))
                    {
                        FieldFound = TRUE;
                    }
                }
            }

            if (FieldFound)
            {
                while (isspace(*pStr)) pStr++;

                // Check for an array
                if (*pStr == '[')
                {
                    PCHAR   EvalEnd;

                    ArrayLen = strtoul(pStr+1, &EvalEnd, 10);

                    if (ArrayLen != 0 && *EvalEnd == ']')
                    {
                        pStr = EvalEnd + 1;
                        while (isspace(*pStr)) pStr++;
                    }
                    // else following csym check will fail returning error.
                }

                if (iscsymf(*pStr))
                {
                    PSTR    FieldType = pStr;
                    ULONG   SubTypeId;

                    while (iscsym(*pStr)) pStr++;
                    *pStr = '\0';

                    hr = Symbols->GetTypeId(Module, FieldType, &SubTypeId);

                    if (SubFieldPath != NULL)
                    {
                        if (hr == S_OK)
                        {
                            hr = GetFieldSize(Client,
                                              Module,
                                              SubTypeId,
                                              SubFieldPath,
                                              pSize,
                                              pLength,
                                              pEntrySize);
                        }
                    }
                    else
                    {
                        if (hr == S_OK)
                        {
                            hr = Symbols->GetTypeSize(Module, SubTypeId, &Size);
                        }
                        else
                        {
                            if (GetBasicTypeSize(FieldType, &Size) == S_OK)
                            {
                                hr = S_OK;
                            }
                        }

                        if (hr == S_OK)
                        {
                            if (pEntrySize != NULL) *pEntrySize = Size;
                            if (pLength != NULL) *pLength = ArrayLen;
                            if (pSize != NULL)
                            {
                                if (ArrayLen != 0) Size *= ArrayLen;
                                *pSize = Size;
                            }
                        }
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }

        if (Field != NULL && Field != FieldCopy && Field != FieldPath)
        {
            HeapFree(GetProcessHeap(), 0, Field);
        }

        OutReader.FreeOutputCopy(TypeLayout);
    }

    Symbols->Release();
    Control->Release();

    return hr;
}


ULONG
DbgIntValTypeFromSize(
    ULONG Size
    )
{
    ULONG   Type;

    switch (Size)
    {
        case 1: Type = DEBUG_VALUE_INT8; break;
        case 2: Type = DEBUG_VALUE_INT16; break;
        case 4: Type = DEBUG_VALUE_INT32; break;
        case 8: Type = DEBUG_VALUE_INT64; break;
        default: Type = DEBUG_VALUE_INVALID; break;
    }
    return Type;
}

BOOL
GetArrayDimensions(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Type,
    OPTIONAL IN PCSTR Field,
    OPTIONAL OUT PULONG ArraySize,
    OPTIONAL OUT PULONG ArrayLength,
    OPTIONAL OUT PULONG EntrySize
    )
{
    HRESULT hr;
    ULONG64 Module;
    ULONG   TypeId;

    BOOL    GotDimensions = FALSE;
    ULONG   Size, ESize;

    if (ArraySize) *ArraySize = 0;
    if (ArrayLength) *ArrayLength = 0;
    if (EntrySize) *EntrySize = 0;

    if (Type == NULL)
    {
        return FALSE;
    }

    if (Field != NULL)
    {
        hr = GetTypeId(Client, Type, &TypeId, &Module);

        if (hr == S_OK)
        {
            hr = GetFieldSize(Client, Module, TypeId, Field,
                              ArraySize, ArrayLength, EntrySize);

            if (hr == S_OK) GotDimensions = TRUE;
        }
    }

    if (!GotDimensions && ExtQuery(Client) == S_OK)
    {
        ULONG   GrpIndex;
        CHAR    SymbolName[MAX_PATH];
        DEBUG_SYMBOL_PARAMETERS Array;

        _snprintf(SymbolName, sizeof(SymbolName),
                  (Field) ? "%s.%s" : Type,
                  Type, Field);

        if (g_pExtSymbolGroup->AddSymbol(SymbolName, &GrpIndex) == S_OK)
        {
            if (g_pExtSymbolGroup->GetSymbolParameters(GrpIndex, 1, &Array) == S_OK)
            {
                if (Array.SubElements)
                {
                    if (g_pExtSymbols->GetTypeSize(Array.Module, Array.TypeId, &Size) == S_OK)
                    {
                        ExtVerb(" Array %s - Size: %u bytes  Length: %u\n", SymbolName, Size, Array.SubElements);
                        if (ArraySize) *ArraySize = Size;
                        if (ArrayLength) *ArrayLength = Array.SubElements;
                        if (EntrySize) *EntrySize = Size / Array.SubElements;
                        GotDimensions = TRUE;
                    }
                    else
                    {
                        ExtErr("Couldn't get size of %s.\n", Type);
                    }
                }
                else
                {
                    ExtErr("%s has 0 subelements.\n", SymbolName);
                }
            }
            else
            {
                ExtErr("Couldn't get parameter info for %s.\n", SymbolName);
            }

            g_pExtSymbolGroup->RemoveSymbolByIndex(GrpIndex);
        }
        else
        {
            ExtErr("Couldn't lookup symbol %s.\n", SymbolName);
        }

        ExtRelease();
    }

    if (!GotDimensions)
    {
        ULONG   Index = -1;
        PCSTR   ArrayName = Field ? Field : Type;
        char    FirstEntryName[128];
        ULONG   error;

        FIELD_INFO EntrySizeField = { DbgStr(Field), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
        SYM_DUMP_PARAM ArraySym = {
           sizeof (SYM_DUMP_PARAM), DbgStr(Type), 
           DBG_DUMP_NO_PRINT, 0,
           NULL, NULL, NULL,
           (Field ? 1 : 0), &EntrySizeField
        };

        ExtVerb("Using WinDbg extension interface.\n");

        if (Field)
        {
            error = Ioctl(IG_DUMP_SYMBOL_INFO, &ArraySym, ArraySym.size);
            Size = (error) ? 0 : EntrySizeField.size;

            EntrySizeField.fName = DbgStr(FirstEntryName);
        }
        else
        {
            Size = Ioctl(IG_GET_TYPE_SIZE, &ArraySym, ArraySym.size);

            ArraySym.sName = DbgStr(FirstEntryName);
        }

        if (Size == 0)
        {
            dprintf("Array size is zero.\n");

            return FALSE;
        }

        if (ArraySize) *ArraySize = Size;

        _snprintf(FirstEntryName, sizeof(FirstEntryName), "%s[0]", ArrayName);

        if (Field)
        {
            error = Ioctl(IG_DUMP_SYMBOL_INFO, &ArraySym, ArraySym.size);
            ESize = (error) ? 0 : EntrySizeField.size;
        
            vPrintNativeSymDumpParam(&ArraySym);
        }
        else
        {
            ESize = Ioctl(IG_GET_TYPE_SIZE, &ArraySym, ArraySym.size);
        }

        if (ESize)
        {
            DbgPrint("%s dimensions: %u bytes [%u] = %u bytes.\n",
                     ArrayName, ESize, Size/ESize, Size);

            if (ArrayLength) *ArrayLength = Size/ESize;
            if (EntrySize) *EntrySize = ESize;

            GotDimensions = TRUE;
        }
    }

    return GotDimensions;
}



HRESULT
DumpType(
    PDEBUG_CLIENT Client,
    PCSTR Type,
    ULONG64 Offset,
    ULONG Flags,
    OutputControl *OutCtl,
    BOOL Physical
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   DefaultOutput;

    if (Client == NULL) return E_INVALIDARG;

    if (OutCtl == NULL)
    {
        DefaultOutput.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
        OutCtl = &DefaultOutput;
    }

    if ((hr = GetTypeId(Client, Type, &TypeId, &Module)) != S_OK)
    {
        OutCtl->OutErr(" Not a type nor symbol - HRESULT %s.\n", pszHRESULT(hr));
    }
    else
    {
        TypeOutputDumper    TypeReader(Client, OutCtl);

        if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
        {
            OutCtl->Output(" %s", Type);
            if (Offset != 0) OutCtl->Output(" @ %s0x%p", ((Physical) ? "#" : ""), Offset);
            OutCtl->Output((Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT) ? " " : ":\n");
        }

        hr = TypeReader.OutputType(Physical, Module, TypeId, Offset, Flags, NULL);
    }

    return hr;
}


HRESULT
ExtDumpType(
    IN PDEBUG_CLIENT Client,
    IN PCSTR ExtName,
    IN PCSTR Type,
    IN PCSTR Args
    )
{
    INIT_API();

    HRESULT         hr = S_OK;
    DEBUG_VALUE     Offset;

    Offset.I64 = 0;

    while (isspace(*Args)) Args++;

    if (*Args == '-' ||
        (hr = Evaluate(Client, Args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK)
    {
        if (hr != S_OK)
        {
            ExtErr("Evaluate '%s' returned %s.\n", Args, pszHRESULT(hr));
        }
        ExtOut("Usage: %s [-?] [%s Addr]\n", ExtName, Type);
    }
    else
    {
        hr = DumpType(Client, Type, Offset.I64);

        if (hr != S_OK)
        {
            ExtErr("Type Dump for %s returned %s.\n", Type, pszHRESULT(hr));
        }
    }

    EXIT_API(hr);
}


void
DumpDSP(PDEBUG_CLIENT Client, PDEBUG_SYMBOL_PARAMETERS pDSP)
{
    ExtOut("  Module Base   : %p\n", pDSP->Module);
    ExtOut("  TypeId        : %lx\n", pDSP->TypeId);
    ExtOut("  ParentSymbol  : %lx\n", pDSP->ParentSymbol);
    ExtOut("  SubElements   : %lu\n", pDSP->SubElements);
    ExtOut("  Flags         : %lx\n", pDSP->Flags);
    ExtOut("  Reserved      : %I64u\n", pDSP->Reserved);
}


DECLARE_API(dt)
{
    HRESULT                 Hr = E_INVALIDARG;
    BOOL                    VerboseInfo = FALSE;
    BOOL                    NotGDIType = FALSE;
    BOOL                    AllClients = FALSE;
    BOOL                    SessionAddr = FALSE;
    BOOL                    Physical = FALSE;
    char                    TypeSym[MAX_NAME];
    char                   *pcTypeSym = TypeSym;
    DEBUG_VALUE             Offset;
    ULONG                   Index;
    DEBUG_SYMBOL_PARAMETERS DSP;
    DEBUG_VALUE             RepeatCount = { {1}, DEBUG_VALUE_INVALID};
    ULONG                   Size = 0;

    INIT_API();

    while (isspace(*args)) args++;

    while (*args == '-')
    {
        args++;

        do
        {
            switch (tolower(*args))
            {
                case 'v': VerboseInfo = TRUE; break;
                case 's': SessionAddr = TRUE; break;
                case 'n': NotGDIType = TRUE; break;
                case 'c': AllClients = TRUE; break;
                case 'l':
                {
                    ULONG RemIndex;

                    Hr = Evaluate(Client, args+1, DEBUG_VALUE_INT32, 0, &RepeatCount, &RemIndex);

                    if (Hr == S_OK)
                    {
                        if (RepeatCount.Type == DEBUG_VALUE_INT32 &&
                            RepeatCount.I32 > 0)
                        {
                            if (RepeatCount.I32 < 512)
                            {
                                args += RemIndex;
                                break;
                            }
                            else
                            {
                                ExtErr("Array count %lu is higher than 512 limit.\n\n", RepeatCount.I32);
                            }
                        }
                        else
                        {
                            ExtErr("Invalid array count at \"%s\"\n\n", args+1);
                        }
                        Hr = E_INVALIDARG;
                    }
                    else
                    {
                        ExtErr("Missing array count.\n\n");
                    }
                }
                default:
                {
                    ExtOut("dt dumps GDI types expanding enum and flag values.\n"
                           "\n"
                           "Usage: dt [-?vsn] [-l<Count>] <Type|Symbol> [[#]Offset]\n"
                           "\n"
                           "    -v  Verbose type/symbol information\n"
                           "    -s  Lookup according to !session setting\n"
                           "    -n  Directly through debug engine\n"
                           "    -l  Dump an array of Type/Symbol Count times\n");

                    EXIT_API(*args == '?' ? S_OK : Hr);
                }
            }

            args++;

        } while (!isspace(*args) && *args != '\0');

        while (isspace(*args)) args++;
    }

    // Get Type/Symbol name from argument string
    while (*args != '\0' && !isspace(*args) &&
           (pcTypeSym < (TypeSym + sizeof(TypeSym) - 2)))
    {
        *pcTypeSym++ = *args++;
    }

    // Type/Symbols should be followed by a space or nothing
    if (*args != '\0' && !isspace(*args))
    {
        ExtErr("Invalid arguments\n");
        EXIT_API(E_INVALIDARG);
    }

    *pcTypeSym = '\0';

    while (isspace(*args))
    {
        args++;
    }

    if (*args == '#')
    {
        if (SessionAddr)
        {
            ExtErr("-s may not be combined with physical addresses.\n");
            EXIT_API(E_INVALIDARG);
        }

        Physical = TRUE;
        args++;
    }

    Offset.Type = DEBUG_VALUE_INVALID;
    Hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL);

    if (Physical && Offset.Type == DEBUG_VALUE_INVALID)
    {
        ExtErr("Invalid offset\n");
        EXIT_API(((Hr != S_OK) ? Hr : E_INVALIDARG));
    }

    if ((Hr = g_pExtSymbolGroup->AddSymbol(TypeSym, &Index)) == S_OK)
    {
        if ((Hr = g_pExtSymbolGroup->GetSymbolParameters(Index, 1, &DSP)) == S_OK)
        {
            if (VerboseInfo) DumpDSP(Client, &DSP);
        }
        else
        {
            ExtErr(" GetSymbolParameters returned error %lX.\n", Hr);
        }
        g_pExtSymbolGroup->RemoveSymbolByIndex(Index);
    }
    else
    {
        ExtVerb(" Not a symbol - Symbol lookup returned error %lX.\n", Hr);

        Hr = GetTypeId(Client, TypeSym, &DSP.TypeId, &DSP.Module);

        if (Hr == S_OK)
        {
            if (VerboseInfo)
            {
                ExtOut("  Module Base   : %p\n", DSP.Module);
                ExtOut("  TypeId        : %lx\n", DSP.TypeId);
            }
        }
        else
        {
            ExtErr(" Not a type/symbol - %s.\n", pszHRESULT(Hr));
        }
    }

    if (Hr == S_OK && VerboseInfo)
    {
        HRESULT HrCur;

        char    ModuleName[40];
        Hr = g_pExtSymbols->GetModuleNames(DEBUG_ANY_ID, DSP.Module,
                                           NULL, 0, NULL,
                                           ModuleName, sizeof(ModuleName), NULL,
                                           NULL, 0, NULL);
        if (Hr == S_OK)
        {
            ExtOut("  Module Name   : %s\n", ModuleName);
        }
        else
        {
            ExtErr(" GetModuleNames returned error %lx.\n", Hr);
        }

        ExtVerb("GetTypeName(%p, %lx)\n", DSP.Module, DSP.TypeId);
        char    TypeName[MAX_NAME];
        HrCur = g_pExtSymbols->GetTypeName(DSP.Module, DSP.TypeId,
                                           TypeName, sizeof(TypeName),
                                           NULL);
        if (HrCur == S_OK)
        {
            ExtOut("  Type Name     : %s\n", TypeName);
        }
        else
        {
            ExtErr(" GetTypeName returned error %lx.\n", HrCur);
            if (Hr == S_OK) Hr = HrCur;
        }
    }

    if (Hr == S_OK && ((RepeatCount.I32 != 1) || VerboseInfo))
    {
        Hr = g_pExtSymbols->GetTypeSize(DSP.Module, DSP.TypeId, &Size);
        if (Hr == S_OK)
        {
            if (VerboseInfo)
            {
                ExtOut("  Type Size     : %lu\n", Size);
            }

            if (RepeatCount.I32 != 1 && Size == 0)
            {
                ExtErr("Error: GetTypeSize returned size of 0.\n");
                Hr = E_FAIL;
            }
        }
        else
        {
            ExtErr(" GetTypeSize returned error %lx.\n", Hr);
        }
    }

    if (Hr == S_OK)
    {
        // Try to evaluate TypeSym for an offset if none was specified.
        if (*args == '\0' &&
            (Offset.Type == DEBUG_VALUE_INVALID ||
             (Offset.I64 == 0 && !Physical)))
        {
            Offset.Type = DEBUG_VALUE_INVALID;
            Evaluate(Client, TypeSym, DEBUG_VALUE_INT64, 0, &Offset, NULL);
        }

        if (Offset.Type == DEBUG_VALUE_INVALID)
        {
            Offset.I64 = 0;
        }
        else if (SessionAddr && SessionId != CURRENT_SESSION)
        {
            ULONG64 PhysAddr;

            Hr = GetPhysicalAddress(Client, SessionId, Offset.I64, &PhysAddr);

            if (Hr == S_OK)
            {
                Physical = TRUE;
                Offset.I64 = PhysAddr;

                if (RepeatCount.I32 != 1)
                {
                    ExtWarn("Array dumping is not supported for session dumps.\n");
                    RepeatCount.I32 = 1;
                }
            }
            else
            {
                ExtErr("Couldn't lookup 0x%p in Session %s.\n", Offset.I64, SessionStr);
            }
        }

        if (Hr == S_OK)
        {
            if (Offset.I64 == 0 && !Physical && RepeatCount.I32 != 1)
            {
                ExtWarn("No valid offset was found so array dump has been overridden.\n");
                RepeatCount.I32 = 1;
            }

            while (RepeatCount.I32 > 0 && Hr == S_OK)
            {
                if ((Offset.I64 == 0 && !Physical) || NotGDIType)
                {
                    ExtVerb("OutputTypedData(DEBUG_OUTCTL_THIS_CLIENT, 0x%p, %p, %lx, 0)\n",
                            Offset.I64, DSP.Module, DSP.TypeId);
                    if (Physical)
                    {
                        Hr = g_pExtSymbols->OutputTypedDataPhysical((AllClients ? DEBUG_OUTCTL_ALL_CLIENTS : DEBUG_OUTCTL_THIS_CLIENT),
                                                                    Offset.I64,
                                                                    DSP.Module,
                                                                    DSP.TypeId,
                                                                    0);
                    }
                    else
                    {
                        Hr = g_pExtSymbols->OutputTypedDataVirtual((AllClients ? DEBUG_OUTCTL_ALL_CLIENTS : DEBUG_OUTCTL_THIS_CLIENT),
                                                                   Offset.I64,
                                                                   DSP.Module,
                                                                   DSP.TypeId,
                                                                   0);
                    }
                }
                else
                {
                    Hr = DumpType(Client, TypeSym, Offset.I64, DEBUG_OUTTYPE_DEFAULT, NULL, Physical);
                }

                if (--RepeatCount.I32 > 0)
                {
                    Offset.I64 += Size;
                }
            }

            if (Hr != S_OK)
            {
                ExtErr("Type dump returned %s.\n", pszHRESULT(Hr));
            }
        }
    }

    EXIT_API(Hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\extparse.cxx ===
/******************************Module*Header*******************************\
* Module Name: extparse.cxx
*
* Copyright (c) 1998-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/* Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter
 * with the beginning of each token in the array.
 * It also returns the number of tokens found. 
 */
int parse_Tokenizer(char *cmdstr, char **tok) {
  char *seps=" \t\n";                  //white space separators
  int tok_count = 0;                   //the token count
  char *token = strtok(cmdstr, seps);  //get the first token
  while(token) {
    tok[tok_count++]=token;
    token = strtok(NULL, seps);
  }
  return tok_count;
}

/* This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (parse_iFindToken) 
 * but occasionally we need the case sensitive version (parse_FindToken).
 */
int parse_FindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(strcmp(tok[i], srchtok)==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

int parse_iFindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(_strnicmp(tok[i], srchtok, strlen(srchtok))==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* Verifies that the given token at tok[tok_pos] is a switch
 * and contains the switch value sw.
 *
 * Both case sensitive and insensitive versions.
 */
int parse_iIsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(toupper(*s)==toupper(sw)) {return 1;}
    }
  }
  return 0;
}

int parse_IsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(*s==sw) {return 1;}      //search each char
    }
  }
  return 0;
}

/* Finds a switch in a given list of tokens.
 * of the form -xxx(sw)xxx or /xxx(sw)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 */
int parse_FindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {                          //search each token
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}

int parse_iFindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}


/* Find the first non-switch token starting from position start
 * Will find token at position start
 */
int parse_FindNonSwitch(char **tok, int ntok, int start) {
  for(int i=start; i<ntok; i++) {
    if((tok[i][0]!='-')&&(tok[i][0]!='/')) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* case insensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 */
int parse_iIsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (_strnicmp(tok[tok_pos], chk, strlen(chk))==0);
}

/* case sensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 */
int parse_IsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (strcmp(tok[tok_pos], chk)==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\fontexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontexts.cxx
*
* Created: 29-Aug-1994 08:42:10
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// TODO: Break this file up grouping close knit extensions together.

// LOGFONTW
#define GetLOGFONTWField(field)   \
        GetLOGFONTWSubField(#field, field)

#define GetLOGFONTWSubField(field,local)    \
        GetFieldData(offLOGFONTW, GDIType(LOGFONTW), field, sizeof(local), &local)

#define GetLOGFONTWOffset(field)  \
        GetFieldOffset(GDIType(LOGFONTW), #field, &offset)

#define GetLOGFONTWFieldAndOffset(field) {    \
        GetLOGFONTWField(field);              \
        GetLOGFONTWOffset(field);             \
}

// RFONT
#define GetRFONTField(field)   \
        GetRFONTSubField(#field, field)

#define GetRFONTSubField(field,local)    \
        GetFieldData(foSrc, GDIType(RFONT), field, sizeof(local), &local)

#define GetRFONTOffset(field)  \
        GetFieldOffset(GDIType(RFONT), #field, &offset)

#define GetRFONTFieldAndOffset(field) {    \
        GetRFONTField(field);              \
        GetRFONTOffset(field);             \
}

// FONTOBJ
#define GetFONTOBJField(field)   \
        GetFONTOBJSubField(#field, field)

#define GetFONTOBJSubField(field,local)    \
        GetFieldData(foSrc, GDIType(FONTOBJ), field, sizeof(local), &local)

#define GetFONTOBJOffset(field)  \
        GetFieldOffset(GDIType(FONTOBJ), #field, &offset)

#define GetFONTOBJFieldAndOffset(field) {    \
        GetFONTOBJField(field);              \
        GetFONTOBJOffset(field);             \
}

// PFE
#define GetPFEField(field)   \
        GetPFESubField(#field, field)

#define GetPFESubField(field,local)    \
        GetFieldData(pfeSrc, GDIType(PFE), field, sizeof(local), &local)

#define GetPFEOffset(field)  \
        GetFieldOffset(GDIType(PFE), #field, &offset)

#define GetPFEFieldAndOffset(field) {    \
        GetPFEField(field);              \
        GetPFEOffset(field);             \
}

// IFIMETRICS
#define GetIFIMETRICSField(field)   \
        GetIFIMETRICSSubField(#field, field)

#define GetIFIMETRICSSubField(field,local)    \
        GetFieldData(pifiSrc, GDIType(IFIMETRICS), field, sizeof(local), &local)

#define GetIFIMETRICSOffset(field)  \
        GetFieldOffset(GDIType(IFIMETRICS), #field, &offset)

#define GetIFIMETRICSFieldAndOffset(field) {    \
        GetIFIMETRICSField(field);              \
        GetIFIMETRICSOffset(field);             \
}

// PFF
#define GetPFFField(field)   \
        GetPFFSubField(#field, field)

#define GetPFFSubField(field,local)    \
        GetFieldData(pffSrc, GDIType(PFF), field, sizeof(local), &local)

#define GetPFFOffset(field)  \
        GetFieldOffset(GDIType(PFF), #field, &offset)

#define GetPFFFieldAndOffset(field) {    \
        GetPFFField(field);              \
        GetPFFOffset(field);             \
}

// ESTROBJ
#define GetESTROBJField(field)   \
        GetESTROBJSubField(#field, field)

#define GetESTROBJSubField(field,local)    \
        GetFieldData(estrobjSrc, GDIType(ESTROBJ), field, sizeof(local), &local)

#define GetESTROBJOffset(field)  \
        GetFieldOffset(GDIType(ESTROBJ), #field, &offset)

#define GetESTROBJFieldAndOffset(field) {    \
        GetESTROBJField(field);              \
        GetESTROBJOffset(field);             \
}

// GLYPHPOS
#define GetGLYPHPOSField(field)   \
        GetGLYPHPOSSubField(#field, field)

#define GetGLYPHPOSSubField(field,local)    \
        GetFieldData(glyphposSrc, GDIType(GLYPHPOS), field, sizeof(local), &local)

#define GetGLYPHPOSOffset(field)  \
        GetFieldOffset(GDIType(GLYPHPOS), #field, &offset)

#define GetGLYPHPOSFieldAndOffset(field) {    \
        GetGLYPHPOSField(field);              \
        GetGLYPHPOSOffset(field);             \
}


// GLYPHBITS
#define GetGLYPHBITSField(field)   \
        GetGLYPHBITSSubField(#field, field)

#define GetGLYPHBITSSubField(field,local)    \
        GetFieldData(glyphbitsSrc, GDIType(GLYPHBITS), field, sizeof(local), &local)

#define GetGLYPHBITSOffset(field)  \
        GetFieldOffset(GDIType(GLYPHBITS), #field, &offset)

#define GetGLYPHBITSFieldAndOffset(field) {    \
        GetGLYPHBITSField(field);              \
        GetGLYPHBITSOffset(field);             \
}

// GLYPHDEF
#define GetGLYPHDEFField(field)   \
        GetGLYPHDEFSubField(#field, field)

#define GetGLYPHDEFSubField(field,local)    \
        GetFieldData(glyphdefSrc, GDIType(GLYPHDEF), field, sizeof(local), &local)

#define GetGLYPHDEFOffset(field)  \
        GetFieldOffset(GDIType(GLYPHDEF), #field, &offset)

#define GetGLYPHDEFFieldAndOffset(field) {    \
        GetGLYPHDEFField(field);              \
        GetGLYPHDEFOffset(field);             \
}

// CACHE
#define GetCACHEField(field)   \
        GetCACHESubField(#field, field)

#define GetCACHESubField(field,local)    \
        GetFieldData(cacheSrc, GDIType(CACHE), field, sizeof(local), &local)

#define GetCACHEOffset(field)  \
        GetFieldOffset(GDIType(CACHE), #field, &offset)

#define GetCACHEFieldAndOffset(field) {    \
        GetCACHEField(field);              \
        GetCACHEOffset(field);             \
}

DWORD adw[4*1024];                // scratch buffer

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64

#include <winfont.h>
#define WOW_EMBEDING 2


VOID Gdidpft(PFT *);

void vDumpFONTHASH(FONTHASH*,FONTHASH*);
void vDumpCOLORADJUSTMENT(COLORADJUSTMENT*, COLORADJUSTMENT*);
void vDumpLINEATTRS(LINEATTRS*, LINEATTRS*);
void vDumpIFIMETRICS(IFIMETRICS*, IFIMETRICS*);
void vDumpPFF(PFF*, PFF*);
void vDumpGlyphMemory(RFONT*);
unsigned cjGLYPHBITS(GLYPHBITS*, RFONT*);
void vDumpRFONTList(RFONT*,unsigned*,unsigned*,unsigned*,unsigned*);

#endif  // DOES NOT SUPPORT API64

void vDumpLOGFONTW(ULONG64);
void vDumpCACHE(ULONG64);

#define tmalloc(a,b) (a *) LocalAlloc(LMEM_FIXED, (b))
#define tfree(b) LocalFree((b))


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   wcsncpy
*
* Routine Description:
*
*   Copies a zero terminated Unicode from the source on the remote
*   address space to a destination in the local address space.
*
* Arguments:
*
*   pwszDst - local address
*
*   pwszSrc - remote address
*
*   c - maximum count of characters in destination
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

LPWSTR wcsncpy(
    LPWSTR  pwszDst,
    ULONG64 pwszSrc,
    size_t  c)
{
    LPWSTR pwszRet = pwszDst;
    ULONG  cbRead;

    if (c)
    {
        WCHAR wc;
        
        __try {
            ReadMemory( pwszSrc, &wc, sizeof(wc), &cbRead );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return(NULL);
        }

        while (wc && c && cbRead) {
            pwszSrc += sizeof(wc);
            *pwszDst++ = wc;
            ReadMemory( pwszSrc, &wc, sizeof(wc), &cbRead );
            --c;
        }

        // Add trailing 0 if we have room.
        if (c)
            *pwszDst = 0;
    }

    return(pwszRet);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpHFONT
*
\**************************************************************************/

void vDumpHFONT(ULONG64 hf)
{
    ULONG64     pobj, plfwSrc;
    ULONG       offset;

    if (GetObjectAddress(NULL,hf,&pobj) != S_OK) return;
    GetFieldOffset("LFONT", "elfw", &offset);
    plfwSrc = pobj + offset;

    vDumpLOGFONTW(plfwSrc);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   tstats
*
* Routine Description:
*
*   Returns statistics for TextOut
*   It gives you the distibution of character counts for
*   GreExtTextOutW calls.
*
\**************************************************************************/

DECLARE_API( tstats )
{
    dprintf("Extension 'tstats' not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    typedef struct _TSTATENTRY {
        int c;         // number observed
    } TSTATENTRY;
    typedef struct _TSTAT {
        TSTATENTRY NO; // pdx == 0, opaque
        TSTATENTRY DO; // pdx != 0, opaque
        TSTATENTRY NT; // pdx == 0, transparent
        TSTATENTRY DT; // pdx != 0, transparent
    } TSTAT;
    typedef struct _TEXTSTATS {
        int cchMax;
        TSTAT ats[1];
    } TEXTSTATS;
    TEXTSTATS *pTS, TS;
    TSTAT *ats, *pts, *ptsBin;
    int cj, binsize, cLast, cMin, cNO, cDO, cNT, cDT, cBins;

    PARSE_ARGUMENTS(tstats_help);
    if(ntok==0) {
      binsize=1;
    } else {
      tok_pos = parse_FindNonSwitch(tokens, ntok);
      if(tok_pos==-1) { goto tstats_help; }
//check this and see if it makes more sense to use GetValue() or GetExpression()
      sscanf(tokens[tok_pos], "%d", &binsize);
      if( (binsize<0) || (binsize>50) ) { goto tstats_help; }
    }

    pTS = 0;
    GetAddress(pTS,"win32k!gTS");
    if (pTS == 0) {
        dprintf("Could not find address of win32k!gTS\n");
        return;
    }
    move2(&TS,pTS,sizeof(TS));
    if (TS.ats == 0) {
        dprintf("No statistics are available\n");
        return;
    }
    cj = (TS.cchMax + 2) * sizeof(TSTAT);
    if (!(ats = tmalloc(TSTAT,cj))) {
        dprintf("memory allocation failure\n");
        return;
    }
    move2(ats, &(pTS->ats), cj);
    dprintf("\n\n\n");
    dprintf(" +------------+------ OPAQUE -------+----- TRANSPARENT ---+\n");
    dprintf(" |  strlen    | pdx == 0 | pdx != 0 | pdx == 0 | pdx != 0 |\n");
    dprintf(" +------------+----------+----------+----------+----------+\n");

    // I will partition TS.cchMax+2 entries into bins with
    // binsize enties each. The total number of bins needed
    // to get everything is ceil((TS.cchMax+2)/binsize)
    // which is equal to floor((TS.cchMax+1)/binsize) + 1
    // The last one is dealt with separately. Thus the number
    // of entries in the very last bin is equal to
    //
    // cLast = TS.cchMax + 2 - (floor((TS.cchMax+1)/binsize)+1)
    //
    // which is equal to 1 + (TS.cchMax+1) mod binsize

    cLast = 1 + ((TS.cchMax + 1) % binsize);
    for (cMin=0,pts=ptsBin=ats; pts<ats+(TS.cchMax+2-cLast); cMin+=binsize) {
        ptsBin += binsize;
        for (cNO=cDO=cNT=cDT=0 ; pts < ptsBin ; pts++) {
            cNO += pts->NO.c;
            cDO += pts->DO.c;
            cNT += pts->NT.c;
            cDT += pts->DT.c;
        }
        if (binsize == 1)
            dprintf(
                "         %-5d %10d %10d %10d %10d\n" ,
                cMin,   cNO,   cDO,   cNT,   cDT
            );
        else
            dprintf(
                "  %5d--%-5d %10d %10d %10d %10d\n" ,
                cMin, cMin+binsize-1, cNO, cDO, cNT, cDT
            );
    }
    // do the last bin which may or may not be full
    for (cNO=cDO=cNT=cDT=0 ; cLast ; cLast--, pts++) {
       cNO += pts->NO.c;
       cDO += pts->DO.c;
       cNT += pts->NT.c;
       cDT += pts->DT.c;
    }
    dprintf("  %5d--Inf   %10d %10d %10d %10d\n\n\n",cMin,cNO,cDO,cNT,cDT);
    tfree(ats);
    return;

tstats_help:
    dprintf("Usage: tstats [-?] [1..50]\n");
    dprintf("tstats can be used without parameters in which case the binsize defaults to 1\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gs
*
* Routine Description:
*
*   dumps FD_GLYPHSET structure
*
* Arguments:
*
*   address of structure
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( gs )
{
    dprintf("Extension 'gs' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FD_GLYPHSET fdg, *pfdg;
    FLONG fl;
    WCRUN *pwc;
    unsigned BytesPerHandle, i;
    unsigned u;
    HANDLE *ph, *phLast;
    FLAGDEF *pfd;

    PARSE_POINTER(gs_help);
    move( fdg, arg );
    if (fdg.cjThis > sizeof(adw))
    {
        dprintf("FD_GLYPHSET table too big to fit into adw\n");
        return;
    }
    move2( adw, arg, fdg.cjThis );
    pfdg = (FD_GLYPHSET*) adw;


    dprintf("\t\t     cjThis  = %u = %-#x\n", pfdg->cjThis, pfdg->cjThis );
    dprintf("\t\t     flAccel = %-#x\n", pfdg->flAccel );
    fl = pfdg->flAccel;
    for (pfd=afdGS; pfd->psz; pfd++)
    {
        if (pfd->fl & fl)
            dprintf("\t\t\t       %s\n", pfd->psz);
        fl &= ~pfd->fl;
    }
    if (fl) dprintf("\t\t\t       %-#x (BAD FLAGS)\n", fl);
    dprintf("\t\t     cGlyphsSupported = %u\n", pfdg->cGlyphsSupported );
    dprintf("\t\t     cRuns   = %u\n", pfdg->cRuns );
    dprintf("\t\t\t\tWCHAR  HGLYPH\n");

    if ( pfdg->flAccel & GS_UNICODE_HANDLES )
        BytesPerHandle = 0;
    else
        BytesPerHandle = 4;

    for ( pwc = pfdg->awcrun; pwc < pfdg->awcrun + pfdg->cRuns; pwc++ )
    {
        dprintf("                                ------------\n");
        ph = (HANDLE*)((BYTE*) pwc->phg + (UINT_PTR) adw - (unsigned) arg);
        phLast = ph + pwc->cGlyphs;
        i = (unsigned) pwc->wcLow;
        for ( ; ph < phLast; i++, ph++ )
        {
            if (CheckControlC())                // CTRL-C hit?
                break;                          // yes stop the loop
            u = BytesPerHandle ? (ULONG)(UINT_PTR) *ph : i;
            dprintf("\t\t\t\t%-#6x %-#x\n",i,u);
        }
    }
    return;
gs_help:
    dprintf ("Usage: gs [-?] pointer to FD_GLYPHSET structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gdata
*
* Routine Description:
*
*   dumps a GLYPHDATA structure
*
* Arguments:
*
* address of structure
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( gdata )
{
    dprintf("Extension 'gdata' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHDATA gd, *pgd;
    LONG *al;

    PARSE_POINTER(gdata_help);
    move( gd, arg );
    pgd = (GLYPHDATA*) arg;
    dprintf("\n\n");
    dprintf("[%x]         gdf %-#x\n", &(pgd->gdf), gd.gdf.pgb);
    dprintf("[%x]          hg %-#x\n", &(pgd->hg ), gd.hg);
    dprintf("[%x]         fxD %-#x\n", &(pgd->fxD), gd.fxD);
    dprintf("[%x]         fxA %-#x\n", &(pgd->fxA), gd.fxA);
    dprintf("[%x]        fxAB %-#x\n", &(pgd->fxAB), gd.fxAB);
    dprintf("[%x]    fxInkTop %-#x\n", &(pgd->fxInkTop), gd.fxInkTop);
    dprintf("[%x] fxInkBottom %-#x\n", &(pgd->fxInkBottom), gd.fxInkBottom);
    dprintf("[%x]      rclInk %d %d %d %d\n",
        &(pgd->rclInk),
        gd.rclInk.left,
        gd.rclInk.top,
        gd.rclInk.right,
        gd.rclInk.bottom
    );
    al = (LONG*) &gd.ptqD.x;
    dprintf("[%x]        ptqD % 8x.%08x % 8x.%08x\n",
        &(pgd->ptqD),
        al[1], al[0], al[3], al[2]
    );
    dprintf("\n");
    return;
gdata_help:
    dprintf ("Usage: gdata [-?] pointer to a GLYPHDATA structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( fv )
{
    dprintf("Extension 'fv' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FILEVIEW fv, *pfv;
    
    PARSE_POINTER(fv_help);
    move( fv, arg );
    pfv = (FILEVIEW*) arg;
    dprintf("\n");
    dprintf("[%x] LastWriteTime %08x%08x\n", &(pfv->LastWriteTime), fv.LastWriteTime.HighPart, fv.LastWriteTime.LowPart);
    dprintf("[%x]       pvKView %-#x\n"    , &(pfv->pvKView), fv.pvKView);
    dprintf("[%x]      pvViewFD %-#x\n"    , &(pfv->pvViewFD), fv.pvViewFD);
    dprintf("[%x]        cjView %-#x\n"    , &(pfv->cjView), fv.cjView);
    dprintf("[%x]      pSection %-#x\n"    , &(pfv->pSection), fv.pSection);
    dprintf("\n");
    return;
fv_help:
    dprintf ("Usage: fv [-?] pointer to a FILEVIEW structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( ffv )
{
    dprintf("Extension 'ffv' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FONTFILEVIEW ffv, *pffv;
    PWSZ pwszDest;

    PARSE_POINTER(ffv_help);
    move( ffv, arg );
    pffv = (FONTFILEVIEW*) arg;
    dprintf("\n");
    dprintf("[%x]    LastWriteTime %08x%08x\n", &pffv->fv.LastWriteTime , ffv.fv.LastWriteTime.HighPart, ffv.fv.LastWriteTime.LowPart);
    dprintf("[%x]          pvKView %-#x\n"    , &pffv->fv.pvKView       , ffv.fv.pvKView    );
    dprintf("[%x]         pvViewFD %-#x\n"    , &pffv->fv.pvViewFD      , ffv.fv.pvViewFD  );
    dprintf("[%x]           cjView %-#x\n"    , &pffv->fv.cjView        , ffv.fv.cjView    );
    dprintf("[%x]         pSection %-#x\n"    , &pffv->fv.pSection      , ffv.fv.pSection  );

    dprintf("[%x]         pwszPath %-#x"      , &pffv->pwszPath         , ffv.pwszPath     );
    if ( ffv.pwszPath )
    {
        pwszDest = wcsncpy((PWSZ) adw,  ffv.pwszPath, sizeof(adw)/sizeof(WCHAR));
        dprintf(" = \"%ws\"\n", pwszDest );
    }
    else
    {
        dprintf("\n");
    }

    dprintf("[%x]     ulRegionSize %-#x\n"    , &pffv->ulRegionSize     , ffv.ulRegionSize );
    dprintf("[%x]       cKRefCount %-#x\n"    , &pffv->cKRefCount       , ffv.cKRefCount   );
    dprintf("[%x]      cRefCountFD %-#x\n"    , &pffv->cRefCountFD      , ffv.cRefCountFD  );
    dprintf("[%x]      SpoolerBase %-#x\n"    , &pffv->SpoolerBase      , ffv.SpoolerBase  );
    dprintf("[%x]       SpoolerPid %-#x\n"    , &pffv->SpoolerPid       , ffv.SpoolerPid   );
    dprintf("\n");
    return;
ffv_help:
    dprintf ("Usage: ffv [-?] pointer to a FONTFILEVIEW structure\n");
    return;
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( elf )
{
    dprintf("Extension 'elf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LOGFONTW lf;

    PARSE_POINTER(elf_help);
    move(lf,arg);
    vDumpLOGFONTW( &lf, (LOGFONTW*) arg );
    return;
elf_help:
    dprintf ("Usage: elf [-?] pointer to an LOGFONTW structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( helf )
{
    dprintf("Extension 'helf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LOGFONTW lf, *plf;

    PARSE_POINTER(helf_help);
    plf = (LOGFONTW*) ((BYTE*)_pobj((HANDLE) arg) + offsetof(LFONT,elfw));
    move( lf , plf );
    vDumpLOGFONTW( &lf, plf );
    return;
helf_help:
    dprintf ("Usage: helf [-?] font handle\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dhelf
*
\**************************************************************************/

DECLARE_API( dhelf )
{
    dprintf("Extension 'dhelf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\ngdikdx.dhelf will soon be replaced by gdikdx.helf\n\n");
    helf(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ifi
*
\**************************************************************************/

DECLARE_API( ifi )
{
    dprintf("Extension 'ifi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    IFIMETRICS *pifiDst, *pifiSrc;
    ULONG cjIFI=0;

    PARSE_POINTER(ifi_help);
    pifiSrc = (IFIMETRICS *)arg;
    move(cjIFI,&pifiSrc->cjThis);
    if (cjIFI == 0) {
        dprintf("cjIFI == 0 ... no dump\n");
        return;
    }
    pifiDst = tmalloc(IFIMETRICS, cjIFI);
    if (pifiDst == 0) {
        dprintf("LocalAlloc Failed\n");
        return;
    }
    move2(pifiDst, pifiSrc, cjIFI);
    vDumpIFIMETRICS(pifiDst, pifiSrc);
    tfree(pifiDst);
    return;
ifi_help:
    dprintf ("Usage: [-?] pointer to an IFIMETRICS structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   difi
*
\**************************************************************************/

DECLARE_API( difi )
{
    dprintf("Extension 'difi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\n");
    dprintf("WARNING gdikdx.difi will soon be replaced by gdikdx.ifi\n");
    dprintf("\n\n");
    ifi(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bParseDbgFlags
*
* Routine Description:
*
*   Looks at a flag string of the form
*
*       -[abc..]*[ \t]
*
*   and and sets the corresponding flags
*
* Arguments:
*
*   pszFlags            pointer to the flags string
*
*   ppszStop            pointer to place to put a pointer
*                       to the terminating character
*
*   pai                 pointer to an ARGINFO structure
*
*
* Return Value:
*
*   Returns TRUE if all the flags were good. The corresponding flags are
*   set in pai->fl. Returns FALSE if an error occurs. The pointer to
*   the terminating character is set.
*
\**************************************************************************/
/*
int bParseDbgFlags(const char *pszFlags, const char **ppchStop, ARGINFO *pai)
{
    char ch;
    const char *pch;
    OPTDEF *pod;

    pch = pszFlags;                              // go to beginning of string
    pch += (*pch == '-' || *pch == '/');         // first char a '-'?
    for (ch = *pch; !isspace(ch); ch = *pch++) { // character not a space?
        for (pod = pai->aod; pod->ch; pod++) {   // yes, go to start of table
            if (ch == pod->ch) {                 // found character?
                pai->fl |= pod->fl;              // yes, set flag
                break;                           // and stop
            }
        }                                        // go to next table entry
        if (pod->ch == 0)                        // charater found in table?
            return(0);                           // no, return error
    }                                            // go to next char in string
    return((*ppchStop = pch) != pszFlags);       // set stop pos'n and return
}
*/
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bParseDbgArgs
*
* Routine Description:
*
*   This routine parses the argument string pointer in pai looking
*   for a string of the form:
*
*   [ \t]*(-[abc..]*[ \t]+)* hexnumber
*
*   The value of the hexadecimal number is placed in pai->pv and the
*   flags are set in pai->fl according to the options table set
*   in pai->aod;
*
* Arguments:
*
*   pai                 Pointer to an ARGINFO structure
*
* Return Value:
*
*   Returns TRUE if parsing was good, FALSE otherwise.
*
\**************************************************************************/
/*
int bParseDbgArgs(ARGINFO *pai)
{
    int argc;       // # args in command line
    char ch;
    const char *pch;
    int bInArg;
    int bParseDbgFlags(const char*,const char**,ARGINFO*);

    pai->fl = 0;                                // clear flags
    pai->pv = 0;                                // clear pointer
    for (bInArg=0, pch=pai->psz, argc=0; ch = *pch; pch++) {
        if (isspace(ch))                        // count the number of args
            bInArg = 0;
        else {
            argc += (bInArg == 0);
            bInArg = 1;
        }
    }
    for (pch = pai->psz; 1 < argc; argc--) {    // get the flags from the
        if (!bParseDbgFlags(pch, &pch, pai))    // first (argc-1) arguments
            break;
    }
    // get the number from the last argument in command line
    return (argc == 1 && sscanf(pch, "%x", &(pai->pv)) == 1);
}
*/
/******************************Public*Routine******************************\
*
* History:
*  20-Aug-1995 -by  Kirk Olynyk [kirko]
* Now has option flags.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( fo )
{
    INIT_API();

    ULONG64     foSrc;
    ULONG       offset;
    ULONG       localULONG;
    
    char *psz, ach[128];
    int i;

    BOOL Maximal=FALSE;
    BOOL Transform=FALSE;
    BOOL Font=FALSE;
    BOOL Header=FALSE;
    BOOL Glyphset=FALSE;
    BOOL Memory=FALSE;
    BOOL Cache=FALSE;

    PARSE_POINTER(fo_help);
	foSrc = arg;

    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) {Maximal=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'x')!=-1) {Transform=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {Font=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'c')!=-1) {Cache=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'w')!=-1) {Glyphset=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'y')!=-1) {Memory=TRUE;}

    if(!(Maximal||Transform||Font||Cache||Header||Glyphset||Memory)) {Header=TRUE;}

    
#define Dprint(expr, member)  \
      dprintf("[0x%p] " #expr "    " #member "\n", foSrc+offset, ##member)

    #define vDumpFoEFLOAT(member)                                            \
        GetFieldOffset(GDIType(RFONT), #member, &offset);                       \
        sprintEFLOAT(Client, ach, foSrc+offset);                             \
        dprintf("[0x%p]            %s    " #member "\n", foSrc+offset, ach)

    #define vDumpFoULONG(member)                                            \
        GetFieldOffset(GDIType(RFONT), #member, &offset);                       \
        GetRFONTSubField(#member,localULONG); \
        dprintf("[0x%p] %20u      " #member "\n", foSrc+offset, localULONG)

    if(Maximal) {Header=TRUE;}

    if (Header) {
        FLONG fl;
		ULONG      iUniq;
		ULONG      iFace;
		ULONG      cxMax;
		FLONG      flFontType;
		ULONG64    iTTUniq;
		ULONG64    iFile;
		SIZE       sizLogResPpi;
		ULONG      ulStyleSize;
		ULONG64      pvConsumer;
		ULONG64      pvProducer;

		GetFONTOBJFieldAndOffset(iUniq);
        Dprint( %+#20x, iUniq);
		GetFONTOBJFieldAndOffset(iFace);
        Dprint( %+#20x, iFace);
		GetFONTOBJFieldAndOffset(cxMax);
        Dprint( %20d  , cxMax);
		GetFONTOBJFieldAndOffset(flFontType);
        Dprint( %+#20x, flFontType);
        for (FLAGDEF *pfd = afdFO; pfd->psz; pfd++)
            if (pfd->fl & flFontType)
                dprintf(" \t\t%s\n", pfd->psz);
		GetFONTOBJFieldAndOffset(iTTUniq);
        Dprint( %+#20p, iTTUniq);
		GetFONTOBJFieldAndOffset(iFile);
        Dprint( %+#20p, iFile);
		GetFONTOBJFieldAndOffset(sizLogResPpi.cx);
        Dprint( %20u  , sizLogResPpi.cx);
		GetFONTOBJFieldAndOffset(sizLogResPpi.cy);
        Dprint( %20u  , sizLogResPpi.cy);
		GetFONTOBJFieldAndOffset(ulStyleSize);
        Dprint( %20u  , ulStyleSize);
		GetFONTOBJFieldAndOffset(pvConsumer);
        Dprint( %+#20p, pvConsumer);
		GetFONTOBJFieldAndOffset(pvProducer);
        Dprint( %+#20p, pvProducer);
    }

    if (Maximal) {

typedef struct _RFONTLINK { /* rfl */
    ULONG64 prfntPrev;
    ULONG64 prfntNext;
} RFONTLINK, *PRFONTLINK;


typedef struct _CACHE {

// Info for GLYPHDATA portion of cache

    ULONG64 pgdNext;         // ptr to next free place to put GLYPHDATA
    ULONG64 pgdThreshold;    // ptr to first uncommited spot
    ULONG64      pjFirstBlockEnd; // ptr to end of first GLYPHDATA block
    ULONG64 pdblBase;        // ptr to base of current GLYPHDATA block
    ULONG      cMetrics;        // number of GLYPHDATA's in the metrics cache

// Info for GLYPHBITS portion of cache

    ULONG     cjbblInitial;     // size of initial bit block
    ULONG     cjbbl;            // size of any individual block in bytes
    ULONG     cBlocksMax;       // max # of blocks allowed
    ULONG     cBlocks;          // # of blocks allocated so far
    ULONG     cGlyphs;          // for statistical purposes only
    ULONG     cjTotal;          // also for stat purposes only
    ULONG64 pbblBase;         // ptr to the first bit block (head of the list)
    ULONG64 pbblCur;          // ptr to the block containing next
    ULONG64     pgbNext;          // ptr to next free place to put GLYPHBITS
    ULONG64     pgbThreshold;     // end of the current block

// Info for lookaside portion of cache

    ULONG64           pjAuxCacheMem;  // ptr to lookaside buffer, if any
    SIZE_T          cjAuxCacheMem;  // size of current lookaside buffer

// Miscellany

    ULONG cjGlyphMax;          // size of largest glyph

//  Type of metrics being cached

    BOOL   bSmallMetrics;

// binary cache search, used mostly for fe fonts

    INT iMax;
    INT iFirst;
    INT cBits;

} CACHE;

    ULONG           iUnique;        // uniqueness number
    FLONG           flType;         // Cache type -
    ULONG           ulContent;      // Type of contents
    ULONG64            hdevProducer;   // HDEV of the producer of font.
    BOOL            bDeviceFont;    // TRUE if realization of a device specific font
    ULONG64            hdevConsumer;   // HDEV of the consumer of font.
    ULONG64          dhpdev;         // device handle of PDEV of the consumer of font
    ULONG64         ppfe;           // pointer to physical font entry
    ULONG64         pPFF;           // point to physical font file
    FD_XFORM        fdx;            // N->D transform used to realize font
    ULONG           cBitsPerPel;    // number of bits per pel
//    MATRIX          mxWorldToDevice;// RFONT was realized with this DC xform
    INT             iGraphicsMode;  // graphics mode used when
//    EPOINTFL        eptflNtoWScale; // baseline and ascender scaling factors --
    BOOL            bNtoWIdent;     // TRUE if Notional to World is identity
//    EXFORMOBJ       xoForDDI;       // notional to device EXFORMOBJ
//    MATRIX          mxForDDI;       // xoForDDI's matrix
    FLONG           flRealizedType;
    POINTL          ptlUnderline1;
    POINTL          ptlStrikeOut;
    POINTL          ptlULThickness;
    POINTL          ptlSOThickness;
    LONG            lCharInc;
    FIX             fxMaxAscent;
    FIX             fxMaxDescent;
    FIX             fxMaxExtent;
    POINTFIX        ptfxMaxAscent;
    POINTFIX        ptfxMaxDescent;
    ULONG           cxMax; // width in pels of the widest glyph
    LONG            lMaxAscent;
    LONG            lMaxHeight;
    ULONG cyMax;      // did not use to be here
    ULONG cjGlyphMax; // (cxMax + 7)/8 * cyMax, or at least it should be
    FD_XFORM  fdxQuantized;
    LONG      lNonLinearExtLeading;
    LONG      lNonLinearIntLeading;
    LONG      lNonLinearMaxCharWidth;
    LONG      lNonLinearAvgCharWidth;
    ULONG           ulOrientation;
//    EPOINTFL        pteUnitBase;
//    EFLOAT          efWtoDBase;
//    EFLOAT          efDtoWBase;
    LONG            lAscent;
 //   EPOINTFL        pteUnitAscent;
//    EFLOAT          efWtoDAscent;
//    EFLOAT          efDtoWAscent;
    LONG            lEscapement;
//    EPOINTFL        pteUnitEsc;
//    EFLOAT          efWtoDEsc;
//    EFLOAT          efDtoWEsc;
//    EFLOAT          efEscToBase;
//    EFLOAT          efEscToAscent;
    HGLYPH          hgDefault;
    HGLYPH          hgBreak;
    FIX             fxBreak;
    ULONG64     pfdg;          // ptr to wchar-->hglyph map
    ULONG64            wcgp;          // ptr to wchar->pglyphdata map, if any
    FLONG           flInfo;
    INT             cSelected;      // number of times selected
    RFONTLINK       rflPDEV;        // doubly linked list links
    RFONTLINK       rflPFF;         // doubly linked list links
    ULONG64      hsemCache;      // glyph cache semaphore
    CACHE           cache;          // glyph bitmap cache
    POINTL          ptlSim;         //  for bitmap scaling
    BOOL            bNeededPaths;   // was this rfont realized for a path bracket
//    EFLOAT          efDtoWBase_31;
//    EFLOAT          efDtoWAscent_31;
    ULONG64    ptmw;           // cached text metrics
    LONG            lMaxNegA;
    LONG            lMaxNegC;
    LONG            lMinWidthD;
    BOOL            bIsSystemFont;     // is this fixedsys/system/or terminal
    FLONG           flEUDCState;       // EUDC state information.
    ULONG64           prfntSystemTT;    // system TT linked rfont
    ULONG64           prfntSysEUDC;     // pointer to System wide EUDC Rfont.
    ULONG64           prfntDefEUDC;     // pointer to Default EUDC Rfont.
    ULONG64           paprfntFaceName; // facename links
    ULONG64           aprfntQuickBuff;
                                       // quick buffer for face name and remote links
    BOOL            bFilledEudcArray;  // will be TRUE, the buffer is filled.
    ULONG           ulTimeStamp;       // timestamp for current link.
    UINT            uiNumLinks;        // number of linked fonts.
    BOOL            bVertical;         // vertical face flag.
    ULONG64      hsemEUDC;          // EUDC semaphore
       // maximal dump
#define GetAndPrintRFONTFieldAndOffset(expr, member) \
				GetRFONTFieldAndOffset(member); Dprint(expr, member)

        GetAndPrintRFONTFieldAndOffset( %+#20x, iUnique);
        GetAndPrintRFONTFieldAndOffset( %+#20x, flType);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ulContent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hdevProducer);
        GetAndPrintRFONTFieldAndOffset( %+#20x, bDeviceFont);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hdevConsumer);
        GetAndPrintRFONTFieldAndOffset( %+#20x, dhpdev);
        GetAndPrintRFONTFieldAndOffset( %+#20p, ppfe);
        GetAndPrintRFONTFieldAndOffset( %+#20p, pPFF);

        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eXX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eXY);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eYX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eYY);

        GetAndPrintRFONTFieldAndOffset( %20u  , cBitsPerPel);

		GetRFONTOffset (mxWorldToDevice);
        dprintf("[0x%p] mxWorldToDevice: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);

        GetAndPrintRFONTFieldAndOffset( %20u  , iGraphicsMode);

		vDumpFoEFLOAT(eptflNtoWScale.x);
		vDumpFoEFLOAT(eptflNtoWScale.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , bNtoWIdent);

		GetRFONTOffset (xoForDDI.pmx);
        dprintf("[0x%p] xoForDDI.pmx: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);
        vDumpFoULONG(xoForDDI.ulMode);

		GetRFONTOffset (mxForDDI);
        dprintf("[0x%p] mxForDDI: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);

        GetAndPrintRFONTFieldAndOffset( %+#20x, flRealizedType);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlUnderline1.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlUnderline1.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlStrikeOut.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlStrikeOut.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlULThickness.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlULThickness.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSOThickness.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSOThickness.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , lCharInc);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxAscent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxDescent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxExtent);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxAscent.x);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxAscent.y);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxDescent.x);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxDescent.y);
        GetAndPrintRFONTFieldAndOffset( %20u  , cxMax);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxAscent);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxHeight);
        GetAndPrintRFONTFieldAndOffset( %20u  , cyMax);
        GetAndPrintRFONTFieldAndOffset( %20u  , cjGlyphMax);

        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eXX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eXY);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eYX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eYY);

        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearExtLeading);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearIntLeading);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearMaxCharWidth);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearAvgCharWidth);
        GetAndPrintRFONTFieldAndOffset( %20u  , ulOrientation);

		vDumpFoEFLOAT(pteUnitBase.x);
		vDumpFoEFLOAT(pteUnitBase.y);

		vDumpFoEFLOAT(efWtoDBase);
		vDumpFoEFLOAT(efDtoWBase);

        GetAndPrintRFONTFieldAndOffset( %20d  , lAscent);

		vDumpFoEFLOAT(pteUnitAscent.x);
		vDumpFoEFLOAT(pteUnitAscent.y);

        vDumpFoEFLOAT(efWtoDAscent);
        vDumpFoEFLOAT(efDtoWAscent);

        GetAndPrintRFONTFieldAndOffset( %20d  , lEscapement);

        vDumpFoEFLOAT(pteUnitEsc.x);
        vDumpFoEFLOAT(pteUnitEsc.y);

        vDumpFoEFLOAT(efWtoDEsc);
        vDumpFoEFLOAT(efDtoWEsc);
        vDumpFoEFLOAT(efEscToBase);
        vDumpFoEFLOAT(efEscToAscent);

        GetAndPrintRFONTFieldAndOffset( %+#20x, flInfo);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hgBreak);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxBreak);
        GetAndPrintRFONTFieldAndOffset( %+#20x, pfdg);

        GetAndPrintRFONTFieldAndOffset( %+#20p, wcgp);
        GetAndPrintRFONTFieldAndOffset( %20u  , cSelected);

      //rflPDEV
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPDEV.prfntPrev);
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPDEV.prfntNext);

      //rflPFF
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPFF.prfntPrev);
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPFF.prfntNext);

      //hsemCache
        GetAndPrintRFONTFieldAndOffset( %+#20x, hsemCache);

        //cache
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgdNext);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgdThreshold);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pjFirstBlockEnd);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pdblBase);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cMetrics);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjbbl);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBlocksMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBlocks);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cGlyphs);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjTotal);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pbblBase);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pbblCur);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgbNext);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgbThreshold);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pjAuxCacheMem);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjAuxCacheMem);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjGlyphMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.bSmallMetrics);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.iMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.iFirst);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBits);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSim.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSim.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , bNeededPaths);

        vDumpFoEFLOAT(efDtoWBase_31);
        vDumpFoEFLOAT(efDtoWAscent_31);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptmw);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxNegA);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxNegC);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMinWidthD);
        GetAndPrintRFONTFieldAndOffset( %20d  , bIsSystemFont);
        GetAndPrintRFONTFieldAndOffset( %+#20x, flEUDCState);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntSystemTT);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntSysEUDC);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntDefEUDC);
        GetAndPrintRFONTFieldAndOffset( %+#20x, paprfntFaceName);\

      //aprfntQuickBuff
#if 0
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[0]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[1]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[2]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[3]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[4]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[5]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[6]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[7]);
#endif

        GetAndPrintRFONTFieldAndOffset( %20d  , bFilledEudcArray);
        GetAndPrintRFONTFieldAndOffset( %20u  , ulTimeStamp);
        GetAndPrintRFONTFieldAndOffset( %20u  , uiNumLinks);
        GetAndPrintRFONTFieldAndOffset( %20d  , bVertical);

    }

    if (Memory)
	{
		dprintf("Extension 'fo -y' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
        vDumpGlyphMemory((RFONT*)arg);
#endif
	}

    if (Font) {
		ULONG64         ppfe;           // pointer to physical font entry
        GetRFONTFieldAndOffset(ppfe);
        dprintf("[Font Information]\n    ppfe = %-#p\n",  ppfe);
        // print the face name of the font
        if (ppfe) {
			ULONG64     pfeSrc= ppfe;
			ULONG64     pifi;
			GetPFEFieldAndOffset(pifi);
            if (pifi) {
                ULONG		dpwszFaceName, cjThis;
				ULONG64     pifiSrc = pifi;
				GetIFIMETRICSFieldAndOffset(cjThis);
				GetIFIMETRICSFieldAndOffset(dpwszFaceName);
                if (cjThis) {
					WCHAR  wszFaceName[MAX_PATH+1];
					
					ReadMemory(pifiSrc+dpwszFaceName, wszFaceName,MAX_PATH, NULL);
                    dprintf("           [%ws]\n", wszFaceName);
                }
            }
        }
		ULONG64         pPFF;           // point to physical font file
        GetRFONTFieldAndOffset(pPFF);
        dprintf("    pPFF  = %-#p\n", pPFF);
        if (pPFF) {
			ULONG64     pffSrc = pPFF;
			SIZE_T          sizeofThis;
			ULONG           cFonts;         // number of fonts (same as chpfe)
			ULONG64       aulData;     // data buffer for HPFE and filename
			ULONG64  sizeOfPVOID;

			sizeOfPVOID = GetTypeSize("PVOID");

			GetPFFFieldAndOffset(sizeofThis);
			GetPFFFieldAndOffset(cFonts);
			GetPFFFieldAndOffset(aulData);

			offset = offset + cFonts * (ULONG)sizeOfPVOID;
            if (sizeofThis) {
					WCHAR  wszPathName[MAX_PATH+1];
					
					ReadMemory(pffSrc+offset, wszPathName,MAX_PATH, NULL);
                    dprintf("           [%ws]\n", wszPathName);
            }
        }
    }
    if (Transform) {
		dprintf("Extension 'fo -x' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
        LONG l1,l2,l3,l4;

        psz = ach;
        psz += sprintFLOATL( psz, rf.fdx.eXX );
        *psz++ = ' ';
        psz += sprintFLOATL( psz, rf.fdx.eXY );
        dprintf("[transform]\n   fdx             = %s\n", ach);

        psz = ach;
        psz += sprintFLOATL( psz, rf.fdx.eXY );
        *psz++ = ' ';
        psz += sprintFLOATL( psz, rf.fdx.eYY );
        dprintf ("                     %s\n", ach );

        l1 = rf.mxWorldToDevice.efM11.lEfToF();
        l2 = rf.mxWorldToDevice.efM12.lEfToF();
        l3 = rf.mxWorldToDevice.efM21.lEfToF();
        l4 = rf.mxWorldToDevice.efM22.lEfToF();
        dprintf(
        "   mxWorldToDevice =\n"
        );

        sprintEFLOAT( ach, rf.mxWorldToDevice.efM11 );
        dprintf("       efM11 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM12 );
        dprintf("       efM12 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM21 );
        dprintf("       efM21 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM22 );
        dprintf("       efM22 = %s\n", ach );


        dprintf(
        "       fxDx  = %-#x\n"
        "       fxDy  = %-#x\n"
        , rf.mxWorldToDevice.fxDx
        , rf.mxWorldToDevice.fxDy
        );
        l1 = (LONG) rf.mxWorldToDevice.flAccel;
        dprintf("       flAccel = %-#x\n", l1);
        for (FLAGDEF *pfd=afdMX; pfd->psz; pfd++)
            if (l1 & pfd->fl)
                dprintf("\t\t%s\n", pfd->psz);

        psz = ach;
        psz += sprintEFLOAT( psz, rf.eptflNtoWScale.x);
        *psz++ = ' ';
        psz += sprintEFLOAT( psz, rf.eptflNtoWScale.y);
        dprintf("   eptflNtoWScale  = %s\n", ach );

        dprintf(
            "   bNtoWIdent      = %d\n"
            ,   rf.bNtoWIdent
        );
        dprintf(
        "   xoForDDI        =\n"
        "   mxForDDI        =\n"
        );
        dprintf(
        "   ulOrientation   = %u\n"
        , rf.ulOrientation
        );

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitBase.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitBase.y );
        dprintf("   pteUnitBase     = %s\n", ach );

        sprintEFLOAT( ach, rf.efWtoDBase );
        dprintf("   efWtoDBase      = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWBase );
        dprintf("   efDtoWBase      = %s\n", ach );

        dprintf("   lAscent         = %d\n", rf.lAscent);

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitAscent.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitAscent.y );
        dprintf("   pteUnitAscent   = %s\n", ach );

        sprintEFLOAT( ach, rf.efWtoDAscent );
        dprintf("   efWtoDAscent    = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWAscent );
        dprintf("   efDtoWAscent    = %s\n", ach );

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitEsc.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitEsc.y );
        dprintf("   pteUnitEsc      = %s\n", ach );


        sprintEFLOAT( ach, rf.efWtoDEsc    );
        dprintf("   efWtoDEsc       = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWEsc    );
        dprintf("   efDtoWEsc       = %s\n", ach );

        sprintEFLOAT( ach, rf.efEscToBase  );
        dprintf("   efEscToBase     = %s\n", ach );

        sprintEFLOAT( ach, rf.efEscToAscent);
        dprintf("   efEscToAscent   = %s\n", ach );

        dprintf("\n");
#endif
    }

    if (Glyphset) {
		dprintf("Extension 'fo -w' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
        if (rf.pfdg) {
            FD_GLYPHSET fdg, *pfdg;
            WCRUN *pwc;
            move( fdg, rf.pfdg );
            move2( adw, rf.pfdg, fdg.cjThis );
            pfdg = (FD_GLYPHSET*) adw;
            dprintf(
                "\t\t     cjThis  = %u = %-#x\n"
                , pfdg->cjThis
                , pfdg->cjThis
                );
            dprintf("\t\t     flAccel = %-#x\n", pfdg->flAccel );
            FLONG flAccel = pfdg->flAccel;
            for (FLAGDEF *pfd=afdGS; pfd->psz; pfd++)
                if (flAccel & pfd->fl) {
                    dprintf("\t\t\t\t%s\n", pfd->psz);
                    flAccel &= ~pfd->fl;
                }
            if (flAccel)
                    dprintf("\t\t\t\t????????\n");
            dprintf("\t\t\tcGlyphsSupported\t= %u\n", pfdg->cGlyphsSupported );
            dprintf("\t\t\tcRuns\t\t= %u\n", pfdg->cRuns );
            dprintf("\t\t\t\tWCHAR  HGLYPH\n");
            for ( pwc = pfdg->awcrun; pwc < pfdg->awcrun + pfdg->cRuns; pwc++ ) {
                dprintf("\t\t\t\t------------\n");
                HGLYPH *ahg= tmalloc(HGLYPH,sizeof(HGLYPH)*pwc->cGlyphs);
                if ( ahg ) {
                    move2(ahg, pwc->phg, sizeof(HGLYPH) * pwc->cGlyphs );
                    for (unsigned i = 0; i < pwc->cGlyphs; i++) {
                        if (CheckControlC()) {
                            tfree( ahg );
                            return;
                        }
                        dprintf("\t\t\t\t%-#6x %-#x\n",
                            pwc->wcLow + (USHORT) i, ahg[i]);
                    }
                    tfree( ahg );
                }
            }
        }
#endif
    }

    if (Cache) {
        ULONG64      hsemCache;      // glyph cache semaphore
        GetRFONTFieldAndOffset(hsemCache);
        GetRFONTOffset( cache.pgdNext);
        dprintf(
            "[cache]\n"
            "   hsemCache = %-#x\n" // semaphore
            , hsemCache
        );
        vDumpCACHE(foSrc+offset);
    }
    EXIT_API(S_OK);
fo_help:
    dprintf("Usage: fo [-?] [-a] [-c] [-f] [-h] [-w] [-x] [-y] pointer to FONTOBJ"
            "   -a    maximal dump\n"
            "   -c    cache\n"
            "   -x    transform data\n"
            "   -?    this message\n"
            "   -f    font\n"
            "   -h    FONTOBJ header\n"
            "   -w    FD_GLYPHSET\n"
            "   -y    Glyph Memory Usage\n");

#undef Dprintf
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpPFE
*
\**************************************************************************/

void vDumpPFE(ULONG64 offPFE)
{
#define N3(a,b,c) \
        GetPFEFieldAndOffset(c); \
        dprintf( "[%p] %s", pfeSrc + offset, (a)); dprintf( (b), ##c )
#define N2(a,c) \
        GetPFEOffset(c); \
        dprintf( "[%p] %s", pfeSrc + offset, (a)); 

    ULONG     offset;
    ULONG64     pfeSrc= offPFE;
    FLAGDEF *pfd;
    FLONG fl;

    ULONG64            pPFF;               // pointer to physical font file object
    ULONG           iFont;              // index of the font for IFI or device
    FLONG           flPFE;
    ULONG64     pfdg;              // ptr to wc-->hg map
    ULONG           idfdg;              // id returned by driver for FD_GLYPHSET
    ULONG64     pifi;               // pointer to ifimetrics
    ULONG           idifi;              // id returned by driver for IFIMETRICS
    ULONG64  pkp;               // pointer to kerning pairs (lazily loaded on demand)
    ULONG           idkp;               // id returned by driver for FD_KERNINGPAIR
    ULONG           ckp;                // count of kerning pairs in the FD_KERNINGPAIR arrary
    LONG            iOrientation;       // Cache IFI orientation.
    ULONG           cjEfdwPFE;          // size of enumeration data needed for this pfe
    ULONG64           pgiset;    // initialized to NULL;
    ULONG           ulTimeStamp;        // unique time stamp (smaller == older)
    ULONG         pid;
//    QUICKLOOKUP     ql;                 // QUICKLOOKUP if a linked font
    ULONG64        pFlEntry;           // Pointer to linked font list
    ULONG           cAlt;
    ULONG           cPfdgRef;
    BYTE            aiFamilyName[1]; // aiFamilyNameg[cAltCharSets]

    dprintf("\nPFE\n\n");
    N3("pPFF              ", "%-#x\n", pPFF);
    N3("iFont             ", "%u\n", iFont);
    N3("pifi              ", "%-#x\n", pifi);

    N3("flPFE             ", "%-#x\n", flPFE);
    for (fl = flPFE, pfd=afdPFE; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                   %s\n", pfd->psz);
        }
    }

    N3("pfdg              ", "%-#x\n", pfdg);
    N2("idifi\n", idifi);
    N3("pkp               ", "%-#x\n", pkp);
    N3("idkp              ", "%-#x\n", idkp);
    N3("ckp               ", "%u\n", ckp);
    N3("iOrieintation     ", "%d\n", iOrientation);
    N3("cjEfdwPFE         ", "%-#x\n", cjEfdwPFE);
    N3("pgiset            ", "%-#x\n", pgiset);
    N3("ulTimeStamp       ", "%u\n", ulTimeStamp);
    N2("ufi\n",                      ufi);
    N3("pid               ", "%-#x\n", pid);


    N2("ql\n"                        , ql);
    N3("pFlEntry          ", "%-#x\n", pFlEntry);


    N3("cAlt              ", "%u\n",   cAlt);
    N3("cPfdgRef          ", "%u\n",   cPfdgRef);
    N2("aiFamilyName[]"    , aiFamilyName[0]);
    dprintf("\n\n");
    #undef  N2
    #undef  N3

}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pfe
*
\**************************************************************************/

DECLARE_API( pfe )
{
    PARSE_POINTER(pfe_help);
    vDumpPFE( arg );
    EXIT_API(S_OK);
pfe_help:
    dprintf ("Usage: pfe [-?] pointer to PFE\n");
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( hpfe )
{
    dprintf("Why are you using a handle? Nobody uses a handle to a PFE\n");
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* vPrintSkeletonPFF
*
* Argument
*
*    pLocalPFF          points to a complete local PFF structure
*                       (including PFE*'s and path name)
*                       all addresses contained are remote
*                       except for pwszPathname_ which has
*                       been converted before this routine
*                       was called
*
* History:
*  Tue 30-Aug-1994 07:25:18 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintSkeletonPFF( PFF *pLocalPFF )
{
    PFE **ppPFEl, **ppPFEl_;

    if (pLocalPFF->hdev)
        dprintf("\t%-#8x (HDEV)\n", pLocalPFF->hdev);
    else
        dprintf("\t\"%ws\"\n", pLocalPFF->pwszPathname_);
    dprintf("\t    PFE*        IFI*\n");

    ppPFEl  = (PFE**)  &(pLocalPFF->aulData[0]);
    ppPFEl_ = ppPFEl + pLocalPFF->cFonts;
    while (ppPFEl < ppPFEl_) {
        PFE *pPFEr = *ppPFEl;

        dprintf("\t    %-#10x", pPFEr);
        if ( pPFEr ) {
            PFE PFEt;
            move2(&PFEt, pPFEr, sizeof(PFEt));
            dprintf("  %-#10x\t", PFEt.pifi);
            {
                ULONG sizeofIFI;
                IFIMETRICS *pHeapIFI;
                move2(
                    &sizeofIFI
                  , PFEt.pifi + offsetof(IFIMETRICS,cjThis)
                  , sizeof(sizeofIFI));
                if (pHeapIFI = tmalloc(IFIMETRICS,sizeofIFI)) {
                    move2(pHeapIFI, PFEt.pifi, sizeofIFI);
                    IFIOBJ ifio(pHeapIFI);
                    dprintf(
                        "\"%ws\" %d %d\n"
                      , ifio.pwszFaceName()
                      , ifio.lfHeight()
                      , ifio.lfWidth()
                      );
                    tfree(pHeapIFI);
                } else
                    dprintf("!!! memory allocation failure !!!\n");
            }
        } else
            dprintf("  INVALID PFE\n");
        ppPFEl++;
    }
    // Now print the RFONT list
    {
        RFONT LocalRFONT, *pRemoteRFONT;

        if (pRemoteRFONT = pLocalPFF->prfntList) {
            dprintf("\t\tRFONT*      PFE*\n");
            do {
                move2(&LocalRFONT, pRemoteRFONT, sizeof(LocalRFONT));
                dprintf("\t\t%-#10x  %-#10x\n", pRemoteRFONT, LocalRFONT.ppfe);
                pRemoteRFONT = LocalRFONT.rflPFF.prfntNext;
            } while (pRemoteRFONT);
        }
    }
}
#endif  // DOES NOT SUPPORT API64
        
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpPFT( PFT *pLocal, PFT *pRemote )
{
    COUNT i;

    dprintf("[%8x]  pfhFamily %-#x\n", &pRemote->pfhFamily, pLocal->pfhFamily);
    dprintf("[%8x]    pfhFace %-#x\n", &pRemote->pfhFace  , pLocal->pfhFace  );
    dprintf("[%8x]     pfhUFI %-#x\n", &pRemote->pfhUFI   , pLocal->pfhUFI   );
    dprintf("[%8x]   cBuckets %-#x\n", &pRemote->cBuckets , pLocal->cBuckets );
    dprintf("[%8x]     cFiles %-#x\n", &pRemote->cFiles   , pLocal->cFiles   );

    for (i = 0; i < pLocal->cBuckets; i++)
    {
        PFF *pRemotePFF = pLocal->apPFF[i];

        if (pRemotePFF)
        {
            PFF *pLast;

            dprintf("[%8x]", &pRemote->apPFF[i]);

            pLast = 0;
            while (pRemotePFF && !CheckControlC())
            {
                PFF LocalPFF;

                dprintf(" %8x", pRemotePFF);

                move(LocalPFF, pRemotePFF);
                pLast      = pRemotePFF;
                pRemotePFF = LocalPFF.pPFFNext;
                if (pRemotePFF && pRemotePFF == pLast)
                {
                    dprintf(" <---- BAD PFF ?");
                    pRemotePFF = 0;
                }
            }
            dprintf("\n");
        }
    }

    dprintf("\n"
            "PFF*     Pathname_\n"
            "-------- ---------\n");

    for (i = 0; i < pLocal->cBuckets; i++)
    {
        PFF *pRemotePFF, LocalPFF;
        PWSZ pwszDst;

        if ( pRemotePFF = pLocal->apPFF[i] )
        {
            dprintf("apPFF[%d]\n", i);
            for ( ; pRemotePFF; pRemotePFF=LocalPFF.pPFFNext)
            {
                move(LocalPFF, pRemotePFF);
                pwszDst = wcsncpy((PWSZ) adw, LocalPFF.pwszPathname_, sizeof(adw)/sizeof(WCHAR));
                if ( pwszDst == 0 )
                {
                    pwszDst = L"";
                }
                dprintf("%8x \"%ws\"\n", pRemotePFF, pwszDst);
            }
            dprintf("\n");
        }
    }
}
#endif  // DOES NOT SUPPORT API64

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpFONTHASH( FONTHASH *pLocal, FONTHASH *pRemote )
{
    UINT i;
    union {
        UINT id;
        char ach[4];
    } u;

    /*
    UINT         id;        // 'HASH'
    FONTHASHTYPE fht;       // table type
    UINT         cBuckets;  // total number of buckets
    UINT         cUsed;     // number of buckets in use
    UINT         cCollisions;
    HASHBUCKET  *pbktFirst; // first bucket of doubly linked list of hash
                            // buckets maintained in order loaded into system
    HASHBUCKET  *pbktLast;  // last bucket of doubly linked list of hash
                            // buckets maintained in order loaded into system
    HASHBUCKET  *apbkt[1];  // array of bucket pointers.
    */

    u.id = pLocal->id;
    dprintf("[%8x]          id %8x   %c%c%c%c\n", &pRemote->id, u.id, u.ach[0], u.ach[1], u.ach[2], u.ach[3]);
    dprintf("[%8x]         fht %-#10x %s\n", &pRemote->fht, pLocal->fht, pszFONTHASHTYPE(pLocal->fht));
    dprintf("[%8x]    cBuckets %-#x\n", &pRemote->cBuckets, pLocal->cBuckets);
    dprintf("[%8x]       cUsed %-#x\n", &pRemote->cUsed, pLocal->cUsed);
    dprintf("[%8x] cCollisions %-#x\n", &pRemote->cCollisions, pLocal->cCollisions);
    dprintf("[%8x]   pbktFirst %-#x\n", &pRemote->pbktFirst, pLocal->pbktFirst);
    dprintf("[%8x]    pbktLast %-#x\n", &pRemote->pbktLast, pLocal->pbktLast);
    dprintf("\n");

    i = pLocal->cBuckets * sizeof(HASHBUCKET*);
    if (i == 0 )
    {
        dprintf("No buckets here\n");
        return;
    }

    move2(adw,&(pRemote->apbkt[0]),i);

    for ( i = 0; i < pLocal->cBuckets; i++)
    {
        HASHBUCKET *pRemoteHB = ((HASHBUCKET**) adw)[i];

        if ( pRemoteHB )
        {
            HASHBUCKET LocalHB;

            dprintf("apbkt[%3u]", i);

            for ( ; pRemoteHB; pRemoteHB = LocalHB.pbktCollision)
            {
                dprintf(" %-#x", pRemoteHB);
                move(LocalHB, pRemoteHB);
            }
            dprintf("\n");
        }
    }
    dprintf("\n");

    for ( i = 0; i < pLocal->cBuckets; i++)
    {
        HASHBUCKET *pRemoteHB = ((HASHBUCKET**) adw)[i];

        if ( pRemoteHB )
        {
            HASHBUCKET LocalHB;

            dprintf("--------------------------------------\n");
            dprintf("apbkt[%3u]\n", i);

            for ( ; pRemoteHB; pRemoteHB = LocalHB.pbktCollision)
            {
                dprintf("HASHBUCKET* %-#x ", pRemoteHB);
                move(LocalHB, pRemoteHB);

                switch ( pLocal->fht )
                {
                case FHT_FACE:
                case FHT_FAMILY:

                    dprintf("\t\"%ws\"", LocalHB.u.wcCapName);
                    break;

                case FHT_UFI:

                    dprintf("\tUFI(%-#x,%-#x)", LocalHB.u.ufi.CheckSum, LocalHB.u.ufi.Index);
                    break;

                default:

                    break;
                }
                dprintf("\n");

                {
                    PFELINK *ppfel = LocalHB.ppfelEnumHead;
                    PFELINK  pfelLocal;

                    PFE LocalPFE;

                    if (ppfel)
                    {
                        dprintf("PFE*\n");
                        while (ppfel)
                        {
                            move(pfelLocal, ppfel);
                            dprintf("%-#x", pfelLocal.ppfe);
                            move(LocalPFE,pfelLocal.ppfe);

                            if (LocalPFE.pPFF)
                            {
                                PFF LocalPFF;
                                WCHAR awc[MAX_PATH];

                                move(LocalPFF, LocalPFE.pPFF);
                                wcsncpy( awc, LocalPFF.pwszPathname_, MAX_PATH);
                                awc[MAX_PATH-1]=0;
                                dprintf(" \"%ws\"", awc);
                            }

                            if (LocalPFE.pifi)
                            {
                                ULONG dp;
                                WCHAR awc[LF_FACESIZE+1];
                                PWSZ pwszSrc;
                                FWORD fwdAscender, fwdDescender, fwdWidth;

                                move(dp,&((LocalPFE.pifi)->dpwszFaceName));
                                pwszSrc = (PWSZ)(((char*) (LocalPFE.pifi)) + dp);
                                wcsncpy(awc, pwszSrc, LF_FACESIZE);
                                awc[LF_FACESIZE] = 0;
                                dprintf(" \"%ws\"", awc);

                                move(fwdAscender, &LocalPFE.pifi->fwdWinAscender);
                                move(fwdDescender, &LocalPFE.pifi->fwdWinDescender);
                                move(fwdWidth, &LocalPFE.pifi->fwdAveCharWidth);

                                dprintf(" %4d %4d %4d", fwdAscender, fwdDescender, fwdWidth);

                            }

                            dprintf("\n");

                            ppfel = pfelLocal.ppfelNext;
                        }
                    }
                }
            }
        }
    }
    dprintf("--------------------------------------\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* vPrintSkeletonPFT
*
* History:
*  Mon 29-Aug-1994 15:51:16 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintSkeletonPFT( PFT *pLocalPFT )
{
    PFF *pPFFr, **ppPFFl, **ppPFFl_, *pPFFNext ,*pHeapPFF;

    dprintf("pfhFamily      = %-#x\n" , pLocalPFT->pfhFamily       );
    dprintf("pfhFace        = %-#x\n" , pLocalPFT->pfhFace         );
    dprintf("cBuckets       = %u\n"   , pLocalPFT->cBuckets        );
    dprintf("cFiles         = %u\n"   , pLocalPFT->cFiles          );
    dprintf("\n\n");


    for (
            ppPFFl  = pLocalPFT->apPFF
          , ppPFFl_ = pLocalPFT->apPFF + pLocalPFT->cBuckets
        ;   ppPFFl < ppPFFl_
        ;   ppPFFl++
    ) {
        // if the bucket is empty skip to the next otherwise print
        // the bucket number and then print the contents of all
        // the PFF's hanging off the bucket.

        if (!(pPFFr = *ppPFFl))
            continue;
        dprintf("apPFF[%u]\n", ppPFFl - pLocalPFT->apPFF);
        while ( pPFFr ) {
            // get the size of the remote PFF and allocate enough space
            // on the heap

            dprintf("    %-#8x", pPFFr);
            PFF FramePFF;
            move(FramePFF, pPFFr);
            if (pHeapPFF = tmalloc(PFF,FramePFF.sizeofThis)) {
                // get a local copy of the PFF and fix up the sting pointer
                // to point to the address in the local heap then print
                // the local copy. Some of the addresses in the local
                // PFF point to remote object but vPrintSkeleton will
                // take care of that. When we are done we free the memory.

                move2(pHeapPFF, pPFFr, (ULONG)(ULONG_PTR)FramePFF.sizeofThis);
                PFFOBJ pffo(pHeapPFF);
                pHeapPFF->pwszPathname_ = pffo.pwszCalcPathname();
                vPrintSkeletonPFF(
                   pHeapPFF
                  );
                tfree(pHeapPFF);
            }
            else {
                dprintf("Allocation failure\n");
                break;
            }
            pPFFr = FramePFF.pPFFNext;
        }
    }
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( pft )
{
    dprintf("Extension 'pft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PARSE_POINTER(pft_help);
    Gdidpft((PFT *) arg);
    return;
pft_help:
    dprintf ("Usage: pft [-?] pointer to PFT\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* dpft
*
* History:
*  Mon 29-Aug-1994 15:39:39 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID Gdidpft( PFT *pRemotePFT)
{
    ULONG size;
    PFT LocalPFT, *pLocalPFT;

    move(LocalPFT, pRemotePFT);
    size = offsetof(PFT, apPFF[0]) + LocalPFT.cBuckets * sizeof(PFF *);
    if (pLocalPFT = tmalloc(PFT, size)) {
        move2(pLocalPFT, pRemotePFT, size);
        vDumpPFT(pLocalPFT, pRemotePFT);
        tfree(pLocalPFT);
    } else
        dprintf("dpft error --- failed to allocate memory\n");
    dprintf("\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* dpubft
*
* dumps the public font table
*
* History:
*  Thu 01-Sep-1994 23:20:54 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( pubft )
{
    dprintf("Extension 'pubft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT * pft;
    PARSE_ARGUMENTS(pubft_help);

    GetValue (pft,  "win32k!gpPFTPublic");
    Gdidpft(pft);
    return;
pubft_help:
    dprintf("Usage: pubft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTPublic\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* Gdidpvtft( )
*
* dumps the private PFT
*
* History:
*  01-Oct-1996 -by-  Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

DECLARE_API( pvtft )
{
    dprintf("Extension 'pvtft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT * pft;
    PARSE_ARGUMENTS(pvtft_help);
    GetValue (pft,  "win32k!gpPFTPrivate");
    Gdidpft(pft);
    return;
pvtft_help:
    dprintf("Usage: pvtft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTPrivate\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* ddevft
*
* dumps the device font table
*
* History:
*  Thu 01-Sep-1994 23:21:15 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( devft )
{
    dprintf("Extension 'devft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT *pft;
    PARSE_ARGUMENTS(devft_help);
    GetValue (pft,  "win32k!gpPFTDevice");
    Gdidpft(pft);
    return;
devft_help:
    dprintf("Usage: devft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTDevice\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  Sat 23-Sep-1995 08:26:09 by Kirk Olynyk [kirko]
* Re-wrote it.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( stro )
{
#define QUICK_FACE_NAME_LINKS      8

    ULONG     offset;
    ULONG64     estrobjSrc;

    ULONG     cGlyphs;     // Number of glyphs.
    FLONG     flAccel;     // Accelerator flags exposed to the driver.
    ULONG     ulCharInc;   // Non-zero if constant character increment.
    RECTL     rclBkGround; // Background rect of the string.
    ULONG64 pgp;         // Accelerator if all GLYPHPOS's are valid.
    ULONG64     pwszOrg;     // pointer to original unicode string.

    ULONG      cgposCopied;          // For enumeration.
    ULONG      cgposPositionsEnumerated;   // only used for enumerating positions in linked strings
    ULONG64  prfo;                 // Remember our RFONTOBJ.
    FLONG      flTO;                 // flags
    ULONG64 pgpos;                // Pointer to the GLYPHPOS structures.
    POINTFIX   ptfxRef;              // Reference point.
    POINTFIX   ptfxUpdate;           // CP advancement for the string.
    POINTFIX   ptfxEscapement;       // The total escapement vector.
    RECTFX     rcfx;                 // The TextBox, projected onto the base and ascent.
    FIX        fxExtent;             // The Windows compatible text extent.
    FIX        xExtra;               // computed in H3, G2,3 cases
    FIX        xBreakExtra;          // computed in H3, G2,3 cases
    DWORD      dwCodePage;           // accelerator for ps driver
    ULONG      cExtraRects;          // Rectangles for underline
    RECTL      arclExtra[3];         //  and strikeout.
    RECTL      rclBkGroundSave;      // used to save a copy of BkGroundRect
    ULONG64      pwcPartition;        // For partitioning
    ULONG64       plPartition;         // Points to partitioning information
    ULONG64      plNext;              // Next glyph in font
    ULONG64   pgpNext;             // For enumeration
    LONG       lCurrentFont;         // For enumeration
    POINTL     ptlBaseLineAdjust;     // Used to adjust SysEUDC baseline
    ULONG      cTTSysGlyphs;         // Number of TT system font glyphs in a string
    ULONG      cSysGlyphs;           // Number of system eudc glyphs in a string.
    ULONG      cDefGlyphs;           // Number of default eudc glyphs in a string.
    ULONG      cNumFaceNameLinks;    // Number of linked face name eudc in a string .
    ULONG64     pacFaceNameGlyphs;    // Pointer to array of number of face name glyphs.
    ULONG      acFaceNameGlyphs[QUICK_FACE_NAME_LINKS];

    FLONG fl;
    FLAGDEF *pfd;
    WCHAR *awc;
    int i;
    BOOL Header=FALSE;
    BOOL Position=FALSE;
    BOOL East=FALSE;

    PARSE_POINTER(stro_help);
    estrobjSrc= arg;

    if(parse_iFindSwitch(tokens, ntok, 'p')!=-1) {Position=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'e')!=-1) {East=TRUE;}

    if(!(Position||East||Header)) {Header=TRUE;}
    if(East) {Header=TRUE;}

    if (Header) {
        GetESTROBJFieldAndOffset(cGlyphs); 
        dprintf("[%-#p] cGlyphs                %-#x\n", estrobjSrc+offset               , cGlyphs               );
        GetESTROBJFieldAndOffset(flAccel); 
        dprintf("[%-#p] flAccel                %-#x\n", estrobjSrc+offset               , flAccel               );
        for (fl=flAccel, pfd=afdSO; pfd->psz; pfd++)
            if (fl & pfd->fl) {
                dprintf("\t\t%s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        GetESTROBJFieldAndOffset(ulCharInc); 
        dprintf("[%-#p] ulCharInc              %-#x=%u\n", estrobjSrc+offset             , ulCharInc            , ulCharInc              );
        GetESTROBJFieldAndOffset(rclBkGround.left); 
        dprintf("[%-#p] rclBkGround.left       %-#x=%d\n", estrobjSrc+offset      , rclBkGround.left     , rclBkGround.left       );
        GetESTROBJFieldAndOffset(rclBkGround.top); 
        dprintf("[%-#p] rclBkGround.top        %-#x=%d\n", estrobjSrc+offset       , rclBkGround.top      , rclBkGround.top        );
        GetESTROBJFieldAndOffset(rclBkGround.right); 
        dprintf("[%-#p] rclBkGround.right      %-#x=%d\n", estrobjSrc+offset     , rclBkGround.right    , rclBkGround.right      );
        GetESTROBJFieldAndOffset(rclBkGround.bottom); 
        dprintf("[%-#p] rclBkGround.bottom     %-#x=%d\n", estrobjSrc+offset    , rclBkGround.bottom   , rclBkGround.bottom     );
        GetESTROBJFieldAndOffset(pgp); 
       dprintf("[%-#p] pgp                    %-#x\n", estrobjSrc+offset                   , pgp                   );

        GetESTROBJFieldAndOffset(pwszOrg); 
        awc = (WCHAR*) adw;
        awc[0] = 0;
        if (pwszOrg && cGlyphs < 256) {
            ReadMemory((ULONG_PTR) pwszOrg, adw, cGlyphs * sizeof(WCHAR), 0);
            awc[255] = 0;
        }
        dprintf("[%-#p] pwszOrg                %-#x ", estrobjSrc+offset, pwszOrg);
        GetESTROBJFieldAndOffset(prfo); 
        if (awc[0] && prfo) {
#if 0
            if (offsetof(RFONTOBJ,prfnt) != 0)
                dprintf("\noffsetof(RFONTOBJ,prfnt) != 0\n");
            else 
#endif
            {
                ULONG64         foSrc;
                FLONG           flType;         // Cache type -

                GetFieldData(prfo, "PVOID", NULL, sizeof(foSrc), &foSrc);
                GetRFONTFieldAndOffset( flType);


                WCHAR wc, *pwc;
                USHORT *pus, *pusStnl;

                switch (flType & (RFONT_TYPE_UNICODE | RFONT_TYPE_HGLYPH)) {

                case RFONT_TYPE_UNICODE:

                    dprintf("%c", '\"');
                    for (pwc = awc; wc = *pwc; pwc++) {
                        if (wc < 256 )
                            dprintf("%c", isprint((int)wc) ? (char) wc : 250);
                        else
                            dprintf("\\u%04X", wc);
                    }
                    dprintf("\"\n");
                    break;

                case RFONT_TYPE_HGLYPH:

                    for (pwc = awc; wc = *pwc; pwc++)
                        dprintf("\t\t\t\tu%04X", wc);
                    dprintf("\n");
                    break;

                default:

                      dprintf("   flType = %-#x [unknown string type]\n", flType);
                      break;
                }
            }
        } else
            dprintf("\n");
    }

    if (East) {

        GetESTROBJFieldAndOffset(cgposCopied); 
        dprintf("[%-#p] cgposCopied            %-#x\n", estrobjSrc+offset           , cgposCopied           );
        GetESTROBJFieldAndOffset(cgposPositionsEnumerated); 
        dprintf("[%-#p] cgposPositionsEnumerated %-#x\n", estrobjSrc+offset          , cgposPositionsEnumerated           );
        GetESTROBJFieldAndOffset(prfo); 
        dprintf("[%-#p] prfo                   %-#p\n", estrobjSrc+offset                  , prfo                  );
        GetESTROBJFieldAndOffset(flTO); 
        dprintf("[%-#p] flTO                   %-#x\n", estrobjSrc+offset                  , flTO                  );
        for (fl=flTO, pfd=afdTO; pfd->psz; pfd++)
            if (fl & pfd->fl) {
                dprintf("\t\t%s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        GetESTROBJFieldAndOffset(pgpos); 
        dprintf("[%-#p] pgpos                  %-#p\n", estrobjSrc+offset                 , pgpos                 );
        GetESTROBJFieldAndOffset(ptfxRef.x); 
        dprintf("[%-#p] ptfxRef.x              %-#x\n", estrobjSrc+offset             , ptfxRef.x             );
        GetESTROBJFieldAndOffset(ptfxRef.y); 
        dprintf("[%-#p] ptfxRef.y              %-#x\n", estrobjSrc+offset             , ptfxRef.y             );
        GetESTROBJFieldAndOffset(ptfxUpdate.x); 
        dprintf("[%-#p] ptfxUpdate.x           %-#x\n", estrobjSrc+offset          , ptfxUpdate.x          );
        GetESTROBJFieldAndOffset(ptfxUpdate.y); 
        dprintf("[%-#p] ptfxUpdate.y           %-#x\n", estrobjSrc+offset          , ptfxUpdate.y          );
        GetESTROBJFieldAndOffset(ptfxEscapement.x); 
        dprintf("[%-#p] ptfxEscapement.x       %-#x\n", estrobjSrc+offset      , ptfxEscapement.x      );
        GetESTROBJFieldAndOffset(ptfxEscapement.y); 
        dprintf("[%-#p] ptfxEscapement.y       %-#x\n", estrobjSrc+offset      , ptfxEscapement.y      );
        GetESTROBJFieldAndOffset(rcfx.xLeft); 
        dprintf("[%-#p] rcfx.xLeft             %-#x\n", estrobjSrc+offset            , rcfx.xLeft            );
        GetESTROBJFieldAndOffset(rcfx.yTop); 
        dprintf("[%-#p] rcfx.yTop              %-#x\n", estrobjSrc+offset             , rcfx.yTop             );
        GetESTROBJFieldAndOffset(rcfx.xRight); 
        dprintf("[%-#p] rcfx.xRight            %-#x\n", estrobjSrc+offset           , rcfx.xRight           );
        GetESTROBJFieldAndOffset(rcfx.yBottom); 
        dprintf("[%-#p] rcfx.yBottom           %-#x\n", estrobjSrc+offset          , rcfx.yBottom          );
        GetESTROBJFieldAndOffset(fxExtent); 
        dprintf("[%-#p] fxExtent               %-#x\n", estrobjSrc+offset              , fxExtent              );
        GetESTROBJFieldAndOffset(xExtra); 
        dprintf("[%-#p] xExtra                 %-#x\n", estrobjSrc+offset                , xExtra                );
        GetESTROBJFieldAndOffset(xBreakExtra); 
        dprintf("[%-#p] xBreakExtra            %-#x\n", estrobjSrc+offset           , xBreakExtra           );
        GetESTROBJFieldAndOffset(dwCodePage); 
        dprintf("[%-#p] dwCodePage             %-#x=%u\n", estrobjSrc+offset            , dwCodePage            , dwCodePage            );
        GetESTROBJFieldAndOffset(cExtraRects); 
        dprintf("[%-#p] cExtraRects            %-#x=%u\n", estrobjSrc+offset           , cExtraRects           , cExtraRects           );
        GetESTROBJFieldAndOffset(arclExtra[0].left); 
        dprintf("[%-#p] arclExtra[0].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[0].left     , arclExtra[0].left     );
        GetESTROBJFieldAndOffset(arclExtra[0].top); 
        dprintf("[%-#p] arclExtra[0].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[0].top      , arclExtra[0].top      );
        GetESTROBJFieldAndOffset(arclExtra[0].right); 
        dprintf("[%-#p] arclExtra[0].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[0].right    , arclExtra[0].right    );
        GetESTROBJFieldAndOffset(arclExtra[0].bottom); 
        dprintf("[%-#p] arclExtra[0].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[0].bottom   , arclExtra[0].bottom   );
        GetESTROBJFieldAndOffset(arclExtra[1].left); 
        dprintf("[%-#p] arclExtra[1].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[1].left     , arclExtra[1].left     );
        GetESTROBJFieldAndOffset(arclExtra[1].top); 
        dprintf("[%-#p] arclExtra[1].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[1].top      , arclExtra[1].top      );
        GetESTROBJFieldAndOffset(arclExtra[1].right); 
        dprintf("[%-#p] arclExtra[1].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[1].right    , arclExtra[1].right    );
        GetESTROBJFieldAndOffset(arclExtra[1].bottom); 
        dprintf("[%-#p] arclExtra[1].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[1].bottom   , arclExtra[1].bottom   );
        GetESTROBJFieldAndOffset(arclExtra[2].left); 
        dprintf("[%-#p] arclExtra[2].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[2].left     , arclExtra[2].left     );
        GetESTROBJFieldAndOffset(arclExtra[2].top); 
        dprintf("[%-#p] arclExtra[2].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[2].top      , arclExtra[2].top      );
        GetESTROBJFieldAndOffset(arclExtra[2].right); 
        dprintf("[%-#p] arclExtra[2].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[2].right    , arclExtra[2].right    );
        GetESTROBJFieldAndOffset(arclExtra[2].bottom); 
        dprintf("[%-#p] arclExtra[2].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[2].bottom   , arclExtra[2].bottom   );
        GetESTROBJFieldAndOffset(rclBkGroundSave.top); 
        dprintf("[%-#p] rclBkGroundSave.top    %-#x=%d\n", estrobjSrc+offset   , rclBkGroundSave.top   , rclBkGroundSave.top   );
        GetESTROBJFieldAndOffset(rclBkGroundSave.left); 
        dprintf("[%-#p] rclBkGroundSave.left   %-#x=%d\n", estrobjSrc+offset  , rclBkGroundSave.left  , rclBkGroundSave.left  );
        GetESTROBJFieldAndOffset(rclBkGroundSave.right); 
        dprintf("[%-#p] rclBkGroundSave.right  %-#x=%d\n", estrobjSrc+offset , rclBkGroundSave.right , rclBkGroundSave.right );
        GetESTROBJFieldAndOffset(rclBkGroundSave.bottom); 
        dprintf("[%-#p] rclBkGroundSave.bottom %-#x=%d\n", estrobjSrc+offset, rclBkGroundSave.bottom, rclBkGroundSave.bottom);
        GetESTROBJFieldAndOffset(pwcPartition); 
        dprintf("[%-#p] pwcPartition           %-#p\n", estrobjSrc+offset          , pwcPartition          );
        GetESTROBJFieldAndOffset(plPartition); 
        dprintf("[%-#p] plPartition            %-#p\n", estrobjSrc+offset           , plPartition           );
        GetESTROBJFieldAndOffset(plNext); 
        dprintf("[%-#p] plNext                 %-#p\n", estrobjSrc+offset                , plNext                );
        GetESTROBJFieldAndOffset(pgpNext); 
        dprintf("[%-#p] pgpNext                %-#p\n", estrobjSrc+offset               , pgpNext               );
        GetESTROBJFieldAndOffset(lCurrentFont); 
        dprintf("[%-#p] lCurrentFont           %-#x\n", estrobjSrc+offset          , lCurrentFont          );
        GetESTROBJFieldAndOffset(ptlBaseLineAdjust.x); 
        dprintf("[%-#p] ptlBaseLineAdjust.x     %-#x\n", estrobjSrc+offset    , ptlBaseLineAdjust.x    );
        GetESTROBJFieldAndOffset(ptlBaseLineAdjust.y); 
        dprintf("[%-#p] ptlBaseLineAdjust.y     %-#x\n", estrobjSrc+offset    , ptlBaseLineAdjust.y    );
        GetESTROBJFieldAndOffset(cTTSysGlyphs); 
        dprintf("[%-#p] cTTSysGlyphs           %-#x\n", estrobjSrc+offset          , cTTSysGlyphs          );
        GetESTROBJFieldAndOffset(cSysGlyphs); 
        dprintf("[%-#p] cSysGlyphs             %-#x\n", estrobjSrc+offset            , cSysGlyphs            );
        GetESTROBJFieldAndOffset(cDefGlyphs); 
        dprintf("[%-#p] cDefGlyphs             %-#x\n", estrobjSrc+offset            , cDefGlyphs            );
        GetESTROBJFieldAndOffset(cNumFaceNameLinks); 
        dprintf("[%-#p] cNumFaceNameLinks      %-#x\n", estrobjSrc+offset     , cNumFaceNameLinks     );
        GetESTROBJFieldAndOffset(pacFaceNameGlyphs); 
        dprintf("[%-#p] pacFaceNameGlyphs      %-#p\n", estrobjSrc+offset     , pacFaceNameGlyphs     );

        GetESTROBJFieldAndOffset(acFaceNameGlyphs[0]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 0, acFaceNameGlyphs[0]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[1]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 1, acFaceNameGlyphs[1]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[2]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 2, acFaceNameGlyphs[2]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[3]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 3, acFaceNameGlyphs[3]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[4]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 4, acFaceNameGlyphs[4]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[5]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 5, acFaceNameGlyphs[5]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[6]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 6, acFaceNameGlyphs[6]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[7]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 7, acFaceNameGlyphs[7]   );
    }
    if (Position) {

      /* GLYPHPOS: */
      ULONG      hg, i;
      ULONG64     pgdf;
      POINTL      ptl;

      /* GLYPHDEF */
      ULONG64 pgb = 0;

      ULONG64 glyphposSrc, sizeOfGlyphPos;

	  sizeOfGlyphPos = GetTypeSize("GLYPHPOS");

      GetESTROBJFieldAndOffset(rclBkGround.left); 
      GetESTROBJFieldAndOffset(rclBkGround.top); 
      GetESTROBJFieldAndOffset(rclBkGround.right); 
      GetESTROBJFieldAndOffset(rclBkGround.bottom); 
      GetESTROBJFieldAndOffset(cGlyphs); 
      GetESTROBJFieldAndOffset(pgp); 

      glyphposSrc = pgp;

      dprintf("   ---------- ----------      ---------- ----------\n");
      dprintf("   HGLYPH      GLYPHBITS*         x          y\n");
      dprintf("   ---------- ----------      ---------- ----------\n");

      for (i = 0; i < cGlyphs; i++) {
          char *pszOutOfBounds = "";
          GetGLYPHPOSFieldAndOffset(pgdf); 
          GetGLYPHPOSFieldAndOffset(hg); 
          GetGLYPHPOSFieldAndOffset(ptl.x); 
          GetGLYPHPOSFieldAndOffset(ptl.y); 


          if (pgdf) {
              POINTL      ptlOrigin;
              SIZEL       sizlBitmap;
              BYTE        aj[1];
              ULONG64 glyphdefSrc = pgdf;

              GetGLYPHDEFFieldAndOffset(pgb); 

              if (pgb) {
                  RECT rcGlyph;
                  ULONG64 glyphbitsSrc = pgb;

                  GetGLYPHBITSFieldAndOffset(ptlOrigin.x); 
                  GetGLYPHBITSFieldAndOffset(ptlOrigin.y); 
                  GetGLYPHBITSFieldAndOffset(sizlBitmap.cx); 
                  GetGLYPHBITSFieldAndOffset(sizlBitmap.cy); 

                  rcGlyph.left   = ptl.x   + ptlOrigin.x;
                  rcGlyph.top    = ptl.y   + ptlOrigin.y;
                  rcGlyph.right  = rcGlyph.left + sizlBitmap.cx;
                  rcGlyph.bottom = rcGlyph.top  + sizlBitmap.cy;

                  if (
                      ( rcGlyph.left   < rclBkGround.left   ) ||
                      ( rcGlyph.right  > rclBkGround.right  ) ||
                      ( rcGlyph.top    < rclBkGround.top    ) ||
                      ( rcGlyph.bottom > rclBkGround.bottom )
                  )
                  {
                      pszOutOfBounds = " *** out of bounds ***";
                  }
              } /* if (pgb) */
          } /* if (pgdf) */
          dprintf(
              "   %-#10x %-#18p      %-10d %-10d%s\n"
              , hg
              , pgb        // print the CONTENTS of the GLYPHDEF
              , ptl.x
              , ptl.y
              , pszOutOfBounds
          );
          glyphposSrc += sizeOfGlyphPos;
      } /* for */
        dprintf("   ---------- ----------      ---------- ----------\n\n");
    }
    EXIT_API(S_OK);
stro_help:
    dprintf("!gdikdx.stro [-p] address\n"
            "-? print this message\n"
            "-p print glyph positions\n"
            "-h print header\n"
            "-e far east\n");

    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dstro
*
\**************************************************************************/

DECLARE_API( dstro )
{
    dprintf("Extension 'dstro' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\n");
    dprintf("gdikdx.dstro will soon be replaced by gdikdx.stro\n");
    dprintf("\n\n");
    stro(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Dumps monochrome bitmaps.
*
* History:
*  Sat 23-Sep-1995 08:26:43 by Kirk Olynyk [kirko]
* Re-wrote it.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( gb )
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'
    #define CH_GARBAGE         '+'
    

    ULONG64 glyphbitsSrc;
    ULONG       offset;

    BYTE     j, *pj8, *pj, *pjNext, *pjEnd;
    int      i, k, cj, cjScan, c4, c8, cLast;
    char     *pch;

    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];

    BOOL Gray=FALSE;
    BOOL Mono=FALSE;
    BOOL Header=FALSE;

    PARSE_POINTER(gb_help);
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'm')!=-1) {Mono=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'g')!=-1) {Gray=TRUE;}
    if(Mono&&Gray) {
      Gray=FALSE;
      dprintf("cannot have Monochrome and Gray simultaneously\n"
              "assuming Monochrome\n");
    }
    if(!(Header||Mono||Gray)) {
      Header=TRUE;
      Mono=TRUE;
    }

    //arg from PARSE_POINTER() above.
    glyphbitsSrc = arg;

    GetGLYPHBITSFieldAndOffset(ptlOrigin.x); 
    GetGLYPHBITSFieldAndOffset(ptlOrigin.y); 
    GetGLYPHBITSFieldAndOffset(sizlBitmap.cx); 
    GetGLYPHBITSFieldAndOffset(sizlBitmap.cy); 

    // header information
    if (Header) {
        dprintf(
            "ptlOrigin  = (%d,%d)\n"
            "sizlBitmap = (%d,%d)\n"
            "\n\n"
            , ptlOrigin.x
            , ptlOrigin.y
            , sizlBitmap.cx
            , sizlBitmap.cy
        );
    }
    // do stuff common to monochrome and gray glyphs
    if (Mono||Gray) {
        if ( sizlBitmap.cx > 150 ) {
            dprintf("\nBitmap is wider than 150 characters\n");
            EXIT_API(S_OK);
        }
        // cjScan = number of bytes per scan
        if (Mono) {
            cjScan = (sizlBitmap.cx + 7)/8;  // 8 pixels per byte
        } else
            cjScan = (sizlBitmap.cx + 1)/2;  // 2 pixels per byte
        // cj = number of bytes in image bits (excluding header)
        if ( ( cj = cjScan * sizlBitmap.cy ) > sizeof(adw) ) {
            dprintf( "\nThe bits will blow out the buffer\n" );
            EXIT_API(S_OK);
        }

        GetGLYPHBITSFieldAndOffset(aj[0]); 

        ReadMemory((ULONG_PTR) (glyphbitsSrc + offset), adw, cj, NULL);
        dprintf("\n\n  ");           // leave space for number and vertical bar
        for (i = 0, k = 0; i < sizlBitmap.cx; i++, k++) {
            k = (k > 9) ? 0 : k;                // print x-coordinates (mod 10)
            dprintf("%1d", k);
        }                                       // go to new line
        dprintf("\n %c",CH_TOP_LEFT_CORNER);    // leave space for number
        for (i = 0; i < sizlBitmap.cx; i++)  // and then mark corner
            dprintf("%c",CH_HORIZONTAL_BAR);    // fill out horizontal line
        dprintf("\n");                          // move down to scan output
    }
    // monochrome glyph
    if (Mono)
    {
        static char ach[16*4] = {
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON
        };

        i      = sizlBitmap.cx;
        c8     = i / 8;     // c8 = number of whole bytes
        i      = i % 8;     // i = remaining number of pixels = 0..7
        c4     = i / 4;     // number of whole nybbles        = 0..1
        cLast  = i % 4;     // remaining number of pixels     = 0..3

        // k      = row number
        // pjEnd  = pointer to address of scan beyond last scan
        // pjNext = pointer to next scan
        // pj     = pointer to current byte
        // for each scan ...

        for (
            pj = (BYTE*)adw, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0 ;
            pjNext < pjEnd                                           ;
            pj=pjNext , pjNext+=cjScan, k++
        )
        {
            if (CheckControlC())
                EXIT_API(S_OK);

            k = (k > 9) ? 0 : k;

            // print row number (mod 10) followed by a vertical bar ...

            dprintf("%1d%c",k,CH_VERTICAL_BAR);

            // then do the pixels of the scan ...
            // whole bytes first ...

            for (pj8 = pj+c8 ; pj < pj8; pj++)
            {
                // high nybble first ...

                pch = ach + 4 * (*pj >> 4);
                dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);

                // low nybble next ...

                pch = ach + 4 * (*pj & 0xf);
                dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);
            }

            // last partial byte ...

            if (c4 || cLast)
            {
                // high nybble first ...

                pch = ach + 4 * (*pj >> 4);

                if (c4)
                {
                    // print the entire high nybble ...

                    dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);

                    // go to the low nybble ...

                    pch = ach + 4 * (*pj & 0xf);
                }

                // last partial nybble ...

                switch(cLast)
                {
                case 3: dprintf("%c",*pch++);
                case 2: dprintf("%c",*pch++);
                case 1: dprintf("%c",*pch);
                }

                //
                // print any extraneous bits
                //
                for (j = *pj << i; j; j <<= 1)
                {
                    if ( j & 0x80 )
                    {
                        dprintf("%c",CH_GARBAGE);
                    }
                }

            }
            dprintf("\n");
        }
    }
    // gray glyph
    if (Gray)
    {
        static char achGray[16] = {
            CH_PIXEL_OFF,
            '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
            CH_PIXEL_ON
        };
        c8 = sizlBitmap.cx / 2; // number of whole bytes;
        c4 = sizlBitmap.cx % 2; // number of whole nybbles;
        // k      = row number
        // pjEnd  = pointer to address of scan beyond last scan
        // pjNext = pointer to next scan
        // pj     = pointer to current byte
        // for each scan ...
        for (
            pj = (BYTE*)adw, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0 ;
            pjNext < pjEnd                                           ;
            pj=pjNext , pjNext+=cjScan, k++
        )
        {
            if (CheckControlC())
                EXIT_API(S_OK);
            k = (k > 9) ? 0 : k;
            // print row number (mod 10) followed by a vertical bar ...
            dprintf("%1d%c",k,CH_VERTICAL_BAR);
            // then do the pixels of the scan ...
            // whole bytes first ...
            for (pj8 = pj+c8 ; pj < pj8; pj++)
                dprintf("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
            // last partial byte ...
            if (c4)
                dprintf("%c", achGray[*pj >> 4]);
            dprintf("\n");
        }
    }
    EXIT_API(S_OK);

gb_help:
    dprintf("Usage: gb [-?] [-g|-m] [-h] address\n"
            "   -?    this message\n"
            "   -h    print header\n"
            "   -m    print monochrome bitmap\n"
            "   -g    print 4-bpp bitmap\n"
            "If no flags are supplied, -m -h assumed.\n"
            "Cannot supply -m and -g together.");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpCOLORADJUSTMENT
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpCOLORADJUSTMENT(COLORADJUSTMENT *pdca, COLORADJUSTMENT *pdcaSrc)
{
    FLAGDEF *pfd;
    FLONG fl;

    #define M3(aa,bb) \
        dprintf("[%x] %s%-#x\n", &(pdcaSrc->##aa), (bb), pdca->##aa)
    #define M2(aa,bb) \
        dprintf("[%x] %s", &(pdcaSrc->##aa), (bb))

    dprintf("\nCOLORADJUSTMENT\n address\n -------\n");
    M3( caSize           , "caSize            " );

    // caFlags

    M3( caFlags          , "caFlags           " );
    for ( fl = pdca->caFlags, pfd = afdCOLORADJUSTMENT; pfd->psz; pfd++)
        if (fl & pfd->fl) {
            dprintf("\t\t\t\t\t%s\n", pfd->psz);
            fl &= ~pfd->fl;
        }
    if (fl)
        dprintf("\t\t\t\t\tbad flags %-#x\n", fl);

    M3( caIlluminantIndex, "caIlluminantIndex " );
    M3( caRedGamma       , "caRedGamma        " );
    M3( caGreenGamma     , "caGreenGamma      " );
    M3( caBlueGamma      , "caBlueGamma       " );
    M3( caReferenceBlack , "caReferenceBlack  " );
    M3( caReferenceWhite , "caReferenceWhite  " );
    M3( caContrast       , "caContrast        " );
    M3( caBrightness     , "caBrightness      " );
    M3( caColorfulness   , "caColorfulness    " );
    M3( caRedGreenTint   , "caRedGreenTint    " );
    dprintf("\n");

    #undef M2
    #undef M3
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( gdf )
{
    dprintf("Extension 'gdf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHDEF gd;
    PARSE_POINTER(gdf_help);    
    move(gd, arg);
    dprintf("\n\nGLYPHDEF\n\n");
    dprintf("[%x] %-#x\n", arg, gd.pgb);
    dprintf("\n");
    return;
gdf_help:
    dprintf("Usage: gdf [-?] GLYPHDEF pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGLYPHPOS
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpGLYPHPOS(GLYPHPOS *p1, GLYPHPOS *p0)
{
    dprintf("\nGLYPHPOS\n\n");
    dprintf("[%x] hg   %-#x\n" , &p0->hg  , p1->hg  );
    dprintf("[%x] pgdf %-#x\n" , &p0->pgdf, p1->pgdf);
    dprintf("[%x] ptl  %d %d\n", &p0->ptl , p1->ptl.x, p1->ptl.y);
    dprintf("\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gp
*
\**************************************************************************/

DECLARE_API( gp )
{
    dprintf("Extension 'gp' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHPOS gp;
    PARSE_POINTER(gp_help);
    move(gp,arg);
    vDumpGLYPHPOS(&gp,(GLYPHPOS*)arg);
    return;
gp_help:
    dprintf("Usage: gp [-?] GLYPHPOS pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ca
*
\**************************************************************************/

DECLARE_API( ca )
{
    dprintf("Extension 'ca' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    COLORADJUSTMENT ca;
    PARSE_POINTER(ca_help);
    move(ca, arg);
    vDumpCOLORADJUSTMENT(&ca, (COLORADJUSTMENT*) arg);
    return;
ca_help:
    dprintf("Usage: ca [-?] COLORADJUSTMENT pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDATABLOCK
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpDATABLOCK(
    DATABLOCK *p,     // pointer to local DATABLOCK copy
    DATABLOCK *p0     // pointer to original DATABLOCK on debug machine
    )
{
    dprintf( "\nDATABLOCK\n address\n -------\n" );
    dprintf( "[%x] pdblNext %-#x\n", &(p0->pdblNext), p->pdblNext);
    dprintf( "[%x] cgd        %u\n",   &(p0->cgd       ), p->cgd       );
    dprintf( "\n" );
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpCACHE
*
\**************************************************************************/

void vDumpCACHE(ULONG64 cacheSrc)
{
    ULONG       offset;

    ULONG64 pgdNext;         // ptr to next free place to put GLYPHDATA
    ULONG64 pgdThreshold;    // ptr to first uncommited spot
    ULONG64      pjFirstBlockEnd; // ptr to end of first GLYPHDATA block
    ULONG64 pdblBase;        // ptr to base of current GLYPHDATA block
    ULONG      cMetrics;        // number of GLYPHDATA's in the metrics cache
    ULONG     cjbblInitial;     // size of initial bit block
    ULONG     cjbbl;            // size of any individual block in bytes
    ULONG     cBlocksMax;       // max # of blocks allowed
    ULONG     cBlocks;          // # of blocks allocated so far
    ULONG     cGlyphs;          // for statistical purposes only
    ULONG     cjTotal;          // also for stat purposes only
    ULONG64 pbblBase;         // ptr to the first bit block (head of the list)
    ULONG64 pbblCur;          // ptr to the block containing next
    ULONG64     pgbNext;          // ptr to next free place to put GLYPHBITS
    ULONG64     pgbThreshold;     // end of the current block
    ULONG64           pjAuxCacheMem;  // ptr to lookaside buffer, if any
    SIZE_T          cjAuxCacheMem;  // size of current lookaside buffer
    ULONG cjGlyphMax;          // size of largest glyph
    BOOL   bSmallMetrics;
    INT iMax;
    INT iFirst;
    INT cBits;
    

    #define GetAndPrintCACHEFieldAndOffset(expr, member) \
				GetCACHEFieldAndOffset(member); dprintf("[0x%p] " #expr "    " #member "\n", cacheSrc+offset, ##member)


    dprintf("\nCACHE\n address\n -------\n" );
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgdNext);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgdThreshold);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pjFirstBlockEnd);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pdblBase);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cMetrics);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjbbl);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBlocksMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBlocks);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cGlyphs);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjTotal);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pbblBase);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pbblCur);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgbNext);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgbThreshold);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pjAuxCacheMem);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjAuxCacheMem);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjGlyphMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, bSmallMetrics);
    GetAndPrintCACHEFieldAndOffset( %+#20x, iMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, iFirst);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBits);
    dprintf("\n");

    #undef M3
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cache
*
\**************************************************************************/

DECLARE_API( cache )
{
    PARSE_POINTER(cache_help);
    vDumpCACHE(arg);
    EXIT_API(S_OK);
cache_help:
    dprintf("Usage: cache [-?] CACHE pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpLOGFONTW
*
* Arguments:
*
*   plfw    -- pointer to local copy of LOGFONTW,
*              dereferences are off of this address are safe
*   plfwSrc -- address of original on debug machine,
*              dereferences off of this address are not safe
*
* Return Value:
*
*   none
*
\**************************************************************************/

void vDumpLOGFONTW(ULONG64 offLOGFONTW)
{
#define N3(a,b,c) \
        dprintf( "[%p] %s", offLOGFONTW + offset, (a)); dprintf( (b), ##c )
    
    // LOGFONTW

    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[LF_FACESIZE];

    ULONG     offset;
    
    dprintf("\nLOGFONTW\n address\n --------\n" );
    
    GetLOGFONTWFieldAndOffset(lfHeight);
    N3( "lfHeight         " , "%d\n"    , lfHeight         );
    
    GetLOGFONTWFieldAndOffset(lfWidth);
    N3( "lfWidth          " , "%d\n"    , lfWidth          );

    GetLOGFONTWFieldAndOffset(lfEscapement);
    N3( "lfEscapement     " , "%d\n"    , lfEscapement     );

    GetLOGFONTWFieldAndOffset(lfOrientation);
    N3( "lfOrientation    " , "%d\n"    , lfOrientation    );

    GetLOGFONTWFieldAndOffset(lfWeight);
    N3( "lfWeight         " , "%d"      , lfWeight         );
    dprintf(" = %s\n", pszFW(lfWeight) );
    
    GetLOGFONTWFieldAndOffset(lfItalic);
    N3( "lfItalic         " , "0x%02x\n"  , lfItalic         );
    
    GetLOGFONTWFieldAndOffset(lfUnderline);
    N3( "lfUnderline      " , "0x%02x\n"  , lfUnderline      );
    
    GetLOGFONTWFieldAndOffset(lfStrikeOut);
    N3( "lfStrikeOut      " , "0x%02x\n"  , lfStrikeOut      );
    
    GetLOGFONTWFieldAndOffset(lfCharSet);
    N3( "lfCharSet        " , "0x%02x"    , lfCharSet        );
    dprintf(" = %s\n", pszCHARSET(lfCharSet));
    
    GetLOGFONTWFieldAndOffset(lfOutPrecision);
    N3( "lfOutPrecision   " , "0x%02x"    , lfOutPrecision   );
    dprintf(" = %s\n", pszOUT_PRECIS(lfOutPrecision ));
        
    GetLOGFONTWFieldAndOffset(lfClipPrecision);
    N3( "lfClipPrecision  " , "0x%02x"    , lfClipPrecision  );
    dprintf(" = %s\n", pszCLIP_PRECIS(lfClipPrecision));
        
    GetLOGFONTWFieldAndOffset(lfQuality);
    N3( "lfQuality        " , "0x%02x"    , lfQuality        );
    dprintf(" = %s\n", pszQUALITY(lfQuality));

    GetLOGFONTWFieldAndOffset(lfPitchAndFamily);
    N3( "lfPitchAndFamily " , "0x%02x"    , lfPitchAndFamily );
    dprintf(" = %s\n", pszPitchAndFamily(lfPitchAndFamily ) );

    GetLOGFONTWFieldAndOffset(lfFaceName);
    dprintf("[%p] lfFaceName       \"%ws\"\n", offLOGFONTW + offset, lfFaceName);
    dprintf("\n");
    
#undef N3
    
    return;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpFONTDIFF
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpFONTDIFF(FONTDIFF *p1/*copy*/ , FONTDIFF *p0 /* original */)
{

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nFONTDIFF\n-------\n");
    N3("jReserved1      ", "0x%02x\n", jReserved1);
    N3("jReserved2      ", "0x%02x\n", jReserved2);
    N3("jReserved3      ", "0x%02x\n", jReserved3);
    N3("bWeight         ", "0x%02x", bWeight   );
    dprintf(" = %s\n", pszPanoseWeight(p1->bWeight));
    N3("usWinWeight     ", "%u"    , usWinWeight);
    dprintf(" = %s\n", pszFW(p1->usWinWeight));
    N3("fsSelection     ", "%-#x\n"  , fsSelection);
    for (FLAGDEF *pfd=afdFM_SEL; pfd->psz; pfd++) {
        if ((FLONG)p1->fsSelection & pfd->fl) {
            dprintf("                %s\n", pfd->psz);
        }
    }
    N3("fwdAveCharWidth ", "%d\n"    , fwdAveCharWidth);
    N3("fwdMaxCharInc   ", "%d\n"    , fwdMaxCharInc);
    N2("ptlCaret        ", ptlCaret);
    dprintf("%d %d\n", p1->ptlCaret.x, p1->ptlCaret.y);
    dprintf("\n");

    #undef N2
    #undef N3
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpIFIMETRICS
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpIFIMETRICS(IFIMETRICS *p1, IFIMETRICS *p0)
{
    FLONG fl;
    FLAGDEF *pfd;

    #define GETPTR(p,a) ((void*)(((BYTE*)(p))+(a)))

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nIFIMETICS\n address\n -------\n");
    N3("cjThis                ", "%u\n"    , cjThis                );
    N3("cjIfiExtra            ", "%u\n"    , cjIfiExtra            );
    N3("dpwszFamilyName       ", "%-#x"  ,  dpwszFamilyName        );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszFamilyName));
    N3("dpwszStyleName        ", "%-#x"  , dpwszStyleName          );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszStyleName));
    N3("dpwszFaceName         ", "%-#x"  , dpwszFaceName           );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszFaceName));
    N3("dpwszUniqueName       ", "%-#x"  , dpwszUniqueName         );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszUniqueName));
    N3("dpFontSim             ", "%-#x\n"  , dpFontSim             );
    N3("lEmbedId              ", "%-#x\n"  , lEmbedId              );
    N3("lItalicAngle          ", "%d\n"    , lItalicAngle          );
    N3("lCharBias             ", "%d\n"    , lCharBias             );
    N3("dpCharSets            ", "%-#x\n"  , dpCharSets            );

    if (p1->dpCharSets)
    {

        BYTE *pj0  = (BYTE *) GETPTR(p0,p1->dpCharSets);
        BYTE *pj1  = (BYTE *) GETPTR(p1,p1->dpCharSets);
        BYTE *pj1End = pj1 + 16; // number of charsets

        dprintf("    Supported Charsets: \n");
        for (; pj1 < pj1End; pj1++, pj0++)
            dprintf("[%x]\t\t\t%s\n", pj0, pszCHARSET(*pj1));
    }


    N3("jWinCharSet           ", "0x%02x", jWinCharSet           );
    dprintf(" %s\n", pszCHARSET(p1->jWinCharSet));

    N3("jWinPitchAndFamily    ", "0x%02x", jWinPitchAndFamily    );
    dprintf(" %s\n", pszPitchAndFamily(p1->jWinPitchAndFamily));


    N3("usWinWeight           ", "%u"    , usWinWeight           );
    dprintf(" %s\n", pszFW(p1->usWinWeight));

    N3("flInfo                ", "%-#x\n"  , flInfo                );
    for (fl=p1->flInfo,pfd=afdInfo;pfd->psz;pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fsSelection           ", "%-#x\n"  , fsSelection           );
    for (fl = p1->fsSelection, pfd = afdFM_SEL; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fsType                ", "%-#x\n"  , fsType                );
    for (fl=p1->fsType, pfd=afdFM_TYPE; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fwdUnitsPerEm         ", "%d\n"    , fwdUnitsPerEm         );
    N3("fwdLowestPPEm         ", "%d\n"    , fwdLowestPPEm         );
    N3("fwdWinAscender        ", "%d\n"    , fwdWinAscender        );
    N3("fwdWinDescender       ", "%d\n"    , fwdWinDescender       );
    N3("fwdMacAscender        ", "%d\n"    , fwdMacAscender        );
    N3("fwdMacDescender       ", "%d\n"    , fwdMacDescender       );
    N3("fwdMacLineGap         ", "%d\n"    , fwdMacLineGap         );
    N3("fwdTypoAscender       ", "%d\n"    , fwdTypoAscender       );
    N3("fwdTypoDescender      ", "%d\n"    , fwdTypoDescender      );
    N3("fwdTypoLineGap        ", "%d\n"    , fwdTypoLineGap        );
    N3("fwdAveCharWidth       ", "%d\n"    , fwdAveCharWidth       );
    N3("fwdMaxCharInc         ", "%d\n"    , fwdMaxCharInc         );
    N3("fwdCapHeight          ", "%d\n"    , fwdCapHeight          );
    N3("fwdXHeight            ", "%d\n"    , fwdXHeight            );
    N3("fwdSubscriptXSize     ", "%d\n"    , fwdSubscriptXSize     );
    N3("fwdSubscriptYSize     ", "%d\n"    , fwdSubscriptYSize     );
    N3("fwdSubscriptXOffset   ", "%d\n"    , fwdSubscriptXOffset   );
    N3("fwdSubscriptYOffset   ", "%d\n"    , fwdSubscriptYOffset   );
    N3("fwdSuperscriptXSize   ", "%d\n"    , fwdSuperscriptXSize   );
    N3("fwdSuperscriptYSize   ", "%d\n"    , fwdSuperscriptYSize   );
    N3("fwdSuperscriptXOffset ", "%d\n"    , fwdSuperscriptXOffset );
    N3("fwdSuperscriptYOffset ", "%d\n"    , fwdSuperscriptYOffset );
    N3("fwdUnderscoreSize     ", "%d\n"    , fwdUnderscoreSize     );
    N3("fwdUnderscorePosition ", "%d\n"    , fwdUnderscorePosition );
    N3("fwdStrikeoutSize      ", "%d\n"    , fwdStrikeoutSize      );
    N3("fwdStrikeoutPosition  ", "%d\n"    , fwdStrikeoutPosition  );
    N3("chFirstChar           ", "0x%02x\n", chFirstChar           );
    N3("chLastChar            ", "0x%02x\n", chLastChar            );
    N3("chDefaultChar         ", "0x%02x\n", chDefaultChar         );
    N3("chBreakChar           ", "0x%02x\n", chBreakChar           );
    N3("wcFirstChar           ", "%-#x\n"    , wcFirstChar           );
    N3("wcLastChar            ", "%-#x\n"    , wcLastChar            );
    N3("wcDefaultChar         ", "%-#x\n"    , wcDefaultChar         );
    N3("wcBreakChar           ", "%-#x\n"    , wcBreakChar           );
    N2("ptlBaseline           ", ptlBaseline);
        dprintf("%d %d\n", p1->ptlBaseline.x, p1->ptlBaseline.y);
    N2("ptlAspect             ", ptlAspect  );
        dprintf("%d %d\n", p1->ptlAspect.x, p1->ptlAspect.y);
    N2("ptlCaret              ", ptlCaret   );
        dprintf("%d %d\n", p1->ptlCaret.x, p1->ptlCaret.y);
    N2("rclFontBox            ", rclFontBox );
        dprintf("%d %d %d %d\n",
        p1->rclFontBox.left,
        p1->rclFontBox.top,
        p1->rclFontBox.right,
        p1->rclFontBox.bottom);
    N2("achVendId\n"        , achVendId[0]);
    N3("cKerningPairs         ", "%d\n"    , cKerningPairs         );
    N3("ulPanoseCulture       ", "%u\n"    , ulPanoseCulture       );
    N2("panose\n", panose);

    if (p1->dpFontSim) {
        FONTDIFF *pfd0, *pfd1;
        FONTSIM *pfs0 = (FONTSIM*) GETPTR(p0, p1->dpFontSim);
        FONTSIM *pfs1 = (FONTSIM*) GETPTR(p1, p1->dpFontSim);
        if (pfs1->dpBold) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpBold);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpBold);
            dprintf("\nBold Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
        if (pfs1->dpItalic) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpItalic);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpItalic);
            dprintf("\nItalic Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
        if (pfs1->dpBoldItalic) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpBoldItalic);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpBoldItalic);
            dprintf("\nBold Italic Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
    }

    if (p1->cjIfiExtra)
    {
        // #define GETIFIEX(a) ((ULONG)p1 + sizeof(IFIMETRICS) + offsetof(IFIEXTRA,##a))

        dprintf("\nIFIEXTRA\n -------\n");
        IFIEXTRA *pifiex = (IFIEXTRA *)(p1 + 1);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,ulIdentifier))
            dprintf("ulIdentifier:   0x%x\n", pifiex->ulIdentifier);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpFontSig))
            dprintf("dpFontSig:      0x%x\n", pifiex->dpFontSig);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,cig))
            dprintf("cig:            %u\n", pifiex->cig);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpDesignVector))
            dprintf("dpDesignVector: 0x%x\n", pifiex->dpDesignVector);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpAxesInfoW))
            dprintf("dpAxesInfoW:    0x%x\n", pifiex->dpAxesInfoW);

        dprintf("\n -------\n");
    }

    dprintf("\n");

    #undef N3
    #undef N2
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pff
*
\**************************************************************************/


DECLARE_API( pff )
{
    dprintf("Extension 'pff' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFF *pPFFCopy, *pPFFSrc;
    ULONG size;
    
    PARSE_POINTER(pff_help);
    pPFFSrc = (PFF *)arg;
    move(size,&pPFFSrc->sizeofThis);
    if (pPFFCopy = tmalloc(PFF, size)) {
        move2(pPFFCopy, pPFFSrc, size);
        PFFOBJ pffo(pPFFCopy);
        pPFFCopy->pwszPathname_ = pffo.pwszCalcPathname();
        vDumpPFF(pPFFCopy,pPFFSrc);
        tfree(pPFFCopy);
    } else
        dprintf("could not allocate memory\n");
    return;
pff_help:
    dprintf("Usage: pff [-?] PFF pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpPFF
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpPFF(PFF *p1 /*copy*/, PFF *p0 /*original*/)
{
    ULONG iFile;
    PWSZ  pwszSrc, pwszDest;

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    N3("sizeofThis    ", "%u\n", sizeofThis);
    N3("pPFFNext      ", "%-#x\n", pPFFNext);
    N3("pPFFPrev      ", "%-#x\n", pPFFPrev);

    if (p1->hff != HFF_INVALID) // if not device font
    {
    N2("pwszPathname_ ", pwszPathname_);
    move( pwszSrc, &p0->pwszPathname_ );
    pwszDest = wcsncpy((PWSZ) adw,  pwszSrc, sizeof(adw)/sizeof(WCHAR));
    if ( pwszDest )
    {
        dprintf("%-#x = \"%ws\"\n", pwszSrc, (PWSZ) adw );
    }
    else
    {
        dprintf("\n");
    }
    }

    N3("flState       ", "%-#x\n", flState);
    for (FLAGDEF *pfd = afdPFF; pfd->psz; pfd++) {
        if (p1->flState & pfd->fl) {
            dprintf("              %s\n", pfd->psz);
        }
    }
    N3("cwc           ", "%u\n", cwc);
    N3("cFiles        ", "%u\n", cFiles);
    N3("cLoaded       ", "%u\n", cLoaded);
    N3("cNotEnum      ", "%u\n", cNotEnum);
    N3("cRFONT        ", "%u\n", cRFONT);
    N3("prfntList     ", "%-#x\n", prfntList);
    N3("hff           ", "%-#x\n", hff);
    N3("hdev          ", "%-#x\n", hdev);
    N3("dhpdev        ", "%-#x\n", dhpdev);
    N3("pfhFace       ", "%-#x\n", pfhFace);
    N3("pfhFamily     ", "%-#x\n", pfhFamily);
    N3("pfhUFI        ", "%-#x\n", pfhUFI);
    N3("pPFT          ", "%-#x\n", pPFT);
    N3("ulCheckSum    ", "%-#x\n", ulCheckSum);
    N3("cFonts        ", "%u\n", cFonts);
    N3("ppfv          ", "%-#x\n", ppfv);
    N3("pPvtDataHead  ", "%-#x\n", pPvtDataHead);
    dprintf("\n\n");

    #undef N3
    #undef N2
}

///******************************Public*Routine******************************\
//*
//* Routine Name:
//*
//*   vDumpFONTHASH
//*
//\**************************************************************************/
//
//void vDumpFONTHASH(FONTHASH *p1 /*copy*/,FONTHASH *p0 /*org*/)
//{
//    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
//    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)
//
//    dprintf("\nFONTHASH\n");
//    N3("id            ", "%4x\n", id);
//    N3("fht           ", "%d",    fht);
//    dprintf(" = %s\n", pszFONTHASHTYPE(p1->fht));
//    N3("cBuckets      ", "%u\n", cBuckets);
//    N3("cCollisions   ", "%u\n", cCollisions);
//    N3("pbktFirst     ", "%-#x\n", pbktFirst);
//    N3("pbktLast      ", "%-#x\n", pbktLast);
//    N3("apbkt         ", "%-#x\n", apbkt);
//
//    #undef N3
//   #undef N2
//}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpHASHBUCKET
*
\**************************************************************************/

void vDumpHASHBUCKET(HASHBUCKET *p1 /*copy*/, HASHBUCKET *p0 /*org*/)
{
    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nHASHBUCKET\n");
    N3("pbktCollision   ", "%-#x\n", pbktCollision);
    N3("ppfelEnumHead   ", "%-#x\n", ppfelEnumHead);
    N3("ppfelEnumTail   ", "%-#x\n", ppfelEnumTail);
    N3("cTrueType       ", "%u\n",   cTrueType);
    N3("fl              ", "%-#x\n", fl);
    N3("pbktPrev        ", "%-#x\n", pbktPrev);
    N3("pbktNext        ", "%-#x\n", pbktNext);
    N3("ulTime          ", "%u\n",   ulTime);
    N2("u\n", u);

    N2("u.wcCapName     ", u.wcCapName);
    wcscpy((PWSZ) adw, p1->u.wcCapName);
    dprintf("\"%ws\"\n", adw);

    N2("u.ufi\n", u.ufi);
    N3("u.ufi.CheckSum  ", "%-#x\n", u.ufi.CheckSum);
    N3("u.ufi.Index     ", "%u\n",   u.ufi.Index);



    {

        dprintf("\n");

        {
            PFELINK *ppfel = p1->ppfelEnumHead;
            PFELINK  pfelLocal;

            PFE LocalPFE;

            if (ppfel)
            {
                dprintf("PFE*\n");
                while (ppfel)
                {
                    move(pfelLocal, ppfel);
                    dprintf("%-#x", pfelLocal.ppfe);
                    move(LocalPFE,pfelLocal.ppfe);

                    if (LocalPFE.pPFF)
                    {
                        PFF LocalPFF;
                        WCHAR awc[MAX_PATH];

                        move(LocalPFF, LocalPFE.pPFF);
                        wcsncpy( awc, LocalPFF.pwszPathname_, MAX_PATH);
                        awc[MAX_PATH-1]=0;
                        dprintf(" \"%ws\"", awc);
                    }

                    if (LocalPFE.pifi)
                    {
                        ULONG dp;
                        WCHAR awc[LF_FACESIZE+1];
                        PWSZ pwszSrc;
                        FWORD fwdAscender, fwdDescender, fwdWidth;

                        move(dp,&((LocalPFE.pifi)->dpwszFaceName));
                        pwszSrc = (PWSZ)(((char*) (LocalPFE.pifi)) + dp);
                        wcsncpy(awc, pwszSrc, LF_FACESIZE);
                        awc[LF_FACESIZE] = 0;
                        dprintf(" \"%ws\"", awc);

                        move(fwdAscender, &LocalPFE.pifi->fwdWinAscender);
                        move(fwdDescender, &LocalPFE.pifi->fwdWinDescender);
                        move(fwdWidth, &LocalPFE.pifi->fwdAveCharWidth);

                        dprintf(" %4d %4d %4d", fwdAscender, fwdDescender, fwdWidth);

                    }

                    dprintf("\n");

                    ppfel = pfelLocal.ppfelNext;
                }
            }
        }
    }

    #undef N3
    #undef N2
}

void vDumpTEXTMETRICW(TEXTMETRICW *ptmLocal, TEXTMETRICW *ptmRemote)
{
    #define N3(a,b,c) dprintf("[%x] %s", &ptmRemote->##c, (a)); dprintf((b),ptmLocal->##c)

    dprintf("\nTEXTMETRICW\n");
    N3("tmHeight            ", "%d\n",    tmHeight           );
    N3("tmAscent            ", "%d\n",    tmAscent           );
    N3("tmDescent           ", "%d\n",    tmDescent          );
    N3("tmInternalLeading   ", "%d\n",    tmInternalLeading  );
    N3("tmExternalLeading   ", "%d\n",    tmExternalLeading  );
    N3("tmAveCharWidth      ", "%d\n",    tmAveCharWidth     );
    N3("tmMaxCharWidth      ", "%d\n",    tmMaxCharWidth     );
    N3("tmWeight            ", "%d\n",    tmWeight           );
    N3("tmOverhang          ", "%d\n",    tmOverhang         );
    N3("tmDigitizedAspectX  ", "%d\n",    tmDigitizedAspectX );
    N3("tmDigitizedAspectY  ", "%d\n",    tmDigitizedAspectY );
    N3("tmFirstChar         ", "%-#6x\n", tmFirstChar        );
    N3("tmLastChar          ", "%-#6x\n", tmLastChar         );
    N3("tmDefaultChar       ", "%-#6x\n", tmDefaultChar      );
    N3("tmBreakChar         ", "%-#6x\n", tmBreakChar        );
    N3("tmItalic            ", "%-#4x\n", tmItalic           );
    N3("tmUnderlined        ", "%-#4x\n", tmUnderlined       );
    N3("tmStruckOut         ", "%-#4x\n", tmStruckOut        );
    N3("tmPitchAndFamily    ", "%-#4x\n", tmPitchAndFamily   );
    N3("tmCharSet           ", "%-#4x\n", tmCharSet          );

    dprintf("\n");
    #undef N3
}

void vDumpTMDIFF(TMDIFF *ptmdLocal, TMDIFF *ptmdRemote)
{
    #define N3(a,b,c) dprintf("[%x] %s", &ptmdRemote->##c, (a)); dprintf((b),ptmdLocal->##c)

    dprintf("\nTMDIFF\n");
    N3("cjotma              ", "%u\n",    cjotma             );
    N3("chFirst             ", "%-#4x\n", chFirst            );
    N3("chLast              ", "%-#4x\n", chLast             );
    N3("chDefault           ", "%-#4x\n", chDefault          );
    N3("chBreak             ", "%-#4x\n", chBreak            );

    dprintf("\n");
    #undef N3
}
#endif 0   // DOES NOT SUPPORT API64

DECLARE_API( tmwi )
{
    dprintf("Extension 'tmwi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    TMW_INTERNAL tmwi, *ptmwi;
   
    PARSE_POINTER(tmwi_help);
    ptmwi = (TMW_INTERNAL *)arg;
    move(tmwi, ptmwi);
    vDumpTEXTMETRICW(&tmwi.tmw, &ptmwi->tmw);
    vDumpTMDIFF(&tmwi.tmdTmw, &ptmwi->tmdTmw);
    return;
tmwi_help:
    dprintf("Usage: tmwi [-?] TMW_INTERNAL pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( tm )
{
    dprintf("Extension 'tm' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    TEXTMETRICW tm;
    PARSE_POINTER(tm_help);
    move(tm, arg);
    vDumpTEXTMETRICW(&tm, (TEXTMETRICW*) arg);
    return;
tm_help:
    dprintf("Usage: tm [-?] TEXTMETRIC pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   fh
*
\**************************************************************************/

DECLARE_API( fh )
{
    dprintf("Extension 'fh' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FONTHASH fh;
    PARSE_POINTER(fh_help);
    move(fh, arg);
    vDumpFONTHASH( &fh, (FONTHASH*) arg);
    return;
fh_help:
    dprintf("Usage: fh [-?] FONTHASH pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   hb
*
\**************************************************************************/

DECLARE_API( hb )
{
    dprintf("Extension 'hb' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    HASHBUCKET hb;
    PARSE_POINTER(hb_help);
    move(hb, arg);
    vDumpHASHBUCKET(&hb, (HASHBUCKET*) arg);
    return;
hb_help:
    dprintf("Usage: hb [-?] HASHBUCKET pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cjGLYPHBITS
*
* Routine Description:
*
*   Calculates the amount of memory associated with a GLYPHBITS structure
*
* Arguments:
*
*   pgb     pointer to GLYPHBITS structure
*   prf     pointer to RFONT
*
* Return Value:
*
*   count of byte's
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
unsigned cjGLYPHBITS(GLYPHBITS *pgb, RFONT *prf)
{
    unsigned cj = 0;
    if (pgb) {
        if (prf->ulContent & FO_GLYPHBITS) {
            cj = offsetof(GLYPHBITS, aj);
            cj = (cj + 3) & ~3;
            unsigned cjRow = pgb->sizlBitmap.cx;
            if (prf->fobj.flFontType & FO_GRAY16)
                cjRow = (cjRow+1)/2;
            else
                cjRow = (cjRow+7)/8;
            cj += pgb->sizlBitmap.cy * cjRow;
            cj = (cj + 3) & ~3;
        }
    }
    return( cj );
}
#endif 0   // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGlyphMemory
*
* Routine Description:
*
*   Dumps the memory usage for the glyphs associated with an RFONT
*
* Arguments:
*
*   pRemoteRFONT        pointer to a remote RFONT
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpGlyphMemory(RFONT *pRemoteRFONT)
{
    unsigned cj;
    if (!pRemoteRFONT)
        return;
    RFONT rf;
    move(rf, pRemoteRFONT);
    if ( rf.wcgp ) {
        WCGP wcgp;
        move(wcgp, rf.wcgp);
        cj = offsetof(WCGP,agpRun[0]) + wcgp.cRuns * sizeof(GPRUN);
        WCGP *pWCGP;
        if ( pWCGP = tmalloc(WCGP, cj) ) {
            move2(pWCGP, rf.wcgp, cj);
            dprintf("------------------\n");
            dprintf("character     size\n");
            dprintf("------------------\n");
            GPRUN *pRun = pWCGP->agpRun;
            GPRUN *pRunSentinel = pRun + pWCGP->cRuns;
            for (; pRun < pRunSentinel ; pRun++ ) {
                if (!pRun->apgd)
                    continue;
                cj = sizeof(GLYPHDATA*) * pRun->cGlyphs;
                GLYPHDATA **apgd;
                if (!(apgd = tmalloc(GLYPHDATA*, cj)))
                    continue;
                move2(apgd, pRun->apgd, cj);
                unsigned wc = pRun->wcLow;
                unsigned wcSentinel = wc + pRun->cGlyphs;
                GLYPHDATA **ppgd = apgd;
                for (; wc < wcSentinel; wc++, ppgd++) {
                    if (!*ppgd)
                        continue;
                    GLYPHDEF gdf;
                    move(gdf, &((*ppgd)->gdf));
                    if (gdf.pgb) {
                        GLYPHBITS gb;
                        move(gb, gdf.pgb);
                        cj = cjGLYPHBITS(&gb, &rf);
                        dprintf("%-#8x  %8u\n", wc, cj);
                    }
                }
                tfree(apgd);
            }
            dprintf("------------------\n");


            tfree(pWCGP);
        }
    }
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pdev
*
* Routine Description:
*
*   Alternate version of PDEV dumper
*
* Arguments:
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
char *pszDrvProcName(int index);

DECLARE_API( pdev )
{
    dprintf("Extension 'pdev' is not converted.\n");
    PDEV _pdev, *pPDEV;
    RFONT rf, *prf;
    CACHE cache;
    BOOL HookFn=FALSE;
    BOOL GlyphMem=FALSE;
    BOOL MemAddr=FALSE;

    PARSE_POINTER(pdev_help);
    pPDEV = (PDEV *)arg;

    if(parse_iFindSwitch(tokens, ntok, 'y')!=-1) {GlyphMem=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'o')!=-1) {MemAddr=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {HookFn=TRUE;}

    move( _pdev, arg );

    if (GlyphMem) {
        dprintf("\n\nGlyph Bits Memory Allocation\n\n");

        dprintf("cMetrics, cGlyphs, cjTotal, Total/Max, cBlocks,  Ht, Wd, cjGlyphMax, FaceName\n");

        unsigned cTouchedTotal, cAllocTotal, cjWastedTotal, cjAllocTotal;
        cTouchedTotal = cAllocTotal = cjWastedTotal = cjAllocTotal = 0;
        dprintf("[Active Fonts]\n");
        vDumpRFONTList(
            _pdev.prfntActive,
            &cTouchedTotal,
            &cAllocTotal,
            &cjWastedTotal,
            &cjAllocTotal
            );
        dprintf("[Inactive Fonts]\n");
        vDumpRFONTList(
            _pdev.prfntInactive,
            &cTouchedTotal,
            &cAllocTotal,
            &cjWastedTotal,
            &cjAllocTotal
            );
    }

    //
    // offsets
    //

    if (MemAddr)
    {
    #define N2(a,c)   dprintf("[%x] %s\n", &pPDEV->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &pPDEV->##c, (a)); dprintf((b),_pdev.##c)

    N3( "                  hHmgr ", "%-#x\n", hHmgr                   );
    N3( "         cExclusiveLock ", "%-#x\n", cExclusiveLock          );
    N3( "                    Tid ", "%-#x\n", Tid                     );
    N3( "              ppdevNext ", "%-#x\n", ppdevNext               );
    N3( "              cPdevRefs ", "%-#x\n", cPdevRefs               );
    N3( "  pfnDrvSetPointerShape ", "%-#x\n", pfnDrvSetPointerShape   );
    N3( "      pfnDrvMovePointer ", "%-#x\n", pfnDrvMovePointer       );
    N3( "         pfnMovePointer ", "%-#x\n", pfnMovePointer          );
    N3( "                pfnSync ", "%-#x\n", pfnSync                 );
    N3( "                  pldev ", "%-#x\n", pldev                   );
    N3( "                 dhpdev ", "%-#x\n", dhpdev                  );
    N3( "               ppalSurf ", "%-#x\n", ppalSurf                );
    N2( "                devinfo ",           devinfo                 );
    N2( "                GdiInfo ",           GdiInfo                 );
    N3( "               pSurface ", "%-#x\n", pSurface                );
    N3( "               hSpooler ", "%-#x\n", hSpooler                );
    N2( "              ptlOrigin ",           ptlOrigin               );
    N2( "      eDirectDrawGlobal ",           eDirectDrawGlobal       );
    N3( "            ppdevParent ", "%-#x\n", ppdevParent             );
    N3( "                     fl ", "%-#x\n", fl                      );
    N3( "            hsemDevLock ", "%-#x\n", hsemDevLock             );
    N2( "            hsemPointer ",           hsemPointer             );
    N2( "             ptlPointer ",           ptlPointer              );
    N3( "           hlfntDefault ", "%-#x\n", hlfntDefault            );
    N3( "      hlfntAnsiVariable ", "%-#x\n", hlfntAnsiVariable       );
    N3( "         hlfntAnsiFixed ", "%-#x\n", hlfntAnsiFixed          );
    N2( "                 ahsurf ",           ahsurf                  );
    N3( "           pwszDataFile ", "%-#x\n", pwszDataFile            );
    N3( "             pDevHTInfo ", "%-#x\n", pDevHTInfo              );
    N3( "            prfntActive ", "%-#x\n", prfntActive             );
    N3( "          prfntInactive ", "%-#x\n", prfntInactive           );
    N3( "              cInactive ", "%-#x\n", cInactive               );
    N2( "                   ajbo ",           ajbo                    );
    N3( "cDirectDrawDisableLocks ", "%-#x\n", cDirectDrawDisableLocks );
    N3( "            TypeOneInfo ", "%-#x\n", TypeOneInfo             );
    N3( "          RemoteTypeOne ", "%-#x\n", RemoteTypeOne           );
    N2( "                   apfn ",           apfn                    );

    #undef N3
    #undef N2
    }

    if (HookFn)
    {
        dprintf("\nDispatch Table\n");

        for (int i = 0; i < INDEX_LAST; i++)
        {
            if (_pdev.apfn[i])
            {
                dprintf("[%-#x] %-#10x %s\n", &(pPDEV->apfn[i]), _pdev.apfn[i], pszDrvProcName(i));
            }
        }
        dprintf("\n");
    }
    return;
pdev_help:
    dprintf("Usage: pdev [-?] [-o] [-f] [-y] pointer to a PDEV\n");
    dprintf("-y     glyph memory usage\n");
    dprintf("-o     memory addresses\n");
    dprintf("-f     functions hooked\n");
    EXIT_API(S_OK);
}
#endif  // DOES NOT SUPPORT API64


DECLARE_API( fdm )
{
    dprintf("Extension 'fdm' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FD_DEVICEMETRICS Fdm, *pFdm;
    FLONG fl;
    char ach[128], *psz;
    FLAGDEF *pfd;

    PARSE_POINTER(fdm_help);
    pFdm = (FD_DEVICEMETRICS *)arg;
    move( Fdm, arg );

    #define N2(a,c)   dprintf("[%x] %s", &pFdm->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &pFdm->##c, (a)); dprintf((b),Fdm.##c)

    N3("flRealizedType         ", "%-#x\n", flRealizedType);
    fl = Fdm.flRealizedType;
    for (pfd=afdFDM; pfd->psz; pfd++) {
        if (pfd->fl & fl)
            dprintf("\t\t\t       %s\n", pfd->psz);
        fl &= ~pfd->fl;
    }

    N2("pteBase                ", pteBase);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.pteBase.x );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.pteBase.y );
    dprintf("%s\n", ach);

    N2("pteSide                ", pteSide);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.pteSide.x );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.pteSide.y );
    dprintf("%s\n", ach);

    N3("lD                     ", "%d\n", lD);
    N3("fxMaxAscender          ", "%-#x\n", fxMaxAscender);
    N3("fxMaxDescender         ", "%-#x\n", fxMaxDescender);

    N2("ptlUnderline1          ", ptlUnderline1);
    dprintf("%d %d\n", Fdm.ptlUnderline1.x, Fdm.ptlUnderline1.y);

    N2("ptlStrikeOut           ", ptlStrikeOut );
    dprintf("%d %d\n", Fdm.ptlStrikeOut.x,  Fdm.ptlStrikeOut.y );

    N2("ptlULThickness         ", ptlULThickness);
    dprintf("%d %d\n", Fdm.ptlULThickness.x, Fdm.ptlULThickness.y);

    N2("ptlSOThickness         ", ptlSOThickness);
    dprintf("%d %d\n", Fdm.ptlSOThickness.x, Fdm.ptlSOThickness.y);

    N3("cxMax                  ", "%-#x\n", cxMax);
    N3("cyMax                  ", "%-#x\n", cyMax);
    N3("cjGlyphMax             ", "%-#x\n", cjGlyphMax);

    N2("fdxQuantized           ", fdxQuantized);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eXX );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eXY );
    dprintf("%s\n", ach);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eYX );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eYY );
    dprintf("\t\t\t\t  %s\n", ach);

    N3("lNonLinearExtLeading   ", "%-#x\n", lNonLinearExtLeading);
    N3("lNonLinearIntLeading   ", "%-#x\n", lNonLinearIntLeading);
    N3("lNonLinearMaxCharWidth ", "%-#x\n", lNonLinearMaxCharWidth);
    N3("lNonLinearAvgCharWidth ", "%-#x\n", lNonLinearAvgCharWidth);
    N3("lMinA                  ", "%-#x\n", lMinA );
    N3("lMinC                  ", "%-#x\n", lMinC );
    N3("lMinD                  ", "%-#x\n", lMinD );
    N3("alReserved[0]          ", "%-#x\n", alReserved[0]);


    /*
    FLONG  flRealizedType
   POINTE  pteBase
   POINTE  pteSide
     LONG  lD
      FIX  fxMaxAscender
      FIX  fxMaxDescender
   POINTL  ptlUnderline1
   POINTL  ptlStrikeOut
   POINTL  ptlULThickness
   POINTL  ptlSOThickness
    ULONG  cxMax;
    ULONG  cyMax;
    ULONG  cjGlyphMax;
 FD_XFORM  fdxQuantized
     LONG  lNonLinearExtLeading
     LONG  lNonLinearIntLeading
     LONG  lNonLinearMaxCharWidth
     LONG  lNonLinearAvgCharWidth
     LONG  lMinA
     LONG  lMinC
     LONG  lMinD
     LONG  alReserved
     */

    #undef N3
    #undef N2
    return;
fdm_help:
    dprintf("Usage: fdm [-?] pointer to FD_DEVICEMETRICS structure.\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpRFONTList
*
* Routine Description:
*
*   Dump the memory allocation information for the RFONT structures
*   along the linked list.
*
* Arguments:
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpRFONTList(
    RFONT *prfRemote,
    unsigned *pcTouchedTotal,
    unsigned *pcAllocTotal,
    unsigned *pcjWastedTotal,
    unsigned *pcjAllocTotal
    )
{

    RFONT rf, *prf;

    for (prf = prfRemote; prf; prf = rf.rflPDEV.prfntNext) {
        move( rf, prf );
        if (rf.ppfe) {
            PFE _pfe;
            move(_pfe, rf.ppfe);
            if (_pfe.pifi) {
                unsigned cjIFI;
                move(cjIFI, &(_pfe.pifi->cjThis));
                if (cjIFI) {
                    IFIMETRICS *pifi;
                    if (pifi = tmalloc(IFIMETRICS, cjIFI)) {
                        // Create an IFIOBJ to get the face name
                        // out of the IFIMETRICS structure
                        move2(pifi, (_pfe.pifi), cjIFI);
                        IFIOBJ ifio(pifi);

                        dprintf("%8d, %5d,%8d,%8d,%8d,%8d,%4d,%4d,%ws\n",
                           rf.cache.cMetrics,
                           rf.cache.cGlyphs,
                           rf.cache.cjTotal,
                           (rf.cache.cjTotal + rf.cache.cjGlyphMax/2) / rf.cache.cjGlyphMax,
                           rf.cache.cBlocks,
                           rf.lMaxHeight, rf.cxMax,
                           rf.cache.cjGlyphMax,
                           ifio.pwszFaceName()
                           );
                        tfree(pifi);
                    }
                }
            }
        }
    }
}
#endif 0   // DOES NOT SUPPORT API64

DECLARE_API ( dispcache )
{
    dprintf("Extension 'dispcache' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PDEV *pPDEV;
    char ach[32];
    PARSE_ARGUMENTS(dispcache_help);
    GetValue( pPDEV, "win32k!ghdev");
    sprintf(ach, "-y %p", pPDEV);
    pdev( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, ach );
    return;
dispcache_help:
    dprintf("Usage: dispcache [-?]\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API ( xo )
{
    dprintf("Extension 'xo' is not converted.\n");
    dprintf("Use 'dt win32k!EXFORMOBJ Address' and '!gdikdx.mx Matrix_Address'\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    EXFORMOBJ xo, *pxo;
    MATRIX mx;
    
    PARSE_POINTER(xo_help);
    pxo = (EXFORMOBJ *)arg;
    move(xo, pxo);
    dprintf("EXFORMOBJ\n");
    dprintf("[%8x]  %8x\n", &pxo->pmx, xo.pmx);
    dprintf("[%8x]  %8x\n", &pxo->ulMode, xo.ulMode);
    if ( xo.pmx ) {
        move( mx, xo.pmx );
        vDumpMATRIX( &mx, xo.pmx );
    }
    return;
xo_help:
    dprintf("Usage: xo [-?] EXFORMOBJ pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\gdiexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: gdiexts.cxx
*
* Copyright (c) 1995-2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// TODO: Break this file up grouping close knit extensions together.


#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintBLTRECORD(VOID  *pv);
void vDumpLOGFONTW(LOGFONTW*, LOGFONTW*);

#endif  // DOES NOT SUPPORT API64

//
// This function is used for writing DIB images to disk in BMP format
// from a debugger extension.
//

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
#define DIBDBG
int WriteDIBToFile(void *pBits, DWORD w, DWORD h,
                   LONG byte_width, int colordepth,
                   void *pPal, DWORD palentries,
                   char *filename) {
  FILE *fp;
  VOID *pvTmpBits=NULL;
  VOID *pvTmpPal=NULL;
  int r;

  #ifdef DIBDBG
    dprintf("input:\n");
    dprintf("pBits: %p\n", pBits);
    dprintf("width: %ld\n", w);
    dprintf("height: %ld\n", h);
    dprintf("byte width: %ld\n", byte_width);
    dprintf("color depth: %ld\n", colordepth);
    dprintf("pPal: %p\n", pPal);
    dprintf("palette entries: %ld\n", palentries);
    dprintf("filename: %s\n", filename);
  #endif

  dprintf("starting\n");
  if((fp = fopen(filename, "wb")) == NULL) {
    dprintf("Error opening %s\n", filename);
    dprintf("If you're using a share, make sure the share is writeable by the machine running the debugger\n");
    return 1;
  }

  dprintf("opened\n");

  if((pPal==NULL)&&(palentries!=0)) {
    dprintf("Palette pointer is NULL, but palentries is %ld (should be 0)\n", palentries);
    fclose(fp);
    return 2;
  }

  if(byte_width<0) {
    dprintf("Upside down DIB, inverting...\n");
    byte_width = -byte_width;
  }

  //write the file header
  BITMAPFILEHEADER bfh;
  bfh.bfType='MB';    //backwords 'BM'
  bfh.bfSize = (DWORD)byte_width*h+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
  bfh.bfReserved1=0;
  bfh.bfReserved2=0;
  bfh.bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*palentries;
  r = fwrite(&bfh, sizeof(bfh), 1, fp);
  if(!r) {
    dprintf("Error writing file header\n");
    fclose(fp);
    return 5;
  }
  dprintf("header\n");

  //write the BITMAPINFOHEADER
  BITMAPINFOHEADER bih;
  bih.biSize = sizeof(BITMAPINFOHEADER);
  bih.biWidth = (LONG)w;
  bih.biHeight = (LONG)h;
  bih.biPlanes = 1;
  bih.biBitCount = (WORD)colordepth;
  bih.biCompression = 0;
  bih.biSizeImage = 0;
  bih.biXPelsPerMeter = 0;
  bih.biYPelsPerMeter = 0;
  bih.biClrUsed = 0;
  bih.biClrImportant = 0;
  r = fwrite(&bih, sizeof(bih), 1, fp);
  if(!r) {
    dprintf("Error writing header\n");
    fclose(fp);
    return 4;
  }
  dprintf("header\n");

  //write out the palette - if one exists
  if( (pPal!=NULL)&&(palentries>0) ) {
    dprintf("writing the palette\n");
    pvTmpPal = (void *)malloc(sizeof(DWORD)*palentries);
    if(pvTmpPal==NULL) {
      fclose(fp);
      return 7;
    }
    move2(pvTmpPal, pPal, sizeof(DWORD)*palentries);
    r = fwrite(pvTmpPal, sizeof(DWORD)*palentries, 1, fp);
    if(!r) {
      dprintf("Error writing palette\n");
      fclose(fp);
      return 3;
    }
  }
  dprintf("palette\n");


  //write out the bits
  pvTmpBits = (VOID *)malloc(byte_width*h);
  if(pvTmpBits==NULL) {
    if(pvTmpPal) free(pvTmpPal);
    fclose(fp);
    return 8;
  }
  move2(pvTmpBits, pBits, byte_width*h);

  dprintf("bits\n");


  r = fwrite(pvTmpBits, byte_width*h, 1, fp);
  if(!r) {
    dprintf("Error writing bits\n");
    fclose(fp);
    return 6;
  }
  dprintf("write\n");

  fclose(fp);
  if(pvTmpPal) free(pvTmpPal);
  if(pvTmpBits) free(pvTmpBits);

  dprintf("Wrote DIB to %s\n", filename);
  return 0;
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( ddib  )
*
* History:
*  11/12/98    -by- Adrian Secchia [asecchia]
* Wrote it.
\**************************************************************************/
DECLARE_API( ddib )
{
    PARSE_ARGUMENTS(ddib_help);
    if(ntok<1) {
      goto ddib_help;
    }

    int w_sw, h_sw, b_sw, f_sw, y_sw, p_sw, i_sw;
    
    //find valid tokens - ignore the rest
    w_sw = parse_iFindSwitch(tokens, ntok, 'w');
    h_sw = parse_iFindSwitch(tokens, ntok, 'h');
    b_sw = parse_iFindSwitch(tokens, ntok, 'b');
    f_sw = parse_iFindSwitch(tokens, ntok, 'f');
    y_sw = parse_iFindSwitch(tokens, ntok, 'y');
    p_sw = parse_iFindSwitch(tokens, ntok, 'p');
    i_sw = parse_iFindSwitch(tokens, ntok, 'i');

    //
    // i must be present unless all of w, h and b are present.
    // conversely w, h and b must be present unless i is present.
    // f must always be present
    //
    if( ((i_sw<0) && ((w_sw<0) || (h_sw<0) || (b_sw<0)) ) ||
        (f_sw<0)) {
      dprintf("required parameter missing\n");
      goto ddib_help;
    }

    if( (w_sw>ntok-3) || (h_sw>ntok-3) ||
        (b_sw>ntok-3) || (f_sw>ntok-3) ||
        (y_sw>ntok-3) || (p_sw>ntok-4) ||
        (i_sw>ntok-3) ) {
      dprintf("invalid parameter format\n");
      goto ddib_help;
    }

    EXIT_API(S_OK);

ddib_help:
  dprintf("Usage: ddib [-?] [-i LPBITMAPINFO] [-w Width] [-h Height] [-f filename] [-b Bits] [-y Byte_Width] [-p palbits palsize] pbits\n");
  dprintf("\t-i required parameter specifies LPBITMAPINFO structure (hex)\n");
  dprintf("\t-w required parameter specifies width in pixels (hex)\n");
  dprintf("\t-h required parameter specifies height in pixels (hex)\n");
  dprintf("\t-b required parameter specifies number of bits per pixel (hex)\n");
  dprintf("\t-y optional parameter specifies byte width of dib (hex)\n"
          "\t   if omitted this parameter is computed from w and b parameters\n");
  dprintf("\t-p optonal parameter specifies the palette pointer and the number of palette entries (hex)\n");
  dprintf("\t-f required parameter specifies the filename to store the dib - usually a public share\n");
  dprintf("\tpBits required parameter specifies pointer to the bit data - must be last.\n");
  dprintf("If the -i option is supplied then the -w, -h and -b become optional.\n");
  dprintf("If the -i is omitted, then -w, -h and -b are required.\n");

  EXIT_API(S_OK);

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  int r;
  PVOID pvBits;
  PVOID pvPal=NULL;
  DWORD palsize = 0;

  DWORD bmiSize;
  LPBITMAPINFO pbmi;
  BITMAPINFO bmi;

  LONG w, h, b, bw;





  if(i_sw>=0) {
    pbmi = (LPBITMAPINFO)GetExpression(tokens[i_sw+1]);
    move2(&bmiSize, pbmi, sizeof(DWORD));                   //Get the size of the BITMAPINFOHEADER
    if(bmiSize>sizeof(BITMAPINFOHEADER)) {
      dprintf("Invalid bmiSize\n");
      bmiSize = sizeof(BITMAPINFOHEADER);
    }
    move2(&bmi, pbmi, bmiSize);                             //I wonder if this could run off the end of the bitmapinfoheader while reading (it is a variable length structure - both the BITMAPINFOHEADER and the RGBQUAD)

    //
    // Set the parameters - they are possibly overwritten later
    // if other parameters are specified.
    //
    w = bmi.bmiHeader.biWidth;
    h = bmi.bmiHeader.biHeight;
    b = bmi.bmiHeader.biBitCount;

    //
    // Get the palette from the LPBITMAPINFO structure providing that
    // the user hasn't specified a manual palette address
    //
    if(p_sw<0) {
      pvPal = (PVOID) ( (PBYTE)pbmi+sizeof(BITMAPINFOHEADER) );  //point to the start of the rgbquad array
      switch(b) {
        case 0: break;
        case 1: palsize = 2; break;
        case 4: palsize = 16; break;
        case 8: palsize = 256; break;
        case 16:
          if(bmi.bmiHeader.biCompression==BI_BITFIELDS) {
            palsize = 3;
            break;
          }
        case 24:
        case 32:
          palsize = 0;
          pvPal = NULL;
          break;
        default:
          palsize = 0;
          pvPal = NULL;
          dprintf("WARNING: you're trying to dump a DIB with an unusual bit depth %d\n", b);
          dprintf("bit depth should be specified in hex!\n");
        break;
      }
    }

    if( (bmi.bmiHeader.biClrUsed<palsize) && (bmi.bmiHeader.biClrUsed>0) ) {
      palsize = bmi.bmiHeader.biClrUsed;
    }

  }

  if(w_sw>=0) { w = (LONG)GetExpression(tokens[w_sw+1]); }
  if(h_sw>=0) { h = (LONG)GetExpression(tokens[h_sw+1]); }
  if(b_sw>=0) { b = (LONG)GetExpression(tokens[b_sw+1]); }

  if(p_sw>=0) {
    pvPal = (PVOID)GetExpression(tokens[p_sw+1]);
    palsize = (LONG)GetExpression(tokens[p_sw+2]);
  }

  if(y_sw>=0) {
    bw = (LONG)GetExpression(tokens[y_sw+1]);
  } else {
    switch(b) {
      case 32: bw = w*4; break;
      case 24: bw = w*3; break;
      case 16: bw = w*2; break;
      case 8: bw = w; break;
      case 1: bw = w/8 + (int)((w%8) != 0); break;
      default: bw = w;
    }
  }

  pvBits = (PVOID)GetExpression(tokens[ntok-1]);

  if( (r=WriteDIBToFile(pvBits, w, h, bw, b, pvPal, palsize, tokens[f_sw+1])) !=0 ) {
    dprintf("Error %d writing to file\n", r);
    goto ddib_help;
  }
  return;

#endif  // DOES NOT SUPPORT API64
}



/******************************Public*Routine******************************\
* VOID vPrintBLTRECORD
*
* Dump the contents of BLTRECORD structure
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintBLTRECORD(VOID  *pv)
{
    BLTRECORD   *pblt = (BLTRECORD *) pv;

    dprintf("SURFOBJ   *psoTrg        0x%08lx\n", pblt->pSurfTrg()->pSurfobj());
    dprintf("SURFOBJ   *psoSrc        0x%08lx\n", pblt->pSurfSrc()->pSurfobj());
    dprintf("SURFOBJ   *psoMsk        0x%08lx\n", pblt->pSurfMsk()->pSurfobj());

    dprintf("POINTFIX  aptfx[0]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[0].x >> 4, pblt->pptfx()[0].x & 15, pblt->pptfx()[0].y >> 4, pblt->pptfx()[0].y & 15);
    dprintf("POINTFIX  aptfx[1]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[1].x >> 4, pblt->pptfx()[1].x & 15, pblt->pptfx()[1].y >> 4, pblt->pptfx()[1].y & 15);
    dprintf("POINTFIX  aptfx[2]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[2].x >> 4, pblt->pptfx()[2].x & 15, pblt->pptfx()[2].y >> 4, pblt->pptfx()[2].y & 15);
    dprintf("POINTFIX  aptfx[3]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[3].x >> 4, pblt->pptfx()[3].x & 15, pblt->pptfx()[3].y >> 4, pblt->pptfx()[3].y & 15);

    dprintf("POINTL    aptlTrg[0]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[0].x, pblt->pptlTrg()[0].y);
    dprintf("POINTL    aptlTrg[1]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[1].x, pblt->pptlTrg()[1].y);
    dprintf("POINTL    aptlTrg[2]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[2].x, pblt->pptlTrg()[2].y);

    dprintf("POINTL    aptlSrc[0]   = (0x%08lx, 0x%08lx)\n", pblt->pptlSrc()[0].x, pblt->pptlSrc()[0].y);
    dprintf("POINTL    aptlSrc[1]   = (0x%08lx, 0x%08lx)\n", pblt->pptlSrc()[1].x, pblt->pptlSrc()[1].y);

    dprintf("POINTL    aptlMask[0]  = (0x%08lx, 0x%08lx)\n", pblt->pptlMask()[0].x, pblt->pptlMask()[0].y);

    dprintf("POINTL    aptlBrush[0] = (0x%08lx, 0x%08lx)\n", pblt->pptlBrush()[0].x, pblt->pptlBrush()[0].y);

    dprintf("ROP4  rop4 = 0x%08lx, FLONG flState = 0x%08lx\n", pblt->rop(), pblt->flGet());
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* DECLARE_API( dblt  )
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( dblt )
{
    dprintf("Use 'dt win32k!BLTRECORD -r <Address>'\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  DWORD blt[1024];
  PARSE_POINTER(dblt_help);
  dprintf("BLTRECORD structure at 0x%p:\n", (PVOID)arg);
  move2(blt, (BLTRECORD *)arg, sizeof(BLTRECORD));
  vPrintBLTRECORD(blt);
  return;

dblt_help:
  dprintf("Usage: dblt [-?] BLTRECORD_PTR\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* xlate
*
\**************************************************************************/

DECLARE_API( xlate )
{
    return ExtDumpType(Client, "xlate", "XLATE", args);
}


/******************************Public*Routine******************************\
* bltinfo
*
\**************************************************************************/

DECLARE_API( bltinfo )
{
    return ExtDumpType(Client, "bltinfo", "BLTINFO", args);
}


/******************************Public*Routine******************************\
* stats
*
*  27-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PSZ apszGetDCDword[] =
{
    "GCAPS              ",
    "STRETCHBLTMODE     ",
    "GRAPHICSMODE       ",
    "ROP2               ",
    "BKMODE             ",
    "POLYFILLMODE       ",
    "TEXTALIGN          ",
    "TEXTCHARACTEREXTRA ",
    "TEXTCOLOR          ",
    "BKCOLOR            ",
    "RELABS             ",
    "BREAKEXTRA         ",
    "CBREAK             ",
    "MAPMODE            ",
    "ARCDIRECTION       ",
    "SAVEDEPTH          ",
    "FONTLANGUAGEINFO   "
};

PSZ apszSetDCDword[] =
{
    "UNUSED             ",
    "EPSPRINTESCCALLED  ",
    "COPYCOUNT          ",
    "BKMODE             ",
    "POLYFILLMODE       ",
    "ROP2               ",
    "STRETCHBLTMODE     ",
    "TEXTALIGN          ",
    "BKCOLOR            ",
    "RELABS             ",
    "TEXTCHARACTEREXTRA ",
    "TEXTCOLOR          ",
    "SELECTFONT         ",
    "MAPPERFLAGS        ",
    "MAPMODE            ",
    "ARCDIRECTION       ",
    "GRAPHICSMODE       "
};


PSZ apszGetDCPoint[] =
{
    "UNUSED             ",
    "VPEXT              ",
    "WNDEXT             ",
    "VPORG              ",
    "WNDORG             ",
    "ASPECTRATIOFILTER  ",
    "BRUSHORG           ",
    "DCORG              ",
    "CURRENTPOSITION    "
};

PSZ apszSetDCPoint[] =
{
    "VPEXT              ",
    "WNDEXT             ",
    "VPORG              ",
    "WNDORG             ",
    "OFFVPORG           ",
    "OFFWNDORG          ",
    "MAX                "
};

DECLARE_API( stats  )
{
    dprintf("Extension 'stats' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
#if DBG

    DWORD adw[100];
    PDWORD pdw;
    int i;

    PARSE_ARGUMENTS(stats_help);

    // Get DCDword

    GetAddress(pdw, "win32k!acGetDCDword");
    move2(adw, pdw, sizeof(DWORD) * DDW_MAX);

    dprintf("\nGetDCDword %lx:\n",pdw);

//CHECKLOOP
    for (i = 0; i < DDW_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszGetDCDword[i],adw[i]);
    }

    // Set DCDword

    GetAddress(pdw, "win32k!acSetDCDword");
    move2(adw, pdw, sizeof(DWORD) * GASDDW_MAX);

    dprintf("\nSetDCDword:\n");

//CHECKLOOP
    for (i = 0; i < GASDDW_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszSetDCDword[i],adw[i]);
    }

    // Get DCPoint

    GetAddress(pdw, "win32k!acGetDCPoint");
    move2(adw, pdw, sizeof(DWORD) * DCPT_MAX);

    dprintf("\nGetDCPoint:\n");

//CHECKLOOP
    for (i = 0; i < DCPT_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszGetDCPoint[i],adw[i]);
    }

    // Set DCPoint

    GetAddress(pdw, "win32k!acSetDCPoint");
    move2(adw, pdw, sizeof(DWORD) * GASDCPT_MAX);

    dprintf("\nSetDCPoint:\n");

//CHECKLOOP
    for (i = 0; i < GASDCPT_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszSetDCPoint[i],adw[i]);
    }

#else
    goto stats_help;
#endif

  return;
stats_help:
  dprintf("Usage: stats [-?]\n");
  dprintf("-? displays this help.\n");
  dprintf("stats only works in checked builds.\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}



/******************************Public*Routine******************************\
* PALETTE
*
\**************************************************************************/

DECLARE_API( palette )
{
    BEGIN_API( palette );

    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    ULONG64         PaletteAddr;
    DEBUG_VALUE     Arg;
    DEBUG_VALUE     Offset;

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK)
    {
        OutCtl.Output("Usage: palette [-?] <HPALETTE | PALETTE Addr>\n");
    }
    else
    {
        hr = GetObjectAddress(Client,Arg.I64,&PaletteAddr,PAL_TYPE,TRUE,TRUE);

        if (hr != S_OK || PaletteAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             PaletteAddrFromHmgr;

            PaletteAddr = Arg.I64;

            // Try to read hHmgr from PALETTE type, but if that
            // fails use the BASEOBJECT type, which is public.
            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(PaletteAddr, GDIType(PALETTE), 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of PALETTE's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HPALETTE nor valid PALETTE address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client,ObjHandle.I64,&PaletteAddrFromHmgr,
                                     PAL_TYPE,TRUE,FALSE) == S_OK &&
                    PaletteAddr != PaletteAddrFromHmgr)
                {
                    OutCtl.OutWarn("\tNote: PALETTE may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "PALETTE", PaletteAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for PALETTE returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}


DECLARE_API( dppal  )
{
    INIT_API();
    ExtOut("Obsolete: Use 'palette poi(<EPALOBJ Addr>)'.\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* DECLARE_API( sprite  )
*
\**************************************************************************/

PCSTR SpriteFields[] = {
    "dwShape",
    "fl",
    "BlendFunction",
    "pState",
    "pNextZ",
    "pNextY",
    "pPreviousY",
    "pNextActive",
    "rclSprite",
    "rclSrc",
    "psoShape",
    "psoUnderlay",
    "prgnClip",
    "ppalShape",
    NULL
};

DECLARE_API( sprite  )
{
    BEGIN_API( sprite );

    HRESULT         hr = S_OK;
    BOOL            DumpAll = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);


    while (isspace(*args)) args++;

    if (args[0] == '-' && tolower(args[1]) == 'a' && isspace(args[2]))
    {
        DumpAll = TRUE;
        args+=3;
    }

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: sprite [-?a] <SPRITE Addr>\n"
               "        -a  - dump entire structure\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "SPRITE", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (!DumpAll)
            {
                TypeReader.MarkFields(SpriteFields);
            }

            OutCtl.Output(" SPRITE @ 0x%p:\n", Offset.I64);

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
        }

        if (hr != S_OK)
        {
            OutCtl.OutErr("Type Dump for SPRITE returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( spritestate  )
*
\**************************************************************************/

PCSTR SpriteStateFields[] = {
    "hdev",
    "cVisible",
    "pListZ",
    "pListY",
    "psoScreen",
    "cVisible",
    "pRange",
    "pRangeLimit",
    "psoComposite",
    "prgnUnlocked",
    NULL
};

PCSTR SpriteStateCursorFields[] = {
    "pSpriteCursor",
    "xHotCursor",
    "yHotCursor",
    "ulNumCursors",
    "pTopCursor",
    "pBottomCursor",
    "ulTrailTimeStamp",
    "ulTrailPeriod",
    NULL
};

PCSTR SpriteStateHookFields[] = {
    "bHooked",
    "bInsideDriverCall",
    "flOriginalSurfFlags",
    "iOriginalType",
    "flSpriteSurfFlags",
    "iSpriteType",
    NULL
};

PCSTR SpriteStateMetaFields[] = {
    "cMultiMon",
    "ahdevMultiMon",
    "pListMeta",
    NULL
};

PCSTR SpriteStateLargeFields[] = {
    "coTmp",
    "coRectangular",
    NULL
};


DECLARE_API( spritestate  )
{
    BEGIN_API( spritestate );

    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpAll = FALSE;
    BOOL            DumpCursor = FALSE;
    BOOL            DumpHook = FALSE;
    BOOL            DumpMeta = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);


    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'a': DumpAll = TRUE; break;
                case 'c': DumpCursor = TRUE; break;
                case 'h': DumpHook = TRUE; break;
                case 'm': DumpMeta = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: spritestate [-?chma] <SPRITESTATE Addr>\n"
               "        -c  - dump cursor fields\n"
               "        -h  - dump hook fields\n"
               "        -m  - dump meta fields\n"
               "        -a  - dump entire structure\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "SPRITESTATE", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (DumpAll)
            {
                TypeReader.ExcludeMarked();

                TypeReader.MarkFields(SpriteStateLargeFields);
            }
            else
            {
                TypeReader.IncludeMarked();

                TypeReader.MarkFields(SpriteStateFields);

                if (DumpCursor)
                {
                    TypeReader.MarkFields(SpriteStateCursorFields);
                }

                if (DumpHook)
                {
                    TypeReader.MarkFields(SpriteStateHookFields);
                }

                if (DumpMeta)
                {
                    TypeReader.MarkFields(SpriteStateMetaFields);
                }
            }

            OutCtl.Output(" SPRITESTATE @ 0x%p:\n", Offset.I64);

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
        }

        if (hr != S_OK)
        {
            OutCtl.OutErr("Type Dump for SPRITESTATE returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}



/**************************************************************************\
* PDEV Fields
*
\**************************************************************************/

PCSTR   GeneralPDEVFields[] = {
    "ppdevNext",
    "fl",
    "cPdevRefs",
    "cPdevOpenRefs",
    "pldev",
    "dhpdev",
    "hSpooler",
    "pSurface",
    "ppalSurf",
    "eDirectDrawGlobal.",
    "SpriteState.",
    "pDesktopId",
    "pGraphicsDevice",
    "ppdevParent",
    "hsemDevLock",
    "ptlOrigin",
    "apfn.",
    "daDirectDrawContext.",
    NULL
};

PCSTR   PDEVPointerFields[] = {
    "ptlPointer",
    "pfnDrvSetPointerShape",
    "pfnDrvMovePointer",
    "pfnMovePointer",
    "pfnSync",
    "hsemPointer",
    NULL
};

PCSTR   PDEVFontFields[] = {
    "hlfntDefault",
    "hlfntAnsiVariable",
    "hlfntAnsiFixed",
    "prfntActive",
    "prfntInactive",
    "cInactive",
    NULL
};

PCSTR   PDEVDevInfoFields[] = {
    "devinfo.flGraphicsCaps",
    "devinfo.cFonts",
    "devinfo.iDitherFormat",
    "devinfo.cxDither",
    "devinfo.cyDither",
    "devinfo.hpalDefault",
    "devinfo.flGraphicsCaps2",
    NULL
};

PCSTR   PDEVPatternFields[] = {
    "ahsurf",       // To Do: make sure array gets dumped
    "pDevHTInfo",
    NULL
};

PCSTR   PDEVGDIInfoFields[] = {
    "GdiInfo",
    "flAccelerated",
    NULL
};

PCSTR   PDEVSpriteStateFields[] = {
    "SpriteState.bHooked",
    "SpriteState.pListZ",
    "SpriteState.psoScreen",
    "SpriteState.cVisible",
    "SpriteState.cMultiMon",
    "SpriteState.bInsideDriverCall",
    "SpriteState.iOriginalType",
    "SpriteState.iSpriteType",
    "SpriteState.pBottomCursor",
    "SpriteState.ulNumCursors",
    NULL
};


/******************************Public*Routine******************************\
* PDEV
*
\**************************************************************************/

DECLARE_API( pdev )
{
    BEGIN_API( pdev );
    INIT_API();

    HRESULT         hr = S_OK;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    BOOL    BadSwitch = FALSE;
    BOOL    DumpAll = FALSE;
    BOOL    DumpDEVINFO = FALSE;
    BOOL    DumpFont = FALSE;
    BOOL    DumpGDIINFO = FALSE;
    BOOL    DumpPattern = FALSE;
    BOOL    DumpPointer = FALSE;
    BOOL    DumpSpriteState = FALSE;
    BOOL    Recurse = FALSE;
    BOOL    DisplaysOnly = FALSE;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'a': DumpAll = TRUE; break;
                case 'd': DumpDEVINFO = TRUE; break;
                case 'f': DumpFont = TRUE; break;
                case 'g': DumpGDIINFO = TRUE; break;
                case 'n': DumpPattern = TRUE; break;
                case 'p': DumpPointer = TRUE; break;
                case 's': DumpSpriteState = TRUE; break;
                case 'r':
                case 'R': Recurse = TRUE; break;
                case 'D': DisplaysOnly = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: pdev [-?adfgnpsRD] [PDEV Addr]\n"
               "\n"
               "   PDEV Addr - address of PDEV otherwise win32k!gppdevList is used\n"
               "\n"
               "   a - All info (dump everything)\n"
               "   d - DEVINFO struct\n"
               "   f - Font info\n"
               "   g - GDIINFO struct\n"
               "   m - DEVMODE\n"
               "   n - Default patterns\n"
               "   p - Pointer info\n"
               "   s - SpriteState\n"
               "\n"
               "   R - Recurse\n"
               "   D - Display devices only\n");
    }
    else if (*args != '\0' &&
             ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
              Offset.I64 == 0))
    {
        if (hr == S_OK)
        {
            OutCtl.Output("Expression %s evalated to zero.\n", args);
        }
        else
        {
            OutCtl.OutErr("Evaluate(%s) returned %s.\n", args, pszHRESULT(hr));
        }
    }
    else
    {
        // If no address was given use win32k!gppdevList
        if (*args == '\0')
        {
            DEBUG_VALUE ppdevList;

            hr = g_pExtControl->Evaluate(GDISymbol(gppdevList),
                                         DEBUG_VALUE_INT64,
                                         &ppdevList,
                                         NULL);

            if (hr == S_OK)
            {
                if (SessionId == CURRENT_SESSION)
                {
                    hr = g_pExtData->ReadPointersVirtual(1, ppdevList.I64, &Offset.I64);
                }
                else
                {
                    ULONG64 ppdevListPhys;

                    if ((hr = GetPhysicalAddress(Client,
                                                 SessionId,
                                                 ppdevList.I64,
                                                 &ppdevListPhys)) == S_OK)
                    {
                        hr = ReadPointerPhysical(Client, ppdevListPhys, &Offset.I64);

                        if (hr == S_OK)
                        {
                            OutCtl.Output("First PDEV in session %lu located at 0x%p.\n",
                                   SessionId, Offset.I64);
                        }
                    }
                }

                if (hr == S_OK)
                {
                    if (Offset.I64 == 0)
                    {
                        OutCtl.OutErr(" Displays are not initialized or symbols are incorrect.\n"
                                "  %s @ %#p is NULL.\n", GDISymbol(gppdevList), ppdevList.I64);
                        hr = S_FALSE;
                    }
                }
                else
                {
                    OutCtl.OutErr("Unable to get the contents of %s @ %#p\n", GDISymbol(gppdevList), ppdevList.I64);
                }
            }
            else
            {
                OutCtl.OutErr("Unable to locate %s\n", GDISymbol(gppdevList));
            }
        }

        OutputFilter        OutFilter(Client);
        OutputState         OutState(Client);

        if (hr == S_OK &&
            (hr = OutState.Setup(0, &OutFilter)) == S_OK &&
            (hr = GetTypeId(Client, "PDEV", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtl);

            do
            {
                if (OutCtl.GetInterrupt() == S_OK) break;

                OutCtl.Output("PDEV @ 0x%p:\n", Offset.I64);

                // Read two fields to OutFilter: 'ppdevNext' and 'fl'
                OutFilter.DiscardOutput();

                TypeReader.IncludeMarked();
                TypeReader.ClearMarks();
                TypeReader.MarkField("ppdevNext");
                TypeReader.MarkField("fl");

                if ((hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
                    (hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64)) == S_OK &&
                    (hr = OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client)) == S_OK)
                {
                    // If we only want displays, check for PDEV_DISPLAY
                    // in OutFilter (
                    if (!DisplaysOnly ||
                        OutFilter.Query("PDEV_DISPLAY") == S_OK)
                    {
                        TypeReader.ClearMarks();

                        if (DumpAll)
                        {
                            TypeReader.ExcludeMarked();

                            // Don't recurse for big sub structures
                            TypeReader.MarkField("SpriteState.*");
                            TypeReader.MarkField("devinfo.*");
                            TypeReader.MarkField("GdiInfo.*");
                        }
                        else
                        {
                            TypeReader.IncludeMarked();

                            TypeReader.MarkFields(GeneralPDEVFields);

                            if (DumpDEVINFO)
                            {
                                TypeReader.MarkFields(PDEVDevInfoFields);
                            }

                            if (DumpFont)
                            {
                                TypeReader.MarkFields(PDEVFontFields);
                            }

                            if (DumpGDIINFO)
                            {
                                TypeReader.MarkFields(PDEVGDIInfoFields);
                            }

                            if (DumpPattern)
                            {
                                TypeReader.MarkFields(PDEVPatternFields);
                            }

                            if (DumpPointer)
                            {
                                TypeReader.MarkFields(PDEVPointerFields);
                            }

                            if (DumpSpriteState)
                            {
                                TypeReader.MarkFields(PDEVSpriteStateFields);
                            }
                        }

                        hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
                    }
                    else
                    {
                        OutCtl.Output("  Not marked PDEV_DISPLAY.\n");
                    }

                    if (Recurse)
                    {
                        hr = OutFilter.Query("ppdevNext", &Offset, DEBUG_VALUE_INT64);
                        if (hr == S_OK)
                        {
                            if (Offset.I64 != 0)
                            {
                                OutCtl.Output("-----------------------------------\n");
                            }
                            else
                            {
                                Recurse = FALSE;
                            }
                        }
                    }
                }
            } while (hr == S_OK && Recurse);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for PDEV returned %s.\n", pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.OutErr("Type Dump setup for PDEV returned %s.\n", pszHRESULT(hr));
        }
    }

    EXIT_API(hr);
}

DECLARE_API( dpdev  )
{
    return pdev(Client, args);
}


/******************************Public*Routine******************************\
* dldev
*
* Syntax:   dldev [LDEV pointer]
*
* History:
*  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

DECLARE_API (dldev)
{
    dprintf("Extension 'dldev' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    BOOL   recursive = TRUE;
    PWSZ   psz;
    PLDEV  pldevNext, pl_CD;
    LDEV   ldev;
    WCHAR  DriverName[MAX_PATH];
    SYSTEM_GDI_DRIVER_INFORMATION GdiDriverInfo;
    BOOL   invalid_type = false;
    BOOL   force;
    int    forcenum=0;
    BOOL   forcecount;
    BOOL   FirstLoop=FALSE;


    GetValue(pldevNext, "win32k!gpldevDrivers");

    PARSE_ARGUMENTS(dldev_help);
    if(ntok<1) { goto dldev_help; }
    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dldev_help; }
    if(parse_IsSwitch(tokens, tok_pos-1, 'F')) {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    }
    if(tok_pos==-1) { goto dldev_help; }

    pl_CD = pldevNext = (PLDEV)GetExpression(tokens[tok_pos]);

    force = (parse_FindSwitch(tokens, ntok, 'f')!=-1);
    forcecount = ((tok_pos = parse_FindSwitch(tokens, ntok, 'F'))!=-1);
    if(tok_pos != -1) {
      if(((tok_pos+1)>=ntok)||
         (sscanf(tokens[tok_pos+1], "%d", &forcenum)!=1)) {
        goto dldev_help;
      }
    }


    dprintf("\n--------------------------------------------------\n");

    do
    {
        if(forcecount) {
          if((--forcenum)<0) {
            break;
          }
        }

        if(pl_CD) {
          ReadMemory((UINT_PTR)pl_CD, &ldev, sizeof(LDEV), NULL);
          pl_CD = ldev.pldevNext;
          if(pl_CD) {
            ReadMemory((UINT_PTR)pl_CD, &ldev, sizeof(LDEV), NULL);
            pl_CD = ldev.pldevNext;
          }
        }
        ReadMemory((UINT_PTR)pldevNext, &ldev, sizeof(LDEV), NULL);

        dprintf("ldev  = 0x%lx\n", pldevNext);

        switch (ldev.ldevType)
        {
        case LDEV_DEVICE_DISPLAY:
            psz = L"LDEV_DEVICE_DISPLAY";
            break;
        case LDEV_DEVICE_PRINTER:
            psz = L"LDEV_DEVICE_PRINTER";
            break;
        case LDEV_FONT:
            psz = L"LDEV_FONT";
            break;
        case LDEV_DEVICE_META:
            psz = L"LDEV_DEVICE_META";
            break;
        case LDEV_DEVICE_MIRROR:
            psz = L"LDEV_DEVICE_MIRROR";
            break;
        case LDEV_IMAGE:
            psz = L"LDEV_IMAGE";
            break;
        default:
            invalid_type = true;
            psz = L"INVALID LDEV TYPE";
            break;
        }

        dprintf("next ldev       = 0x%lx\n", ldev.pldevNext      );
        dprintf("previous ldev   = 0x%lx\n", ldev.pldevPrev      );

        dprintf("levtype         = %ws\n",   psz                 );
        dprintf("cRefs           = %d\n",    ldev.cldevRefs      );
        dprintf("ulDriverVersion = 0x%lx\n", ldev.ulDriverVersion);
        dprintf("pGdiDriverInfo  = 0x%lx\n", ldev.pGdiDriverInfo );

        dprintf("name            = ");

        if (ldev.pGdiDriverInfo == NULL)
        {
            dprintf("Linked-in driver\n");

        }
        else
        {
            ReadMemory((ULONG_PTR) ldev.pGdiDriverInfo,
                       &GdiDriverInfo,
                       sizeof(SYSTEM_GDI_DRIVER_INFORMATION),
                       NULL);

            ReadMemory((ULONG_PTR) GdiDriverInfo.DriverName.Buffer,
                       DriverName,
                       GdiDriverInfo.DriverName.Length,
                       NULL);

            *(DriverName + GdiDriverInfo.DriverName.Length/2) = UNICODE_NULL;

            dprintf("%ws\n", &DriverName);
        }

        if(invalid_type) {
          dprintf("The ldev is invalid\n");
        }
        dprintf("\n");
        if(!FirstLoop&&(pl_CD==pldevNext)) {
          dprintf("ERROR: Cycle detected in linked list.\n");
          break;
        }
        if(CheckControlC()) {
          dprintf("User Break\n");
          return;
        }
        FirstLoop=FALSE;
    } while ( (!invalid_type||force||forcecount) && recursive && (pldevNext = ldev.pldevNext));

    dprintf("--------------------------------------------------\n\n");
  return;
dldev_help:
  dprintf("Usage: dldev [-?] [-f] [-F #] ldev\n");
  dprintf("-f forces the recursion even if the type is invalid\n");
  dprintf("In an infinite loop, Ctrl-C will eventually break the recursion\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* dgdev
*
* Syntax:   dgdev [GRAPHICS_DEVICE pointer]
*
* History:
*  Andre Vachon [andreva]
*   Wrote it.
*  Jason Hartman [jasonha]
*   Converted to new debugger API.
\**************************************************************************/

char szCurrentDeviceList[]      = GDISymbol(gpGraphicsDeviceList);
char szLocalDeviceList[]        = GDISymbol(gpLocalGraphicsDeviceList);
char szRemoteDeviceList[]       = GDISymbol(gpRemoteGraphicsDeviceList);

char szCurrentDeviceListLast[]  = GDISymbol(gpGraphicsDeviceListLast);
char szLocalDeviceListLast[]    = GDISymbol(gpLocalGraphicsDeviceListLast);
char szRemoteDeviceListLast[]   = GDISymbol(gpRemoteGraphicsDeviceListLast);

char szGraphicsDeviceHeader[] = "--------------------------------------------------\n"
                                "GRAPHICS_DEVICE @ ";

DECLARE_API( dgdev )
{
    INIT_API();
    BEGIN_API( dgdev );

    HRESULT     hr;

    ULONG64     GDeviceAddr = 0;
    ULONG64     LastPointerAddr = 0;
    ULONG64     LastGDExpected = 0;
    BOOL        recursive = FALSE;
    BOOL        bDumpModes = FALSE;
    BOOL        UseAddress = FALSE;
    char       *pszDeviceList = NULL;
    char        szPGDSymbolBuffer[128];
    ULONG       error;

    OutputControl   OutCtl(Client);

    #define GRAPHICS_DEVICE_CBDEVMODEINFO   0
    #define GRAPHICS_DEVICE_DEVMODEINFO     1

    FIELD_INFO  GraphicsDeviceFields[] = {
        { DbgStr("cbdevmodeInfo"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("devmodeInfo"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("szNtDeviceName"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
        { DbgStr("szWinDeviceName"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
        { DbgStr("pNextGraphicsDevice"),NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pVgaDevice"),         NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pDeviceHandle"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pPhysDeviceHandle"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("hkClassDriverConfig"),NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("stateFlags"),         NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, FlagCallback},
        { DbgStr("numRawModes"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("devmodeMarks"),       NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("DiplayDriverNames"),  DbgStr("Di(s)playDriverNames :"), 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_MULTI_STRING | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
#if 1
        { DbgStr("DeviceDescription"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
#else
        { DbgStr("DeviceDescription"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, WStringCallback},
#endif
        { DbgStr("numMonitorDevice"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("MonitorDevices"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pFileObject"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };

    FIELD_INFO  GraphicsDeviceLink = { DbgStr("pNextGraphicsDevice"),  DbgStr(""), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NextItemCallback};

    SYM_DUMP_PARAM GraphicsDeviceSym = {
        sizeof(SYM_DUMP_PARAM), DbgStr(GDIType(tagGRAPHICS_DEVICE)), 0, 0/*GDeviceAddr*/,
        NULL, afdGRAPHICS_DEVICE_stateFlags, NULL,
        sizeof(GraphicsDeviceFields)/sizeof(GraphicsDeviceFields[0]),
        GraphicsDeviceFields
    };
    PrepareCallbacks(FALSE);


    // Interpret command line

    PARSE_ARGUMENTS(dgdev_help);

    if (parse_iFindSwitch(tokens, ntok, 'm')!=-1)
    {
        GraphicsDeviceFields[GRAPHICS_DEVICE_CBDEVMODEINFO].fieldCallBack = SizeDEVMODEListCallback;
        GraphicsDeviceFields[GRAPHICS_DEVICE_DEVMODEINFO].fieldCallBack = DEVMODEListCallback;
    }
    if (parse_iFindSwitch(tokens, ntok, 'R')!=-1) { recursive = TRUE; }

    // Determine where to start looking: global or commnad line arg?

    // -c means current/last device list
    if (parse_iFindSwitch(tokens, ntok, 'c')!=-1)
    {
        pszDeviceList = szCurrentDeviceList;

        LastPointerAddr = GetExpression(szCurrentDeviceListLast);
    }
    // -l means local device list
    if (parse_iFindSwitch(tokens, ntok, 'l')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;

        pszDeviceList = szLocalDeviceList;

        LastPointerAddr = GetExpression(szLocalDeviceListLast);
    }
    // -r means remote device list
    if (parse_iFindSwitch(tokens, ntok, 'r')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;

        pszDeviceList = szRemoteDeviceList;

        LastPointerAddr = GetExpression(szRemoteDeviceListLast);
    }
    // -p may not be used with -c, -l, or -r
    if (parse_iFindSwitch(tokens, ntok, 'p')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;
    }

    tok_pos = parse_FindNonSwitch(tokens, ntok);

    // Evaluate expression
    if (tok_pos != -1)
    {
        ULONG64 Displacement;

        if (pszDeviceList != NULL)
        {
            dprintf("  No expression maybe used with -c, -l, or -r.\n");
            goto dgdev_help;
        }

        GDeviceAddr = GetExpression(tokens[tok_pos]);

        if (GDeviceAddr == 0)
        {
            dprintf("  Expression \"%s\" evaluated to NULL.\n", tokens[tok_pos]);
            EXIT_API(S_OK);
        }

        // Look up symbol for address if we can
        Displacement = -1;
        szPGDSymbolBuffer[0] = 0;
        GetSymbol(GDeviceAddr, szPGDSymbolBuffer, &Displacement);

        if (Displacement == 0 && szPGDSymbolBuffer[0] != 0)
        {
            pszDeviceList = szPGDSymbolBuffer;
        }
        else
        {
            UseAddress = TRUE;
        }
    }

    // -p means the expression is a list pointer
    if (parse_iFindSwitch(tokens, ntok, 'p')!=-1)
    {
        if (tok_pos == -1)
        {
            dprintf(" Missing expression with -p.\n");
            goto dgdev_help;
        }

        // Use list show method
        GDeviceAddr = 0;
        if (pszDeviceList == NULL)
        {
            pszDeviceList = tokens[tok_pos];
        }
    }

    // User either specified a list or a pointer to a list
    if (GDeviceAddr == 0)
    {
        // TRUE if no -R, FALSE otherwise
        recursive = !recursive;

        if (pszDeviceList == NULL)
        {
            pszDeviceList = szCurrentDeviceList;
        }
        
        dprintf("Using Graphics Device List from %s\n", pszDeviceList);

        DEBUG_VALUE pgdevList;

        hr = g_pExtControl->Evaluate(pszDeviceList,
                                     DEBUG_VALUE_INT64,
                                     &pgdevList,
                                     NULL);

        if (hr == S_OK && pgdevList.I64 != 0)
        {
            if (SessionId == CURRENT_SESSION)
            {
                hr = g_pExtData->ReadPointersVirtual(1, pgdevList.I64, &GDeviceAddr);

                if (hr != S_OK)
                {
                    OutCtl.OutErr("  ReadPointer for %s failed at 0x%p.\n",
                                  pszDeviceList, pgdevList.I64);
                }
            }
            else
            {
                ULONG64 pgdevListPhys;

                UseAddress = TRUE;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             pgdevList.I64,
                                             &pgdevListPhys)) == S_OK)
                {
                    hr = ReadPointerPhysical(Client, pgdevListPhys, &GDeviceAddr);

                    if (hr == S_OK)
                    {
                        OutCtl.Output("First GRAPHICS_DEVICE in session %lu located at 0x%p.\n",
                                      SessionId, GDeviceAddr);
                    }
                    else
                    {
                        OutCtl.OutErr("  ReadPointerPhysical for %s failed at # 0x%p.\n",
                               pszDeviceList, pgdevListPhys);
                    }
                }
                else
                {
                    OutCtl.OutErr("  Failed Virtual to Physical conversion for %s (0x%p) in session %ld.\n",
                                  pszDeviceList, pgdevList.I64, SessionId);
                }
            }

            if (hr != S_OK) EXIT_API(S_OK);

            // If a list last pointer exists, look it up.
            if (LastPointerAddr != 0)
            {
                if (SessionId == CURRENT_SESSION)
                {
                    hr = g_pExtData->ReadPointersVirtual(1, LastPointerAddr, &LastGDExpected);

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("  ReadPointer 0x%p failed.\n", LastPointerAddr);
                    }
                }
                else
                {
                    ULONG64 pgdevLastPhys;

                    if ((hr = GetPhysicalAddress(Client,
                                                 SessionId,
                                                 LastPointerAddr,
                                                 &pgdevLastPhys)) == S_OK)
                    {
                        hr = ReadPointerPhysical(Client, pgdevLastPhys, &LastGDExpected);

                        if (hr == S_OK)
                        {
                            OutCtl.Output("Last GRAPHICS_DEVICE in session %lu located at 0x%p.\n",
                                          SessionId, LastGDExpected);
                        }
                        else
                        {
                            OutCtl.OutErr("  ReadPointerPhysical for %s failed at # 0x%p.\n",
                                          pszDeviceList, pgdevLastPhys);
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("  Failed Virtual to Physical conversion for %s (0x%p) in session %ld.\n",
                                      pszDeviceList, LastPointerAddr, SessionId);
                    }
                }
            }

            if (GDeviceAddr == 0)
            {
                OutCtl.Output("Graphics Device address is NULL.\n");
                EXIT_API(S_OK);
            }
        }
        else
        {
            // We should only be here if a -clr look up failed.
            if (hr != S_OK)
            {
                OutCtl.OutErr("  Evaluate(%s) returned %s\n",
                              pszDeviceList, pszHRESULT(hr));
            }
            else
            {
                OutCtl.OutErr("  Evaluate(%s) = NULL\n", pszHRESULT(hr));
            }
            OutCtl.OutErr("  Please double check symbols for " GDIModule() ".\n");
            EXIT_API(S_OK);
        }
    }

    if (recursive)
    {
        // Enable linked list resursion
        GraphicsDeviceSym.Options |= DBG_DUMP_LIST;
        GraphicsDeviceSym.listLink = &GraphicsDeviceLink;

        NextItemCallbackInit(szGraphicsDeviceHeader, LastGDExpected);
    }
    else
    {
        // Printer header since this is a single structure dump
        dprintf(szGraphicsDeviceHeader);
        if (UseAddress)
        {
            dprintf("%#p\n", GDeviceAddr);
        }
    }

    if (UseAddress)
    {
        // Dump from a type w/ an address
        GraphicsDeviceSym.addr = GDeviceAddr;
    }
    else
    {
        // Dump from a symbol
        GraphicsDeviceSym.sName = DbgStr(pszDeviceList);
        if (GetTypeSize(pszDeviceList) == 8)
        {
            GraphicsDeviceLink.fieldCallBack = PointerToNextItemCallback;
        }
    }

    // Do the dumping
    error = Ioctl( IG_DUMP_SYMBOL_INFO, &GraphicsDeviceSym, GraphicsDeviceSym.size );

    if (error)
    {
        dprintf("Unable to get contents of GRAPHICS_DEVICE\n");
        dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
    }

    dprintf("--------------------------------------------------\n\n");

    // Did we find end of list as expected?
    if (recursive && !LastCallbackItemFound())
    {
        dprintf(" * Error: Last expected GRAPHICS_DEVICE @ %#p was not found.\n", LastGDExpected);
    }

    EXIT_API(S_OK);

dgdev_help:
    dprintf("Usage: dgdev [-?] [-mR] [-clr | [-p] expr ]\n"
            "         ? - Show this help\n"
            "         m - Dump modes\n"
            "         R - Recurse for address; don't for list\n"
            "         c - Recurse list from current list [default]\n"
            "         l - Recurse list from local list\n"
            "         r - Recurse list from remote list\n"
            "         p - expr is address or symbol for pointer to list\n"
            "      expr - Address or symbol for GRAPHICS_DEVICE to show\n"
            );
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* BRUSH
*
\**************************************************************************/

DECLARE_API( brush )
{
    BEGIN_API( brush );

    HRESULT         hr = S_OK;
    ULONG64         BrushAddr;
    DEBUG_VALUE     Arg;
    DEBUG_VALUE     Offset;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK)
    {
        OutCtl.Output("Usage: brush [-?] <HBRUSH | BRUSH Addr>\n");
    }
    else
    {
        hr = GetObjectAddress(Client,Arg.I64,&BrushAddr,BRUSH_TYPE,TRUE,TRUE);

        if (hr != S_OK || BrushAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             BrushAddrFromHmgr;

            BrushAddr = Arg.I64;

            // Try to read hHmgr from BRUSH type, but if that
            // fails use the BASEOBJECT type, which is public.
            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(BrushAddr, GDIType(BRUSH), 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of BRUSH's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HBRUSH nor valid BRUSH address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client,ObjHandle.I64,&BrushAddrFromHmgr,
                                     BRUSH_TYPE,TRUE,FALSE) == S_OK &&
                    BrushAddrFromHmgr != BrushAddr)
                {
                    OutCtl.OutWarn("\tNote: BRUSH may not be valid.\n"
                            "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "BRUSH", BrushAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for BRUSH returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( dpbrush ) - OBSOLETE
*
\**************************************************************************/

DECLARE_API( dpbrush )
{
    INIT_API();
    ExtOut("Obsolete: Use '!gdikdx.brush <Handle | Address>'.\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* DECLARE_API( ebrush )
*
*   Dumps an EBRUSHOBJ
*
\**************************************************************************/

DECLARE_API( ebrush )
{
    return ExtDumpType(Client, "ebrush", "EBRUSHOBJ", args);
}


/******************************Public*Routine******************************\
* DECLARE_API( semorder )
*
\**************************************************************************/

#define NUM_ALOC_FIELDS 5

ULONG gSemAcquireLocArrayLength = 0;

ULONG SemAcquireLocCountCallback(
    PFIELD_INFO pField,
    PULONG pSemAcquireLocArrayLength
    )
{
    ULONG Count = (ULONG)pField->address;

    *pSemAcquireLocArrayLength = (Count < gSemAcquireLocArrayLength) ? Count : 0;

    return ULONGCallback(pField, pSemAcquireLocArrayLength);
}

DECLARE_API( semorder )
{
    ULONG64 ThreadAddress = CURRENT_THREAD_ADDRESS;
    ULONG64 Tcb_Header_Type;
    DEBUG_VALUE W32ThreadAddress;
    ULONG64 SemTableAddress;
    BOOL    bShowALocs = TRUE;
    ULONG   error;

    static char szHeader[]      = " hSem x hold count\tOrder\tParent";
    static char szHeaderALoc[]  = " hSem x hold count\tOrder\tParent    \n\t Acquisitions: name and location";

    ULONG   dwProcessor=0;
    HANDLE  hCurrentThread=NULL;

    INIT_API();

    PARSE_ARGUMENTS(semorder_help);

    if (parse_iFindSwitch(tokens, ntok, 'n')!=-1)
    {
        bShowALocs = FALSE;
    }

    if (!GetExpressionEx(args, &ThreadAddress, &args))
    {
        while (*args && isspace(*args)) args++;
        if (*args)
        {
            if (args[0] == '-' && args[1]=='n' && (args[2] == 0 || isspace(args[2])))
            {
                args += 2;
                while (*args && isspace(*args)) args++;

                if (*args && !GetExpressionEx(args, &ThreadAddress, &args))
                {
                    dprintf("Error: invalid arguments: %s\n", args);
                    goto semorder_help;
                }
            }
            else
            {
                dprintf("Error: invalid arguments: %s\n", args);
                goto semorder_help;
            }
        }
    }

    if (S_OK != GetThreadField(Client, &ThreadAddress, "Tcb.Win32Thread",
                               &W32ThreadAddress, DEBUG_VALUE_INT64))
    {
        EXIT_API(S_OK);
    }

    ExtVerb("  W32Thread = 0x%p\n", W32ThreadAddress.I64);

    if (error = GetFieldValue(W32ThreadAddress.I64, GDIType(W32THREAD), "pSemTable", SemTableAddress))
    {
        dprintf("Unable to get pSemTable from W32THREAD 0x%p\n", W32ThreadAddress.I64 );
        dprintf("  (GetFieldValue returned %s)\n", pszWinDbgError(error));
        EXIT_API(S_OK);
    }

    ExtVerb("  pSemTable = %p\n", SemTableAddress);

    if (SemTableAddress == 0)
    {
        dprintf("  No semaphores have been tracked for validation.\n");
    }
    else
    {
        FIELD_INFO SemEntryList = { NULL, DbgStr(szHeaderALoc),
                                    0 /*pSemTable->numEntries*/, 0, 0, ArrayCallback };
        FIELD_INFO SemEntryFields[] = {
            { DbgStr("Acquired"),           NULL,           0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_ARRAY, 0, NULL},
            { DbgStr("Acquired.name"),      DbgStr("\n\t"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.func"),      DbgStr(" in"),  0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.file"),      DbgStr(" @"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.line"),      DbgStr(":"),    0, DBG_DUMP_FIELD_FULL_NAME, 0, LONGCallback},
            { DbgStr("hsem"),               DbgStr(" "),    0, DBG_DUMP_FIELD_FULL_NAME, 0, DWORDCallback},
            { DbgStr("count"),              DbgStr(" x "),  0, DBG_DUMP_FIELD_FULL_NAME, 0, SemAcquireLocCountCallback},
            { DbgStr("order"),              DbgStr("\t"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, ULONGCallback},
            { DbgStr("parent"),             DbgStr("\t"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, DWORDCallback},
        };
        SYM_DUMP_PARAM SemEntrySym = {
           sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SemEntry)), 
           DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY,
           0 /*pSemTable->entries*/,
           &SemEntryList, &SemEntryFields[0].size, NULL,
           sizeof(SemEntryFields)/sizeof(SemEntryFields[0]), SemEntryFields
        };
        PrepareCallbacks(FALSE, 0);

        if (error = (ULONG)InitTypeRead(SemTableAddress, win32k!SemTable))
        {
            dprintf("Error: InitTypeRead for SemTable returned %s\n", pszWinDbgError(error));
            EXIT_API(S_OK);
        }

        SemEntryList.size = (ULONG)ReadField(numEntries);

        if (SemEntryList.size == 0)
        {
            dprintf(" No entries are currently held.\n");
        }
        else
        {
            SemEntrySym.addr = ReadField(entries);

            gSemAcquireLocArrayLength = 0;

            if (bShowALocs)
            {
                FIELD_INFO SemEntryLocEntrySizeField = { DbgStr("Acquired[0]"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
                FIELD_INFO SemEntryLocArraySizeField = { DbgStr("Acquired"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
                SYM_DUMP_PARAM SemEntryLocSizeSym = {
                   sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SemEntry)), 
                   DBG_DUMP_NO_PRINT, 0,
                   NULL, NULL, NULL,
                   1, &SemEntryLocEntrySizeField
                };

                // Get size of one entry
                error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntryLocSizeSym, SemEntryLocSizeSym.size);

                if (!error && SemEntryLocEntrySizeField.size != 0)
                {
                    SemEntryLocSizeSym.Fields = &SemEntryLocArraySizeField;

                    // Get size of entire array
                    error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntryLocSizeSym, SemEntryLocSizeSym.size);

                    if (!error)
                    {
                        gSemAcquireLocArrayLength = SemEntryLocArraySizeField.size / SemEntryLocEntrySizeField.size;
                    }
                }
            }

            if (gSemAcquireLocArrayLength == 0)
            {
                // Setup dump to ignore acquisition location info
                SemEntryList.printName = DbgStr(szHeader);

                SemEntrySym.nFields -= NUM_ALOC_FIELDS;
                SemEntrySym.Fields += NUM_ALOC_FIELDS;

                SemEntryFields[NUM_ALOC_FIELDS+1].fieldCallBack = ULONGCallback;
            }

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntrySym, SemEntrySym.size);

            dprintf("\n");

            if (error)
            {
                dprintf("Error: Ioctl returned %s\n", pszWinDbgError(error));
            }
        }
    }

    EXIT_API(S_OK);

semorder_help:
    dprintf("Usage: semorder [-n] [thread]\n"
            "\n"
            "           -n  Don't display acquisition location details\n");
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\hmgr.cxx ===
/******************************Module*Header*******************************\
* Module Name: hmgr.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// Sometimes GDI _ENTRY structure can't be read.
//  We can use another module's version since the structure should be the same.
CHAR szEntryType[MAX_PATH];

CachedType Entry = {FALSE, "_ENTRY", 0, 0, 0};

// Cache virtual table addresses for each session since the lookup is slow.
// Additionally cache one for the current session since it too is now slow.
#define NUM_CACHED_SESSIONS 8
struct {
    ULONG   UniqueState;
    ULONG64 VirtualTableAddr;
} CachedTableAddr[NUM_CACHED_SESSIONS+1] = { { 0, 0 } };

BitFieldInfo *HandleIndex;
BitFieldInfo *HandleType;
BitFieldInfo *HandleAltType;
BitFieldInfo *HandleFullType;
BitFieldInfo *HandleStock;
BitFieldInfo *HandleFullUnique;


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   HmgrInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void HmgrInit(PDEBUG_CLIENT Client)
{
    strcpy(szEntryType, GDIType(_ENTRY));

    Entry.Valid = FALSE;
    Entry.Module = 0;
    Entry.TypeId = 0;
    Entry.Size = 0;

    if (HandleIndex != NULL) HandleIndex->Valid = FALSE;
    if (HandleType != NULL) HandleType->Valid = FALSE;
    if (HandleAltType != NULL) HandleAltType->Valid = FALSE;
    if (HandleFullType != NULL) HandleFullType->Valid = FALSE;
    if (HandleStock != NULL) HandleStock->Valid = FALSE;
    if (HandleFullUnique != NULL) HandleFullUnique->Valid = FALSE;

    for (int s = 0; s < sizeof(CachedTableAddr)/sizeof(CachedTableAddr[0]); s++)
    {
        CachedTableAddr[s].UniqueState = INVALID_UNIQUE_STATE;
    }

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   HmgrExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void HmgrExit()
{
    if (HandleIndex != NULL)
    {
        delete HandleIndex;
        HandleIndex = NULL;
    }

    if (HandleType != NULL)
    {
        delete HandleType;
        HandleType = NULL;
    }

    if (HandleAltType != NULL)
    {
        delete HandleAltType;
        HandleAltType = NULL;
    }

    if (HandleFullType != NULL)
    {
        delete HandleFullType;
        HandleFullType = NULL;
    }

    if (HandleStock != NULL)
    {
        delete HandleStock;
        HandleStock = NULL;
    }

    if (HandleFullUnique != NULL)
    {
        delete HandleFullUnique;
        HandleFullUnique = NULL;
    }

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntryType
*
* Routine Description:
*
*   looks up hmgr entry type id and module
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   TypeId - Pointer to receive entry's type id
*   Module - Pointer to receive entry's module
*
* Return Value:
*
*   S_OK if successful.
*
\**************************************************************************/

HRESULT
GetEntryType(
    PDEBUG_CLIENT Client,
    PULONG TypeId,
    PULONG64 Module
    )
{
    HRESULT hr = S_OK;

    if (!Entry.Valid)
    {
        OutputControl   OutCtl(Client);
        PDEBUG_SYMBOLS  Symbols;

        if (TypeId != NULL) *TypeId = 0;
        if (Module != NULL) *Module = 0;

        if (Client == NULL) return E_INVALIDARG;

        if (Type_Module.Base == 0)
        {
            OutCtl.OutErr("Symbols not initialized properly.\n"
                           " Please use !reinit.\n");
            return S_FALSE;
        }

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) != S_OK)
        {
            return hr;
        }

        if ((hr = Symbols->GetTypeId(Type_Module.Base, Entry.Type, &Entry.TypeId)) == S_OK)
        {
            Entry.Module = Type_Module.Base;
            Entry.Valid = TRUE;

            sprintf(szEntryType, "%s!%s", Type_Module.Name, Entry.Type);

            OutCtl.OutVerb("Found %s in module %s @ 0x%p.\n",
                            Entry.Type, Type_Module.Name, Entry.Module);
        }
        else
        {
            ULONG   ModuleIndex = 0;
            ULONG64 ModuleBase = 0;

            while (Symbols->GetModuleByIndex(ModuleIndex, &Entry.Module) == S_OK &&
                   Entry.Module != 0)
            {
                if ((hr = Symbols->GetTypeId(Entry.Module,
                                             Entry.Type,
                                             &Entry.TypeId)) == S_OK)
                {
                    OutCtl.OutVerb("Found %s: TypeId 0x%lx in module @ 0x%p.\n",
                                   Entry.Type, Entry.TypeId, Entry.Module);
                    break;
                }

                ModuleIndex++;
                Entry.Module = 0;
            }

            if (hr != S_OK)
            {
                Entry.Module = 0;
                Entry.TypeId = 0;
                OutCtl.OutErr("Unable to find type '%s'.\n", Entry.Type);
            }
            else
            {
                Entry.Valid = TRUE;

                if (Symbols->GetModuleNames(ModuleIndex, Entry.Module,
                                            NULL, 0, NULL,
                                            szEntryType, sizeof(szEntryType), NULL,
                                            NULL, 0, NULL) == S_OK)
                {
                    OutCtl.OutVerb("Found %s in module(%lu) %s @ %p.\n",
                                    Entry.Type, ModuleIndex, szEntryType, Entry.Module);
                    strcat(szEntryType, "!");
                    strcat(szEntryType, "_ENTRY");
                }
                else
                {
                    OutCtl.OutVerb("Found %s in unknown module(%lu) @ %p.\n",
                                    Entry.Type, ModuleIndex, Entry.Module);
                    strcpy(szEntryType, Entry.Type);
                }
            }
        }
    }

    if (hr == S_OK)
    {
        if (TypeId != NULL) *TypeId = Entry.TypeId;
        if (Module != NULL) *Module = Entry.Module;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntrySize
*
* Routine Description:
*
*   looks up hmgr entry size
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   address of handle manager entry
*
\**************************************************************************/

ULONG GetEntrySize(
    PDEBUG_CLIENT Client
    )
{
    if (Entry.Size == 0)
    {
        PDEBUG_SYMBOLS  Symbols;

        if (Client != NULL &&
            GetEntryType(Client, NULL, NULL) == S_OK &&
            Client->QueryInterface(__uuidof(IDebugSymbols),
                                   (void **)&Symbols) == S_OK)
        {
            if (Symbols->GetTypeSize(Entry.Module,
                                     Entry.TypeId,
                                     &Entry.Size) != S_OK)
            {
                OutputControl   OutCtl(Client);
                OutCtl.OutErr("Unable to get size of _ENTRY.\n");
                Entry.Size = 0;
            }

            Symbols->Release();
        }
    }

    return Entry.Size;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetIndexFromHandle
*
* Routine Description:
*
*   Decodes entry index from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Index - Address to receive extracted handle index
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetIndexFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Index
    )
{
    HRESULT hr = S_FALSE;

    if (HandleIndex == NULL)
    {
        HandleIndex = new BitFieldInfo;
    }

    if (HandleIndex == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleIndex->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleIndex);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if (OutState.Execute("dt " GDIType(GDIHandleBitFields) " Index") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                // Use position 0 and INDEX_BITS from ntgdistr.h
                HandleIndex->Valid = HandleIndex->Compose(0, INDEX_BITS);
                hr = HandleIndex->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Index != NULL)
    {
        if (hr == S_OK)
        {
            *Index = (Handle64 & HandleIndex->Mask) >> HandleIndex->BitPos;
        }
        else
        {
            *Index = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetTypeFromHandle
*
* Routine Description:
*
*   Decodes base type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Type - Address to receive extracted handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Type,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleType == NULL)
    {
        HandleType = new BitFieldInfo;
    }

    if (HandleType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleType);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " Type")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position TYPE_SHIFT and TYPE_BITS from ntgdistr.h
                HandleType->Valid = HandleType->Compose(TYPE_SHIFT, TYPE_BITS);
                hr = HandleType->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Type != NULL)
    {
        if (hr == S_OK)
        {
            *Type = Handle64 & HandleType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *Type >>= HandleType->BitPos;
            }
        }
        else
        {
            *Type = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetAltTypeFromHandle
*
* Routine Description:
*
*   Decodes alt type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   AltType - Address to receive extracted alt handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetAltTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 AltType,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleAltType == NULL)
    {
        HandleAltType = new BitFieldInfo;
    }

    if (HandleAltType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleAltType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleAltType);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " AltType")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position ALTTYPE_SHIFT and ALTTYPE_BITS from ntgdistr.h
                HandleAltType->Valid = HandleAltType->Compose(ALTTYPE_SHIFT, ALTTYPE_BITS);
                hr = HandleAltType->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (AltType != NULL)
    {
        if (hr == S_OK)
        {
            *AltType = Handle64 & HandleAltType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *AltType >>= HandleAltType->BitPos;
            }
        }
        else
        {
            *AltType = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetFullTypeFromHandle
*
* Routine Description:
*
*   Decodes full type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   FullType - Address to receive extracted full handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetFullTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 FullType,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleFullType == NULL)
    {
        HandleFullType = new BitFieldInfo;
    }

    if (HandleFullType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleFullType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        if ((hr = GetTypeFromHandle(Client, 0, NULL)) == S_OK &&
            (hr = GetAltTypeFromHandle(Client, 0, NULL)) == S_OK)
        {
            if (!HandleType->Valid || HandleType->Bits == 0)
            {
                *HandleFullType = *HandleAltType;
            }
            else if (!HandleAltType->Valid || HandleAltType->Bits == 0)
            {
                *HandleFullType = *HandleType;
            }
            else
            {
                ULONG64 Mask;

                HandleFullType->BitPos = min(HandleType->BitPos, HandleAltType->BitPos);
                HandleFullType->Bits = max(HandleAltType->Bits+HandleAltType->BitPos,
                                           HandleType->Bits+HandleType->BitPos) -
                                       HandleFullType->BitPos;
                HandleFullType->Mask = HandleAltType->Mask | HandleType->Mask;

                // Make sure we have the BitPos and Bits count correct
                for (Mask = HandleFullType->Mask >> HandleFullType->BitPos;
                     HandleFullType->Bits > 0 && ((Mask & 1) == 0);
                     HandleFullType->Bits--, Mask >> 1)
                {
                    HandleFullType->BitPos++;
                }

                HandleFullType->Valid = (HandleFullType->Bits > 0);
            }

            if (!HandleFullType->Valid)
            {
                hr = S_FALSE;
            }
        }
    }

    if (FullType != NULL)
    {
        if (hr == S_OK)
        {
            *FullType = Handle64 & HandleFullType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *FullType >>= HandleFullType->BitPos;
            }
        }
        else
        {
            *FullType = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetStockFromHandle
*
* Routine Description:
*
*   Decodes stock value from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Stock - Address to receive extracted handle stock setting
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetStockFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Stock,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleStock == NULL)
    {
        HandleStock = new BitFieldInfo;
    }

    if (HandleStock == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleStock->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleStock);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " Stock")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position STOCK_SHIFT and STOCK_BITS from ntgdistr.h
                HandleStock->Valid = HandleStock->Compose(STOCK_SHIFT, STOCK_BITS);
                hr = HandleStock->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Stock != NULL)
    {
        if (hr == S_OK)
        {
            *Stock = Handle64 & HandleStock->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *Stock >>= HandleStock->BitPos;
            }
        }
        else
        {
            *Stock = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetFullUniqueFromHandle
*
* Routine Description:
*
*   Decodes full unique value from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   FullUnique - Address to receive extracted handle FullUnique value
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetFullUniqueFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 FullUnique,
    ULONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleFullUnique == NULL)
    {
        HandleFullUnique = new BitFieldInfo;
    }

    if (HandleFullUnique == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleFullUnique->Valid)
    {
        hr = S_OK;
    }
    else
    {
        if (HandleIndex == NULL || !HandleIndex->Valid)
        {
            // Try to read Index bitfield
            hr = GetIndexFromHandle(Client, 0, NULL);
        }

        if (HandleIndex != NULL && HandleIndex->Valid)
        {
            BitFieldInfo        GDIHandle;
            BitFieldParser      BitFieldReader(Client, &GDIHandle);
            OutputState         OutState(Client);

            if ((hr = BitFieldReader.Ready()) == S_OK &&
                (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
            {
                // Read FullUnique from symbol file
                if (OutState.Execute("dt " GDIType(GDIHandleBitFields)) == S_OK &&
                    BitFieldReader.ParseOutput() == S_OK &&
                    BitFieldReader.Complete() == S_OK)
                {
                    ULONG64 Mask;

                    HandleFullUnique->BitPos = HandleIndex->BitPos + HandleIndex->Bits;
                    HandleFullUnique->Bits = GDIHandle.Bits - HandleFullUnique->BitPos;
                    HandleFullUnique->Mask = GDIHandle.Mask & ~HandleIndex->Mask;
                    
                    // Make sure we have the BitPos and Bits count correct
                    for (Mask = HandleFullUnique->Mask >> HandleFullUnique->BitPos;
                         HandleFullUnique->Bits > 0 && ((Mask & 1) == 0);
                         HandleFullUnique->Bits--, Mask >> 1)
                    {
                        HandleFullUnique->BitPos++;
                    }

                    HandleFullUnique->Valid = (HandleFullUnique->Bits > 0);
                }
                else
                {
                    // Use values from ntgdistr.h
                    HandleFullUnique->Valid =
                        HandleFullUnique->Compose(TYPE_SHIFT,
                                                 TYPE_BITS + 
                                                 ALTTYPE_BITS + 
                                                 STOCK_BITS + 
                                                 UNIQUE_BITS);
                }

                hr = HandleFullUnique->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (FullUnique != NULL)
    {
        if (hr == S_OK)
        {
            *FullUnique = Handle64 & HandleFullUnique->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *FullUnique >>= HandleFullUnique->BitPos;
            }
        }
        else
        {
            *FullUnique = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetHandleTable
*
* Routine Description:
*
*   reads current location of handle table
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   TableAddr - PULONG64 to return start address of handle table
*
* Return Value:
*
*   If successful, S_OK.
*
\**************************************************************************/

HRESULT
GetHandleTable(
    PDEBUG_CLIENT Client,
    PULONG64 TableAddr
    )
{
    ULONG CurrentUniqueState = UniqueTargetState;

    HRESULT     hr;

    PDEBUG_CONTROL      Control;
    PDEBUG_SYMBOLS      Symbols;
    PDEBUG_DATA_SPACES  Data;

    if (TableAddr == NULL)
    {
        return E_INVALIDARG;
    }

    if (CurrentUniqueState != INVALID_UNIQUE_STATE)
    {
        if (SessionId < NUM_CACHED_SESSIONS)
        {
            if (CachedTableAddr[SessionId].UniqueState == CurrentUniqueState)
            {
                *TableAddr = CachedTableAddr[SessionId].VirtualTableAddr;
                return S_OK;
            }
        }
        else if (SessionId == CURRENT_SESSION)
        {
            if (CachedTableAddr[NUM_CACHED_SESSIONS].UniqueState == CurrentUniqueState)
            {
                *TableAddr = CachedTableAddr[NUM_CACHED_SESSIONS].VirtualTableAddr;
                return S_OK;
            }
        }
    }

    *TableAddr = 0;

    if (Client == NULL) return E_INVALIDARG;

    OutputControl   OutCtl(Client);

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Symbols->Release();
        return hr;
    }

    CHAR    PointerName[80];
    ULONG64 pent;

    hr = S_FALSE;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        sprintf(PointerName, "%s!gpentHmgr", GDIKM_Module.Name);
        hr = Symbols->GetOffsetByName(PointerName, &pent);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to locate %s\n", PointerName);
        }
    }

    if (hr != S_OK && SessionId == CURRENT_SESSION)
    {
        sprintf(PointerName, "%s!pGdiSharedHandleTable", GDIUM_Module.Name);
        hr = Symbols->GetOffsetByName(PointerName, &pent);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to locate %s\n", PointerName);
        }
    }


    if (hr == S_OK)
    {
        if (SessionId == CURRENT_SESSION)
        {
            hr = Data->ReadPointersVirtual(1, pent, TableAddr);

            if (hr == S_OK)
            {
                CachedTableAddr[NUM_CACHED_SESSIONS].VirtualTableAddr = *TableAddr;
                CachedTableAddr[NUM_CACHED_SESSIONS].UniqueState = CurrentUniqueState;
            }
        }
        else
        {
            ULONG64 pentPhys;

            if ((hr = GetPhysicalAddress(Client,
                                         SessionId,
                                         pent,
                                         &pentPhys)) == S_OK)
            {
                hr = ReadPointerPhysical(Client, pentPhys, TableAddr);

                if (hr == S_OK)
                {
                    if (SessionId < NUM_CACHED_SESSIONS)
                    {
                        CachedTableAddr[SessionId].VirtualTableAddr = *TableAddr;
                        CachedTableAddr[SessionId].UniqueState = CurrentUniqueState;
                    }
                }
            }
        }

        if (hr == S_OK)
        {
            if (!*TableAddr)
            {
                OutCtl.OutErr(" GDI handle manager is not initialized or symbols are incorrect.\n"
                              "  %s @ %#p is NULL.\n", PointerName, pent);
                hr = S_FALSE;
            }
        }
        else
        {
            OutCtl.OutErr("Unable to get the contents of %s @ %#p\n",
                          PointerName, pent);
        }
    }

    Data->Release();
    Symbols->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetMaxHandles
*
* Routine Description:
*
*   reads current maximum number of handles
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   Zero for failure, otherwise maximum valid handle index
*
\**************************************************************************/

HRESULT
GetMaxHandles(
    PDEBUG_CLIENT Client,
    PULONG64 MaxHandles
    )
{
    static ULONG    CachedUniqueState = INVALID_UNIQUE_STATE;
    static ULONG    LastSession = INVALID_SESSION;
    static ULONG64  LastMaxHandles = 0;

    ULONG CurrentUniqueState = UniqueTargetState;

    HRESULT         hr;


    if (MaxHandles == NULL) return E_INVALIDARG;

    if (CurrentUniqueState != INVALID_UNIQUE_STATE &&
        CachedUniqueState == CurrentUniqueState &&
        LastSession == SessionId)
    {
        *MaxHandles = LastMaxHandles;
        return S_OK;
    }


    if (Client == NULL) return E_INVALIDARG;

    OutputControl   OutCtl(Client);


    hr = S_FALSE;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        CHAR    SymName[80];

        sprintf(SymName, "%s!gcMaxHmgr", GDIKM_Module.Name);
        hr = ReadSymbolData(Client, SymName, MaxHandles, sizeof(*MaxHandles), NULL);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to get contents of %s\n", SymName);
        }
    }

    if (hr != S_OK)
    {
        ULONG64 Module;
        ULONG   TypeId;

        if ((hr = GetTypeId(Client, "_GDI_SHARED_MEMORY", &TypeId, &Module)) == S_OK)
        {
            ULONG   NumHandles;

            hr = GetFieldSize(Client, Module, TypeId, "aentryHmgr",
                              NULL, &NumHandles, NULL);

            if (hr == S_OK)
            {
                *MaxHandles = NumHandles;
            }
            else
            {
                OutCtl.OutErr("Unable to get length of _GDI_SHARED_MEMORY.aentryHmgr\n");
            }
        }
    }

    if (hr == S_OK)
    {
        CachedUniqueState = CurrentUniqueState;
        LastSession = SessionId;
        LastMaxHandles = *MaxHandles;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntryAddress
*
* Routine Description:
*
*   looks up hmgr entry for an engine handle index
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Index64 -- engine handle index
*
* Return Value:
*
*   address of handle manager entry
*
\**************************************************************************/

HRESULT
GetEntryAddress(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 EntryAddr,
    PBOOL Physical
    )
{
    HRESULT     hr;
    ULONG64     Index;
    ULONG64     MaxIndex;
    ULONG64     TableAddr;
    ULONG       EntSize;

    *EntryAddr = 0;
    *Physical = FALSE;

    if ((hr = GetIndexFromHandle(Client, Handle64, &Index)) == S_OK &&
        (hr = GetHandleTable(Client, &TableAddr)) == S_OK &&
        (hr = GetMaxHandles(Client, &MaxIndex)) == S_OK)
    {
        if (Index >= MaxIndex)
        {
            OutputControl   OutCtl(Client);
            OutCtl.OutVerb("Bad index: Index (%I64x) >= Max Handles (%I64x)\n",
                           Index, MaxIndex);

            hr = S_FALSE;
        }
        else
        {
            if ((EntSize = GetEntrySize(Client)) == 0)
            {
                hr = S_FALSE;
            }
        }
    }

    if (hr == S_OK)
    {
        if (SessionId != CURRENT_SESSION)
        {
            *Physical = TRUE;
            hr = GetPhysicalAddress(Client, SessionId,
                                    TableAddr + EntSize * Index,
                                    EntryAddr);
        }
        else
        {
            *EntryAddr = TableAddr + EntSize * Index;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetObjectAddress
*
* Routine Desciption:
*
*   Converts an engine handle to an address of an object
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 -- engine handle
*   ValidateBaseObj -- verifies _BASEOBJECT.hHmgr == Handle64
*   ExcpectedType -- Object type expected to find
*
* Return Value:
*
*   Address of object if Handle64 leads to valid object of ExpectedType
*   otherwise 0.
*
\**************************************************************************/

HRESULT
GetObjectAddress(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Address,
    UCHAR ExpectedType,
    BOOL ValidateFullUnique,
    BOOL ValidateBaseObj
    )
{
    HRESULT         hr;
    PDEBUG_CONTROL  Control;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         EntryAddr;
    BOOL            Physical;
    UCHAR           Type;
    ULONG64         ObjAddr = 0;

    if (Address != NULL) *Address = 0;

    if (Client == NULL) return E_INVALIDARG;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Control->Release();
        return hr;
    }

    OutputControl   OutCtl(Client);

    if ((hr = GetEntryAddress(Client, Handle64, &EntryAddr, &Physical)) == S_OK)
    {
        ULONG64                 EntryModule = 0;
        ULONG                   EntryTypeId = 0;
        ULONG64                 HandlesFullUnique;
        DEBUG_VALUE             FullUnique;
        DEBUG_VALUE             Objt;
        DEBUG_VALUE             pobj;
        TypeOutputParser        EntryReader(Client);
        OutputState             OutState(Client);
        ULONG                   TypeOutFlags = DEBUG_OUTTYPE_RECURSION_LEVEL(((Physical || !ValidateBaseObj) ? 1 : 2));

        if ((hr = OutState.Setup(0, &EntryReader)) == S_OK &&
            (hr = OutState.OutputType(Physical,
                                      EntryAddr,
                                      Entry.Module,
                                      Entry.TypeId,
                                      TypeOutFlags)) == S_OK)
        {
            if (ExpectedType != ANY_TYPE)
            {
                if ((hr = EntryReader.Get(&Objt, "Objt", DEBUG_VALUE_INT8)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's object type, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    ExpectedType != Objt.I8)
                {
                    OutCtl.OutVerb(" Expected type (0x%lx) doesn't match entry's (0x%lx)\n",
                                   (ULONG)ExpectedType, (ULONG)Objt.I8);
                    hr = S_FALSE;
                }
            }

            if (hr == S_OK && ValidateFullUnique)
            {
                if ((hr = EntryReader.Get(&FullUnique, "FullUnique", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's full unique value, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    (hr = GetFullUniqueFromHandle(Client, Handle64, &HandlesFullUnique)) != S_OK)
                {
                    OutCtl.OutErr("Unable to extract full unique value from handle, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    HandlesFullUnique != FullUnique.I64)
                {
                    OutCtl.OutVerb(" Handle's full unique value (0x%p) doesn't match entry's (0x%p)\n",
                                   HandlesFullUnique, FullUnique.I64);
                    hr = S_FALSE;
                }
            }

            // If valid so far, get the object address.
            if (hr == S_OK)
            {
                if ((hr = EntryReader.Get(&pobj, "pobj", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's object address, %s.\n",
                                  pszHRESULT(hr));
                }
                else
                {
                    ObjAddr = pobj.I64;
                }
            }

            if (hr == S_OK && ValidateBaseObj)
            {
                DEBUG_VALUE     ObjHandle;

                if (Physical)
                {
                    hr = OutState.OutputTypeVirtual(ObjAddr, "_BASEOBJECT", 0);
                }

                if (hr != S_OK ||
                    (hr = EntryReader.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to read object's base info, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    ObjHandle.I64 != Handle64)
                {
                    // If Handle64's full unique bits weren't validated and
                    // Handle64 doesn't match hHmgr in baseobj,
                    // set them to to full unique from entry.
                    if (!ValidateFullUnique)
                    {
                        if ((hr = EntryReader.Get(&FullUnique, "FullUnique", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            OutCtl.OutErr("Unable to get entry's full unique value, %s.\n",
                                          pszHRESULT(hr));
                        }

                        // Make sure HandleFullUnique is valid
                        if (hr == S_OK &&
                            (hr = GetFullUniqueFromHandle(Client, 0, NULL)) != S_OK)
                        {
                            OutCtl.OutErr("Unable to compose handle from entry, %s.\n", pszHRESULT(hr));
                        }
                        else
                        {
                            Handle64 = (Handle64 & ~(HandleFullUnique->Mask)) |
                                       (FullUnique.I64 << HandleFullUnique->BitPos);

                            if (Control->IsPointer64Bit() != S_OK)
                            {
                                Handle64 = DEBUG_EXTEND64(Handle64);
                            }
                        }
                    }

                    if (hr == S_OK &&
                        ObjHandle.I64 != Handle64)
                    {
                        OutCtl.OutVerb(" Handle (0x%p) doesn't match object's hHmgr (0x%p)\n",
                                       Handle64, ObjHandle.I64);
                        hr = S_FALSE;
                    }
                }
            }
        }
    }
    
    if (hr == S_OK &&
        Address != NULL)
    {
        *Address = ObjAddr;
    }

    Symbols->Release();
    Control->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetObjectHandle
*
* Routine Desciption:
*
*   Retrieves handle of an object from it address
*
* Arguments:
*
*   Client -- PDEBUG_CLIENT
*   ObjectAddr -- Address of OBJECT
*   Handle64 -- ULONG64 to receive engine handle
*   ValidateHandle -- verifies ENTRY.pobj == ObjectAddr
*   ExcpectedType -- Object type expected to find
*                    Currently only value when ValidateHandle is TRUE
*
* Return Value:
*
*   HRESULT of retrieval attempts and validation.
*       S_OK indicates everything succeeded.
*
\**************************************************************************/

HRESULT
GetObjectHandle(
    PDEBUG_CLIENT Client,
    ULONG64 ObjectAddr,
    PULONG64 Handle64,
    BOOL ValidateHandle,
    UCHAR ExpectedType
    )
{
    HRESULT                 hr;
    DEBUG_VALUE             ObjHandle;
    TypeOutputParser        ObjectReader(Client);
    OutputState             OutState(Client);

    if (Handle64 != NULL) *Handle64 = 0;

    if (ObjectAddr == 0) return E_INVALIDARG;

    if ((hr = OutState.Setup(0, &ObjectReader)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(ObjectAddr,
                                         "_BASEOBJECT",
                                         0)) == S_OK)
    {
        hr = ObjectReader.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64);
    }

    if (hr == S_OK && ValidateHandle)
    {
        ULONG64 ObjectAddrFromHmgr;

        hr = GetObjectAddress(Client, ObjHandle.I64, &ObjectAddrFromHmgr,
                              ExpectedType, TRUE, FALSE);

        if (hr == S_OK &&
            ObjectAddrFromHmgr != ObjectAddr)
        {
            hr = S_FALSE;
        }
    }

    if (hr == S_OK && Handle64 != NULL)
    {
        *Handle64 = ObjHandle.I64;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   OutputHandleInfo
*
* Routine Desciption:
*
*   Retrieves handle of an object from it address
*
* Arguments:
*
*   Client -- PDEBUG_CLIENT
*   Handle64 -- engine handle
*
* Return Value:
*
*   HRESULT of retrieval attempts and validation.
*       S_OK indicates everything succeeded.
*
\**************************************************************************/

HRESULT
OutputHandleInfo(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE Handle
    )
{
    if (Client == NULL || OutCtl == NULL || Handle == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT     hrRet;
    HRESULT     hr;
    DEBUG_VALUE ConvValue;
    ULONG64     Type;
    ULONG64     FullType;
    ULONG64     Stock;
    ENUMDEF    *pEnumDef;

    if (Handle->Type != DEBUG_VALUE_INT64)
    {
        if ((hr = OutCtl->CoerceValue(Handle, DEBUG_VALUE_INT64, &ConvValue)) != S_OK)
        {
            return hr;
        }

        Handle = &ConvValue;
    }

    if (Handle->I64 == 0) 
    {
        return S_OK;
    }

    hrRet = GetTypeFromHandle(Client, Handle->I64, &Type);

    if (hrRet == S_OK)
    {
        DbgPrint("Handle 0x%I64x's type is %I64x.\n", Handle->I64, Type);

        pEnumDef = aedENTRY_Objt;

        while (pEnumDef->psz != NULL)
        {
            if (pEnumDef->ul == Type)
            {
                OutCtl->Output(pEnumDef->psz);
                break;
            }

            pEnumDef++;
        }

        if (pEnumDef->psz == NULL)
        {
            OutCtl->Output("Unknown type %I64d", Type);
        }
    }
    else
    {
        OutCtl->Output("Unable to extract type");
    }

    hr = GetFullTypeFromHandle(Client, Handle->I64, &FullType, GET_BITS_UNSHIFTED);

    if (hr == S_OK)
    {
        DbgPrint("Handle 0x%I64x's Full Type is %I64x.\n", Handle->I64, FullType);

        pEnumDef = aedENTRY_FullType;

        while (pEnumDef->psz != NULL)
        {
            if (pEnumDef->ul == FullType)
            {
                OutCtl->Output(" : %s", pEnumDef->psz);
                break;;
            }

            pEnumDef++;
        }

        if (pEnumDef->psz == NULL)
        {
            ULONG64 AltType;

            hr = GetAltTypeFromHandle(Client, Handle->I64, &AltType);

            if (hr == S_OK && AltType != 0)
            {
                OutCtl->Output(" : Unknown alt type %I64d", AltType);
            }
        }
    }
    else if (hrRet == S_OK)
    {
        hrRet = hr;
    }

    hr = GetStockFromHandle(Client, Handle->I64, &Stock);

    if (hr == S_OK)
    {
        if (Stock)
        {
            OutCtl->Output(" (STOCK)");
        }
    }
    else if (hrRet == S_OK)
    {
        hrRet = hr;
    }

    return hrRet;
}


HRESULT
OutputFullUniqueInfo(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE FullUnique
    )
{
    if (Client == NULL || OutCtl == NULL || FullUnique == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT     hr;
    ULONG64     FullUniqTest;
    DEBUG_VALUE Handle;

    hr = GetFullUniqueFromHandle(Client, -1, &FullUniqTest);

    if (hr == S_OK)
    {
        if (FullUniqTest == 0)
        {
            hr = S_FALSE;
        }
        else
        {
            if (FullUnique->Type == DEBUG_VALUE_INT64)
            {
                Handle = *FullUnique;
            }
            else
            {
                hr = OutCtl->CoerceValue(FullUnique, DEBUG_VALUE_INT64, &Handle);

                if (hr != S_OK) return hr;
            }

            Handle.I64 <<= HandleFullUnique->BitPos;

            hr = OutputHandleInfo(OutCtl, Client, &Handle);
        }
    }

    return hr;
}


char *pszTypes[] = {
"DEF_TYPE     ",
"DC_TYPE      ",
"UNUSED1      ",
"UNUSED2      ",
"RGN_TYPE     ",
"SURF_TYPE    ",
"CLIOBJ_TYPE  ",
"PATH_TYPE    ",
"PAL_TYPE     ",
"ICMLCS_TYPE  ",
"LFONT_TYPE   ",
"RFONT_TYPE   ",
"PFE_TYPE     ",
"PFT_TYPE     ",
"ICMCXF_TYPE  ",
"ICMDLL_TYPE  ",
"BRUSH_TYPE   ",
"UNUSED3      ",
"UNUSED4      ",
"SPACE_TYPE   ",
"UNUSED5      ",
"META_TYPE    ",
"EFSTATE_TYPE ",
"BMFD_TYPE    ",
"VTFD_TYPE    ",
"TTFD_TYPE    ",
"RC_TYPE      ",
"TEMP_TYPE    ",
"DRVOBJ_TYPE  ",
"DCIOBJ_TYPE  ",
"SPOOL_TYPE   ",
"TOTALS       ",
"DEF          "
};

/******************************Public*Routine******************************\
* DECLARE_API( dumphmgr  )
*
* Dumps the count of handles in Hmgr for each object type.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

/*
HmgCurrentNumberOfObjects
HmgMaximumNumberOfObjects
HmgCurrentNumberOfLookAsideObjects
HmgMaximumNumberOfLookAsideObjects
HmgNumberOfObjectsAllocated
HmgNumberOfLookAsideHits
HmgCurrentNumberOfHandles
HmgMaximumNumberOfHandles
HmgNumberOfHandlesAllocated
*/

DECLARE_API( dumphmgr  )
{
    INIT_API();
    ExtWarn("Extension 'dumphmgr' is not fully converted.\n");
    HRESULT hr;
    ULONG64 pent;
    ULONG64 gcMaxHmgr;
    ULONG   entSize;

    DEBUG_VALUE ObjType;

    ULONG ulLoop;    // loop variable
    ULONG pulCount[MAX_TYPE + 2];
    ULONG cUnknown = 0;
    ULONG cUnknownSize = 0;
    ULONG cUnused = 0;

    DecArrayDumper(HmgCurrentNumberOfHandles, ULONG);
    DecArrayDumper(HmgMaximumNumberOfHandles, ULONG);
    DecArrayDumper(HmgNumberOfHandlesAllocated, ULONG);
    DecArrayDumper(HmgCurrentNumberOfObjects, ULONG);
    DecArrayDumper(HmgMaximumNumberOfObjects, ULONG);
    DecArrayDumper(HmgNumberOfObjectsAllocated, ULONG);
    DecArrayDumper(HmgCurrentNumberOfLookAsideObjects, ULONG);
    DecArrayDumper(HmgMaximumNumberOfLookAsideObjects, ULONG);
    DecArrayDumper(HmgNumberOfLookAsideHits, ULONG);

    char   *TableHeader;
    char    TableFormat[128];

    while (*args && isspace(*args)) args++;
    
    if (*args != '\0')
    {
        ExtOut("dumphmgr displays the count of each type of object in the handle manager\n"
               "\n"
               "Usage: dumphmgr [-?]\n"
               "    -? shows this help\n"
               "\n"
               "    If available statics for Handles, Objects, and objects allocated\n"
               "    from LookAside lists are shown.  Each class has three statics:\n"
               "        Cur - current number of items allocated\n"
               "        Max - largest number of items ever allocated at one time\n"
               "        Total - total allocations ever made for that item\n"
               );

        EXIT_API(S_OK);
    }

    // Get the pointers and counts

    if ((hr = GetHandleTable(Client, &pent)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        EXIT_API(hr);
    }
    
    ExtOut("Handle Entry Table at 0x%p.\n", pent);
    ExtOut("Max handles out so far %I64u.\n", gcMaxHmgr);

    entSize = GetEntrySize(Client);

    if (!entSize || !gcMaxHmgr)
    {
        EXIT_API(S_FALSE);
    }

    ULONG   Reserved;
    ULONG64 Module;
    ULONG   TypeId;
    if ((hr = GetTypeId(Client, "_GDI_SHARED_MEMORY", &TypeId, &Module)) == S_OK)
    {
        hr = GetFieldSize(Client, Module, TypeId, "aentryHmgr", &Reserved);
    }

    // Print out the amount reserved and committed
    ExtOut("Page Size: %lu   Entry Size: %lu\n", PageSize, entSize);
    ExtOut("Total Hmgr: Reserved memory ");
    if (hr == S_OK)
    {
        ExtOut("%lu", Reserved);
    }
    else
    {
        ExtOut("?");
    }
    ExtOut(" Committed %lu\n", ((( (ULONG)gcMaxHmgr * entSize) + PageSize) & ~(PageSize - 1)));
    ExtOut("\n");


    for (ulLoop = 0; ulLoop <= TOTAL_TYPE; ulLoop++)
    {
        pulCount[ulLoop] = 0;
    }

    TypeOutputParser    TypeReader(Client);
    OutputState         OutState(Client);
    ULONG64             EntryModule;
    ULONG               EntryTypeId;

    if ((hr = TypeReader.LookFor(&ObjType, "Objt", DEBUG_VALUE_INT8)) == S_OK &&
        (hr = OutState.Setup(0, &TypeReader)) == S_OK)
    {
        if ((hr = GetTypeId(Client, szEntryType,
                            &EntryTypeId, &EntryModule)) != S_OK)
        {
            ExtErr("GetTypeId(%s) failed.\n", szEntryType);
        }
    }

    if (hr != S_OK)
    {
        ExtErr("Failed to prepare type read: %s\n", pszHRESULT(hr));
        EXIT_API(hr);
    }

    for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
    {
        if (g_pExtControl->GetInterrupt() == S_OK)
        {
            ExtErr("User cancled.\n");
            EXIT_API(E_ABORT);
        }

        TypeReader.DiscardOutput();
        TypeReader.Relook();
        if ((hr = OutState.OutputTypeVirtual(pent,
                                             EntryModule,
                                             EntryTypeId,
                                             0)) != S_OK ||
            (hr = TypeReader.ParseOutput()) != S_OK ||
            (hr = TypeReader.Complete()) != S_OK)
        {
            ExtErr("Error reading table entry @ %p, %s\n", pent, pszHRESULT(hr));
            ExtWarn("Only %lu entries were read.\n", ulLoop);
            break;
        }

        if (ObjType.I8 == DEF_TYPE)
        {
            cUnused++;
        }
        if (ObjType.I8 > MAX_TYPE)
        {
            cUnknown++;
        }
        else
        {
            pulCount[ObjType.I8]++;
        }

        pent += entSize;
    }


    ULONG64 TmpOffset;  // Have to pass an valid pointer when checking for a symbol.

    if (g_pExtSymbols->GetOffsetByName(GDISymbol(HmgCurrentNumberOfObjects), &TmpOffset) == S_OK &&
        HmgCurrentNumberOfObjects.ReadArray(GDISymbol(HmgCurrentNumberOfObjects)) &&
        HmgMaximumNumberOfObjects.ReadArray(GDISymbol(HmgMaximumNumberOfObjects)) &&
        HmgCurrentNumberOfLookAsideObjects.ReadArray(GDISymbol(HmgCurrentNumberOfLookAsideObjects)) &&
        HmgMaximumNumberOfLookAsideObjects.ReadArray(GDISymbol(HmgMaximumNumberOfLookAsideObjects)) &&
        HmgNumberOfObjectsAllocated.ReadArray(GDISymbol(HmgNumberOfObjectsAllocated)) &&
        HmgNumberOfLookAsideHits.ReadArray(GDISymbol(HmgNumberOfLookAsideHits)) &&
        HmgCurrentNumberOfHandles.ReadArray(GDISymbol(HmgCurrentNumberOfHandles)) &&
        HmgMaximumNumberOfHandles.ReadArray(GDISymbol(HmgMaximumNumberOfHandles)) &&
        HmgNumberOfHandlesAllocated.ReadArray(GDISymbol(HmgNumberOfHandlesAllocated))
        )
    {
        ExtOut("             Current  ---- Handles -----  ---- Objects -----  --- LookAside ----\n"
               "    TYPE     Handles   Cur   Max  Total    Cur   Max  Total    Cur   Max  Total\n");

        _snprintf(TableFormat, sizeof(TableFormat),
                  "%%s%%6lu %%c %s %s %s  %s %s %s  %s %s %s\n",
                  HmgCurrentNumberOfHandles.SetPrintFormat(5),
                  HmgMaximumNumberOfHandles.SetPrintFormat(5),
                  HmgNumberOfHandlesAllocated.SetPrintFormat(6),
                  HmgCurrentNumberOfObjects.SetPrintFormat(5),
                  HmgMaximumNumberOfObjects.SetPrintFormat(5),
                  HmgNumberOfObjectsAllocated.SetPrintFormat(6),
                  HmgCurrentNumberOfLookAsideObjects.SetPrintFormat(5),
                  HmgMaximumNumberOfLookAsideObjects.SetPrintFormat(5),
                  HmgNumberOfLookAsideHits.SetPrintFormat(6)
                  );
    }
    else
    {
        ExtOut("             Current\n"
               "    TYPE     Handles\n");

        _snprintf(TableFormat, sizeof(TableFormat), "%%s%%6lu\n");
    }

    // init the totals
    pulCount[TOTAL_TYPE]                           = 0;
    HmgCurrentNumberOfObjects[TOTAL_TYPE]          = 0;
    HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE] = 0;
    HmgMaximumNumberOfHandles[TOTAL_TYPE]          = 0;
    HmgMaximumNumberOfObjects[TOTAL_TYPE]          = 0;
    HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE] = 0;
    HmgNumberOfHandlesAllocated[TOTAL_TYPE]        = 0;
    HmgNumberOfObjectsAllocated[TOTAL_TYPE]        = 0;
    HmgNumberOfLookAsideHits[TOTAL_TYPE]           = 0;

    // now go through printing each line and accumulating totals
    for (ulLoop = 0; ulLoop <= MAX_TYPE; ulLoop++)
    {
        ExtOut(TableFormat,
               pszTypes[ulLoop],
               pulCount[ulLoop],
               ((pulCount[ulLoop] == HmgCurrentNumberOfHandles[ulLoop]) ? '=' :
                ((pulCount[ulLoop] < HmgCurrentNumberOfHandles[ulLoop]) ? '<' : '>')),
               HmgCurrentNumberOfHandles[ulLoop],
               HmgMaximumNumberOfHandles[ulLoop],
               HmgNumberOfHandlesAllocated[ulLoop],
               HmgCurrentNumberOfObjects[ulLoop],
               HmgMaximumNumberOfObjects[ulLoop],
               HmgNumberOfObjectsAllocated[ulLoop],
               HmgCurrentNumberOfLookAsideObjects[ulLoop],
               HmgMaximumNumberOfLookAsideObjects[ulLoop],
               HmgNumberOfLookAsideHits[ulLoop]);

        if (ulLoop != DEF_TYPE)
        {
            pulCount[TOTAL_TYPE]                    += pulCount[ulLoop];

            HmgCurrentNumberOfHandles[TOTAL_TYPE]   += HmgCurrentNumberOfHandles[ulLoop];
            HmgMaximumNumberOfHandles[TOTAL_TYPE]   += HmgMaximumNumberOfHandles[ulLoop];
            HmgNumberOfHandlesAllocated[TOTAL_TYPE] += HmgNumberOfHandlesAllocated[ulLoop];

            HmgCurrentNumberOfObjects[TOTAL_TYPE]   += HmgCurrentNumberOfObjects[ulLoop];
            HmgMaximumNumberOfObjects[TOTAL_TYPE]   += HmgMaximumNumberOfObjects[ulLoop];
            HmgNumberOfObjectsAllocated[TOTAL_TYPE] += HmgNumberOfObjectsAllocated[ulLoop];

            HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE] += HmgCurrentNumberOfLookAsideObjects[ulLoop];
            HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE] += HmgMaximumNumberOfLookAsideObjects[ulLoop];
            HmgNumberOfLookAsideHits[TOTAL_TYPE]    += HmgNumberOfLookAsideHits[ulLoop];
        }

    }

    ExtOut(TableFormat,
           pszTypes[TOTAL_TYPE],
           pulCount[TOTAL_TYPE],
           ((pulCount[TOTAL_TYPE] == HmgCurrentNumberOfHandles[TOTAL_TYPE]) ? '=' :
            ((pulCount[TOTAL_TYPE] < HmgCurrentNumberOfHandles[TOTAL_TYPE]) ? '<' : '>')),
           HmgCurrentNumberOfHandles[TOTAL_TYPE],
           HmgMaximumNumberOfHandles[TOTAL_TYPE],
           HmgNumberOfHandlesAllocated[TOTAL_TYPE],
           HmgCurrentNumberOfObjects[TOTAL_TYPE],
           HmgMaximumNumberOfObjects[TOTAL_TYPE],
           HmgNumberOfObjectsAllocated[TOTAL_TYPE],
           HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE],
           HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE],
           HmgNumberOfLookAsideHits[TOTAL_TYPE]);

    ExtOut ("\ncUnused objects %lu\n", cUnused);

    ExtOut("cUnknown objects %lu %lu\n",cUnknown,cUnknownSize);

    EXIT_API(S_OK);
}


char *pszTypes2[] = {
"DEF",
"DC",
"UNUSED_2",     // "LDB",
"UNUSED_3",     // "PDB",
"RGN",
"SURF",
"CLIOBJ",
"PATH",
"PAL",
"ICMLCS",
"LFONT",
"RFONT",
"PFE",
"PFT",
"ICMCXF",
"ICMDLL",
"BRUSH",
"UNUSED_17",    // "D3D_HANDLE",
"UNUSED_18",    // "CACHE",
"SPACE",
"UNUSED_20",    // "DBRUSH"
"META",
"EFSTATE",
"BMFD",
"VTFD",
"TTFD",
"RC",
"TEMP",
"DRVOBJ",
"DCIOBJ",
"SPOOL"
};


/******************************Public*Class********************************\
* class AccumPidObjects
*
\**************************************************************************/


class PidObjects {
public:
    ULONG Pid;
    PidObjects *pNextPid;
    PidObjects *pPrevPid;
    Array<ULONG> TypeCount;

    PidObjects(ULONG Pid_, ULONG TotalTypes) : TypeCount(TotalTypes)
    {
        Pid = Pid_;
        pNextPid = NULL;
        pPrevPid = NULL;
    }
};

class AccumPidObjects {
public:
    AccumPidObjects(ULONG ulMaxType_, char **pszTypeDesc_);
    ~AccumPidObjects();

    HRESULT Valid();

    VOID Add(ULONG Type)
    {
        ObjectTotals[Type]++;
        ObjectTotals[ulMaxType]++;
    }

    HRESULT Add(ULONG Pid, ULONG Type);
    HRESULT OutputResults(OutputControl *OutCtl, Array<BOOL> &ShowZeroCountForType);

    void Reset();

    Array<ULONG>    ObjectTotals;

private:
    PidObjects *GetFirstPid();
    PidObjects *GetEntry(ULONG Pid);

    ULONG           ulMaxType;
    ULONG           ulMaxObjectsPerPid;
    PidObjects     *PidList;                // Linked list of Pids

    char          **pszTypeDesc;

    Array<ULONG>    ColWidth;
};


AccumPidObjects::AccumPidObjects(
    ULONG ulMaxType_,
    char **pszTypeDesc_
    ) : ObjectTotals(ulMaxType_+1), ColWidth(ulMaxType_+1)
{
    ulMaxType = ulMaxType_;
    PidList = NULL;
    pszTypeDesc = pszTypeDesc_;

    Reset();
}


AccumPidObjects::~AccumPidObjects()
{
    PidObjects *pPO, *pPONext;

    pPO = GetFirstPid();

    while (pPO != NULL)
    {
        pPONext = pPO->pNextPid;
        delete pPO;
        pPO = pPONext;
    }
}


HRESULT
AccumPidObjects::Valid()
{
    return ((ulMaxType > 0) ? S_OK : S_FALSE);
}


HRESULT
AccumPidObjects::Add(
    ULONG Pid,
    ULONG Type
    )
{
    PidObjects *pEntry;

    pEntry = GetEntry(Pid);

    if (pEntry == NULL) return E_FAIL;

    Add(Type);

    pEntry->TypeCount[Type]++;
    pEntry->TypeCount[ulMaxType]++;

    if (pEntry->TypeCount[ulMaxType] > ulMaxObjectsPerPid)
    {
        ulMaxObjectsPerPid = pEntry->TypeCount[ulMaxType];
        PidList = pEntry;
    }

    return S_OK;
}


HRESULT
AccumPidObjects::OutputResults(
    OutputControl *OutCtl,
    Array<BOOL> &ShowZeroCountForType
    )
{
    HRESULT     hr = S_OK;
    PidObjects *pPO;
    ULONG       Type;

    // Output headers
    hr = OutCtl->Output("Pid\\Type  %*s", ColWidth[ulMaxType], "Total");
    for (Type = 0; hr == S_OK && Type < ulMaxType; Type++)
    {
        if (ObjectTotals[Type] > 0 || ShowZeroCountForType[Type])
        {
            hr = OutCtl->Output(" %*s", ColWidth[Type], pszTypeDesc[Type]);
        }
    }
    if (hr == S_OK) hr = OutCtl->Output("\n");

    // Output per PID results
    for (pPO = GetFirstPid(); hr == S_OK && pPO != NULL; pPO = pPO->pNextPid)
    {
        hr = OutCtl->Output("%8lx: %*lu", pPO->Pid,
                            ColWidth[ulMaxType], pPO->TypeCount[ulMaxType]);

        for (Type = 0; hr == S_OK && Type < ulMaxType; Type++)
        {
            if (ObjectTotals[Type] > 0 || ShowZeroCountForType[Type])
            {
                hr = OutCtl->Output(" %*lu", ColWidth[Type], pPO->TypeCount[Type]);
            }
        }

        if (hr == S_OK) hr = OutCtl->Output("\n");
    }

    // Output totals
    hr = OutCtl->Output("  Totals: %*lu",
                        ColWidth[ulMaxType], ObjectTotals[ulMaxType]);

    for (Type = 0; hr == S_OK && Type < ulMaxType; Type++)
    {
        if (ObjectTotals[Type] > 0 || ShowZeroCountForType[Type])
        {
            hr = OutCtl->Output(" %*lu", ColWidth[Type], ObjectTotals[Type]);
        }
    }

    OutCtl->Output("\n");

    return hr;
}


void
AccumPidObjects::Reset()
{
    PidObjects *pPO, *pPONext;
    ULONG       i;

    pPO = GetFirstPid();

    while (pPO != NULL)
    {
        pPONext = pPO->pNextPid;
        delete pPO;
        pPO = pPONext;
    }

    PidList = NULL;
    ulMaxObjectsPerPid = 0;

    for (i = 0; i < ulMaxType; i++)
    {
        ObjectTotals[i] = 0;
        ColWidth[i] = max(6, strlen(pszTypeDesc[i]));
    }

    ObjectTotals[ulMaxType] = 0;
    ColWidth[ulMaxType] = 8;
}


PidObjects*
AccumPidObjects::GetFirstPid()
{
    PidObjects *pPO = PidList;

    if (pPO != NULL)
    {
        while (pPO->pPrevPid != NULL)
            pPO = pPO->pPrevPid;
    }

    return pPO;
}


PidObjects*
AccumPidObjects::GetEntry(
    ULONG Pid
    )
{
    PidObjects *pPO = PidList;

    if (pPO != NULL && pPO->Pid != Pid)
    {
        if (pPO->Pid < Pid)
        {
            while (pPO->pNextPid != NULL)
            {
                pPO = pPO->pNextPid;

                if (pPO->Pid >= Pid)
                {
                    break;
                }
            }
        }
        else
        {
            while (pPO->pPrevPid != NULL)
            {
                pPO = pPO->pPrevPid;

                if (pPO->Pid <= Pid)
                {
                    break;
                }
            }
        }
    }

    if (pPO == NULL || pPO->Pid != Pid)
    {
        PidObjects *pPONew = new PidObjects(Pid, ulMaxType+1);

        if (pPONew != NULL)
        {
            if (pPO == NULL)
            {
                PidList = pPONew;
            }
            else if (pPO->Pid < Pid)
            {
                pPONew->pNextPid = pPO->pNextPid;
                pPONew->pPrevPid = pPO;

                pPO->pNextPid = pPONew;
                if (pPONew->pNextPid != NULL)
                {
                    pPONew->pNextPid->pPrevPid = pPONew;
                }
            }
            else
            {
                pPONew->pNextPid = pPO;
                pPONew->pPrevPid = pPO->pPrevPid;

                pPO->pPrevPid = pPONew;
                if (pPONew->pPrevPid != NULL)
                {
                    pPONew->pPrevPid->pNextPid = pPONew;
                }
            }
        }

        pPO = pPONew;
    }

    return pPO;
}



/******************************Public*Routine******************************\
* DECLARE_API( dumpobj  )
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
*  29-Dec-2000    -by- Jason Hartman [jasonha]
* Ported to Type debugging API.
\**************************************************************************/

#define USE_READ   0
#define ENTRY_RECURSE_LEVELS    1

DECLARE_API( dumpobjr )
{
    HRESULT     hr;

    BEGIN_API( dumpobjr );

    BOOL        CheckType = TRUE;
    Array<BOOL> MatchType(TOTAL_TYPE);
    Array<CHAR> TypeList;

    BOOL        CheckPid = FALSE;
    BOOL        ThisPid;
    DEBUG_VALUE MatchPid = {0, DEBUG_VALUE_INVALID};
    BOOL        TrackPerPid;

    BOOL        CheckLock = FALSE;
    BOOL        Summary = FALSE;
    BOOL        BadArg = FALSE;

    BOOL        UseIndex = FALSE;
    DEBUG_VALUE StartIndex = {0, DEBUG_VALUE_INVALID};

    OutputControl   OutCtl(Client);
    ULONG64         EntryAddr;
    ULONG64         gcMaxHmgr;
    ULONG           EntrySize;

    ULONG           Index = 0;

    ULONG           LongestType = 0;
    int         i;

    for (i = 0; i <= MAX_TYPE; i++)
    {
        ULONG   Len = strlen(pszTypes2[i]);
        if (Len > LongestType)
        {
            LongestType = Len;
        }
    }

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (CheckType && !TypeList.IsEmpty())
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -a may not be specified with a Type list.\n");
                        }
                        else
                        {
                            CheckType = FALSE;
                        }
                        break;
                    case 'i':
                        if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: PID value not found after -%c.\n",
                                          (ThisPid ? 'p' : 'n'));
                        }
                        else
                        {
                            UseIndex = TRUE;
                        }
                        break;
                    case 'l': CheckLock = TRUE; break;
                    case 'n':
                        if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: Index value not found after -i.\n");
                        }
                        else if (CheckPid && ThisPid)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -n may not be used with -p.\n");
                        }
                        else
                        {
                            CheckPid = TRUE;
                            ThisPid = FALSE;
                        }
                        break;
                    case 'p':
                        if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: Index value not found after -i.\n");
                        }
                        if (CheckPid && !ThisPid)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -p may not be used with -n.\n");
                        }
                        else
                        {
                            CheckPid = TRUE;
                            ThisPid = TRUE;
                        }
                        break;
                    case 's': Summary = TRUE; break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be a PID.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as a pid
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT32,
                             EVALUATE_DEFAULT_RADIX, &MatchPid,
                             &Rem) == S_OK &&
                    args + Rem == EOP)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a PID.\n",
                                  args);
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be the start Index.
                CHAR    EOIChar;
                PSTR    EOI = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an index
                while (*EOI != '\0' && !isspace(*EOI)) EOI++;
                EOIChar = *EOI;
                *EOI = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT32,
                             EVALUATE_DEFAULT_RADIX, &StartIndex,
                             &Rem) == S_OK &&
                    args + Rem == EOI)
                {
                    args = EOI;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as an Index.\n",
                                  args);
                    BadArg = TRUE;
                }
                *EOI = EOIChar;
            }
            else
            {
                // This argument must be a Type specification.
                if (!CheckType)
                {
                    OutCtl.OutErr("Error: a Type list may not be specified with -a.\n");
                    BadArg = TRUE;
                    break;
                }

                for (i = 0; i <= MAX_TYPE; i++)
                {
                    SIZE_T CheckLen = strlen(pszTypes2[i]);

                    if (_strnicmp(args, pszTypes2[i], CheckLen) == 0 &&
                        (!iscsym(args[CheckLen]) ||
                         (_strnicmp(&args[CheckLen], "_TYPE", 5) == 0 &&
                          !iscsym(args[CheckLen+5])
                       )))
                    {
                        if (!MatchType[i])
                        {
                            // Add Type to list
                            SIZE_T CatLoc = TypeList.GetLength();
                            if (CatLoc > 0)
                            {
                                TypeList[CatLoc] = ' ';
                            }
                            TypeList.Set(pszTypes2[i], CheckLen+1, CatLoc);
                        }
                        MatchType[i] = TRUE;
                        args += CheckLen;
                        if (iscsym(*args)) args += 5;
                        break;
                    }
                }

                if (i > MAX_TYPE)
                {
                    OutCtl.OutErr("Error: Unknown Type in '%s'.\n", args);
                    BadArg = TRUE;
                    break;
                }
            }
        }
    }

    if (!BadArg)
    {
        if (CheckType && TypeList.IsEmpty())
        {
            OutCtl.OutErr("Error: Missing -a or Type list.\n");
            BadArg = TRUE;
        }
        else if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing PID.\n");
            BadArg = TRUE;
        }
        else if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Index.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        OutCtl.Output("Usage: dumpobj [-?ls] [-np PID] [-i Index] <-a | Type(s)>\n"
                      "\n"
                      "     a - All object types\n"
                      "     i - Hmgr Entry Index to begin dump\n"
                      "     l - Check Lock\n"
                      "     n - Entries NOT owned by pid\n"
                      "     p - Entries owned by pid\n"
                      "     s - Summary counts only\n"
                      "\n"
                      " The -s option combined with the -a option will produce\n"
                      "  a list of the totals for each object type.\n");

        OutCtl.Output("\n Valid Type values are:\n");
        i = 0;
        while (i <= MAX_TYPE)
        {
            do
            {
                OutCtl.Output("   %-*s", LongestType, pszTypes2[i++]);
            } while (i <= MAX_TYPE && i%4);
            OutCtl.Output("\n");
        }

        return S_OK;
    }

    //
    // Get the pointers and counts from win32k
    //

    if ((hr = GetHandleTable(Client, &EntryAddr)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        return hr;
    }
    
    EntrySize = GetEntrySize(Client);

    if (!gcMaxHmgr || !EntrySize || !EntryAddr)
    {
        OutCtl.OutErr("Error: gpentHmgr = %p, gcMaxHmgr = %I64u\n", EntryAddr, gcMaxHmgr);
        return S_OK;
    }

    if (UseIndex) Index = StartIndex.I32;

    OutCtl.Output("Searching %s %I64u entries starting at 0x%p",
                  (Index ? "remaining" : "all"), gcMaxHmgr - Index, EntryAddr);
    if (SessionId != CURRENT_SESSION)
    {
        OutCtl.Output(" in session %s", SessionStr);
    }
    OutCtl.Output(".\n");

    PDEBUG_CONTROL  Control;
    PDEBUG_SYMBOLS  Symbols;
    BOOL            IsPointer64Bit;
    BOOL            ComposeHandles;
    ULONG           PointerSize;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Control->Release();
        return hr;
    }

    if (!Summary)
    {
        // Setup some things neded for listing entries.

        IsPointer64Bit = (Control->IsPointer64Bit() == S_OK);

        // Make sure HandleFullUnique is valid
        hr = GetFullUniqueFromHandle(Client, 0, NULL);
        if (hr != S_OK)
        {
            OutCtl.OutWarn("Unable to compose handles from entries, %s.\n",
                          pszHRESULT(hr));
        }
        ComposeHandles = (hr == S_OK);
    }

    OutCtl.Output("Object %s for %s objects",
                  Summary ? "count" : "list",
                  CheckType ? TypeList.GetBuffer() : "all");

    if (CheckPid)
    {
        if (!ThisPid) OutCtl.Output(" NOT");
        OutCtl.Output(" owned by PID 0x%lx\n", MatchPid.I32);
    }
    else
    {
        OutCtl.Output(" with any owner\n");
    }

    if (!Summary)
    {
        PointerSize = IsPointer64Bit ? 21 : 10;

        //            "0x1234 0x12345678 0xXX 0x12345678 1    4294967295 Tttt 0x1234 0xXX 0x...\n"
        OutCtl.Output("Index  Handle     %-*s PID        Lock ShareCount %-*s Unique %-*s Flags\n",
                      PointerSize, "ObjectAddr", LongestType, "Type", PointerSize, "UserAddr");
    }


    TrackPerPid = (!CheckPid || !ThisPid);

    AccumPidObjects ObjectCount(MAX_TYPE, pszTypes2);

    TypeOutputParser    TypeReader(Client);
    OutputState         OutState(Client, FALSE);
    DEBUG_VALUE     Type;
#if ENTRY_RECURSE_LEVELS >= 2
    DEBUG_VALUE     Lock;
#else
    DEBUG_VALUE     ulObj;
#endif
    DEBUG_VALUE     PID;
    DEBUG_VALUE     Unique;
    DEBUG_VALUE     Flags;
    ULONG           ObjsNotAssignedToPID = 0;
    ULONG           FailedReads = 0;
    BOOL            FailedRead = FALSE;
    BOOL            NeedNewLine = FALSE;

    HANDLE          hHeap = GetProcessHeap();
    PBYTE           EntryBuffer = NULL;
    ULONG           ObjtOffset;

    if (hHeap != NULL &&
        (EntryBuffer = (PBYTE)HeapAlloc(hHeap, 0, EntrySize)) != NULL &&
        Symbols->GetFieldOffset(Entry.Module, Entry.TypeId, "Objt", &ObjtOffset) == S_OK &&
        (hr = OutState.Setup(0, &TypeReader)) == S_OK)
    {
        for (Index = 0; Index < gcMaxHmgr; Index++, EntryAddr += EntrySize/*, DbgPrint(" }\n")*/)
        {
//            DbgPrint("{");
            if (FailedRead) FailedReads++;

            if (Index % 40 == 0)
            {
                OutCtl.Output((Summary ? DEBUG_OUTPUT_NORMAL : DEBUG_OUTPUT_VERBOSE), ".");
                NeedNewLine = TRUE;
            }

            if (Control->GetInterrupt() == S_OK)
            {
                NeedNewLine = FALSE;
                OutCtl.OutErr("User aborted at index %lu\n", Index);
                hr = E_ABORT;
                break;
            }

            TypeReader.DiscardOutput();
/*            DbgPrint(" Read");
            Symbols->ReadTypedDataVirtual(EntryAddr,
                                          Entry.Module,
                                          Entry.TypeId,
                                          EntryBuffer,
                                          EntrySize,
                                          NULL);
            DbgPrint("Type");*/
//            DbgPrint(" Out");
            if (SessionId != CURRENT_SESSION)
            {
                ULONG64 PhysEntryAddr;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             EntryAddr,
                                             &PhysEntryAddr)) == S_OK)
                {
                    hr = OutState.OutputType(TRUE,
                                             PhysEntryAddr,
                                             Entry.Module,
                                             Entry.TypeId,
                                             DEBUG_OUTTYPE_NO_INDENT |
                                             DEBUG_OUTTYPE_NO_OFFSET |
                                             DEBUG_OUTTYPE_COMPACT_OUTPUT |
                                             DEBUG_OUTTYPE_RECURSION_LEVEL(ENTRY_RECURSE_LEVELS));
                }
            }
            else
            {
                hr = OutState.OutputTypeVirtual(EntryAddr,
                                                Entry.Module,
                                                Entry.TypeId,
                                                DEBUG_OUTTYPE_NO_INDENT |
                                                DEBUG_OUTTYPE_NO_OFFSET |
                                                DEBUG_OUTTYPE_COMPACT_OUTPUT |
                                                DEBUG_OUTTYPE_RECURSION_LEVEL(ENTRY_RECURSE_LEVELS));
            }
//            DbgPrint("Type");

            if (hr == S_OK)
            {
//                DbgPrint(" Objt");
#if USE_READ
                
#else
                hr = TypeReader.Get(&Type, "Objt", DEBUG_VALUE_INT32);
#endif
                if (hr != S_OK) Type.Type = DEBUG_VALUE_INVALID;

                if (CheckType &&
                    ((FailedRead = (Type.Type != DEBUG_VALUE_INT32)) ||
                     !MatchType[Type.I32]))
                {
//                    OutCtl.OutWarn("Type %lu doesn't match.\n", Type.I32);
                    continue;
                }

#if ENTRY_RECURSE_LEVELS >= 2
//                DbgPrint(" Lock");
                if (CheckLock &&
                    ((FailedRead = (TypeReader.Get(&Lock, "Lock",
                                                   DEBUG_VALUE_INT32) != S_OK)) ||
                     Lock.I32 == 0))
                {
                    OutCtl.OutWarn("Lock required, but not locked.\n");
                    continue;
                }

//                DbgPrint(" PID");
                PID.Type = DEBUG_VALUE_INVALID;
                FailedRead = (TypeReader.Get(&PID, "Pid_Shifted", DEBUG_VALUE_INT32) != S_OK);
                PID.I32 *= 2;

                if (CheckPid)
                {
                    if (FailedRead ||
                        ((PID.I32 == MatchPid.I32) ? !ThisPid : ThisPid))
                    {
                        continue;
                    }
                }
#else
                ulObj.Type = DEBUG_VALUE_INVALID;
                FailedRead = (TypeReader.Get(&ulObj, "ulObj", DEBUG_VALUE_INT32) != S_OK);
                PID.Type = ulObj.Type;
                PID.I32 = (ulObj.I32 & ~1);

                if (CheckLock || CheckPid)
                {
                    if (FailedRead)
                    {
//                        OutCtl.OutWarn("ulObj is required, but wasn't read.\n");
                        continue;
                    }

//                    DbgPrint(" Lock");
                    if (CheckLock && (ulObj.I32 & 1) == 0)
                    {
//                        OutCtl.OutWarn("Lock required, but not locked.\n");
                        continue;
                    }

//                    DbgPrint(" PID");
                    if (CheckPid &&
                        (PID.I32 == MatchPid.I32) ? !ThisPid : ThisPid)
                    {
                        continue;
                    }
                }
#endif

                FailedRead = (Type.Type != DEBUG_VALUE_INT32);

                if (!FailedRead)
                {
//                    DbgPrint(" MATCH");
                    if (TrackPerPid)
                    {
                        if (PID.Type != DEBUG_VALUE_INT32 ||
                            ObjectCount.Add(PID.I32, Type.I32) != S_OK)
                        {
                            ObjsNotAssignedToPID++;
                            ObjectCount.Add(Type.I32);
                        }
                    }
                    else
                    {
                        ObjectCount.Add(Type.I32);
                    }
                }

                if (!Summary)
                {
                    PCSTR   pszValue;

                    if (NeedNewLine) 
                    {
                        OutCtl.OutVerb("\n");
                        NeedNewLine = FALSE;
                    }

                    // Index
                    OutCtl.Output("0x%.4lx ", Index);

                    // Handle
                    if (ComposeHandles &&
                        TypeReader.Get(&Unique, "FullUnique", DEBUG_VALUE_INT64) == S_OK)
                    {
                        ULONG64 Handle64;

                        Handle64 = (Index & ~(HandleFullUnique->Mask)) |
                                   (Unique.I64 << HandleFullUnique->BitPos);

                        if (IsPointer64Bit)
                        {
                            Handle64 = DEBUG_EXTEND64(Handle64);
                        }

                        OutCtl.Output("0x%p ", Handle64);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // ObjectAddr
                    if (TypeReader.Get(NULL, "pobj") == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%*s ", PointerSize, pszValue);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // PID
                    if (PID.Type == DEBUG_VALUE_INT32)
                    {
                        OutCtl.Output("0x%.8lx ", PID.I32);
                    }
                    else
                    {
                        OutCtl.Output("       ? ");
                    }

                    // Lock
#if ENTRY_RECURSE_LEVELS >= 2
                    if (Lock.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&Lock, "Lock", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("%4lu ", Lock.I32);
                    }
                    else
                    {
                        OutCtl.Output("   ? ");
                    }
#else
                    if (ulObj.Type == DEBUG_VALUE_INT32)
                    {
                        OutCtl.Output("%4lu ", ulObj.I32 & 1);
                    }
                    else
                    {
                        OutCtl.Output("   ? ");
                    }
#endif

                    // ShareCount
                    OutCtl.Output("<Not Read> ");

                    // Type
                    if (Type.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&Type, "Objt", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("%-*s ", LongestType, pszTypes2[Type.I32]);
                    }
                    else
                    {
                        OutCtl.Output("%-*s ", LongestType, "?");
                    }

                    // Unique
                    if (Unique.Type == DEBUG_VALUE_INT64 ||
                        TypeReader.Get(&Unique, "FullUnique", DEBUG_VALUE_INT64) == S_OK)
                    {
                        OutCtl.Output("0x%.4I64x ", Unique.I64);
                    }
                    else
                    {
                        OutCtl.Output("     ? ");
                    }

                    // UserAddr
                    if (TypeReader.Get(NULL, "pUser") == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%*s ", PointerSize, pszValue);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // Flags
                    if (TypeReader.Get(&Flags, "Flags", DEBUG_VALUE_INT64) == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%s (", pszValue);
                        Flags.I64 = OutputFlags(&OutCtl, afdENTRY_Flags, Flags.I64, TRUE);
                        OutCtl.Output(")");
                        if (Flags.I64)
                        {
                            OutCtl.Output(" Unknown Flags: 0x%I64x", Flags.I64);
                        }
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }

                    OutCtl.Output("\n");
                }
            }
            else
            {
                FailedRead = TRUE;
            }
        }

        if (FailedRead) FailedReads++;

        if (NeedNewLine) 
        {
            OutCtl.Output((Summary ? DEBUG_OUTPUT_NORMAL : DEBUG_OUTPUT_VERBOSE), "\n");
        }

        if (FailedReads)
        {
            OutCtl.OutWarn("Warning: %lu entry reads failed -> uncounted.\n", FailedReads);
        }

        if (ObjsNotAssignedToPID)
        {
            OutCtl.OutWarn("Warning: %lu entries weren't assigned to a PID.\n", ObjsNotAssignedToPID);
        }

        if (Index < gcMaxHmgr)
        {
            OutCtl.OutWarn("Warning: Entries at and beyond index 0x%lx weren't processed.\n", Index);
        }

        // Display results
        ObjectCount.OutputResults(&OutCtl, MatchType);
    }

    if (EntryBuffer != NULL)
    {
        HeapFree(hHeap, 0, EntryBuffer);
    }

    Symbols->Release();
    Control->Release();

    return S_OK;
}

#if 1

#define TYPE_ALL          0
#define PID_ALL      0x8002

DECLARE_API( dumpobj  )
{
    BEGIN_API( dumpobj );
    INIT_API();
    ExtWarn("Extension 'dumpobj' is not fully converted.\n");
    HRESULT hr;
    ULONG64 pent;
    ULONG64 gcMaxHmgr;
    ULONG   entSize;
    ULONG   ulLoop;
    ULONG   Pid = PID_ALL;
    BOOL    AnyPid = TRUE;
    BOOL    MatchPid = TRUE;
    ULONG   Type = TYPE_ALL;
    BOOL    bCheckLock = FALSE;
    BOOL    bSummary = FALSE;
    BOOL    bShareCount = FALSE;
    int     i;

    PARSE_ARGUMENTS(dumpobj_help);

    if(ntok<1) {
      goto dumpobj_help;
    }

    //find valid tokens - ignore the rest
    bShareCount = (parse_iFindSwitch(tokens, ntok, 'c') >= 0);
    bCheckLock = (parse_iFindSwitch(tokens, ntok, 'l') >= 0);
    bSummary = (parse_iFindSwitch(tokens, ntok, 's') >= 0);
    MatchPid = !(parse_iFindSwitch(tokens, ntok, 'n') >= 0);
    tok_pos = parse_iFindSwitch(tokens, ntok, 'p');
    if (tok_pos>=0)
    {
        tok_pos++;

        if ((tok_pos+1)>=ntok)
        {
            goto dumpobj_help;               //-p requires a pid and it can't be the last arg
        }

        AnyPid = FALSE;
        Pid = (LONG)GetExpression(tokens[tok_pos]);
    }

    //find first non-switch token not preceeded by a -p
    tok_pos = -1;
    do {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'p')));
    if(tok_pos==-1) {
      goto dumpobj_help;
    }


//CHECKLOOP
    for (Type = 0; Type <= MAX_TYPE; ++Type)
    {
        if (parse_iIsToken(tokens, tok_pos, pszTypes2[Type]) ||
            parse_iIsToken(tokens, tok_pos, pszTypes[Type]))
        {
            break;
        }
    }

    if (Type > MAX_TYPE) {
        goto dumpobj_help;
    }
    //
    // Get the pointers and counts from win32k
    //

    if ((hr = GetHandleTable(Client, &pent)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        EXIT_API(hr);
    }
    
    entSize = GetEntrySize(Client);

    ExtVerb("gpentHmgr = %p, gcMaxHmgr = %I64u\n", pent, gcMaxHmgr);

    if (!gcMaxHmgr || !entSize || !pent)
    {
        ExtErr("Error: gpentHmgr = %p, gcMaxHmgr = %I64u\n", pent, gcMaxHmgr);
        EXIT_API(S_OK);
    }

    //
    // dprintf out the amount reserved and committed, note we assume a 4K page size
    //

    dprintf("object list for %s type objects",Type == TYPE_ALL ? "ALL" : pszTypes2[Type]);

    if (AnyPid)
    {
        dprintf(" with any owner\n");
    }
    else
    {
        if (!MatchPid) dprintf(" NOT");
        dprintf(" owned by PID 0x%lx\n",Pid);
    }

    if(!bSummary) {
      dprintf("%4s, %8s, %6s, %6s, %4s, %8s, %8s, %6s, %6s, %8s,%9s\n",
           "I","handle","Lock","sCount","pid","pv","objt","unique","Flags","pUser","Tlock");

      dprintf("--------------------------------------------------------------------------------------------\n");
    }

    {
        LONG ObjCount = 0;
        LONG ObjArray[MAX_TYPE+1];

        for(i=0;i<=MAX_TYPE;i++) {
          ObjArray[i]=0;
        }

//CHECKLOOP
        for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
        {
            if (CheckControlC())
            {
                ExtErr("User aborted at index %lu\n", ulLoop);
                EXIT_API(E_ABORT);
            }

            if (bSummary && ulLoop % 40 == 0) ExtVerb(".");

            ULONG   error;
            ULONG   objt;
            ULONG   ThisPid;
            ULONG64 pobj;
            USHORT  fullUnique;
            UCHAR   flags;
            ULONG64 pUser;
            ULONG   owner;
            ULONG   shareCount;

            if (error = GetFieldValue(pent, szEntryType, "Objt", objt))
            {
                ExtErr("Error reading table entry\n");
                ExtErr("  (GetFieldValue returned %s @ %p)\n", pszWinDbgError(error), pent);
                EXIT_API(S_OK);
            }
            
            if (error = GetFieldValue(pent, szEntryType, "ObjectOwner", owner))
            {
                ExtErr("error reading table entry\n");
                ExtErr("  (GetFieldValue returned %s)\n", pszWinDbgError(error));
                EXIT_API(S_OK);
            }
            
            ThisPid = owner & PID_MASK;

            if (0 && gbVerbose)
            {
                dprintf("Type: %lu, PID: %lu, Locked: %s\n", objt, ThisPid, (owner & LOCK_MASK) ? "YES" : "NO");
            }

            if (
                 ((objt == Type) || (Type == TYPE_ALL)) &&
                 (AnyPid ||
                  (MatchPid ? (ThisPid == Pid) : (ThisPid != Pid))) &&
                 ((!bCheckLock) || (owner & LOCK_MASK))
               )
            {

                ObjCount++;

                if (!bSummary)
                {
                    if (GetFieldData(pent, szEntryType, "FullUnique", sizeof(fullUnique), &fullUnique))
                    {
                        ExtErr("error reading FullUnique\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "Flags", sizeof(flags), &flags))
                    {
                        ExtErr("error reading flags\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "pUser", sizeof(pUser), &pUser))
                    {
                        ExtErr("error reading pUser\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "einfo.pobj", sizeof(pobj), &pobj))
                    {
                        ExtErr("error reading einfo.pobj\n");
                        EXIT_API(S_OK);
                    }

                    dprintf("%4lx, %08lx, %6lx",
                        ulLoop,
                        MAKE_HMGR_HANDLE(ulLoop,fullUnique),
                        owner & LOCK_MASK);

                    if (!bShareCount)
                    {
                        dprintf(", Unread");
                    }
                    else if (GetFieldData(pobj, GDIType(_BASEOBJECT), "ulShareCount", sizeof(shareCount), &shareCount))
                    {
                        dprintf(", ??????");
                    }
                    else
                    {
                        dprintf(", %6lx", shareCount);
                    }

                    dprintf(", %4lx, %p", ThisPid, pobj);

                    dprintf(", %8s, %6hx, %6lx, %p, %p\n",
                        pszTypes2[objt],
                        fullUnique,
                        flags,
                        pUser,
                        pUser);
                }
                else
                {
                    ObjArray[objt]++;
                }

            }

            pent += entSize;
        }

        if(bSummary && (Type==TYPE_ALL)) {
          for(i=0;i<=MAX_TYPE; i++) {
            if(ObjArray[i]>0) {
              dprintf("%s\t%ld\n", pszTypes2[i], ObjArray[i]);
            }
          }
        }

        ExtOut("Total objects = %li",ObjCount);
        // Subtract any unused objects
        if (bSummary && ObjArray[0])
        {
            ExtOut(" - %li = %li", ObjArray[0], ObjCount - ObjArray[0]);
        }
        ExtOut("\n");
    }

    EXIT_API(S_OK);

dumpobj_help:
    dprintf("Usage: dumpobj [-?] [-n] [-p pid] [-l] [-s] object_type\n");
    dprintf("\t-l check lock\n");
    dprintf("\t-s summary\n");
    dprintf("\t-n not pid\n\n");
    dprintf(" The -s option combined with the DEF object type will produce\n"
            "  a list of the totals for each object type.\n\n");

    dprintf(" Valid object_type values are:\n");
    for (i=0; i<=MAX_TYPE; ) {
        do
        {
            dprintf("   %-12s", pszTypes2[i++]);
        } while (i <= MAX_TYPE && i%4);
        dprintf("\n");
    }

    EXIT_API(S_OK);
}
#endif



/******************************Public*Routine******************************\
* DECLARE_API( dh  )
*
* Debugger extension to dump a handle.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dh  )
{
    BEGIN_API( dh );

    HRESULT     hr;
    DEBUG_VALUE Handle;
    ULONG64     offENTRY;
    BOOL        Physical;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Handle, NULL)) != S_OK ||
        Handle.I64 == 0)
    {
        OutCtl.Output("Usage: dh [-?] <Handle>\n");
    }
    else
    {
        OutCtl.Output("--------------------------------------------------\n");
        OutCtl.Output("GDI Entry for handle 0x%p:\n", Handle.I64);

        if ((hr = GetEntryAddress(Client, Handle.I64, &offENTRY, &Physical)) == S_OK)
        {
            OutputFilter    OutFilter(Client);
            OutputState     OutState(Client, FALSE);
            OutputControl   OutCtl;

            if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL |
                                     DEBUG_OUTPUT_ERROR |
                                     DEBUG_OUTPUT_WARNING,
                                     &OutFilter)) == S_OK &&
                (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                        DEBUG_OUTCTL_NOT_LOGGED,
                                        OutState.Client)) == S_OK)
            {
                hr = DumpType(OutState.Client,
                              szEntryType,
                              offENTRY,
                              DEBUG_OUTTYPE_NO_INDENT | DEBUG_OUTTYPE_NO_OFFSET,
                              &OutCtl,
                              Physical);

                if (hr == S_OK)
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "_EINFO");
                    OutFilter.Skip(OUTFILTER_SKIP_DEFAULT, "_OBJECTOWNER");

                    BOOL        DumpObj = FALSE;
                    DEBUG_VALUE Value;
                    CHAR        ReplacementText[80];

                    // Check for used vs free entry
                    if (OutFilter.Query("Objt", &Value, DEBUG_VALUE_INT8) == S_OK)
                    {
                        DumpObj = (Value.I8 != DEF_TYPE);
                        OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                       OUTFILTER_QUERY_WHOLE_WORD,
                                       (Value.I8 == DEF_TYPE) ? "pobj" : "hFree");
                    }

                    // Account for Pid shifting
                    if (OutFilter.Query("Pid_Shifted", &Value, DEBUG_VALUE_INT32) == S_OK)
                    {
                        sprintf(ReplacementText,
                                "Pid              : 0x%lx (%ld)",
                                2*Value.I32, 2*Value.I32);
                        OutFilter.Replace(OUTFILTER_REPLACE_LINE | OUTFILTER_QUERY_ONE_LINE,
                                          "Pid_Shifted", ReplacementText);
                    }

                    hr = OutFilter.OutputText();

                    if (hr == S_OK && DumpObj)
                    {
                        if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
                        {
                            if ((hr = OutFilter.Query("pobj", &Value, DEBUG_VALUE_INT64)) == S_OK)
                            {
                                // Restore OutCtl settings
                                OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
                                OutCtl.Output("--------------------------------------------------\n");

                                if (Physical)
                                {
                                    ULONG64 PhysAddr;

                                    ASSERTMSG("HMGR Entry was looked up thru a physical address, but the SessionId is CURRENT.\n", SessionId != CURRENT_SESSION);
                                    hr = GetPhysicalAddress(Client,
                                                            SessionId,
                                                            Value.I64,
                                                            &PhysAddr);
                                    if (hr == S_OK)
                                    {
                                        Value.I64 = PhysAddr;
                                    }
                                    else
                                    {
                                        OutCtl.OutErr("GDI BaseObject @ 0x%p in session %lu in unavailable.\n",
                                                      Value.I64, SessionId);
                                    }
                                }

                                if (hr == S_OK)
                                {
                                    OutCtl.Output("GDI BaseObject @ %s0x%p:\n",
                                                  ((Physical) ? "#" : ""),
                                                  Value.I64);

                                    hr = DumpType(Client,
                                                  "_BASEOBJECT",
                                                  Value.I64,
                                                  DEBUG_OUTTYPE_NO_INDENT |
                                                  DEBUG_OUTTYPE_NO_OFFSET,
                                                  &OutCtl,
                                                  Physical);
                                }
                            }
                        }
                    }
                }

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump returned %s.\n", pszHRESULT(hr));
                }
            }
            else
            {
                OutCtl.OutErr(" Output state/control setup returned %s.\n",
                              pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.Output(" ** Unable to find a valid entry address. **\n");
        }

        OutCtl.Output("--------------------------------------------------\n");  
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* DECLARE_API( dht  )
*
* Debugger extension to extract type data from a handle.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
*  30-Nov-2000    -by- Jason Hartman [jasonha]
* Ported to 64 bit debugger API.
\**************************************************************************/

DECLARE_API( dht  )
{
    BEGIN_API( dht );

    HRESULT     hr;
    DEBUG_VALUE Handle;
    ULONG64     Index;
    ULONG64     FullUnique;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Handle, NULL)) != S_OK ||
        Handle.I64 == 0)
    {
        OutCtl.Output("Usage: dht [-?] <Handle>\n");
    }
    else
    {
        OutCtl.Output("Handle: 0x%p\n", Handle.I64);

        if (GetIndexFromHandle(Client, Handle.I64, &Index) == S_OK)
        {
            OutCtl.Output("  Index: 0x%p\n", Index);
        }
        if (GetFullUniqueFromHandle(Client, Handle.I64, &FullUnique) == S_OK)
        {
            OutCtl.Output("  FullUnique: 0x%p\n", FullUnique);
        }
        OutCtl.Output("  Type: ");
        hr = OutputHandleInfo(&OutCtl, Client, &Handle);
        OutCtl.Output("\n");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\flags.cxx ===
/******************************Module*Header*******************************\
* Module Name: flags.cxx
*
* Copyright (c) 1995-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// The following define expands 'FLAG(x)' to '"x", x':

#define FLAG(x) { #x, x }

#define END_FLAG { 0, 0 }


// The following define expands 'ENUM(x)' to '"x", x':

#define ENUM(x) { #x, x }

#define END_ENUM { 0, 0 }


#define CASEENUM(x) case x: psz = #x; break


FLAGDEF afdFDM[] = {
    {"FDM_TYPE_BM_SIDE_CONST         " , FDM_TYPE_BM_SIDE_CONST          },
    {"FDM_TYPE_MAXEXT_EQUAL_BM_SIDE  " , FDM_TYPE_MAXEXT_EQUAL_BM_SIDE   },
    {"FDM_TYPE_CHAR_INC_EQUAL_BM_BASE" , FDM_TYPE_CHAR_INC_EQUAL_BM_BASE },
    {"FDM_TYPE_ZERO_BEARINGS         " , FDM_TYPE_ZERO_BEARINGS          },
    {"FDM_TYPE_CONST_BEARINGS        " , FDM_TYPE_CONST_BEARINGS         },
    {                                 0, 0                               }
};


FLAGDEF afdPFF[] = {
    {"PFF_STATE_READY2DIE     ", PFF_STATE_READY2DIE     },
    {"PFF_STATE_PERMANENT_FONT", PFF_STATE_PERMANENT_FONT},
    {"PFF_STATE_NETREMOTE_FONT", PFF_STATE_NETREMOTE_FONT},
    {"PFF_STATE_EUDC_FONT     ", PFF_STATE_EUDC_FONT     },
    {"PFF_STATE_MEMORY_FONT   ", PFF_STATE_MEMORY_FONT   },
    {"PFF_STATE_DCREMOTE_FONT ", PFF_STATE_DCREMOTE_FONT },
    {                         0, 0                       }
};

FLAGDEF afdLINEATTRS[] = {
    { "LA_GEOMETRIC", LA_GEOMETRIC },
    { "LA_ALTERNATE", LA_ALTERNATE },
    { "LA_STARTGAP ", LA_STARTGAP  },
    { "LA_STYLED   ", LA_STYLED    },
    {              0, 0            }
};

FLAGDEF afdDCPATH[] = {
    { "DCPATH_ACTIVE   ", DCPATH_ACTIVE    },
    { "DCPATH_SAVE     ", DCPATH_SAVE      },
    { "DCPATH_CLOCKWISE", DCPATH_CLOCKWISE },
    {                  0, 0                }
};

FLAGDEF afdCOLORADJUSTMENT[] = {
    { "CA_NEGATIVE  ", CA_NEGATIVE   },
    { "CA_LOG_FILTER", CA_LOG_FILTER },
    {               0, 0             }
};

FLAGDEF afdATTR[] = {
    { "ATTR_CACHED       ", ATTR_CACHED        },
    { "ATTR_TO_BE_DELETED", ATTR_TO_BE_DELETED },
    { "ATTR_NEW_COLOR    ", ATTR_NEW_COLOR     },
    { "ATTR_CANT_SELECT  ", ATTR_CANT_SELECT   },
    { "ATTR_RGN_VALID    ", ATTR_RGN_VALID     },
    { "ATTR_RGN_DIRTY    ", ATTR_RGN_DIRTY     },
    {                    0, 0                  }
};

FLAGDEF afdDCla[] = {
    { "LA_GEOMETRIC", LA_GEOMETRIC },
    { "LA_ALTERNATE", LA_ALTERNATE },
    { "LA_STARTGAP ", LA_STARTGAP  },
    { "LA_STYLED   ", LA_STYLED    },
    {              0, 0            }
};

FLAGDEF afdDCPath[] = {
    { "DCPATH_ACTIVE   ", DCPATH_ACTIVE    },
    { "DCPATH_SAVE     ", DCPATH_SAVE      },
    { "DCPATH_CLOCKWISE", DCPATH_CLOCKWISE },
    {                  0, 0                }
};

FLAGDEF afdDirty[] = {
    { "DIRTY_FILL              ", DIRTY_FILL              },
    { "DIRTY_LINE              ", DIRTY_LINE              },
    { "DIRTY_TEXT              ", DIRTY_TEXT              },
    { "DIRTY_BACKGROUND        ", DIRTY_BACKGROUND        },
    { "DIRTY_CHARSET           ", DIRTY_CHARSET           },
    { "SLOW_WIDTHS             ", SLOW_WIDTHS             },
    { "DC_CACHED_TM_VALID      ", DC_CACHED_TM_VALID      },
    { "DISPLAY_DC              ", DISPLAY_DC              },
    { "DIRTY_PTLCURRENT        ", DIRTY_PTLCURRENT        },
    { "DIRTY_PTFXCURRENT       ", DIRTY_PTFXCURRENT       },
    { "DIRTY_STYLESTATE        ", DIRTY_STYLESTATE        },
    { "DC_PLAYMETAFILE         ", DC_PLAYMETAFILE         },
    { "DC_BRUSH_DIRTY          ", DC_BRUSH_DIRTY          },
    { "DC_PEN_DIRTY            ", DC_PEN_DIRTY            },
    { "DC_DIBSECTION           ", DC_DIBSECTION           },
    { "DC_LAST_CLIPRGN_VALID   ", DC_LAST_CLIPRGN_VALID   },
    { "DC_PRIMARY_DISPLAY      ", DC_PRIMARY_DISPLAY      },
    {                          0, 0                       }
};

FLAGDEF afdPAL[] = {
    {"PAL_INDEXED           ",PAL_INDEXED       },
    {"PAL_BITFIELDS         ",PAL_BITFIELDS     },
    {"PAL_RGB               ",PAL_RGB           },
    {"PAL_BGR               ",PAL_BGR           },
    {"PAL_DC                ",PAL_DC            },
    {"PAL_FIXED             ",PAL_FIXED         },
    {"PAL_FREE              ",PAL_FREE          },
    {"PAL_MANAGED           ",PAL_MANAGED       },
    {"PAL_NOSTATIC          ",PAL_NOSTATIC      },
    {"PAL_MONOCHROME        ",PAL_MONOCHROME    },
    {"PAL_BRUSHHACK         ",PAL_BRUSHHACK     },
    {"PAL_DIBSECTION        ",PAL_DIBSECTION    },
    {"PAL_NOSTATIC256       ",PAL_NOSTATIC256   },
    {"PAL_HT                ",PAL_HT            },
    {"PAL_RGB16_555         ",PAL_RGB16_555     },
    {"PAL_RGB16_565         ",PAL_RGB16_565     },
    {                       0, 0                }
};

FLAGDEF afdDCFL[] = {
    { "DC_FL_PAL_BACK", DC_FL_PAL_BACK },
    {                0, 0              }
};

FLAGDEF afdDCFS[] = {
    { "DC_DIRTYFONT_XFORM", DC_DIRTYFONT_XFORM },
    { "DC_DIRTYFONT_LFONT", DC_DIRTYFONT_LFONT },
    { "DC_UFI_MAPPING    ", DC_UFI_MAPPING     },
    {                    0, 0                  }
};

FLAGDEF afdPD[] = {
    { "PD_BEGINSUBPATH", PD_BEGINSUBPATH },
    { "PD_ENDSUBPATH  ", PD_ENDSUBPATH   },
    { "PD_RESETSTYLE  ", PD_RESETSTYLE   },
    { "PD_CLOSEFIGURE ", PD_CLOSEFIGURE  },
    { "PD_BEZIERS     ", PD_BEZIERS      },
    {                 0, 0               }
};


FLAGDEF afdFS[] = {
    { "PDEV_DISPLAY                    ", PDEV_DISPLAY                    },
    { "PDEV_HARDWARE_POINTER           ", PDEV_HARDWARE_POINTER           },
    { "PDEV_SOFTWARE_POINTER           ", PDEV_SOFTWARE_POINTER           },
    { "PDEV_GOTFONTS                   ", PDEV_GOTFONTS                   },
    { "PDEV_PRINTER                    ", PDEV_PRINTER                    },
    { "PDEV_ALLOCATEDBRUSHES           ", PDEV_ALLOCATEDBRUSHES           },
    { "PDEV_HTPAL_IS_DEVPAL            ", PDEV_HTPAL_IS_DEVPAL            },
    { "PDEV_DISABLED                   ", PDEV_DISABLED                   },
    { "PDEV_SYNCHRONIZE_ENABLED        ", PDEV_SYNCHRONIZE_ENABLED        },
    { "PDEV_FONTDRIVER                 ", PDEV_FONTDRIVER                 },
    { "PDEV_GAMMARAMP_TABLE            ", PDEV_GAMMARAMP_TABLE            },
    { "PDEV_UMPD                       ", PDEV_UMPD                       },
    { "PDEV_SHARED_DEVLOCK             ", PDEV_SHARED_DEVLOCK             },
    { "PDEV_META_DEVICE                ", PDEV_META_DEVICE                },
    { "PDEV_DRIVER_PUNTED_CALL         ", PDEV_DRIVER_PUNTED_CALL         },
    { "PDEV_CLONE_DEVICE               ", PDEV_CLONE_DEVICE               },
    {                                  0, 0                               }
};

FLAGDEF afdDCX[] = {
    { "METAFILE_TO_WORLD_IDENTITY   ",  METAFILE_TO_WORLD_IDENTITY    },
    { "WORLD_TO_PAGE_IDENTITY       ",  WORLD_TO_PAGE_IDENTITY        },
    { "DEVICE_TO_PAGE_INVALID       ",  DEVICE_TO_PAGE_INVALID        },
    { "DEVICE_TO_WORLD_INVALID      ",  DEVICE_TO_WORLD_INVALID       },
    { "WORLD_TRANSFORM_SET          ",  WORLD_TRANSFORM_SET           },
    { "POSITIVE_Y_IS_UP             ",  POSITIVE_Y_IS_UP              },
    { "INVALIDATE_ATTRIBUTES        ",  INVALIDATE_ATTRIBUTES         },
    { "PTOD_EFM11_NEGATIVE          ",  PTOD_EFM11_NEGATIVE           },
    { "PTOD_EFM22_NEGATIVE          ",  PTOD_EFM22_NEGATIVE           },
    { "ISO_OR_ANISO_MAP_MODE        ",  ISO_OR_ANISO_MAP_MODE         },
    { "PAGE_TO_DEVICE_IDENTITY      ",  PAGE_TO_DEVICE_IDENTITY       },
    { "PAGE_TO_DEVICE_SCALE_IDENTITY",  PAGE_TO_DEVICE_SCALE_IDENTITY },
    { "PAGE_XLATE_CHANGED           ",  PAGE_XLATE_CHANGED            },
    { "PAGE_EXTENTS_CHANGED         ",  PAGE_EXTENTS_CHANGED          },
    { "WORLD_XFORM_CHANGED          ",  WORLD_XFORM_CHANGED           },
    {                               0,  0                             }
};

FLAGDEF afdDC[] = {
    { "DC_DISPLAY          ", DC_DISPLAY           },
    { "DC_DIRECT           ", DC_DIRECT            },
    { "DC_CANCELED         ", DC_CANCELED          },
    { "DC_PERMANANT        ", DC_PERMANANT         },
    { "DC_DIRTY_RAO        ", DC_DIRTY_RAO         },
    { "DC_ACCUM_WMGR       ", DC_ACCUM_WMGR        },
    { "DC_ACCUM_APP        ", DC_ACCUM_APP         },
    { "DC_RESET            ", DC_RESET             },
    { "DC_SYNCHRONIZEACCESS", DC_SYNCHRONIZEACCESS },
    { "DC_EPSPRINTINGESCAPE", DC_EPSPRINTINGESCAPE },
    { "DC_TEMPINFODC       ", DC_TEMPINFODC        },
    { "DC_FULLSCREEN       ", DC_FULLSCREEN        },
    { "DC_IN_CLONEPDEV     ", DC_IN_CLONEPDEV      },
    { "DC_REDIRECTION      ", DC_REDIRECTION       },   
    { "DC_SHAREACCESS      ", DC_SHAREACCESS       },   
    {                      0, 0                    }
};

FLAGDEF afdGC[] = {
    { "GCAPS_BEZIERS         ", GCAPS_BEZIERS          },
    { "GCAPS_GEOMETRICWIDE   ", GCAPS_GEOMETRICWIDE    },
    { "GCAPS_ALTERNATEFILL   ", GCAPS_ALTERNATEFILL    },
    { "GCAPS_WINDINGFILL     ", GCAPS_WINDINGFILL      },
    { "GCAPS_HALFTONE        ", GCAPS_HALFTONE         },
    { "GCAPS_COLOR_DITHER    ", GCAPS_COLOR_DITHER     },
    { "GCAPS_HORIZSTRIKE     ", GCAPS_HORIZSTRIKE      },
    { "GCAPS_VERTSTRIKE      ", GCAPS_VERTSTRIKE       },
    { "GCAPS_OPAQUERECT      ", GCAPS_OPAQUERECT       },
    { "GCAPS_VECTORFONT      ", GCAPS_VECTORFONT       },
    { "GCAPS_MONO_DITHER     ", GCAPS_MONO_DITHER      },
    { "GCAPS_ASYNCCHANGE     ", GCAPS_ASYNCCHANGE      },
    { "GCAPS_ASYNCMOVE       ", GCAPS_ASYNCMOVE        },
    { "GCAPS_DONTJOURNAL     ", GCAPS_DONTJOURNAL      },
    { "GCAPS_ARBRUSHOPAQUE   ", GCAPS_ARBRUSHOPAQUE    },
    { "GCAPS_PANNING         ", GCAPS_PANNING          },
    { "GCAPS_HIGHRESTEXT     ", GCAPS_HIGHRESTEXT      },
    { "GCAPS_PALMANAGED      ", GCAPS_PALMANAGED       },
    { "GCAPS_DITHERONREALIZE ", GCAPS_DITHERONREALIZE  },
    { "GCAPS_NO64BITMEMACCESS", GCAPS_NO64BITMEMACCESS },
    { "GCAPS_FORCEDITHER     ", GCAPS_FORCEDITHER      },
    { "GCAPS_GRAY16          ", GCAPS_GRAY16           },
    { "GCAPS_ICM             ", GCAPS_ICM              },
    { "GCAPS_CMYKCOLOR       ", GCAPS_CMYKCOLOR        },
    {                        0, 0                      }
};

FLAGDEF afdGC2[] = {
    { "GCAPS2_JPEGSRC        ", GCAPS2_JPEGSRC         },
    { "GCAPS2_SYNCFLUSH      ", GCAPS2_SYNCFLUSH       },
    { "GCAPS2_PNGSRC         ", GCAPS2_PNGSRC          },
    {                        0, 0                      }
};

FLAGDEF afdTSIM[] = {
  { "TO_MEM_ALLOCATED ", TO_MEM_ALLOCATED  },
  { "TO_ALL_PTRS_VALID", TO_ALL_PTRS_VALID },
  { "TO_VALID         ", TO_VALID          },
  { "TO_ESC_NOT_ORIENT", TO_ESC_NOT_ORIENT },
  { "TO_PWSZ_ALLOCATED", TO_PWSZ_ALLOCATED },
  { "TO_HIGHRESTEXT   ", TO_HIGHRESTEXT    },
  { "TSIM_UNDERLINE1  ", TSIM_UNDERLINE1   },
  { "TSIM_UNDERLINE2  ", TSIM_UNDERLINE2   },
  { "TSIM_STRIKEOUT   ", TSIM_STRIKEOUT    },
  {                   0, 0                 }
};

FLAGDEF afdRC[] = {
    { "RC_NONE        ", RC_NONE         },
    { "RC_BITBLT      ", RC_BITBLT       },
    { "RC_BANDING     ", RC_BANDING      },
    { "RC_SCALING     ", RC_SCALING      },
    { "RC_BITMAP64    ", RC_BITMAP64     },
    { "RC_GDI20_OUTPUT", RC_GDI20_OUTPUT },
    { "RC_GDI20_STATE ", RC_GDI20_STATE  },
    { "RC_SAVEBITMAP  ", RC_SAVEBITMAP   },
    { "RC_DI_BITMAP   ", RC_DI_BITMAP    },
    { "RC_PALETTE     ", RC_PALETTE      },
    { "RC_DIBTODEV    ", RC_DIBTODEV     },
    { "RC_BIGFONT     ", RC_BIGFONT      },
    { "RC_STRETCHBLT  ", RC_STRETCHBLT   },
    { "RC_FLOODFILL   ", RC_FLOODFILL    },
    { "RC_STRETCHDIB  ", RC_STRETCHDIB   },
    { "RC_OP_DX_OUTPUT", RC_OP_DX_OUTPUT },
    { "RC_DEVBITS     ", RC_DEVBITS      },
    { 0                , 0               }
};

FLAGDEF afdTC[] = {
    { "TC_OP_CHARACTER", TC_OP_CHARACTER },
    { "TC_OP_STROKE   ", TC_OP_STROKE    },
    { "TC_CP_STROKE   ", TC_CP_STROKE    },
    { "TC_CR_90       ", TC_CR_90        },
    { "TC_CR_ANY      ", TC_CR_ANY       },
    { "TC_SF_X_YINDEP ", TC_SF_X_YINDEP  },
    { "TC_SA_DOUBLE   ", TC_SA_DOUBLE    },
    { "TC_SA_INTEGER  ", TC_SA_INTEGER   },
    { "TC_SA_CONTIN   ", TC_SA_CONTIN    },
    { "TC_EA_DOUBLE   ", TC_EA_DOUBLE    },
    { "TC_IA_ABLE     ", TC_IA_ABLE      },
    { "TC_UA_ABLE     ", TC_UA_ABLE      },
    { "TC_SO_ABLE     ", TC_SO_ABLE      },
    { "TC_RA_ABLE     ", TC_RA_ABLE      },
    { "TC_VA_ABLE     ", TC_VA_ABLE      },
    { "TC_RESERVED    ", TC_RESERVED     },
    { "TC_SCROLLBLT   ", TC_SCROLLBLT    },
    { 0                , 0               }
};

FLAGDEF afdHT[] = {
    { "HT_FLAG_SQUARE_DEVICE_PEL", HT_FLAG_SQUARE_DEVICE_PEL },
    { "HT_FLAG_HAS_BLACK_DYE    ", HT_FLAG_HAS_BLACK_DYE     },
    { "HT_FLAG_ADDITIVE_PRIMS   ", HT_FLAG_ADDITIVE_PRIMS    },
    { "HT_FLAG_OUTPUT_CMY       ", HT_FLAG_OUTPUT_CMY        },
    { 0                          , 0                         }
};

FLAGDEF afdDCfs[] = {
  { "DC_DISPLAY          ", DC_DISPLAY           },
  { "DC_DIRECT           ", DC_DIRECT            },
  { "DC_CANCELED         ", DC_CANCELED          },
  { "DC_PERMANANT        ", DC_PERMANANT         },
  { "DC_DIRTY_RAO        ", DC_DIRTY_RAO         },
  { "DC_ACCUM_WMGR       ", DC_ACCUM_WMGR        },
  { "DC_ACCUM_APP        ", DC_ACCUM_APP         },
  { "DC_RESET            ", DC_RESET             },
  { "DC_SYNCHRONIZEACCESS", DC_SYNCHRONIZEACCESS },
  { "DC_EPSPRINTINGESCAPE", DC_EPSPRINTINGESCAPE },
  { "DC_TEMPINFODC       ", DC_TEMPINFODC        },
  { "DC_FULLSCREEN       ", DC_FULLSCREEN        },
  { "DC_IN_CLONEPDEV     ", DC_IN_CLONEPDEV      },
  { "DC_REDIRECTION      ", DC_REDIRECTION       },
  {                     0, 0                    }
};

FLAGDEF afdGInfo[] = {
  { "GCAPS_BEZIERS         ", GCAPS_BEZIERS          },
  { "GCAPS_GEOMETRICWIDE   ", GCAPS_GEOMETRICWIDE    },
  { "GCAPS_ALTERNATEFILL   ", GCAPS_ALTERNATEFILL    },
  { "GCAPS_WINDINGFILL     ", GCAPS_WINDINGFILL      },
  { "GCAPS_HALFTONE        ", GCAPS_HALFTONE         },
  { "GCAPS_COLOR_DITHER    ", GCAPS_COLOR_DITHER     },
  { "GCAPS_HORIZSTRIKE     ", GCAPS_HORIZSTRIKE      },
  { "GCAPS_VERTSTRIKE      ", GCAPS_VERTSTRIKE       },
  { "GCAPS_OPAQUERECT      ", GCAPS_OPAQUERECT       },
  { "GCAPS_VECTORFONT      ", GCAPS_VECTORFONT       },
  { "GCAPS_MONO_DITHER     ", GCAPS_MONO_DITHER      },
  { "GCAPS_ASYNCCHANGE     ", GCAPS_ASYNCCHANGE      },
  { "GCAPS_ASYNCMOVE       ", GCAPS_ASYNCMOVE        },
  { "GCAPS_DONTJOURNAL     ", GCAPS_DONTJOURNAL      },
  { "GCAPS_ARBRUSHOPAQUE   ", GCAPS_ARBRUSHOPAQUE    },
  { "GCAPS_HIGHRESTEXT     ", GCAPS_HIGHRESTEXT      },
  { "GCAPS_PALMANAGED      ", GCAPS_PALMANAGED       },
  { "GCAPS_DITHERONREALIZE ", GCAPS_DITHERONREALIZE  },
  { "GCAPS_NO64BITMEMACCESS", GCAPS_NO64BITMEMACCESS },
  { "GCAPS_FORCEDITHER     ", GCAPS_FORCEDITHER      },
  { "GCAPS_GRAY16          ", GCAPS_GRAY16           },
  { "GCAPS_ICM             ", GCAPS_ICM              },
  { "GCAPS_CMYKCOLOR       ", GCAPS_CMYKCOLOR        },
  {                        0, 0                      }
};

// IFIMETRICS::flInfo
FLAGDEF afdInfo[] = {
  { "FM_INFO_TECH_TRUETYPE            ", FM_INFO_TECH_TRUETYPE             },
  { "FM_INFO_TECH_BITMAP              ", FM_INFO_TECH_BITMAP               },
  { "FM_INFO_TECH_STROKE              ", FM_INFO_TECH_STROKE               },
  { "FM_INFO_TECH_OUTLINE_NOT_TRUETYPE", FM_INFO_TECH_OUTLINE_NOT_TRUETYPE },
  { "FM_INFO_ARB_XFORMS               ", FM_INFO_ARB_XFORMS                },
  { "FM_INFO_1BPP                     ", FM_INFO_1BPP                      },
  { "FM_INFO_4BPP                     ", FM_INFO_4BPP                      },
  { "FM_INFO_8BPP                     ", FM_INFO_8BPP                      },
  { "FM_INFO_16BPP                    ", FM_INFO_16BPP                     },
  { "FM_INFO_24BPP                    ", FM_INFO_24BPP                     },
  { "FM_INFO_32BPP                    ", FM_INFO_32BPP                     },
  { "FM_INFO_INTEGER_WIDTH            ", FM_INFO_INTEGER_WIDTH             },
  { "FM_INFO_CONSTANT_WIDTH           ", FM_INFO_CONSTANT_WIDTH            },
  { "FM_INFO_NOT_CONTIGUOUS           ", FM_INFO_NOT_CONTIGUOUS            },
  { "FM_INFO_TECH_MM                  ", FM_INFO_TECH_MM                   },
  { "FM_INFO_RETURNS_OUTLINES         ", FM_INFO_RETURNS_OUTLINES          },
  { "FM_INFO_RETURNS_STROKES          ", FM_INFO_RETURNS_STROKES           },
  { "FM_INFO_RETURNS_BITMAPS          ", FM_INFO_RETURNS_BITMAPS           },
  { "FM_INFO_DSIG                     ", FM_INFO_DSIG                      },
  { "FM_INFO_RIGHT_HANDED             ", FM_INFO_RIGHT_HANDED              },
  { "FM_INFO_INTEGRAL_SCALING         ", FM_INFO_INTEGRAL_SCALING          },
  { "FM_INFO_90DEGREE_ROTATIONS       ", FM_INFO_90DEGREE_ROTATIONS        },
  { "FM_INFO_OPTICALLY_FIXED_PITCH    ", FM_INFO_OPTICALLY_FIXED_PITCH     },
  { "FM_INFO_DO_NOT_ENUMERATE         ", FM_INFO_DO_NOT_ENUMERATE          },
  { "FM_INFO_ISOTROPIC_SCALING_ONLY   ", FM_INFO_ISOTROPIC_SCALING_ONLY    },
  { "FM_INFO_ANISOTROPIC_SCALING_ONLY ", FM_INFO_ANISOTROPIC_SCALING_ONLY  },
  { "FM_INFO_TECH_CFF                 ", FM_INFO_TECH_CFF                  },
  { "FM_INFO_FAMILY_EQUIV             ", FM_INFO_FAMILY_EQUIV              },
  { "FM_INFO_DBCS_FIXED_PITCH         ", FM_INFO_DBCS_FIXED_PITCH          },
  { "FM_INFO_NONNEGATIVE_AC           ", FM_INFO_NONNEGATIVE_AC            },
  { "FM_INFO_IGNORE_TC_RA_ABLE        ", FM_INFO_IGNORE_TC_RA_ABLE         },
  { "FM_INFO_TECH_TYPE1               ", FM_INFO_TECH_TYPE1                },
  {                                   0, 0                                 }
};


FLAGDEF afdFM_SEL[] = {
  { "FM_SEL_ITALIC    ", FM_SEL_ITALIC    },
  { "FM_SEL_UNDERSCORE", FM_SEL_UNDERSCORE},
  { "FM_SEL_NEGATIVE  ", FM_SEL_NEGATIVE  },
  { "FM_SEL_OUTLINED  ", FM_SEL_OUTLINED  },
  { "FM_SEL_STRIKEOUT ", FM_SEL_STRIKEOUT },
  { "FM_SEL_BOLD      ", FM_SEL_BOLD      },
  { "FM_SEL_REGULAR   ", FM_SEL_REGULAR   },
  {                   0, 0                }
};


// STROBJ::flAccel

FLAGDEF afdSO[] = {
    { "SO_FLAG_DEFAULT_PLACEMENT", SO_FLAG_DEFAULT_PLACEMENT },
    { "SO_HORIZONTAL            ", SO_HORIZONTAL             },
    { "SO_VERTICAL              ", SO_VERTICAL               },
    { "SO_REVERSED              ", SO_REVERSED               },
    { "SO_ZERO_BEARINGS         ", SO_ZERO_BEARINGS          },
    { "SO_CHAR_INC_EQUAL_BM_BASE", SO_CHAR_INC_EQUAL_BM_BASE },
    { "SO_MAXEXT_EQUAL_BM_SIDE  ", SO_MAXEXT_EQUAL_BM_SIDE   },
    {                           0, 0                         }
};

// ESTROBJ::flTO

FLAGDEF afdTO[] = {
    { "TO_MEM_ALLOCATED ", TO_MEM_ALLOCATED  },
    { "TO_ALL_PTRS_VALID", TO_ALL_PTRS_VALID },
    { "TO_VALID         ", TO_VALID          },
    { "TO_ESC_NOT_ORIENT", TO_ESC_NOT_ORIENT },
    { "TO_PWSZ_ALLOCATED", TO_PWSZ_ALLOCATED },
    { "TO_HIGHRESTEXT   ", TO_HIGHRESTEXT    },
    { "TO_BITMAPS       ", TO_BITMAPS        },
    { "TO_PARTITION_INIT", TO_PARTITION_INIT },
    { "TO_ALLOC_FACENAME", TO_ALLOC_FACENAME },
    { "TO_SYS_PARTITION ", TO_SYS_PARTITION  },
    { "TSIM_UNDERLINE1  ", TSIM_UNDERLINE1   },
    { "TSIM_UNDERLINE2  ", TSIM_UNDERLINE2   },
    { "TSIM_STRIKEOUT   ", TSIM_STRIKEOUT    },
    {                   0, 0                 }
};

// DCLEVEL::flXform

FLAGDEF afdflx[] = {
  { "METAFILE_TO_WORLD_IDENTITY   ", METAFILE_TO_WORLD_IDENTITY    },
  { "WORLD_TO_PAGE_IDENTITY       ", WORLD_TO_PAGE_IDENTITY        },
  { "DEVICE_TO_PAGE_INVALID       ", DEVICE_TO_PAGE_INVALID        },
  { "DEVICE_TO_WORLD_INVALID      ", DEVICE_TO_WORLD_INVALID       },
  { "WORLD_TRANSFORM_SET          ", WORLD_TRANSFORM_SET           },
  { "POSITIVE_Y_IS_UP             ", POSITIVE_Y_IS_UP              },
  { "INVALIDATE_ATTRIBUTES        ", INVALIDATE_ATTRIBUTES         },
  { "PTOD_EFM11_NEGATIVE          ", PTOD_EFM11_NEGATIVE           },
  { "PTOD_EFM22_NEGATIVE          ", PTOD_EFM22_NEGATIVE           },
  { "ISO_OR_ANISO_MAP_MODE        ", ISO_OR_ANISO_MAP_MODE         },
  { "PAGE_TO_DEVICE_IDENTITY      ", PAGE_TO_DEVICE_IDENTITY       },
  { "PAGE_TO_DEVICE_SCALE_IDENTITY", PAGE_TO_DEVICE_SCALE_IDENTITY },
  { "PAGE_XLATE_CHANGED           ", PAGE_XLATE_CHANGED            },
  { "PAGE_EXTENTS_CHANGED         ", PAGE_EXTENTS_CHANGED          },
  { "WORLD_XFORM_CHANGED          ", WORLD_XFORM_CHANGED           },
  {                               0, 0                             }
};

// DCLEVEL::flFontState

FLAGDEF afdFS2[] = {
    { "DC_DIRTYFONT_XFORM", DC_DIRTYFONT_XFORM },
    { "DC_DIRTYFONT_LFONT", DC_DIRTYFONT_LFONT },
    { "DC_UFI_MAPPING    ", DC_UFI_MAPPING     },
    {                    0, 0                  }
};


// RFONT::flType

FLAGDEF afdRT[] = {
    { "RFONT_TYPE_NOCACHE", RFONT_TYPE_NOCACHE },
    { "RFONT_TYPE_UNICODE", RFONT_TYPE_UNICODE },
    { "RFONT_TYPE_HGLYPH ", RFONT_TYPE_HGLYPH  },
    {                    0, 0                  }
};

// FONTOBJ::flFontType

FLAGDEF afdFO[] = {
    { "FO_TYPE_RASTER  ", FO_TYPE_RASTER   },
    { "FO_TYPE_DEVICE  ", FO_TYPE_DEVICE   },
    { "FO_TYPE_TRUETYPE", FO_TYPE_TRUETYPE },
    { "FO_SIM_BOLD     ", FO_SIM_BOLD      },
    { "FO_SIM_ITALIC   ", FO_SIM_ITALIC    },
    { "FO_EM_HEIGHT    ", FO_EM_HEIGHT     },
    { "FO_GRAY16       ", FO_GRAY16        },
    { "FO_NOHINTS      ", FO_NOHINTS       },
    { "FO_NO_CHOICE    ", FO_NO_CHOICE     },
    {                  0, 0                }
};

// FD_GLYPHSET::flAccel

FLAGDEF afdGS[] = {
    { "GS_UNICODE_HANDLES", GS_UNICODE_HANDLES },
    { "GS_8BIT_HANDLES   ", GS_8BIT_HANDLES    },
    { "GS_16BIT_HANDLES  ", GS_16BIT_HANDLES   },
    {                    0, 0                  }
};

// IFIMETRICS::fsType

FLAGDEF afdFM_TYPE[] = {
    { "FM_TYPE_LICENSED ", FM_TYPE_LICENSED  },
    { "FM_READONLY_EMBED", FM_READONLY_EMBED },
    { "FM_EDITABLE_EMBED", FM_EDITABLE_EMBED },
    {                   0, 0                 }
};

FLAGDEF afdPFE[] = {
    { "PFE_DEVICEFONT ", PFE_DEVICEFONT },
    { "PFE_DEADSTATE  ", PFE_DEADSTATE  },
    { "PFE_REMOTEFONT ", PFE_REMOTEFONT },
    { "PFE_EUDC       ", PFE_EUDC       },
    { "PFE_SBCS_SYSTEM", PFE_SBCS_SYSTEM},
    { "PFE_UFIMATCH   ", PFE_UFIMATCH   },
    { "PFE_MEMORYFONT ", PFE_MEMORYFONT },
    { "PFE_DBCS_FONT  ", PFE_DBCS_FONT  },
    { "PFE_VERT_FACE  ", PFE_VERT_FACE  },
    {                0, 0              }
};

FLAGDEF afdBMF[] = {
    { "BMF_TOPDOWN            ", BMF_TOPDOWN            },
    { "BMF_NOZEROINIT         ", BMF_NOZEROINIT         },
    { "BMF_DONTCACHE          ", BMF_DONTCACHE          },
    { "BMF_USERMEM            ", BMF_USERMEM            },
    { "BMF_KMSECTION          ", BMF_KMSECTION          },
    { "BMF_NOTSYSMEM          ", BMF_NOTSYSMEM          },
    FLAG(BMF_WINDOW_BLT),
    FLAG(BMF_UMPDMEM),
    FLAG(BMF_ISREADONLY),
    FLAG(BMF_MAKEREADWRITE),
    {                         0, 0                      }
};

FLAGDEF afdDDSCAPS[] = {
    { "DDSCAPS_ALPHA              ", DDSCAPS_ALPHA              },
    { "DDSCAPS_BACKBUFFER         ", DDSCAPS_BACKBUFFER         },
    { "DDSCAPS_COMPLEX            ", DDSCAPS_COMPLEX            },
    { "DDSCAPS_FLIP               ", DDSCAPS_FLIP               },
    { "DDSCAPS_FRONTBUFFER        ", DDSCAPS_FRONTBUFFER        },
    { "DDSCAPS_OFFSCREENPLAIN     ", DDSCAPS_OFFSCREENPLAIN     },
    { "DDSCAPS_OVERLAY            ", DDSCAPS_OVERLAY            },
    { "DDSCAPS_PALETTE            ", DDSCAPS_PALETTE            },
    { "DDSCAPS_PRIMARYSURFACE     ", DDSCAPS_PRIMARYSURFACE     },
    { "DDSCAPS_PRIMARYSURFACELEFT ", DDSCAPS_PRIMARYSURFACELEFT },
    { "DDSCAPS_SYSTEMMEMORY       ", DDSCAPS_SYSTEMMEMORY       },
    { "DDSCAPS_TEXTURE            ", DDSCAPS_TEXTURE            },
    { "DDSCAPS_3DDEVICE           ", DDSCAPS_3DDEVICE           },
    { "DDSCAPS_VIDEOMEMORY        ", DDSCAPS_VIDEOMEMORY        },
    { "DDSCAPS_VISIBLE            ", DDSCAPS_VISIBLE            },
    { "DDSCAPS_WRITEONLY          ", DDSCAPS_WRITEONLY          },
    { "DDSCAPS_ZBUFFER            ", DDSCAPS_ZBUFFER            },
    { "DDSCAPS_OWNDC              ", DDSCAPS_OWNDC              },
    { "DDSCAPS_LIVEVIDEO          ", DDSCAPS_LIVEVIDEO          },
    { "DDSCAPS_HWCODEC            ", DDSCAPS_HWCODEC            },
    { "DDSCAPS_MODEX              ", DDSCAPS_MODEX              },
    { "DDSCAPS_MIPMAP             ", DDSCAPS_MIPMAP             },
    { "DDSCAPS_ALLOCONLOAD        ", DDSCAPS_ALLOCONLOAD        },
    { "DDSCAPS_VIDEOPORT          ", DDSCAPS_VIDEOPORT          },
    { "DDSCAPS_LOCALVIDMEM        ", DDSCAPS_LOCALVIDMEM        },
    { "DDSCAPS_NONLOCALVIDMEM     ", DDSCAPS_NONLOCALVIDMEM     },
    { "DDSCAPS_STANDARDVGAMODE    ", DDSCAPS_STANDARDVGAMODE    },
    { "DDSCAPS_OPTIMIZED          ", DDSCAPS_OPTIMIZED          },
    {                             0, 0                          }
};

FLAGDEF afdDDSCAPS2[] = {
    { "DDSCAPS2_HARDWAREDEINTERLACE ", DDSCAPS2_HARDWAREDEINTERLACE },
    { "DDSCAPS2_HINTDYNAMIC         ", DDSCAPS2_HINTDYNAMIC         },
    { "DDSCAPS2_HINTSTATIC          ", DDSCAPS2_HINTSTATIC          },
    { "DDSCAPS2_TEXTUREMANAGE       ", DDSCAPS2_TEXTUREMANAGE       },
    { "DDSCAPS2_RESERVED1           ", DDSCAPS2_RESERVED1           },
    { "DDSCAPS2_RESERVED2           ", DDSCAPS2_RESERVED2           },
    { "DDSCAPS2_OPAQUE              ", DDSCAPS2_OPAQUE              },
    { "DDSCAPS2_HINTANTIALIASING    ", DDSCAPS2_HINTANTIALIASING    },
    { "DDSCAPS2_CUBEMAP             ", DDSCAPS2_CUBEMAP             },
    { "DDSCAPS2_CUBEMAP_POSITIVEX   ", DDSCAPS2_CUBEMAP_POSITIVEX   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEX   ", DDSCAPS2_CUBEMAP_NEGATIVEX   },
    { "DDSCAPS2_CUBEMAP_POSITIVEY   ", DDSCAPS2_CUBEMAP_POSITIVEY   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEY   ", DDSCAPS2_CUBEMAP_NEGATIVEY   },
    { "DDSCAPS2_CUBEMAP_POSITIVEZ   ", DDSCAPS2_CUBEMAP_POSITIVEZ   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEZ   ", DDSCAPS2_CUBEMAP_NEGATIVEZ   },
    { "DDSCAPS2_CUBEMAP_ALLFACES    ", DDSCAPS2_CUBEMAP_ALLFACES    },
    { "DDSCAPS2_MIPMAPSUBLEVEL      ", DDSCAPS2_MIPMAPSUBLEVEL      },
    {                              0, 0                             }
};

FLAGDEF afdDDRAWISURF[] = {
    FLAG(DDRAWISURF_HASCKEYSRCBLT),
    FLAG(DDRAWISURF_HASPIXELFORMAT),
    FLAG(DDRAWISURF_FRONTBUFFER),
    FLAG(DDRAWISURF_BACKBUFFER),
    END_FLAG
};

#if ENABLE_ALL_FLAGS
FLAGDEF afdDDSURFACEFL[] = {
    FLAG(DD_SURFACE_FLAG_PRIMARY),
    FLAG(DD_SURFACE_FLAG_CLIP),
    FLAG(DD_SURFACE_FLAG_DRIVER_CREATED),
    FLAG(DD_SURFACE_FLAG_CREATE_COMPLETE),
    FLAG(DD_SURFACE_FLAG_UMEM_ALLOCATED),
    FLAG(DD_SURFACE_FLAG_VMEM_ALLOCATED),
    END_FLAG
};
#endif  // ENABLE_ALL_FLAGS

FLAGDEF afdDDPIXELFORMAT[] = {
    FLAG(DDPF_ALPHAPIXELS),
    FLAG(DDPF_ALPHA),
    FLAG(DDPF_FOURCC),
    FLAG(DDPF_PALETTEINDEXED4),
    FLAG(DDPF_PALETTEINDEXEDTO8),
    FLAG(DDPF_PALETTEINDEXED8),
    FLAG(DDPF_RGB),
    FLAG(DDPF_COMPRESSED),
    FLAG(DDPF_RGBTOYUV),
    FLAG(DDPF_YUV),
    FLAG(DDPF_ZBUFFER),
    FLAG(DDPF_PALETTEINDEXED1),
    FLAG(DDPF_PALETTEINDEXED2),
    FLAG(DDPF_ZPIXELS),
    END_FLAG
};

FLAGDEF afdDVERIFIER[] = {
    FLAG(DRIVER_VERIFIER_SPECIAL_POOLING),
    FLAG(DRIVER_VERIFIER_FORCE_IRQL_CHECKING),
    FLAG(DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES),
    FLAG(DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS),
    FLAG(DRIVER_VERIFIER_IO_CHECKING),
    END_FLAG
};


char *pszGraphicsMode(LONG l)
{
    char *psz;
    switch (l) {
    case GM_COMPATIBLE: psz = "GM_COMPATIBLE"; break;
    case GM_ADVANCED  : psz = "GM_ADVANCED"  ; break;
    default           : psz = "GM_?"         ; break;
    }
    return( psz );
}

char *pszROP2(LONG l)
{
    char *psz;
    switch (l) {
    case  R2_BLACK      : psz = "R2_BLACK"      ; break;
    case  R2_NOTMERGEPEN: psz = "R2_NOTMERGEPEN"; break;
    case  R2_MASKNOTPEN : psz = "R2_MASKNOTPEN" ; break;
    case  R2_NOTCOPYPEN : psz = "R2_NOTCOPYPEN" ; break;
    case  R2_MASKPENNOT : psz = "R2_MASKPENNOT" ; break;
    case  R2_NOT        : psz = "R2_NOT"        ; break;
    case  R2_XORPEN     : psz = "R2_XORPEN"     ; break;
    case  R2_NOTMASKPEN : psz = "R2_NOTMASKPEN" ; break;
    case  R2_MASKPEN    : psz = "R2_MASKPEN"    ; break;
    case  R2_NOTXORPEN  : psz = "R2_NOTXORPEN"  ; break;
    case  R2_NOP        : psz = "R2_NOP"        ; break;
    case  R2_MERGENOTPEN: psz = "R2_MERGENOTPEN"; break;
    case  R2_COPYPEN    : psz = "R2_COPYPEN"    ; break;
    case  R2_MERGEPENNOT: psz = "R2_MERGEPENNOT"; break;
    case  R2_MERGEPEN   : psz = "R2_MERGEPEN"   ; break;
    case  R2_WHITE      : psz = "R2_WHITE"      ; break;
    default             : psz = "R2_?"          ; break;
    }
    return( psz );
}

char *pszDCTYPE(LONG l)
{
    char *psz;
    switch (l) {
    case DCTYPE_DIRECT: psz = "DCTYPE_DIRECT"; break;
    case DCTYPE_MEMORY: psz = "DCTYPE_MEMORY"; break;
    case DCTYPE_INFO  : psz = "DCTYPE_INFO"  ; break;
    default           : psz = "DCTYPE_?"     ; break;
    }
    return( psz );
}

char *pszTA_V(long l)
{
    char *psz;
    switch (l & ( TA_TOP | TA_BOTTOM | TA_BASELINE )) {
    case TA_TOP   : psz = "TA_TOP"     ; break;
    case TA_RIGHT : psz = "TA_BOTTOM"  ; break;
    case TA_CENTER: psz = "TA_BASELINE"; break;
    default       : psz = "TA_?"       ; break ;
    }
    return( psz );
}

char *pszTA_H(long l)
{
    char *psz;
    switch (l & ( TA_LEFT | TA_RIGHT | TA_CENTER )) {
    case TA_LEFT  : psz = "TA_LEFT"  ; break;
    case TA_RIGHT : psz = "TA_RIGHT" ; break;
    case TA_CENTER: psz = "TA_CENTER"; break;
    default       : psz = "TA_?"     ; break;
    }
    return( psz );
}

char *pszTA_U(long l)
{
    char *psz;
    switch (l & (TA_NOUPDATECP | TA_UPDATECP)) {
    case TA_NOUPDATECP: psz = "TA_NOUPDATECP"; break;
    case TA_UPDATECP  : psz = "TA_UPDATECP"  ; break;
    default           : psz = "TA_?"         ; break;
    }
    return( psz );
}

char *pszMapMode(long l)
{
    char *psz;
    switch (l) {
    case MM_TEXT       : psz = "MM_TEXT"       ; break;
    case MM_LOMETRIC   : psz = "MM_LOMETRIC"   ; break;
    case MM_HIMETRIC   : psz = "MM_HIMETRIC"   ; break;
    case MM_LOENGLISH  : psz = "MM_LOENGLISH"  ; break;
    case MM_HIENGLISH  : psz = "MM_HIENGLISH"  ; break;
    case MM_TWIPS      : psz = "MM_TWIPS"      ; break;
    case MM_ISOTROPIC  : psz = "MM_ISOTROPIC"  ; break;
    case MM_ANISOTROPIC: psz = "MM_ANISOTROPIC"; break;
    default            : psz = "MM_?"          ; break;
    }
    return( psz );
}

char *pszBkMode(long l)
{
    char *psz;
    switch (l) {
    case TRANSPARENT:   psz = "TRANSPARENT"; break;
    case OPAQUE     :   psz = "OPAQUE"     ; break;
    default         :   psz = "BKMODE_?"   ; break;
    }
    return( psz );
}

char *pszFW(long l)
{
    char *psz;
    switch ( l ) {
    case FW_DONTCARE  : psz = "FW_DONTCARE  "; break;
    case FW_THIN      : psz = "FW_THIN      "; break;
    case FW_EXTRALIGHT: psz = "FW_EXTRALIGHT"; break;
    case FW_LIGHT     : psz = "FW_LIGHT     "; break;
    case FW_NORMAL    : psz = "FW_NORMAL    "; break;
    case FW_MEDIUM    : psz = "FW_MEDIUM    "; break;
    case FW_SEMIBOLD  : psz = "FW_SEMIBOLD  "; break;
    case FW_BOLD      : psz = "FW_BOLD      "; break;
    case FW_EXTRABOLD : psz = "FW_EXTRABOLD "; break;
    case FW_HEAVY     : psz = "FW_HEAVY     "; break;
    default           : psz = "?FW"          ; break;
    }
    return( psz );
}

char *pszCHARSET(long l)
{
    char *psz;
    switch ( l ) {
    case ANSI_CHARSET        : psz = "ANSI_CHARSET       "; break;
    case DEFAULT_CHARSET     : psz = "DEFAULT_CHARSET    "; break;
    case SYMBOL_CHARSET      : psz = "SYMBOL_CHARSET     "; break;
    case SHIFTJIS_CHARSET    : psz = "SHIFTJIS_CHARSET   "; break;
    case HANGEUL_CHARSET     : psz = "HANGEUL_CHARSET    "; break;
    case GB2312_CHARSET      : psz = "GB2312_CHARSET     "; break;
    case CHINESEBIG5_CHARSET : psz = "CHINESEBIG5_CHARSET"; break;
    case OEM_CHARSET         : psz = "OEM_CHARSET        "; break;
    case JOHAB_CHARSET       : psz = "JOHAB_CHARSET      "; break;
    case HEBREW_CHARSET      : psz = "HEBREW_CHARSET     "; break;
    case ARABIC_CHARSET      : psz = "ARABIC_CHARSET     "; break;
    case GREEK_CHARSET       : psz = "GREEK_CHARSET      "; break;
    case TURKISH_CHARSET     : psz = "TURKISH_CHARSET    "; break;
    case THAI_CHARSET        : psz = "THAI_CHARSET       "; break;
    case EASTEUROPE_CHARSET  : psz = "EASTEUROPE_CHARSET "; break;
    case RUSSIAN_CHARSET     : psz = "RUSSIAN_CHARSET    "; break;
    case BALTIC_CHARSET      : psz = "BALTIC_CHARSET     "; break;
    default                  : psz = "?_CHARSET"          ; break;
    }
    return( psz );
}

char *pszOUT_PRECIS( long l )
{
    char *psz;
    switch ( l ) {
    case OUT_DEFAULT_PRECIS   : psz = "OUT_DEFAULT_PRECIS  "; break;
    case OUT_STRING_PRECIS    : psz = "OUT_STRING_PRECIS   "; break;
    case OUT_CHARACTER_PRECIS : psz = "OUT_CHARACTER_PRECIS"; break;
    case OUT_STROKE_PRECIS    : psz = "OUT_STROKE_PRECIS   "; break;
    case OUT_TT_PRECIS        : psz = "OUT_TT_PRECIS       "; break;
    case OUT_DEVICE_PRECIS    : psz = "OUT_DEVICE_PRECIS   "; break;
    case OUT_RASTER_PRECIS    : psz = "OUT_RASTER_PRECIS   "; break;
    case OUT_TT_ONLY_PRECIS   : psz = "OUT_TT_ONLY_PRECIS  "; break;
    case OUT_OUTLINE_PRECIS   : psz = "OUT_OUTLINE_PRECIS  "; break;
    default                   : psz = "OUT_?"               ; break;
    }
    return( psz );
}

char achFlags[100];

char *pszCLIP_PRECIS( long l )
{
    char *psz, *pch;

    switch ( l & CLIP_MASK) {
    case CLIP_DEFAULT_PRECIS   : psz = "CLIP_DEFAULT_PRECIS  "; break;
    case CLIP_CHARACTER_PRECIS : psz = "CLIP_CHARACTER_PRECIS"; break;
    case CLIP_STROKE_PRECIS    : psz = "CLIP_STROKE_PRECIS   "; break;
    default                    : psz = "CLIP_?"               ; break;
    }
    pch = achFlags;
    pch += sprintf(pch, "%s", psz);
    if ( l & CLIP_LH_ANGLES )
        pch += sprintf(pch, " | CLIP_LH_ANGLES");
    if ( l & CLIP_TT_ALWAYS )
        pch += sprintf(pch, " | CLIP_TT_ALWAYS");
    if ( l & CLIP_EMBEDDED )
        pch += sprintf(pch, " | CLIP_EMBEDDED");
    return( achFlags );
}

char *pszQUALITY( long l )
{
    char *psz;
    switch (l) {
    case DEFAULT_QUALITY        : psz = "DEFAULT_QUALITY       "; break;
    case DRAFT_QUALITY          : psz = "DRAFT_QUALITY         "; break;
    case PROOF_QUALITY          : psz = "PROOF_QUALITY         "; break;
    case NONANTIALIASED_QUALITY : psz = "NONANTIALIASED_QUALITY"; break;
    case ANTIALIASED_QUALITY    : psz = "ANTIALIASED_QUALITY   "; break;
    default                     : psz = "?_QUALITY"             ; break;
    }
    return( psz );
}

char *pszPitchAndFamily( long l )
{
    char *psz, *pch = achFlags;

    switch ( l & 0xf) {
    case DEFAULT_PITCH : psz = "DEFAULT_PITCH "; break;
    case FIXED_PITCH   : psz = "FIXED_PITCH   "; break;
    case VARIABLE_PITCH: psz = "VARIABLE_PITCH"; break;
    case MONO_FONT     : psz = "MONO_FONT     "; break;
    default            : psz = "PITCH_?"       ; break;
    }
    pch += sprintf(pch, "%s", psz);
    switch ( l & 0xf0) {
    case FF_DONTCARE   : psz = "FF_DONTCARE  "; break;
    case FF_ROMAN      : psz = "FF_ROMAN     "; break;
    case FF_SWISS      : psz = "FF_SWISS     "; break;
    case FF_MODERN     : psz = "FF_MODERN    "; break;
    case FF_SCRIPT     : psz = "FF_SCRIPT    "; break;
    case FF_DECORATIVE : psz = "FF_DECORATIVE"; break;
    default            : psz = "FF_?"         ; break;
    }
    pch += sprintf(pch, " | %s", psz);
    return( achFlags );
}

char *pszPanoseWeight( long l )
{
    char *psz;
    switch ( l ) {
    case PAN_ANY               : psz = "PAN_ANY              "; break;
    case PAN_NO_FIT            : psz = "PAN_NO_FIT           "; break;
    case PAN_WEIGHT_VERY_LIGHT : psz = "PAN_WEIGHT_VERY_LIGHT"; break;
    case PAN_WEIGHT_LIGHT      : psz = "PAN_WEIGHT_LIGHT     "; break;
    case PAN_WEIGHT_THIN       : psz = "PAN_WEIGHT_THIN      "; break;
    case PAN_WEIGHT_BOOK       : psz = "PAN_WEIGHT_BOOK      "; break;
    case PAN_WEIGHT_MEDIUM     : psz = "PAN_WEIGHT_MEDIUM    "; break;
    case PAN_WEIGHT_DEMI       : psz = "PAN_WEIGHT_DEMI      "; break;
    case PAN_WEIGHT_BOLD       : psz = "PAN_WEIGHT_BOLD      "; break;
    case PAN_WEIGHT_HEAVY      : psz = "PAN_WEIGHT_HEAVY     "; break;
    case PAN_WEIGHT_BLACK      : psz = "PAN_WEIGHT_BLACK     "; break;
    case PAN_WEIGHT_NORD       : psz = "PAN_WEIGHT_NORD      "; break;
    default:                     psz = "PAN_WEIGHT_?         "; break;
    }
    return(psz);
}

char *pszFONTHASHTYPE(FONTHASHTYPE fht)
{
    char *psz;

    switch (fht) {
    case FHT_FACE  : psz = "FHT_FACE"  ; break;
    case FHT_FAMILY: psz = "FHT_FAMILY"; break;
    case FHT_UFI   : psz = "FHT_UFI"   ; break;
    default        : psz = "FHT_?"     ; break;
    }
    return(psz);
}

char *pszDrvProcName(int index)
{
    char *pwsz;

    switch (index)
    {
    case INDEX_DrvEnablePDEV             : pwsz = "EnablePDEV             "; break;
    case INDEX_DrvCompletePDEV           : pwsz = "CompletePDEV           "; break;
    case INDEX_DrvDisablePDEV            : pwsz = "DisablePDEV            "; break;
    case INDEX_DrvEnableSurface          : pwsz = "EnableSurface          "; break;
    case INDEX_DrvDisableSurface         : pwsz = "DisableSurface         "; break;
    case INDEX_DrvAssertMode             : pwsz = "AssertMode             "; break;
    case INDEX_DrvOffset                 : pwsz = "Offset                 "; break;
    case INDEX_DrvResetPDEV              : pwsz = "ResetPDEV              "; break;
    case INDEX_DrvDisableDriver          : pwsz = "DisableDriver          "; break;
    case INDEX_DrvCreateDeviceBitmap     : pwsz = "CreateDeviceBitmap     "; break;
    case INDEX_DrvDeleteDeviceBitmap     : pwsz = "DeleteDeviceBitmap     "; break;
    case INDEX_DrvRealizeBrush           : pwsz = "RealizeBrush           "; break;
    case INDEX_DrvDitherColor            : pwsz = "DitherColor            "; break;
    case INDEX_DrvStrokePath             : pwsz = "StrokePath             "; break;
    case INDEX_DrvFillPath               : pwsz = "FillPath               "; break;
    case INDEX_DrvStrokeAndFillPath      : pwsz = "StrokeAndFillPath      "; break;
    case INDEX_DrvPaint                  : pwsz = "Paint                  "; break;
    case INDEX_DrvBitBlt                 : pwsz = "BitBlt                 "; break;
    case INDEX_DrvCopyBits               : pwsz = "CopyBits               "; break;
    case INDEX_DrvStretchBlt             : pwsz = "StretchBlt             "; break;
    case INDEX_DrvSetPalette             : pwsz = "SetPalette             "; break;
    case INDEX_DrvTextOut                : pwsz = "TextOut                "; break;
    case INDEX_DrvEscape                 : pwsz = "Escape                 "; break;
    case INDEX_DrvDrawEscape             : pwsz = "DrawEscape             "; break;
    case INDEX_DrvQueryFont              : pwsz = "QueryFont              "; break;
    case INDEX_DrvQueryFontTree          : pwsz = "QueryFontTree          "; break;
    case INDEX_DrvQueryFontData          : pwsz = "QueryFontData          "; break;
    case INDEX_DrvSetPointerShape        : pwsz = "SetPointerShape        "; break;
    case INDEX_DrvMovePointer            : pwsz = "MovePointer            "; break;
    case INDEX_DrvLineTo                 : pwsz = "LineTo                 "; break;
    case INDEX_DrvSendPage               : pwsz = "SendPage               "; break;
    case INDEX_DrvStartPage              : pwsz = "StartPage              "; break;
    case INDEX_DrvEndDoc                 : pwsz = "EndDoc                 "; break;
    case INDEX_DrvStartDoc               : pwsz = "StartDoc               "; break;
    case INDEX_DrvGetGlyphMode           : pwsz = "GetGlyphMode           "; break;
    case INDEX_DrvSynchronize            : pwsz = "Synchronize            "; break;
    case INDEX_DrvSaveScreenBits         : pwsz = "SaveScreenBits         "; break;
    case INDEX_DrvGetModes               : pwsz = "GetModes               "; break;
    case INDEX_DrvFree                   : pwsz = "Free                   "; break;
    case INDEX_DrvDestroyFont            : pwsz = "DestroyFont            "; break;
    case INDEX_DrvQueryFontCaps          : pwsz = "QueryFontCaps          "; break;
    case INDEX_DrvLoadFontFile           : pwsz = "LoadFontFile           "; break;
    case INDEX_DrvUnloadFontFile         : pwsz = "UnloadFontFile         "; break;
    case INDEX_DrvFontManagement         : pwsz = "FontManagement         "; break;
    case INDEX_DrvQueryTrueTypeTable     : pwsz = "QueryTrueTypeTable     "; break;
    case INDEX_DrvQueryTrueTypeOutline   : pwsz = "QueryTrueTypeOutline   "; break;
    case INDEX_DrvGetTrueTypeFile        : pwsz = "GetTrueTypeFile        "; break;
    case INDEX_DrvQueryFontFile          : pwsz = "QueryFontFile          "; break;
    case INDEX_DrvMovePanning            : pwsz = "MovePanning            "; break;
    case INDEX_DrvQueryAdvanceWidths     : pwsz = "QueryAdvanceWidths     "; break;
    case INDEX_DrvSetPixelFormat         : pwsz = "SetPixelFormat         "; break;
    case INDEX_DrvDescribePixelFormat    : pwsz = "DescribePixelFormat    "; break;
    case INDEX_DrvSwapBuffers            : pwsz = "SwapBuffers            "; break;
    case INDEX_DrvStartBanding           : pwsz = "StartBanding           "; break;
    case INDEX_DrvNextBand               : pwsz = "NextBand               "; break;
    case INDEX_DrvGetDirectDrawInfo      : pwsz = "GetDirectDrawInfo      "; break;
    case INDEX_DrvEnableDirectDraw       : pwsz = "EnableDirectDraw       "; break;
    case INDEX_DrvDisableDirectDraw      : pwsz = "DisableDirectDraw      "; break;
    case INDEX_DrvQuerySpoolType         : pwsz = "QuerySpoolType         "; break;
    case INDEX_DrvIcmCreateColorTransform: pwsz = "IcmCreateColorTransform"; break;
    case INDEX_DrvIcmDeleteColorTransform: pwsz = "IcmDeleteColorTransform"; break;
    case INDEX_DrvIcmCheckBitmapBits     : pwsz = "IcmCheckBitmapBits     "; break;
    case INDEX_DrvIcmSetDeviceGammaRamp  : pwsz = "IcmSetDeviceGammaRamp  "; break;
    case INDEX_DrvGradientFill           : pwsz = "GradientFill           "; break;
    case INDEX_DrvStretchBltROP          : pwsz = "StretchBltROP          "; break;
    case INDEX_DrvPlgBlt                 : pwsz = "PlgBlt                 "; break;
    case INDEX_DrvAlphaBlend             : pwsz = "AlphaBlend             "; break;
    case INDEX_DrvSynthesizeFont         : pwsz = "SynthesizeFont         "; break;
    case INDEX_DrvGetSynthesizedFontFiles: pwsz = "GetSynthesizedFontFiles"; break;
    case INDEX_DrvTransparentBlt         : pwsz = "TransparentBlt         "; break;
    case INDEX_DrvQueryPerBandInfo       : pwsz = "QueryPerBandInfo       "; break;
    default                              : pwsz = "???                    "; break;
    }
    return(pwsz);
}


char *pszHRESULT(HRESULT hr)
{
    char *psz;

    switch (hr)
    {
    case 0: psz = "OK"; break;
    CASEENUM(S_FALSE);
    CASEENUM(E_NOTIMPL);
    CASEENUM(E_OUTOFMEMORY);
    CASEENUM(E_INVALIDARG);
    CASEENUM(E_NOINTERFACE);
    CASEENUM(E_ABORT);
    CASEENUM(E_FAIL);
    default:
        switch (hr & 0xCFFFFFFF)
        {
        CASEENUM(STATUS_UNSUCCESSFUL);
        default:
            psz = achFlags;
            sprintf(psz, "unknown HRESULT 0x%08lx", hr);
            break;
        }
        break;
    }
    return(psz);
}


char *pszWinDbgError(ULONG ulError)
{
    char *psz;

    switch (ulError)
    {
    case 0: psz = "no error"; break;
    CASEENUM(MEMORY_READ_ERROR);
    CASEENUM(SYMBOL_TYPE_INDEX_NOT_FOUND);
    CASEENUM(SYMBOL_TYPE_INFO_NOT_FOUND);
    CASEENUM(FIELDS_DID_NOT_MATCH);
    CASEENUM(NULL_SYM_DUMP_PARAM);
    CASEENUM(NULL_FIELD_NAME);
    CASEENUM(INCORRECT_VERSION_INFO);
    CASEENUM(EXIT_ON_CONTROLC);
    CASEENUM(CANNOT_ALLOCATE_MEMORY);
    default:
        psz = achFlags;
        sprintf(psz, "unknown WinDbg error 0x08%x", ulError);
        break;
    }
    return(psz);
}


/******************************Public*Routine******************************\
*   print standard flags
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6-Mar-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG64
flPrintFlags(
    FLAGDEF *pFlagDef,
    ULONG64 fl
    )
{
    ULONG64 FlagsFound = 0;

    while (pFlagDef->psz != NULL)
    {
        if (pFlagDef->fl & fl)
        {
            if (FlagsFound) dprintf("\n");
            dprintf("       %s",pFlagDef->psz);
            if (FlagsFound & pFlagDef->fl)
            {
                dprintf(" (SHARED FLAG)");
            }
            FlagsFound |= pFlagDef->fl;
        }

        pFlagDef++;
    }

    return fl & ~FlagsFound;
}

BOOL
bPrintEnum(
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            dprintf(pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}


// BASEOBJECT.BaseFlags
FLAGDEF afdBASEOBJECT_BaseFlags[] = {
    FLAG(HMGR_LOOKASIDE_ALLOC_FLAG),
    END_FLAG
};


// _BLENDFUNCTION.BlendOp
ENUMDEF aed_BLENDFUNCTION_BlendOp[] = {
    ENUM(AC_SRC_OVER),
    END_ENUM
};

// _BLENDFUNCTION.BlendFlags
FLAGDEF afd_BLENDFUNCTION_BlendFlags[] = {
    FLAG(AC_USE_HIGHQUALITYFILTER),
    FLAG(AC_MIRRORBITMAP),
    END_FLAG
};

// _BLENDFUNCTION.AlphaFormat
FLAGDEF afd_BLENDFUNCTION_AlphaFormat[] = {
    FLAG(AC_SRC_ALPHA),
    END_FLAG
};


// BRUSH._flAttrs
// EBRUSHOBJ.flAttrs
FLAGDEF afdBRUSH__flAttrs[] = {
    FLAG(BR_NEED_FG_CLR),
    FLAG(BR_NEED_BK_CLR),
    FLAG(BR_DITHER_OK),
    FLAG(BR_IS_SOLID),
    FLAG(BR_IS_HATCH),
    FLAG(BR_IS_BITMAP),
    FLAG(BR_IS_DIB),
    FLAG(BR_IS_NULL),
    FLAG(BR_IS_GLOBAL),
    FLAG(BR_IS_PEN),
    FLAG(BR_IS_OLDSTYLEPEN),
    FLAG(BR_IS_DIBPALCOLORS),
    FLAG(BR_IS_DIBPALINDICES),
    FLAG(BR_IS_DEFAULTSTYLE),
    FLAG(BR_IS_MASKING),
    FLAG(BR_IS_INSIDEFRAME),
    FLAG(BR_IS_MONOCHROME),
    FLAG(BR_CACHED_ENGINE),
    FLAG(BR_CACHED_IS_SOLID),
    END_FLAG
};

// BRUSH._ulStyle
ENUMDEF aedBRUSH__ulStyle[] = {
    ENUM(HS_HORIZONTAL),
    ENUM(HS_VERTICAL),
    ENUM(HS_FDIAGONAL),
    ENUM(HS_BDIAGONAL),
    ENUM(HS_CROSS),
    ENUM(HS_DIAGCROSS),
    ENUM(HS_SOLIDCLR),
    ENUM(HS_DITHEREDCLR),
    ENUM(HS_SOLIDTEXTCLR),
    ENUM(HS_DITHEREDTEXTCLR),
    ENUM(HS_SOLIDBKCLR),
    ENUM(HS_DITHEREDBKCLR),
    ENUM(HS_API_MAX),
    ENUM(HS_NULL),
    ENUM(HS_PAT),
    ENUM(HS_MSK),
    ENUM(HS_PATMSK),
    ENUM(HS_STYLE_MAX),
    END_ENUM
};


// BRUSHOBJ.flColorType
FLAGDEF afdBRUSHOBJ_flColorType[] = {
    FLAG(BR_DEVICE_ICM),
    FLAG(BR_HOST_ICM),
    FLAG(BR_CMYKCOLOR),
    FLAG(BR_ORIGCOLOR),
    END_FLAG
};


// CLIPOBJ.iDComplexity
ENUMDEF aedCLIPOBJ_iDComplexity[] = {
    ENUM(DC_TRIVIAL),
    ENUM(DC_RECT),
    ENUM(DC_COMPLEX),
    END_ENUM
};

// CLIPOBJ.iFComplexity
ENUMDEF aedCLIPOBJ_iFComplexity[] = {
    ENUM(FC_RECT),
    ENUM(FC_RECT4),
    ENUM(FC_COMPLEX),
    END_ENUM
};

// CLIPOBJ.iMode
ENUMDEF aedCLIPOBJ_iMode[] = {
    ENUM(TC_RECTANGLES),
    ENUM(TC_PATHOBJ),
    END_ENUM
};

// CLIPOBJ.fjOptions
FLAGDEF afdCLIPOBJ_fjOptions[] = {
    FLAG(OC_BANK_CLIP),
    END_FLAG
};


// DC.fs_
FLAGDEF afdDC_fs_[] = {
    FLAG(DC_DISPLAY),
    FLAG(DC_DIRECT),
    FLAG(DC_CANCELED),
    FLAG(DC_PERMANANT),
    FLAG(DC_DIRTY_RAO),
    FLAG(DC_ACCUM_WMGR),
    FLAG(DC_ACCUM_APP),
    FLAG(DC_RESET),
    FLAG(DC_SYNCHRONIZEACCESS),
    FLAG(DC_EPSPRINTINGESCAPE),
    FLAG(DC_TEMPINFODC),
    FLAG(DC_FULLSCREEN),
    FLAG(DC_IN_CLONEPDEV),
    FLAG(DC_REDIRECTION),
    FLAG(DC_SHAREACCESS),
    FLAG(DC_STOCKBITMAP),
    END_FLAG
};

// DC.flGraphicsCaps_
// DEVINFO.flGraphicsCaps
FLAGDEF afdDC_flGraphicsCaps_[] = {
    FLAG(GCAPS_BEZIERS),
    FLAG(GCAPS_GEOMETRICWIDE),
    FLAG(GCAPS_ALTERNATEFILL),
    FLAG(GCAPS_WINDINGFILL),
    FLAG(GCAPS_HALFTONE),
    FLAG(GCAPS_COLOR_DITHER),
    {"GCAPS_HORIZSTRIKE (obsolete)", GCAPS_HORIZSTRIKE },
    {"GCAPS_VERTSTRIKE (obsolete)", GCAPS_VERTSTRIKE },
    FLAG(GCAPS_OPAQUERECT),
    FLAG(GCAPS_VECTORFONT),
    FLAG(GCAPS_MONO_DITHER),
    {"GCAPS_ASYNCCHANGE (obsolete)", GCAPS_ASYNCCHANGE },
    FLAG(GCAPS_ASYNCMOVE),
    FLAG(GCAPS_DONTJOURNAL),
    {"GCAPS_DIRECTDRAW (obsolete)", GCAPS_DIRECTDRAW },
    FLAG(GCAPS_ARBRUSHOPAQUE),
    FLAG(GCAPS_PANNING),
    FLAG(GCAPS_HIGHRESTEXT),
    FLAG(GCAPS_PALMANAGED),
    FLAG(GCAPS_DITHERONREALIZE),
    {"GCAPS_NO64BITMEMACCESS (obsolete)", GCAPS_NO64BITMEMACCESS },
    FLAG(GCAPS_FORCEDITHER),
    FLAG(GCAPS_GRAY16),
    FLAG(GCAPS_ICM),
    FLAG(GCAPS_CMYKCOLOR),
    FLAG(GCAPS_LAYERED),
    FLAG(GCAPS_ARBRUSHTEXT),
    FLAG(GCAPS_SCREENPRECISION),
    FLAG(GCAPS_FONT_RASTERIZER),
    FLAG(GCAPS_NUP),
    END_FLAG
};

// DC.flGraphicsCaps2_
// DEVINFO.flGraphicsCaps2
FLAGDEF afdDC_flGraphicsCaps2_[] = {
    FLAG(GCAPS2_JPEGSRC),
    FLAG(GCAPS2_xxxx),
    FLAG(GCAPS2_PNGSRC),
    FLAG(GCAPS2_CHANGEGAMMARAMP),
    FLAG(GCAPS2_ALPHACURSOR),
    FLAG(GCAPS2_SYNCFLUSH),
    FLAG(GCAPS2_SYNCTIMER),
    FLAG(GCAPS2_ICD_MULTIMON),
    FLAG(GCAPS2_MOUSETRAILS),
    END_FLAG
};


// DEVMODEx.dmFields
FLAGDEF afdDEVMODE_dmFields[] = {
    FLAG(DM_ORIENTATION),
    FLAG(DM_PAPERSIZE),
    FLAG(DM_PAPERLENGTH),
    FLAG(DM_PAPERWIDTH),
    FLAG(DM_SCALE),
    FLAG(DM_POSITION),
    FLAG(DM_NUP),
    FLAG(DM_DISPLAYORIENTATION),
    FLAG(DM_COPIES),
    FLAG(DM_DEFAULTSOURCE),
    FLAG(DM_PRINTQUALITY),
    FLAG(DM_COLOR),
    FLAG(DM_DUPLEX),
    FLAG(DM_YRESOLUTION),
    FLAG(DM_TTOPTION),
    FLAG(DM_COLLATE),
    FLAG(DM_FORMNAME),
    FLAG(DM_LOGPIXELS),
    FLAG(DM_BITSPERPEL),
    FLAG(DM_PELSWIDTH),
    FLAG(DM_PELSHEIGHT),
    FLAG(DM_DISPLAYFLAGS),
    FLAG(DM_DISPLAYFREQUENCY),
    FLAG(DM_ICMMETHOD),
    FLAG(DM_ICMINTENT),
    FLAG(DM_MEDIATYPE),
    FLAG(DM_DITHERTYPE),
    FLAG(DM_PANNINGWIDTH),
    FLAG(DM_PANNINGHEIGHT),
    FLAG(DM_DISPLAYFIXEDOUTPUT),

    END_FLAG
};

// DEVMODEx.dmPaperSize
ENUMDEF aedDEVMODE_dmPaperSize[] = {
    { "Unspecified", 0},
    ENUM(DMPAPER_LETTER),
    ENUM(DMPAPER_LETTERSMALL),
    ENUM(DMPAPER_TABLOID),
    ENUM(DMPAPER_LEDGER),
    ENUM(DMPAPER_LEGAL),
    ENUM(DMPAPER_STATEMENT),
    ENUM(DMPAPER_EXECUTIVE),
    ENUM(DMPAPER_A3),
    ENUM(DMPAPER_A4),
    ENUM(DMPAPER_A4SMALL),
    ENUM(DMPAPER_A5),
    ENUM(DMPAPER_B4),
    ENUM(DMPAPER_B5),
    ENUM(DMPAPER_FOLIO),
    ENUM(DMPAPER_QUARTO),
    ENUM(DMPAPER_10X14),
    ENUM(DMPAPER_11X17),
    ENUM(DMPAPER_NOTE),
    ENUM(DMPAPER_ENV_9),
    ENUM(DMPAPER_ENV_10),
    ENUM(DMPAPER_ENV_11),
    ENUM(DMPAPER_ENV_12),
    ENUM(DMPAPER_ENV_14),
    ENUM(DMPAPER_CSHEET),
    ENUM(DMPAPER_DSHEET),
    ENUM(DMPAPER_ESHEET),
    ENUM(DMPAPER_ENV_DL),
    ENUM(DMPAPER_ENV_C5),
    ENUM(DMPAPER_ENV_C3),
    ENUM(DMPAPER_ENV_C4),
    ENUM(DMPAPER_ENV_C6),
    ENUM(DMPAPER_ENV_C65),
    ENUM(DMPAPER_ENV_B4),
    ENUM(DMPAPER_ENV_B5),
    ENUM(DMPAPER_ENV_B6),
    ENUM(DMPAPER_ENV_ITALY),
    ENUM(DMPAPER_ENV_MONARCH),
    ENUM(DMPAPER_ENV_PERSONAL),
    ENUM(DMPAPER_FANFOLD_US),
    ENUM(DMPAPER_FANFOLD_STD_GERMAN),
    ENUM(DMPAPER_FANFOLD_LGL_GERMAN),
    ENUM(DMPAPER_ISO_B4),
    ENUM(DMPAPER_JAPANESE_POSTCARD),
    ENUM(DMPAPER_9X11),
    ENUM(DMPAPER_10X11),
    ENUM(DMPAPER_15X11),
    ENUM(DMPAPER_ENV_INVITE),
    ENUM(DMPAPER_RESERVED_48),
    ENUM(DMPAPER_RESERVED_49),
    ENUM(DMPAPER_LETTER_EXTRA),
    ENUM(DMPAPER_LEGAL_EXTRA),
    ENUM(DMPAPER_TABLOID_EXTRA),
    ENUM(DMPAPER_A4_EXTRA),
    ENUM(DMPAPER_LETTER_TRANSVERSE),
    ENUM(DMPAPER_A4_TRANSVERSE),
    ENUM(DMPAPER_LETTER_EXTRA_TRANSVERSE),
    ENUM(DMPAPER_A_PLUS),
    ENUM(DMPAPER_B_PLUS),
    ENUM(DMPAPER_LETTER_PLUS),
    ENUM(DMPAPER_A4_PLUS),
    ENUM(DMPAPER_A5_TRANSVERSE),
    ENUM(DMPAPER_B5_TRANSVERSE),
    ENUM(DMPAPER_A3_EXTRA),
    ENUM(DMPAPER_A5_EXTRA),
    ENUM(DMPAPER_B5_EXTRA),
    ENUM(DMPAPER_A2),
    ENUM(DMPAPER_A3_TRANSVERSE),
    ENUM(DMPAPER_A3_EXTRA_TRANSVERSE),
    ENUM(DMPAPER_DBL_JAPANESE_POSTCARD),
    ENUM(DMPAPER_A6),
    ENUM(DMPAPER_JENV_KAKU2),
    ENUM(DMPAPER_JENV_KAKU3),
    ENUM(DMPAPER_JENV_CHOU3),
    ENUM(DMPAPER_JENV_CHOU4),
    ENUM(DMPAPER_LETTER_ROTATED),
    ENUM(DMPAPER_A3_ROTATED),
    ENUM(DMPAPER_A4_ROTATED),
    ENUM(DMPAPER_A5_ROTATED),
    ENUM(DMPAPER_B4_JIS_ROTATED),
    ENUM(DMPAPER_B5_JIS_ROTATED),
    ENUM(DMPAPER_JAPANESE_POSTCARD_ROTATED),
    ENUM(DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED),
    ENUM(DMPAPER_A6_ROTATED),
    ENUM(DMPAPER_JENV_KAKU2_ROTATED),
    ENUM(DMPAPER_JENV_KAKU3_ROTATED),
    ENUM(DMPAPER_JENV_CHOU3_ROTATED),
    ENUM(DMPAPER_JENV_CHOU4_ROTATED),
    ENUM(DMPAPER_B6_JIS),
    ENUM(DMPAPER_B6_JIS_ROTATED),
    ENUM(DMPAPER_12X11),
    ENUM(DMPAPER_JENV_YOU4),
    ENUM(DMPAPER_JENV_YOU4_ROTATED),
    ENUM(DMPAPER_P16K),
    ENUM(DMPAPER_P32K),
    ENUM(DMPAPER_P32KBIG),
    ENUM(DMPAPER_PENV_1),
    ENUM(DMPAPER_PENV_2),
    ENUM(DMPAPER_PENV_3),
    ENUM(DMPAPER_PENV_4),
    ENUM(DMPAPER_PENV_5),
    ENUM(DMPAPER_PENV_6),
    ENUM(DMPAPER_PENV_7),
    ENUM(DMPAPER_PENV_8),
    ENUM(DMPAPER_PENV_9),
    ENUM(DMPAPER_PENV_10),
    ENUM(DMPAPER_P16K_ROTATED),
    ENUM(DMPAPER_P32K_ROTATED),
    ENUM(DMPAPER_P32KBIG_ROTATED),
    ENUM(DMPAPER_PENV_1_ROTATED),
    ENUM(DMPAPER_PENV_2_ROTATED),
    ENUM(DMPAPER_PENV_3_ROTATED),
    ENUM(DMPAPER_PENV_4_ROTATED),
    ENUM(DMPAPER_PENV_5_ROTATED),
    ENUM(DMPAPER_PENV_6_ROTATED),
    ENUM(DMPAPER_PENV_7_ROTATED),
    ENUM(DMPAPER_PENV_8_ROTATED),
    ENUM(DMPAPER_PENV_9_ROTATED),
    ENUM(DMPAPER_PENV_10_ROTATED),

    ENUM(DMPAPER_USER),

    END_ENUM
};

// DEVMODEx.dmDisplayOrientation
ENUMDEF aedDEVMODE_dmDisplayOrientation[] = {
    ENUM(DMDO_DEFAULT),
    ENUM(DMDO_90),
    ENUM(DMDO_180),
    ENUM(DMDO_270),

    END_ENUM
};

// DEVMODEx.dmDisplayFixedOutput
ENUMDEF aedDEVMODE_dmDisplayFixedOutput[] = {
    ENUM(DMDFO_DEFAULT),
    ENUM(DMDFO_STRETCH),
    ENUM(DMDFO_CENTER),

    END_ENUM
};

// DEVMODEx.dmDisplayFlags
FLAGDEF afdDEVMODE_dmDisplayFlags[] = {
    { "DM_GRAYSCALE (obsolete)", 0x00000001 },
    { "DM_INTERLACED (obsolete)", 0x00000002 },
    FLAG(DMDISPLAYFLAGS_TEXTMODE),

    END_FLAG
};

// DEVMODEx.dmICMMethod
ENUMDEF aedDEVMODE_dmICMMethod[] = {
    { "Unspecified", 0},
    ENUM(DMICMMETHOD_NONE),
    ENUM(DMICMMETHOD_SYSTEM),
    ENUM(DMICMMETHOD_DRIVER),
    ENUM(DMICMMETHOD_DEVICE),

    ENUM(DMICMMETHOD_USER),

    END_ENUM
};

// DEVMODEx.dmICMIntent
ENUMDEF aedDEVMODE_dmICMIntent[] = {
    { "Unspecified", 0},
    ENUM(DMICM_SATURATE),
    ENUM(DMICM_CONTRAST),
    ENUM(DMICM_COLORIMETRIC),
    ENUM(DMICM_ABS_COLORIMETRIC),

    ENUM(DMICM_USER),

    END_ENUM
};

// DEVMODEx.dmMediaType
ENUMDEF aedDEVMODE_dmMediaType[] = {
    { "Unspecified", 0},
    ENUM(DMMEDIA_STANDARD),
    ENUM(DMMEDIA_TRANSPARENCY),
    ENUM(DMMEDIA_GLOSSY),

    ENUM(DMMEDIA_USER),

    END_ENUM
};

// DEVMOCEx.dmDitherType
ENUMDEF aedDEVMODE_dmDitherType[] = {
    { "Unspecified", 0},
    ENUM(DMDITHER_NONE),
    ENUM(DMDITHER_COARSE),
    ENUM(DMDITHER_FINE),
    ENUM(DMDITHER_LINEART),
    ENUM(DMDITHER_ERRORDIFFUSION),
    ENUM(DMDITHER_RESERVED6),
    ENUM(DMDITHER_RESERVED7),
    ENUM(DMDITHER_RESERVED8),
    ENUM(DMDITHER_RESERVED9),
    ENUM(DMDITHER_GRAYSCALE),

    ENUM(DMDITHER_USER),

    END_ENUM
};


// GDIINFO.flRaster
FLAGDEF afdGDIINFO_flRaster[] = {
    FLAG(RC_NONE),
    FLAG(RC_BITBLT),
    FLAG(RC_BANDING),
    FLAG(RC_SCALING),
    FLAG(RC_BITMAP64),
    FLAG(RC_GDI20_OUTPUT),
    FLAG(RC_GDI20_STATE),
    FLAG(RC_SAVEBITMAP),
    FLAG(RC_DI_BITMAP),
    FLAG(RC_PALETTE),
    FLAG(RC_DIBTODEV),
    FLAG(RC_BIGFONT),
    FLAG(RC_STRETCHBLT),
    FLAG(RC_FLOODFILL),
    FLAG(RC_STRETCHDIB),
    FLAG(RC_OP_DX_OUTPUT),
    FLAG(RC_DEVBITS),
    END_FLAG
};


// GRAPHICS_DEVICE.stateFlags
FLAGDEF afdGRAPHICS_DEVICE_stateFlags[] = {
    FLAG(DISPLAY_DEVICE_ATTACHED_TO_DESKTOP),
    FLAG(DISPLAY_DEVICE_MULTI_DRIVER),
    FLAG(DISPLAY_DEVICE_PRIMARY_DEVICE),
    FLAG(DISPLAY_DEVICE_MIRRORING_DRIVER),
    FLAG(DISPLAY_DEVICE_VGA_COMPATIBLE),
    FLAG(DISPLAY_DEVICE_REMOVABLE),
    FLAG(DISPLAY_DEVICE_MODESPRUNED),
    FLAG(DISPLAY_DEVICE_POWERED_OFF),
    FLAG(DISPLAY_DEVICE_ACPI),
    FLAG(DISPLAY_DEVICE_DUALVIEW),
    FLAG(DISPLAY_DEVICE_REMOTE),
    FLAG(DISPLAY_DEVICE_DISCONNECT),
    END_FLAG
};


// ENTRY FullType (Shifted Portion of ENTRY.FullUnique)
ENUMDEF aedENTRY_FullType[] = {
    ENUM(LO_BRUSH_TYPE),
    ENUM(LO_DC_TYPE),
    ENUM(LO_BITMAP_TYPE),
    ENUM(LO_PALETTE_TYPE),
    ENUM(LO_FONT_TYPE),
    ENUM(LO_REGION_TYPE),
    ENUM(LO_ICMLCS_TYPE),
    ENUM(LO_CLIENTOBJ_TYPE),

    ENUM(LO_ALTDC_TYPE),
    ENUM(LO_PEN_TYPE),
    ENUM(LO_EXTPEN_TYPE),
    ENUM(LO_DIBSECTION_TYPE),
    ENUM(LO_METAFILE16_TYPE),
    ENUM(LO_METAFILE_TYPE),
    ENUM(LO_METADC16_TYPE),

    END_ENUM
};

// ENTRY.Objt
ENUMDEF aedENTRY_Objt[] = {
    ENUM(DEF_TYPE),
    ENUM(DC_TYPE),
    ENUM(UNUSED1_TYPE),
    ENUM(UNUSED2_TYPE),
    ENUM(RGN_TYPE),
    ENUM(SURF_TYPE),
    ENUM(CLIENTOBJ_TYPE),
    ENUM(PATH_TYPE),
    ENUM(PAL_TYPE),
    ENUM(ICMLCS_TYPE),
    ENUM(LFONT_TYPE),
    ENUM(RFONT_TYPE),
    ENUM(PFE_TYPE),
    ENUM(PFT_TYPE),
    ENUM(ICMCXF_TYPE),
    ENUM(SPRITE_TYPE),
    ENUM(BRUSH_TYPE),
    ENUM(UMPD_TYPE),
    ENUM(UNUSED4_TYPE),
    ENUM(SPACE_TYPE),
    ENUM(UNUSED5_TYPE),
    ENUM(META_TYPE),
    ENUM(EFSTATE_TYPE),
    ENUM(BMFD_TYPE),
    ENUM(VTFD_TYPE),
    ENUM(TTFD_TYPE),
    ENUM(RC_TYPE),
    ENUM(TEMP_TYPE),
    ENUM(DRVOBJ_TYPE),
    ENUM(DCIOBJ_TYPE),
    ENUM(SPOOL_TYPE),
    END_ENUM
};

// ENTRY.Flags
FLAGDEF afdENTRY_Flags[] = {
    FLAG(HMGR_ENTRY_UNDELETABLE),
    FLAG(HMGR_ENTRY_LAZY_DEL),
    FLAG(HMGR_ENTRY_INVALID_VIS),
    FLAG(HMGR_ENTRY_LOOKASIDE_ALLOC),
    END_FLAG
};


// LINEATTRS.fl
FLAGDEF afdLINEATTRS_fl[] = {
    FLAG(LA_GEOMETRIC),
    FLAG(LA_ALTERNATE),
    FLAG(LA_STARTGAP),
    FLAG(LA_STYLED),
    END_FLAG
};

// LINEATTRS.iJoin
ENUMDEF aedLINEATTRS_iJoin[] = {
    ENUM(JOIN_ROUND),
    ENUM(JOIN_BEVEL),
    ENUM(JOIN_MITER),
    END_ENUM
};

// LINEATTRS.iEndCap
ENUMDEF aedLINEATTRS_iEndCap[] = {
    ENUM(ENDCAP_ROUND),
    ENUM(ENDCAP_SQUARE),
    ENUM(ENDCAP_BUTT),
    END_ENUM
};


// MATRIX.flAccel
FLAGDEF afdMATRIX_flAccel[] = {
    FLAG(XFORM_SCALE),
    FLAG(XFORM_UNITY),
    FLAG(XFORM_Y_NEG),
    FLAG(XFORM_FORMAT_LTOFX),
    FLAG(XFORM_FORMAT_FXTOL),
    FLAG(XFORM_FORMAT_LTOL),
    FLAG(XFORM_NO_TRANSLATION),
    END_FLAG
};


// PALETTE.flPal
FLAGDEF afdPALETTE_flPal[] = {
    FLAG(PAL_INDEXED),
    FLAG(PAL_BITFIELDS),
    FLAG(PAL_RGB),
    FLAG(PAL_BGR),
    FLAG(PAL_CMYK),
    FLAG(PAL_DC),
    FLAG(PAL_FIXED),
    FLAG(PAL_FREE),
    FLAG(PAL_MANAGED),
    FLAG(PAL_NOSTATIC),
    FLAG(PAL_MONOCHROME),
    FLAG(PAL_BRUSHHACK),
    FLAG(PAL_DIBSECTION),
    FLAG(PAL_NOSTATIC256),
    FLAG(PAL_HT),
    FLAG(PAL_RGB16_555),
    FLAG(PAL_RGB16_565),
    FLAG(PAL_GAMMACORRECT),
    END_FLAG
};


// PATH.flags
FLAGDEF afdPATH_flags[] = {
    FLAG(PD_BEGINSUBPATH),
    FLAG(PD_ENDSUBPATH),
    FLAG(PD_RESETSTYLE),
    FLAG(PD_CLOSEFIGURE),
    FLAG(PD_BEZIERS),
    FLAG(PATH_JOURNAL),
    END_FLAG
};

// PATH.flType
FLAGDEF afdPATH_flType[] = {
    FLAG(PATHTYPE_KEEPMEM),
    FLAG(PATHTYPE_STACK),
    END_FLAG
};


// PATHOBJ.fl
// PATH.fl
FLAGDEF afdPATHOBJ_fl[] = {
    FLAG(PO_BEZIERS),
    FLAG(PO_ELLIPSE),
    FLAG(PO_ALL_INTEGERS),
    FLAG(PO_ENUM_AS_INTEGERS),
    END_FLAG
};


// PDEV.fl
FLAGDEF afdPDEV_fl[] = {
    FLAG(PDEV_DISPLAY),
    FLAG(PDEV_HARDWARE_POINTER),
    FLAG(PDEV_SOFTWARE_POINTER),
    FLAG(PDEV_xxx1),
    FLAG(PDEV_xxx2),
    FLAG(PDEV_xxx3),
    FLAG(PDEV_GOTFONTS),
    FLAG(PDEV_PRINTER),
    FLAG(PDEV_ALLOCATEDBRUSHES),
    FLAG(PDEV_HTPAL_IS_DEVPAL),
    FLAG(PDEV_DISABLED),
    FLAG(PDEV_SYNCHRONIZE_ENABLED),
    FLAG(PDEV_xxx4),
    FLAG(PDEV_FONTDRIVER),
    FLAG(PDEV_GAMMARAMP_TABLE),
    FLAG(PDEV_UMPD),
    FLAG(PDEV_SHARED_DEVLOCK),
    FLAG(PDEV_META_DEVICE),
    FLAG(PDEV_DRIVER_PUNTED_CALL),
    FLAG(PDEV_CLONE_DEVICE),
    FLAG(PDEV_MOUSE_TRAILS),
    FLAG(PDEV_SYNCHRONOUS_POINTER),
    END_FLAG
};

// PDEV.flAccelerated
FLAGDEF afdPDEV_flAccelerated[] = {
    FLAG(ACCELERATED_CONSTANT_ALPHA),
    FLAG(ACCELERATED_PIXEL_ALPHA),
    FLAG(ACCELERATED_TRANSPARENT_BLT),
    END_FLAG
};

// PDEV.dwDriverCapableOverride
FLAGDEF afdPDEV_dwDriverCapableOverride[] = {
    FLAG(DRIVER_CAPABLE_ALL),
    FLAG(DRIVER_NOT_CAPABLE_GDI),
    FLAG(DRIVER_NOT_CAPABLE_DDRAW),
    FLAG(DRIVER_NOT_CAPABLE_D3D),
    FLAG(DRIVER_NOT_CAPABLE_OPENGL),
    END_FLAG
};


// SPRITE.fl
FLAGDEF afdSPRITE_fl[] = {
    FLAG(SPRITE_FLAG_CLIPPING_OBSCURED),
    FLAG(SPRITE_FLAG_JUST_TRANSFERRED),
    FLAG(SPRITE_FLAG_NO_WINDOW),
    FLAG(SPRITE_FLAG_EFFECTIVELY_OPAQUE),
    FLAG(SPRITE_FLAG_HIDDEN),
    FLAG(SPRITE_FLAG_VISIBLE),
    END_FLAG
};

// SPRITE.dwShape
// _SpriteCachedAttributes.dwShape
FLAGDEF afdSPRITE_dwShape[] = {
    FLAG(ULW_COLORKEY),
    FLAG(ULW_ALPHA),
    FLAG(ULW_OPAQUE),

    // Private flags
    //FLAG(ULW_NOREPAINT),
    //FLAG(ULW_DEFAULT_ATTRIBUTES),
    //FLAG(ULW_NEW_ATTRIBUTES),
    FLAG(ULW_CURSOR),
    FLAG(ULW_DRAGRECT),
    END_FLAG
};


// SURFACE.SURFOBJ.iType
ENUMDEF aedSTYPE[] = {
    ENUM(STYPE_BITMAP),
    ENUM(STYPE_DEVICE),
    ENUM(STYPE_DEVBITMAP),
    END_ENUM
};

// SURFACE.SURFOBJ.fjBitmap
FLAGDEF afdSURFOBJ_fjBitmap[] = {
    FLAG(BMF_TOPDOWN),
    FLAG(BMF_NOZEROINIT),
    FLAG(BMF_DONTCACHE),
    FLAG(BMF_USERMEM),
    FLAG(BMF_KMSECTION),
    FLAG(BMF_NOTSYSMEM),
    FLAG(BMF_WINDOW_BLT),
    FLAG(BMF_UMPDMEM),
    {"BMF_SPRITE (obsolete)", 0x0100},
    FLAG(BMF_ISREADONLY),
    FLAG(BMF_MAKEREADWRITE),
    END_FLAG
};

// SURFACE.SURFOBJ.iBitmapFormat
// BLTINFO.iFormatSrc
// BLTINFO.iFormatDst
// DEVINFO.iDitherFormat
// EBRUSHOBJ._iMetaFormat
ENUMDEF aedBMF[] = {
    ENUM(BMF_1BPP),
    ENUM(BMF_4BPP),
    ENUM(BMF_8BPP),
    ENUM(BMF_16BPP),
    ENUM(BMF_24BPP),
    ENUM(BMF_32BPP),
    ENUM(BMF_4RLE),
    ENUM(BMF_8RLE),
    ENUM(BMF_JPEG),
    ENUM(BMF_PNG),
    END_ENUM
};

// SURFACE.SurfFlags
FLAGDEF afdSURFACE_SurfFlags[] = {
    FLAG(HOOK_BITBLT),
    FLAG(HOOK_STRETCHBLT),
    FLAG(HOOK_PLGBLT),
    FLAG(HOOK_TEXTOUT),
    { "HOOK_PAINT (obsolete)", HOOK_PAINT },
    FLAG(HOOK_STROKEPATH),
    FLAG(HOOK_FILLPATH),
    FLAG(HOOK_STROKEANDFILLPATH),
    FLAG(HOOK_LINETO),
//    FLAG(SHAREACCESS_SURFACE),
    FLAG(HOOK_COPYBITS),
//    { "HOOK_MOVEPANNING (obsolete)", HOOK_MOVEPANNING },
    FLAG(HOOK_SYNCHRONIZE),
    FLAG(HOOK_STRETCHBLTROP),
//    { "HOOK_SYNCHRONIZEACCESS (obsolete)", HOOK_SYNCHRONIZEACCESS },
    FLAG(HOOK_TRANSPARENTBLT),
    FLAG(HOOK_ALPHABLEND),
    FLAG(HOOK_GRADIENTFILL),

    FLAG(USE_DEVLOCK_SURFACE),

    FLAG(PDEV_SURFACE),
    FLAG(ABORT_SURFACE),
    FLAG(DYNAMIC_MODE_PALETTE),
    FLAG(UNREADABLE_SURFACE),
    FLAG(PALETTE_SELECT_SET),
    FLAG(API_BITMAP),
    FLAG(BANDING_SURFACE),
    FLAG(INCLUDE_SPRITES_SURFACE),
    FLAG(LAZY_DELETE_SURFACE),
    FLAG(DDB_SURFACE),
    FLAG(ENG_CREATE_DEVICE_SURFACE),
    FLAG(DRIVER_CREATED_SURFACE),
    FLAG(DIRECTDRAW_SURFACE),
    FLAG(MIRROR_SURFACE),
    FLAG(UMPD_SURFACE),

    FLAG(REDIRECTION_SURFACE),
    FLAG(SHAREACCESS_SURFACE),

    END_FLAG
};


// XLATEOBJ.flXlate
FLAGDEF afdXLATEOBJ_flXlate[] = {
    FLAG(XO_TRIVIAL),
    FLAG(XO_TABLE),
    FLAG(XO_TO_MONO),
    FLAG(XO_FROM_CMYK),
    FLAG(XO_DEVICE_ICM),
    FLAG(XO_HOST_ICM),
    END_FLAG
};


// XLATE.lCachIndex
ENUMDEF aedXLATE_lCacheIndex[] = {
    ENUM(XLATE_CACHE_INVALID),
    ENUM(XLATE_CACHE_JOURNAL),
    END_ENUM
};

// XLATE.flPrivate
FLAGDEF afdXLATE_flPrivate[] = {
    FLAG(XLATE_FROM_MONO),
    FLAG(XLATE_RGB_SRC),
    FLAG(XLATE_RGB_BOTH),
    FLAG(XLATE_PAL_MANAGED),
    FLAG(XLATE_USE_CURRENT),
    FLAG(XLATE_USE_SURFACE_PAL),
    FLAG(XLATE_USE_FOREGROUND),
    END_FLAG
};


extern EnumFlagEntry efe_PATHOBJ;
extern EnumFlagEntry efeXCLIPOBJ;


EnumFlagField aeff_BASEOBJECT[] = {
    { "hHmgr",      CALL_FUNC,  OutputHandleInfo        },
    { "BaseFlags",  FLAG_FIELD, afdBASEOBJECT_BaseFlags },
};
EnumFlagEntry efe_BASEOBJECT = EFTypeEntry(_BASEOBJECT);

EnumFlagField aeff_BLENDFUNCTION[] = {
    { "BlendOp",        ENUM_FIELD, aed_BLENDFUNCTION_BlendOp       },
    { "BlendFlags",     FLAG_FIELD, afd_BLENDFUNCTION_BlendFlags    },
    { "AlphaFormat",    FLAG_FIELD, afd_BLENDFUNCTION_AlphaFormat   },
};

EnumFlagField aeffBLTINFO[] = {
    { "iFormatSrc", ENUM_FIELD, aedBMF  },
    { "iFormatDst", ENUM_FIELD, aedBMF  },
};

EnumFlagField aeffBRUSH[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "_ulStyle",       ENUM_FIELD,     aedBRUSH__ulStyle   },
    { "_flAttrs",       FLAG_FIELD,     afdBRUSH__flAttrs   },
};

EnumFlagField aeff_BRUSHOBJ[] = {
    { "flColorType",    FLAG_FIELD, afdBRUSHOBJ_flColorType },
};
EnumFlagEntry efe_BRUSHOBJ = EFTypeEntry(_BRUSHOBJ);

EnumFlagField aeff_CLIPOBJ[] = {
    { "iDComplexity",   ENUM_FIELD, aedCLIPOBJ_iDComplexity },
    { "iFComplexity",   ENUM_FIELD, aedCLIPOBJ_iFComplexity },
    { "iMode",          ENUM_FIELD, aedCLIPOBJ_iMode        },
    { "fjOptions",      FLAG_FIELD, afdCLIPOBJ_fjOptions    },
};
EnumFlagEntry efe_CLIPOBJ = EFTypeEntry(_CLIPOBJ);

EnumFlagField aeffDC[] = {
    { "_BASEOBJECT",        PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "fs_",                FLAG_FIELD,     afdDC_fs_               },
    { "flGraphicsCaps_",    FLAG_FIELD,     afdDC_flGraphicsCaps_   },
    { "flGraphicsCaps2_",   FLAG_FIELD,     afdDC_flGraphicsCaps2_  },
};

EnumFlagField aeff_devicemodeA[] = {
    { "dmFields",               FLAG_FIELD, afdDEVMODE_dmFields             },
    { "dmPaperSize",            ENUM_FIELD, aedDEVMODE_dmPaperSize          },
    { "dmDisplayOrientation",   ENUM_FIELD, aedDEVMODE_dmDisplayOrientation },
    { "dmDisplayFixedOutput",   ENUM_FIELD, aedDEVMODE_dmDisplayFixedOutput },
    { "dmDisplayFlags",         FLAG_FIELD, afdDEVMODE_dmDisplayFlags       },
    { "dmICMMethod",            ENUM_FIELD, aedDEVMODE_dmICMMethod          },
    { "dmICMIntent",            ENUM_FIELD, aedDEVMODE_dmICMIntent          },
    { "dmMediaType",            ENUM_FIELD, aedDEVMODE_dmMediaType          },
    { "dmDitherType",           ENUM_FIELD, aedDEVMODE_dmDitherType         },
};

EnumFlagField aeff_devicemodeW[] = {
    { "dmFields",               FLAG_FIELD, afdDEVMODE_dmFields             },
    { "dmPaperSize",            ENUM_FIELD, aedDEVMODE_dmPaperSize          },
    { "dmDisplayOrientation",   ENUM_FIELD, aedDEVMODE_dmDisplayOrientation },
    { "dmDisplayFixedOutput",   ENUM_FIELD, aedDEVMODE_dmDisplayFixedOutput },
    { "dmDisplayFlags",         FLAG_FIELD, afdDEVMODE_dmDisplayFlags       },
    { "dmICMMethod",            ENUM_FIELD, aedDEVMODE_dmICMMethod          },
    { "dmICMIntent",            ENUM_FIELD, aedDEVMODE_dmICMIntent          },
    { "dmMediaType",            ENUM_FIELD, aedDEVMODE_dmMediaType          },
    { "dmDitherType",           ENUM_FIELD, aedDEVMODE_dmDitherType         },
};

EnumFlagField aefftagDEVINFO[] = {
    { "flGraphicsCaps",     FLAG_FIELD, afdDC_flGraphicsCaps_   },
    { "iDitherFormat",      ENUM_FIELD, aedBMF                  },
    { "flGraphicsCaps2",    FLAG_FIELD, afdDC_flGraphicsCaps2_  },
};

EnumFlagField aeffEBRUSHOBJ[] = {
    { "_BRUSHOBJ",      PARENT_FIELDS,  &efe_BRUSHOBJ       },
    { "flAttrs",        FLAG_FIELD,     afdBRUSH__flAttrs   },
    { "_iMetaFormat",   ENUM_FIELD,     aedBMF              },
};

EnumFlagField aeffECLIPOBJ[] = {
    { "XCLIPOBJ",   PARENT_FIELDS, &efeXCLIPOBJ     },
};

EnumFlagField aeffEPATHOBJ[] = {
    { "_PATHOBJ",   PARENT_FIELDS, &efe_PATHOBJ     },
};

EnumFlagField aeff_ENTRY[] = {
    { "FullUnique",     CALL_FUNC,  OutputFullUniqueInfo    },
    { "Objt",           ENUM_FIELD, aedENTRY_Objt           },
    { "Flags",          FLAG_FIELD, afdENTRY_Flags          },
};

EnumFlagField aeff_FLOAT_LONG[] = {
    { "e",  CALL_FUNC, OutputFLOATL },
};

EnumFlagField aeff_GDIINFO[] = {
    { "flRaster",       FLAG_FIELD, afdGDIINFO_flRaster     },
};

EnumFlagField aefftagGRAPHICS_DEVICE[] = {
    { "stateFlags",     FLAG_FIELD, afdGRAPHICS_DEVICE_stateFlags   },
};

EnumFlagField aeff_LINEATTRS[] = {
    { "fl",             FLAG_FIELD, afdLINEATTRS_fl         },
    { "iJoin",          ENUM_FIELD, aedLINEATTRS_iJoin      },
    { "iEndCap",        ENUM_FIELD, aedLINEATTRS_iEndCap    },
};

EnumFlagField aeffMATRIX[] = {
    { "flAccel",        FLAG_FIELD, afdMATRIX_flAccel       },
};

EnumFlagField aeffPALETTE[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "flPal",          FLAG_FIELD,     afdPALETTE_flPal    },
};

EnumFlagField aeffPATH[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "flags",          FLAG_FIELD, afdPATH_flags           },
    { "flType",         FLAG_FIELD, afdPATH_flType          },
    { "fl",             FLAG_FIELD, afdPATHOBJ_fl           },
};

EnumFlagField aeff_PATHOBJ[] = {
    { "fl",             FLAG_FIELD, afdPATHOBJ_fl   },
};
EnumFlagEntry efe_PATHOBJ = EFTypeEntry(_PATHOBJ);

EnumFlagField aeffPDEV[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "fl",             FLAG_FIELD,     afdPDEV_fl              },
    { "flAccelerated",  FLAG_FIELD,     afdPDEV_flAccelerated   },
    { "dwDriverCapableOverride", FLAG_FIELD, afdPDEV_dwDriverCapableOverride},
//    { "dwDriverAccelerationLevel", CALL_FUNC, },
};

EnumFlagField aeffSPRITE[] = {
    { "fl",             FLAG_FIELD,     afdSPRITE_fl            },
    { "dwShape",        FLAG_FIELD,     afdSPRITE_dwShape       },
};

EnumFlagField aeff_SpriteCachedAttributes[] = {
    { "dwShape",        FLAG_FIELD,     afdSPRITE_dwShape       },
};

EnumFlagField aeff_SPRITESTATE[] = {
    { "flOriginalSurfFlags",    FLAG_FIELD, afdSURFACE_SurfFlags    },
    { "iOriginalType",          ENUM_FIELD, aedSTYPE                },
    { "flSpriteSurfFlags",      FLAG_FIELD, afdSURFACE_SurfFlags    },
    { "iSpriteType",            ENUM_FIELD, aedSTYPE                },
};

EnumFlagField aeff_SURFOBJ[] = {
    { "iBitmapFormat",  ENUM_FIELD, aedBMF      },
    { "iType",          ENUM_FIELD, aedSTYPE    },
    { "fjBitmap",       FLAG_FIELD, afdSURFOBJ_fjBitmap     },
};

EnumFlagField aeffSURFACE[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "SurfFlags",      FLAG_FIELD,     afdSURFACE_SurfFlags    },
};

EnumFlagField aeffXCLIPOBJ[] = {
    { "_CLIPOBJ",   PARENT_FIELDS, &efe_CLIPOBJ     },
};
EnumFlagEntry efeXCLIPOBJ = EFTypeEntry(XCLIPOBJ);

EnumFlagField aeff_XLATEOBJ[] = {
    { "flXlate",    FLAG_FIELD, afdXLATEOBJ_flXlate },
};
EnumFlagEntry efe_XLATEOBJ = EFTypeEntry(_XLATEOBJ);

EnumFlagField aeffXLATE[] = {
    { "_XLATEOBJ",      PARENT_FIELDS,     &efe_XLATEOBJ            },
    { "lCacheIndex",    ENUM_FIELD_LIMITED, aedXLATE_lCacheIndex    },
    { "flPrivate",      FLAG_FIELD,         afdXLATE_flPrivate      },
};


EnumFlagEntry EFDatabase[] = {
//    { , 0, , aeff },
    EFTypeEntry(_BASEOBJECT),
    EFTypeEntry(_BLENDFUNCTION),
    EFTypeEntry(BLTINFO),
    EFTypeEntry(BRUSH),
    EFTypeEntry(_BRUSHOBJ),
    EFTypeEntry(_CLIPOBJ),
    EFTypeEntry(DC),
    EFTypeEntry(_devicemodeA),
    EFTypeEntry(_devicemodeW),
    EFTypeEntry(tagDEVINFO),
    EFTypeEntry(EBRUSHOBJ),
    EFTypeEntry(ECLIPOBJ),
    EFTypeEntry(_ENTRY),
    EFTypeEntry(EPATHOBJ),
    EFTypeEntry(_FLOAT_LONG),
    EFTypeEntry(_GDIINFO),
    EFTypeEntry(tagGRAPHICS_DEVICE),
    EFTypeEntry(_LINEATTRS),
    EFTypeEntry(MATRIX),
    EFTypeEntry(PALETTE),
    EFTypeEntry(PATH),
    EFTypeEntry(_PATHOBJ),
    EFTypeEntry(PDEV),
    EFTypeEntry(SPRITE),
    EFTypeEntry(_SpriteCachedAttributes),
    EFTypeEntry(_SPRITESTATE),
    EFTypeEntry(SURFACE),
    EFTypeEntry(_SURFOBJ),
    EFTypeEntry(XCLIPOBJ),
    EFTypeEntry(_XLATEOBJ),
    EFTypeEntry(XLATE),
    { "", 0, 0, NULL}
};


/******************************Public*Routine******************************\
*   output standard flags
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

ULONG64
OutputFlags(
    OutputControl *OutCtl,
    FLAGDEF *pFlagDef,
    ULONG64 fl,
    BOOL SingleLine
    )
{
    ULONG64 FlagsFound = 0;

    if (fl == 0)
    {
        while (pFlagDef->psz != NULL)
        {
            if (pFlagDef->fl == 0)
            {
                if (!SingleLine) OutCtl->Output("\n       ");
                OutCtl->Output("%s",pFlagDef->psz);
            }

            pFlagDef++;
        }
    }
    else
    {
        while (pFlagDef->psz != NULL)
        {
            if (pFlagDef->fl & fl)
            {
                if (!SingleLine)
                {
                    OutCtl->Output("\n       ");
                }
                else if (FlagsFound)
                {
                    OutCtl->Output(" | ");
                }

                OutCtl->Output("%s",pFlagDef->psz);

                if (FlagsFound & pFlagDef->fl)
                {
                    OutCtl->Output(" (SHARED FLAG)");
                }
                FlagsFound |= pFlagDef->fl;
            }

            pFlagDef++;
        }
    }

    return fl & ~FlagsFound;
}


/******************************Public*Routine******************************\
*   output standard enum values
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputEnum(
    OutputControl *OutCtl,
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            OutCtl->Output(pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}

BOOL
OutputEnumWithParenthesis(
    OutputControl *OutCtl,
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            OutCtl->Output("(%s)", pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}


/******************************Public*Routine******************************\
*   Output interpretation of pszField's value if found in pEFEntry
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputFieldValue(
    OutputControl *OutCtl,
    EnumFlagEntry *pEFEntry,
    const CHAR *pszField,
    PDEBUG_VALUE Value,
    PDEBUG_CLIENT Client,
    BOOL Compact
    )
{
    EnumFlagField  *pEFField;
    DEBUG_VALUE     ConvValue;

    if (OutCtl == NULL ||
        pEFEntry == NULL ||
        pszField == NULL ||
        Value == NULL ||
        Value->Type == DEBUG_VALUE_INVALID)
    {
        return E_INVALIDARG;
    }

    for (ULONG i = 0; i < pEFEntry->FieldEntries; i++)
    {
        pEFField = &pEFEntry->FieldEntry[i];

        if (pEFField->EFType == PARENT_FIELDS)
        {
            if (OutputFieldValue(OutCtl, pEFField->Parent, pszField, Value, Client, Compact))
            {
                return TRUE;
            }
        }
        else if (strcmp(pszField, pEFField->FieldName) == 0)
        {
            switch (pEFField->EFType)
            {
                case FLAG_FIELD:
                {
                    ULONG64 flRem;

                    if (Value->Type != DEBUG_VALUE_INT64)
                    {
                        if (OutCtl->CoerceValue(Value, DEBUG_VALUE_INT64, &ConvValue) != S_OK)
                        {
                            return FALSE;
                        }
                        Value = &ConvValue;
                    }

                    if (Compact)
                    {
                        OutCtl->Output(" (");
                    }
                    flRem = OutputFlags(OutCtl, pEFField->FlagDef, Value->I64, Compact);
                    if (flRem && ((flRem != 0xffffffff00000000) || !(Value->I64 & 0x80000000)))
                    {
                        if (!Compact) OutCtl->Output("\n      ");
                        OutCtl->Output("  Unknown Flags: 0x%I64x", flRem);
                    }
                    if (Compact)
                    {
                        OutCtl->Output(")");
                    }
                    return TRUE;
                }

                case ENUM_FIELD:
                case ENUM_FIELD_LIMITED:
                {
                    if (Value->Type != DEBUG_VALUE_INT64)
                    {
                        if (OutCtl->CoerceValue(Value, DEBUG_VALUE_INT64, &ConvValue) != S_OK)
                        {
                            return FALSE;
                        }
                        Value = &ConvValue;
                    }

                    OutCtl->Output(" ");
                    if (!OutputEnumWithParenthesis(OutCtl, pEFField->EnumDef, Value->I64))
                    {
                        if (pEFField->EFType != ENUM_FIELD_LIMITED)
                        {
                            OutCtl->Output("(Unknown Value)", Value->I64);
                        }
                    }
                    return TRUE;
                }

                case CALL_FUNC:
                    OutCtl->Output(" ");
                    pEFField->EFFunc(OutCtl, Client, Value);
                    return TRUE;

                default:
                    OutCtl->OutErr("        Unknown database entry type.\n");
                    break;
            }
        }
    }

    return FALSE;
}


/******************************Public*Routine******************************\
*   Output interpretations of known fields as stored in EFDatabase
*       (Known flags & enum values as well some special fields.)
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputTypeFieldValue(
    OutputControl *OutCtl,
    const CHAR *pszType,
    const CHAR *pszField,
    PDEBUG_VALUE Value,
    PDEBUG_CLIENT Client,
    BOOL Compact
    )
{
    if (OutCtl == NULL ||
        Value == NULL ||
        Value->Type == DEBUG_VALUE_INVALID)
    {
        return E_INVALIDARG;
    }

    BOOL            FoundType = FALSE;
    EnumFlagEntry  *pEFEntry = EFDatabase;

    BOOL            FoundField;

    for (pEFEntry = EFDatabase;
         pEFEntry->TypeName[0] != '\0';
         pEFEntry++)
    {
        if (strcmp(pszType, pEFEntry->TypeName) == 0)
        {
            FoundType = TRUE;
            break;
        }
    }

    if (!FoundType)
    {
        // Check if this type is a clean typedef
        // (Test it against database with prefixed
        // '_'s and 'tag's removed.)
        for (pEFEntry = EFDatabase;
             pEFEntry->TypeName[0] != '\0';
             pEFEntry++)
        {
            if ((pEFEntry->TypeName[0] == '_') ?
                (strcmp(pszType, &pEFEntry->TypeName[1]) == 0) :
                (pEFEntry->TypeName[0] == 't' &&
                 pEFEntry->TypeName[1] == 'a' &&
                 pEFEntry->TypeName[2] == 'g' &&
                 strcmp(pszType, &pEFEntry->TypeName[3]) == 0))
            {
                FoundType = TRUE;
                break;
            }
        }

    }

    return (FoundType) ?
        OutputFieldValue(OutCtl, pEFEntry, pszField, Value, Client, Compact) :
        FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\input.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    input.cxx

Abstract:

    This file contains the routines to get user input.

Author:

    Jason Hartman (JasonHa) 2001-05-22

Environment:

    User Mode

--*/

#include "precomp.hxx"



HRESULT
GetYNInput(
    PDEBUG_CONTROL Control,
    PCSTR Prompt
    )
{
    HRESULT hr;
    CHAR    Response[4];
    ULONG   ResponseLen;

    Control->Output(DEBUG_OUTPUT_NORMAL, "%s yn\n", Prompt);

    do
    {
        hr = Control->Input(Response, sizeof(Response), &ResponseLen);

        if (hr == E_ABORT) break;

        if (hr == S_OK)
        {
            if (ResponseLen != 2)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                Response[0] = (CHAR)tolower(Response[0]);

                if (Response[0] != 'y' && Response[0] != 'n')
                {
                    hr = E_INVALIDARG;
                }
            }
        }

        if (hr != S_OK)
        {
            Control->Output(DEBUG_OUTPUT_WARNING, " Please answer y or n.\n");
        }
    } while (hr != S_OK);

    if (hr == S_OK && Response[0] != 'y')
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\kdexts.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    kdexts.cxx

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.hxx"


//
// globals
//
HINSTANCE               ghDllInst;
WINDBG_EXTENSION_APIS64 ExtensionApis;
BOOL                    gbVerbose = FALSE;


DBGKD_GET_VERSION64     KernelVersionPacket;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG   PageShift;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
ULONG   TargetClass;
ULONG   PlatformId = -1;
ULONG   MajorVer = 0;
ULONG   MinorVer = 0;
ULONG   SrvPack = 0;
ULONG   BuildNo = 0;
BOOL    NewPool = FALSE;
ULONG   PoolBlockShift;

BOOL    Connected = FALSE;
BOOL    Remote = FALSE;
CHAR    RemoteID[MAX_PATH];

ModuleParameters GDIKM_Module = { 0, DEBUG_ANY_ID, "win32k", "sys" };
ModuleParameters GDIUM_Module = { 0, DEBUG_ANY_ID, "gdi32", "dll" };
ModuleParameters Type_Module;

HRESULT SymbolInit(PDEBUG_CLIENT);


BOOLEAN
WINAPI
DllMain(
    HINSTANCE hInstDll,
	DWORD fdwReason,
	LPVOID lpvReserved
    )
{
    switch (fdwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            DbgPrint("DllMain: DLL_PROCESS_ATTACH: hInstance = %lx => ghDllInit(%lx)\n", hInstDll, ghDllInst);
            ghDllInst = hInstDll;
            break;
    }

    return TRUE;
}


extern "C"
HRESULT
CALLBACK
DebugExtensionSetClient(
    LPCSTR RemoteArgs
    )
{
    if (RemoteArgs != NULL)
    {
        Remote = TRUE;
        strncpy(RemoteID, RemoteArgs, sizeof(RemoteID));
    }
    else
    {
        Remote = FALSE;
    }

    return S_OK;
}


HRESULT
GetDebugClient(
    PDEBUG_CLIENT *pClient
    )
{
    HRESULT         Hr = S_FALSE;
    PDEBUG_CLIENT   Client;

    if (pClient == NULL)
    {
        return S_FALSE;
    }

    *pClient = NULL;

    if (Remote)
    {
        Hr = DebugConnect(RemoteID, __uuidof(IDebugClient), (void **)&Client);
        if (Hr == S_OK)
        {
            Hr = Client->ConnectSession(DEBUG_CONNECT_SESSION_NO_VERSION |
                                        DEBUG_CONNECT_SESSION_NO_ANNOUNCE,
                                        0);
            if (Hr != S_OK)
            {
                Client->Release();
            }
        }
    }
    else
    {
        Hr = DebugCreate(__uuidof(IDebugClient), (void **)&Client);
    }

    if (Hr == S_OK)
    {
        *pClient = Client;
    }

    return Hr;
}


void
GetLabIdFromBuildString(
    PSTR BuildString,
    PULONG pLabId
    )
{
    PCHAR pstr;

    *pLabId = 0;
    _strlwr(BuildString);
    pstr = strstr(BuildString, "lab");
    if (pstr) {
        sscanf(pstr+3, "%ld", pLabId);
    }
}



//PDEBUG_EXTENSION_INITIALIZE
extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    DbgPrint("DebugExtensionInitialize called.\n");

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    
    if ((Hr = GetDebugClient(&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        DebugClient->Release();
        return Hr;
    }

    ExtensionApis.nSize = sizeof(ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
    {
        GetRemoteWindbgExtApis(&ExtensionApis);
    }

    Hr = SetEventCallbacks(DebugClient);
    DbgPrint("EventCallbacks set for 0x%p returned %s.\n",
             DebugClient, pszHRESULT(Hr));

    ViewerInit();

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


//PDEBUG_EXTENSION_NOTIFY
extern "C"
void
CALLBACK
DebugExtensionNotify(
    ULONG Notify,
    ULONG64 Argument
    )
{
    switch (Notify) {
        case DEBUG_NOTIFY_SESSION_ACTIVE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_ACTIVE\n");
            break;
        case DEBUG_NOTIFY_SESSION_INACTIVE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_INACTIVE\n");
            break;
        case DEBUG_NOTIFY_SESSION_ACCESSIBLE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_ACCESSIBLE\n");
            break;
        case DEBUG_NOTIFY_SESSION_INACCESSIBLE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_INACCESSIBLE\n");
            break;
        default:
            DbgPrint("DebugExtensionNotify recieved unknown notification %u\n", Notify);
            break;
    }

    //
    // The first time we actually connect to a target, get the architecture
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_CONTROL DebugControl;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = GetDebugClient(&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                        for (PageShift = 0; Page >>= 1; PageShift++) ;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&TargetClass, &Qualifier)) != S_OK)
                {
                    TargetClass = DEBUG_CLASS_UNINITIALIZED;
                }

                ULONG StringUsed;
                CHAR  BuildString[100];
                if ((Hr = DebugControl->GetSystemVersion(&PlatformId, &MajorVer,
                                                         &MinorVer, NULL,
                                                         0, NULL,
                                                         &SrvPack, BuildString,
                                                         sizeof(BuildString), &StringUsed)) == S_OK)
                {
                    PCHAR pstr;
                    ULONG LabId = 0;
                    BuildNo = MinorVer;

                    _strlwr(BuildString);
                    pstr = strstr(BuildString, "lab");
                    if (pstr != NULL)
                    {
                        sscanf(pstr+3, "%ld", &LabId);
                    }

                    NewPool = ((BuildNo > 2407) || (LabId == 1 && BuildNo >= 2402));
                    PoolBlockShift = NewPool ? 
                        POOL_BLOCK_SHIFT_LAB1_2402 : POOL_BLOCK_SHIFT_OLD;
                }
                else
                {
                    PlatformId = -1;
                    MajorVer = 0;
                    MinorVer = 0;
                    SrvPack = 0;
                    BuildNo = 0;

                    NewPool = FALSE;
                    PoolBlockShift = PageShift - 8;
                }

                DebugControl->Release();
            }

            // Try to initialize symbols only if the event monitor
            // hasn't fully registered.  This indicates that the
            // extension is just being loaded as opposed to being
            // loaded at system boot and reconnect (when GDI modules
            // won't even be loaded yet).
            if (UniqueTargetState == INVALID_UNIQUE_STATE)
            {
                SymbolInit(DebugClient);
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
        PlatformId = -1;
        MajorVer = 0;
        MinorVer = 0;
        SrvPack = 0;
    }

    return;
}

//PDEBUG_EXTENSION_UNINITIALIZE
extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    DbgPrint("DebugExtensionUninitialize called.\n");

    SessionExit();
    HmgrExit();
    ViewerExit();
    BasicTypesExit();

    ReleaseEventCallbacks(NULL);

    ExtRelease(TRUE);

    return;
}



BOOLEAN
IsCheckedBuild(
    PBOOLEAN Checked
    )
{
    if (MajorVer == 0) return FALSE;

    //
    // 0xC for checked, 0xF for free.
    //
    *Checked = ((MajorVer & 0xFF) == 0xc) ;
    return TRUE;
}


HRESULT GetModuleParameters(
    PDEBUG_CLIENT Client,
    ModuleParameters *Module,
    BOOL TryReload
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);

    if (Client == NULL) return E_POINTER;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                    (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    hr = Symbols->GetModuleByModuleName(Module->Name, 0, &Module->Index, &Module->Base);

    Client->FlushCallbacks();

    if (hr != S_OK && TryReload)
    {
        CHAR ReloadArgs[MAX_PATH];

        OutCtl.OutVerb("GetModuleByModuleName returned %s.\n", pszHRESULT(hr));

        sprintf(ReloadArgs,
                (Module->Base != 0) ? "%s.%s=0x%I64x" : "%s.%s",
                Module->Name, Module->Ext, Module->Base);

        OutCtl.OutWarn("Trying %s reload.\n", ReloadArgs);

        hr = Symbols->Reload(ReloadArgs);

        Client->FlushCallbacks();

        if (hr == S_OK)
        {
            hr = Symbols->GetModuleByModuleName(Module->Name, 0, &Module->Index, &Module->Base);
            OutCtl.OutVerb("Module %s @ 0x%p; HRESULT %s\n", Module->Name, Module->Base, pszHRESULT(hr));

            Client->FlushCallbacks();
        }
        else
        {
            OutCtl.OutWarn("Reload(\"%s\") returned %s\n", ReloadArgs, pszHRESULT(hr));
        }
    }
    else
    {
        OutCtl.OutVerb("Module %s @ 0x%p.\n", Module->Name, Module->Base);
    }

    if (hr == S_OK)
    {
        hr = Symbols->GetModuleParameters(1,
                                          NULL,
                                          Module->Index,
                                          &Module->DbgModParams);

        OutCtl.OutVerb("SymbolType for %s: ", Module->Name);
        switch (Module->DbgModParams.SymbolType)
        {
            case DEBUG_SYMTYPE_NONE: OutCtl.OutVerb("NONE"); break;
            case DEBUG_SYMTYPE_COFF: OutCtl.OutVerb("COFF"); break;
            case DEBUG_SYMTYPE_CODEVIEW: OutCtl.OutVerb("CODEVIEW"); break;
            case DEBUG_SYMTYPE_PDB: OutCtl.OutVerb("PDB"); break;
            case DEBUG_SYMTYPE_EXPORT: OutCtl.OutVerb("EXPORT"); break;
            case DEBUG_SYMTYPE_DEFERRED: OutCtl.OutVerb("DEFERRED"); break;
            case DEBUG_SYMTYPE_SYM: OutCtl.OutVerb("SYM"); break;
            case DEBUG_SYMTYPE_DIA: OutCtl.OutVerb("DIA"); break;
            default:
                OutCtl.OutVerb("unknown %ld", Module->DbgModParams.SymbolType);
                break;
        }
        OutCtl.OutVerb(" (HRESULT %s)\n", pszHRESULT(hr));

        Client->FlushCallbacks();
    }

    Symbols->Release();

    return hr;
}


HRESULT
SymbolLoad(
    PDEBUG_CLIENT Client
    )
{
    HRESULT hr;
    ULONG   Class;
    ULONG   Qualifier;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        GetModuleParameters(Client, &GDIUM_Module, FALSE);

        if ((hr = GetModuleParameters(Client, &GDIKM_Module, TRUE)) == S_OK &&
            GDIKM_Module.Base != 0)
        {
            Type_Module = GDIKM_Module;
        }
    }
    else
    {
        hr = GetModuleParameters(Client, &GDIUM_Module, TRUE);
    }

    if (hr == S_OK)
    {
        gbSymbolsNotLoaded = FALSE;
    }

    if (Type_Module.Base == 0)
    {
        Type_Module = GDIUM_Module;
    }

    DbgPrint("Using %s for type module.\n", Type_Module.Name);

    return hr;
}


HRESULT SymbolInit(PDEBUG_CLIENT Client)
{
    HRESULT hr;

    GDIKM_Module.Base = 0;
    GDIUM_Module.Base = 0;
    Type_Module.Base = 0;

    hr = SymbolLoad(Client);

    BasicTypesInit(Client);
    HmgrInit(Client);
    SessionInit(Client);

    return hr;
}


HRESULT
InitAPI(PDEBUG_CLIENT Client, PCSTR ExtName)
{
    static BOOL SecondaryCall = FALSE;

    HRESULT hr;

    hr = EventCallbacksReady(Client);

    if (hr != S_OK)
    {
        OutputControl   OutCtl(Client);

        OutCtl.OutWarn(" Warning: Event callbacks have not been registered.\n");

        if (SecondaryCall)
        {
            OutCtl.OutWarn("   All extension caching is disabled.\n");
        }
        else
        {
            OutCtl.OutWarn("   If %s is the first extension used, use .load or !load in the future.\n"
                           "   Caching is disabled for this use of !%s.\n",
                           ExtName, ExtName);
        }
    }

    SecondaryCall = TRUE;

    if (gbSymbolsNotLoaded)
    {
        SymbolInit(Client);
    }

    return hr;
}


DECLARE_API(reinit)
{
    HRESULT hr;
    hr = SymbolInit(Client);
    return hr;
}


DECLARE_API(verbose)
{
    INIT_API();

    gbVerbose = !gbVerbose;
    ExtOut(" GDIKDX Verbose mode is now %s.\n", gbVerbose ? "ON" : "OFF");

    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\objects.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    objects.cxx

Abstract:

    This file contains the routines to list objects.

Author:

    Jason Hartman (JasonHa) 2001-05-12

Environment:

    User Mode

--*/

#include "precomp.hxx"


PCSTR   BaseObjectFields[] = {
    "hHmgr",
    "ulShareCount",
    "cExclusiveLock",
    "BaseFlags",
    "Tid",
    NULL
};

PCSTR   SurfaceObjectFields[] = {
    "so.hsurf",
    "so.hdev",
    "so.sizlBitmap",
    "so.cjBits",
    "so.pvBits",
    "so.iBitmapFormat",
    "so.iType",
    "so.fjBitmap",
    NULL
};

PCSTR   ExtendedSurfaceObjectFields[] = {
    "ulShareCount",
    "BaseFlags",
    "so.dhsurf",
    "SurfFlags",
    NULL
};


#if 0

HRESULT
ListObjectFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT         hr;
    DEBUG_VALUE     PoolType;
      * = ( *)Context;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)atu;

    if ( != S_OK)
    {
        return S_FALSE;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            hr = atu->Add(Tag->I32, FreePool, BlockSize);
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                Tag->I32 &= ~PROTECTED_POOL;
            }
            else if (PoolType.I32 & POOL_QUOTA_MASK)
            {
                Tag->I32 = 'CORP';
            }

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    hr = atu->Add(Tag->I32, AllocatedPool, BlockSize);
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    hr = atu->Add(Tag->I32, FreePool, BlockSize);
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                hr = atu->Add(Tag->I32, IndeterminatePool, BlockSize);
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}
#endif


DECLARE_API( listobj )
{
    HRESULT     hr;

    BEGIN_API( listobj );

    BOOL        CheckType = TRUE;
    Array<BOOL> MatchType(TOTAL_TYPE);
    Array<CHAR> TypeList;

    ULONG       TagFilter = '  *G';
    FLONG       SearchFlags = 0;
    BOOL        CheckHandle = FALSE;
    BOOL        Summary = FALSE;
    BOOL        BadArg = FALSE;

    OutputControl   OutCtl(Client);
    ULONG64         EntryAddr;
    ULONG64         gcMaxHmgr;
    ULONG           EntrySize;

    ULONG           Index = 0;

    ULONG           LongestType = 0;
    int         i;

    for (i = 0; i <= MAX_TYPE; i++)
    {
        ULONG   Len = strlen(pszTypes2[i]);
        if (Len > LongestType)
        {
            LongestType = Len;
        }
    }

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (CheckType && !TypeList.IsEmpty())
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -a may not be specified with a Type list.\n");
                        }
                        else
                        {
                            CheckType = FALSE;
                        }
                        break;

                    case 'h':
                        CheckHandle = TRUE;
                        break;

                    case 'n':
                        SearchFlags |= SEARCH_POOL_NONPAGED;
                        break;

                    case 'p':
                        SearchFlags |= SEARCH_POOL_PAGED;
                        break;

                    case 's':
                        Summary = TRUE;
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            {
                // This argument must be a Type specification.
                if (!CheckType)
                {
                    OutCtl.OutErr("Error: a Type list may not be specified with -a.\n");
                    BadArg = TRUE;
                    break;
                }

                for (i = 0; i <= MAX_TYPE; i++)
                {
                    SIZE_T CheckLen = strlen(pszTypes2[i]);

                    if (_strnicmp(args, pszTypes2[i], CheckLen) == 0 &&
                        (!iscsym(args[CheckLen]) ||
                         (_strnicmp(&args[CheckLen], "_TYPE", 5) == 0 &&
                          !iscsym(args[CheckLen+5])
                       )))
                    {
                        if (!MatchType[i])
                        {
                            // Add Type to list
                            SIZE_T CatLoc = TypeList.GetLength();
                            if (CatLoc > 0)
                            {
                                TypeList[CatLoc] = ' ';
                                TagFilter = '???G';
                            }
                            else
                            {
                                TagFilter = '0??G' + (i << 24);
                            }
                            TypeList.Set(pszTypes2[i], CheckLen+1, CatLoc);
                        }
                        MatchType[i] = TRUE;
                        args += CheckLen;
                        if (iscsym(*args)) args += 5;
                        break;
                    }
                }

                if (i > MAX_TYPE)
                {
                    OutCtl.OutErr("Error: Unknown Type in '%s'.\n", args);
                    BadArg = TRUE;
                    break;
                }
            }
        }
    }

    if (!BadArg)
    {
        if (CheckType && TypeList.IsEmpty())
        {
            OutCtl.OutErr("Error: Missing -a or Type list.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("listobj searches session pool for known GDI objects\n"
                          " and displays basic object properties\n"
                          "\n");
        }

        OutCtl.Output("Usage: listobj [-?hnps] <-a | Type(s)>\n"
                      "\n"
                      "     a - All object types\n"
                      "     h - Validate handle\n"
                      "     n - Search non-paged pool\n"
                      "     p - Seach paged pool\n"
                      "     s - Summary counts only\n"
                      "\n"
                      " The -s option combined with the -a option will produce\n"
                      "  a list of the totals for each object type.\n");

        OutCtl.Output("\n Valid Type values are:\n");
        i = 0;
        while (i <= MAX_TYPE)
        {
            do
            {
                OutCtl.Output("   %-*s", LongestType, pszTypes2[i++]);
            } while (i <= MAX_TYPE && i%4);
            OutCtl.Output("\n");
        }

        hr = S_OK;
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    
        if ((SearchFlags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            SearchFlags |= SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED;
        }

#if 0
        hr = SearchSessionPool(Client,
                               DEFAULT_SESSION, TagFilter, SearchFlags,
                               0,
                               ListObjectsFilter, &AllocStats, &AllocStats);
#else
        OutCtl.OutWarn("listobj not implemented.\n");
        hr = E_NOTIMPL;
#endif
    
        if (hr == S_OK || hr == E_ABORT)
        {
            //OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\math.cxx ===
/******************************Module*Header*******************************\
* Module Name: math.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#include <limits.h>



HRESULT
GetAddressAndLength(
    OutputControl &OutCtl,
    PCSTR args,
    PBOOL UnknownArg,
    PDEBUG_VALUE Address,
    PDEBUG_VALUE Length
    )
{
    HRESULT     hr = S_OK;
    BOOL        ArgsOk = TRUE;
    DEBUG_VALUE Addr;
    DEBUG_VALUE Len;
    ULONG       RemIndex;

    if (UnknownArg != NULL) *UnknownArg = FALSE;
    if (Address != NULL) Address->Type = DEBUG_VALUE_INVALID;
    if (Length != NULL) Length->Type = DEBUG_VALUE_INVALID;

    Addr.Type = DEBUG_VALUE_INVALID;
    Len.Type = DEBUG_VALUE_INVALID;

    while (isspace(*args)) args++;

    while (hr == S_OK && ArgsOk && *args != '\0')
    {
        if (*args == '-')
        {
            ArgsOk = FALSE;
            do
            {
                args++;
            } while (*args != '\0' && !isspace(*args));
        }
        else if (Addr.Type == DEBUG_VALUE_INVALID)
        {
            hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT64, &Addr, &RemIndex);
            if (hr == S_OK && Addr.I64 != 0)
            {
                args += RemIndex;
            }
            else
            {
                PCHAR   pEOA;
                CHAR    EOAChar;

                ArgsOk = FALSE;

                if (hr == S_OK)
                {
                    pEOA = (PCHAR)&args[RemIndex];
                    EOAChar = *pEOA;
                    *pEOA = '\0';
                }
                OutCtl.OutErr("Invalid Address: %s\n", args);
                if (hr == S_OK)
                {
                    *pEOA = EOAChar;
                }
            }
        }
        else if (Len.Type == DEBUG_VALUE_INVALID)
        {
            hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT32, &Len, &RemIndex);
            if (hr == S_OK && Len.I64 != 0)
            {
                args += RemIndex;
            }
            else
            {
                PCHAR   pEOA;
                CHAR    EOAChar;

                ArgsOk = FALSE;

                if (hr == S_OK)
                {
                    pEOA = (PCHAR)&args[RemIndex];
                    EOAChar = *pEOA;
                    *pEOA = '\0';
                }
                OutCtl.OutErr("Invalid Length: %s\n", args);
                if (hr == S_OK)
                {
                    *pEOA = EOAChar;
                }
            }
        }
        else
        {
            ArgsOk = FALSE;
        }

        while (isspace(*args)) args++;
    }

    if (hr == S_OK)
    {
        if (UnknownArg != NULL) *UnknownArg = !ArgsOk;
        if (Address != NULL) *Address = Addr;
        if (Length != NULL) *Length = Len;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dfloat
*
\**************************************************************************/

DECLARE_API( dfloat ) 
{
    dprintf("Extension 'dfloat' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  ULONG Num;
  ULONG Adr;
  BOOL List=FALSE;
  ULONG Value;
  
  PARSE_ARGUMENTS(dfloat_help);
  if(ntok<1) { 
    goto dfloat_help;
  }

  //find valid tokens - ignore the rest
  tok_pos = parse_iFindSwitch(tokens, ntok, 'l');
  if(tok_pos>=0) {
    List = TRUE;
    if((tok_pos+1)>=ntok) { 
      goto dfloat_help;               //-l requires an argument and it can't be the last arg
    }
    tok_pos++;
    Num = (LONG)GetExpression(tokens[tok_pos]);
  }

  //find first non-switch token not preceeded by a -l
  tok_pos = -1;
  do {
    tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
  } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'l')));
  if(tok_pos==-1) {
    goto dfloat_help;
  }

  Adr = (ULONG)GetExpression(tokens[tok_pos]);

  if(List) {
    for(ULONG i=0; i<Num; i++) {
      move(Value, Adr);
      dprintf("%lx: %lx %g\n", Adr, Value, *(float *)&Value);
      Adr+=sizeof(ULONG);
    }
  } else {
    dprintf("%g\n", *(float *)&Adr);
  }

  return;

dfloat_help:
  dprintf("Usage: dfloat [-?] [-l num] Value");
  dprintf("Displays the 32bit Value as an IEEE float\n");
  dprintf("if the -l option is specified the Value is interpreted as a pointer\n"
          "and an array of num 32bit values is displayed starting at the pointer\n");
#endif  // DOES NOT SUPPORT API64
  EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   efloat address [count]
*
* Routine Description:
*
*   dumps an EFLOAT
*
* Arguments:
*
*   address [count]
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( efloat )
{
#if 1
    HRESULT         hr = E_POINTER;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Addr;
    DEBUG_VALUE     Length;
    BOOL            UnknownArg;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( efloat );

    hr = GetAddressAndLength(OutCtl, args, &UnknownArg, &Addr, &Length);

    if (hr != S_OK || UnknownArg || Addr.Type != DEBUG_VALUE_INT64)
    {
        OutCtl.Output("Usage: efloat <EFLOAT Address> [Length]\n");
    }
    else
    {
        if (Length.Type != DEBUG_VALUE_INT32)
        {
            Length.I32 = 1;
        }

        OutputReader    OutputBuffer;
        OutputState     OutState(Client, FALSE);
        ULONG64         Module;
        ULONG           TypeId;
        ULONG           Size;
        PSTR            TypeDump;

        if ((hr = OutState.Setup(0, &OutputBuffer)) == S_OK &&
            (hr = GetTypeId(Client, "EFLOAT", &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &Size)) == S_OK)
        {
            if (Size == 0)
            {
                OutCtl.OutErr("EFLOAT type has 0 size.\n");
                hr = S_FALSE;
            }
            else
            {
                ULONG64 LastAddr = Addr.I64 + Size*Length.I32;
                ULONG   BytesRead;

                while (Addr.I64 < LastAddr &&
                       OutCtl.GetInterrupt() != S_OK)
                {
                    OutCtl.Output("0x%p  ", Addr.I64);

                    OutputBuffer.DiscardOutput();

                    hr = OutState.OutputTypeVirtual(Addr.I64,
                                                    Module,
                                                    TypeId,
                                                    DEBUG_OUTTYPE_NO_INDENT |
                                                    DEBUG_OUTTYPE_NO_OFFSET |
                                                    DEBUG_OUTTYPE_COMPACT_OUTPUT);
                    if (hr == S_OK &&
                        (hr = OutputBuffer.GetOutputCopy(&TypeDump)) == S_OK)
                    {
                        for (PSTR psz = TypeDump; *psz != '\0'; psz++)
                        {
                            if (*psz == '\n') *psz = ' ';
                        }

                        OutCtl.Output("%s", TypeDump);
                        OutputEFLOAT_S(Client, &OutCtl,
                                       Module, TypeId,
                                       TypeDump,
                                       DEBUG_OUTTYPE_NO_INDENT |
                                       DEBUG_OUTTYPE_NO_OFFSET |
                                       DEBUG_OUTTYPE_COMPACT_OUTPUT,
                                       NULL);
                        OutputBuffer.FreeOutputCopy(TypeDump);
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }
                    OutCtl.Output("\n");

                    Addr.I64 += Size;
                }
            }
        }
    }

    Symbols->Release();

    return hr;
#else
    INIT_API();

    ULONG64 EFloatAddr;
    ULONG   EFloatSize;
    int     count;
    char    ach[64];

    PARSE_POINTER(efloat_help);

    tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    if (tok_pos==-1)
    {
        count=1;
    }
    else
    {
        if (sscanf(tokens[tok_pos], "%d", &count) == EOF ||
            count <= 0)
        {
            goto efloat_help;
        }
    }

    EFloatAddr = arg;
    EFloatSize = GetTypeSize(GDIType(EFLOAT));

    while (count > 0 && !CheckControlC())
    {
        for (ULONG offset = 0;  offset < EFloatSize; offset+=sizeof(DWORD))
        {
            ULONG64 Value;

            GetFieldValue(EFloatAddr+offset, "DWORD", NULL, Value);
            sprintf(ach, " %%0%dx", 2*min(sizeof(DWORD), EFloatSize-offset));
            dprintf(ach, (DWORD)Value);
        }

        dprintf(" = ");
        sprintEFLOAT(Client, ach, EFloatAddr );
        dprintf("%s\n", ach);

        EFloatAddr += EFloatSize;
        count--;
    }

    EXIT_API(S_OK);

efloat_help:
    dprintf("Usage: efloat [-?] address [count]\n");
    EXIT_API(S_OK);
#endif
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   sprintEFLOAT
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
// Here for reference
int sprintEFLOAT_Old(char *ach, EFLOAT& ef)
{
    EFLOATEXT efInt;
    EFLOATEXT efFrac;
    LONG lInt, lFrac;
    char chSign;
    efFrac = ef;

    if (efFrac.bIsNegative()) {
        efFrac.vNegate();
        chSign = '-';
    }
    else
        chSign = '+';
    efFrac.bEfToLTruncate(lInt);
    efInt = lInt;
    efFrac -= efInt;
    efFrac *= (LONG) 1000000;
    efFrac.bEfToLTruncate(lFrac);

    return(sprintf(ach,"%c%d.%06d", chSign, lInt, lFrac));
}
#endif  // DOES NOT SUPPORT API64

int sprintEFLOAT_I386(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    ULONG64 lMant;
    LONG    lExp;
    ULONG   lInt, lFrac;
    ULONG64 fx3232;
    ULONG   error;
    char    chSign = '+';

    if (error = (ULONG)InitTypeRead(offEF, win32k!EFLOAT_S))
    {
        dprintf(" Unable to get contents of EFLOAT\n");
        dprintf("  (InitTypeRead returned %s)\n", pszWinDbgError(error));
        return 0;
    }
    lMant = ReadField(lMant);
    lExp  = (LONG)ReadField(lExp);

    if (lMant & 0x80000000)      // EFLOAT::bIsNegative
    {
        // EFLOAT::vNegate()
        if ((lMant & 0x7FFFFFFF) == 0)
        {
            lMant = 0x40000000;
            lExp += 1;
        }
        else
        {
            lMant = - (LONG)lMant;
        }
        chSign = '-';
    }
    // EFLOAT::bEfToLTruncate
    if (lExp > 32)
        return(sprintf(ach,"Overflow: exponent %d > 32", lExp));
    if (lExp < -32)
        return(sprintf(ach,"%c0.000000", chSign));


    if (lExp < 0)
    {
        fx3232 = lMant >> -lExp;
    }
    else
    {
        fx3232 = lMant << lExp;
    }

    lInt = (ULONG) (fx3232 >> 32);
    lFrac = (ULONG) ( ( (fx3232 & 0xFFFFFFFF) * 1000000 + 0x80000000) >> 32);

    if (lFrac > 1000000)
    {
        return(sprintf(ach,"Bug in sprintEFLOAT_I386: fraction above 1000000"));
    }

    if (lFrac == 1000000)
    {
        lInt++;
        lFrac = 0;
    }

    return(sprintf(ach,"%c%u.%06d", chSign, lInt, lFrac));
}

int sprintEFLOAT_IA64(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    return(sprintf(ach,"EFLOAT parser needs written for IA64"));
}

int sprintEFLOAT(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    switch (TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return(sprintEFLOAT_I386(Client, ach, offEF));
    case IMAGE_FILE_MACHINE_IA64:
        return(sprintEFLOAT_IA64(Client, ach, offEF));
    default:
        return(sprintf(ach,"EFLOAT parser needs written for machine type %X", TargetMachine));
    }
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputEFLOAT_S
*
* Routine Description:
*
*   Outputs an EFLOAT_S
*
\**************************************************************************/

HRESULT
OutputEFLOAT_S(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         Mant, Exp;

    if (Parser.LookFor(&Mant, "lMant", DEBUG_VALUE_INT32) == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.Complete() == S_OK &&
        Parser.LookFor(&Exp, "lExp", DEBUG_VALUE_INT32) == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.Complete() == S_OK)
    {
        LONG    lMant = Mant.I32;
        LONG    lExp = Exp.I32;
        ULONG   lInt, lFrac;
        ULONG64 fx3232;
        char    chSign = '+';

        if (lMant < 0)  // EFLOAT::bIsNegative
        {
            // EFLOAT::vNegate()
            if (lMant == LONG_MIN)
            {
                lMant = -(LONG_MIN/2);
                lExp += 1;
            }
            else
            {
                lMant = -lMant;
            }
            chSign = '-';
        }

        // EFLOAT::bEfToLTruncate
        if (lExp > 32)
            return OutCtl->Output("Overflow: exponent %d > 32", lExp);
        if (lExp < -32)
            return OutCtl->Output("%c0.000000", chSign);


        fx3232 = (lExp < 0) ? (((ULONG64) lMant) >> -lExp) : (((ULONG64) lMant) << lExp);
        lInt = (ULONG) (fx3232 >> 32);
        lFrac = (ULONG) ( ( (fx3232 & 0xFFFFFFFF) * 1000000 + 0x80000000) >> 32);

        if (lFrac > 1000000)
        {
            OutCtl->Output(DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR,
                           "Bug in sprintEFLOAT_I386: fraction above 1000000");
        }
        else
        {
            if (lFrac == 1000000)
            {
                lInt++;
                lFrac = 0;
            }

            hr = OutCtl->Output("%c%u.%06d", chSign, lInt, lFrac);
        }
    }
    else
    {
        hr = OutCtl->Output("%s", Buffer);
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFLOATL
*
* Routine Description:
*
*   Outputs a FLOAT from a DEBUG_VALUE regardless of Type
*
\**************************************************************************/

HRESULT
OutputFLOATL(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE Value
    )
{
    if (OutCtl == NULL || Value == NULL)
    {
        return E_INVALIDARG;
    }

    return OutCtl->Output("%#g", (double) Value->F32);
}


/******************************Public*Routine******************************\
* FLOATL
*
*   dumps an array of FLOAT's
*
* History:
*  Wed 24-Apr-1996 10:00:27 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( floatl )
{
    HRESULT         hr = E_POINTER;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Addr;
    DEBUG_VALUE     Length;
    BOOL            UnknownArg;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( floatl );

    hr = GetAddressAndLength(OutCtl, args, &UnknownArg, &Addr, &Length);

    if (hr != S_OK || UnknownArg || Addr.Type != DEBUG_VALUE_INT64)
    {
        OutCtl.Output("Usage: floatl <FLOATL Address> [Count]\n");
    }
    else
    {
        if (Length.Type != DEBUG_VALUE_INT32)
        {
            Length.I32 = 1;
        }

        ULONG64     Module;
        ULONG       TypeId;
        ULONG       Size;
        DEBUG_VALUE Value;

        if ((hr = GetTypeId(Client, "FLOATL", &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &Size)) == S_OK)
        {
            if (Size == 0 || Size > sizeof(Value.RawBytes))
            {
                OutCtl.OutErr("FLOATL type has unexpected size.\n");
                hr = S_FALSE;
            }
            else
            {
                ULONG64 LastAddr = Addr.I64 + Size*Length.I32;
                ULONG   BytesRead;

                while (Addr.I64 < LastAddr &&
                       OutCtl.GetInterrupt() != S_OK)
                {
                    OutCtl.Output("0x%p  ", Addr.I64);

                    if (Symbols->ReadTypedDataVirtual(Addr.I64,
                                                      Type_Module.Base,
                                                      TypeId,
                                                      &Value,
                                                      Size,
                                                      &BytesRead) == S_OK &&
                        BytesRead == Size)
                    {
                        OutputFLOATL(&OutCtl, Client, &Value);
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }
                    OutCtl.Output("\n");

                    Addr.I64 += Size;
                }
            }
        }
    }

    Symbols->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpMATRIX
*
\**************************************************************************/

void vDumpMATRIX(PDEBUG_CLIENT Client, ULONG64 offMX)
{
    DumpType(Client, "MATRIX", offMX);
}


/******************************Public*Routine******************************\
* MATRIX
*
\**************************************************************************/

DECLARE_API( matrix )
{
    return ExtDumpType(Client, "matrix", "MATRIX", args); 
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   mx
*
\**************************************************************************/

DECLARE_API( mx )
{
    return ExtDumpType(Client, "mx", "MATRIX", args); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\help.cxx ===
/******************************Module*Header*******************************\
* Module Name: help.cxx
*
* Display the help information for gdiexts
*
* Created: 16-Feb-1995
* Author: Lingyun Wang [lingyunw]
*
* Copyright (c) 1995-2000 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* help
*
* Prints a simple help summary of the debugging extentions.
*
* History:
*  05-May-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//
// Debugger extention help.  If you add any debugger extentions, please
// add a brief description here.  Thanks!
//

char *szHelp = 
"=======================================================================\n"
"GDIEXTS server debugger extentions:\n"
"-----------------------------------------------------------------------\n"
"\n"
"help                                     -- Displays this help page.\n"
"\n"
"All of the debugger extensions support a -? option for extension\n"
" specific help.\n"
"All of the debugger extensions that expect a pointer (or handle)\n"
" can parse expressions such as:\n"
"    ebp+8\n"
" or\n"
"    win32k!gpentHmgr\n"
"\n"
"Switches are case insensitive and can be reordered unless otherwise\n"
"specified in the extension help.\n"
"\n"
"  - general extensions -\n"
"\n"
"dumphmgr                                 -- handle manager objects\n"
//"dumpdd                                   -- DirectDraw: handle manager objects\n"
"dumpobj      [-p pid] [type]             -- all objects of specific type\n"
"dh           <GDI HANDLE>                -- HMGR entry of handle\n"
"dht          <GDI HANDLE>                -- handle type/uniqueness/index\n"
"dldev        [LDEV ptr]                  -- LDEV\n"
"dgdev        [-clr | GRAPHICS_DEVICE]    -- GRAPHICS_DEVICE list\n"
"dfloat       [-l num] Value              -- Dump an IEEE float or float array\n"
"dblt         [BLTRECORD ptr]             -- BLTRECORD\n"
//"dddsurface   [EDD_SURFACE ptr]           -- EDD_SURFACE\n"
//"dddlocal     [EDD_DIRECTDRAW_LOCAL ptr]  -- EDD_DIRECTDRAW_LOCAL\n"
//"dddglobal    [EDD_DIRECTDRAW_GLOBAL ptr] -- EDD_DIRECTDRAW_GLOBAL\n"
"rgnlog       nnn                         -- last nnn rgnlog entries\n"
"stats                                    -- accumulated statistics\n"
"verifier                                 -- Dump verifier information\n"
"\n"
"\n"
"  - type dump extensions -\n"
"\n"
"dt           <Type> <Offset>              -- GDI Type Dump w/ flag/enums\n"
"bltinfo      <BLTINFO Address>            -- BLTINFO\n"
"blendobj     <BLENDOBJ Address>           -- BLENDOBJ\n"
"brush        <BRUSH Address | HBRUSH>     -- BRUSH\n"
"brushobj     <BRUSHOBJ Address>           -- BRUSHOBJ\n"
"clipobj      <CLIPOBJ Address>            -- CLIPOBJ\n"
"ddc          <DC Address | HDC>           -- DC (ddc -? for more info)\n"
"devmodea     <DEVMODEA Address>           -- Ascii DEVMODE\n"
"devmodew     <DEVMODEW Address>           -- Unicode DEVMODE\n"
"ebrush       <EBRUSHOBJ Address>          -- EBRUSHOBJ\n"
"epathobj     <EPATHOBJ Address>           -- EPATHOBJ (+PATH)\n"
"lineattrs    <LINEATTRS Address>          -- LINEATTRS\n"
"maxtrix      <MATRIX Address>             -- MATRIX\n"
"palette      <PALETTE Address | HPALETTE> -- PALETTE\n"
"path         <PATH Address | HPATH>       -- PATH\n"
"pathobj      <PATHOBJ Address>            -- PATHOBJ\n"
"pdev         <PDEV Address>               -- PDEV (pdev -? for more info)\n"
"region       <REGION Address | HRGN>      -- REGION\n"
"sprite       <SPRITE Address>             -- SPRITE\n"
"spritestate  <SPRITESTATE Address>        -- SPRITE_STATE\n"
"surface      <SURFACE Address | HSURF>    -- SURFACE\n"
"surfobj      <SURFOBJ Address | HSURF>    -- SURFOBJ\n"
"wndobj       <WNDOBJ Address>             -- WNDOBJ\n"
"xlate        <XLATE Address>              -- XLATE\n"
"xlateobj     <XLATEOBJ Address>           -- XLATEOBJ\n"
//"obj      <OBJ Address>            -- OBJ\n"
"\n"
"\n"
"  - dc extensions -\n"
"dclist         -- list compact info about all known and readble surfaces\n"
"ddc          <DC Address | HDC>           -- DC (ddc -? for more info)\n"
"\n"
"  - session extensions -\n"
"session      [SessionId]                 -- Get/set session settings\n"
"spoolfind    <Tag>                       -- Search session pool for Tag\n"
"spoolsum                                 -- Summarize/verify pool numbers\n"
"spoolused                                -- Show pool allocs by tag\n"
"sprocess     [SessionId [Flags]]         -- Dump Processes in Session\n"
"svtop        <Session Virtual Address>   -- Lookup physical address\n"
"\n"
"  - surface extensions -\n"
"pageinsurfs                          -- Page-in all surf objects found in hmgr\n"
"pageinsurface <SURFACE Address>      -- Page-in image bits for a surface\n"
"surface    <SURFACE Address | HSURF | -o SURFOBJ Address>  -- Dump SURFACE type\n"
"surfobj    <SURFOBJ Address | HSURF>                       -- Dump SURFOBJ type\n"
"surflist       -- list compact info about all known and readable surfaces\n"
"vsurf      <SURFACE Address | HSURF | -o SURFOBJ Address>  -- display a surface\n"
"\n"
"  - process/thread extensions -\n"
"batch      [TEB Address | -t Thread]           -- list batched GDI commands\n"
"semorder   [Thread]                            -- show semaphore usage history\n"
"w32p       [W32PROCESS Address | -p Process]   -- dump W32PROCESS structure\n"
"w32t       [W32THREAD Address | -t Thread]     -- dump W32THREAD structure\n"
"\n"
"\n"
"hdc          HDC [-?gltf]\n"
"dcl          DCLEVEL*\n"
"dca          DC_ATTR*\n"
"ca           COLORADJUSTMENT*\n"
"efloat       <EFLOAT Address> [Count]\n"
"batch        DISPLAY TEB BATCHED COMMANDS\n"
"dpeb         DISPLAY PEB CACHED OBJECTS\n"
"floatl       <FLOATL Address> [Count]\n"
"xo           XFORMOBJ*\n"
"\n"
"  - font extensions -\n"
"\n"
"tstats\n"
"gs        FD_GLYPHSET*\n"
"gdata     GLYPHDATA*\n"
"elf       LOGFONTW*\n"
"tm        TEXTMETRICW*\n"
"tmwi      TMW_INTERNAL*\n"
"helf      HFONT\n"
"ifi       IFIMETRICS*\n"
"fo        RFONT* [-?axedtrfmoculhw]\n"
"pfe       PFE*\n"
"pff       PFF*\n"
"pft       PFT*\n"
"stro      STROBJ* [-?pheo]\n"
"gb        GLYPHBITS* [-?gh]\n"
"gdf       GLYPHDEF*\n"
"gp        GLYPHPOS*\n"
"cache     CACHE*\n"
"fh        FONTHASH*\n"
"hb        HASHBUCKET*\n"
"fv        FILEVIEW*\n"
"ffv       FONTFILEVIEW*\n"
"cliserv   CLISERV*\n"
"dhelf     HFONT\n"
"difi      IFIMETRICS*\n"
"dstro     STROBJ*\n"
"gdicall   GDICALL*\n"
"hpfe      HPFE\n"
"proxymsg  PROXYMSG*\n"
"\n"
"pubft -- dumps all PUBLIC fonts\n"
"pvtft -- dumps all Private or Embedded fonts\n"
"devft -- dumps all DEVICE fonts\n"
"dispcache -- dumps glyph cache for display PDEV\n"
"\n"
"=======================================================================\n";


DECLARE_API( help )
{
    OutputControl   OutCtl(Client);

    OutCtl.Output(szHelp);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\oscompat.cxx ===
#include "precomp.hxx"

// Copied from nt\base\win32\client\thread.c

HANDLE
OSCompat_OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if (NT_SUCCESS(Status))
    {
        return Handle;
    }
    else
    {
        SetLastError(Status);
        return NULL;
    }
}


// Copied from nt\base\ntos\rtl\bitmap.c

static CONST ULONG FillMaskUlong[] = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};


ULONG
OSCompat_RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk;
    ULONG Hunk;

    //
    //  Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Scan backwards for the first clear bit
    //

    End = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the End bit, then read in the bitmap
    //  hunk. Set the rest of the bits in this word, NOT
    //  inclusive of the FromIndex bit.
    //

    PHunk = BitMapHeader->Buffer + (End / 32);
    Hunk = *PHunk | ~FillMaskUlong[(End % 32) + 1];

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search
    //

    if (Hunk == (ULONG)~0) {

        //
        //  Adjust the pointers backwards
        //

        End -= (End % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)~0) break;

            PHunk--;
            End -= 32;
        }
    }

    //
    //  Bitwise search backward for the clear bit
    //

    while ((End != MAXULONG) && (RtlCheckBit( BitMapHeader, End ) == 1)) { End -= 1; }

    //
    //  Scan backwards for the first set bit
    //

    Start = End;

    //
    //  We know that the clear bit was in the last word we looked at,
    //  so continue from there to find the next set bit, clearing the
    //  previous bits in the word.
    //

    Hunk = *PHunk & FillMaskUlong[Start % 32];

    //
    //  If the subword is unset then we can proceed in big steps
    //

    if (Hunk == (ULONG)0) {

        //
        //  Adjust the pointers backward
        //

        Start -= (Start % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)0) break;

            PHunk--;
            Start -= 32;
        }
    }

    //
    //  Bitwise search backward for the set bit
    //

    while ((Start != MAXULONG) && (RtlCheckBit( BitMapHeader, Start ) == 0)) { Start -= 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start + 1;
    return (End - Start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\region.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    region.cxx

Abstract:

    This file contains the routines to debug regions.

Author:

    Jason Hartman (JasonHa) 2001-04-30

Environment:

    User Mode

--*/

#include "precomp.hxx"


/******************************Public*Routine******************************\
* DECLARE_API( dr  )
*
* Debugger extension to dump a region
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( dr  )
{
    OutputControl   OutCtl(Client);
    OutCtl.Output("Obsolete: Use 'region hrgn|prgn'.\n");
    return S_OK;
}

/******************************Public*Routine******************************\
* DECLARE_API( cr  )
*
* Debugger extension to check a region
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( cr  )
{
    OutputControl   OutCtl(Client);
    OutCtl.Output("Obsolete: Use 'region -c hrgn|prgn'\n");
    return S_OK;
}


/******************************Public*Routine******************************\
* DECLARE_API( region  )
*
* Debugger extension to dump and validate a region
*
*  22-May-2000    -by- Jason Hartman [jasonha]
*                   Converted from old dr & cr
*
\**************************************************************************/

DECLARE_API( region  )
{
    ULONG64 RgnAddr;
    ULONG   error;
    ULONG   Flags = 0;

    #define REGION_CSCANS       0
    #define REGION_SCAN_ADDRESS 1
    #define REGION_SCAN_TAIL    2
    #define REGION_SIZEOBJ      3

    #define NUM_REGION_BASEOBJ_FIELDS   3

    FIELD_INFO RegionFields[] = {
        { DbgStr("cScans"),         DbgStr("cScans           :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_CSCANS
        { DbgStr("scan"),           DbgStr("scan <- pscnHead :"), 0, DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME, 0, AddressPrintCallback},    // REGION_SCAN_ADDRESS
        { DbgStr("pscnTail"),       DbgStr("pscnTail         :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_SCAN_TAIL
        { DbgStr("sizeObj"),        DbgStr("sizeObj          :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_SIZEOBJ
        { DbgStr("sizeRgn"),        DbgStr("sizeRgn          :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("cRefs"),          DbgStr("cRefs            :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("rcl"),            DbgStr("rcl              :"), 0, DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME, 0, RECTLCallback},
        { DbgStr("hHmgr"),          DbgStr("hHmgr            :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("cExclusiveLock"), DbgStr("cExclusiveLock   :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("Tid"),            DbgStr("Tid              :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };
    SYM_DUMP_PARAM RegionSym = {
       sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(REGION)), DBG_DUMP_COMPACT_OUT, 0/*RgnAddr*/,
       NULL, &RegionSym, NewlineCallback, sizeof(RegionFields)/sizeof(RegionFields[0]), RegionFields
    };
    PrepareCallbacks(TRUE);

    INIT_API();

    PARSE_POINTER(region_help);

    if (ntok > 1)
    {
      if (parse_iFindSwitch(tokens, ntok, 'c')!=-1)
      {
          Flags |= SCAN_DUMPER_NO_PRINT;
      }
      else if (parse_iFindSwitch(tokens, ntok, 'f')!=-1)
      {
          Flags |= SCAN_DUMPER_FORCE;
      }

      if (parse_iFindSwitch(tokens, ntok, 'r')!=-1)
      {
          Flags |= SCAN_DUMPER_FROM_TAIL;
      }
    }

    // get pointer to object from handle or use param as pointer
    if ((GetObjectAddress(Client,arg,&RgnAddr,RGN_TYPE,TRUE,TRUE) != S_OK) ||
        (RgnAddr == 0))
    {
        ULONG64 ObjHandle;
        ULONG64 RgnAddrFromHmgr;

        RgnAddr = arg;

        if (error = GetFieldValue(RgnAddr, GDIType(REGION), "hHmgr", ObjHandle))
        {
            ExtErr("Unable to get contents of REGION::hHmgr\n");
            ExtErr("  (Ioctl returned %s)\n", pszWinDbgError(error));
            ExtErr(" %#p is neither an HRGN nor valid REGION address\n", arg);
            EXIT_API(S_OK);
        }

        if (!ObjHandle)
        {
            ExtOut("\tREGION is reserved for system use (no handle manger entry).\n");
            RegionSym.nFields -= NUM_REGION_BASEOBJ_FIELDS;
        }
        else if (GetObjectAddress(Client,ObjHandle,&RgnAddrFromHmgr,
                                  RGN_TYPE,TRUE,FALSE) == S_OK &&
                 RgnAddrFromHmgr != RgnAddr)
        {
            ExtOut("\tNote: REGION may not be valid.\n\t      It does not have a valid handle manager entry.\n");
        }
    }

    ExtOut("REGION @ %#p\n  ", RgnAddr);

    RegionSym.addr = RgnAddr;
    error = Ioctl( IG_DUMP_SYMBOL_INFO, &RegionSym, RegionSym.size );

    if (error)
    {
        ExtErr("Unable to get contents of REGION\n");
        ExtErr("  (Ioctl returned %s)\n", pszWinDbgError(error));
    }
    else
    {
        ScanDumper  Dumper(RegionFields[REGION_SCAN_ADDRESS].address,
                           RegionFields[REGION_SCAN_TAIL].address,
                           (ULONG)RegionFields[REGION_CSCANS].address,
                           RegionFields[REGION_SCAN_ADDRESS].address,
                           RgnAddr+RegionFields[REGION_SIZEOBJ].address,
                           Flags
                           );
        BOOL        Valid;

        if ((Flags & SCAN_DUMPER_FROM_TAIL) != 0 && !Dumper.Reverse)
        {
            // We rquested a reverse dump, but Dumper wouldn't allow it.
            EXIT_API(S_OK);
        }

        Valid = Dumper.DumpScans((ULONG)RegionFields[REGION_CSCANS].address);

        if (Dumper.Reverse)
        {
            if (Dumper.ScanAddr != RegionFields[REGION_SCAN_ADDRESS].address)
            {
                ExtOut(" * Final ScanAddr (%#p) is not at head address (%#p)\n",
                       Dumper.ScanAddr, RegionFields[REGION_SCAN_ADDRESS].address);
                Valid = FALSE;
            }
        }
        else
        {
            if (Dumper.ScanAddr != RegionFields[REGION_SCAN_TAIL].address)
            {
                ExtOut(" * Final ScanAddr (%#p) is not at tail address (%#p)\n",
                       Dumper.ScanAddr, RegionFields[REGION_SCAN_TAIL].address);
                Valid = FALSE;
            }
        }

        if (Valid)
        {
            ExtOut("  Region is valid.\n");
        }
        else
        {
            ExtOut("  Region is NOT valid.\n");
        }
    }

    EXIT_API(S_OK);

region_help:
  ExtOut("Usage: region [-?cfr] hrgn|prgn\n");
  ExtOut(" dumps/validates a region\n");
  ExtOut("  c - doesn't print scans; validation only\n");
  ExtOut("  f - continue printing even if an error is found\n");
  ExtOut("  r - read scans in reverse order\n");
  EXIT_API(S_OK);
}


/**************************************************************************\
 *
\**************************************************************************/

BOOL bStrInStr(CHAR *pchTrg, CHAR *pchSrc)
{
    BOOL bRes  = 0;
    int c = strlen(pchSrc);

//CHECKLOOP umm? This could be difficult to detect
    while (TRUE)
    {
    // find the first character

        pchTrg = strchr(pchTrg,*pchSrc);

    // didn't find it?, fail!

        if (pchTrg == NULL)
            return(FALSE);

    // did we find the string? succeed

        if (strncmp(pchTrg,pchSrc,c) == 0)
            return(TRUE);

    // go get the next one.

        pchTrg++;
    }
}


/******************************Public*Routine******************************\
* rgnlog
*
\**************************************************************************/

#define MAXSEARCH  4

DECLARE_API( rgnlog )
{
#if 1
    HRESULT     hr = S_OK;
    BOOL        BadArg = FALSE;
    ULONG       RemainingArgIndex;
    DEBUG_VALUE DumpCount = { 0, DEBUG_VALUE_INVALID };
    CHAR        EmptySearchString[] = "";
    PSTR        SearchStringList = EmptySearchString;
    PSTR        SearchString = SearchStringList;

    OutputControl   OutCtl(Client);

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            args++;

            if (*args == '\0' || isspace(*args))
            {
                BadArg = TRUE;
            }
            else if (DumpCount.Type == DEBUG_VALUE_INVALID &&
                     args[0] == '1' && (args[1] == '\0' || isspace(args[1])))
            {
                DumpCount.I32 = -1;
                DumpCount.Type = DEBUG_VALUE_INT32;
            }
            else
            {
                while (*args != '\0' && !isspace(*args))
                {
                    switch (*args)
                    {
                        case '?':
                        default:
                            BadArg = TRUE;
                            break;
                    }

                    if (BadArg) break;
                    args++;
                }
            }
        }
        else
        {
            if (DumpCount.Type == DEBUG_VALUE_INVALID)
            {
                if (Evaluate(Client, args, DEBUG_VALUE_INT32, EVALUATE_DEFAULT_RADIX,
                             &DumpCount, &RemainingArgIndex, NULL, EVALUATE_COMPACT_EXPR) != S_OK ||
                    DumpCount.I32 == 0)
                {
                    BadArg = TRUE;
                }
                else
                {
                    args += RemainingArgIndex;
                }
            }
            else
            {
                if (SearchStringList == EmptySearchString)
                {
                    SearchStringList = (PSTR)HeapAlloc(GetProcessHeap(), 0,
                                                       sizeof(*SearchStringList)*(strlen(args)+2));

                    if (SearchStringList == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        SearchString = SearchStringList;
                        *SearchString = '\0';
                    }
                }

                if (hr == S_OK)
                {
                    if (*args == '`' || *args == '\'' || *args == '\"')
                    {
                        CHAR    StringEnd = *args;

                        if (args[1] == StringEnd || args[1] == '\0')
                        {
                            BadArg = TRUE;
                        }
                        else
                        {
                            while (*args != StringEnd && *args != '\0')
                            {
                                *SearchString++ = *args++;
                            }

                            if (*args == StringEnd) args++;

                            if (!isspace(*args) || *args != '\0')
                            {
                                OutCtl.Output("Malformed Search String at '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                            else
                            {
                                *SearchString++ = '\0';
                            }
                        }
                    }
                    else
                    {
                        while (!isspace(*args) && *args != '\0')
                        {
                            *SearchString++ = *args++;
                        }

                        *SearchString++ = '\0';
                    }
                }
            }
        }
    }

    if (hr == S_OK)
    {
        if (BadArg)
        {
            if (*args == '?')  OutCtl.Output("rgnlog - dump/search rgnlog from checked builds.\n");
            OutCtl.Output("Usage: rgnlog [-?] <Entries> [<Search Strings>]\n"
                          "\n"
                          "   Entries - Number of tailing entries to dump/search\n"
                          "   Search Strings - Dump only logs contain one of strings specified\n");
        }
        else
        {
            // Mark end of search string list with a NULL string.
            *SearchString = '\0';

            LONG    iLog, iPass;
            ULONG   LogArraySize, LogLength, LogEntrySize;
            CHAR    SymName[80];

            sprintf(SymName, "%s!iLog", GDIKM_Module.Name);
            hr = ReadSymbolData(Client, SymName, &iLog, sizeof(iLog), NULL);
            if (hr != S_OK) OutCtl.OutErr("Unable to get contents of %s\n", SymName);

            if (hr == S_OK)
            {
                sprintf(SymName, "%s!iPass", GDIKM_Module.Name);
                hr = ReadSymbolData(Client, SymName, &iPass, sizeof(iPass), NULL);
                if (hr != S_OK) OutCtl.OutErr("Unable to get contents of %s\n", SymName);
            }

            if (hr == S_OK)
            {
                sprintf(SymName, "%s!argnlog", GDIKM_Module.Name);
                hr = GetArrayDimensions(Client, SymName, NULL,
                                        &LogArraySize, &LogLength, &LogEntrySize);
                if (hr != S_OK) OutCtl.OutErr("Unable to get dimensions of %s\n", SymName);
            }

            if (hr == S_OK)
            {
            }

            if (hr == S_OK)
            {
                if (*SearchStringList != '\0')
                {
                    OutCtl.Output("Searching last %ld entries for:\n",
                                  DumpCount.I32);

                    for (SearchString = SearchStringList;
                         *SearchString != '\0';
                         *SearchString += strlen(SearchString)+1)
                    {
                        OutCtl.Output("  \"%s\"\n", SearchString);
                    }
                }
                else
                {
                    OutCtl.Output("Dumping last %ld entries.\n",
                                  DumpCount.I32);
                }
                // To Do
            }
        }
    }

    if (SearchStringList != EmptySearchString)
    {
        HeapFree(GetProcessHeap(), 0, SearchStringList);
    }

    return hr;
#else
    dprintf("Extension 'rgnlog' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LONG      cDump;
    LONG      iCurrent;
    RGNLOGENTRY rl;
    RGNLOGENTRY *prl;
    LONG      gml;          // gMaxRgnLog
    int       i, j;
    PVOID     pv;
    CHAR      achTmp[30];
    CHAR      achBuf[256];
    PCHAR     pchS[MAXSEARCH];
    int       cSearch;
    BOOL      bPrint;

    PARSE_ARGUMENTS(rgnlog_help);
    if(ntok<1) { goto rgnlog_help; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto rgnlog_help; }
//check that this supports decimal
    cDump = (LONG)GetExpression(tokens[tok_pos]);
    if(cDump==0) { goto rgnlog_help; }

    cSearch = 0;
    while(cSearch<MAXSEARCH) {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
      if(tok_pos==-1) {break;}
      pchS[cSearch]=tokens[tok_pos];
      cSearch++;
    }

    for (i = 0; i < cSearch; ++i)
        dprintf("search[%s]\n",pchS[i]);

// get some stuff

    GetAddress(pv, "&win32k!iLog");

    dprintf("&iLog = %lx\n",pv);

    if (pv == NULL)
    {
        dprintf("iCurrent was NULL\n");
        return;
    }
    move(iCurrent, pv);

    GetAddress(i,"&win32k!iPass");

    if (pv == NULL)
    {
        dprintf("iPass was NULL\n");
        return;
    }
    move(i,i);

    dprintf("--------------------------------------------------\n");
    dprintf("rgn log list, cDump = %ld, iCur = %ld, iPass = %ld\n", cDump,iCurrent,i);
    dprintf("%5s-%4s:%8s,%8s,(%8s),%8s,%8s,%4s\n",
           "TEB ","i","hrgn","prgn","return","arg1","arg2","arg3");
    dprintf("--------------------------------------------------\n");

// Dereference the handle via the engine's handle manager.

    GetAddress(prl, "win32k!argnlog");

    if (!prl)
    {
        dprintf("prl was NULL\n");
        return;
    }

    GetAddress(gml, "&win32k!gMaxRgnLog");

    if (!gml)
    {
        dprintf("gml was NULL\n");
        return;
    }
    move(gml,gml);

// set iCurrent to the first thing to dump

    if (cDump > gml)
        cDump = gml;

    if (cDump > iCurrent)
        iCurrent += gml;

    iCurrent -= cDump;

    dprintf("prl = %lx, gml = %ld, cDump = %ld, iCurrent = %ld\n",prl,gml,cDump,iCurrent);


//CHECKLOOP add exit/more support
    for (i = 0; i < cDump; ++i)
    {
        move(rl,&prl[iCurrent]);

        if (rl.pszOperation != NULL)
        {
            move2(achTmp,rl.pszOperation,30);
        }
        else
            achTmp[0] = 0;

        sprintf(achBuf,"%5lx-%4ld:%p,%p,(%8lx),%p, %p,%p, %s, %p, %p\n",
              (ULONG_PTR)rl.teb >> 12,iCurrent,rl.hrgn,rl.prgn,rl.lRes,rl.lParm1,
              rl.lParm2,rl.lParm3,achTmp,rl.pvCaller,rl.pvCallersCaller);

        bPrint = (cSearch == 0);

        for (j = 0; (j < cSearch) && !bPrint; ++j)
            bPrint |= bStrInStr(achBuf,pchS[j]);

        if (bPrint)
        {
            dprintf(achBuf);
        }

        if (++iCurrent >= gml)
            iCurrent = 0;

        if (CheckControlC())
            return;
    }
  return;
rgnlog_help:
  dprintf("\n rgnlog nnn [search1] [search2] [search3] [search4]\n");
  dprintf("\t nnn - dumps the last n entries of the rgn log\n");
  dprintf("\t search[n] - displays only entries containing one of n strings\n");
  dprintf("\t NOTE: only works on checked builds.  you must set bLogRgn at run time\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\remote.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remote.cxx

Abstract:

    This file contains the thunk routines to make
    wdbgext api calls from a remote client.

Author:

    Jason Hartman (JasonHa) 2000-10-27

Environment:

    User Mode

--*/

#include "precomp.hxx"



VOID
RemoteWarn(PCSTR pszAPI)
{
    ExtApiClass ExtApi(NULL);
    if (ExtApi.Client != NULL)
    {
        ExtWarn("Extension using WinDbg Extension API, %s, which isn't remote compatible.\n", pszAPI);
    }
}


VOID
WDBGAPIV
RemoteThunkOutputRoutine(
    PCSTR lpFormat,
    ...
    )
{
    ExtApiClass ExtApi(NULL);
//    RemoteWarn("dprintf");
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, lpFormat);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, lpFormat, Args);
    va_end(Args);
}


ULONG64
WDBGAPI
RemoteThunkGetExpressionRoutine(
    PCSTR lpExpression
    )
{
    ExtApiClass ExtApi(NULL);
//    RemoteWarn("GetExpression");
    DEBUG_VALUE Value;

    if (g_pExtControl != NULL)
    {
        if (g_pExtControl->Evaluate(lpExpression, DEBUG_VALUE_INT64, &Value, NULL) == S_OK)
        {
            return Value.I64;
        }
    }

    return 0;
}

//PWINDBG_GET_SYMBOL64
VOID
WDBGAPI
RemoteThunkGetSymbolRoutine(
    ULONG64    offset,
    PCHAR      pchBuffer,
    PULONG64   pDisplacement
    )
{
    RemoteWarn("GetSymbol");
    if (pchBuffer != NULL) ((PSTR)pchBuffer)[0] = '\0';
    if (pDisplacement != NULL) *pDisplacement = 0;
    return;
}


ULONG
WDBGAPI
RemoteThunkDisasmRoutine(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    )
{
    RemoteWarn("Disasm");
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkCheckControlCRoutine(
    VOID
    )
{
    ExtApiClass ExtApi(NULL);
    RemoteWarn("CheckControlC");

    return (g_pExtControl != NULL) ?
        (g_pExtControl->GetInterrupt() == S_OK) :
        FALSE;
}


ULONG
WDBGAPI
RemoteThunkReadProcessMemoryRoutine(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    )
{
    RemoteWarn("ReadMemory");
    if (lpBuffer != NULL) RtlZeroMemory(lpBuffer, cb);
    if (lpcbBytesRead != NULL) *lpcbBytesRead = 0;
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkWriteProcessMemoryRoutine(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    )
{
    RemoteWarn("WriteMemory");
    if (lpcbBytesWritten != NULL) *lpcbBytesWritten = 0;
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkGetThreadContextRoutine(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    )
{
    RemoteWarn("GetContext");
    if (lpContext != NULL) RtlZeroMemory(lpContext, cbSizeOfContext);
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkSetThreadContextRoutine(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    )
{
    RemoteWarn("SetContext");
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkIoctlRoutine(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    )
{
    RemoteWarn("Ioctl");
    return 0;
}



ULONG
RemoteThunkStackTraceRoutine(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    )
{
    RemoteWarn("StackTrace");
    return 0;
}



void GetRemoteWindbgExtApis(
    PWINDBG_EXTENSION_APIS64 ExtensionApis
    )
{
    ExtensionApis->lpOutputRoutine = RemoteThunkOutputRoutine;
    ExtensionApis->lpGetExpressionRoutine = RemoteThunkGetExpressionRoutine;
    ExtensionApis->lpGetSymbolRoutine = RemoteThunkGetSymbolRoutine;
    ExtensionApis->lpDisasmRoutine = RemoteThunkDisasmRoutine;
    ExtensionApis->lpCheckControlCRoutine = RemoteThunkCheckControlCRoutine;
    ExtensionApis->lpReadProcessMemoryRoutine = RemoteThunkReadProcessMemoryRoutine;
    ExtensionApis->lpWriteProcessMemoryRoutine = RemoteThunkWriteProcessMemoryRoutine;
    ExtensionApis->lpGetThreadContextRoutine = RemoteThunkGetThreadContextRoutine;
    ExtensionApis->lpSetThreadContextRoutine = RemoteThunkSetThreadContextRoutine;
    ExtensionApis->lpIoctlRoutine = RemoteThunkIoctlRoutine;
    ExtensionApis->lpStackTraceRoutine = RemoteThunkStackTraceRoutine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\surface.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    surface.cxx

Abstract:

    This file contains the routines to page in surface data.

Author:

    Jason Hartman (JasonHa) 2001-05-16

Environment:

    User Mode

--*/

#include "precomp.hxx"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

BYTE    x86_jmp_here[] = { 0xeb, 0xfe };   // spin jmp
BYTE    x86_jmp_plus_0x0e[] = { 0xeb, 0x0e };   // jmp
BYTE    x86_jb_plus_0x02[] = { 0x72, 0x02 };    // je
BYTE    x86_jne_minus_0x18[] = { 0x75, 0xe7 };    // jne

BYTE    x86_jmp_plus_0x06[] = { 0xeb, 0x06 };   // jmp
BYTE    x86_jb_plus_0x0c[] = { 0x72, 0x0c };    // je
BYTE    x86_jnz_minus_0x08[] = { 0x75, 0xf8 };    // jne

#define I_START_IP          0x00000001
#define I_WRITE_ADDRESS     0x00000002

typedef struct _Instruction {
    FLONG   Flags;
    ULONG   ByteLen;
    PSTR    Code;
} Instruction;



/******************************Public*Routine******************************\
* SURFACE
*
\**************************************************************************/

DECLARE_API( surface )
{
    BEGIN_API( surface );

    HRESULT         hr = S_OK;
    ULONG64         SurfAddr;
    DEBUG_VALUE     Arg;
    BOOL            BadSwitch = FALSE;
    BOOL            AddressIsSURFOBJ = FALSE;
    BOOL            AddressIsSURFACE = FALSE;
    BOOL            ArgumentIsHandle = FALSE;

    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (tolower(*args))
            {
                case 'a':
                    if (ArgumentIsHandle || AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        AddressIsSURFACE = TRUE;
                    }
                    break;
                case 'h':
                    if (AddressIsSURFACE || AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        ArgumentIsHandle = TRUE;
                    }
                    break;
                case 'o':
                    if (ArgumentIsHandle || AddressIsSURFACE)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        AddressIsSURFOBJ = TRUE;
                    }
                    break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: surface [-?] < [-h] HSURF | [-a] SURFACE Addr | -o SURFOBJ Addr>\n"
                      "\n"
                      "  Note: HBITMAP is the same as HSURF.\n");
    }
    else
    {
        if (AddressIsSURFOBJ)
        {
            PDEBUG_SYMBOLS  Symbols;

            ULONG64 SurfModule;
            ULONG   SurfTypeId;
            ULONG   BaseObjTypeId;
            ULONG   SurfObjOffset;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                // Try to read SURFOBJ offset from SURFACE type, but
                // if that fails assume it is directly after BASEOBJECT.
                if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                    (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                {
                    if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                    {
                        hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                    }
                }

                Symbols->Release();
            }

            if (hr != S_OK)
            {
                OutCtl.OutErr("Error: SURFOBJ to SURFACE lookup failed.\n");
            }
            else
            {
                SurfAddr = Arg.I64 - SurfObjOffset;
            }
        }
        else if (AddressIsSURFACE)
        {
            SurfAddr = Arg.I64;
        }
        else
        {
            // Try to look value up as a SURFACE handle
            hr = GetObjectAddress(Client, Arg.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

            if (hr != S_OK || SurfAddr == 0)
            {
                if (ArgumentIsHandle)
                {
                    OutCtl.OutErr(" 0x%p is not a valid HSURF\n", Arg.I64);
                }
                else
                {
                    // The value wasn't restricted to a handle
                    // so try as a SURFACE address.
                    SurfAddr = Arg.I64;
                    hr = S_OK;
                }
            }
            else
            {
                ArgumentIsHandle = TRUE;
            }
        }

        if (hr == S_OK && !ArgumentIsHandle)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             SurfAddrFromHmgr;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(SurfAddr, "SURFACE", 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of SURFACE::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                if (AddressIsSURFOBJ)
                {
                    OutCtl.OutErr(" 0x%p is not a valid SURFOBJ address\n", Arg.I64);
                }
                else if (AddressIsSURFACE)
                {
                    OutCtl.OutErr(" 0x%p is not a valid SURFACE address\n", Arg.I64);
                }
                else
                {
                    OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFACE address\n", Arg.I64);
                }
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &SurfAddrFromHmgr,
                                     SURF_TYPE, TRUE, FALSE) == S_OK &&
                    SurfAddrFromHmgr != SurfAddr)
                {
                    OutCtl.OutWarn("\tNote: SURFACE may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "SURFACE", SurfAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for SURFACE returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    EXIT_API(hr);
}


DECLARE_API( dpso  )
{
    INIT_API();
    ExtOut("Obsolete: Use 'surfobj <SURFOBJ Addr>'.\n");
    EXIT_API(S_OK);
}



/******************************Public*Routine******************************\
* SURFLIST
*
*   List readable surfaces and brief info
*
\**************************************************************************/

PCSTR   SurfaceListFields[] = {
    "so.hsurf",
    "so.hdev",
    "so.sizlBitmap",
    "so.cjBits",
    "so.pvBits",
    "so.iBitmapFormat",
    "so.iType",
    "so.fjBitmap",
    NULL
};

PCSTR   ExtendedSurfaceListFields[] = {
    "ulShareCount",
    "BaseFlags",
    "so.dhsurf",
    "SurfFlags",
    NULL
};

DECLARE_API( surflist )
{
    BEGIN_API( surflist );

    HRESULT hr;
    HRESULT hrMask;
    ULONG64 index = 0;
    ULONG64 gcMaxHmgr;
    ULONG64 SurfAddr;
    BOOL    BadSwitch = FALSE;
    BOOL    DumpBaseObject = FALSE;
    BOOL    DumpExtended = FALSE;
    BOOL    DumpUserFields = FALSE;

    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'b': DumpBaseObject = TRUE; break;
                case 'e': DumpExtended = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: surflist [-?be] [<Start Index>] [<Member List>]\n"
                      "\n"
                      "   b - Dump BASEOBJECT information\n"
                      "   e - Dump extended members\n"
                      "         ulShareCount, BaseFlags, dhsurf, SurfFlags\n"
                      "\n"
                      "   Start Index - First hmgr entry index to begin listing\n"
                      "   Member List - Space seperated list of other SURFACE members\n"
                      "                 to be included in the dump\n");

        return S_OK;
    }

    DEBUG_VALUE dvIndex;
    ULONG       RemIndex;
    if (*args != '\0' && !iscsymf(*args) &&
        ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &dvIndex, &RemIndex)) == S_OK))
    {
        index = dvIndex.I64;
        args += RemIndex;

        // Always keep args at the next unhandled argument
        while (isspace(*args)) args++;
    }

    if ((hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        OutCtl.OutErr("Unable to get sizeof GDI handle table. HRESULT %s\n", pszHRESULT(hr));
        return hr;
    }

    gcMaxHmgr = (ULONG64)(ULONG)gcMaxHmgr;

    if (index != 0 && index >= gcMaxHmgr)
    {
        OutCtl.Output("No remaining handle entries to be searched.\n");
        return hr;
    }

    OutCtl.Output("Searching %s 0x%I64x handle entries for Surfaces.\n",
                  (index ? "remaining" : "all"), gcMaxHmgr - index);

    OutputFilter    OutFilter(Client);
    OutputState     OutState(Client, FALSE);
    OutputControl   OutCtlToFilter;
    ULONG64         Module;
    ULONG           TypeId;
    ULONG           OutputMask;
    BOOL            IsPointer64Bit;
    ULONG           PointerSize;

    if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL,
                             &OutFilter)) == S_OK &&
        (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                DEBUG_OUTCTL_NOT_LOGGED,
                                OutState.Client)) == S_OK &&
        (hr = GetTypeId(Client, "SURFACE", &TypeId, &Module)) == S_OK)
    {
        TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToFilter);

        TypeReader.SelectMarks(1);
        TypeReader.IncludeMarked();
        if (DumpBaseObject) TypeReader.MarkFields(BaseObjectFields);
        if (DumpExtended) TypeReader.MarkFields(ExtendedSurfaceListFields);

        // Add user specified fields to dump list
        PSTR    MemberList = NULL;
        CHAR   *pBOF = (CHAR *)args;

        if (iscsymf(*pBOF))
        {
            MemberList = (PSTR) HeapAlloc(GetProcessHeap(), 0, strlen(pBOF)+1);

            if (MemberList != NULL)
            {
                strcpy(MemberList, pBOF);
                pBOF = MemberList;

                DumpUserFields = TRUE;

                while (iscsymf(*pBOF))
                {
                    CHAR   *pEOF = pBOF;
                    CHAR    EOFChar;

                    // Get member
                    do {
                         pEOF++;
                    } while (iscsym(*pEOF) || *pEOF == '.' || *pEOF == '*');
                    EOFChar = *pEOF;
                    *pEOF = '\0';
                    TypeReader.MarkField(pBOF);

                    // Advance to next
                    if (EOFChar != '\0')
                    {
                        do
                        {
                            pEOF++;
                        } while (isspace(*pEOF));
                    }

                    pBOF = pEOF;
                }
            }
            else
            {
                OutCtl.OutErr("Error: Couldn't allocate memory for Member List.\n");
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK && *pBOF != '\0')
        {
            OutCtl.OutErr("Error: \"%s\" is not a valid member list.\n", pBOF);
            hr = E_INVALIDARG;
        }

        if (hr == S_OK)
        {
            // Setup default dump specifications
            TypeReader.SelectMarks(0);
            TypeReader.IncludeMarked();
            TypeReader.MarkFields(SurfaceListFields);

            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " so _SURFOBJ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " hsurf ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " hdev ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "(null)", "(null)    ");
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " sizlBitmap", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " cjBits", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " pvBits", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " iBitmapFormat", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " iType", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " fjBitmap", NULL);

            // Output dump header
            PointerSize = (OutCtl.IsPointer64Bit() == S_OK) ? 21 : 10;
            OutCtl.Output(" %-*s HSURF      HDEV        Dimensions cjBits %-*s Format\t\t\t",
                          PointerSize, "&SURFACE", PointerSize, "pvBits");
            if (DumpBaseObject) OutCtl.Output(" \tBASEOBJECT");
            if (DumpExtended) OutCtl.Output(" ulShareCount  BaseFlags  dhsurf  SurfFlags");
            if (DumpUserFields) OutCtl.Output(" %s", args);
            OutCtl.Output("\n");

            for (; index < gcMaxHmgr; index++)
            {
                if (OutCtl.GetInterrupt() == S_OK) break;

                // Turn off error and verbose messages for this call to
                // GetObjectAddress since it will spew for non-surfaces.
                if ((hrMask = Client->GetOutputMask(&OutputMask)) == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    hrMask = Client->SetOutputMask(OutputMask & ~(DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE));
                }

                hr = GetObjectAddress(Client, index, &SurfAddr, SURF_TYPE, FALSE, FALSE);

                // Restore mask
                if (hrMask == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    Client->SetOutputMask(OutputMask);
                }

                if (hr != S_OK || SurfAddr == 0) continue;

                OutCtl.Output(" 0x%p ", SurfAddr);

                // Read to fields to OutFilter: 'ppdevNext' and 'fl'
                OutFilter.DiscardOutput();


                hr = TypeReader.OutputVirtual(Module, TypeId, SurfAddr,
                                              DEBUG_OUTTYPE_NO_OFFSET |
                                              DEBUG_OUTTYPE_COMPACT_OUTPUT);

                if (hr == S_OK)
                {
                    if (DumpBaseObject || DumpExtended || DumpUserFields)
                    {
                        OutCtlToFilter.Output("  \t");
                        TypeReader.SelectMarks(1);
                        TypeReader.OutputVirtual(Module, TypeId, SurfAddr,
                                                 DEBUG_OUTTYPE_NO_OFFSET |
                                                 DEBUG_OUTTYPE_COMPACT_OUTPUT);
                        TypeReader.SelectMarks(0);
                    }

                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    OutCtl.Output("\n");
                }
                else
                {
                    OutCtl.Output("0x????%4.4I64x  ** failed to read surface **\n", index);
                }
            }

            hr = S_OK;
        }

        if (MemberList != NULL)
        {
            HeapFree(GetProcessHeap(), 0, MemberList);
        }
    }
    else
    {
        OutCtl.OutErr(" Output state/control setup returned %s.\n",
                      pszHRESULT(hr));
    }

    return hr;
}



/******************************Public*Routine******************************\
* VSURF
*
*   View the contents of a surface
*
\**************************************************************************/

DECLARE_API( vsurf )
{
    HRESULT     hr = S_OK;

    BEGIN_API( vsurf );

    BOOL        BadArg = FALSE;
    BOOL        AddressIsSURFOBJ = FALSE;
    BOOL        AddressIsSURFACE = FALSE;
    BOOL        ArgumentIsHandle = FALSE;

    BOOL        DisplayToDesktop = FALSE;

    PSTR        pszMetaFile = NULL;

    // Values that can be overridden
    DEBUG_VALUE pvScan0 = { 0, DEBUG_VALUE_INVALID};
    DEBUG_VALUE lDelta = { 0, DEBUG_VALUE_INVALID};
    DEBUG_VALUE iBitmapFormat = { -1, DEBUG_VALUE_INVALID};
    DEBUG_VALUE pPal = { 0, DEBUG_VALUE_INVALID};

    // Dimension specifications
    enum {
        left = 0,
        top = 1,
        cx = 2,
        cy = 3,
        right = 2,
        bottom = 3,
    };
    BOOL        GotAllDims = FALSE;
    ULONG       DimsFound = 0;
    BOOL        DimsSpecWxH = FALSE;
    DEBUG_VALUE dim[4];

    // The address or handle
    DEBUG_VALUE SurfSpec = { 0, DEBUG_VALUE_INVALID};

    ULONG       Rem;

    OutputControl   OutCtl(Client);

    if (Client == NULL)
    {
        return E_INVALIDARG;
    }

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Dimensions must be adjacent - raise error later otherwise
            if (DimsFound)
            {
                GotAllDims = TRUE;
            }

            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (ArgumentIsHandle || AddressIsSURFOBJ)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            AddressIsSURFACE = TRUE;
                            args++;
                        }
                        break;
                    case 'b':
                        {
                            args++;
                            if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &pvScan0,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate pvScan0 value from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }

                            if (!BadArg &&
                                Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &lDelta,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate lDelta value from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                        }
                        break;
                    case 'd':
                        DisplayToDesktop = TRUE;
                        args++;
                        break;
                    case 'e':
                        {
                            PCSTR   pszStart;
                            SIZE_T  FileNameLen;

                            // Find beginning of path
                            do
                            {
                                args++;
                            } while (isspace(*args));

                            pszStart = args;

                            if (*pszStart == '\0')
                            {
                                OutCtl.OutErr("Error: Missing EMF filepath.\n");
                                BadArg = TRUE;
                            }
                            else
                            {
                                // Point args beyond path
                                while (*args != '\0' && !isspace(*args))
                                {
                                    args++;
                                }

                                FileNameLen = args - pszStart;
                                pszMetaFile = (PSTR) HeapAlloc(GetProcessHeap(), 0, FileNameLen+4+1);
                                if (pszMetaFile != NULL)
                                {
                                    RtlCopyMemory(pszMetaFile, pszStart, FileNameLen);
                                    pszMetaFile[FileNameLen] = 0;

                                    // Append .emf if needed
                                    if (FileNameLen < 4 ||
                                        _strnicmp(&pszMetaFile[FileNameLen-4], ".emf", 4) != 0)
                                    {
                                        strcat(pszMetaFile, ".emf");
                                    }
                                }
                                else
                                {
                                    OutCtl.OutErr("Failed to allocate memory.\n");
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }
                        break;
                    case 'f':
                        {
                            do
                            {
                                args++;
                            } while (isspace(*args));

                            if (_strnicmp(args, "BMF_", sizeof("BMF_")) == 0)
                            {
                                ENUMDEF *ped = aedBMF;
                                SIZE_T CheckLen;

                                for (ped = aedBMF; ped->psz != NULL; ped++)
                                {
                                    CheckLen = strlen(ped->psz);
                                    if (_strnicmp(args, ped->psz, CheckLen) == 0 &&
                                        !iscsym(args[CheckLen]))
                                    {
                                        iBitmapFormat.I64 = ped->ul;
                                        iBitmapFormat.Type = DEBUG_VALUE_INT64;
                                        break;
                                    }
                                }

                                if (iBitmapFormat.Type != DEBUG_VALUE_INT64)
                                {
                                    BadArg = TRUE;
                                }
                            }
                            else if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                              EVALUATE_DEFAULT_RADIX, &iBitmapFormat,
                                              &Rem, NULL,
                                              EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                BadArg = TRUE;
                            }

                            if (BadArg)
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate iBitmapFormat value from '%s'.\n",
                                              args);
                            }
                        }
                        break;
                    case 'h':
                        if (AddressIsSURFACE || AddressIsSURFOBJ)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            ArgumentIsHandle = TRUE;
                            args++;
                        }
                        break;
                    case 'o':
                        if (ArgumentIsHandle || AddressIsSURFACE)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            AddressIsSURFOBJ = TRUE;
                            args++;
                        }
                        break;
                    case 'p':
                        {
                            args++;
                            if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &pPal,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate PALETTE address from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                        }
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (SurfSpec.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or handle.
                if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &SurfSpec,
                             &Rem, NULL, EVALUATE_COMPACT_EXPR) == S_OK)
                {
                    args += Rem;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate %s from '%s'.\n",
                                  (AddressIsSURFOBJ ?
                                   "SURFOBJ address" :
                                   "address or handle"),
                                  args);
                    BadArg = TRUE;
                }
            }
            else if (!GotAllDims)
            {
                // This argument must be part of dimension specification.

                // Check for 'x' indicating WxH specification
                if (tolower(args[0]) == 'x' && (args[1] == '\0' || isspace(args[1])))
                {
                    if (DimsFound == 3)
                    {
                        args += 2;
                        DimsSpecWxH = TRUE;
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Malformed dimension specification.\n");
                        BadArg = TRUE;
                        break;
                    }
                }
                else
                {
                    if (Evaluate(Client, args, DEBUG_VALUE_INT32,
                                 EVALUATE_DEFAULT_RADIX, &dim[DimsFound],
                                 &Rem, NULL, EVALUATE_COMPACT_EXPR) == S_OK)
                    {
                        args += Rem;
                        DimsFound++;

                        GotAllDims = (DimsFound == 4);
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Couldn't evaluate dimension from '%s'.\n",
                                      args);
                        BadArg = TRUE;
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Error: Unexpected argument at '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (hr == S_OK)
    {
        if (!BadArg)
        {
            if (DimsFound == 1 || DimsFound == 3)
            {
                OutCtl.OutErr("Error: Missing part of dimensions.\n");
                BadArg = TRUE;
            }
            else if (SurfSpec.Type == DEBUG_VALUE_INVALID)
            {
                OutCtl.OutErr("Error: Missing address or handle.\n");
                BadArg = TRUE;
            }
            else if (SurfSpec.I64 == 0)
            {
                OutCtl.OutErr("Error: Invalid (0) address or handle.\n");
                BadArg = TRUE;
            }
            else if (!DimsSpecWxH && DimsFound == 4)
            {
                dim[cx].I32 = dim[right].I32 - dim[left].I32;
                dim[cy].I32 = dim[bottom].I32 - dim[top].I32;
                if ((LONG)dim[cx].I32 < 0 ||
                    (LONG)dim[cy].I32 < 0)
                {
                    OutCtl.OutErr("Error: Invalid dimensions.\n");
                    BadArg = TRUE;
                }
            }
        }

        if (BadArg)
        {
            if (*args == '?') OutCtl.Output("View (or save) the contents of a surface\n");

            OutCtl.Output("\n"
                          "Usage: vsurf [-?bdefp] < [-h] HSURF | [-a] SURFACE Addr | -o SURFOBJ Addr> [Dimensions]\n"
                          "  b <pvScan0> <lDelta>  - Override those fields from surface\n"
                          "                           Zero values will not override\n"
                          "  d                     - Blt contents to (0,0) on the desktop\n"
                          "  e <Filepath>          - Full path to save surface as an EMF\n"
                          "  f <iBitmapFormat>     - Overrides bitmap format\n"
                          "  p <PALETTE Addr>      - Specifies PALETTE to use for indexed surfaces\n"
                          "  Dimensions = Left Top [Right Bottom | Width x Height]\n"
                          "\n"
                          "  Notes:\n"
                          "    HBITMAP is the same as HSURF.\n"
                          "    When not saving to a file, a window will be opened.\n"
                          "     -> Use GDIView.exe if debugging remotely.\n");
        }
        else
        {
            PDEBUG_SYMBOLS      Symbols = NULL;
            PDEBUG_DATA_SPACES  Data = NULL;
            ULONG64             SurfAddr;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) != S_OK ||
                (hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                             (void **)&Data)) != S_OK)
            {
                OutCtl.OutErr("Error setting up debugger interface.\n");
            }
            else
            {
                if (AddressIsSURFOBJ)
                {
                    ULONG64 SurfModule = 0;
                    ULONG   SurfTypeId = 0;
                    ULONG   SurfObjOffset;
                    ULONG   BaseObjTypeId = 0;

                    // Try to read SURFOBJ offset from SURFACE type, but
                    // if that fails assume it is directly after BASEOBJECT.
                    if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                        (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                    {
                        if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                        {
                            hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                        }
                    }

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("Error: SURFOBJ to SURFACE lookup failed.\n");
                    }
                    else
                    {
                        SurfAddr = SurfSpec.I64 - SurfObjOffset;
                    }
                }
                else if (AddressIsSURFACE)
                {
                    SurfAddr = SurfSpec.I64;
                }
                else
                {
                    hr = GetObjectAddress(Client, SurfSpec.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

                    if (hr != S_OK)
                    {
                        if (ArgumentIsHandle)
                        {
                            OutCtl.OutErr(" 0x%p is not a valid HSURF\n", SurfSpec.I64);
                        }
                        else
                        {
                            SurfAddr = SurfSpec.I64;
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        ArgumentIsHandle = TRUE;
                    }
                }
            }

            if (hr == S_OK)
            {
                enum {
                    SF_hHmgr,
                    //SF_ulShareCount,
                    //SF_cExclusiveLock,
                    //SF_Tid,
                    SF_so_dhsurf,
                    SF_so_hsurf,
                    SF_so_dhpdev,
                    SF_so_hdev,
                    SF_so_sizlBitmap_cx,
                    SF_so_sizlBitmap_cy,
                    SF_so_cjBits,
                    SF_so_pvBits,
                    SF_so_pvScan0,
                    SF_so_lDelta,
                    SF_so_iUniq,
                    SF_so_iBitmapFormat,
                    SF_so_iType,
                    SF_so_fjBitmap,
                    //SF_pdcoAA,
                    //SF_SurfFlags,
                    SF_pPal,
                    //SF_EBitmap_hdc,
                    //SF_EBitmap_cRef,
                    //SF_EBitmap_hpalHint,
                    //SF_EBitmap_sizlDim_cx,
                    //SF_EBitmap_sizlDim_cy,

                    SF_TOTAL
                };

                DEBUG_VALUE         SurfValues[SF_TOTAL];
                DEBUG_VALUE         ObjHandle;
                TypeOutputParser    SurfParser(Client);     // SURFACE dump
                OutputFilter        OutFilter(Client);      // For other misc types
                OutputState         OutState(Client);
                OutputControl       OutCtlToFilter;
                ULONG64             SurfAddrFromHmgr;
                CHAR                szFallbackDTCmd[128];

                struct {
                    BITMAPINFOHEADER    bmiHeader;
                    DWORD               bmiColors[256];
                } bmi;


                for (int svi = 0; svi < SF_TOTAL; svi++)
                {
                    SurfValues[svi].Type = DEBUG_VALUE_INVALID;
                }

                if ((hr = OutState.Setup(0, &SurfParser)) != S_OK ||
                    ((hr = OutState.OutputTypeVirtual(SurfAddr,
                                                      "SURFACE",
                                                      DEBUG_OUTTYPE_BLOCK_RECURSE)) != S_OK &&
                     ((sprintf(szFallbackDTCmd,
                               "dt " GDIType(SURFACE) " hHmgr -y so. -y so.sizlBitmap. pPal 0x%I64x",
                               SurfAddr) == 0) ||
                      (hr = OutState.Execute(szFallbackDTCmd)) != S_OK)) ||
                    (hr = SurfParser.Get(&SurfValues[SF_hHmgr],
                                         "hHmgr",
                                         DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get contents of SURFACE::hHmgr\n");
                    OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    if (AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr(" 0x%p is not a valid SURFOBJ address\n", SurfSpec.I64);
                    }
                    else if (AddressIsSURFACE)
                    {
                        OutCtl.OutErr(" 0x%p is not a valid SURFACE address\n", SurfSpec.I64);
                    }
                    else if (ArgumentIsHandle)
                    {
                        OutCtl.OutErr(" although 0x%p is a valid HSURF\n", SurfSpec.I64);
                    }
                    else
                    {
                        OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFACE address\n", SurfSpec.I64);
                    }
                }
                else if ((hr = OutState.Setup(0, &OutFilter)) != S_OK ||
                         (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                                         DEBUG_OUTCTL_NOT_LOGGED |
                                                         DEBUG_OUTCTL_OVERRIDE_MASK,
                                                         OutState.Client)) != S_OK)
                {
                    OutCtl.OutErr("Error preparing misc type reader.\n");
                }
                else
                {
                    if (!ArgumentIsHandle)
                    {
                        if (GetObjectAddress(Client, SurfValues[SF_hHmgr].I64, &SurfAddrFromHmgr,
                                             SURF_TYPE, TRUE, FALSE) == S_OK &&
                            SurfAddrFromHmgr != SurfAddr)
                        {
                            OutCtl.OutWarn("\tNote: SURFACE may not be valid.\n"
                                           "\t      It does not have a valid handle manager entry.\n");
                        }
                    }

                    if (SurfParser.Get(&SurfValues[SF_so_hsurf], "hsurf", DEBUG_VALUE_INT64) != S_OK)
                    {
                        OutCtl.OutWarn("Warning: Couldn't read hsurf.\n");
                    }
                    else
                    {
                        if (SurfValues[SF_so_hsurf].I64 != SurfValues[SF_hHmgr].I64)
                        {
                            OutCtl.OutWarn("Warning: hsurf, 0x%p, != hHmgr, 0x%p.\n",
                                           SurfValues[SF_so_hsurf].I64,
                                           SurfValues[SF_hHmgr].I64);
                        }
                    }

                    // Check dimensions
                    if (DimsFound < 2)
                    {
                        dim[left].I32 = 0;
                        dim[top].I32 = 0;
                    }

                    if ((hr = SurfParser.Get(&SurfValues[SF_so_sizlBitmap_cx], "cx", DEBUG_VALUE_INT32)) != S_OK ||
                        (hr = SurfParser.Get(&SurfValues[SF_so_sizlBitmap_cy], "cy", DEBUG_VALUE_INT32)) != S_OK)
                    {
                        if (DimsFound == 4 && dim[cx].Type == DEBUG_VALUE_INT32 && dim[cy].Type == DEBUG_VALUE_INT32)
                        {
                            hr = S_OK;
                            bmi.bmiHeader.biWidth = dim[cx].I32;
                            bmi.bmiHeader.biHeight = dim[cy].I32;
                        }
                        else
                        {
                            OutCtl.OutErr("Error: Couldn't get SURFACE dimensions.\n");
                        }
                    }
                    else
                    {
                        bmi.bmiHeader.biWidth = SurfValues[SF_so_sizlBitmap_cx].I32;
                        bmi.bmiHeader.biHeight = SurfValues[SF_so_sizlBitmap_cy].I32;

                        bmi.bmiHeader.biWidth -= dim[left].I32;
                        bmi.bmiHeader.biHeight -= dim[top].I32;

                        if (DimsFound == 4)
                        {
                            if ((LONG)dim[cx].I32 < bmi.bmiHeader.biWidth)
                            {
                                bmi.bmiHeader.biWidth = (LONG)dim[cx].I32;
                            }
                            if ((LONG)dim[cy].I32 < bmi.bmiHeader.biHeight)
                            {
                                bmi.bmiHeader.biHeight = (LONG)dim[cy].I32;
                            }
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (bmi.bmiHeader.biWidth <= 0)
                        {
                            OutCtl.OutWarn("Error: Invalid x dimensions.\n");
                            hr = S_FALSE;
                        }
                        else if (bmi.bmiHeader.biHeight <= 0)
                        {
                            OutCtl.OutWarn("Error: Invalid y dimensions.\n");
                            hr = S_FALSE;
                        }
                    }

                    // Check pvScan0
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_pvScan0], "pvScan0", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (pvScan0.Type == DEBUG_VALUE_INT64 && pvScan0.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get address of first scanline.\n");
                                if (SurfParser.Get(&SurfValues[SF_so_dhsurf], "dhsurf", DEBUG_VALUE_INT64) == S_OK)
                                {
                                    OutCtl.Output(" dhsurf is 0x%p.\n", SurfValues[SF_so_dhsurf].I64);
                                }
                            }
                        }
                        else if (SurfValues[SF_so_pvScan0].I64 == 0 &&
                                 pvScan0.Type == DEBUG_VALUE_INT64 &&
                                 pvScan0.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding pvScan0, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_pvScan0].I64,
                                           pvScan0.I64);
                        }
                        else
                        {
                            pvScan0 = SurfValues[SF_so_pvScan0];
                        }
                    }

                    // Check lDelta
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_lDelta], "lDelta", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (lDelta.Type == DEBUG_VALUE_INT64 && lDelta.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get SURFACE lDelta.\n");
                                if (SurfParser.Get(&SurfValues[SF_so_dhsurf], "dhsurf", DEBUG_VALUE_INT64) == S_OK)
                                {
                                    OutCtl.Output(" dhsurf is 0x%p.\n", SurfValues[SF_so_dhsurf].I64);
                                }
                            }
                        }
                        else if (SurfValues[SF_so_lDelta].I64 == 0 &&
                                 lDelta.Type == DEBUG_VALUE_INT64 &&
                                 lDelta.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding lDelta, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_lDelta].I64,
                                           lDelta.I64);
                        }
                        else
                        {
                            lDelta = SurfValues[SF_so_lDelta];
                        }
                    }

                    // Check iBitmapFormat
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_iBitmapFormat], "iBitmapFormat", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (iBitmapFormat.Type == DEBUG_VALUE_INT64 && iBitmapFormat.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get SURFACE iBitmapFormat.\n");
                            }
                        }
                        else if (SurfValues[SF_so_iBitmapFormat].I64 == 0 &&
                                 iBitmapFormat.Type == DEBUG_VALUE_INT64 &&
                                 iBitmapFormat.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding iBitmapFormat, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_iBitmapFormat].I64,
                                           iBitmapFormat.I64);
                        }
                        else
                        {
                            iBitmapFormat = SurfValues[SF_so_iBitmapFormat];
                        }
                    }

                    if (hr == S_OK)
                    {
                        bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
                        bmi.bmiHeader.biPlanes = 1;
                        bmi.bmiHeader.biCompression = BI_RGB;

                        bmi.bmiHeader.biSizeImage = 0;
                        bmi.bmiHeader.biXPelsPerMeter = bmi.bmiHeader.biYPelsPerMeter = 0;
                        bmi.bmiHeader.biClrUsed = 0;
                        bmi.bmiHeader.biClrImportant = 0;

                        if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_32BPP)
                        {
                            bmi.bmiHeader.biBitCount = 32;
                        }
                        else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_24BPP)
                        {
                            bmi.bmiHeader.biBitCount = 24;
                        }
                        else
                        {
                            if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_16BPP)
                            {
                                bmi.bmiHeader.biBitCount = 16;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_8BPP)
                            {
                                bmi.bmiHeader.biBitCount = 8;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_4BPP)
                            {
                                bmi.bmiHeader.biBitCount = 4;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_1BPP)
                            {
                                bmi.bmiHeader.biBitCount = 1;
                            }
                            else
                            {
                                OutCtl.OutErr("Unrecognized iBitmapFormat %ld.\n", SurfValues[SF_so_iBitmapFormat].I32);
                                hr = S_FALSE;
                            }
                        }
                    }

                    if (hr == S_OK && bmi.bmiHeader.biBitCount < 24)
                    {
                        // Get PALETTE
                        if (SurfParser.Get(&SurfValues[SF_pPal], "pPal", DEBUG_VALUE_INT64) == S_OK)
                        {
                            if (pPal.Type == DEBUG_VALUE_INT64)
                            {
                                if (SurfValues[SF_pPal].I64 != 0 &&
                                    pPal.I64 != SurfValues[SF_pPal].I64)
                                {
                                    OutCtl.OutWarn(" Overriding PALETTE address, 0x%p, with 0x%p.\n",
                                                   SurfValues[SF_pPal].I64,
                                                   pPal.I64);
                                }
                            }
                            else
                            {
                                pPal = SurfValues[SF_pPal];
                            }
                        }
                        else if (pPal.Type != DEBUG_VALUE_INT64)
                        {
                            OutCtl.OutWarn(" Error reading PALETTE address from SURFACE.\n");
                        }

                        // Try getting the PALETTE from the PDEV if need be
                        if (pPal.Type != DEBUG_VALUE_INT64 || pPal.I64 == 0)
                        {
                            if ((hr = SurfParser.Get(&SurfValues[SF_so_hdev], "hdev", DEBUG_VALUE_INT64)) == S_OK &&
                                SurfValues[SF_so_hdev].I64 != 0)
                            {
                                OutFilter.DiscardOutput();

                                if ((hr = OutState.OutputTypeVirtual(SurfValues[SF_so_hdev].I64, "PDEV", 0)) != S_OK ||
                                    (hr = OutFilter.Query("ppalSurf", &pPal, DEBUG_VALUE_INT64)) != S_OK)
                                {
                                    OutCtl.OutErr(" Error reading PALETTE address from PDEV.\n");
                                    pPal.Type = DEBUG_VALUE_INVALID;
                                }
                            }
                        }

                        // Read PALETTE settings
                        if (pPal.Type == DEBUG_VALUE_INT64 && pPal.I64 != 0)
                        {
                            PCSTR   ReqPALETTEFields[] = {
                                "flPal",
                                "cEntries",
                                "apalColor",
                                NULL
                            };

                            TypeOutputDumper    PALReader(OutState.Client, &OutCtlToFilter);
                            DEBUG_VALUE         cEntries;
                            DEBUG_VALUE         ppalColor;
                            BOOL                Check565 = FALSE;
                            BOOL                Check555 = FALSE;

                            PALReader.IncludeMarked();
                            PALReader.MarkFields(ReqPALETTEFields);

                            OutFilter.DiscardOutput();

                            if ((hr = PALReader.OutputVirtual("PALETTE", pPal.I64)) == S_OK &&
                                (hr = OutFilter.Query("cEntries", &cEntries, DEBUG_VALUE_INT32)) == S_OK)
                            {
                                bmi.bmiHeader.biClrUsed = cEntries.I32;

                                if ((hr = OutFilter.Query("PAL_FIXED")) != S_OK &&
                                    (hr = OutFilter.Query("PAL_INDEXED")) != S_OK)
                                {
                                    OutCtl.OutErr(" Error: vsurf only supports fixed and indexed palettes.\n");
                                }
                                else if (OutFilter.Query("PAL_BITFIELDS") == S_OK)
                                {
                                    if (bmi.bmiHeader.biClrUsed > 0)
                                    {
                                        OutCtl.OutErr(" Error: PALETTE @ 0x%p is BITFIELDS, but has Entries.\n", pPal.I64);
                                        hr = S_FALSE;
                                    }
                                    else
                                    {
                                        bmi.bmiHeader.biCompression = BI_BITFIELDS;
                                        bmi.bmiHeader.biClrUsed = 3;

                                        if (OutFilter.Query("PAL_RGB16_565") == S_OK)
                                        {
                                            Check565 = TRUE;
                                        }
                                        else if (OutFilter.Query("PAL_RGB16_555") == S_OK)
                                        {
                                            Check555 = TRUE;
                                        }
                                        else
                                        {
                                            OutCtl.OutWarn(" Warning: Nonstandard bitfields format in PALETTE @ 0x%p.\n",
                                                          pPal.I64);
                                        }
                                    }
                                }

                                if (hr == S_OK && bmi.bmiHeader.biClrUsed > 0)
                                {
                                    if (bmi.bmiHeader.biClrUsed > 256 ||
                                        OutFilter.Query("apalColor", &ppalColor, DEBUG_VALUE_INT64) != S_OK ||
                                        ppalColor.I64 == 0)
                                    {
                                        OutCtl.OutErr(" Error: PALETTE @ 0x%p is invalid.\n", pPal.I64);
                                        hr = S_FALSE;
                                    }
                                    else
                                    {
                                        ULONG PALBytes = bmi.bmiHeader.biClrUsed * sizeof(DWORD);
                                        ULONG BytesRead;

                                        OutCtl.OutVerb("Reading %ld palette entries @ 0x%p.\n", 
                                                       bmi.bmiHeader.biClrUsed, ppalColor.I64);

                                        hr = Data->ReadVirtual(ppalColor.I64, bmi.bmiColors, PALBytes, &BytesRead);
                                        if (hr != S_OK)
                                        {
                                            OutCtl.OutErr("Error: Couldn't read any PALETTE entries at 0x%p.\n", ppalColor.I64);
                                        }
                                        else if (BytesRead != PALBytes)
                                        {
                                            OutCtl.OutErr("Error: Only read %lu of %lu bytes from PALETTE entries at 0x%p.\n",
                                                          BytesRead,
                                                          PALBytes,
                                                          ppalColor.I64);
                                            hr = S_FALSE;
                                        }
                                        else
                                        {
                                            if (Check565)
                                            {
                                                if (bmi.bmiColors[0] != 0xf800 ||
                                                    bmi.bmiColors[1] != 0x07e0 ||
                                                    bmi.bmiColors[2] != 0x001f)
                                                {
                                                    OutCtl.OutWarn(" Palette bitfields don't match standard 565 format.\n");
                                                }
                                            }
                                            else if (Check555)
                                            {
                                                if (bmi.bmiColors[0] != 0x7c00 ||
                                                    bmi.bmiColors[1] != 0x03e0 ||
                                                    bmi.bmiColors[2] != 0x001f)
                                                {
                                                    OutCtl.OutWarn(" Palette bitfields don't match standard 555 format.\n");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                OutCtl.OutErr(" Error reading PALETTE.\n");
                            }
                        }
                        else
                        {
                            OutCtl.OutErr("Error: Unable to obtain valid PALETTE address.\n");
                            if (hr == S_OK) hr = S_FALSE;
                        }
                    }

                    if (hr == S_OK)
                    {
                        // We have all the format information we need from the target.
                        ULONG       FirstBit = dim[left].I32*bmi.bmiHeader.biBitCount;
                        LONG        xOrigin;
                        LONG        Width;
                        HBITMAP     hBitmap;
                        LPVOID      pDIBits;

                        if (SurfParser.Get(&SurfValues[SF_so_iUniq], "iUniq", DEBUG_VALUE_INT32) != S_OK)
                        {
                            SurfValues[SF_so_iUniq].I32 = 0;
                        }

                        // Save original width and adjust for full byte reads if needed
                        xOrigin = (LONG)(FirstBit & 0x7);
                        Width = (LONG)bmi.bmiHeader.biWidth;
                        bmi.bmiHeader.biWidth += (FirstBit & 0x7);
                        bmi.bmiHeader.biWidth = (bmi.bmiHeader.biWidth + 0x7) & ~0x7;

                        // Create a Top-Down DIB Section
                        bmi.bmiHeader.biHeight = -bmi.bmiHeader.biHeight;

                        hBitmap = CreateDIBSection(NULL, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS, &pDIBits, NULL, 0);

                        if (hBitmap)
                        {
                            DIBSECTION  ds;

                            if (GetObject(hBitmap, sizeof(ds), &ds) != 0)
                            {
                                HRESULT hr = S_OK;
                                PBYTE   pBits = (PBYTE)pDIBits;
                                ULONG64 ScanAddr = pvScan0.I64;
                                ULONG   ScanSize;
                                ULONG   ScanBytesRead;
                                BOOL    GoodRead = FALSE;
                                LONG    LastScanWithData = -1;

                                ScanSize = ds.dsBm.bmWidthBytes;

                                ScanAddr += FirstBit/8 + dim[top].I32*lDelta.I64;

                                for (LONG y = 0; y < ds.dsBm.bmHeight; y++)
                                {
                                    OutCtl.Output(".");
                                    if (y % 70 == 69) OutCtl.Output("%ld%% read\n", 100*y/ds.dsBm.bmHeight);

                                    if (OutCtl.GetInterrupt() == S_OK)
                                    {
                                        break;
                                    }

                                    if ((hr = Data->ReadVirtual(ScanAddr, pBits, ScanSize, &ScanBytesRead)) != S_OK)
                                    {
                                        ScanBytesRead = 0;
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        GoodRead = TRUE;
                                    }

                                    if (ScanBytesRead != ScanSize)
                                    {
                                        if (LastScanWithData+1 == y || ScanBytesRead != 0)
                                        {
                                            OutCtl.OutErr("ReadVirtual(0x%p) failed read @ 0x%p (scan %ld).\n", ScanAddr, ScanAddr+ScanBytesRead, y);
                                        }
                                        RtlZeroMemory(pBits+ScanBytesRead,ScanSize-ScanBytesRead);

                                        // If this scan crosses into next page,
                                        // try reading a partial scan from that page.
                                        if (ScanBytesRead == 0 && PageSize != 0)
                                        {
                                            ULONG64 NextPage;
                                            ULONG ReadSize;

                                            for (NextPage = (ScanAddr + PageSize) & ~((ULONG64)PageSize-1);
                                                 NextPage < ScanAddr + ScanSize;
                                                 NextPage += PageSize
                                                 )
                                            {
                                                ReadSize = ScanSize - (ULONG)(NextPage - ScanAddr);
                                                if (Data->ReadVirtual(NextPage, pBits + ScanSize - ReadSize, ReadSize, &ScanBytesRead) == S_OK)
                                                {
                                                    GoodRead = TRUE;
                                                    if (ScanBytesRead != 0)
                                                    {
                                                        OutCtl.OutErr("Partial scan read of %lu bytes succeeded @ 0x%p (scan %ld).\n", ScanBytesRead, NextPage, y);
                                                        if (ScanBytesRead == ReadSize) break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (ScanBytesRead != 0)
                                    {
                                        if (LastScanWithData+1 != y && ScanBytesRead == ScanSize)
                                        {
                                            OutCtl.OutErr("Next fully successful ReadVirtual @ 0x%p (scan %ld).\n", ScanAddr, y);
                                        }
                                        LastScanWithData = y;
                                    }

                                    pBits += ScanSize;
                                    ScanAddr += lDelta.I64;
                                }

                                OutCtl.Output("\n");

                                if (LastScanWithData + 1 != ds.dsBm.bmHeight)
                                {
                                    OutCtl.OutErr("Scans %ld to %ld weren't read.\n",
                                                  LastScanWithData + 1,
                                                  ds.dsBm.bmHeight - 1);
                                }

                                SURF_INFO   SurfInfo = { {0}, hBitmap,
                                                        xOrigin,
                                                        0,
                                                        Width,
                                                        ds.dsBm.bmHeight,
                                                        ds.dsBm.bmBitsPixel
                                                        };

                                _stprintf(SurfInfo.SurfName,
                                          "%s @ 0x%I64x (%lu,%lu)-(%lu,%lu) [Uniq=0x%lx]",
                                          ((AddressIsSURFOBJ) ?
                                            _T("SURFOBJ") :
                                            _T("SURFACE")),
                                          ((AddressIsSURFOBJ) ?
                                            SurfSpec.I64 :
                                            SurfAddr),
                                          dim[left].I32,
                                          dim[top].I32,
                                          dim[left].I32 + Width,
                                          dim[top].I32 + ds.dsBm.bmHeight,
                                          SurfValues[SF_so_iUniq].I32);

                                if (GoodRead)
                                {
                                    OutCtl.OutVerb("%s %s\n",
                                                   ((pszMetaFile != NULL) ?
                                                    "Saving" : "Displaying"),
                                                   SurfInfo.SurfName);
                                }

                                if (!GoodRead)
                                {
                                    OutCtl.OutErr("No image data was read.\n");
                                    DeleteObject(hBitmap);
                                }
                                else if (pszMetaFile != NULL || DisplayToDesktop)
                                {
                                    HDC hdcSurface = CreateCompatibleDC(NULL);

                                    if (hdcSurface == NULL ||
                                        SelectObject(hdcSurface, hBitmap) == NULL)
                                    {
                                        OutCtl.OutErr("Error: Failed to prepare captured surface for Blt.\n");
                                        OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                    }
                                    else
                                    {
                                        if (pszMetaFile != NULL)
                                        {
                                            HDC hdcMeta = CreateEnhMetaFile(NULL, pszMetaFile, NULL, SurfInfo.SurfName);

                                            if (hdcMeta == NULL ||
                                                !BitBlt(hdcMeta, 0, 0, Width, ds.dsBm.bmHeight,
                                                        hdcSurface, xOrigin, 0, SRCCOPY))
                                            {
                                                OutCtl.OutErr("Error: Save to metafile failed.\n");
                                                OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                            }

                                            DeleteEnhMetaFile(CloseEnhMetaFile(hdcMeta));
                                        }

                                        if (DisplayToDesktop)
                                        {
                                            HDC hdcScreen = GetDC(NULL);

                                            if (hdcScreen == NULL ||
                                                !Rectangle(hdcScreen, 0, 0, ds.dsBm.bmWidth+2, ds.dsBm.bmHeight+2) ||
                                                !BitBlt(hdcScreen, 1, 1, Width, ds.dsBm.bmHeight,
                                                        hdcSurface, xOrigin, 0, SRCCOPY))
                                            {
                                                OutCtl.OutErr("Error: Display to screen failed.\n");
                                                OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                            }

                                            ReleaseDC(NULL, hdcScreen);
                                        }
                                    }

                                    DeleteObject(hBitmap);
                                    DeleteDC(hdcSurface);
                                }
                                else if (CreateViewer(Client, &SurfInfo) == 0)
                                {
                                    OutCtl.OutErr("CreateViewer failed.\n");
                                    DbgPrint("CreateViewer failed.\n");
                                    DeleteObject(hBitmap);
                                }
                            }
                            else
                            {
                                OutCtl.OutErr("GetDIBits failed.\n");
                                DeleteObject(hBitmap);
                            }
                        }
                        else
                        {
                            OutCtl.OutErr("CreateDIBSection failed.\n");
                            OutCtl.OutVerb(" GetLastError: 0x%lx.\n", GetLastError());
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Couldn't read required SURFACE fields.\n");
                    }
                }
            }

            if (Data != NULL) Data->Release();
            if (Symbols != NULL) Symbols->Release();
        }
    }

    if (pszMetaFile != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pszMetaFile);
    }

    return hr;
}


                                
LONG
DebuggerExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    PDEBUG_CLIENT Client,
    PCSTR Interface,
    PCSTR Func
    )
{
    // Any references to objects will be leaked.

    OutputControl   OutCtl(Client);
    CHAR            szBuffer[80];

    if (Interface != NULL && Func != NULL)
    {
        OutCtl.OutErr("%08x Exception in debugger %s.%s.\n",
                      ExceptionInfo->ExceptionRecord->ExceptionCode,
                      Interface,
                      Func
                      );
    }
    else
    {
        OutCtl.OutErr("%08x Exception in extension %s.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Func
               );
    }

    StringCbPrintfA(szBuffer, sizeof(szBuffer),
              "      PC: 0x%p  ExceptionInformation: 0x%p 0x%p 0x%p\n",
                  ExceptionInfo->ExceptionRecord->ExceptionAddress,
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[2]
              );
    OutCtl.OutErr("%s", szBuffer);

    return EXCEPTION_EXECUTE_HANDLER;
}


HRESULT
AssembleTempRoutine(
    PDEBUG_CLIENT Client,
    Instruction *instructions,
    PCSTR Arguments
    )
{
    static BOOL                 CodeWritten = FALSE;
    static PDEBUG_CONTROL2      Control = NULL;
    static PDEBUG_DATA_SPACES   Data = NULL;
    static PDEBUG_REGISTERS     Registers = NULL;
    static PDEBUG_SYMBOLS       Symbols = NULL;
    static ULONG                RegisterCount = 0;
    static PDEBUG_VALUE         SavedRegisters = NULL;
    static ULONG64              IP = 0;
    static BYTE                 OldCode[256] = "";
    static ULONG                CodeRead = 0;
    static ULONG64              FinalIP = 0;

    HRESULT         hr;
    OutputControl   OutCtl(Client);

    ULONG           CodeRestored;

    if (!CodeWritten && RegisterCount == 0)
    {
        if ((hr = Client->QueryInterface(__uuidof(IDebugControl2),
                                         (void **)&Control)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&Registers)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) == S_OK)
        {
            DEBUG_VALUE     Argument;
            ULONG           Rem;

            ULONG64         LimitIP;
            ULONG64         AsmIP;
            ULONG64         StartIP;
            ULONG64         EndIP;
            ULONG           CodeEmitted;

            if (hr == S_OK &&
                (hr = Registers->GetInstructionOffset(&IP)) == S_OK &&
                (hr = Data->ReadVirtual(IP, OldCode, sizeof(OldCode), &CodeRead)) == S_OK &&
                CodeRead == sizeof(OldCode))
            {
                OutCtl.Output("Code from 0x%p to 0x%p saved.\n", IP, IP+CodeRead);

                LimitIP = IP + CodeRead - 0x20;     // Enough space for any instruction
                StartIP = EndIP = IP;

                for (int i = 0; hr == S_OK && instructions[i].Code != NULL; i++)
                {
                    AsmIP = EndIP;

                    if (AsmIP > LimitIP)
                    {
                        OutCtl.OutErr("\nError: There may not be enough code saved to assemble @ 0x%p.\n"
                                      "\n       Aborting to be on the safe side.",
                                      AsmIP);

                        hr = E_OUTOFMEMORY;
                    }

                    if (hr == S_OK &&
                        instructions[i].Flags & I_WRITE_ADDRESS)
                    {
                        hr = Evaluate(Client, Arguments,
                                      DEBUG_VALUE_INT32, EVALUATE_DEFAULT_RADIX,
                                      &Argument, &Rem, NULL, EVALUATE_COMPACT_EXPR);

                        if (hr == S_OK)
                        {
                            Arguments += Rem;
                        }
                        else
                        {
                            OutCtl.OutErr("\nMissing address for instruction %#lu '%s'",
                                          i,
                                          (instructions[i].ByteLen == 0) ?
                                           instructions[i].Code :
                                           "Emitted Bytes");
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (instructions[i].Flags & I_START_IP)
                        {
                            StartIP = AsmIP;
                        }

                        OutCtl.Output(".");
                        if (instructions[i].ByteLen > 0)
                        {
                            OutCtl.OutVerb(" Emitting %lu bytes @ 0x%p...\n",
                                          instructions[i].ByteLen, AsmIP);
                            hr = Data->WriteVirtual(AsmIP, instructions[i].Code, instructions[i].ByteLen, &CodeEmitted);
                            if (hr == S_OK)
                            {
                                if (CodeEmitted == instructions[i].ByteLen)
                                    EndIP = AsmIP + CodeEmitted;
                                else
                                    hr = E_FAIL;
                            }
                        }
                        else
                        {
                            OutCtl.OutVerb(" Assembling '%s' @ 0x%p...\n", instructions[i].Code, AsmIP);
                            hr = Control->Assemble(AsmIP, instructions[i].Code, &EndIP);
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (instructions[i].Flags & I_WRITE_ADDRESS)
                        {
                            hr = Data->WriteVirtual(EndIP-sizeof(Argument.I32),
                                                    &Argument.I32,
                                                    sizeof(Argument.I32),
                                                    &CodeEmitted);
                            if (hr == S_OK)
                            {
                                if (CodeEmitted != sizeof(Argument.I32))
                                {
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    OutCtl.OutVerb("   Wrote argument 0x%lx at 0x%p.\n",
                                                   Argument.I32,
                                                   EndIP - sizeof(Argument.I32));
                                }
                            }

                            if (hr != S_OK)
                            {
                                OutCtl.Output("\nCouldn't write argument at 0x%p.",
                                              EndIP - sizeof(Argument.I32));
                            }
                        }
                    }
                }

                OutCtl.Output("\n");

                if (hr == S_OK)
                {
                    FinalIP = AsmIP;

                    if (EndIP - IP > sizeof(OldCode))
                    {
                        OutCtl.OutErr("Error: Didn't save enough code!\n"
                                      "  Code from 0x%p to 0x%p was trashed.\n",
                                      IP + sizeof(OldCode), EndIP);
                        hr = E_FAIL;
                    }
                }

                if (hr == S_OK)
                {
                    // Save registers
                    if ((hr = Registers->GetNumberRegisters(&RegisterCount)) == S_OK)
                    {
                        SavedRegisters = (PDEBUG_VALUE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DEBUG_VALUE)*RegisterCount);
                        if (SavedRegisters != NULL)
                        {
                            if ((hr = Registers->GetValues(RegisterCount, NULL, 0, SavedRegisters)) != S_OK)
                            {
                                HeapFree(GetProcessHeap(), 0, SavedRegisters);
                                SavedRegisters = NULL;
                                RegisterCount = 0;
                            }
                            else
                            {
                                OutCtl.OutVerb(" Saved %lu registers.\n", RegisterCount);
                            }
                        }
                        else
                        {
                            RegisterCount = 0;
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (hr != S_OK)
                    {
                        OutCtl.Output("Error saving register values.\n");
                    }
                }

                if (hr == S_OK)
                {
                    CHAR    szDisasmCmd[64];

                    OutCtl.Output(" Temporary routine placed from 0x%p to 0x%p.\n",
                                  IP, EndIP);
                    OutCtl.Output("Please verify code, especially jumps:\n");
                    sprintf(szDisasmCmd, "u 0x%I64x 0x%I64x", IP, EndIP);
                    Control->Execute(DEBUG_OUTCTL_THIS_CLIENT,
                                     szDisasmCmd,
                                     DEBUG_EXECUTE_NOT_LOGGED |
                                     DEBUG_EXECUTE_NO_REPEAT);
                    OutCtl.Output("Then set IP to 0x%p and run machine.\n", StartIP);

                    CodeWritten = TRUE;
                }
                else
                {
                    if (Data->WriteVirtual(IP, OldCode, CodeRead, &CodeRestored) != S_OK ||
                        CodeRestored != CodeRead)
                    {
                        OutCtl.OutErr("Error restoring original code.\n");
                    }
                }
            }
        }
    }
    else
    {
        HRESULT hrGetIP;
        ULONG64 ResultIP;
        HRESULT hrRestore = S_OK;

        hr = S_OK;

        if ((hrGetIP = Registers->GetInstructionOffset(&ResultIP)) == S_OK)
        {
            if (ResultIP != FinalIP)
            {
                OutCtl.OutWarn("Result IP = 0x%p differs from expected 0x%p.\n",
                               ResultIP, FinalIP);
            }
        }
        else
        {
            OutCtl.OutWarn("Unable to confirm result IP.\n");
            ResultIP = (FinalIP == 0) ? -1 : 0;
        }

        if (CodeWritten)
        {
            if (ResultIP == FinalIP ||
                (hrRestore = GetYNInput((PDEBUG_CONTROL)Control, "Restore code anyway?")) == S_OK)
            {
                if ((hr = Data->WriteVirtual(IP, OldCode, CodeRead, &CodeRestored)) == S_OK &&
                    CodeRestored == CodeRead)
                {
                    CodeWritten = FALSE;
                    IP = 0;

                    OutCtl.Output("Original code restored.\n");

                }
                else
                {
                    OutCtl.OutErr("Error restoring original code.\n");
                    if (hr == S_OK) hr = E_FAIL;
                }
            }
        }

        if (hr == S_OK &&
            RegisterCount != 0)
        {
            if (ResultIP == FinalIP ||
                (hrRestore = GetYNInput((PDEBUG_CONTROL)Control, "Restore register values anyway?")) == S_OK)
            {
                DEBUG_VALUE     NewRegValue;
                ULONG           Register;

                for (Register = 0; Register < RegisterCount && hr == S_OK; Register++)
                {
                    __try {
                        hr = Registers->SetValue(Register, &SavedRegisters[Register]);
                    }
                    __except(DebuggerExceptionFilter(GetExceptionInformation(),
                                                     Client,
                                                     "IDebugRegisters", "SetValue"))
                    {
                        hr = S_FALSE;
                    }

                    if (hr != S_OK)
                    {
                        RtlZeroMemory(&NewRegValue, sizeof(NewRegValue));
                        if (Registers->GetValue(Register, &NewRegValue) == S_OK)
                        {
                            if (!RtlEqualMemory(&SavedRegisters[Register], &NewRegValue, sizeof(NewRegValue)))
                            {
                                OutCtl.OutErr(" Registers %lu's value had changed.\n", Register);
                            }
                            else
                            {
                                OutCtl.Output(" However, registers %lu's value had NOT changed.\n", Register);
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            OutCtl.OutErr(" Unable to check register %lu's current value.\n", Register);
                        }

                        if (hr != S_OK)
                        {
                            OutCtl.OutErr(" Register %lu's value has not been restored.\n", Register);
                            hr = GetYNInput((PDEBUG_CONTROL)Control, "Continue restoring registers?");
                        }
                    }
                }

                if (hr == S_OK)
                {
                    OutCtl.Output("Original register values restored.\n");
                }
                else
                {
                    OutCtl.OutErr("Error restoring original register values.\n");
                }
            }
            else
            {
                hr = S_FALSE;
            }

            if (hr != S_OK)
            {
                hr = GetYNInput((PDEBUG_CONTROL)Control, "Discard saved register values?");
            }

            if (hr == S_OK)
            {
                HeapFree(GetProcessHeap(), 0, SavedRegisters);
                SavedRegisters = NULL;
                RegisterCount = 0;
            }
        }

        if (hr == S_OK) hr = hrRestore;
    }

    if (!CodeWritten && RegisterCount == 0)
    {
        if (Symbols != NULL) { Symbols->Release(); Symbols = NULL; }
        if (Registers != NULL) { Registers->Release(); Registers = NULL; }
        if (Data != NULL) { Data->Release(); Data = NULL; }
        if (Control != NULL) { Control->Release(); Control = NULL; }
    }

    return hr;
}


Instruction PageInSurfs_x86_Instructions[] = {
    { 0, sizeof(x86_jmp_here), (PSTR) x86_jmp_here}, // To loop here
    { 0, 0, "int 3" },
    { I_START_IP, 0, "push	 @eax" },
    { 0, 0, "push	 @ecx" },
    { 0, 0, "push	 @edx" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "xor	 @ecx, @ecx" },
    { 0, sizeof(x86_jmp_plus_0x0e), (PSTR) x86_jmp_plus_0x0e}, // To loop condition
    // Loop start
    { 0, 0, "mov	 @ecx, DWORD PTR [@eax]" },
    { 0, 0, "mov	 @eax, DWORD PTR [@eax+0x30]" },
    { 0, 0, "cmp	 @eax, 0x80000000" },
    { 0, sizeof(x86_jb_plus_0x02), (PSTR) x86_jb_plus_0x02},   // To loop condition
    { 0, 0, "mov	 @eax, DWORD PTR [@eax]" },
    // Loop condition
    { 0, 0, "mov	 @dl, 5" },
    { 0, 0, "call	 win32k!HmgSafeNextObjt" },
    { 0, 0, "test	 @eax, @eax" },
    { 0, sizeof(x86_jne_minus_0x18), (PSTR) x86_jne_minus_0x18},   // To loop start
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "pop	 @edx" },
    { 0, 0, "pop	 @ecx" },
    { 0, 0, "pop	 @eax" },
    { 0, 0, "int 3" },
    { 0, 0, NULL }
};

DECLARE_API( pageinsurfs )
{
    BEGIN_API( pageinsurfs );

    HRESULT hr = S_OK;

    OutputControl   OutCtl(Client);
    Instruction    *instructions;

    switch (TargetMachine)
    {
        case IMAGE_FILE_MACHINE_I386:
            instructions = PageInSurfs_x86_Instructions;
            break;

        default:
        {
            OutCtl.OutWarn("This extension is only supported on x86 architectures.\n");
            hr = E_NOTIMPL;
            break;
        }
    }

    if (hr == S_OK)
    {
        hr = AssembleTempRoutine(Client, instructions, args);
    }

    return hr;
}



Instruction PageInSurface_x86_Instructions[] = {
    { 0, sizeof(x86_jmp_here), (PSTR) x86_jmp_here}, // To loop here
    { 0, 0, "int 3" },
    {I_START_IP, 0, "push	 @eax" },
    { 0, 0, "push	 @ecx" },
    { 0, 0, "push	 @edx" },
    { 0, 0, "push	 @esi" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    {I_WRITE_ADDRESS, 0, "mov	 @edx, 0xDeadBeef" },
    { 0, 0, "mov	 @esi, DWORD PTR [@edx+0x30]" },                // pvScan0
    { 0, 0, "cmp	 @esi, 0x80000000" },                           // Check User address/NULL
    { 0, 0, "mov	 @ecx, DWORD PTR [@edx+0x24]" },                // sizlBitmap.cy
    { 0, sizeof(x86_jb_plus_0x0c), (PSTR) x86_jb_plus_0x0c},        // To end
    { 0, 0, "test	 @ecx, @ecx" },                                 // Check scan
    { 0, sizeof(x86_jmp_plus_0x06), (PSTR) x86_jmp_plus_0x06},      // To loop condition
    // Loop start
    { 0, 0, "mov	 @eax, DWORD PTR [@esi]" },
    { 0, 0, "add	 @esi, DWORD PTR [@edx+0x34]" },                // lDelta
    { 0, 0, "dec    @ecx" },
    // Loop condition
    { 0, sizeof(x86_jnz_minus_0x08), (PSTR) x86_jnz_minus_0x08},    // To loop start
    // End
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "pop	 @esi" },
    { 0, 0, "pop	 @edx" },
    { 0, 0, "pop	 @ecx" },
    { 0, 0, "pop	 @eax" },
    { 0, 0, "int 3" },
    { 0, 0, NULL }
};

DECLARE_API( pageinsurface )
{
    BEGIN_API( pageinsurface );

    HRESULT hr = S_OK;

    OutputControl   OutCtl(Client);
    Instruction    *instructions;

    switch (TargetMachine)
    {
        case IMAGE_FILE_MACHINE_I386:
            instructions = PageInSurface_x86_Instructions;
            break;

        default:
        {
            OutCtl.OutWarn("This extension is only supported on x86 architectures.\n");
            hr = E_NOTIMPL;
            break;
        }
    }

    if (hr == S_OK)
    {
        hr = AssembleTempRoutine(Client, instructions, args);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\session.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    This file contains the routines to handle session.

Author:

    Jason Hartman (JasonHa) 2000-09-28

Environment:

    User Mode

--*/

#include "precomp.hxx"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//
// Special defines
//

// ddk\inc\ntddk.h:
#define PROTECTED_POOL          0x80000000

// base\ntos\inc\pool.h:
#define POOL_QUOTA_MASK         8


// Information about how to handle a process listing
// and status about how it was handled.
class CProcessListing
{
public:
    IN ULONG m_cListLimit;
    IN OUT ULONG m_cTotal;
    IN OUT ULONG m_cProcessed;
    IN OUT ULONG64 m_oStartProcess;
    OUT ULONG64 m_oLastProcess;

public:
    CProcessListing(ULONG cListLimit = -1) {
        m_cListLimit = cListLimit;
        m_cTotal = 0;
        m_cProcessed = 0;
        m_oStartProcess = 0;
        m_oLastProcess = 0;
    }

    void PrepareForNextListing()
    {
        m_oStartProcess = m_oLastProcess;
    }

    BOOL Unprocessed()
    {
        return (m_cTotal > m_cProcessed);
    }
};


#define SESSION_SEARCH_LIMIT    50

ULONG   SessionId = CURRENT_SESSION;
CHAR    SessionStr[16] = "CURRENT";

CachedType  HwPte = { FALSE, "NT!HARDWARE_PTE", 0, 0, 0 };

#define NUM_CACHED_SESSIONS 8

struct {
    ULONG   UniqueState;
    ULONG64 SessionSpaceAddr;
} CachedSession[NUM_CACHED_SESSIONS+1] = { { 0, 0 } };
ULONG ExtraCachedSessionId;

#define NUM_CACHED_DIR_BASES    8

struct {
    ULONG   UniqueState;
    ULONG64 PageDirBase;
} CachedDirBase[NUM_CACHED_DIR_BASES+1] = { { FALSE, 0} };


struct {
    ULONG   UniqueState;
    ULONG64 PhysAddr;
    ULONG64 Data;
} CachedPhysAddr[2] = { { 0, 0, 0} };

BitFieldInfo *MMPTEValid = NULL;
BitFieldInfo *MMPTEProto = NULL;
BitFieldInfo *MMPTETrans = NULL;
BitFieldInfo *MMPTEX86LargePage = NULL;
BitFieldInfo *MMPTEpfn = NULL;

HRESULT
GetBitMap(
    PDEBUG_CLIENT Client,
    ULONG64 pBitMap,
    PRTL_BITMAP *pBitMapOut
    );

HRESULT
FreeBitMap(
    PRTL_BITMAP pBitMap
    );

HRESULT
OutputSessionProcesses(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG Session,
    PCSTR args,
    CProcessListing *pProcessListing
    );


/**************************************************************************\
*
* Routine Name:
*
*   SessionInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionInit(PDEBUG_CLIENT Client)
{
    for (int s = 0; s < sizeof(CachedSession)/sizeof(CachedSession[0]); s++)
    {
        CachedSession[s].UniqueState = INVALID_UNIQUE_STATE;
    }
    ExtraCachedSessionId = INVALID_SESSION;

    for (int s = 0; s < sizeof(CachedDirBase)/sizeof(CachedDirBase[0]); s++)
    {
        CachedDirBase[s].UniqueState = INVALID_UNIQUE_STATE;
    }

    if (MMPTEValid != NULL) MMPTEValid->Valid = FALSE;
    if (MMPTEProto != NULL) MMPTEProto->Valid = FALSE;
    if (MMPTETrans != NULL) MMPTETrans->Valid = FALSE;
    if (MMPTEX86LargePage != NULL) MMPTEX86LargePage->Valid = FALSE;
    if (MMPTEpfn != NULL) MMPTEpfn->Valid = FALSE;

    CachedPhysAddr[0].UniqueState = INVALID_UNIQUE_STATE;
    CachedPhysAddr[1].UniqueState = INVALID_UNIQUE_STATE;

    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   SessionExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionExit()
{
    if (MMPTEValid != NULL)
    {
        delete MMPTEValid;
        MMPTEValid = NULL;
    }

    if (MMPTEProto != NULL)
    {
        delete MMPTEProto;
        MMPTEProto = NULL;
    }

    if (MMPTETrans != NULL)
    {
        delete MMPTETrans;
        MMPTETrans = NULL;
    }

    if (MMPTEX86LargePage != NULL)
    {
        delete MMPTEX86LargePage;
        MMPTEX86LargePage = NULL;
    }

    if (MMPTEpfn != NULL)
    {
        delete MMPTEpfn;
        MMPTEpfn = NULL;
    }

    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEValid
*
* Routine Description:
*
*   Extract Valid value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEValid(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Valid
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEValid == NULL)
    {
        MMPTEValid = new BitFieldInfo;
    }

    if (MMPTEValid == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEValid->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEValid);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Valid bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE Valid") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                MMPTEValid->Valid = MMPTEValid->Compose(0, 1);
                hr = MMPTEValid->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Valid != NULL)
    {
        if (hr == S_OK)
        {
            *Valid = (MMPTE64 & MMPTEValid->Mask) >> MMPTEValid->BitPos;
        }
        else
        {
            *Valid = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEProto
*
* Routine Description:
*
*   Extract Prototype value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEProto(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Proto
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEProto == NULL)
    {
        MMPTEProto = new BitFieldInfo;
    }

    if (MMPTEProto == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEProto->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEProto);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Prototype bit field from symbol file
            if (OutState.Execute("dt NT!MMPTE_PROTOTYPE Prototype") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTEProto->Valid = MMPTEProto->Compose(10, 1);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    MMPTEProto->Valid = MMPTEProto->Compose(1, 1);
                    break;
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE Prototype bit in type info.\n");
                    }
                }

                hr = MMPTEProto->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Proto != NULL)
    {
        if (hr == S_OK)
        {
            *Proto = (MMPTE64 & MMPTEProto->Mask) >> MMPTEProto->BitPos;
        }
        else
        {
            *Proto = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTETrans
*
* Routine Description:
*
*   Extract Transition value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTETrans(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Trans
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTETrans == NULL)
    {
        MMPTETrans = new BitFieldInfo;
    }

    if (MMPTETrans == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTETrans->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTETrans);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Transition bit field from symbol file
            if (OutState.Execute("dt NT!PROTOTYPE_PTE Transition") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTETrans->Valid = MMPTETrans->Compose(11, 1);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    MMPTETrans->Valid = MMPTETrans->Compose(7, 1);
                    break;
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE Transition bit in type info.\n");
                    }
                }

                hr = MMPTETrans->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Trans != NULL)
    {
        if (hr == S_OK)
        {
            *Trans = (MMPTE64 & MMPTETrans->Mask) >> MMPTETrans->BitPos;
        }
        else
        {
            *Trans = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEX86LargePage
*
* Routine Description:
*
*   Extract LargePage value from X86 MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEX86LargePage(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 X86LargePage
    )
{
    HRESULT hr = S_FALSE;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386)
    {
        if (X86LargePage != NULL) *X86LargePage = 0;
        return hr;
    }

    if (MMPTEX86LargePage == NULL)
    {
        MMPTEX86LargePage = new BitFieldInfo;
    }

    if (MMPTEX86LargePage == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEX86LargePage->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEX86LargePage);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read LargePage bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE LargePage") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                MMPTEX86LargePage->Valid = MMPTEX86LargePage->Compose(7, 1);
                hr = MMPTEX86LargePage->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (X86LargePage != NULL)
    {
        if (hr == S_OK)
        {
            *X86LargePage = (MMPTE64 & MMPTEX86LargePage->Mask) >> MMPTEX86LargePage->BitPos;
        }
        else
        {
            *X86LargePage = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEpfn
*
* Routine Description:
*
*   Extract Page Frame Number value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEpfn(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 pfn,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEpfn == NULL)
    {
        MMPTEpfn = new BitFieldInfo;
    }

    if (MMPTEpfn == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEpfn->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEpfn);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read PageFrameNumber bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE PageFrameNumber") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTEpfn->Valid = MMPTEpfn->Compose(12, PaeEnabled ? 24 : 20);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    if (PageSize)
                    {
                        MMPTEpfn->Valid = MMPTEpfn->Compose(PageShift, 50-PageShift);
                        break;
                    }
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE pfn in type info.\n");
                    }
                }
                hr = MMPTEpfn->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (pfn != NULL)
    {
        if (hr == S_OK)
        {
            *pfn = (MMPTE64 & MMPTEpfn->Mask);
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *pfn >>= MMPTEpfn->BitPos;
            }
        }
        else
        {
            *pfn = 0;
        }
    }

    return hr;
}


HRESULT
GetSessionNumbers(
    IN PDEBUG_CLIENT Client,
    OUT PULONG CurrentSession,
    OUT PULONG DefaultSession,
    OUT PULONG TotalSessions,
    OUT PRTL_BITMAP *SessionList
    )
{
    HRESULT hr = S_FALSE;

    if (CurrentSession != NULL)
    {
        DEBUG_VALUE         RunningSession;
        BasicOutputParser   SessionReader(Client, 1);
        OutputState         OutState(Client);

        if ((hr = SessionReader.LookFor(&RunningSession, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = OutState.Setup(0, &SessionReader)) == S_OK &&
            (hr = OutState.Execute("!process -1 0")) == S_OK &&
            (hr = SessionReader.ParseOutput()) == S_OK &&
            (hr = SessionReader.Complete()) == S_OK)
        {
            *CurrentSession = RunningSession.I32;
        }
        else
        {
            *CurrentSession = INVALID_SESSION;
        }
    }

    if (DefaultSession != NULL)
    {
        *DefaultSession = SessionId;
        hr = S_OK;
    }

    if ((TotalSessions != NULL) ||
        (SessionList != NULL))
    {
        ULONG   SessionCount = 0;
        PRTL_BITMAP SessionListBitMap = NULL;
        ULONG64 SessionIdListPointerAddr = 0;
        ULONG64 SessionIdListAddr = 0;

        PDEBUG_SYMBOLS      Symbols;
        PDEBUG_DATA_SPACES  Data;

        if (TotalSessions)
        {
            *TotalSessions = 0;
        }
        if (SessionList)
        {
            *SessionList = NULL;
        }

        OutputControl   OutCtl(Client);

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) != S_OK)
        {
            return hr;
        }

        if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) != S_OK)
        {
            Symbols->Release();
            return hr;
        }

        CHAR PointerName[] = "NT!MiSessionIdBitmap";
        hr = Symbols->GetOffsetByName(PointerName, &SessionIdListPointerAddr);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to locate %s\n", PointerName);
        }
        else
        {
            hr = Data->ReadPointersVirtual(1, SessionIdListPointerAddr, &SessionIdListAddr);

            if (hr == S_OK)
            {
                hr = GetBitMap(Client, SessionIdListAddr, &SessionListBitMap);

                if (hr == S_OK)
                {
                    SessionCount = RtlNumberOfSetBits(SessionListBitMap);
                }
            }
        }

        if (TotalSessions)
        {
            *TotalSessions = SessionCount;
        }

        // Free or return BitMap
        if (SessionListBitMap)
        {
            if (SessionList)
            {
                *SessionList = SessionListBitMap;
            }
            else
            {
                FreeBitMap(SessionListBitMap);
            }
        }

        Data->Release();
        Symbols->Release();
    }

    return hr;
}


HRESULT
SetDefaultSession(
    IN PDEBUG_CLIENT Client,
    IN ULONG NewSession,
    OUT OPTIONAL PULONG OldSession
    )
{
    HRESULT hr = S_FALSE;

    GetSessionNumbers(Client, NULL, OldSession, NULL, NULL);

    if ((NewSession == CURRENT_SESSION) ||
        (GetSessionSpace(Client, NewSession, NULL) == S_OK))
    {
        if (NewSession != SessionId)
        {
            SessionId = NewSession;

            if (SessionId == CURRENT_SESSION)
            {
                strcpy(SessionStr, "CURRENT");
            }
            else
            {
                _ultoa(SessionId, SessionStr, 10);
            }

        }

        hr = S_OK;
    }

    return hr;
}



HRESULT
GetCurrentSession(
    PDEBUG_CLIENT Client,
    PULONG64 CurSessionSpace,
    PULONG CurSessionId
    )
{
    static ULONG        LastCachedUniqueState = INVALID_UNIQUE_STATE;
    static DEBUG_VALUE  LastSessionSpace = { 0, DEBUG_VALUE_INVALID };
    static DEBUG_VALUE  LastSessionId = { INVALID_SESSION, DEBUG_VALUE_INVALID };

    HRESULT             hr = S_OK;
    OutputControl       OutCtl(Client);
    BasicOutputParser   SessionSpaceReader(Client);
    BasicOutputParser   SessionIdReader(Client);
    OutputState         OutState(Client);
    CHAR                szCommand[MAX_PATH];

    ULONG               CurrentUniqueState = UniqueTargetState;


    if (CurSessionSpace != NULL) *CurSessionSpace = 0;
    if (CurSessionId != NULL) *CurSessionId = INVALID_SESSION;

    // Get the current session space
    if (CurrentUniqueState == INVALID_UNIQUE_STATE ||
        LastCachedUniqueState != CurrentUniqueState ||
        LastSessionSpace.Type == DEBUG_VALUE_INVALID)
    {
        PDEBUG_SYSTEM_OBJECTS   System;
        ULONG64                 ProcessAddr;

        if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&System)) == S_OK)
        {
            if ((hr = System->GetCurrentProcessDataOffset(&ProcessAddr)) == S_OK)
            {
                // Set Output callbacks
                if ((hr = SessionSpaceReader.LookFor(&LastSessionSpace, "Session", DEBUG_VALUE_INT64)) == S_OK &&
                    (hr = OutState.Setup(0, &SessionSpaceReader)) == S_OK)
                {
                    sprintf(szCommand, "dt NT!EPROCESS Session 0x%I64x", ProcessAddr);
                    if ((hr = OutState.Execute(szCommand)) == S_OK &&
                        (hr = SessionSpaceReader.ParseOutput()) == S_OK &&
                        (hr = SessionSpaceReader.Complete()) == S_OK)
                    {
                        if (LastSessionSpace.I64 == 0)
                        {
                            hr = E_FAIL;
                        }
                    }
                }

            }
            else
            {
                OutCtl.OutErr("IDebugSystemObjects::GetCurrentProcessDataOffset returned %s.\n", pszHRESULT(hr));
            }

            System->Release();
        }

        if (hr != S_OK)
        {
            LastSessionSpace.Type = DEBUG_VALUE_INVALID;
        }
        else
        {
            OutCtl.OutVerb("Caching current session space @ 0x%p.\n", LastSessionSpace.I64);

            // Update CachedUniqueState and make sure SessionID
            // is refreshed.
            if (CurrentUniqueState == INVALID_UNIQUE_STATE ||
                LastCachedUniqueState != CurrentUniqueState)
            {
                LastCachedUniqueState = CurrentUniqueState;
                LastSessionId.Type = DEBUG_VALUE_INVALID;
            }
        }
    }

    if (hr == S_OK &&
        CurSessionId != NULL &&
        LastSessionId.Type == DEBUG_VALUE_INVALID)
    {
        DEBUG_VALUE         CurrentSessionId;

        // Set Output callbacks
        if ((hr = SessionIdReader.LookFor(&LastSessionId, "SessionId", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = OutState.Setup(0, &SessionIdReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE SessionId 0x%I64x", LastSessionSpace.I64);
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = SessionIdReader.ParseOutput()) == S_OK &&
                (hr = SessionIdReader.Complete()) == S_OK)
            {
                if (LastSessionId.I32 == INVALID_SESSION)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (hr != S_OK)
        {
            LastSessionId.Type = DEBUG_VALUE_INVALID;
        }
    }


    if (hr == S_OK)
    {
        if (CurSessionSpace != NULL) *CurSessionSpace = LastSessionSpace.I64;
        if (CurSessionId != NULL) *CurSessionId = LastSessionId.I32;
    }

    return hr;
}


HRESULT
GetSessionSpace(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PULONG64 SessionSpace
    )
{
    HRESULT             hr;
    OutputControl       OutCtl(Client);
    DEBUG_VALUE         FoundSession;
    DEBUG_VALUE         SessionSpaceAddr;

    ULONG               CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == CURRENT_SESSION)
    {
        ULONG64 CurSessionSpace;
        ULONG   CurSessionId;

        hr = GetCurrentSession(Client, &SessionSpaceAddr.I64, &FoundSession.I32);
    }
    else
    {
        if (CurrentUniqueState != INVALID_UNIQUE_STATE)
        {
            if (Session < NUM_CACHED_SESSIONS)
            {
                if (CachedSession[Session].UniqueState == CurrentUniqueState &&
                    CachedSession[Session].SessionSpaceAddr != 0)
                {
                    if (SessionSpace != NULL) *SessionSpace = CachedSession[Session].SessionSpaceAddr;
                    return S_OK;
                }
            }
            else if (ExtraCachedSessionId != INVALID_SESSION &&
                     Session == ExtraCachedSessionId)
            {
                if (CachedSession[NUM_CACHED_SESSIONS].UniqueState == CurrentUniqueState &&
                    CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr != 0)
                {
                    if (SessionSpace != NULL) *SessionSpace = CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr;
                    return S_OK;
                }
            }
        }

        ULONG64             FirstSessionSpace;
        DEBUG_VALUE         SessionSpaceWsList;
        DEBUG_VALUE         SessionSpaceWsListOffset;
        BasicOutputParser   OffsetReader(Client);
        BasicOutputParser   FlinkReader(Client);
        BasicOutputParser   SessionReader(Client);
        OutputState         OutState(Client);
        CHAR                szCommand[MAX_PATH];

        // Set Output callbacks
        // Get ListEntry offset
        if ((hr = OffsetReader.LookFor(&SessionSpaceWsListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE WsListEntry");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        // Get first session space in list
        if (hr == S_OK &&
            (hr = FlinkReader.LookFor(&SessionSpaceWsList, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &FlinkReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MiSessionWsList");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = FlinkReader.ParseOutput()) == S_OK)
            {
                hr = FlinkReader.Complete();
            }
        }

        // Add SessionId to reader search
        if (hr == S_OK &&
            (hr = SessionReader.LookFor(&FoundSession, "SessionId", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = SessionReader.LookFor(&SessionSpaceWsList, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &SessionReader)) == S_OK)
        {
            SessionSpaceAddr.I64 = SessionSpaceWsList.I64 - SessionSpaceWsListOffset.I64;
            FirstSessionSpace = SessionSpaceAddr.I64;

            OutCtl.OutVerb("First session space @ %p.\n", FirstSessionSpace);

            do
            {
                // Get SessionId for this session space
                SessionReader.DiscardOutput();
                SessionReader.Relook();
                sprintf(szCommand,
                        "dt NT!MM_SESSION_SPACE SessionId WsListEntry.Flink 0x%I64x",
                        SessionSpaceAddr.I64);
                if ((hr = OutState.Execute(szCommand)) == S_OK &&
                    (hr = SessionReader.ParseOutput()) == S_OK &&
                    (hr = SessionReader.Complete()) == S_OK)
                {
                    if (Session == FoundSession.I32)
                    {
                        break;
                    }

                    // Compute next session space
                    SessionSpaceAddr.I64 = SessionSpaceWsList.I64 - SessionSpaceWsListOffset.I64;

                    if (SessionSpaceAddr.I64 == FirstSessionSpace)
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    OutCtl.OutErr("Couldn't get SessionId or next session from \'%s\'\n", szCommand);
                    PSTR pszOutput;
                    if (SessionReader.GetOutputCopy(&pszOutput) == S_OK)
                    {
                        OutCtl.OutVerb(" dt output:\n%s\n", pszOutput);
                        SessionReader.FreeOutputCopy(pszOutput);
                    }
                }
            } while (hr == S_OK);
        }
    }

    if (hr == S_OK)
    {
        OutCtl.OutVerb("Session %ld lookup found Session #%ld @ 0x%p.\n",
                       Session, FoundSession.I32, SessionSpaceAddr.I64);

        if (FoundSession.I32 < NUM_CACHED_SESSIONS)
        {
            CachedSession[FoundSession.I32].UniqueState = CurrentUniqueState;
            CachedSession[FoundSession.I32].SessionSpaceAddr = SessionSpaceAddr.I64;
        }
        else
        {
            ExtraCachedSessionId = FoundSession.I32;
            CachedSession[NUM_CACHED_SESSIONS].UniqueState = CurrentUniqueState;
            CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr = SessionSpaceAddr.I64;
        }

        if (SessionSpace != NULL) *SessionSpace = SessionSpaceAddr.I64;
    }

    return hr;
}


HRESULT
GetSessionDirBase(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PULONG64 PageDirBase
    )
{
    HRESULT             hr = S_FALSE;
    OutputControl       OutCtl(Client);
    ULONG64             SessionSpaceOffset;
    ULONG64             Process = -1;
    DEBUG_VALUE         SessionIdCheck;
    DEBUG_VALUE         dvPageDirBase;
    BasicOutputParser   ProcessReader(Client);
    OutputState         OutState(Client);
    CHAR                szCommand[MAX_PATH];

    static ULONG        LastSession = -2;
    static ULONG64      LastSessionPageDirBase = 0;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == LastSession &&
        LastSessionPageDirBase != 0)
    {
        *PageDirBase = LastSessionPageDirBase;
        return S_OK;
    }

    *PageDirBase = 0;

    if ((hr == GetSessionSpace(Client, Session, &SessionSpaceOffset)) == S_OK)
    {
        DEBUG_VALUE         ProcessSessionListOffset;
        BasicOutputParser   OffsetReader(Client);

        if ((hr = OffsetReader.LookFor(&ProcessSessionListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!_EPROCESS SessionProcessLinks");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        DEBUG_VALUE         SessionProcessListAddr;
        BasicOutputParser   FlinkReader(Client);

        if (hr == S_OK &&
            (hr = FlinkReader.LookFor(&SessionProcessListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &FlinkReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE ProcessList.Flink 0x%I64x", SessionSpaceOffset);
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = FlinkReader.ParseOutput()) == S_OK &&
                (hr = FlinkReader.Complete()) == S_OK)
            {
                Process = SessionProcessListAddr.I64 - ProcessSessionListOffset.I64;
            }
        }
    }
    else
    {
        OutCtl.OutVerb("GetSessionSpace returned HRESULT 0x%lx.\n", hr);
    }

    if (hr == S_OK &&
        (hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
        (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
        (hr = OutState.Setup(0, &ProcessReader)) == S_OK)
    {
        sprintf(szCommand, "!process 0x%I64x 0", Process);
        if ((hr = OutState.Execute(szCommand)) == S_OK &&
            (hr = ProcessReader.ParseOutput()) == S_OK &&
            (hr = ProcessReader.Complete()) == S_OK)
        {
            *PageDirBase = dvPageDirBase.I64;

            OutCtl.OutVerb("DirBase for session %lu is %p.\n", SessionIdCheck.I32, dvPageDirBase.I64);

            if (Session != CURRENT_SESSION &&
                Session != SessionIdCheck.I32)
            {
                hr = S_FALSE;
            }
            else
            {
                LastSession = Session;
                LastSessionPageDirBase = dvPageDirBase.I64;
            }
        }
    }

    return hr;
}


HRESULT
ReadPageTableEntry(
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageTableEntry
    )
{
    HRESULT hr;
    ULONG64 PhysAddr = PageTableBase + PageTableIndex * HwPte.Size;
    ULONG   BytesRead;
    ULONG   CurrentUniqueState = UniqueTargetState;


    *PageTableEntry = 0;

    if (CurrentUniqueState != INVALID_UNIQUE_STATE)
    {
        if (CachedPhysAddr[0].UniqueState == CurrentUniqueState &&
            CachedPhysAddr[0].PhysAddr == PhysAddr)
        {
            *PageTableEntry = CachedPhysAddr[0].Data;
            return S_OK;
        }
        else if (CachedPhysAddr[1].UniqueState == CurrentUniqueState &&
                 CachedPhysAddr[1].PhysAddr == PhysAddr)
        {
            *PageTableEntry = CachedPhysAddr[1].Data;
            return S_OK;
        }
    }

    hr = Data->ReadPhysical(PhysAddr,
                            PageTableEntry,
                            HwPte.Size,
                            &BytesRead);

    if (hr == S_OK)
    {
        if (BytesRead < HwPte.Size)
        {
            hr = S_FALSE;
        }
        else
        {
            static CacheToggle = 1;

            CacheToggle = (CacheToggle+1) % 2;

            CachedPhysAddr[CacheToggle].UniqueState = CurrentUniqueState;
            CachedPhysAddr[CacheToggle].PhysAddr = *PageTableEntry;
        }
    }

    return hr;
}


HRESULT
GetPageFrameNumber(
    PDEBUG_CLIENT Client,
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageFrameNumber,
    PBOOL Large
    )
{
    HRESULT hr;
    ULONG64 PageTableEntry;
    ULONG64 Valid, Proto, Trans, LargePage;
    ULONG64 pfn;

    if ((hr = ReadPageTableEntry(Data, PageTableBase, PageTableIndex, &PageTableEntry)) == S_OK)
    {
        if ((hr = GetMMPTEValid(Client, PageTableEntry, &Valid)) == S_OK)
        {
            if (Valid)
            {
                hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);

                if (hr == S_OK)
                {
                    if (GetMMPTEX86LargePage(Client, PageTableEntry, &LargePage) == S_OK &&
                        LargePage != 0)
                    {
                        // Large pages map 4MB of space - there shouldn't
                        //  be any bits set below that.
                        if (*PageFrameNumber & (4*1024*1024 - 1))
                        {
                            RIP("Found large X86 page with bad frame number.\n");
                        }

                        if (Large == NULL)
                        {
                            RIP("Unexpected large X86 page found.\n");
                        }
                        else
                        {
                            *Large = TRUE;
                        }
                    }
                    else if (Large != NULL)
                    {
                        *Large = FALSE;
                    }
                }
            }
            else
            {
                if ((hr = GetMMPTEProto(Client, PageTableEntry, &Proto)) == S_OK &&
                    (hr = GetMMPTETrans(Client, PageTableEntry, &Trans)) == S_OK)
                {
                    if (Proto == 0 && Trans == 1)
                    {
                        hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT
GetPhysicalBase(
    PDEBUG_CLIENT Client,
    ULONG64 PageDirBase,
    ULONG64 PageDirIndex,
    ULONG64 PageTableIndex,
    PULONG64 PhysicalBase
    )
{
    HRESULT             hr;
    PDEBUG_DATA_SPACES  Data;
    ULONG64             PageTableBase;
    BOOL                Large;

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) == S_OK)
    {
        if ((hr = GetPageFrameNumber(Client, Data,
                                     PageDirBase, PageDirIndex,
                                     &PageTableBase, &Large)) == S_OK)
        {
            if (!Large)
            {
                hr = GetPageFrameNumber(Client, Data,
                                        PageTableBase, PageTableIndex,
                                        PhysicalBase, NULL);
            }
            else
            {
                *PhysicalBase = PageTableBase;
            }
        }

        Data->Release();
    }

    return hr;
}


HRESULT
GetPhysicalAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddr,
    PULONG64 PhysAddr
    )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    ULONG64 PageDirIndex;
    ULONG64 PageTableIndex;
    ULONG64 PageByteIndex;
    ULONG64 PageDirBase;

    OutputControl   OutCtl(Client);

    ULONG CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (!HwPte.Valid)
    {
        PDEBUG_SYMBOLS  Symbols;

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) == S_OK)
        {
            if ((hr = Symbols->GetSymbolTypeId(HwPte.Type, &HwPte.TypeId, &HwPte.Module)) == S_OK &&
                (hr = Symbols->GetTypeSize(HwPte.Module, HwPte.TypeId, &HwPte.Size)) == S_OK &&
                HwPte.Size != 0)
            {
                HwPte.Valid = TRUE;
            }

            Symbols->Release();
        }
    }

    if (HwPte.Valid)
    {
        ULONG   TableEntries = PageSize / HwPte.Size;

        PageByteIndex = VirtAddr & (PageSize-1);
        VirtAddr >>= PageShift;
        PageTableIndex = VirtAddr % TableEntries;
        PageDirIndex = (VirtAddr / TableEntries) % TableEntries;

        if (Session < NUM_CACHED_DIR_BASES &&
            CurrentUniqueState != INVALID_UNIQUE_STATE &&
            CachedDirBase[Session].UniqueState == CurrentUniqueState &&
            (hr = GetPhysicalBase(Client,
                                  CachedDirBase[Session].PageDirBase,
                                  PageDirIndex,
                                  PageTableIndex,
                                  PhysAddr)) == S_OK)
        {
            *PhysAddr |= PageByteIndex;
        }
        else
        {
            DEBUG_VALUE         SessionIdCheck;
            DEBUG_VALUE         dvPageDirBase;
            BasicOutputParser   ProcessReader(Client);
            OutputState         OutState(Client);
            OutputControl       OutCtlToProcessReader;
            BOOL                ShortProcessList = (Session == CURRENT_SESSION);
            BOOL                fOutputNewLine = FALSE;
            CProcessListing     ProcessListing(40);

            if ((hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
                (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
                (hr = OutState.Setup(0, &ProcessReader)) == S_OK &&
                (hr = OutCtlToProcessReader.SetControl(
                    DEBUG_OUTCTL_THIS_CLIENT |
                    DEBUG_OUTCTL_NOT_LOGGED |
                    DEBUG_OUTCTL_OVERRIDE_MASK,
                    OutState.Client)) == S_OK &&
                (hr = (ShortProcessList ?
                       OutState.Execute("!process -1 0") :
                       OutputSessionProcesses(OutState.Client, &OutCtlToProcessReader, Session, "0", &ProcessListing)
                       /*OutState.Execute("!process 0 0")*/
                      )) == S_OK)
            {
                hr = S_FALSE;

                while (hr != S_OK &&
                       OutCtl.GetInterrupt() != S_OK)
                {
                    if (ProcessReader.ParseOutput() != S_OK ||
                        ProcessReader.Complete() != S_OK)
                    {
                        if (ShortProcessList ||
                            !ProcessListing.Unprocessed())
                        {
                            break;
                        }

                        // At this point, we have processed some, but
                        // not all so get the next listing.  Since there
                        // can be a huge process list, output a progress
                        // indicator.

                        OutCtl.Output(".");
                        fOutputNewLine = TRUE;

                        ProcessListing.PrepareForNextListing();
                        ProcessReader.DiscardOutput();

                        hr = OutputSessionProcesses(OutState.Client, &OutCtlToProcessReader, Session, "0", &ProcessListing);
                        if (hr != S_OK)
                        {
                            OutCtl.OutErr("OutputSessionProcesses returned 0x%X (!= S_OK)\n", hr);
                        }

                        ProcessReader.Relook();

                        if (ProcessReader.ParseOutput() != S_OK ||
                            ProcessReader.Complete() != S_OK)
                        {
                            break;
                        }
                    }
                    ProcessReader.Relook();

                    if (Session == CURRENT_SESSION)
                    {
                        // The current process is always first
                        // due to the '!process -1 0' above.
                        Session = SessionIdCheck.I32;
                    }

                    if (Session != SessionIdCheck.I32)
                    {
                        continue;
                    }

                    hr = GetPhysicalBase(Client,
                                         dvPageDirBase.I64,
                                         PageDirIndex,
                                         PageTableIndex,
                                         PhysAddr);

                    if (hr == S_OK)
                    {
                        *PhysAddr |= PageByteIndex;
                        if (Session < NUM_CACHED_DIR_BASES)
                        {
                            CachedDirBase[Session].UniqueState = CurrentUniqueState;
                            CachedDirBase[Session].PageDirBase = dvPageDirBase.I64;
                        }
                        else if (Session == CURRENT_SESSION)
                        {
                            CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState = CurrentUniqueState;
                            CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase = dvPageDirBase.I64;
                        }
                    }
                    else if ((ShortProcessList &&
                              SessionId == CURRENT_SESSION))
                    {
                        ShortProcessList = FALSE;
                        hr = OutputSessionProcesses(OutState.Client, &OutCtlToProcessReader, Session, "0", &ProcessListing);
                        if (hr != S_OK)
                        {
                            OutCtl.OutErr("OutputSessionProcesses returned 0x%X (!= S_OK)\n", hr);
                        }
                        hr = S_FALSE;
                    }
                }

                if (fOutputNewLine)
                {
                    OutCtl.Output("\n");
                }
            }
            else
            {
                OutCtl.OutVerb("Process reading setup failed.\n");
            }
        }
    }
    else
    {
        OutCtl.OutVerb("GetPageLookupData returned 0x%lx.\n", hr);
    }

    return hr;
}


HRESULT
GetNextResidentPage(
    PDEBUG_CLIENT Client,
    ULONG64 PageDirBase,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtPage,
    PULONG64 PhysPage
    )
{
    HRESULT             hr;
    BOOL                Interrupted = FALSE;
    PDEBUG_CONTROL      Control = NULL;
    PDEBUG_DATA_SPACES  Data = NULL;
    ULONG64             PageDirIndex;
    ULONG64             PageTableIndex;
    ULONG64             PageDirIndexLimit;
    ULONG64             PageTableIndexLimit;
    ULONG64             PageTableBase;
    BOOL                LargePage;
    ULONG64             TempAddr;

    if (VirtPage == NULL) VirtPage = &TempAddr;
    if (PhysPage == NULL) PhysPage = &TempAddr;

    *VirtPage = 0;
    *PhysPage = 0;

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) == S_OK &&
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) == S_OK)
    {
        if (!HwPte.Valid)
        {
            PDEBUG_SYMBOLS  Symbols;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                if ((hr = Symbols->GetSymbolTypeId(HwPte.Type, &HwPte.TypeId, &HwPte.Module)) == S_OK &&
                    (hr = Symbols->GetTypeSize(HwPte.Module, HwPte.TypeId, &HwPte.Size)) == S_OK &&
                    HwPte.Size != 0)
                {
                    HwPte.Valid = TRUE;
                }
                else if (hr == S_OK)
                {
                    hr = E_FAIL;
                }

                Symbols->Release();
            }
        }

        if (HwPte.Valid)
        {
            ULONG   TableEntries = PageSize / HwPte.Size;
            ULONG64 Addr;

            *VirtPage = PAGE_ALIGN64(VirtAddrStart);

            Addr = VirtAddrStart >> PageShift;
            PageTableIndex = Addr % TableEntries;
            PageDirIndex = (Addr / TableEntries) % TableEntries;

            Addr = VirtAddrLimit >> PageShift;
            PageTableIndexLimit = Addr % TableEntries;
            PageDirIndexLimit = (Addr / TableEntries) % TableEntries;

            if (VirtAddrLimit & (PageSize-1))
            {
                PageTableIndexLimit++;
            }

            hr = S_FALSE;

            while (PageDirIndex < PageDirIndexLimit && hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase, &LargePage)) == S_OK)
                {
                    if (LargePage)
                    {
                        *PhysPage = PageTableBase;
                    }
                    else
                    {
                        do
                        {
                            if ((hr = GetPageFrameNumber(Client, Data,
                                                         PageTableBase, PageTableIndex,
                                                         PhysPage, NULL)) != S_OK)
                            {
                                hr = Control->GetInterrupt();

                                if (hr == S_OK)
                                {
                                    Interrupted = TRUE;
                                    Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                                }
                                else
                                {
                                    PageTableIndex++;
                                    *VirtPage += PageSize;
                                }
                            }
                        } while (PageTableIndex < TableEntries && hr != S_OK);
                    }
                }
                else
                {
                    *VirtPage += PageSize * (TableEntries - PageTableIndex);
                }

                if (hr != S_OK)
                {
                    hr = Control->GetInterrupt();

                    if (hr == S_OK)
                    {
                        Interrupted = TRUE;
                        Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                    }
                    else
                    {
                        PageTableIndex = 0;
                        PageDirIndex++;
                    }
                }
            }

            if (PageDirIndex == PageDirIndexLimit &&
                PageTableIndex < PageTableIndexLimit &&
                hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase, &LargePage)) == S_OK)
                {
                    if (LargePage)
                    {
                        *PhysPage = PageTableBase;
                    }
                    else
                    {
                        do
                        {
                            if ((hr = GetPageFrameNumber(Client, Data,
                                                         PageTableBase, PageTableIndex,
                                                         PhysPage, NULL)) != S_OK)
                            {
                                hr = Control->GetInterrupt();

                                if (hr == S_OK)
                                {
                                    Interrupted = TRUE;
                                    Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                                }
                                else
                                {
                                    PageTableIndex++;
                                    *VirtPage += PageSize;
                                }
                            }
                        } while (PageTableIndex < PageTableIndexLimit && hr != S_OK);
                    }
                }
            }
        }

    }

    if (Control != NULL) Control->Release();
    if (Data != NULL) Data->Release();

    return ((Interrupted) ? E_ABORT : hr);
}


HRESULT
GetNextResidentAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtAddr,
    PULONG64 PhysAddr
    )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    ULONG64 PageDirBase;

    OutputControl   OutCtl(Client);

    ULONG CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }


    if (Session < NUM_CACHED_DIR_BASES &&
        CurrentUniqueState != INVALID_UNIQUE_STATE &&
        CachedDirBase[Session].UniqueState == CurrentUniqueState)
    {
        PageDirBase = CachedDirBase[Session].PageDirBase;
    }
    else if (SessionId == CURRENT_SESSION &&
             CurrentUniqueState != INVALID_UNIQUE_STATE &&
             CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState == CurrentUniqueState)
    {
        PageDirBase = CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase;
    }
    else
    {
        DEBUG_VALUE         SessionIdCheck;
        DEBUG_VALUE         dvPageDirBase;
        BasicOutputParser   ProcessReader(Client);
        OutputState         OutState(Client);
        BOOL                ShortProcessList = (Session == CURRENT_SESSION);

        if ((hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
            (hr = OutState.Setup(0, &ProcessReader)) == S_OK &&
            (hr = (ShortProcessList ?
                   OutState.Execute("!process -1 0") :
                   OutState.Execute("!process 0 0"))) == S_OK)
        {
            hr = S_FALSE;

            while (hr != S_OK &&
                   OutCtl.GetInterrupt() != S_OK &&
                   ProcessReader.ParseOutput() == S_OK &&
                   ProcessReader.Complete() == S_OK)
            {
                ProcessReader.Relook();

                if (Session == CURRENT_SESSION)
                {
                    // The current process is always first
                    // due to the '!process -1 0' above.
                    Session = SessionIdCheck.I32;
                }

                if (Session == SessionIdCheck.I32)
                {
                    hr = S_OK;
                    PageDirBase = dvPageDirBase.I64;

                    if (Session < NUM_CACHED_DIR_BASES)
                    {
                        CachedDirBase[Session].UniqueState = CurrentUniqueState;
                        CachedDirBase[Session].PageDirBase = dvPageDirBase.I64;
                    }
                    else if (Session == CURRENT_SESSION)
                    {
                        CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState = CurrentUniqueState;
                        CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase = dvPageDirBase.I64;
                    }
                }
            }
        }
        else
        {
            OutCtl.OutVerb("Process reading setup failed.\n");
        }
    }

    if (hr == S_OK)
    {
        hr = GetNextResidentPage(Client,
                                 PageDirBase,
                                 VirtAddrStart,
                                 VirtAddrLimit,
                                 VirtAddr,
                                 PhysAddr);
    }
    else
    {
        OutCtl.OutVerb("Page Directory Base lookup failed.\n");
    }

    return hr;
}


DECLARE_API( session )
{
    INIT_API();

    HRESULT hr;
    ULONG   NewSession = CURRENT_SESSION;
    ULONG   CurrentSession;
    ULONG   SessionCount = 0;
    PRTL_BITMAP SessionList = NULL;
    DEBUG_VALUE DebugValue;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' && args[1] == '?')
    {
        ExtOut("session displays number of sessions on machine and\n"
               " the default SessionId used by session related extensions.\n"
               "\n"
               "Usage: session [SessionId]\n"
               "    SessionId - sets default session used for session extensions\n");

        EXIT_API(S_OK);
    }

    ULONG   OldRadix;
    g_pExtControl->GetRadix(&OldRadix);
    g_pExtControl->SetRadix(10);
    hr = g_pExtControl->Evaluate(args, DEBUG_VALUE_INT32, &DebugValue, NULL);
    g_pExtControl->SetRadix(OldRadix);

    if (GetSessionNumbers(Client, &CurrentSession, NULL, &SessionCount, &SessionList) == S_OK)
    {
        if (SessionCount != 0)
        {
            ExtOut("Sesssions on machine: %lu\n", SessionCount);

            // If a session wasn't specified,
            // list valid sessions (up to a point).
            if (hr != S_OK)
            {
                ULONG SessionLimit = SessionList->SizeOfBitMap;

                ExtOut("Valid Sessions:");

                for (ULONG CheckSession = 0; CheckSession <= SessionLimit; CheckSession++)
                {
                    if (RtlCheckBit(SessionList, CheckSession)
                        /*GetSessionSpace(Client, CheckSession, NULL) == S_OK*/)
                    {
                        ExtOut(" %lu", CheckSession);
                        SessionCount--;
                        if (SessionCount == 0) break;
                    }

                    if (g_pExtControl->GetInterrupt() == S_OK)
                    {
                        ExtWarn("\n  User aborted.\n");
                        break;
                    }
                }

                if (SessionCount > 0)
                {
                    ExtOut(" ...?");
                }
                ExtOut("\n");
            }
        }
        else if (SessionList)
        {
            ExtOut("There are ZERO session on machine.\n");
        }
        else
        {
            ExtErr("Couldn't determine number of sessions.\n");
        }

        if (SessionList)
        {
            FreeBitMap(SessionList);
        }

        if (CurrentSession != INVALID_SESSION)
        {
            ExtVerb("Running session: %lu\n", CurrentSession);
        }
    }

    if (hr == S_OK)
    {
        NewSession = DebugValue.I32;

         ExtVerb("Previous Default Session: %s\n", SessionStr);

        if (SetDefaultSession(Client, NewSession, NULL) != S_OK)
        {
            ExtErr("Couldn't set Session %lu.\n", NewSession);
        }
    }

    ExtOut("Using session %s", SessionStr);
    if (SessionId == CURRENT_SESSION)
    {
        if (GetSessionNumbers(Client, &CurrentSession, NULL, NULL, NULL) == S_OK &&
            CurrentSession != INVALID_SESSION)
        {
            ExtOut(" (%d)", CurrentSession);
        }
        else
        {
            ExtOut(" (?)");
        }
    }
    ExtOut("\n");

    EXIT_API(S_OK);
}


DECLARE_API( svtop )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE SessVirtAddr;
    ULONG64     PhysAddr;

    if (S_OK == g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SessVirtAddr, NULL))
    {
        if ((hr = GetPhysicalAddress(Client, SessionId, SessVirtAddr.I64, &PhysAddr)) == S_OK)
        {
            ExtOut("Session %s: %p -> %p\n", SessionStr, SessVirtAddr.I64, PhysAddr);
        }
        else
        {
            ExtErr("Failed to translate virtual address %p from session %s\n"
                   "  HRESULT: 0x%lx\n",
                   SessVirtAddr.I64, SessionStr, hr);
        }
    }
    else
    {
        ExtOut("Usage: svtop SessionVirtualAddress\n");
    }

    EXIT_API(S_OK);
}


DECLARE_API( sprocess )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE Session;
    ULONG       RemainingArgIndex;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' && args[1] == '?')
    {
        ExtOut("sprocess is like !process, but for the SessionId specified.\n"
               "\n"
               "Usage: sprocess [SessionId [Flags]]\n"
               "    SessionId - specifies which session to dump.\n"
               "              Special SessionId values:\n"
               "               -1 - current session\n"
               "               -2 - last !session SessionId (default)\n"
               "    Flags - see !process help\n");

        EXIT_API(S_OK);
    }

    ULONG       OldRadix;
    g_pExtControl->GetRadix(&OldRadix);
    g_pExtControl->SetRadix(10);
    hr = g_pExtControl->Evaluate(args, DEBUG_VALUE_INT32, &Session, &RemainingArgIndex);
    g_pExtControl->SetRadix(OldRadix);

    if (hr != S_OK)
    {
        Session.I32 = DEFAULT_SESSION;
        args = "0";
        hr = S_OK;
    }
    else
    {
        args += RemainingArgIndex;
    }

    CProcessListing ProcessListing;

    hr = OutputSessionProcesses(Client, NULL, Session.I32, args, &ProcessListing);

    EXIT_API(hr);
}

HRESULT
OutputSessionProcesses(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG Session,
    PCSTR args,
    CProcessListing *pProcessListing
    )
{
    HRESULT         hr;
    PDEBUG_CONTROL  Control = NULL;
    ULONG64         SessionSpace;

    if (OutCtl == NULL)
    {
        OutCtl = new OutputControl(Client);

        if (OutCtl == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        OutCtl->AddRef();
    }

    if ((hr = GetSessionSpace(Client, Session, &SessionSpace)) == S_OK)
    {
        DEBUG_VALUE         ProcessSessionListAddr;
        DEBUG_VALUE         ProcessSessionListOffset;
        DEBUG_VALUE         ProcessesInSession;
        DEBUG_VALUE         Process;
        BasicOutputParser   OffsetReader(Client, 1);
        BasicOutputParser   SessionReader(Client, 2);
        BasicOutputParser   FlinkReader(Client, 1);
        BasicOutputParser   ErrorChecker(Client, 1);
        OutputFilter        OutFilter(Client);
        OutputState         OutState(Client);
        CHAR                szCommand[MAX_PATH];

        // General parser setup and get ListEntry offset in _EPROCESS structure
        if ((hr = OffsetReader.LookFor(&ProcessSessionListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = FlinkReader.LookFor(&ProcessSessionListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = ErrorChecker.LookFor(NULL, "Could not find _EPROCESS")) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            if ((hr = StringCbCopyA(szCommand, sizeof(szCommand),
                                    "dt NT!_EPROCESS SessionProcessLinks")) == S_OK &&
                (hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        // Find first process and number of processes
        if (hr == S_OK)
        {
            if (pProcessListing->m_oStartProcess &&
                pProcessListing->m_cTotal)
            {
                Process.I64 = pProcessListing->m_oStartProcess;
                ProcessesInSession.I32 =
                    pProcessListing->m_cTotal - pProcessListing->m_cProcessed;
            }
            else
            {
                if ((hr = SessionReader.LookFor(&ProcessSessionListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
                    (hr = SessionReader.LookFor(&ProcessesInSession, "ProcessReferenceToSession", DEBUG_VALUE_INT32)) == S_OK &&
                    (hr = OutState.Setup(0, &SessionReader)) == S_OK)
                {
                    if ((hr = StringCbPrintfA(
                            szCommand, sizeof(szCommand),
                            "dt NT!MM_SESSION_SPACE ProcessList.Flink ProcessReferenceToSession 0x%I64x",
                            SessionSpace)) == S_OK &&
                        (hr = OutState.Execute(szCommand)) == S_OK &&
                        (hr = SessionReader.ParseOutput()) == S_OK &&
                        (hr = SessionReader.Complete()) == S_OK)
                    {
                        Process.I64 = ProcessSessionListAddr.I64 - ProcessSessionListOffset.I64;
                        pProcessListing->m_cTotal = ProcessesInSession.I32;
                        pProcessListing->m_cProcessed = 0;
                        pProcessListing->m_oStartProcess = Process.I64;
                        pProcessListing->m_oLastProcess = Process.I64;
                    }
                }
            }
        }

        if (hr == S_OK)
        {
            ULONG cProcessed = 0;

            OutCtl->Output("Processes is session: %lu\n", ProcessesInSession.I32);

            // Dump all processes
            while ((hr == S_OK) &&
                   (ProcessesInSession.I32 > 0) &&
                   (cProcessed < pProcessListing->m_cListLimit))
            {
                hr = StringCbPrintfA(
                    szCommand, sizeof(szCommand),
                    "!process 0x%I64x %s",
                    Process.I64, args);

                // dump process and check that the process was valid
                if (SUCCEEDED(hr) &&
                    (hr = OutState.Setup(0, &OutFilter)) == S_OK)
                {
                    OutFilter.DiscardOutput();

                    hr = OutState.Execute(szCommand);
                }

                OutState.Setup(0, NULL);

                OutFilter.OutputText(OutCtl, DEBUG_OUTPUT_NORMAL);

                if (hr == S_OK)
                {
                    // check that the process was valid
                    PSTR pszText = NULL;

                    if (SUCCEEDED(OutFilter.GetOutputCopy(&pszText)) &&
                        ErrorChecker.Ready() == S_OK &&
                        ErrorChecker.Parse(pszText, NULL) == S_OK &&
                        ErrorChecker.Complete() == S_OK)
                    {
                        hr = S_FALSE;
                    }

                    if (pszText)
                    {
                        OutFilter.FreeOutputCopy(pszText);
                    }
                }

                if (hr == S_OK)
                {
                    // Get next process
                    FlinkReader.DiscardOutput();
                    FlinkReader.Relook();
                    hr = StringCbPrintfA(
                        szCommand, sizeof(szCommand),
                        "dt NT!_EPROCESS SessionProcessLinks.Flink 0x%I64x",
                        Process.I64);
                    if (SUCCEEDED(hr))
                    {
                        if ((hr = OutState.Setup(0, &FlinkReader)) == S_OK &&
                            (hr = OutState.Execute(szCommand)) == S_OK &&
                            (hr = FlinkReader.ParseOutput()) == S_OK &&
                            (hr = FlinkReader.Complete()) == S_OK)
                        {
                            Process.I64 = ProcessSessionListAddr.I64 - ProcessSessionListOffset.I64;

                            ProcessesInSession.I32--;
                        }
                        else
                        {
                            OutCtl->OutVerb("Couldn't get next process from '%s'\n", szCommand);
                        }
                    }
                    else
                    {
                        OutCtl->OutVerb("dt command string is too long for buffer.\n");
                    }
                }

                if (hr == S_OK)
                {
                    cProcessed++;
                    pProcessListing->m_cProcessed++;
                    pProcessListing->m_oLastProcess = Process.I64;
                }
            }

            if (ProcessesInSession.I32 > 0)
            {
                OutCtl->OutErr("%lu processes weren't dumped.\n", ProcessesInSession.I32);
            }
        }
    }
    else
    {
        OutCtl->OutErr("Couldn't get session %lu's data.\n", Session);
    }

    OutCtl->Release();

    return hr;
}


HRESULT
SearchLinkedList(
    PDEBUG_CLIENT   Client,
    ULONG64         StartAddr,
    ULONG64         NextLinkOffset,
    ULONG64         SearchAddr,
    PULONG          LinksTraversed
    )
{
    if (LinksTraversed != NULL)
    {
        *LinksTraversed = 0;
    }

    INIT_API();

    HRESULT hr = S_OK;
    ULONG64 PhysAddr;
    ULONG64 NextAddr = StartAddr;
    ULONG   LinkCount = 0;
    ULONG   PointerSize;
    ULONG   BytesRead;

    PointerSize = (g_pExtControl->IsPointer64Bit() == S_OK) ? 8 : 4;

    do
    {
        if ((hr = GetPhysicalAddress(Client, DEFAULT_SESSION, NextAddr, &PhysAddr)) == S_OK)
        {
            if ((hr = g_pExtData->ReadPhysical(PhysAddr + NextLinkOffset,
                                              &NextAddr,
                                              PointerSize,
                                              &BytesRead)) == S_OK)
            {
                if (BytesRead == PointerSize)
                {
                    LinkCount++;
                    if (PointerSize != 8)
                    {
                        NextAddr = DEBUG_EXTEND64(NextAddr);
                    }
                    ExtVerb("NextAddr: %p\n", NextAddr);
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    } while (hr == S_OK &&
             NextAddr != SearchAddr &&
             NextAddr != 0 &&
             LinkCount < 4 &&
             NextAddr != StartAddr);

    if (LinksTraversed != NULL)
    {
        *LinksTraversed = LinkCount;
    }

    // Did we really find SearchAddr?
    if (hr == S_OK &&
        NextAddr != SearchAddr)
    {
        hr = S_FALSE;
    }

    EXIT_API(hr);
}


DECLARE_API( walklist )
{
    INIT_API();

    HRESULT     hr;
    BOOL        NeedHelp = FALSE;
    BOOL        SearchSessions = FALSE;
    DEBUG_VALUE StartAddr;
    DEBUG_VALUE OffsetToNextField = { -1, DEBUG_VALUE_INVALID };//FIELD_OFFSET(Win32PoolHead, pNext);
    DEBUG_VALUE SearchAddr;
    ULONG       NextArg;
    ULONG       SessionCount;
    ULONG       Session = 0;
    ULONG       OldDefSession;
    ULONG       LinksToDest = 0;

    while (*args && isspace(*args)) args++;

    while (args[0] == '-' && !NeedHelp)
    {
        if (tolower(args[1]) == 'a' && isspace(args[2]))
        {
            SearchSessions = TRUE;
            args += 2;
            while (*args && isspace(*args)) args++;
        }
        else if (tolower(args[1]) == 'o' &&
                 Evaluate(Client, args+2,
                          DEBUG_VALUE_INT64, EVALUATE_DEFAULT_RADIX,
                          &OffsetToNextField, &NextArg,
                          NULL, 0) == S_OK)
        {
            args += 2 + NextArg;
            while (*args && isspace(*args)) args++;
        }
        else
        {
            NeedHelp = TRUE;
        }
    }

    if (!NeedHelp &&
        S_OK == g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &StartAddr, &NextArg))
    {
        args += NextArg;
        if (S_OK != g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SearchAddr, &NextArg))
        {
            SearchAddr.I64 = 0;
        }

        if (OffsetToNextField.Type == DEBUG_VALUE_INVALID)
        {
            ExtWarn("Assuming next field's offset is +8.\n");
            OffsetToNextField.I64 = 8;
        }
        else
        {
            ExtOut("Using field at offset +0x%I64u for next.\n", OffsetToNextField.I64);
        }

        if (SearchSessions &&
            GetSessionNumbers(Client, NULL, &OldDefSession, &SessionCount, NULL) == S_OK &&
            SessionCount > 0)
        {
            ExtOut("Searching all sessions lists @ %p for %p\n", StartAddr.I64, SearchAddr.I64);

            do
            {
                while (SetDefaultSession(Client, Session, NULL) != S_OK &&
                       Session <= SESSION_SEARCH_LIMIT)
                {
                    Session++;
                }

                if (Session <= SESSION_SEARCH_LIMIT)
                {
                    if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
                    {
                        ExtOut("Session %lu: Found %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }
                    else
                    {
                        ExtOut("Session %lu: Couldn't find %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }

                    Session++;
                    SessionCount--;
                }
            } while (SessionCount > 0 && Session <= SESSION_SEARCH_LIMIT);

            if (SessionCount)
            {
                ExtErr("%lu sessions beyond session %lu were not searched.\n",
                       SessionCount, SESSION_SEARCH_LIMIT);
            }

            SetDefaultSession(Client, OldDefSession, NULL);
        }
        else
        {
            ExtOut("Searching Session %s list @ %p for %p\n", SessionStr, StartAddr.I64, SearchAddr.I64);

            if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
            {
                ExtOut("Found %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
            else
            {
                ExtOut("Couldn't find %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
        }
    }
    else
    {
        NeedHelp = TRUE;
    }
    
    if (NeedHelp)
    {
        ExtOut("Usage: walklist [-a] StartAddress [SearchAddr]\n");
    }

    EXIT_API(S_OK);
}


HRESULT
GetBitMap(
    PDEBUG_CLIENT Client,
    ULONG64 pBitMap,
    PRTL_BITMAP *pBitMapOut
    )
{
    HRESULT     hr;
    PRTL_BITMAP p;
    DEBUG_VALUE Size;
    DEBUG_VALUE Buffer;
    ULONG       BufferLen;
    ULONG       BytesRead = 0;

    OutputControl       OutCtl(Client);
    TypeOutputParser    BitMapParser(Client);
    OutputState         OutState(Client);

    *pBitMapOut = NULL;

    if ((hr = OutState.Setup(0, &BitMapParser)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(pBitMap, "NT!_RTL_BITMAP", 0)) == S_OK &&
        (hr = BitMapParser.Get(&Size, "SizeOfBitMap", DEBUG_VALUE_INT32)) == S_OK &&
        (hr = BitMapParser.Get(&Buffer, "Buffer", DEBUG_VALUE_INT64)) == S_OK)
    {
        PDEBUG_DATA_SPACES  Data;

        if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) == S_OK)
        {
            BufferLen = (Size.I32 + 7) / 8;

#if DBG
            OutCtl.OutVerb("Reading RTL_BITMAP @ 0x%p:\n"
                           "  SizeOfBitMap: %lu\n"
                           "  Buffer: 0x%p\n"
                           "   Length in bytes: 0x%lx\n",
                           pBitMap,
                           Size.I32,
                           Buffer.I64,
                           BufferLen);
#endif

            p = (PRTL_BITMAP) HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + BufferLen );
    
            if (p != NULL)
            {
                RtlInitializeBitMap(p, (PULONG)(p + 1), Size.I32);
                hr = Data->ReadVirtual(Buffer.I64, p->Buffer, BufferLen, &BytesRead);
    
                if (hr != S_OK)
                {
                    OutCtl.OutErr("Error reading bitmap contents @ 0x%p\n", Buffer.I64);
                }
                else if (BytesRead < BufferLen)
                {
                    OutCtl.OutErr("Error reading bitmap contents @ 0x%p\n", Buffer.I64 + BytesRead);
                    hr = E_FAIL;
                }

                if (hr != S_OK)
                {
                    HeapFree( GetProcessHeap(), 0, p );
                    p = NULL;
                }
                else
                {
                    *pBitMapOut = p;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            Data->Release();
        }
        else
        {
            OutCtl.OutErr("Error setting up debugger interface.\n");
        }
    }
    else
    {
        OutCtl.OutErr("Error reading bitmap header @ 0x%p.\n", pBitMap);
    }

    return hr;
}


HRESULT
FreeBitMap(
    PRTL_BITMAP pBitMap
    )
{
    return (HeapFree( GetProcessHeap(), 0, pBitMap) ? S_OK : S_FALSE);
}


HRESULT
CheckSingleFilter(
    PUCHAR Tag,
    PUCHAR Filter
    )
{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for ( i = 0; i < 4; i++ )
    {
        tc = (UCHAR) *Tag++;
        fc = (UCHAR) *Filter++;
        if ( fc == '*' ) return S_OK;
        if ( fc == '?' ) continue;
        if (i == 3 && (tc & ~(PROTECTED_POOL >> 24)) == fc) continue;
        if ( tc != fc ) return S_FALSE;
    }

    return S_OK;
}


HRESULT
AccumAllFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (AllocStatsAccum == NULL)
    {
        return E_INVALIDARG;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}



HRESULT
CheckPrintAndAccumFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    OutCtl->Output("0x%p size: %5lx ",//previous size: %4lx ",
                   PoolAddr,
                   BlockSize << POOL_BLOCK_SHIFT/*,
                   PreviousSize << POOL_BLOCK_SHIFT*/);

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            //
            // "Free " with a space after it before the parentheses means
            // it's been freed to a (pool manager internal) lookaside list.
            // We used to print "Lookaside" but that just confused driver
            // writers because they didn't know if this meant in use or not
            // and many would say "but I don't use lookaside lists - the
            // extension or kernel is broken".
            //
            // "Free" with no space after it before the parentheses means
            // it is not on a pool manager internal lookaside list and is
            // instead on the regular pool manager internal flink/blink
            // chains.
            //
            // Note to anyone using the pool package, these 2 terms are
            // equivalent.  The fine distinction is only for those actually
            // writing pool internal code.
            //
            OutCtl->Output(" (Free)");
            OutCtl->Output("      %c%c%c%c\n",
                    Tag->RawBytes[0],
                    Tag->RawBytes[1],
                    Tag->RawBytes[2],
                    Tag->RawBytes[3]
                   );

            if (AllocStatsAccum != NULL)
            {
                AllocStatsAccum->Free++;
                AllocStatsAccum->FreeSize += BlockSize;
            }
        }
        else
        {
            DEBUG_VALUE PoolIndex;
            DEBUG_VALUE ProcessBilled;

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    OutCtl->Output(" (Allocated)");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Allocated++;
                        AllocStatsAccum->AllocatedSize += BlockSize;
                    }
                }
                else
                {
                    //
                    // "Free " with a space after it before the parentheses means
                    // it's been freed to a (pool manager internal) lookaside list.
                    // We used to print "Lookaside" but that just confused driver
                    // writers because they didn't know if this meant in use or not
                    // and many would say "but I don't use lookaside lists - the
                    // extension or kernel is broken".
                    //
                    // "Free" with no space after it before the parentheses means
                    // it is not on a pool manager internal lookaside list and is
                    // instead on the regular pool manager internal flink/blink
                    // chains.
                    //
                    // Note to anyone using the pool package, these 2 terms are
                    // equivalent.  The fine distinction is only for those actually
                    // writing pool internal code.
                    //
                    OutCtl->Output(" (Free )    ");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Free++;
                        AllocStatsAccum->FreeSize += BlockSize;
                    }
                }
            }
            else
            {
                OutCtl->Output(" (?)        ");

                if (AllocStatsAccum != NULL)
                {
                    AllocStatsAccum->Indeterminate++;
                    AllocStatsAccum->IndeterminateSize += BlockSize;
                }
            }

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                OutCtl->Output(" %c%c%c%c%s",
                               Tag->RawBytes[0],
                               Tag->RawBytes[1],
                               Tag->RawBytes[2],
                               (Tag->RawBytes[3] & ~(PROTECTED_POOL >> 24)),
                               ((Tag->I32 & PROTECTED_POOL) ? " (Protected)" : "")
                               );

            }
            
            if (PoolType.I32 & POOL_QUOTA_MASK &&
                PoolHeadReader->Get(&ProcessBilled, "ProcessBilled", DEBUG_VALUE_INT64) == S_OK &&
                ProcessBilled.I64 != 0)
            {
                OutCtl->Output(" Process: 0x%p\n", ProcessBilled.I64);
            }
            else
            {
                OutCtl->Output("\n");
            }
        }
    }
    else
    {
        OutCtl->OutErr(" Couldn't determine PoolType\n");

        if (AllocStatsAccum != NULL)
        {
            AllocStatsAccum->Indeterminate++;
            AllocStatsAccum->IndeterminateSize += BlockSize;
        }
    }

    return hr;
}


typedef struct _TAG_BUCKET : public ALLOCATION_STATS {
    ULONG Tag;
    _TAG_BUCKET *pNextTag;
} TAG_BUCKET, *PTAG_BUCKET;

typedef enum {
    AllocatedPool,
    FreePool,
    IndeterminatePool,
} PoolType;

class AccumTagUsage : public ALLOCATION_STATS {
public:
    AccumTagUsage(ULONG TagFilter);
    ~AccumTagUsage();

    HRESULT Valid();
    HRESULT Add(ULONG Tag, PoolType Type, ULONG Size);
    HRESULT OutputResults(OutputControl *OutCtl, BOOL TagSort);
    void Reset();

private:
    ULONG GetHashIndex(ULONG Tag);
    PTAG_BUCKET GetBucket(ULONG Tag);
    ULONG SetTagFilter(ULONG TagFilter);

    static const HashBitmaskLimit = 10;     // For little-endian, must <= 16

    HANDLE      hHeap;
    ULONG       Buckets;
    PTAG_BUCKET *Bucket;   // Array of buckets

#if BIG_ENDIAN
    ULONG       HighMask;
    ULONG       HighShift;
    ULONG       LowMask;
    ULONG       LowShift;
#else
    ULONG       HighShiftLeft;
    ULONG       HighShiftRight;
    ULONG       LowShiftRight;
    ULONG       LowMask;
#endif
};


AccumTagUsage::AccumTagUsage(
    ULONG TagFilter
    )
{
    hHeap = GetProcessHeap();
    Buckets = SetTagFilter(TagFilter);
    if (Buckets != 0)
    {
        Bucket = (PTAG_BUCKET *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, Buckets*sizeof(*Bucket));
        Reset();
    }
    else
    {
        Bucket = NULL;
    }
}


AccumTagUsage::~AccumTagUsage()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            while (pB != NULL)
            {
                pBNext = pB->pNextTag;
                HeapFree(hHeap, 0, pB);
                pB = pBNext;
            }
        }

        HeapFree(hHeap, 0, Bucket);
    }
}


HRESULT
AccumTagUsage::Valid()
{
    return ((Bucket != NULL) ? S_OK : S_FALSE);
}


HRESULT
AccumTagUsage::Add(
    ULONG Tag,
    PoolType Type,
    ULONG Size
    )
{
    PTAG_BUCKET pBucket = GetBucket(Tag);

    if (pBucket == NULL) return E_FAIL;

    switch (Type)
    {
        case AllocatedPool:
            pBucket->Allocated++;
            pBucket->AllocatedSize += Size;
            break;
        case FreePool:
            pBucket->Free++;
            pBucket->FreeSize += Size;
            break;
        case IndeterminatePool:
        default:
            pBucket->Indeterminate++;
            pBucket->IndeterminateSize += Size;
            break;
    }

    return S_OK;
}


HRESULT
AccumTagUsage::OutputResults(
    OutputControl *OutCtl,
    BOOL AllocSort
    )
{
    HRESULT     hr;
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket == NULL)
    {
        hr = OutCtl->Output(" No results\n");
    }
    else
    {
        CHAR        szNormal[] = "%4.4s %8lu %12I64u  %8lu %12I64u\n";
        CHAR        szShowIndeterminate[] = "%4.4s %8lu %12I64u  %8lu %12I64u  %8lu %12I64u\n";
        PSZ         pszOutFormat = szNormal;

        OutCtl->Output("\n"
                       " %I64u bytes in %lu allocated pages\n"
                       " %I64u bytes in %lu large allocations\n"
                       " %I64u bytes in %lu free pages\n"
                       " %I64u bytes available in %lu expansion pages\n",
                       ((ULONG64) AllocatedPages) << PageShift,
                       AllocatedPages,
                       ((ULONG64) LargePages) << PageShift,
                       LargeAllocs,
                       ((ULONG64) FreePages) << PageShift,
                       FreePages,
                       ((ULONG64) ExpansionPages) << PageShift,
                       ExpansionPages);

        OutCtl->Output("\nTag    Allocs        Bytes     Freed        Bytes");
        if (Indeterminate != 0)
        {
            OutCtl->Output(" Unknown        Bytes");
            pszOutFormat = szShowIndeterminate;
        }
        OutCtl->Output("\n");

        if (AllocSort)
        {
            OutCtl->OutWarn("  Sorting by allocation size isn't supported.\n");
        }
        //else
        {
            // Output results sorted by Tag (natural storage order)

            for (i = 0; i < Buckets; i++)
            {
                for (pB = Bucket[i]; pB != NULL; pB = pB->pNextTag)
                {
                    if (pB->Allocated)
                    {
                        OutCtl->Output(pszOutFormat,
                                       &pB->Tag,
                                       pB->Allocated, ((ULONG64)pB->AllocatedSize) << POOL_BLOCK_SHIFT,
                                       pB->Free, ((ULONG64)pB->FreeSize) << POOL_BLOCK_SHIFT,
                                       pB->Indeterminate, ((ULONG64)pB->IndeterminateSize) << POOL_BLOCK_SHIFT
                                       );
                    }
                }
            }
        }

        OutCtl->Output("-------------------------------------------------------------------------------\n");
        hr = OutCtl->Output(pszOutFormat,
                            "Ttl:",
                            Allocated, ((ULONG64)AllocatedSize) << POOL_BLOCK_SHIFT,
                            Free, ((ULONG64)FreeSize) << POOL_BLOCK_SHIFT,
                            Indeterminate, ((ULONG64)IndeterminateSize) << POOL_BLOCK_SHIFT
                            );
    }

    return hr;
}


void
AccumTagUsage::Reset()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    AllocatedPages = 0;
    LargePages = 0;
    LargeAllocs = 0;
    FreePages = 0;
    ExpansionPages = 0;

    Allocated = 0;
    AllocatedSize = 0;
    Free = 0;
    FreeSize = 0;
    Indeterminate = 0;
    IndeterminateSize = 0;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            if (pB != NULL)
            {
                do
                {
                    pBNext = pB->pNextTag;
                    HeapFree(hHeap, 0, pB);
                    pB = pBNext;
                } while (pB != NULL);

                Bucket[i] = NULL;
            }
        }
    }
}


ULONG
AccumTagUsage::GetHashIndex(
    ULONG Tag
    )
{
#if BIG_ENDIAN
    return (((Tag & HighMask) >> HighShift) | ((Tag & LowMask) >> LowShift));
#else
    return ((((Tag << HighShiftLeft) >> HighShiftRight) & ~LowMask) | ((Tag >> LowShiftRight) & LowMask));
#endif
}


PTAG_BUCKET
AccumTagUsage::GetBucket(
    ULONG Tag
    )
{
    ULONG       Index = GetHashIndex(Tag);
    PTAG_BUCKET pB = Bucket[Index];

    if (pB == NULL ||
#if BIG_ENDIAN
        pB->Tag > Tag
#else
        strncmp((char *)&pB->Tag, (char *)&Tag, 4) > 0
#endif
        )
    {
        pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

        if (pB != NULL)
        {
            pB->Tag = Tag;
            pB->pNextTag = Bucket[Index];
            Bucket[Index] = pB;
        }
    }
    else
    {
        while (pB->pNextTag != NULL)
        {
            if (
#if BIG_ENDIAN
                pB->pNextTag->Tag > Tag
#else
                strncmp((char *)&pB->pNextTag->Tag, (char *)&Tag, 4) > 0
#endif
                )
            {
                break;
            }

            pB = pB->pNextTag;
        }

        if (pB->Tag != Tag)
        {
            PTAG_BUCKET pBPrev = pB;

            pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

            if (pB != NULL)
            {
                pB->Tag = Tag;
                pB->pNextTag = pBPrev->pNextTag;
                pBPrev->pNextTag = pB;
            }
        }
    }

    return pB;
}


ULONG
AccumTagUsage::SetTagFilter(
    ULONG TagFilter
    )
{
    ULONG NumBuckets;
    UCHAR *Filter = (UCHAR *)&TagFilter;
    ULONG i;
    ULONG HighMaskBits, LowMaskBits;
    UCHAR fc;

#if BIG_ENDIAN

    ULONG Mask = 0;
    ULONG MaskBits = 0;

    if (Filter[0] == '*')
    {
        Mask = -1;
        MaskBits = 32;
    }
    else
    {
        for ( i = 0; i < 32; i += 8 )
        {
            Mask <<= 8;
            fc = *Filter++;

            if ( fc == '*' )
            {
                Mask |= ((1 << i) - 1);
                MaskBits += 32 - i;
                break;
            }

            if ( fc == '?' )
            {
                Mask |= 0xFF;
                MaskBits += 8;
            }
        }
    }

    if (MaskBits > HashBitmaskLimit)
    {
        MaskBits = HashBitmaskLimit;
    }

    NumBuckets = (1 << MaskBits);

    for (HighShift = 32, HighMaskBits = 0;
         HighShift > 0 && HighMaskBits < MaskBits;
         HighShift--)
    {
        if (Mask & (1 << (HighShift-1)))
        {
            HighMaskBits++;
        }
        else if (HighMaskBits)
        {
            break;
        }
    }

    HighMask = Mask & ~((1 << HighShift) - 1);
    Mask &= ~HighMask;
    MaskBits -= HighMaskBits;
    HighShift -= MaskBits;

    for (LowShift = HighShift, LowMaskBits = 0;
         LowShift > 0 && LowMaskBits < MaskBits;
         LowShift--)
    {
        if (Mask & (1 << (LowShift-1)))
        {
            LowMaskBits++;
        }
        else if (LowMaskBits)
        {
            break;
        }
    }

    LowMask = Mask & ~((1 << LowShift) - 1);

#else

    HighMaskBits = 0;
    LowMaskBits = 0;

    HighShiftLeft = 32;
    HighShiftRight = 32;
    LowShiftRight = 32;
    LowMask = 0;

    for ( i = 0; i < 32; i += 8 )
    {
        fc = *Filter++;

        if ( fc == '*' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;

                LowMaskBits = ((HighShiftLeft != 0) ?
                               min(8, HashBitmaskLimit - HighMaskBits) :
                               0);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + HighMaskBits + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            break;
        }

        if ( fc == '?' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
                break;
            }
        }
    }

    NumBuckets = 1 << (HighMaskBits + LowMaskBits);

#endif

    if (NumBuckets-1 != GetHashIndex(-1))
    {
        DbgPrint("AccumTagUsage::SetTagFilter: Invalid hash was generated.\n");
        NumBuckets = 0;
    }

    return NumBuckets;
}


HRESULT
AccumTagUsageFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT         hr;
    DEBUG_VALUE     PoolType;
    AccumTagUsage  *atu = (AccumTagUsage *)Context;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)atu;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            hr = atu->Add(Tag->I32, FreePool, BlockSize);
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                Tag->I32 &= ~PROTECTED_POOL;
            }
            else if (PoolType.I32 & POOL_QUOTA_MASK)
            {
                Tag->I32 = 'CORP';
            }

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    hr = atu->Add(Tag->I32, AllocatedPool, BlockSize);
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    hr = atu->Add(Tag->I32, FreePool, BlockSize);
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                hr = atu->Add(Tag->I32, IndeterminatePool, BlockSize);
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}


HRESULT
SearchSessionPool(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG TagName,
    FLONG Flags,
    ULONG64 RestartAddr,
    PoolFilterFunc Filter,
    PALLOCATION_STATS AllocStats,
    PVOID Context
    )
/*++

Routine Description:

    Engine to search session pool.

Arguments:

    TagName - Supplies the tag to search for.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    HRESULT

--*/
{
    HRESULT     hr;

    OutputControl   OutCtl(Client);

    PDEBUG_SYMBOLS      Symbols;
    PDEBUG_DATA_SPACES  Data;

    LOGICAL     PhysicallyContiguous;
    ULONG       PoolBlockSize;
    ULONG64     PoolHeader;
    ULONG64     PoolPage;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       Previous;
    ULONG64     PoolStart;
    ULONG64     PoolStartPage;
    ULONG64     PoolPteAddress;
    ULONG64     PoolEnd;
    BOOL        PageReadFailed;
    ULONG64     PagesRead;
    ULONG64     PageReadFailures;
    ULONG64     PageReadFailuresAtEnd;
    ULONG64     LastPageRead;

    ULONG       PoolTypeFlags = Flags & (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED);

    ULONG64     NTModuleBase;
    ULONG       PoolHeadTypeID;
    ULONG       SessionHeadTypeID;
    ULONG       HdrSize;

    ULONG64 SessionSpace;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Symbols->Release();
        return hr;
    }

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if ((hr = Symbols->GetSymbolTypeId("NT!_POOL_HEADER", &PoolHeadTypeID, &NTModuleBase)) == S_OK &&
        (hr = Symbols->GetTypeSize(NTModuleBase, PoolHeadTypeID, & HdrSize)) == S_OK &&
        (hr = GetSessionSpace(Client, Session, &SessionSpace)) == S_OK)
    {
        ULONG               PoolTagOffset, ProcessBilledOffset;
        BOOL                bQuotaWithTag;

        DEBUG_VALUE         ReadSessionId;
        DEBUG_VALUE         PagedPoolInfo;

        DEBUG_VALUE         NonPagedPoolBytes;
        DEBUG_VALUE         NonPagedPoolAllocations;
        DEBUG_VALUE         NonPagedPoolStart;
        DEBUG_VALUE         NonPagedPoolEnd;

        DEBUG_VALUE         PagedPoolPages;
        DEBUG_VALUE         PagedPoolBytes;
        DEBUG_VALUE         PagedPoolAllocations;
        DEBUG_VALUE         PagedPoolStart;
        DEBUG_VALUE         PagedPoolEnd;

        ULONG               SessionSpaceTypeID;
        ULONG               PagedPoolInfoOffset;
        TypeOutputParser    SessionParser(Client); // Dump of MM_SESSION_SPACE
        TypeOutputParser    PoolHeadReader(Client);
        OutputState         OutState(Client);

        BOOL                SearchingPaged = FALSE;
        PRTL_BITMAP         PagedPoolAllocationMap = NULL;
        PRTL_BITMAP         EndOfPagedPoolBitmap = NULL;
        ULONG               BusyStart;
        PRTL_BITMAP         PagedPoolLargeSessionAllocationMap = NULL;

        BOOL                Continue = TRUE;

        bQuotaWithTag = (Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "PoolTag", &PoolTagOffset) == S_OK &&
                         Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "ProcessBilled", &ProcessBilledOffset) == S_OK &&
                         PoolTagOffset != ProcessBilledOffset);

        // General parser setup and dump MM_SESSION_SPACE structure
        if ((hr = OutState.Setup(0, &SessionParser)) == S_OK &&
            (hr = Symbols->GetTypeId(NTModuleBase, "MM_SESSION_SPACE", &SessionSpaceTypeID)) == S_OK &&
            ((hr = OutState.OutputTypeVirtual(SessionSpace, NTModuleBase, SessionSpaceTypeID, DEBUG_OUTTYPE_BLOCK_RECURSE)) == S_OK ||
             ((hr = OutState.OutputTypeVirtual(SessionSpace, NTModuleBase, SessionSpaceTypeID, 0)) == S_OK &&
              (hr = Symbols->GetFieldOffset(NTModuleBase, SessionSpaceTypeID, "PagedPoolInfo", &PagedPoolInfoOffset)) == S_OK &&
              (hr = OutState.OutputTypeVirtual(SessionSpace + PagedPoolInfoOffset, "NT!_MM_PAGED_POOL_INFO", 0)) == S_OK
            )) &&
            (hr = SessionParser.Get(&ReadSessionId, "SessionId", DEBUG_VALUE_INT32)) == S_OK)
        {
            OutCtl.Output("Searching session %ld pool.\n", ReadSessionId.I32);

            // Remaining type output goes to PoolHead reader
            hr = OutState.Setup(0, &PoolHeadReader);
        }
        else
        {
            OutCtl.OutErr("Error getting basic session pool information.\n");
        }

        while (hr == S_OK && Continue)
        {
            OutCtl.Output("\n");

            if (PoolTypeFlags & SEARCH_POOL_NONPAGED)
            {
                if (SessionParser.Get(&NonPagedPoolBytes, "NonPagedPoolBytes", DEBUG_VALUE_INT64) == S_OK &&
                    SessionParser.Get(&NonPagedPoolAllocations, "NonPagedPoolAllocations", DEBUG_VALUE_INT64) == S_OK)
                {
                    OutCtl.Output("NonPaged pool: %I64u bytes in %I64u allocations\n",
                                  NonPagedPoolBytes.I64, NonPagedPoolAllocations.I64);
                }

                OutCtl.Output(" NonPaged pool range reader isn't implemented.\n");

                PoolStart = 0;
                PoolEnd = 0;
                SearchingPaged = FALSE;
            }
            else
            {
                if (SessionParser.Get(&PagedPoolBytes, "PagedPoolBytes", DEBUG_VALUE_INT64) == S_OK &&
                    SessionParser.Get(&PagedPoolAllocations, "PagedPoolAllocations", DEBUG_VALUE_INT64) == S_OK)
                {
                    OutCtl.Output("Paged pool: %I64u bytes in %I64u allocations\n",
                                  PagedPoolBytes.I64, PagedPoolAllocations.I64);

                    if (SessionParser.Get(&PagedPoolPages, "AllocatedPagedPool", DEBUG_VALUE_INT64) == S_OK)
                    {
                        OutCtl.Output(" Paged Pool Info: %I64u pages allocated\n",
                                      PagedPoolPages.I64);
                    }
                }

                if ((hr = SessionParser.Get(&PagedPoolStart, "PagedPoolStart", DEBUG_VALUE_INT64)) != S_OK ||
                    (hr = SessionParser.Get(&PagedPoolEnd, "PagedPoolEnd", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr(" Couldn't get PagedPool range.\n");
                }
                else
                {
                    PoolStart = PagedPoolStart.I64;
                    PoolEnd = PagedPoolEnd.I64;
                    SearchingPaged = TRUE;

                    DEBUG_VALUE     PagedBitMap;

                    if (SessionParser.Get(&PagedBitMap, "PagedPoolAllocationMap", DEBUG_VALUE_INT64) == S_OK &&
                        GetBitMap(Client, PagedBitMap.I64, &PagedPoolAllocationMap) == S_OK &&
                        SessionParser.Get(&PagedBitMap, "EndOfPagedPoolBitmap", DEBUG_VALUE_INT64) == S_OK &&
                        GetBitMap(Client, PagedBitMap.I64, &EndOfPagedPoolBitmap) == S_OK)
                    {
                        ULONG   PositionAfterLastAlloc;
                        ULONG   AllocBits;
                        ULONG   UnusedBusyBits;

                        if (RtlCheckBit(EndOfPagedPoolBitmap, EndOfPagedPoolBitmap->SizeOfBitMap - 1))
                        {
                            BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                            UnusedBusyBits = 0;
                        }
                        else
                        {
                            OSCompat_RtlFindLastBackwardRunClear(
                                EndOfPagedPoolBitmap,
                                EndOfPagedPoolBitmap->SizeOfBitMap - 1,
                                &PositionAfterLastAlloc);

                            BusyStart = RtlFindSetBits(PagedPoolAllocationMap, 1, PositionAfterLastAlloc);
                            if (BusyStart < PositionAfterLastAlloc || BusyStart == -1)
                            {
                                BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                                UnusedBusyBits = 0;
                            }
                            else
                            {
                                UnusedBusyBits = PagedPoolAllocationMap->SizeOfBitMap - BusyStart;
                            }
                        }

                        AllocBits = RtlNumberOfSetBits(PagedPoolAllocationMap) - UnusedBusyBits;

                        AllocStats->AllocatedPages += AllocBits;
                        AllocStats->FreePages += (BusyStart - AllocBits);
                        AllocStats->ExpansionPages += UnusedBusyBits;

                        if (SessionParser.Get(&PagedBitMap, "PagedPoolLargeSessionAllocationMap", DEBUG_VALUE_INT64) == S_OK &&
                            GetBitMap(Client, PagedBitMap.I64, &PagedPoolLargeSessionAllocationMap) == S_OK)
                        {
                            ULONG AllocStart, AllocEnd;
                            ULONG LargeAllocs = RtlNumberOfSetBits(PagedPoolLargeSessionAllocationMap);

                            AllocStats->LargeAllocs += LargeAllocs;

                            AllocStart = 0;
                            AllocEnd = -1;

                            while (LargeAllocs > 0)
                            {
                                AllocStart = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, AllocStart);
                                if (AllocStart >= AllocEnd+1 && AllocStart != -1)
                                {
                                    AllocEnd = RtlFindSetBits(EndOfPagedPoolBitmap, 1, AllocStart);
                                    if (AllocEnd >= AllocStart && AllocEnd != -1)
                                    {
                                        AllocStats->LargePages += AllocEnd - AllocStart + 1;
                                        AllocStart++;
                                        LargeAllocs--;
                                    }
                                    else
                                    {
                                        OutCtl.OutWarn(" Warning Large Pool Allocation Map or End Of Pool Map is invalid.\n");
                                        break;
                                    }
                                }
                                else
                                {
                                    OutCtl.OutWarn(" Warning Large Pool Allocation Map is invalid.\n");
                                    break;
                                }
                            }

                            if (LargeAllocs != 0)
                            {
                                OutCtl.OutWarn(" %lu large allocations weren't calculated.\n", LargeAllocs);
                                AllocStats->LargeAllocs -= LargeAllocs;
                            }
                        }
                    }
                }
            }

            if (hr == S_OK)
            {
                OutCtl.Output("Searching %s pool (0x%p : 0x%p) for Tag: %c%c%c%c\r\n\n",
                              ((PoolTypeFlags & SEARCH_POOL_NONPAGED) ? "NonPaged" : "Paged"),
                              PoolStart,
                              PoolEnd,
                              TagName,
                              TagName >> 8,
                              TagName >> 16,
                              TagName >> 24);

                PageReadFailed = FALSE;
                PoolStartPage = PAGE_ALIGN64(PoolStart);
                PoolPage = PoolStart;
                PagesRead = 0;
                PageReadFailures = 0;
                PageReadFailuresAtEnd = 0;
                LastPageRead = PAGE_ALIGN64(PoolPage);

                while (PoolPage < PoolEnd && hr == S_OK)
                {
                    Pool        = PAGE_ALIGN64(PoolPage);
                    StartPage   = Pool;
                    Previous    = 0;

                    if (Session != CURRENT_SESSION)
                    {
                        OutCtl.Output("Currently only searching the current session is supported.\n");
                        PoolPage = PoolEnd;
                        break;
                    }

                    if (OutCtl.GetInterrupt() == S_OK)
                    {
                        OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                      Pool-1);
                        hr = E_ABORT;
                        break;
                    }

                    if (SearchingPaged)
                    {
                        if (PagedPoolAllocationMap != NULL)
                        {
                            ULONG   StartPosition, EndPosition;

                            StartPosition = (ULONG)((Pool - PoolStartPage) >> PageShift);
                            EndPosition = RtlFindSetBits(EndOfPagedPoolBitmap, 1, StartPosition);
                            if (EndPosition < StartPosition) EndPosition = -1;

                            if (!RtlCheckBit(PagedPoolAllocationMap, StartPosition))
                            {
                                if (PageReadFailed)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                    }

                                    PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                    LastPageRead = StartPage;
                                    PageReadFailed = FALSE;
                                }

                                if (EndPosition == -1)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;
                                }
                                else
                                {
                                    PoolPage = PoolStartPage + (((ULONG64)EndPosition + 1) << PageShift);
                                }

                                continue;
                            }
                            else if (EndOfPagedPoolBitmap != NULL)
                            {
                                if (PagedPoolLargeSessionAllocationMap != NULL &&
                                    RtlCheckBit(PagedPoolLargeSessionAllocationMap, StartPosition))
                                {
                                    if (EndPosition == -1)
                                    {
                                        OutCtl.OutWarn("No end to large pool allocation @ 0x%p found.\n", Pool);
                                        PoolPage = PoolEnd;
                                    }
                                    else
                                    {
                                        EndPosition++;

                                        if (PageReadFailed)
                                        {
                                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                            {
                                                OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                            }

                                            PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                            LastPageRead = StartPage;
                                            PageReadFailed = FALSE;
                                        }

                                        PoolPage = PoolStartPage + (((ULONG64)EndPosition) << PageShift);

                                        if (Flags & SEARCH_POOL_PRINT_LARGE)
                                        {
                                            OutCtl.Output("0x%p size: %5I64x  %s UNTAGGED Large\n",
                                                          StartPage,
                                                          PoolPage - StartPage,
                                                          ((RtlAreBitsSet(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                           "(Allocated)" :
                                                           ((RtlAreBitsClear(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                            "(! Free !) " :
                                                            "(!! Partially Allocated !!)"))
                                                          );
                                        }

                                        if (Flags & SEARCH_POOL_LARGE_ONLY)
                                        {
                                            // Quickly locate next large allocation
                                            StartPosition = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, EndPosition);

                                            if (StartPosition < EndPosition || StartPosition == -1)
                                            {
                                                OutCtl.OutVerb(" No large allocations found after 0x%p\n", PoolPage-1);
                                                PoolPage = PoolEnd;
                                            }
                                            else
                                            {
                                                PoolPage = PoolStartPage + (((ULONG64)StartPosition) << PageShift);
                                            }
                                        }
                                    }

                                    continue;
                                }
                                else if (EndPosition == -1)
                                {
                                    if (PageReadFailed)
                                    {
                                        if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                        {
                                            OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                        }

                                        PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                        LastPageRead = StartPage;
                                        PageReadFailed = FALSE;
                                    }

                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;

                                    continue;
                                }
                                else if (StartPosition >= BusyStart)
                                {
                                    OutCtl.OutWarn("Found end of allocation at %lu within expansion pages starting at %lu.\n",
                                                   EndPosition, BusyStart);
                                }
                            }
                        }
                    }

                    if (Flags & SEARCH_POOL_LARGE_ONLY)
                    {
                        OutCtl.OutErr(" Unable to identify large pages.  Terminating search at 0x%p.\n", StartPage);
                        PoolPage = PoolEnd;
                        hr = E_FAIL;
                        continue;
                    }

                    // Search page for small allocations
                    while (PAGE_ALIGN64(Pool) == StartPage && hr == S_OK)
                    {
                        DEBUG_VALUE HdrPoolTag, BlockSize, PreviousSize, AllocatorBackTraceIndex, PoolTagHash;
                        ULONG PoolType;

                        PoolHeadReader.DiscardOutput();

                        if ((hr = OutState.OutputType(FALSE, Pool, NTModuleBase, PoolHeadTypeID, 0)) != S_OK ||
                            PoolHeadReader.Get(&HdrPoolTag, "PoolTag", DEBUG_VALUE_INT32) != S_OK)
                        {
                            if (hr != S_OK)
                            {
                                PSTR    psz;

                                OutCtl.OutErr("Type read error %s @ 0x%p.\n", pszHRESULT(hr), Pool);

                                OutCtl.OutWarn("Failed to read an allocated page @ 0x%p.\n", StartPage);

                                if (PoolHeadReader.GetOutputCopy(&psz) == S_OK)
                                {
                                    if (strchr(psz, '?') != NULL)
                                    {
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        OutCtl.OutVerb("PoolHeadReader contains:\n"
                                                       "%s\n", psz);

                                        OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                                      Pool);
                                        hr = E_ABORT;
                                    }

                                    PoolHeadReader.FreeOutputCopy(psz);
                                }

                                if (hr == E_ABORT)
                                {
                                    break;
                                }
                            }

                            if (!PageReadFailed)
                            {
                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    OutCtl.OutWarn(" Couldn't read pool from 0x%p", Pool);
                                }

                                PagesRead += (StartPage - LastPageRead) / PageSize;
                                LastPageRead = StartPage;
                                PageReadFailed = TRUE;
                            }

                            if ((hr = GetNextResidentAddress(Client,
                                                             Session,
                                                             StartPage + PageSize,
                                                             PoolEnd,
                                                             &PoolPage,
                                                             NULL)) != S_OK)
                            {
                                if (hr != E_ABORT)
                                {
                                    hr = S_OK;
                                }

                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    OutCtl.OutWarn(" to 0x%p.\n", PoolEnd);
                                    OutCtl.OutWarn("No remaining resident page found.\n");
                                }

                                PageReadFailuresAtEnd = (PoolEnd - LastPageRead) / PageSize;
                                PageReadFailures += PageReadFailuresAtEnd;
                                LastPageRead = PoolEnd;
                                PageReadFailed = FALSE;

                                PoolPage = PoolEnd;
                            }

                            break;
                        }

                        if (PageReadFailed)
                        {
                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                            {
                                OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                            }

                            PageReadFailures += (StartPage - LastPageRead) / PageSize;
                            LastPageRead = StartPage;
                            PageReadFailed = FALSE;
                        }

                        if (PoolHeadReader.Get(&BlockSize, "BlockSize", DEBUG_VALUE_INT32) != S_OK)
                        {
                            OutCtl.OutErr("Error reading BlockSize @ 0x%p.\n", Pool);
                            break;
                        }

                        if ((BlockSize.I32 << POOL_BLOCK_SHIFT) > PageSize)//POOL_PAGE_SIZE)
                        {
                            OutCtl.OutVerb("Bad allocation size @ 0x%p, too large\n", Pool);
                            break;
                        }

                        if (BlockSize.I32 == 0)
                        {
                            OutCtl.OutVerb("Bad allocation size @ 0x%p, zero is invalid\n", Pool);
                            break;
                        }

                        if (PoolHeadReader.Get(&PreviousSize, "PreviousSize", DEBUG_VALUE_INT32) != S_OK ||
                            PreviousSize.I32 != Previous)
                        {
                            OutCtl.OutVerb("Bad previous allocation size @ 0x%p, last size was 0x%lx\n", Pool, Previous);
                            break;
                        }

                        Filter(&OutCtl,
                               Pool,
                               TagName,
                               &PoolHeadReader,
                               &HdrPoolTag,
                               BlockSize.I32,
                               bQuotaWithTag,
                               Context
                               );

                        Previous = BlockSize.I32;
                        Pool += (Previous << POOL_BLOCK_SHIFT);

                        if ( OutCtl.GetInterrupt() == S_OK)
                        {
                            OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                          PoolPage-1);
                            hr = E_ABORT;
                        }
                    }

                    if (hr == S_OK)
                    {
                        PoolPage = (PoolPage + PageSize);
                    }
                }

                if (PageReadFailed)
                {
                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                    {
                        OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                    }

                    PageReadFailuresAtEnd = (PoolPage - LastPageRead) / PageSize;
                    PageReadFailures += PageReadFailuresAtEnd;
                    PageReadFailed = FALSE;
                }
                else
                {
                    PagesRead += (PoolPage - LastPageRead) / PageSize;
                }

                OutCtl.Output(" Pages Read: %I64d\n"
                              "   Failures: %I64d  (%I64d at end of search)\n",
                              PagesRead, PageReadFailures, PageReadFailuresAtEnd);
            }

            if (PoolTypeFlags == (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED))
            {
                PoolTypeFlags = SEARCH_POOL_PAGED;
            }
            else
            {
                Continue = FALSE;
            }
        }

        if (PagedPoolAllocationMap != NULL) FreeBitMap(PagedPoolAllocationMap);
        if (EndOfPagedPoolBitmap != NULL) FreeBitMap(EndOfPagedPoolBitmap);
        if (PagedPoolLargeSessionAllocationMap != NULL) FreeBitMap(PagedPoolLargeSessionAllocationMap);
    }

    return hr;
}


HRESULT
GetTagFilter(
    PDEBUG_CLIENT Client,
    PCSTR *pArgs,
    PDEBUG_VALUE TagFilter
    )
{
    HRESULT hr;

    PCSTR   args;
    PCSTR   TagArg;

    ULONG   TagLen;
    CHAR    TagEnd;
    ULONG   WildCardPos;

    OutputControl   OutCtl(Client);

    TagArg = args = *pArgs;
    TagFilter->Type = DEBUG_VALUE_INVALID;

    do
    {
        args++;
    } while (*args != '\0' && !isspace(*args));

    while (isspace(*args)) args++;

    if (TagArg[0] == '0' && TagArg[1] == 'x')
    {
        hr = Evaluate(Client, TagArg, DEBUG_VALUE_INT64,
                      EVALUATE_DEFAULT_RADIX, TagFilter,
                      NULL, NULL,
                      EVALUATE_COMPACT_EXPR);
    }
    else
    {
        if (TagArg[0] == '`' || TagArg[0] == '\'' || TagArg[0] == '\"')
        {
            TagEnd = TagArg[0];
            TagArg++;
            args = TagArg;

            while (args - TagArg < 4 &&
                   *args != '\0' &&
                   *args != TagEnd)
            {
                args++;
            }
            TagLen = (ULONG)(args - TagArg);
            if (*args == TagEnd) args++;
            while (isspace(*args)) args++;
        }
        else
        {
            TagLen = (ULONG)(args - TagArg);
            TagEnd = '\0';
        }

        if (TagLen == 0 ||
            (TagLen < 4 &&
             TagArg[TagLen-1] != '*'
            ) ||
            (TagLen >= 4 &&
             TagArg[4] != '\0' &&
             !isspace(TagArg[4]) &&
             (TagArg[4] != TagEnd || (TagArg[5] != '\0' && !isspace(TagArg[5])))
            )
           )
        {
            OutCtl.OutErr(" Invalid Tag filter.\n");
            hr = E_INVALIDARG;
        }
        else
        {
            hr = S_OK;

            for (WildCardPos = 0; WildCardPos < TagLen; WildCardPos++)
            {
                if (TagArg[WildCardPos] == '*')
                {
                    ULONG NewTagLen = WildCardPos + 1;
                    if (NewTagLen < TagLen)
                    {
                        OutCtl.OutWarn(" Ignoring %lu characters after * in Tag.\n",
                                       TagLen - NewTagLen);
                    }
                    TagLen = NewTagLen;
                    // loop will terminate
                }
            }

            if (TagLen < 4)
            {
                TagFilter->I32 = '    ';
                while (TagLen-- > 0)
                {
                    TagFilter->RawBytes[TagLen] = TagArg[TagLen];
                }
            }
            else
            {
                TagFilter->I32 = TagArg[0] | (TagArg[1] << 8) | (TagArg[2] << 16) | (TagArg[3] << 24);
            }
            TagFilter->Type = DEBUG_VALUE_INT32;
        }
    }

    if (hr == S_OK)
    {
        *pArgs = args;
    }

    return hr;
}


HRESULT
OutputAllocStats(
    OutputControl *OutCtl,
    PALLOCATION_STATS AllocStats,
    BOOL PartialResults
    )
{
    return OutCtl->Output("\n"
                          " %I64u bytes in %lu allocated pages\n"
                          " %I64u bytes in %lu large allocations\n"
                          " %I64u bytes in %lu free pages\n"
                          " %I64u bytes available in %lu expansion pages\n"
                          "\n"
                          "%s found (small allocations only): %lu\n"
                          "  Allocated: %I64u bytes in %lu entries\n"
                          "  Free: %I64u bytes in %lu entries\n"
                          "  Undetermined: %I64u bytes in %lu entries\n",
                          ((ULONG64) AllocStats->AllocatedPages) << PageShift,
                          AllocStats->AllocatedPages,
                          ((ULONG64) AllocStats->LargePages) << PageShift,
                          AllocStats->LargeAllocs,
                          ((ULONG64) AllocStats->FreePages) << PageShift,
                          AllocStats->FreePages,
                          ((ULONG64) AllocStats->ExpansionPages) << PageShift,
                          AllocStats->ExpansionPages,
                          ((PartialResults) ? "PARTIAL entries" : "Entries"),
                          AllocStats->Allocated + AllocStats->Free + AllocStats->Indeterminate,
                          ((ULONG64)AllocStats->AllocatedSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Allocated,
                          ((ULONG64)AllocStats->FreeSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Free,
                          ((ULONG64)AllocStats->IndeterminateSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Indeterminate
                          );
}


DECLARE_API( spoolfind )
{
    HRESULT         hr = S_OK;
    
    BEGIN_API( spoolfind );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    FLONG           Flags = 0;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'l':
                        Flags |= SEARCH_POOL_PRINT_LARGE;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (!BadArg && hr == S_OK)
    {
        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            if (Flags & SEARCH_POOL_PRINT_LARGE)
            {
                TagName.I32 = '   *';
                Flags |= SEARCH_POOL_LARGE_ONLY;
            }
            else
            {
                OutCtl.OutErr("Missing Tag.\n");
                hr = E_INVALIDARG;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolfind is like !kdexts.poolfind, but for the SessionId specified.\n"
                          "\n");
        }

        OutCtl.Output("Usage: spoolfind [-lnpf] [-s SessionId] Tag\n"
                      "    -f - show read failure ranges\n"
                      "    -l - show large allocations\n"
                      "    -n - show non-paged pool\n"
                      "    -p - show paged pool\n"
                      "\n"
                      "    Tag - Pool tag to search for\n"
                      "            Can be 4 character string or\n"
                      "             hex value in 0xXXXX format\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        hr = SearchSessionPool(Client,
                               Session.I32, TagName.I32, Flags,
                               0,
                               CheckPrintAndAccumFilter, &AllocStats, &AllocStats);

        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;
}


DECLARE_API( spoolsum )
{
    HRESULT             hr = S_OK;
    
    BEGIN_API( spoolsum );

    ULONG               RemainingArgIndex;

    FLONG               Flags = 0;
    DEBUG_VALUE         Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl       OutCtl(Client);

    while (isspace(*args)) args++;

    while (hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            if (*args == '\0' || isspace(*args)) hr = E_INVALIDARG;

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        hr = E_INVALIDARG;
                        break;
                }

                if (hr != S_OK) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Session.Type == DEBUG_VALUE_INVALID)
            {
                hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                if (hr != S_OK)
                {
                    OutCtl.OutErr("Invalid Session.\n");
                }
                else
                {
                    args += RemainingArgIndex;
                }
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                hr = E_INVALIDARG;
            }
        }
    }

    if (hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolsum summarizes session pool information for SessionId specified.\n"
                          "\n");
            hr = S_OK;
        }

        OutCtl.Output("Usage: spoolsum [-fnp] [[-s] SessionId]\n"
                      "    f - show read failure ranges\n"
                      "    n - show non-paged pool\n"
                      "    p - show paged pool (Default)\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    
        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED;
        }

        hr = SearchSessionPool(Client,
                               DEFAULT_SESSION, '   *', Flags,
                               0,
                               AccumAllFilter, &AllocStats, &AllocStats);
    
        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;
}


DECLARE_API( spoolused )
{
    HRESULT         hr = S_OK;
    
    BEGIN_API( spoolused );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    BOOL            NonPagedUsage = FALSE;
    BOOL            PagedUsage = FALSE;
    BOOL            AllocSort = FALSE;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        AllocSort = TRUE;
                        args++;
                        break;

                    case 'n':
                        NonPagedUsage = TRUE;
                        args++;
                        break;

                    case 'p':
                        PagedUsage = TRUE;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolused is like !kdexts.poolused, but for the SessionId specified.\n"
                          "\n");
        }

        OutCtl.Output("Usage: spoolused [-anp] [-s SessionId] [Tag]\n"
                      "    -a - sort by allocation size (Not Implemented)\n"
                      "    -n - show non-paged pool\n"
                      "    -p - show paged pool\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      "\n"
                      "    Tag - Pool tag filter\n"
                      "            Can be 4 character string or\n"
                      "             hex value in 0xXXXX format\n"
                      );
    }
    else
    {
        if (!NonPagedUsage && !PagedUsage)
        {
            NonPagedUsage = TRUE;
            PagedUsage = TRUE;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            TagName.I32 = '   *';
        }

        AccumTagUsage   atu(TagName.I32);

        if (atu.Valid() != S_OK)
        {
            OutCtl.OutErr("Error: failed to prepare tag usage reader.\n");
            hr = E_FAIL;
        }

        if (hr == S_OK && NonPagedUsage)
        {
            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_NONPAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(&OutCtl, AllocSort);
            }
            else
            {
                OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
            }
        }

        if (hr == S_OK && PagedUsage)
        {
            if (NonPagedUsage) atu.Reset();

            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_PAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(&OutCtl, AllocSort);
            }
            else
            {
                OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\output.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.cxx

Abstract:

    This file contains output state control and output callback classes.

Author:

    Jason Hartman (JasonHa) 2000-11-20

Environment:

    User Mode

--*/

#include "precomp.hxx"


HRESULT
OutputControl::SetControl(
    ULONG OutputControl,
    PDEBUG_CLIENT Client
    )
{
    ULONG   SendMask = OutputControl & DEBUG_OUTCTL_SEND_MASK;

    if (OutputControl != DEBUG_OUTCTL_AMBIENT &&
        (
#if DEBUG_OUTCTL_THIS_CLIENT > 0
        SendMask < DEBUG_OUTCTL_THIS_CLIENT ||
#endif
        SendMask > DEBUG_OUTCTL_LOG_ONLY ||
        (OutputControl & ~(DEBUG_OUTCTL_SEND_MASK |
                           DEBUG_OUTCTL_NOT_LOGGED |
                           DEBUG_OUTCTL_OVERRIDE_MASK))))
    {
        return E_INVALIDARG;
    }

    if (Client != NULL)
    {
        HRESULT         hr;
        PDEBUG_CONTROL  NewControl;

        // Switch to new client
        if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&NewControl)) != S_OK)
        {
            return hr;
        }

        if (Control != NULL) Control->Release();
        Control = NewControl;
    }

    OutCtl = OutputControl;

    return S_OK;
}


HRESULT
OutputControl::Output(
    ULONG Mask,
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    if (Control == NULL) return E_FAIL;

    va_start(Args, Format);
    if (OutCtl == DEBUG_OUTCTL_AMBIENT)
    {
        hr = Control->OutputVaList(Mask, Format, Args);
    }
    else
    {
        hr = Control->ControlledOutputVaList(OutCtl, Mask, Format, Args);
    }
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutputVaList(
    ULONG Mask,
    PCSTR Format,
    va_list Args
    )
{
    HRESULT hr;

    if (Control == NULL) return E_FAIL;

    if (OutCtl == DEBUG_OUTCTL_AMBIENT)
    {
        hr = Control->OutputVaList(Mask, Format, Args);
    }
    else
    {
        hr = Control->ControlledOutputVaList(OutCtl, Mask, Format, Args);
    }

    return hr;
}

HRESULT
OutputControl::Output(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutErr(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutWarn(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutVerb(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);

    return hr;
}


HRESULT
OutputControl::GetInterrupt(
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->GetInterrupt();
}


HRESULT
OutputControl::SetInterrupt(
    ULONG Flags
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->SetInterrupt(Flags);
}


HRESULT
OutputControl::Evaluate(
    IN PCSTR Expression,
    IN ULONG DesiredType,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->Evaluate(Expression,
                          DesiredType,
                          Value,
                          RemainderIndex);
}


HRESULT
OutputControl::CoerceValue(
    IN PDEBUG_VALUE In,
    IN ULONG OutType,
    OUT PDEBUG_VALUE Out
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->CoerceValue(In,
                             OutType,
                             Out);
}


HRESULT
OutputControl::IsPointer64Bit(
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->IsPointer64Bit();
}



OutputState::OutputState(
    PDEBUG_CLIENT OrgClient,
    BOOL SameClient
    )
{
    hrInit = S_FALSE;
    Client = NULL;
    Control = NULL;
    Symbols = NULL;

    SetCallbacks = FALSE;

    CreatedClient = FALSE;
    Saved = FALSE;

    if (OrgClient != NULL)
    {
        if (SameClient)
        {
            Client = OrgClient;
            Client->AddRef();
            CreatedClient = TRUE;
            hrInit = S_OK;
        }
        else
        {
            hrInit = OrgClient->CreateClient(&Client);
        }
    }
}


OutputState::~OutputState()
{
    if (!CreatedClient) Restore();

    EXT_RELEASE(Symbols);
    EXT_RELEASE(Control);

    // If Client was newly created for OutputState, then
    // there shouldn't be any other references to Client.
    if (CreatedClient)
    {
        ULONG   RemainingRefs;

        RemainingRefs = Client->AddRef();
        if (RemainingRefs > 2)
        {
            DbgPrint("OutputState: %lu refs outstanding on created client.\n",
                     RemainingRefs-2);
            DbgBreakPoint();

            // As a precaution, Restore the callbacks;
            // so, any set callback may be cleaned up.
            Restore();
        }
        Client->Release();
    }

    if (Client != NULL) Client->Release();
}


HRESULT
OutputState::Setup(
    ULONG OutMask,
    PDEBUG_OUTPUT_CALLBACKS OutCallbacks
    )
{
    HRESULT hr = hrInit;
    ULONG   LastOutMask;

    if (hr == S_OK)
    {
        if (CreatedClient && !Saved)
        {
            if ((hr = Client->GetOutputMask(&OrgOutMask)) == S_OK &&
                (hr = Client->GetOutputCallbacks(&OrgOutCallbacks)) == S_OK)
            {
                Saved = TRUE;
            }
        }

        if (hr == S_OK &&
            (hr = Client->GetOutputMask(&LastOutMask)) == S_OK &&
            (hr = Client->SetOutputMask(OutMask)) == S_OK)
        {
            if (!Saved && !SetCallbacks)
            {
                OrgOutMask = LastOutMask;
                OrgOutCallbacks = NULL;
            }

            if ((hr = Client->SetOutputCallbacks(OutCallbacks)) == S_OK)
            {
                SetCallbacks = TRUE;
            }
            else
            {
                Client->SetOutputMask(LastOutMask);
            }
        }
    }


    if (hr == S_OK &&
        Symbols == NULL)
    {
        hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
    }

    return hr;
}


HRESULT
OutputState::Execute(
    PCSTR pszCommand
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Control == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugControl), (void **)&Control);
        }

        if (hr == S_OK)
        {
            hr = Control->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                  DEBUG_OUTCTL_NOT_LOGGED |
                                  DEBUG_OUTCTL_OVERRIDE_MASK,
                                  pszCommand,
                                  DEBUG_EXECUTE_NOT_LOGGED |
                                  DEBUG_EXECUTE_NO_REPEAT);

            if (hr != S_OK)
            {
                DbgPrint("IDebugControl::Execute returned %s.\n",
                         pszHRESULT(hr));
            }
        }
    }

    return hr;
}


HRESULT
OutputState::OutputType(
    IN BOOL Physical,
    IN ULONG64 Offset,
    IN PCSTR Type,
    IN ULONG Flags
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Symbols == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
        }

        if (hr == S_OK)
        {
            ULONG64 Module;
            ULONG   TypeId;

            hr = GetTypeId(Client, Type, &TypeId, &Module);

            if (hr != S_OK)
            {
                OutputControl   OutCtl(Client);
                ULONG           ModuleIndex = 0;

                while ((hr = Symbols->GetModuleByIndex(ModuleIndex, &Module)) == S_OK &&
                       (Module != 0))
                {
                    if ((hr = Symbols->GetTypeId(Module, Type, &TypeId)) == S_OK)
                    {
                        OutCtl.OutVerb("Found %s: TypeId 0x%lx in module @ %p.\n",
                                       Type, TypeId, Module);
                        break;
                    }

                    ModuleIndex++;
                    Module = 0;
                }

                if (hr == S_OK &&
                    (Module == 0 || TypeId == 0))
                {
                    hr = S_FALSE;
                }

                if (hr != S_OK)
                {
                    OutCtl.OutVerb("Couldn't find %s in any of %lu modules.\n",
                                   Type, ModuleIndex);
                }
            }

            if (hr == S_OK)
            {
                hr = OutputType(Physical, Offset, Module, TypeId, Flags);
            }
        }
    }

    return hr;
}


HRESULT
OutputState::OutputType(
    IN BOOL Physical,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Symbols == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
        }

        if (hr == S_OK)
        {
            if (Physical)
            {
                hr = Symbols->OutputTypedDataPhysical(DEBUG_OUTCTL_THIS_CLIENT |
                                                      DEBUG_OUTCTL_NOT_LOGGED |
                                                      DEBUG_OUTCTL_OVERRIDE_MASK,
                                                      Offset,
                                                      Module,
                                                      TypeId,
                                                      Flags);
            }
            else
            {
                hr = Symbols->OutputTypedDataVirtual(DEBUG_OUTCTL_THIS_CLIENT |
                                                     DEBUG_OUTCTL_NOT_LOGGED |
                                                     DEBUG_OUTCTL_OVERRIDE_MASK,
                                                     Offset,
                                                     Module,
                                                     TypeId,
                                                     Flags);
            }

            if (hr != S_OK)
            {
                DbgPrint("IDebugSymbols::OutputTypedData%s returned %s for 0x%I64x.\n",
                         (Physical ? "Physical" : "Virtual"),
                         pszHRESULT(hr),
                         Offset);
            }
        }
    }

    return hr;
}


void OutputState::Restore()
{
    if (SetCallbacks)
    {
        Client->SetOutputCallbacks(OrgOutCallbacks);
        Client->SetOutputMask(OrgOutMask);

        SetCallbacks = FALSE;
    }

    if (Saved)
    {
        if (OrgOutCallbacks != NULL) OrgOutCallbacks->Release();
        Saved = FALSE;
    }
}



//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (//(InterfaceId == IID_IUnknown) ||
        (InterfaceId == __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be allocated on a
    // stack or statically, but we retain a refcount
    // for debugging purposes.
    return ++RefCount;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be allocated on a
    // stack or statically, but we retain a refcount
    // for debugging purposes.
    RefCount--;

    if (RefCount < 1)
    {
        DbgPrint("DefOutputCallbacks@0x%p::RefCount(%lu) < 1.\n", this, RefCount);
        DbgBreakPoint();
    }

    return RefCount;
}

STDMETHODIMP
DefOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    // The default Output ignores all Output calls.
    return S_OK;
}


//----------------------------------------------------------------------------
//
// DebugOutputCallbacks::Output
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    DbgPrint("Mask: 0x%lx\tOutput Begin:\n%s:Output End\n", Mask, Text);

    return S_OK;
}


//----------------------------------------------------------------------------
//
// OutputReader
//
// General DebugOutputCallback class to parse output.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OutputReader::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    ULONG       TextLen = strlen(Text);

    if (BufferLeft < TextLen)
    {
        PSTR    NewBuffer;
        SIZE_T  NewBufferSize;

        if (hHeap == NULL)
        {
            hHeap = GetProcessHeap();
            if (hHeap == NULL) return S_FALSE;
        }

        // New length we need plus some extra space
        NewBufferSize = BufferSize + TextLen + 256;

        NewBuffer = (PSTR) ((Buffer == NULL) ?
                            HeapAlloc(hHeap, 0, NewBufferSize):
                            HeapReAlloc(hHeap, 0, Buffer, NewBufferSize));

        if (NewBuffer == NULL)
        {
            DbgPrint("Buffer alloc failed.\n");
            return E_OUTOFMEMORY;
        }

        // How much was really allocated?
        NewBufferSize = HeapSize(hHeap, 0, NewBuffer);

        // If this was the first alloc, initialize
        // buffer and account for terminating zero.
        if (Buffer == NULL)
        {
            NewBuffer[0] = '\0';
            BufferLeft = -1;
        }

        // Update buffer data
        Buffer = NewBuffer;
        BufferLeft += NewBufferSize - BufferSize;
        BufferSize = NewBufferSize;
    }

    // Append new text
    strcat(Buffer, Text);
    BufferLeft -= TextLen;

    return S_OK;
}


// Discard any text left unused by Parse
void
OutputReader::DiscardOutput()
{
    if (Buffer != NULL)
    {
        Buffer[0] = '\0';
        BufferLeft = BufferSize - 1;
    }
}


// Get a copy of the output buffer
HRESULT
OutputReader::GetOutputCopy(
    PSTR *Copy
    )
{
    if (Copy == NULL) return E_INVALIDARG;

    *Copy = NULL;

    if (Buffer == NULL) return S_OK;

    SIZE_T  BufferLength = BufferSize - BufferLeft;

    *Copy = (PSTR)HeapAlloc(hHeap, 0, BufferLength);

    if (*Copy != NULL)
    {
        RtlCopyMemory(*Copy, Buffer, BufferLength);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


//----------------------------------------------------------------------------
//
// OutputParser
//
// General DebugOutputCallback class to parse output.
//
//----------------------------------------------------------------------------

HRESULT
OutputParser::ParseOutput(FLONG Flags)
{
    HRESULT hr;
    ULONG   TextRemainingIndex;

    if (Buffer == NULL)
    {
        return S_OK;
    }

    if (Flags & PARSE_OUTPUT_ALL)
    {
        UnparsedIndex = 0;
    }

    if ((hr = Parse(Buffer + UnparsedIndex, &TextRemainingIndex)) == S_OK)
    {
        UnparsedIndex += TextRemainingIndex;

        if (((Flags & PARSE_OUTPUT_NO_DISCARD) == 0) &&
            (UnparsedIndex > 0))
        {
            RtlMoveMemory(Buffer,
                          Buffer + UnparsedIndex,
                          BufferSize - UnparsedIndex - BufferLeft + 1);

            BufferLeft += UnparsedIndex;
            UnparsedIndex = 0;
        }
    }

    return hr;
}


void
OutputParser::DiscardOutput()
{
    OutputReader::DiscardOutput();
    UnparsedIndex = 0;
}


//----------------------------------------------------------------------------
//
// BasicOutputParser
//
// Basic DebugOutputCallback class to parse output looking for 
// string keys and subsequent values.
//
//----------------------------------------------------------------------------

HRESULT
BasicOutputParser::LookFor(
    PDEBUG_VALUE Value,
    PCSTR Key,
    ULONG Type,
    ULONG Radix
    )
{
    if ((1 > strlen(Key)) ||
        (strlen(Key) >= sizeof(Entries->Key)/sizeof(Entries->Key[0])))
    {
        return E_INVALIDARG;
    }

    if (NumEntries >= MaxEntries) return E_OUTOFMEMORY;

    Entries[NumEntries].Value = Value;
    strcpy(Entries[NumEntries].Key, Key);

    if (Value != NULL)
    {
        Value->Type = DEBUG_VALUE_INVALID;

        if (Radix == PARSER_UNSPECIFIED_RADIX)
        {
            // Set Radix to Hex since value is likely to be an address
            // Otherwise type a deafult of decimal.
            Radix = (Type == DEBUG_VALUE_INT64) ? 16 : 10;
        }

        Entries[NumEntries].Type = Type;
        Entries[NumEntries].Radix = Radix;
    }

    NumEntries++;

    return S_OK;
}

HRESULT
BasicOutputParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    HRESULT     hr = S_OK;
    PCSTR       pStrUnused = Text;
    PCSTR       pStr;
    ULONG       EvalLen;

//    DbgPrint("BasicOutputParser::Parse: Searching \"%s\"\n", pStrUnused);

    while (CurEntry < NumEntries)
    {
        pStr = strstr(pStrUnused, Entries[CurEntry].Key);
        if (pStr == NULL)
        {
            break;
        }

        pStr += strlen(Entries[CurEntry].Key);

        if (Entries[CurEntry].Value != NULL)
        {
            hr = Evaluate(Client,
                          pStr,
                          Entries[CurEntry].Type,
                          Entries[CurEntry].Radix,
                          Entries[CurEntry].Value,
                          &EvalLen);

            if (hr != S_OK)
            {
                DbgPrint("Evaluate returned HRESULT 0x%lx.\n", hr);
                break;
            }

//            DbgPrint("BasicOutputParser::Parse: Found 0x%I64x after \"%s\".\n", Entries[CurEntry].Value->I64, Entries[CurEntry].Key);

            pStr += EvalLen;
        }

        CurEntry++;
        pStrUnused = pStr;
    }

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// BitFieldParser
//
// DebugOutputCallback class to parse bitfield type output
//
//----------------------------------------------------------------------------

BitFieldParser::BitFieldParser(
    PDEBUG_CLIENT Client,
    BitFieldInfo *BFI
    ) :
    BitFieldReader(Client, 2)
{
    if (BFI != NULL &&
        BitFieldReader.LookFor(&BitPos, ": Pos ", DEBUG_VALUE_INT32) == S_OK &&
        BitFieldReader.LookFor(&Bits, ", ", DEBUG_VALUE_INT32) == S_OK)
    {
        BitField = BFI;
        BitField->Valid = FALSE;
        BitField->BitPos = 0;
        BitField->Bits = 0;
        BitField->Mask = 0;
    }
    else
    {
        BitField = NULL;
    }
}


HRESULT
BitFieldParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    PCSTR           pStrUnused = Text;
    ULONG           UnusedIndex = 0;
    PCSTR           pStrRemaining;
    BitFieldInfo    Field;

    do
    {
        if (BitFieldReader.Complete() == S_OK)
        {
            BitFieldReader.Relook();
        }

        BitFieldReader.Parse(pStrUnused, &UnusedIndex);
        pStrUnused += UnusedIndex;

        if (BitFieldReader.Complete() != S_OK)
        {
            break;
        }

        if (!BitField->Valid)
        {
            BitField->Valid = BitField->Compose(BitPos.I32, Bits.I32);
        }
        else
        {
            // Full extent of bit fields seen so far
            BitField->Bits = Bits.I32 + BitPos.I32 - BitField->BitPos;

            // Full mask of bit fields seen so far
            if (Field.Compose(BitPos.I32, Bits.I32))
            {
                BitField->Mask |= Field.Mask;
            }
        }

        // See if there is anything else we might want to parse.
        pStrRemaining = pStrUnused;
        while (isspace(*pStrRemaining) || *pStrRemaining == '\n')
        {
            pStrRemaining++;
        }
    } while (pStrRemaining != '\0');

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return S_OK;
}



//----------------------------------------------------------------------------
//
// OutputFilter
//
// DebugOutputCallback class to filter output
// by skipping/replacing lines.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OutputFilter::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    return (Outputing) ?
        S_OK :
        OutputReader::Output(Mask, Text);
}


HRESULT
OutputFilter::Query(
    PCSTR Query,
    PDEBUG_VALUE Value,
    ULONG Type,
    ULONG Radix
    )
{
    if (Query == NULL) return E_INVALIDARG;

    if (Buffer == NULL) return S_FALSE;

    HRESULT hr;
    BasicOutputParser   Parser(Client, 1);

    if ((hr = Parser.LookFor(Value, Query, Type, Radix)) == S_OK &&
        (hr = Parser.Parse(Buffer, NULL)) == S_OK)
    {
        hr = Parser.Complete();
    }

    return hr;
}


OutputFilter::QuerySpec::QuerySpec(
    ULONG QueryFlags,
    PCSTR QueryText
    )
{
    Next = NULL;
    Flags = QueryFlags;
    QueryLen = (QueryText== NULL) ? 0 : strlen(QueryText);
    if (QueryLen)
    {
        Query = new CHAR[QueryLen+1];
        if (Query == NULL)
        {
            QueryLen = 0;
        }
        else
        {
            strcpy(Query, QueryText);
        }
    }
    else
    {
        Query = NULL;
    }
}


OutputFilter::ReplacementSpec::ReplacementSpec(
    ULONG QueryFlags,
    PCSTR QueryText,
    PCSTR ReplacementText
    ) : QuerySpec(QueryFlags, QueryText)
{
    ReplacementLen = (ReplacementText== NULL) ? 0 : strlen(ReplacementText);
    if (ReplacementLen)
    {
        Replacement = new CHAR[ReplacementLen+1];
        if (Replacement == NULL)
        {
            ReplacementLen = 0;
        }
        else
        {
            strcpy(Replacement, ReplacementText);
        }
    }
    else
    {
        Replacement = NULL;
    }
}


OutputFilter::QuerySpec **
OutputFilter::FindPrior(
    ULONG Flags,
    PCSTR Query,
    QuerySpec **List
    )
{
    QuerySpec **Prior = List;
    QuerySpec  *Next;

    for (Next = *Prior; Next != NULL; Next = Next->Next)
    {
        if (Flags > Next->Flags ||
            (Flags == Next->Flags &&
             strcmp(Query, Next->Query) >= 0))
        {
            break;
        }

        Prior = &Next->Next;
    }

    return Prior;
}


HRESULT
OutputFilter::Replace(
    ULONG Flags,
    PCSTR Query,
    PCSTR Replacement
    )
{
    if (Query == NULL ||
        (Flags & OUTFILTER_REPLACE_LINE) == 0 ||
        (Flags & OUTFILTER_REPLACE_LINE) == (OUTFILTER_REPLACE_BEFORE | OUTFILTER_REPLACE_AFTER))
    {
        return E_INVALIDARG;
    }

    // Don't support replacing one query each time in a single line.
    // This is ok if there can be no further replacements on a matching line.
    if (((Flags & (OUTFILTER_REPLACE_ONCE | OUTFILTER_QUERY_ONE_LINE)) ==
          (OUTFILTER_REPLACE_EVERY | OUTFILTER_QUERY_ONE_LINE)) &&
        !(Flags & (OUTFILTER_REPLACE_AFTER | OUTFILTER_REPLACE_NEXT_LINE)))
    {
        return E_NOTIMPL;
    }

    // Set priority to level 0 if not specified.
    if ((Flags & OUTFILTER_REPLACE_PRIORITY(7)) == 0)
    {
        Flags |= OUTFILTER_REPLACE_PRIORITY(0);
    }

    ReplacementSpec   **PriorNext;
    ReplacementSpec    *Next;
    ULONG               ReplacementLen;

    ReplacementLen = (Replacement == NULL) ? 0 : strlen(Replacement);

    PriorNext = (ReplacementSpec **)FindPrior(Flags, Query, (QuerySpec**)&ReplaceList);
    Next = *PriorNext;

    if (Next != NULL &&
        Flags == Next->Flags &&
        strcmp(Query, Next->Query) == 0)
    {
        if (ReplacementLen == 0)
        {
            if (Next->Replacement != NULL)
            {
                Next->Replacement[0] = '\0';
            }
        }
        else
        {
            if (ReplacementLen > Next->ReplacementLen)
            {
                PSTR NewReplacement = new CHAR[ReplacementLen+1];

                if (NewReplacement == NULL) return E_OUTOFMEMORY;

                if (Next->Replacement != NULL)
                {
                    delete[] Next->Replacement;
                    Next->Replacement = NewReplacement;
                }
            }
            strcpy(Next->Replacement, Replacement);
        }
        Next->ReplacementLen = ReplacementLen;
    }
    else
    {
        ReplacementSpec    *NewQuery;

        NewQuery = new ReplacementSpec(Flags, Query, Replacement);

        if (NewQuery == NULL) return E_OUTOFMEMORY;

        if (NewQuery->Query == NULL ||
            (ReplacementLen && NewQuery->Replacement == NULL))
        {
            delete NewQuery;
            return E_OUTOFMEMORY;
        }

        NewQuery->Next = Next;
        *PriorNext = NewQuery;
    }

    return S_OK;
}

HRESULT
OutputFilter::Skip(
    ULONG Flags,
    PCSTR Query
    )
{
    if (Query == NULL)
    {
        return E_INVALIDARG;
    }

    QuerySpec **PriorNext;
    QuerySpec  *Next;

    PriorNext = FindPrior(Flags, Query, &SkipList);
    Next = *PriorNext;

    if (Next == NULL ||
        Flags != Next->Flags ||
        strcmp(Query, Next->Query) != 0)
    {
        QuerySpec  *NewQuery;

        NewQuery = new QuerySpec(Flags, Query);

        if (NewQuery == NULL) return E_OUTOFMEMORY;

        if (NewQuery->Query == NULL)
        {
            delete NewQuery;
            return E_OUTOFMEMORY;
        }

        NewQuery->Next = Next;
        *PriorNext = NewQuery;
    }

    return S_OK;
}

OutputFilter::QuerySpec *
OutputFilter::FindMatch(
    PCSTR Text,
    QuerySpec *List,
    ULONG Start,
    ULONG Flags,
    PULONG MatchPos
    )
{
    ULONG       Remaining = strlen(Text);
    PCSTR       Search;
    QuerySpec  *Match;

    if (MatchPos != NULL) *MatchPos = 0;

    if (List == NULL ||
        Text == NULL ||
        (Remaining = strlen(Text)) <= Start) return NULL;

    Search = Text + Start;
    Remaining -= Start;

    do
    {
        for (Match = List; Match != NULL; Match = Match->Next)
        {
            if (Match->Flags & OUTFILTER_QUERY_ENABLED &&
                Remaining >= Match->QueryLen &&
                strncmp(Search, Match->Query, Match->QueryLen) == 0)
            {
                if (Match->Flags & OUTFILTER_QUERY_WHOLE_WORD)
                {
                    if ((Search > Text && iscsym(Search[-1])) ||
                        iscsym(Search[Match->QueryLen]))
                    {
                        continue;
                    }
                }
/*
                if (Match->Flags & OUTFILTER_QUERY_ONE_LINE)
                {
                    Match->Flags &= ~OUTFILTER_QUERY_ENABLED;
                }
*/
                Match->Flags |= OUTFILTER_QUERY_HIT;

                if (MatchPos != NULL)
                {
                    *MatchPos = (ULONG)(Search - Text);
                }

                return Match;
            }
        }

        Search++;
        Remaining--;
    } while (Remaining &&
             !(Flags & OUTFILTER_FINDMATCH_AT_START));

    return NULL;
}


HRESULT
OutputFilter::OutputText(
    OutputControl *OutCtl,
    ULONG Mask
    )
{
    // 1. Get line of read buffer
    // 2. Search for a skip query match
    // 3. Search for any/all replace query matches

    if (Buffer == NULL) return S_OK;

    HRESULT         hr;
    PSTR            pNextLine;
    CHAR            EndChar;
    PSTR            pFilter;

    if (OutCtl == NULL)
    {
        OutCtl = new OutputControl(Client);

        if (OutCtl == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        OutCtl->AddRef();
    }

    // Can we quickly just output all text?
    if (SkipList == NULL && ReplaceList == NULL)
    {
        hr = OutCtl->Output(Mask, Buffer);
        OutCtl->Release();
        return hr;
    }

    Outputing = TRUE;

    // Enable all queries and reset hit markings.
    QuerySpec *Query;
    for (Query = SkipList; Query != NULL; Query = Query->Next)
    {
        Query->Flags = (Query->Flags & ~OUTFILTER_QUERY_HIT) | OUTFILTER_QUERY_ENABLED;
    }
    for (Query = (QuerySpec *)ReplaceList; Query != NULL; Query = Query->Next)
    {
        Query->Flags = (Query->Flags & ~OUTFILTER_QUERY_HIT) | OUTFILTER_QUERY_ENABLED;
    }

    hr = S_OK;
    pNextLine = Buffer;

    while (hr == S_OK && *pNextLine != '\0')
    {
        if (OutCtl->GetInterrupt() == S_OK)
        {
            OutCtl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            break;
        }

        pFilter = pNextLine;

        // Find end of this line
        while ((*pNextLine != '\0') &&
               (*pNextLine != '\n') &&
               (*pNextLine != '\r') &&
               (*pNextLine != '\f'))
        {
            pNextLine++;
        }

        EndChar = *pNextLine;
        *pNextLine = '\0';

        // Search for a skip match
        Query = FindMatch(pFilter, SkipList);

        if (Query != NULL)
        {
            DbgPrint("Skipping line with %s.\n", Query->Query);

            if (Query->Flags & OUTFILTER_QUERY_ONE_LINE)
            {
                Query->Flags &= ~OUTFILTER_QUERY_ENABLED;
            }

            *pNextLine = EndChar;
            if (EndChar != '\0')
            {
                pNextLine++;
            }
        }
        else
        {
            PSTR                pFilterLine = pFilter;
            ULONG               MatchPos = 0;
            ReplacementSpec    *Replace;

            for (Replace = ReplaceList;
                 Replace != NULL;
                 Replace = (ReplacementSpec *)Replace->Next)
            {
                if (!(Replace->Flags & (OUTFILTER_QUERY_ONE_LINE | OUTFILTER_QUERY_ENABLED)))
                {
                    Replace->Flags |= OUTFILTER_QUERY_ENABLED;
                }
            }

            while (pFilter < pNextLine &&
                   (Replace = (ReplacementSpec *)FindMatch(pFilterLine,
                                                           ReplaceList,
                                                           MatchPos,
                                                           OUTFILTER_FINDMATCH_DEFAULT,
                                                           &MatchPos)) != NULL)
            {
                if (Replace->Flags & (OUTFILTER_QUERY_ONE_LINE | OUTFILTER_REPLACE_ONCE))
                {
                    Replace->Flags &= ~OUTFILTER_QUERY_ENABLED;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_BEFORE)
                {
                    if (Replace->ReplacementLen)
                    {
                        hr = OutCtl->Output(Mask, "%s", Replace->Replacement);
                    }

                    pFilter = pFilterLine + MatchPos;

                    if (!(Replace->Flags & OUTFILTER_REPLACE_NEXT_LINE) &&
                        !(Replace->Flags & OUTFILTER_REPLACE_ONCE) &&
                        !(Replace->Flags & OUTFILTER_REPLACE_TO_END))
                    {
                        // This replacement leaves the query text intact.
                        // Hence this query will keep matching; so, look for
                        // another query which will actually modify the
                        // query text or the text following it.
                        Replace = (ReplacementSpec *)Replace->Next;

                        while (Replace != NULL &&
                               Replace->Flags & OUTFILTER_REPLACE_BEFORE)
                        {
                            Replace = (ReplacementSpec *)Replace->Next;
                        }

                        Replace = (ReplacementSpec *)
                                    FindMatch(pFilterLine,
                                              Replace,
                                              MatchPos,
                                              OUTFILTER_FINDMATCH_AT_START |
                                              OUTFILTER_FINDMATCH_NO_MARK);

                        if (Replace == NULL)
                        {
                            // Advance MatchPos, but not filtered text.
                            // This unfiltered text may yet be replaced.
                            MatchPos++;
                            continue;
                        }
                    }
                }

                if (!(Replace->Flags & OUTFILTER_REPLACE_BEFORE))
                {
                    CHAR    TempHolder;
                    ULONG   BeginReplacePos = MatchPos;

                    if (!(Replace->Flags & OUTFILTER_REPLACE_THIS))
                    {
                        BeginReplacePos += Replace->QueryLen;
                    }

                    TempHolder = pFilterLine[BeginReplacePos];
                    pFilterLine[BeginReplacePos] = '\0';

                    if ((hr = OutCtl->Output(Mask, "%s", pFilter)) == S_OK &&
                        Replace->ReplacementLen)
                    {
                        hr = OutCtl->Output(Mask, "%s", Replace->Replacement);
                    }

                    pFilterLine[BeginReplacePos] = TempHolder;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_AFTER)
                {
                    pFilter = pNextLine;
                }
                else
                {
                    if (Replace->Flags & OUTFILTER_REPLACE_THIS)
                    {
                        MatchPos += Replace->QueryLen;
                    }
                    pFilter = pFilterLine + MatchPos;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_NEXT_LINE) break;
            }

            *pNextLine = EndChar;
            if (EndChar != '\0')
            {
                pNextLine++;

                // Include any following zero length lines
                while ((*pNextLine == '\n') ||
                       (*pNextLine == '\r') ||
                       (*pNextLine == '\f'))
                {
                    pNextLine++;
                }

                EndChar = *pNextLine;
                *pNextLine = '\0';
            }

            // Output remaining portion of filtered line
            hr = OutCtl->Output(Mask, pFilter);

            if (EndChar != '\0')
            {
                *pNextLine = EndChar;
            }
        }

    }

    Outputing = FALSE;

    OutCtl->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\trace.cxx ===
/******************************Module*Header*******************************\
* Module Name: trace.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

DECLARE_API( trace )
{
    OutputControl   OutCtl(Client);

    OutCtl.Output("trace is not fully supported yet.\n");

    HRESULT         hr = E_INVALIDARG;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         Module;
    ULONG           TypeId;

    // Interpret command line

    while (isspace(*args)) args++;

    if (*args != '\0')
    {
        OutCtl.Output("trace [-cdels] [Name]\n");
        return S_OK;
    }

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( trace );

    if (GDIKM_Module.Base == 0)
    {
        OutCtl.OutErr("Error: win32k.sys module isn't available.\n");
    }
    Module = GDIKM_Module.Base;

    if (Module != 0)
    {
        // Make sure tracing is enabled in GDI
        hr = Symbols->GetTypeId(Module, "GDITraceEntryType", &TypeId);

        if (hr != S_OK)
        {
            OutCtl.OutErr("Error: GDI Tracing is not enabled.\n"
                    "       Rebuild " GDIModule() " with DBG_TRACE enabled.\n");
        }
        else
        {
            OutCtl.OutWarn("no implementation yet.\n");

            CHAR    TypeName[200];
            ULONG   NameSize;

            for (TypeId = 0;
                 Symbols->GetTypeName(Module, TypeId, NULL, 0, NULL) == E_FAIL;
                 TypeId++)
            {
                if (TypeId > 255) break;
            }

            for (;//TypeId = 0;
                 (hr = Symbols->GetTypeName(Module, TypeId,
                                            TypeName, sizeof(TypeName),
                                            &NameSize)) != E_FAIL;
                 TypeId++)
            {
                if ((NameSize > 11 && strncmp(TypeName, "enum_GDITE_", 11) == 0) ||
                    (NameSize > 6 && strncmp(TypeName, "GDITE_", 6) == 0))
                {
                    OutCtl.Output(" %lx ", TypeId);
                    hr = Symbols->OutputTypedDataVirtual(DEBUG_OUTCTL_AMBIENT,
                                                         0, Module, TypeId,
                                                         DEBUG_OUTTYPE_COMPACT_OUTPUT);
                    if (hr != S_OK)
                    {
                        OutCtl.Output("%s = Unknown Value (HRESULT %s)\n", TypeName, pszHRESULT(hr));
                    }
                }
            }

            OutCtl.Output("GetTypeName(,%lx,) returned %s.\n", TypeId, pszHRESULT(hr));
        }
    }

    Symbols->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\path.cxx ===
/******************************Module*Header*******************************\
* Module Name: path.cxx
*
* PATHOBJ gdikdx extension code.
*  
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include  "precomp.hxx"

// PATH
#define GetPATHField(field) \
        GetPATHSubField(#field,field)
#define GetPATHSubField(field,local) \
        GetFieldData(offPATH, "PATH", field, sizeof(local), &local)
// PATHRECORD
#define GetPATHRECORDField(field) \
        GetPATHRECORDSubField(#field,field)
#define GetPATHRECORDSubField(field,local) \
        GetFieldData(offPATHRECORD, "PATHRECORD", field, sizeof(local), &local)



/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPrintPOINTFIX
*
* Routine Description:
*
*   prints a POINTFIX
*
* Arguments:
*
*   pointer to a POINTFIX
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
vPrintPOINTFIX(ULONG64 pPOINTFIX)
{
    FIX x;
    FIX y;
    ULONG error;

    FIELD_INFO vFields[] = 
    {
        { DbgStr("x"),	NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("y"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL}
    };

    SYM_DUMP_PARAM vSym =
    {
       sizeof (SYM_DUMP_PARAM),
       DbgStr(GDIType(POINTFIX)),
       DBG_DUMP_NO_PRINT,
       0/*address*/,
       NULL, NULL, NULL,
       sizeof(vFields)/sizeof(vFields[0]),
       vFields
    };

    vSym.addr = pPOINTFIX;

    error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
    if(error)
    {
        dprintf("Unable to get contents of POINTFIX\n");
        dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
        return;
    }
    x = (FIX) vFields[0].address;
    y = (FIX) vFields[1].address;

    dprintf(
        "(%-#10x, %-#10x) = (%d+(%d/16), %d+(%d/16))"
        , x, y, x/16, x&15, y/16, y&15
    );
}

ULONG
pointFixCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if(pField)
    {
        vPrintPOINTFIX(pField->address);
        dprintf("\n");
    }

    return STATUS_SUCCESS;
}


/******************************Public*Routine******************************\
* vPrintPATHRECORD
*
* History:
*  Mon 20-Jun-1994 15:33:37 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

void
vPrintPATHRECORD(ULONG64 offPATHRECORD)
{
    FLONG flags, fl;
    ULONG count;
    ULONG64 pprnext, pprprev;
    ULONG offaptfx;
    ULONG error;

    if(offPATHRECORD)
    {
        FIELD_INFO vFields[] = 
        {
            { DbgStr("pprnext"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("pprprev"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("flags"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("count"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL}
        };

        SYM_DUMP_PARAM vSym =
        {
           sizeof (SYM_DUMP_PARAM),
           DbgStr(GDIType(PATHRECORD)),
           DBG_DUMP_NO_PRINT,
           0/*address*/,
           NULL, NULL, NULL,
           sizeof(vFields)/sizeof(vFields[0]),
           vFields
        };

        vSym.addr = offPATHRECORD;

        error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
        if(error)
        {
            dprintf("Unable to get contents of PATHRECORD\n");
            dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
            return;
        }

        pprnext = vFields[0].address; 
        pprprev = vFields[1].address;
        dprintf("\tpprnext           = %-#p\n", pprnext);
        dprintf("\tpprprev           = %-#p\n", pprprev);
        flags = (FLONG)vFields[2].address;
        fl = flags;
        dprintf("\tflags             = %-#x\n", fl);

        for(FLAGDEF *pfd=afdPD; pfd->psz; pfd++)
        {
            if(fl & pfd->fl)
                dprintf("\t\t\t      %s\n", pfd->psz);
        }
        count = (ULONG)vFields[3].address;
        dprintf("\tcount    = %u\n", count);

        // Get the offset of aptfx in PATHRECORD.
        GetFieldOffset("PATHRECORD","aptfx",&offaptfx);
        if(count)
        {
    	    FIELD_INFO vField = { NULL, NULL, count, 0, 0, pointFixCallback};

    	    SYM_DUMP_PARAM vSym =
            {
       	        sizeof(SYM_DUMP_PARAM),
                DbgStr(GDIType(POINTFIX)),
                DBG_DUMP_ARRAY | DBG_DUMP_NO_PRINT,
                offPATHRECORD+offaptfx,
                &vField, NULL, NULL, 0, NULL
            };

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
            if(error)
            {
                  dprintf("Unable to dump contents of aptfx\n");
                  dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
                  return;
            }
        }
        dprintf("\n");
    }
}

/******************************Public*Routine******************************\
* vPrintPATHList
*
* History:
*  Sat 20-May-2000 18:25:21 by Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

void vPrintPATHList(ULONG64 offPATH)
{
    ULONG64 pprfirst;
    ULONG64 pprnext;
    ULONG64 ppr_CD;
    ULONG64 ppr;
    ULONG64 offPATHRECORD;
    ULONG count;

    GetPATHField(pprfirst);

    ppr = ppr_CD = offPATHRECORD = pprfirst;

    while(ppr)
    {
        GetPATHRECORDField(pprnext);

        //simple multi-rate cycle detection.
        if(ppr_CD)
        {
            GetFieldData(ppr_CD,
                         "PATHRECORD",
                         "pprnext",
                         sizeof(ppr_CD),
                         &ppr_CD);
            if(ppr_CD)
            {
                GetFieldData(ppr_CD,
                             "PATHRECORD",
                             "pprnext",
                             sizeof(ppr_CD),
                             &ppr_CD);
            }
        }
        if(ppr==ppr_CD)
        {
            dprintf("ERROR: Cycle detected in linked list.\n");
            break;
        }
        if(CheckControlC())
        {
            break;
        }

        vPrintPATHRECORD(offPATHRECORD);

        ppr = offPATHRECORD = pprnext;
    }
}


HRESULT
OutputPATH(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Offset,
    BOOL DumpRecords
    )
{
    HRESULT         hr = S_OK;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   FilterOutCtl(Client);

    if ((hr = GetTypeId(Client, "PATH", &TypeId, &Module)) == S_OK)
    {
        OutputFilter        OutFilter(Client);
        OutputState         OutState(Client);

        if (!DumpRecords ||
            ((hr = OutState.Setup(0, &OutFilter)) == S_OK &&
             (hr = FilterOutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                           DEBUG_OUTCTL_NOT_LOGGED |
                                           DEBUG_OUTCTL_OVERRIDE_MASK,
                                           OutState.Client)) == S_OK))
        {
            TypeOutputDumper    TypeReader(Client,
                                           (DumpRecords ? &FilterOutCtl : OutCtl));

            OutCtl->Output(" PATH @ 0x%p:\n", Offset);

            TypeReader.ExcludeMarked();
            TypeReader.MarkField("cle.*");

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset);

            if (hr != S_OK)
            {
                OutCtl->OutErr("Type Dump for PATH returned %s.\n", pszHRESULT(hr));
            }
            else if (DumpRecords)
            {
                DEBUG_VALUE RecOffset;

                OutFilter.OutputText(OutCtl, DEBUG_OUTPUT_NORMAL);

                if ((hr = OutFilter.Query("pprfirst", &RecOffset, DEBUG_VALUE_INT64)) == S_OK)
                {
                    if (RecOffset.I64 != 0)
                    {
                        OutCtl->OutWarn("Path record dumping to be converted.\n");
                        vPrintPATHList(Offset);
                    }
                    else
                    {
                        OutCtl->OutErr(" No records to dump.\n");
                    }
                }
                else
                {
                    OutCtl->OutErr("Error evaluating 'pprfirst' member.\n");
                }
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* EPATHOBJ
*
\**************************************************************************/

DECLARE_API( epathobj )
{
    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpPath = FALSE;
    BOOL            DumpRecords = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'r': DumpRecords = TRUE; // Make sure DumpPath is set too
                case 'p': DumpPath = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: epathobj [-?pr] <EPATHOBJ Addr>\n"
                      "        -p  - dump path\n"
                      "        -r  - dump path records\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "EPATHOBJ", &TypeId, &Module)) == S_OK)
        {
            OutputFilter        OutFilter(Client);
            OutputState         OutState(Client);

            OutCtl.Output(" EPATHOBJ @ 0x%p:\n", Offset.I64);

            if (!DumpPath ||
                ((hr = OutState.Setup(0, &OutFilter)) == S_OK &&
                 (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                         DEBUG_OUTCTL_NOT_LOGGED |
                                         DEBUG_OUTCTL_OVERRIDE_MASK,
                                         OutState.Client)) == S_OK))
            {
                TypeOutputDumper    TypeReader(Client, &OutCtl);

                hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);

                if (DumpPath)
                {
                    OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
                }

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump for EPATHOBJ returned %s.\n", pszHRESULT(hr));
                }
                else if (DumpPath)
                {
                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    if ((hr = OutFilter.Query("ppath", &Offset, DEBUG_VALUE_INT64)) == S_OK)
                    {
                        if (Offset.I64 != 0)
                        {
                            hr = OutputPATH(Client, &OutCtl, Offset.I64, DumpRecords);
                        }
                        else
                        {
                            OutCtl.OutErr(" No path to dump.\n");
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("Error evaluating 'ppath' member.\n");
                    }
                }
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* PATH
*
\**************************************************************************/

DECLARE_API( path )
{
    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpRecords = FALSE;
    ULONG64         PathAddr;
    DEBUG_VALUE     Arg;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'r': DumpRecords = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: path [-?r] <HPATH | PATH Addr>\n"
                      "        -r  - dump records\n");
    }
    else
    {
        hr = GetObjectAddress(Client, Arg.I64, &PathAddr, PATH_TYPE, TRUE, TRUE);

        if (hr != S_OK || PathAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             PathAddrFromHmgr;

            PathAddr = Arg.I64;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(PathAddr, "PATH", 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of PATH::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HPATH nor valid PATH address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &PathAddrFromHmgr,
                                     PATH_TYPE, TRUE, FALSE) == S_OK &&
                    PathAddrFromHmgr != PathAddr)
                {
                    OutCtl.OutWarn("\tNote: PATH may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = OutputPATH(Client, &OutCtl, PathAddr, DumpRecords);
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( dpo  )
*
* dpo -- "dump PATHOBJ"
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dpo )
{
    OutputControl   OutCtl(Client);
    OutCtl.OutWarn("dpo is obsolete. Please use epathobj.\n");
    return epathobj(Client, args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\process.cxx ===
/******************************Module*Header*******************************\
* Module Name: process.cxx
*
*   Support for dteb and dpeb APIs
*
* Created: 12-Mar-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-2000 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


HRESULT
GetProcessField(
    IN PDEBUG_CLIENT Client,
    IN OUT PULONG64 pProcessAddress,
    IN PCSTR FieldPath,
    OUT PDEBUG_VALUE FieldValue,
    IN ULONG DesiredType
    )
{
    HRESULT                 hr;
    OutputControl           OutCtl(Client);
    PDEBUG_SYSTEM_OBJECTS   System;
    PDEBUG_SYMBOLS          Symbols;

    ULONG64 ProcessAddress = (pProcessAddress != NULL) ? *pProcessAddress : CURRENT_PROCESS_ADDRESS;

    if (Client == NULL || FieldPath == NULL) return E_INVALIDARG;

    PCSTR Field = FieldPath;
    PCSTR Dot;

    // Check FieldPath's basic validity
    if (!iscsymf(*Field)) return E_INVALIDARG;

    while ((Dot = strchr(Field, '.')) != NULL)
    {
        Field = Dot + 1;
        if (!iscsymf(*Field)) return E_INVALIDARG;
    }

    // Query interfaces needed
    if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&System)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        System->Release();
        return hr;
    }

    if (ProcessAddress == CURRENT_PROCESS_ADDRESS)
    {
        hr = System->GetCurrentProcessDataOffset(&ProcessAddress);

        if (hr == S_OK)
        {
            if (ProcessAddress != NULL) *pProcessAddress = ProcessAddress;
        }
        else
        {
            OutCtl.OutErr("GetCurrentProcess returned %s.\n", pszHRESULT(hr));
        }
    }

    if (hr == S_OK)
    {
        TypeOutputParser    TypeParser(Client);
        OutputState         OutState(Client, FALSE);
        OutputControl       OutCtlToParser;
        ULONG               ProcessTypeId;
        ULONG64             NTModule;
        DEBUG_VALUE         ProcessObject;
        DEBUG_VALUE         ObjectType;

        if ((hr = OutState.Setup(0, &TypeParser)) == S_OK &&
            (hr = OutCtlToParser.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
            (hr = Symbols->GetSymbolTypeId("nt!_EPROCESS", &ProcessTypeId, &NTModule)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToParser);

            if ((hr = OutState.OutputTypeVirtual(0, "nt!KOBJECTS", 0)) == S_OK)
            {
                hr = TypeParser.Get(&ProcessObject, "ProcessObject", DEBUG_VALUE_INT64);
            }

            if (hr != S_OK)
            {
                OutCtl.OutWarn("enum nt!KOBJECTS's ProcessObject value wasn't found.\n");
                ProcessObject.I64 = 3;   // From ke.h
            }

            TypeParser.DiscardOutput();

            TypeReader.IncludeMarked();
            TypeReader.MarkField("Pcb.Header.Type");
            TypeReader.MarkField(FieldPath);

            if ((hr = TypeReader.OutputVirtual(NTModule, ProcessTypeId, ProcessAddress)) == S_OK)
            {
                // Make sure this object is a process
                if ((hr = TypeParser.Get(&ObjectType, "Type", DEBUG_VALUE_INT64)) == S_OK &&
                    ObjectType.I64 == ProcessObject.I64)
                {
                    OutCtl.OutVerb("  Process Addr = 0x%p\n", ProcessAddress);

                    hr = TypeParser.Get(FieldValue, Field, DesiredType);
                }
                else
                {
                    if (hr == S_OK)
                    {
                        OutCtl.OutErr("0x%p is not a process object.\n", ProcessAddress);
                        hr = S_FALSE;
                    }
                    else
                    {
                        OutCtl.OutErr("Unable to find 'Type' value from nt!_EPROCESS Pcb.Header.\n");
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Unable to get process contents at 0x%p.\n", ProcessAddress);
            }
        }
        else
        {
            OutCtl.OutErr("Unable to prepare nt!_EPROCESS type read.\n");
        }
    }

    Symbols->Release();
    System->Release();

    return hr;
}


HRESULT
GetThreadField(
    IN PDEBUG_CLIENT Client,
    IN OUT PULONG64 pThreadAddress,
    IN PCSTR FieldPath,
    OUT PDEBUG_VALUE FieldValue,
    IN ULONG DesiredType
    )
{
    HRESULT                 hr;
    OutputControl           OutCtl(Client);
    PDEBUG_SYSTEM_OBJECTS   System;
    PDEBUG_SYMBOLS          Symbols;

    ULONG64 ThreadAddress = (pThreadAddress != NULL) ? *pThreadAddress : CURRENT_THREAD_ADDRESS;

    if (Client == NULL || FieldPath == NULL) return E_INVALIDARG;

    PCSTR Field = FieldPath;
    PCSTR Dot;

    // Check FieldPath's basic validity
    if (!iscsymf(*Field)) return E_INVALIDARG;

    while ((Dot = strchr(Field, '.')) != NULL)
    {
        Field = Dot + 1;
        if (!iscsymf(*Field)) return E_INVALIDARG;
    }

    // Query interfaces needed
    if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&System)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        System->Release();
        return hr;
    }

    if (ThreadAddress == CURRENT_THREAD_ADDRESS)
    {
        hr = System->GetCurrentThreadDataOffset(&ThreadAddress);

        if (hr == S_OK && ThreadAddress != NULL)
            *pThreadAddress = ThreadAddress;
    }

    if (hr == S_OK)
    {
        TypeOutputParser    TypeParser(Client);
        OutputState         OutState(Client, FALSE);
        OutputControl       OutCtlToParser;
        ULONG               ThreadTypeId;
        ULONG64             NTModule;
        DEBUG_VALUE         ThreadObject;
        DEBUG_VALUE         ObjectType;

        if ((hr = OutState.Setup(0, &TypeParser)) == S_OK &&
            (hr = OutCtlToParser.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
            (hr = Symbols->GetSymbolTypeId("nt!_ETHREAD", &ThreadTypeId, &NTModule)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToParser);

            if ((hr = OutState.OutputTypeVirtual(0, "nt!KOBJECTS", 0)) == S_OK)
            {
                hr = TypeParser.Get(&ThreadObject, "ThreadObject", DEBUG_VALUE_INT64);
            }

            if (hr != S_OK)
            {
                OutCtl.OutWarn("enum nt!KOBJECTS's ThreadObject value wasn't found.\n");
                ThreadObject.I64 = 6;   // From ke.h
            }

            TypeParser.DiscardOutput();

            TypeReader.IncludeMarked();
            TypeReader.MarkField("Tcb.Header.Type");
            TypeReader.MarkField(FieldPath);

            if ((hr = TypeReader.OutputVirtual(NTModule, ThreadTypeId, ThreadAddress)) == S_OK)
            {
                // Make sure this object is a thread
                if ((hr = TypeParser.Get(&ObjectType, "Type", DEBUG_VALUE_INT64)) == S_OK &&
                    ObjectType.I64 == ThreadObject.I64)
                {
                    OutCtl.OutVerb("  Thread Addr = 0x%p\n", ThreadAddress);

                    hr = TypeParser.Get(FieldValue, Field, DesiredType);
                }
                else
                {
                    if (hr == S_OK)
                    {
                        OutCtl.OutErr("0x%p is not a thread object.\n", ThreadAddress);
                        hr = S_FALSE;
                    }
                    else
                    {
                        OutCtl.OutErr("Unable to find 'Type' value from nt!_ETHREAD Tcb.Header.\n");
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Unable to get thread contents at 0x%p.\n", ThreadAddress);
            }
        }
        else
        {
            OutCtl.OutErr("Unable to prepare nt!_ETHREAD type read.\n");
        }
    }

    Symbols->Release();
    System->Release();

    return hr;
}


HRESULT
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    HRESULT                 hr = E_INVALIDARG;
    PDEBUG_SYSTEM_OBJECTS   DebugSystem;
    ULONG64                 hCurrentThread;

    if (phCurrentThread != NULL) *phCurrentThread = NULL;
    if (pProcessor != NULL) *pProcessor = 0;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&DebugSystem)) != S_OK)
    {
        return hr;
    }

    hr = DebugSystem->GetCurrentThreadHandle(&hCurrentThread);

    if (hr == S_OK)
    {
        if (phCurrentThread != NULL)
        { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }

        if (pProcessor != NULL)
        {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }
    }

    DebugSystem->Release();

    return hr;
}


/******************************Public*Routine******************************\
*   DumpTebBatch
*
*   Dumps GDI TEB batch info
*
* Arguments:
*
*   TebAddress - address of Teb
*
* Return Value:
*
*   None
*
* History:
*
*    20-Sep-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

// from hmgshare.h
enum _BATCH_TYPE
{
    BatchTypePatBlt,
    BatchTypePolyPatBlt,
    BatchTypeTextOut,
    BatchTypeTextOutRect,
    BatchTypeSetBrushOrg,
    BatchTypeSelectClip,
    BatchTypeSelectFont,
    BatchTypeDeleteBrush,
    BatchTypeDeleteRegion
};

VOID
DumpTebBatch(
    PDEBUG_CLIENT Client,
    ULONG64 TebAddress
    )
{
    FIELD_INFO TebBatchFields[] = {
        { DbgStr("GdiBatchCount"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.Offset"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.HDC"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.Buffer"), NULL,  0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
    };
    SYM_DUMP_PARAM TebBatchSym = {
       sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(_TEB)), 
       0,
       TebAddress,
       NULL, NULL, NULL,
       sizeof(TebBatchFields)/sizeof(TebBatchFields[0]), TebBatchFields
    };
    ULONG   BatchCount;
    BOOL    OldBatch = FALSE;
    ULONG64 BatchEntryAddress;
    ULONG64 BatchBufferLength = 0;
    ULONG64 BatchBufferEnd;
    ULONG   SmallestBatchEntrySize = max(1, GetTypeSize(GDIType(BATCHCOMMAND)));
    USHORT  BatchEntryLength;
    USHORT  BatchEntryType;
    ULONG   error;
    PrepareCallbacks(FALSE, 0);

    ExtOut("GDI Batch Info from Teb %p:\n", TebAddress);

    error = Ioctl(IG_DUMP_SYMBOL_INFO, &TebBatchSym, TebBatchSym.size);

    if (error)
    {
        ExtErr("Ioctl returned %s\n", pszWinDbgError(error));
    }
    else
    {
        BatchCount = (ULONG)TebBatchFields[0].address;
        BatchEntryAddress = TebBatchFields[3].address;

        if (BatchCount == 0)
        {
            ExtOut(" ** Dumping old batch entries **\n");
            OldBatch = TRUE;
        }

        ExtOut("First batch entry @ %p.\n", BatchEntryAddress);

        GetArrayDimensions(Client, "_GDI_TEB_BATCH", "Buffer", NULL, (ULONG *)&BatchBufferLength, NULL);

        if (TebBatchFields[1].address && TebBatchFields[1].address < BatchBufferLength)
        {
            BatchBufferLength = TebBatchFields[1].address;
        }

        BatchBufferEnd = BatchEntryAddress + BatchBufferLength;

        while ((OldBatch || BatchCount > 0) && BatchEntryAddress < BatchBufferEnd)
        {
            error = (ULONG)InitTypeRead(BatchEntryAddress, win32k!BATCHCOMMAND);

            if (error)
            {
                ExtErr("InitTypeRead(%p, %s) returned %s.\n", BatchEntryAddress, GDIType(BATCHCOMMAND), pszWinDbgError(error));
                break;
            }

            BatchEntryLength = (USHORT)ReadField(Length);

            if (BatchEntryAddress + BatchEntryLength > BatchBufferEnd)
            {
                ExtOut("Invalid batch entry - length is too long.\n");
                break;
            }

            if (BatchEntryLength < SmallestBatchEntrySize)
            {
                ExtOut("Invalid batch entry - length is too small.\n");
                break;
            }

            BatchEntryType = (USHORT)ReadField(Type);

            switch (BatchEntryType)
            {
                case BatchTypePatBlt:
                    {
                        ExtOut("  BatchTypePatBlt\n");
                    }
                    break;

                case BatchTypePolyPatBlt:
                    {
                        ExtOut("  BatchTypePolyPatBlt\n");
                    }
                    break;

                case BatchTypeTextOut:
                    {
                        ExtOut("  BatchTypeTextOut\n");
                    }
                    break;

                case BatchTypeTextOutRect:
                    {
                        ExtOut("  BatchTypeTextOutRect\n");
                    }
                    break;

                case BatchTypeSetBrushOrg:
                    {
                        ExtOut("  BatchTypeSetBrushOrg\n");
                    }
                    break;

                case BatchTypeSelectClip:
                    {
                        ExtOut("  BatchTypeSelectClip\n");
                    }
                    break;

                case BatchTypeSelectFont:
                    {
                        ExtOut("  BatchTypeSelectFont\n");
                    }
                    break;

                case BatchTypeDeleteBrush:
                    {
                        ExtOut("  BatchTypeDeleteBrush\n");
                    }
                    break;

                case BatchTypeDeleteRegion:
                    {
                        ExtOut("  BatchTypeDeleteRegion\n");
                    }
                    break;

                default:
                    ExtOut("  BatchType %hu is not recognized.\n", BatchEntryType);
            }

            BatchCount--;
            BatchEntryAddress += (ULONG64)BatchEntryLength;
        }

        if (!OldBatch && BatchCount)
        {
            ExtOut("Batch may be invalid %lu entries unchecked.\n", BatchCount);
        }
    }
#if 0
    if (istatus)
    {
        dprintf ("\nGDI Batch count = %li\n",pteb->GdiBatchCount);

        if (pteb->GdiBatchCount > 0)
        {
            ULONG index;
            PBATCHCOMMAND pBatch = (PBATCHCOMMAND)&pteb->GdiTebBatch.Buffer[0];

            dprintf ("\nGDI Batch HDC   = 0x%lx\n",pteb->GdiTebBatch.HDC);
            dprintf ("\nGDI Batch offet = 0x%lx\n",pteb->GdiTebBatch.Offset);

            for (index=pteb->GdiBatchCount;index>0;index--)
            {

                dprintf("-----------------------------------------------------\n");
                switch (pBatch->Type)
                {
                case BatchTypePatBlt:
                    {
                        PBATCHPATBLT pPatblt = (PBATCHPATBLT)pBatch;

                        dprintf("Patblt: length  = 0x%lx\n",pPatblt->Length);
                        dprintf("Patblt: x       = 0x%lx\n",pPatblt->x);
                        dprintf("Patblt: y       = 0x%lx\n",pPatblt->y);
                        dprintf("Patblt: cx      = 0x%lx\n",pPatblt->cx);
                        dprintf("Patblt: cy      = 0x%lx\n",pPatblt->cy);
                        dprintf("Patblt: hbr     = 0x%lx\n",pPatblt->hbr);
                        dprintf("Patblt: rop4    = 0x%lx\n",pPatblt->rop4);
                        dprintf("Patblt: textclr = 0x%lx\n",pPatblt->TextColor);
                        dprintf("Patblt: backclr = 0x%lx\n",pPatblt->BackColor);
                    }
                    break;

                case BatchTypePolyPatBlt:
                    {
                        PBATCHPOLYPATBLT pPatblt = (PBATCHPOLYPATBLT)pBatch;
                        PPOLYPATBLT ppoly = (PPOLYPATBLT)(&pPatblt->ulBuffer[0]);
                        ULONG Count = pPatblt->Count;

                        dprintf("PolyPatblt: length  = 0x%lx\n",pPatblt->Length);
                        dprintf("Patblt: Count       = 0x%lx\n",pPatblt->Count);
                        dprintf("Patblt: Mode        = 0x%lx\n",pPatblt->Mode);
                        dprintf("Patblt: rop4        = 0x%lx\n",pPatblt->rop4);
                        dprintf("Patblt: textclr     = 0x%lx\n",pPatblt->TextColor);
                        dprintf("Patblt: backclr     = 0x%lx\n",pPatblt->BackColor);

                        while (Count--)
                        {
                            dprintf("\n");
                            dprintf("\t x               = 0x%lx\n",ppoly->x);
                            dprintf("\t y               = 0x%lx\n",ppoly->y);
                            dprintf("\t cx              = 0x%lx\n",ppoly->cx);
                            dprintf("\t cy              = 0x%lx\n",ppoly->cy);
                            dprintf("\t hbr             = 0x%lx\n",ppoly->BrClr.hbr);
                            ppoly++;
                        }
                    }
                    break;

                case BatchTypeTextOut:
                    {
                        PBATCHTEXTOUT pText = (PBATCHTEXTOUT)pBatch;
                        PWCHAR pwchar = (PWCHAR)(&pText->ulBuffer[0]);
                        PLONG  pdx    = (PLONG)(&pText->ulBuffer[pText->PdxOffset]);

                        dprintf("Textout: length      = 0x%lx\n",pText->Length);
                        dprintf("Textout: TextColor   = 0x%lx\n",pText->TextColor);
                        dprintf("Textout: BackColor   = 0x%lx\n",pText->BackColor);
                        dprintf("Textout: BackMode    = 0x%lx\n",pText->BackMode);
                        dprintf("Textout: x           = 0x%lx\n",pText->x);
                        dprintf("Textout: y           = 0x%lx\n",pText->y);
                        dprintf("Textout: fl          = 0x%lx\n",pText->fl);
                        dprintf("Textout: rcl.left    = 0x%lx\n",pText->rcl.left);
                        dprintf("Textout: rcl.top     = 0x%lx\n",pText->rcl.top);
                        dprintf("Textout: rcl.right   = 0x%lx\n",pText->rcl.right);
                        dprintf("Textout: rcl.bottom  = 0x%lx\n",pText->rcl.bottom);
                        dprintf("Textout: dwCodePage  = 0x%lx\n",pText->dwCodePage);
                        dprintf("Textout: cChar       = 0x%lx\n",pText->cChar);
                        dprintf("Textout: PdxOffset   = 0x%lx\n",pText->PdxOffset);

                        if (pText->cChar != 0)
                        {
                            dprintf("\t wchar array\n");
                            dprintf("\t\t");

                            ULONG ix = pText->cChar;
                            while (ix--)
                            {
                                dprintf("%x ",*pwchar++);
                            }
                            dprintf("\n");

                            if (pText->PdxOffset != 0)
                            {
                                dprintf("\t pdx array\n");
                                dprintf("\t\t");

                                ULONG ix = pText->cChar;
                                while (ix--)
                                {
                                    dprintf("%li ",*pdx++);
                                }
                                dprintf("\n");
                            }
                        }
                    }
                    break;

                case BatchTypeTextOutRect:
                    {
                        PBATCHTEXTOUTRECT pText = (PBATCHTEXTOUTRECT)pBatch;

                        dprintf("TextoutRect: length      = 0x%lx\n",pText->Length);
                        dprintf("TextoutRect: BackColor   = 0x%lx\n",pText->BackColor);
                        dprintf("TextoutRect: fl          = 0x%lx\n",pText->fl);
                        dprintf("TextoutRect: rcl.left    = 0x%lx\n",pText->rcl.left);
                        dprintf("TextoutRect: rcl.top     = 0x%lx\n",pText->rcl.top);
                        dprintf("TextoutRect: rcl.right   = 0x%lx\n",pText->rcl.right);
                        dprintf("TextoutRect: rcl.bottom  = 0x%lx\n",pText->rcl.bottom);
                    }
                    break;

                case BatchTypeSetBrushOrg:
                    {
                        PBATCHSETBRUSHORG pOrg = (PBATCHSETBRUSHORG)pBatch;

                        dprintf("SetBrushOrg: length      = 0x%lx\n",pOrg->Length);
                        dprintf("SetBrushOrg: x           = 0x%lx\n",pOrg->x);
                        dprintf("SetBrushOrg: y           = 0x%lx\n",pOrg->y);
                    }
                    break;

                case BatchTypeSelectClip:
                    {
                        PBATCHSETBRUSHORG pOrg = (PBATCHSETBRUSHORG)pBatch;

                        dprintf("SetBrushOrg: length      = 0x%lx\n",pOrg->Length);
                        dprintf("SetBrushOrg: x           = 0x%lx\n",pOrg->x);
                        dprintf("SetBrushOrg: y           = 0x%lx\n",pOrg->y);
                    }
                    break;


                case BatchTypeDeleteBrush:
                    {
                        PBATCHDELETEBRUSH pbr = (PBATCHDELETEBRUSH)pBatch;

                        dprintf("DeleteBrush: length      = 0x%lx\n",pbr->Length);
                        dprintf("DeleteBrush: hbrush      = 0x%lx\n",pbr->hbrush);
                    }
                    break;

                case BatchTypeDeleteRegion:
                    {
                        PBATCHDELETEREGION prg = (PBATCHDELETEREGION)pBatch;

                        dprintf("DeleteRegion: length      = 0x%lx\n",prg->Length);
                        dprintf("DeleteRegion: hregion     = 0x%lx\n",prg->hregion);
                    }
                    break;
                }

                pBatch = (PBATCHCOMMAND)((PBYTE)pBatch + pBatch->Length);
            }
        }
    }
    else
    {
        dprintf("Error reading TEB contents\n");
    }
#endif  // DOES NOT SUPPORT API64
}


/******************************Public*Routine******************************\
* batch
*
*  Lists a threads batched GDI commands
\**************************************************************************/

DECLARE_API( batch )
{
    dprintf("Extension 'batch' is not fully implemented.\n");
    DEBUG_VALUE DebugValue;
    ULONG64 TebAddress = -1;
    BOOL    bShowHelp = FALSE;
    
    INIT_API();

    while (*args && isspace(*args)) args++;
    if (*args)
    {
        if (args[0] == '-')
        {
            if (args[1]=='t' && isspace(args[2]))
            {
                ULONG64 ThreadAddress;

                args += 2;
                while (*args && isspace(*args)) args++;

                if (*args && 
                    (g_pExtControl->Evaluate(args,
                                             DEBUG_VALUE_INT64,
                                             &DebugValue,
                                             NULL) != S_OK)
                    )
                {
                    ExtErr("Invalid arguments: %s\n", args);
                    bShowHelp = TRUE;
                }
                else
                {
                    ThreadAddress = DebugValue.I64;
                    GetThreadField(Client, &ThreadAddress, "Tcb.Teb", 
                                   &DebugValue, DEBUG_VALUE_INT64);
                    TebAddress = DebugValue.I64;
                }
            }
            else
            {
                if (args[1]!='?')
                    ExtErr("Invalid arguments: %s\n", args);
                bShowHelp = TRUE;
            }
        }
        else
        {
            if (S_OK != g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &DebugValue, NULL))
            {
                ExtErr("Couldn't evaluate: %s\n", args);
                EXIT_API(S_OK);
            }

            TebAddress = DebugValue.I64;
        }
    }


    if (!bShowHelp)
    {
        if (TebAddress == (ULONG64)-1)
        {
            g_pExtSystem->GetCurrentThreadTeb(&TebAddress);
        }

        ExtVerb("  Teb = %p\n", TebAddress);

        if (TebAddress)
        {
            DumpTebBatch(Client, TebAddress);
        }
        else
        {
            ExtErr("NULL Teb.\n");
        }
    }

    if (bShowHelp)
    {
        ExtOut("Usage: batch [-?] [TEB | -t Thread]\n");
        ExtOut("   If TEB and Thread are omitted, defaults to the current thread\n");
    }

    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* dpeb
*
*   Dump gdi structure in PEB
*
* Arguments:
*
*    pPEB
*
* Return Value:
*
*    None
*
* History:
*
*    6-Mar-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if 0   // DOES NOT SUPPORT API64
VOID
GdiDPEB(
    PPEB        ppebIn,
    PW32PROCESS pw32process,
    BOOL        bw32
    )
{
    BYTE  lpeb[4096];
    BYTE  lw32proc[sizeof(W32PROCESS)];
    PPEB  ppeb = (PPEB)&lpeb[0];
    PW32PROCESS pw32 = (PW32PROCESS)&lw32proc[0];
    PGDIHANDLECACHE pCache = (PGDIHANDLECACHE)ppeb->GdiHandleBuffer;

    int iStatus = move2(lpeb,ppebIn,sizeof(PEB));

    if (iStatus)
    {
        dprintf("\nDump PEB  0x%lx\n",ppebIn);
        dprintf("GdiSharedHandleTable = 0x%lx\n",ppeb->GdiSharedHandleTable);
        dprintf("GdiDCAttributeList   = 0x%lx\n",ppeb->GdiDCAttributeList);
        dprintf("\n");

        dprintf("GDI Cached brush  handles = %li\n",pCache->ulNumHandles[BrushHandle]);
        dprintf("GDI Cached pen    handles = %li\n",pCache->ulNumHandles[PenHandle]);
        dprintf("GDI Cached region handles = %li\n",pCache->ulNumHandles[RegionHandle]);
        dprintf("GDI Cached lfont  handles = %li\n",pCache->ulNumHandles[LFontHandle]);

        PHANDLE pHandle = &pCache->Handle[0];
        ULONG ux;

        dprintf("\nBRUSH handles\n");

        for (ux=0;ux<CACHE_BRUSH_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\n\nPEN handles\n");

        for (ux=0;ux<CACHE_PEN_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\nREGION handles\n");

        for (ux=0;ux<CACHE_REGION_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\n");
    }
    else
    {
        dprintf("Error reading PEB contents\n");
        return;
    }

    if (bw32)
    {
        iStatus = move2(lw32proc,pw32process,sizeof(W32PROCESS));

        if (iStatus)
        {
            dprintf("W32PROCESS\n");

            dprintf("Process Handle Count %li\n",pw32->GDIHandleCount);


            PSINGLE_LIST_ENTRY pList = (PSINGLE_LIST_ENTRY)pw32->pDCAttrList;

            dprintf("Process DC_ATTRs 0x%lx\n",pw32->pDCAttrList);

            //
            // dump DCATTRs
            //

          //  while (pList)
          //  {
          //      BYTE lList[sizeof(SINGLE_LIST_ENTRY)];
          //      PSINGLE_LIST_ENTRY puList = (PSINGLE_LIST_ENTRY)&lList[0];
          //
          //      move2(lList,pList,sizeof(SINGLE_LIST_ENTRY));
          //
          //      dprintf("dcattr 0x%lx, next = 0x%lx\n",pList,puList->Next);
          //
          //      pList = puList->Next;
          //
          //      if (CheckControlC())
          //      {
          //          return;
          //      }
          //  }
          //
            //
            // dump brushattrs
            //

            pList = (PSINGLE_LIST_ENTRY)pw32->pBrushAttrList;

            dprintf("Process BRUSHATTRs 0x%lx:\n",pw32->pBrushAttrList);

          //  while (pList)
          //  {
          //      BYTE lList[sizeof(SINGLE_LIST_ENTRY)];
          //      PSINGLE_LIST_ENTRY puList = (PSINGLE_LIST_ENTRY)&lList[0];
          //
          //      move2(lList,pList,sizeof(SINGLE_LIST_ENTRY));
          //
          //      dprintf("brushattr 0x%lx, next = 0x%lx\n",pList,puList->Next);
          //
          //      pList = puList->Next;
          //
          //      if (CheckControlC())
          //      {
          //          return;
          //      }
          //  }
        }
    }
}
#endif  // DOES NOT SUPPORT API64



DECLARE_API( dpeb )
{
    dprintf("Extension 'dpeb' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
    PVOID       Process;
    EPROCESS    ProcessContents;
    PPEB        ppeb;
    PW32PROCESS pw32process;
    BOOL        bW32Thread = FALSE;

    //
    // dpeb [peb], look for peb input
    //
    PARSE_ARGUMENTS(peb_help);
    if(parse_iFindSwitch(tokens, ntok, 'w')!=-1) {bW32Thread=TRUE;}

    //
    // use current peb
    //

    Process = GetCurrentProcessAddress( dwProcessor, hCurrentThread, NULL );

    if ( !ReadMemory( (UINT_PTR)Process,
                      &ProcessContents,
                      sizeof(EPROCESS),
                      NULL))
    {
       dprintf("%08lx: Unable to read _EPROCESS\n", Process );
       return;
    }

    dprintf("Process 0x%p      W32Process: 0x%p\n",
               (ULONG_PTR)Process,
               (ULONG_PTR)ProcessContents.Win32Process);

    ppeb        = ProcessContents.Peb;
    pw32process = (PW32PROCESS)ProcessContents.Win32Process;

    GdiDPEB(ppeb,pw32process,bW32Thread);
    return;
peb_help:
    dprintf("Usage: dpeb [-?] [-w]\n");
    dprintf("-w indicates W32PROCESS structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}



DECLARE_API( w32p )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    BOOL            BadArg = FALSE;
    BOOL            ProcessArg = FALSE;
    DEBUG_VALUE     Address = {0, DEBUG_VALUE_INVALID};

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'p':
                        ProcessArg = TRUE;
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Address.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or a Process.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an address or Process
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &Address,
                             &Rem) == S_OK &&
                    args + Rem == EOP &&
                    Address.I64 != 0)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a %s.\n",
                                  args,
                                  (ProcessArg ? "Process" : "W32PROCESS address"));
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else
            {
                // All other arguments are invalid
                OutCtl.OutErr("Error: Invalid argument '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (!BadArg)
    {
        if (ProcessArg && Address.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Process.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("w32p dumps W32PROCESS stucture for current or specified process.\n\n");
        }

        OutCtl.Output("Usage: w32p [-?] [W32PROCESS Addr | -p Process]\n");
    }
    else
    {
        if (Address.Type == DEBUG_VALUE_INVALID || ProcessArg)
        {
            ULONG64 ProcessAddr = (Address.Type == DEBUG_VALUE_INVALID) ?
                                    CURRENT_PROCESS_ADDRESS :
                                    Address.I64;

            hr = GetProcessField(Client, &ProcessAddr, "Win32Process", &Address, DEBUG_VALUE_INT64);

            if (hr == S_OK)
            {
                if (Address.I64 == 0)
                {
                    OutCtl.Output(" Process 0x%p does not have a Win32Process.\n", ProcessAddr);
                    hr = S_FALSE;
                }
            }
            else
            {
                OutCtl.OutErr("Unable to look up Win32Process address.\n");
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "_W32PROCESS", Address.I64);
        }
    }

    return hr;
}


DECLARE_API( w32t )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    BOOL            BadArg = FALSE;
    BOOL            ThreadArg = FALSE;
    DEBUG_VALUE     Address = {0, DEBUG_VALUE_INVALID};

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 't':
                        ThreadArg = TRUE;
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Address.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or a Thread.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an address or Thread
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &Address,
                             &Rem) == S_OK &&
                    args + Rem == EOP &&
                    Address.I64 != 0)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a %s.\n",
                                  args,
                                  (ThreadArg ? "Thread" : "W32THREAD address"));
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else
            {
                // All other arguments are invalid
                OutCtl.OutErr("Error: Invalid argument '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (!BadArg)
    {
        if (ThreadArg && Address.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Thread.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("w32t dumps W32TRHEAD stucture for current or specified thread.\n\n");
        }

        OutCtl.Output("Usage: w32t [-?] [W32THREAD Addr | -t Thread]\n");
    }
    else
    {
        if (Address.Type == DEBUG_VALUE_INVALID || ThreadArg)
        {
            ULONG64 ThreadAddr = (Address.Type == DEBUG_VALUE_INVALID) ?
                                    CURRENT_THREAD_ADDRESS :
                                    Address.I64;

            hr = GetThreadField(Client, &ThreadAddr, "Tcb.Win32Thread", &Address, DEBUG_VALUE_INT64);

            if (hr == S_OK)
            {
                if (Address.I64 == 0)
                {
                    OutCtl.Output(" Thread 0x%p does not have a Win32Thread.\n", ThreadAddr);
                    hr = S_FALSE;
                }
            }
            else
           {
               OutCtl.OutErr("Unable to look up Win32Thread address.\n");
           }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "_W32THREAD", Address.I64);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\typeout.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    typeout.cxx

Abstract:

    This file contains type related output classes.

Author:

    Jason Hartman (JasonHa) 2000-12-18

Environment:

    User Mode

--*/

#include "precomp.hxx"

#define MAX_NAME                 2048


//----------------------------------------------------------------------------
//
// TypeOutputParser
//
// DebugOutputCallback class to parse type output looking for 
// a field and its value.
//
//----------------------------------------------------------------------------

HRESULT
TypeOutputParser::LookFor(
    PDEBUG_VALUE pValueOut,
    PCSTR pszField,
    ULONG DesiredType
    )
{
    Stage = NoField;

    if ((1 > strlen(pszField)) ||
        (strlen(pszField) >= sizeof(Field)/sizeof(Field[0])))
    {
        return E_INVALIDARG;
    }

    Value.Type = DEBUG_VALUE_INVALID;
    strcpy(Field, pszField);

    // Make sure the field name is valid
    while (*pszField)
    {
        if (!__iscsym(*pszField)) return E_INVALIDARG;
        pszField++;
    }

    if (pValueOut != NULL)
    {
        if (Client == NULL) return E_POINTER;
    }

    Type = DesiredType;
    
    ValueOut = pValueOut;

    if (ValueOut != NULL)
    {
        ValueOut->Type = DEBUG_VALUE_INVALID;
    }

    Stage = FieldSpecified;

    return S_OK;
}


HRESULT
TypeOutputParser::Get(
    PDEBUG_VALUE pValueOut,
    PCSTR pszField,
    ULONG DesiredType
    )
{
    HRESULT hr;

    // Check if we've already found this value first
    if (Stage == ValueFound &&
        strcmp(pszField, Field) == 0)
    {
        if (pValueOut != NULL)
        {
            // Make sure to output the right type
            PDEBUG_CONTROL  Control;

            if (Client != NULL)
            {
                hr = Client->QueryInterface(__uuidof(IDebugControl),
                                            (void **)&Control);
                if (hr == S_OK)
                {
                    hr = Control->CoerceValue(&Value, DesiredType, pValueOut);
                    Control->Release();
                }
            }
            else
            {
                hr = E_POINTER;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    else if ((hr = LookFor(pValueOut, pszField, DesiredType)) == S_OK &&
             (hr = ParseOutput(PARSE_OUTPUT_NO_DISCARD | PARSE_OUTPUT_ALL)) == S_OK)
    {
        hr = Complete();
    }

    return hr;
}


HRESULT
TypeOutputParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    HRESULT     hr = S_OK;
    PCSTR       pStrUnused = Text;
    PCSTR       pStr = pStrUnused;
    ULONG       EvalStart, EvalEnd;

//    DbgPrint("TypeOutputParser::Parse: Searching \"%s\"\n", pStrUnused);

    while (Stage == FieldSpecified && pStr != NULL)
    {
        pStr = strstr(pStr, Field);
        if (pStr != NULL)
        {
            // Check Field is bounded by non-symbol characters
            BOOL FieldStart = (pStr-1 < pStrUnused) || (!__iscsym(*(pStr-1)));

            // Advance search location
            pStr += strlen(Field);

            if (FieldStart && !__iscsym(*pStr))
            {
                Stage = FieldFound;
            }
        }
    }

    if (Stage == FieldFound)
    {
        pStrUnused = pStr;

        hr = Evaluate(Client,
                      pStrUnused,
                      DEBUG_VALUE_INVALID,
                      10,
                      &Value,
                      &EvalEnd,
                      &EvalStart);

        if (hr == S_OK)
        {
//            DbgPrint("TypeOutputParser::Parse: Found 0x%I64x after \"%s\".\n", Value.I64, Field);

            Stage = ValueFound;

            SIZE_T  EvalLen = min(EvalEnd-EvalStart, sizeof(szValue)-1);

            RtlCopyMemory(szValue, pStrUnused+EvalStart, EvalLen);
            szValue[EvalLen] = '\0';

            if (ValueOut != NULL)
            {
                // Make sure to output the right type
                PDEBUG_CONTROL  Control;

                if (Client != NULL)
                {
                    hr = Client->QueryInterface(__uuidof(IDebugControl),
                                                (void **)&Control);
                    if (hr == S_OK)
                    {
                        hr = Control->CoerceValue(&Value, Type, ValueOut);
                        Control->Release();
                    }
                }
                else
                {
                    hr = E_POINTER;
                }
            }

            pStrUnused += EvalEnd;
        }
        else
        {
            DbgPrint("Evaluate returned HRESULT 0x%lx.\n", hr);
        }
    }

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return hr;
}



//----------------------------------------------------------------------------
//
// TypeOutputHelper
//
// DebugOutputCallback class to look up a field's type.
//
//----------------------------------------------------------------------------

class TypeOutputHelper : public OutputReader
{
public:
    TypeOutputHelper(PDEBUG_CLIENT DbgClient) : OutputReader()
    {
        Client = DbgClient;
        if (Client != NULL) Client->AddRef();
    }
    ~TypeOutputHelper()
    {
        if (Client != NULL) Client->Release();
    }

    HRESULT FindFieldType(ULONG64 Module,
                          ULONG TypeId,
                          PCSTR SearchLine,
                          PSTR FieldTypeName,
                          ULONG FieldTypeNameSize);

private:
    PDEBUG_CLIENT   Client;
};

HRESULT
TypeOutputHelper::FindFieldType(
    ULONG64 Module,
    ULONG TypeId,
    PCSTR SearchLine,
    PSTR FieldTypeName,
    ULONG FieldTypeNameSize
    )
{
    HRESULT     hr = S_FALSE;
    PSTR        pLine;
    OutputState OutState(Client);

    if (OutState.Client == NULL)
    {
        DbgPrint("TypeOutputHelper::FindFieldType: Client is NULL.\n");
        return hr;
    }

    if ((hr = OutState.Setup(0, this)) != S_OK)
    {
        return hr;
    }

    if ((hr = OutState.OutputTypeVirtual(0, Module, TypeId, 0)) != S_OK)
    {
        return hr;
    }

    if (Buffer != NULL &&
        (pLine = strstr(Buffer, SearchLine)) != NULL)
    {
        pLine += strlen(SearchLine);

        ULONG i = 0;
        while (i < FieldTypeNameSize &&
               iscsym(*pLine))
        {
            FieldTypeName[i++] = *pLine++;
        }
        FieldTypeName[i] = '\0';
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}



//----------------------------------------------------------------------------
//
// TypeOutputDumper
//
// DebugOutputCallback class to dump type output
// expanding flags and enums.
//
//----------------------------------------------------------------------------

TypeOutputDumper::TypeOutputDumper(
    PDEBUG_CLIENT DbgClient,
    OutputControl *DbgOutCtl
    ) : 
    OutputReader()
{
    Client = DbgClient;
    Symbols = NULL;
    OutCtl = NULL;

    if (Client != NULL)
    {
        Client->AddRef();
        Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);

        if (DbgOutCtl == NULL)
        {
            OutCtl = new OutputControl(DEBUG_OUTCTL_AMBIENT, Client);
        }
        else
        {
            OutCtl = DbgOutCtl;
            OutCtl->AddRef();
        }
    }

    Last.Offset = 0;
    Last.Module = 0;
    Last.TypeId = 0;
    Last.Flags = 0;

    MarkUse = IGNORE_MARKS;
    MarkList = NULL;
    Marks = 0;
    MarkListLen = 0;

    CurrentMarkSet = 0;
    for (ULONG Set = 1; Set < lengthof(MarkSet); Set++)
    {
        MarkSet[Set].Use = IGNORE_MARKS;
        MarkSet[Set].List = NULL;
        MarkSet[Set].Marks = 0;
        MarkSet[Set].ListLen = 0;
    }
}


TypeOutputDumper::~TypeOutputDumper()
{
    if (MarkList != NULL) HeapFree(hHeap, 0, MarkList);
    for (ULONG Set = 0; Set < lengthof(MarkSet); Set++)
    {
        if (Set != CurrentMarkSet)
        {
            if (MarkSet[Set].List != NULL) HeapFree(hHeap, 0, MarkSet[Set].List);
        }
    }
    if (OutCtl != NULL) OutCtl->Release();
    if (Symbols != NULL) Symbols->Release();
    if (Client != NULL) Client->Release();
}


void
TypeOutputDumper::DiscardOutput()
{
    // Reset cache id
    Last.Offset = 0;
    Last.Module = 0;
    Last.TypeId = 0;
    Last.Flags = 0;

    OutputReader::DiscardOutput();
}


HRESULT TypeOutputDumper::OutputType(
    BOOL Physical,
    PCSTR Type,
    ULONG64 Offset,
    ULONG Flags,
    PCSTR OutputPrefix
    )
{
    HRESULT hr = S_FALSE;
    char    TypeName[MAX_NAME];
    ULONG64 Module;
    ULONG   TypeId;

    if (OutCtl == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: OutCtl is NULL.\n");
        return hr;
    }

    if (Client == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Client is NULL.\n");
        return hr;
    }

    if (Symbols == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Symbols is NULL.\n");
        return hr;
    }

    if ((hr = GetTypeId(Client, Type, &TypeId, &Module)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeId returned HRESULT 0x%lx.\n", hr);
        return hr;
    }

    if ((hr = Symbols->GetTypeName(Module, TypeId,
                                   TypeName, sizeof(TypeName),
                                   NULL)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeName returned HRESULT %lx.\n", hr);
        return hr;
    }

    if (Offset == 0)
    {
        Physical = FALSE;

        hr = Symbols->GetOffsetByName(Type, &Offset);

        if (hr != S_OK && hr != S_FALSE)
        {
            OutCtl->OutVerb(" GetOffsetByName returned HRESULT 0x%lx\n", hr);
            return hr;
        }

        OutCtl->OutVerb(" Dumping symbol: Type %s @ %p\n", TypeName, Offset);
    }

    return OutputType(Physical, Module, TypeId, Offset, Flags, OutputPrefix);
}

HRESULT TypeOutputDumper::OutputType(
    BOOL Physical,
    ULONG64 Module,
    ULONG TypeId,
    ULONG64 Offset,
    ULONG Flags,
    PCSTR OutputPrefix
    )
{
    HRESULT     hr = S_FALSE;
    CHAR        TypeName[MAX_NAME];
    PSTR        pNextLine;
    PCHAR       pEOL;
    CHAR        EOLChar;
    PSTR        pTypeLine, pFieldOffset, pField, pFieldValue, pFieldValueInLine;
    ULONG64     FieldOffset;
    CHAR        Field[MAX_NAME];
    ULONG       FieldLen;
    DEBUG_VALUE FieldValue;
    CHAR        FieldTypeName[MAX_NAME];
    ULONG       FieldTypeId;
    ULONG       Remainder;

    if (OutCtl == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: OutCtl is NULL.\n");
        return hr;
    }

    if (Client == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Client is NULL.\n");
        return hr;
    }

    if (Symbols == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Symbols is NULL.\n");
        return hr;
    }

    if ((hr = Symbols->GetTypeName(Module, TypeId,
                                   TypeName, sizeof(TypeName),
                                   NULL)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeName(%p, %lx) returned HRESULT 0x%lx.\n",
                        Module, TypeId, hr);
        return hr;
    }

    // Read type information if we don't already have it cached
    if (Offset != Last.Offset ||
        Module != Last.Module ||
        TypeId != Last.TypeId ||
        Flags != Last.Flags)
    {
        OutputState OutState(Client);

        if ((hr = OutState.Setup(0, this)) != S_OK)
        {
            OutCtl->OutVerb(" Callback Setup returned HRESULT 0x%lx.\n", hr);
            return hr;
        }

        DiscardOutput();

        if ((hr = OutState.OutputType(Physical, Offset, Module, TypeId, Flags)) != S_OK)
        {
            OutCtl->OutVerb(" Type Output returned HRESULT 0x%lx.\n", hr);
            return hr;
        }
    }

    pNextLine = Buffer;

    if (pNextLine == NULL)
    {
        return S_OK;
    }

    // The data won't change between instances of
    // this type so this is a sufficient cache id.
    Last.Offset = Offset;
    Last.Module = Module;
    Last.TypeId = TypeId;
    Last.Flags = Flags;

    if (OutputPrefix == NULL) OutputPrefix = "";

    // Check if this type is a pointer
    FieldLen = strlen(TypeName) - 1;
    if (TypeName[FieldLen] == '*')
    {
        // Remove trailing *
        TypeName[FieldLen] = '\0';

        pTypeLine = pNextLine;

        pEOL = pTypeLine;

        // Find end of this line
        while ((*pEOL != '\0') &&
               (*pEOL != '\n') &&
               (*pEOL != '\r') &&
               (*pEOL != '\f'))
        {
            pEOL++;
        }

        // Save EOL char and then zero-terminate line
        EOLChar = *pEOL;
        *pEOL = '\0';

        // Output TYPE @ Real Address
        OutCtl->Output("%s%s @ %s\n", OutputPrefix, TypeName, pTypeLine);

        // Restore EOL
        *pEOL = EOLChar;

        if (EOLChar == '\0') return S_OK;

        // Look for begining of next line
        do
        {
            pNextLine++;
        } while ((*pNextLine == '\n') ||
                 (*pNextLine == '\r') ||
                 (*pNextLine == '\f'));
    }

    EOLChar = '\0';

    while (*pNextLine != '\0')
    {
        // Restore buffer string
        if (EOLChar != '\0')
        {
            *pEOL = EOLChar;
            EOLChar = '\0';
        }

        hr = OutCtl->GetInterrupt();
//        DbgPrint("GetInt returned %s.\n", pszHRESULT(hr));
        if (hr == S_OK)
        {
            OutCtl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            break;
        }

        pTypeLine = pNextLine;

        // Find end of this line
        pEOL = pTypeLine;
        if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
        {
            while ((*pEOL != '\0') &&
                   (*pEOL != '\n') &&
                   ((pEOL[0] != ' ') ||
                    (pEOL[1] != ' ')))
            {
                pEOL++;
            }
        }
        else
        {
            while ((*pEOL != '\0') &&
                   (*pEOL != '\n') &&
                   (*pEOL != '\r') &&
                   (*pEOL != '\f'))
            {
                pEOL++;
            }
        }

        pNextLine = pEOL;

        EOLChar = *pEOL;

        if (EOLChar != '\0')
        {
            *pEOL = '\0';

            // Look for begining of next line
            if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
            {
                do
                {
                    pNextLine++;
                } while ((*pNextLine == '\n') ||
                         ((pNextLine[0] == ' ') &&
                          ((pNextLine[1] == ' ') ||
                           (pNextLine[1] == '\n'))));
            }
            else
            {
                do
                {
                    pNextLine++;
                } while ((*pNextLine == '\n') ||
                         (*pNextLine == '\r') ||
                         (*pNextLine == '\f'));
            }
        }

        pFieldOffset = pTypeLine;
        Remainder = 0;
        FieldOffset = 0;

        while (isspace(*pFieldOffset)) pFieldOffset++;

        if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
        {
            if (*pFieldOffset == '+')
            {
                DEBUG_VALUE TypeFieldOffset;

                pFieldOffset++;

                hr = Evaluate(Client, pFieldOffset, DEBUG_VALUE_INT64, 0, &TypeFieldOffset, &Remainder);

                if (hr != S_OK)
                {
                    OutCtl->OutVerb(" Evaluate couldn't evauluate field offset in\n"
                                    "%s%s\n", OutputPrefix, pTypeLine);
                    continue;
                }

                FieldOffset = Offset + TypeFieldOffset.I64;
            }
            else if (*pFieldOffset == '=')
            {
                DEBUG_VALUE StaticFieldOffset;

                pFieldOffset++;

                hr = Evaluate(Client, pFieldOffset, DEBUG_VALUE_INT64, 0, &StaticFieldOffset, &Remainder);

                if (hr != S_OK)
                {
                    OutCtl->OutVerb(" Evaluate couldn't evauluate field offset in\n"
                                    "%s%s\n", OutputPrefix, pTypeLine);
                    continue;
                }

                FieldOffset = StaticFieldOffset.I64;
            }
        }

        // HRESULT indicating line parsing failure
        hr = S_FALSE;

        pField = pFieldOffset + Remainder;

        while (*pField != '\0' && isspace(*pField))
        {
            pField++;
        }

        if (!iscsymf(*pField))
        {
            OutCtl->OutWarn(" Couldn't find field in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }

        pFieldValue = pField;

        while (iscsym(*pFieldValue)) pFieldValue++;

        // Check for scoped field name: Type::Field
        if (pFieldValue[0] == ':' &&
            pFieldValue[1] == ':' &&
            iscsymf(pFieldValue[2]))
        {
            pFieldValue += 3;
            while (iscsym(*pFieldValue)) pFieldValue++;
        }

        if (!isspace(*pFieldValue))
        {
            OutCtl->OutWarn(" Couldn't find field value in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }

        FieldLen = (ULONG)(pFieldValue - pField);
        if (FieldLen >= sizeof(Field)/sizeof(Field[0]))
        {
            OutCtl->OutWarn(" Field too long in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }
        strncpy(Field, pField, FieldLen);
        Field[FieldLen] = '\0';

        if (MarkUse != IGNORE_MARKS)
        {
            ULONG   Mark;
            BOOL    Marked = FALSE;

            for (Mark = 0; Mark < Marks; Mark++)
            {
                if (FieldLen == MarkList[Mark].Len)
                {
                    // For exclusion, entire Field must match.
                    // For inclusion, only top level field must match.
                    Marked = (MarkUse == EXCLUDE_MARKED) ?
                        (strcmp(Field, MarkList[Mark].Field) == 0) :
                        (strncmp(Field, MarkList[Mark].Field, FieldLen) == 0);
                    if (Marked) break;
                }
            }

            // EXCULDE_MARKED - may not be marked
            // INCLUDE_MARKED - must be marked
            if ((MarkUse == EXCLUDE_MARKED) ? Marked : !Marked)
            {
                hr = S_OK;
                continue;
            }
        }

        while (*pFieldValue != '\0' &&
               !(iscsym(*pFieldValue) || *pFieldValue == '('))
        {
            pFieldValue++;
        }

        pFieldValueInLine = pFieldValue;

        if (*pFieldValue == '\0')
        {
            OutCtl->OutWarn(" No value found in:\n");
            OutCtl->OutVerb("  (checking for complex type)\n");

            TypeOutputHelper    FieldTypeReader(Client);
            if ((hr = FieldTypeReader.FindFieldType(Module, TypeId, pTypeLine,
                                                    FieldTypeName,
                                                    sizeof(FieldTypeName))) != S_OK)
            {
                OutCtl->OutErr(" No value/complex type found in:\n", pTypeLine);
                OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);
                continue;
            }

            pFieldValue = FieldTypeName;
        }

        // We have a full line
        hr = S_OK;

        if (iscsymf(*pFieldValue))
        {
            // If the debugger recognizes this field as a basic type
            // it will output the type and the values together.
            // We just want to get the type name.
            if (pFieldValue != FieldTypeName)
            {
                PSTR pFieldTypeName = FieldTypeName;
                do
                {
                    *pFieldTypeName++ = *pFieldValue++;
                }
                while (iscsym(*pFieldValue) &&
                       pFieldTypeName < &FieldTypeName[sizeof(FieldTypeName)/sizeof(FieldTypeName[0])-1]);
                *pFieldTypeName = '\0';

                // Check for whitespace at the end of the field name
                if (*pFieldValue != '\0' && !isspace(*pFieldValue))
                {
                    // If not, try using entire field value as type name.
                    pFieldValue -= pFieldTypeName - FieldTypeName;
                }
                else
                {
                    // If there is, ignore remaining field value (if any)
                    pFieldValue = FieldTypeName;
                }
            }

            if ((hr = Symbols->GetTypeId(Module, pFieldValue, &FieldTypeId)) == S_OK)
            {
                DbgPrint("Dumping SubType %s (%lx)\n", pFieldValue, FieldTypeId);
                CHAR    SubPrefix[40] = "";

                // 
                if (FieldOffset == 0 &&
                    Offset != 0 &&
                    pFieldOffset == pField)
                {
                    if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
                    {
                        OutCtl->OutWarn("Field offset not available while attempting sub-type dump.\n");
                    }

                    ULONG   FieldOffset32;
                    if ((hr = Symbols->GetFieldOffset(Module, TypeId, Field, &FieldOffset32)) == S_OK)
                    {
                        FieldOffset = Offset + FieldOffset32;
                    }
                }

                if (hr == S_OK)
                {
                    // Is this a primitive GDI type
                    if (IsKnownType(Client, Module, FieldTypeId))
                    {
                        *pFieldValueInLine = '\0';
                        // Output the type line w/o field type and newline
                        OutCtl->Output("%s%s", OutputPrefix, pTypeLine);
                        OutputKnownType(Client, OutCtl, Module, FieldTypeId, FieldOffset, Flags);
                        OutCtl->Output("%c", EOLChar);
                    }
                    else
                    {
                        // Output the type line
                        OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);

                        strcpy(SubPrefix, OutputPrefix);
                        if (!(Flags & (DEBUG_OUTTYPE_NO_INDENT | DEBUG_OUTTYPE_COMPACT_OUTPUT)))
                        {
                            strcat(SubPrefix, "   ");
                        }

                        TypeOutputDumper    SubTypeDumper(Client, OutCtl);
                        BOOL                SubDump = TRUE;

                        if (MarkUse != IGNORE_MARKS)
                        {
                            ULONG   Mark;

                            SubTypeDumper.MarkUse = MarkUse;

                            for (Mark = 0; Mark < Marks; Mark++)
                            {
                                if (FieldLen == MarkList[Mark].Len &&
                                    strncmp(Field, MarkList[Mark].Field, FieldLen) == 0)
                                {
                                    if (MarkUse == EXCLUDE_MARKED)
                                    {
                                        // Exact matches on exclusion shouldn't be here.
                                        if (MarkList[Mark].Field[FieldLen] == '\0')
                                        {
                                            DbgPrint("This field should completely excluded.\n");
                                            DbgBreakPoint();
                                        }

                                        // MarkUse = EXCLUDE_MARKED
                                        if (MarkList[Mark].Field[FieldLen+1] == '*')
                                        {
                                            // All subfields are marked; so,
                                            // no subfields are to be included.
                                            SubDump = FALSE;
                                            break;
                                        }
                                        else if (MarkList[Mark].Field[FieldLen+1] == '\0')
                                        {
                                            // No subfields are marked; so,
                                            // all subfields are to be included.
                                            SubTypeDumper.MarkUse = IGNORE_MARKS;
                                        }
                                        else
                                        {
                                            SubTypeDumper.MarkUse = EXCLUDE_MARKED;
                                            SubTypeDumper.MarkField(MarkList[Mark].Field+FieldLen+1);
                                        }
                                    }
                                    else
                                    {
                                        // MarkUse = INCLUDE_MARKED
                                        if (MarkList[Mark].Field[FieldLen] == '\0' ||
                                            MarkList[Mark].Field[FieldLen+1] == '*')
                                        {
                                            // We have an exact match or all
                                            // subfields are marked; so, all
                                            // subfields are to be included.
                                            SubDump = TRUE;
                                            SubTypeDumper.MarkUse = IGNORE_MARKS;
                                            break;
                                        }
                                        else if (MarkList[Mark].Field[FieldLen+1] == '\0')
                                        {
                                            // No subfields are to be included.
                                            SubDump = FALSE;
                                        }
                                        else
                                        {
                                            SubDump = TRUE;
                                            SubTypeDumper.MarkField(MarkList[Mark].Field+FieldLen+1);
                                        }
                                    }
                                }
                            }
                        }

                        if (SubDump)
                        {
                            hr = SubTypeDumper.OutputType(Physical,
                                                          Module,
                                                          FieldTypeId,
                                                          FieldOffset,
                                                          Flags,
                                                          SubPrefix);
                        }
                    }
                }

                if (hr != S_OK)
                {
                    OutCtl->OutWarn(" SubType dump returned HRESULT 0x%lx.\n",
                                    hr);
                }
            }
            else
            {
                if (strcmp(pFieldValue, "__unnamed") != 0)
                {
                    OutCtl->OutErr(" Couldn't identify type '%s' in:\n",
                                   pFieldValue);
                }
                OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);
            }

            // Even if the sub type dump failed we
            // can continue the rest of this type.
            hr = S_OK;
        }
        else
        {
            // Use %s so there is no interpretation on pTypeLine.
            OutCtl->Output("%s%s", OutputPrefix, pTypeLine);

            if ((hr = Evaluate(Client, pFieldValue,
                               DEBUG_VALUE_INT64, 10,
                               &FieldValue, NULL)) == S_OK)
            {
                // Send this field through the FlagEnum search
                OutputTypeFieldValue(OutCtl,
                                     TypeName, Field, &FieldValue,
                                     Client,
                                     Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT);
            }
            else
            {
                OutCtl->OutWarn(" Evaluate(%s) returned HRESULT 0x%lx.\n",
                                pFieldValue, hr);
                hr = S_OK;
            }

            // Flush output line
            OutCtl->Output("%c", EOLChar);
        }
    }

    if (EOLChar != '\0')
    {
        *pEOL = EOLChar;
    }

    return hr;
}


HRESULT
TypeOutputDumper::SelectMarks(
    ULONG Set
    )
{
    if (Set >= lengthof(MarkSet)) return E_INVALIDARG;

    if (Set != CurrentMarkSet)
    {
        MarkSet[CurrentMarkSet].Use = MarkUse;
        MarkSet[CurrentMarkSet].List = MarkList;
        MarkSet[CurrentMarkSet].Marks = Marks;
        MarkSet[CurrentMarkSet].ListLen = MarkListLen;

        CurrentMarkSet = Set;
        MarkUse = MarkSet[CurrentMarkSet].Use;
        MarkList = MarkSet[CurrentMarkSet].List;
        Marks = MarkSet[CurrentMarkSet].Marks;
        MarkListLen = MarkSet[CurrentMarkSet].ListLen;
    }

    return S_OK;
}


HRESULT
TypeOutputDumper::MarkField(
    PCSTR Field
    )
{
    if (Field == NULL) return E_INVALIDARG;

    ULONG FieldLen = strlen(Field);

    if (Marks == MarkListLen)
    {
        FieldSpec  *NewList;
        SIZE_T      NewListSize;

        if (hHeap == NULL)
        {
            hHeap = GetProcessHeap();
            if (hHeap == NULL) return S_FALSE;
        }

        // New entry we need plus some extra space
        NewListSize = (MarkListLen+8)*sizeof(FieldSpec);

        NewList = (FieldSpec *) ((MarkList == NULL) ?
                            HeapAlloc(hHeap, 0, NewListSize):
                            HeapReAlloc(hHeap, 0, MarkList, NewListSize));

        if (NewList == NULL)
        {
            DbgPrint("Buffer alloc failed.\n");
            return E_OUTOFMEMORY;
        }

        // How much was really allocated?
        NewListSize = HeapSize(hHeap, 0, NewList);

        // Update List data
        MarkList = NewList;
        MarkListLen = NewListSize / sizeof(FieldSpec);
    }


    // Add new entry
    PCSTR NextField = strchr(Field, '.');

    MarkList[Marks].Len = (NextField != NULL) ?
                            NextField - Field :
                            strlen(Field);

    MarkList[Marks].Field = Field;

    Marks++;

    return S_OK;
}


HRESULT
TypeOutputDumper::MarkFields(
    PCSTR *FieldList,
    ULONG Count
    )
{
    if (FieldList == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    PCSTR   Field;

    while (hr == S_OK &&
           Count &&
           *FieldList != NULL)
    {
        hr = MarkField(*FieldList);
        FieldList++;
        Count--;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\verifier.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    verifier.cxx

Abstract:

    This file contains the verifier related routines
    for the kernel debugger extensions dll.

Author:

    Jason Hartman (JasonHa)

Environment:

    User Mode

--*/


#include "precomp.hxx"

// Pool tracking is always disabled for graphic drivers. (NTBUG:421768)
#define GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED 0


/******************************Public*Routine******************************\
* DECLARE_API( verifier )
*
* Dumps the stack backtraces in the tracked pool.  Only for checked Hydra.
*
\**************************************************************************/

CHAR szVSTATE[]              = "win32k!VSTATE";
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
CHAR szVERIFIERTRACKHDR[]    = "win32k!VERIFIERTRACKHDR";
#endif

const PSZ gpszVerifierFuncs[] = {
    "EngAllocMem           ",
    "EngFreeMem            ",
    "EngAllocUserMem       ",
    "EngFreeUserMem        ",
    "EngCreateBitmap       ",
    "EngCreateDeviceSurface",
    "EngCreateDeviceBitmap ",
    "EngCreatePalette      ",
    "EngCreateClip         ",
    "EngCreatePath         ",
    "EngCreateWnd          ",
    "EngCreateDriverObj    ",
    "BRUSHOBJ_pvAllocRbrush",
    "CLIPOBJ_ppoGetPath    ",
};

#define NUM_VER_FUNCS   (sizeof(gpszVerifierFuncs)/sizeof(gpszVerifierFuncs[0]))

DECLARE_API( verifier  )
{
    ULONG       error;
    ULONG64     offVState;

    #define GetVSTATEField(field,local)   \
        GetFieldValue(offVState, szVSTATE, field, local)
    
    // VSTATE fields
    FLONG       fl;
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    ULONG64     pList;
#endif
    
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    BOOL bDump = FALSE;
#endif
    BOOL bStats = FALSE;

    //
    // Parse arguments.
    //

    PARSE_ARGUMENTS(verifier_help);
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto verifier_help; }
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    if(parse_iFindSwitch(tokens, ntok, 'd')!=-1) { bDump = TRUE; }
#endif
    if(parse_iFindSwitch(tokens, ntok, 's')!=-1) { bStats = TRUE; }

    //
    // Get global veriferier address (VSTATE gvs)
    //

    offVState = GetExpression(GDISymbol(gvs));
    if (! offVState)
    {
        ReloadSymbols(GDIModule());
        offVState = GetExpression(GDISymbol(gvs));

        if (! offVState)
        {
            dprintf(" GetExpression(\"%s\") returned 0.\n", GDISymbol(gvs));
            dprintf("  Please fix symbols and try again.\n");
            EXIT_API(S_OK);
        }
    }


    //
    // Always dump the verifier state.
    //

    dprintf("Global VSTATE (@ %#p)\n", offVState);

    if (error = (ULONG)InitTypeRead(offVState, win32k!VSTATE))
    {
        dprintf(" unable to get contents of verifier state\n");
        dprintf("  (InitTypeRead returned %s)\n", pszWinDbgError(error));
        EXIT_API(S_OK);
    }

    fl = (FLONG)ReadField(fl);
    dprintf("  fl                      = 0x%08lx\n", fl);
    if (fl = (FLONG)flPrintFlags(afdDVERIFIER, (ULONG64)fl))
    {
        dprintf("                              Unknown flags: 0x%08lx\n", fl);
    }
    dprintf("  bSystemStable           = %s\n"     , ReadField(bSystemStable) ? "TRUE" : "FALSE");
    dprintf("  ulRandomSeed            = 0x%08lx\n", (ULONG)ReadField(ulRandomSeed));
    dprintf("  ulFailureMask           = 0x%08lx\n", (ULONG)ReadField(ulFailureMask));
    dprintf("  ulDebugLevel            = %ld\n"    , (ULONG)ReadField(ulDebugLevel));
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    dprintf("  hsemPoolTracker         = %#p\n"    , ReadField(hsemPoolTracker));
    pList = ReadField(lePoolTrackerHead.Flink);
    dprintf("  lePoolTrackerHead.Flink = %#p\n"    , pList);
    dprintf("  lePoolTrackerHead.Blink = %#p\n"    , ReadField(lePoolTrackerHead.Blink));
#endif

    //
    // Optionally dump the statistics for each function hooked by verifier.
    //

    if (bStats)
    {
        FIELD_INFO Array = {
            DbgStr("avs"), DbgStr(""),
            0, DBG_DUMP_FIELD_FULL_NAME,
            0, NULL
        };
        FIELD_INFO Entry = {
            DbgStr("avs[0]"), DbgStr(""),
            0, DBG_DUMP_FIELD_FULL_NAME,
            0, NULL
        };

        SYM_DUMP_PARAM Sym = {
            sizeof (SYM_DUMP_PARAM), DbgStr(szVSTATE),
            DBG_DUMP_NO_PRINT, offVState,
            NULL, NULL, NULL,
            1, &Array
        };

        // Read size of the statistics array
        error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

        if (!error)
        {
            // Read size of a single statistics entry
            Sym.Fields = &Entry;

            error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
        }

        if (error || (Entry.size == 0))
        {
            dprintf("\n Unable to get verifier statistics.\n");
            if (error)
            {
                if (error == FIELDS_DID_NOT_MATCH)
                {
                    dprintf(" * " GDIModule() " was not built with VERIFIER_STATISTICS defined.\n");
                }
                else
                {
                    dprintf("  Last error was %s\n.", pszWinDbgError(error));
                }
            }
        }
        else
        {
            char szBuffer[80];                          // Composition buffer for field names
            int ArraySize = Array.size/Entry.size;  // Number of hooked functions
            int i;
            ULONG ulAttempts;
            ULONG ulFailures;

            dprintf("\nVerifier statistics:\n");
            dprintf("Function               Attempts   Failures\n");
            dprintf("---------------------- ---------- ----------\n");

            // Read and print statistics for each hooked function
            for (i = 0; i < ArraySize && !CheckControlC(); i++)
            {
                sprintf(szBuffer, "avs[%d].ulAttempts", i);
                error = GetVSTATEField(szBuffer, ulAttempts);
                if (error) break;

                sprintf(szBuffer, "avs[%d].ulFailures", i);
                error = GetVSTATEField(szBuffer, ulFailures);
                if (error) break;

                dprintf("%s 0x%08lx 0x%08lx\n",
                        ((i < NUM_VER_FUNCS) ?
                         gpszVerifierFuncs[i] :
                         " * Uknown Interface * "),
                        ulAttempts,
                        ulFailures);
            }

            if (i == 0)
            {
                dprintf(" ** No Statistics Available **\n");
            }
            else if (i > NUM_VER_FUNCS)
            {
                dprintf("\n  * - .verifier extension needs updated.\n");
            }

            if (error)
            {
                dprintf(" Last statistic read returned %s.\n", szBuffer, pszWinDbgError(error));
            }
        }
    }

#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    //
    // Optionally dump tracked pool.
    //

    if (bDump)
    {
        if (fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            FIELD_INFO SizeInfo = {DbgStr("ulSize"), NULL, 0, 0, 0, NULL};
            SYM_DUMP_PARAM Sym = {
                sizeof(SYM_DUMP_PARAM), DbgStr(szVERIFIERTRACKHDR),
                DBG_DUMP_NO_PRINT, 0, NULL, NULL, NULL,
                1, &SizeInfo
            };
            BYTE    Tag[4];     // Allocation tag
            ULONG64 Size;       // Size of allocation
            ULONG   SizeSize;
            ULONG   SizeHdr;    // Size of header struct (offset to allocation)

            // Read sizeof of ulSize field
            error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
            SizeSize = (error) ? sizeof(Size) : SizeInfo.size;

            // Read sizeof VERIFIERTRACKHDR structure
            Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
            SizeHdr = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

            dprintf("\nTracked VerifierEngAllocMem allocations\n");
            dprintf("Tag \tSize    %s\tAddr            \n", (SizeSize == sizeof(ULONG)) ? "" : "        ");
            dprintf("----\t--------%s\t----------------\n", (SizeSize == sizeof(ULONG)) ? "" : "--------");

            // Are there any allocations?
            if (pList)
            {
                ULONG64 pListHead = pList;

                // Read until we loop back to the first allocation.
                do
                {
                    // Attempt to read allocation info
                    error = GetFieldValue(pList, szVERIFIERTRACKHDR, "ulTag", Tag);
                    if (error) break;
                    error = GetFieldValue(pList, szVERIFIERTRACKHDR, "ulSize", Size);
                    if (error) break;

                    // Print Tag
                    dprintf("%c%c%c%c", Tag[0], Tag[1], Tag[2], Tag[3]);
                    // Print allocation size
                    if (SizeSize == sizeof(ULONG))
                    {
                        dprintf("\t%08X", (ULONG)Size);
                    }
                    else
                    {
                        dprintf("\t%I64X", Size);
                    }
                    // Print start address of allocation
                    if (SizeHdr != 0)
                    {
                        dprintf("\t%p\n", pList+SizeHdr);
                    }
                    else
                    {
                        dprintf("\t%p+??\n", pList);
                    }

                    // Get next allocation
                    error = GetFieldValue(pList, GDIType(LIST_ENTRY), "FLink", pList);

                } while (pList != pListHead && !error && !CheckControlC());
            }
            else
            {
                dprintf(" ** No tracked allocations.\n");
            }
        }
        else
            dprintf("\nPool tracking not enabled\n");
    }
#endif

    EXIT_API(S_OK);

    //
    // Debugger extension help.
    //

verifier_help:

    dprintf("Usage: verifier [-?h"
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
            "d"
#endif
            "s]\n");
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    dprintf(" d - Dump tracked pool (if pool tracking enabled)\n");
#endif
    dprintf(" s - Dump allocation statistics\n");
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\sources.inc ===
MAJORCOMP=windows
MINORCOMP=gdi

TARGETNAME=efloat
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..\..\inc;                         \
         ..\..\..\dxkernel\inc;             \
         $(WINCORE_PATH)\w32inc;            \
         ..\..\gre;                         \
         $(BASE_INC_PATH);                  \
         $(DRIVERS_INC_PATH);               \
         $(MULTIMEDIA_INC_PATH);            \
         $(DDK_INC_PATH)
         
## Hydra
INCLUDES=$(INCLUDES);                       \
         $(TERMSRV_INC_PATH)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -DLANGPACK -DFE_SB

SOURCES=fontmath.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\fontmath.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontmath.cxx
*
* math stuff needed by ttfd which uses efloat routines
*
* Created: 04-Apr-1992 10:31:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

extern "C"
{
    #define __CPLUSPLUS

    #include <engine.h>
};

#include "engine.hxx"
#include "equad.hxx"

/******************************Public*Routine******************************\
*
* bFDXform, transform an array of points, output in POINTFIX
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bFDXform(
    XFORML    *pxf
  , POINTFIX *pptfxDst
  , POINTL   *pptlSrc
  , SIZE_T    c
    )
{
    BOOL bRet;
    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    bRet = FALSE;

    if ( ef12.bIsZero() && ef21.bIsZero()) {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {

            EFLOAT ef;

            ef = pptlSrc->x;
            ef *= ef11;

            if ( !ef.bEfToFx( pptfxDst->x )) {
                break;
            }
            ef = pptlSrc->y;
            ef *= ef22;
            if ( !ef.bEfToFx( pptfxDst->y )) {
                break;
            }
        }
        bRet = TRUE;
    } else {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {
            EFLOAT efX;
            EFLOAT efY;
            EFLOAT ef1;
            EFLOAT ef2;

            efX = pptlSrc->x;
            efY = pptlSrc->y;

            ef1  = efX;
            ef1 *= ef11;
            ef2  = efY;
            ef2 *= ef21;
            ef2 += ef1;

            if ( !ef2.bEfToFx( pptfxDst->x )) {
                break;
            }

            ef1  = efX;
            ef1 *= ef12;
            ef2  = efY;
            ef2 *= ef22;
            ef2 += ef1;

            if ( !ef2.bEfToFx( pptfxDst->y )) {
                break;
            }
        }
        bRet = TRUE;
    }
    return( bRet );
}

/******************************Public*Routine******************************\
*
* bXformUnitVector
*
* xform vector by pfdxo, compute the unit vector of the transformed
* vector and the norm of the transformed vector. Norm and the transformed
* vector are multiplied by 16 so that when converting to long the result
* will acutally be a 28.4 fix
*
* Effects:
*
* Warnings:
*
* History:
*  01-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bXformUnitVector(
      POINTL *pptl           // IN  incoming unit vector
 ,    XFORML *pxf            // IN  xform to use
 , PVECTORFL  pvtflXformed   // OUT xform of the incoming unit vector
 ,    POINTE *ppteUnit       // OUT *pptqXormed/|*pptqXormed|, POINTE
 ,  EPOINTQF *pptqUnit       // OUT the same as pteUnit, diff format
 ,    EFLOAT *pefNorm        // OUT |*pptqXormed|
    )
{
    EFLOAT efX_;
    EFLOAT efY_;
    BOOL b = TRUE;

    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;
    EFLOAT efX;
    EFLOAT efY;

    //
    // Convert longs to FIX point
    //

    efX = 16 * pptl->x;
    efY = 16 * pptl->y;

    //
    // Convert the matrix elements from FLOAT to EFLOAT
    //

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    //
    // Transform the vector and put the result in efX_ and efY_
    //

    if ( ef12.bIsZero() && ef21.bIsZero() ) {
        efX_  = efX;
        efX_ *= ef11;
        efY_  = efY;
        efY_ *= ef22;
    } else {
        EFLOAT ef;

        efX_  = efX;
        efX_ *= ef11;
        ef    = efY;
        ef   *= ef21;
        efX_ += ef;

        ef    = efX;
        ef   *= ef12;
        efY_  = efY;
        efY_ *= ef22;
        efY_ += ef;
    }

    //
    // Record the results
    //

    pvtflXformed->x = efX_;
    pvtflXformed->y = efY_;

    // get the norm

    efX_ *= efX_;
    efY_ *= efY_;
    efX_ += efY_;
    efX_.vSqrt();

    *pefNorm = efX_;

    // make a unit vector out of eptfl

    EVECTORFL vtfl;

    vtfl.x.eqDiv(pvtflXformed->x,*pefNorm);
    vtfl.y.eqDiv(pvtflXformed->y,*pefNorm);

    vtfl.x.vEfToF(ppteUnit->x);
    vtfl.y.vEfToF(ppteUnit->y);

    // compute this same quantity in POINTQF format if requasted to do so:

    if (pptqUnit != (EPOINTQF *)NULL) {
        vtfl.x.vTimes16();
        vtfl.y.vTimes16();

    // convert to 28.36 format. The incoming vector is already
    // multliplied by 16 to ensure that the result is in the 28.36

        *pptqUnit = vtfl;
    }

    return b;
}

/******************************Public*Routine******************************\
*
* vLTimesVtfl
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
EPOINTQF  *pptq
)
{
    EVECTORFL  vtfl;
    EFLOAT     ef; ef = l;
    vtfl.x.eqMul(pvtfl->x,ef);
    vtfl.y.eqMul(pvtfl->y,ef);

// convert to 28.36 format. The incoming vector will already have been
// multliplied by 16 to ensure that the result is in the 28.36

    *pptq = vtfl;
}

/******************************Public*Routine******************************\
*
* fxLTimesEf
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" FIX  fxLTimesEf
(
EFLOAT *pef,
LONG    l
)
{
// *pef is a norm, already multiplied by 16 to ensure that the result
// is in 28.4 format

    l = lCvt((*pef), l);
    return (FIX)l;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vLToE
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

extern "C" VOID vLToE(FLOATL *pe, LONG l)
{
    EFLOAT ef;
    ef = l;
    ef.vEfToF(*pe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


SRCBASE=$(WINCORE_PATH)

PUBLICINCS=

TARGET_H_DIRECTORY=$(TARGET_DIRECTORY)

PRIVATEINCS= $(NTGDI_PATH)\gre\hmgr.h                \
             $(NTGDI_PATH)\gre\patblt.hxx            \
             $(NTGDI_PATH)\gre\xformobj.hxx          \
             $(NTGDI_PATH)\gre\engine.hxx            \
             $(NTGDI_PATH)\gre\epointfl.hxx          \
             $(NTGDI_PATH)\gre\rfntobj.hxx           \
             $(NTGDI_PATH)\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx

$(O)\geninc.cxx:                                          \
		       ..\..\gre\$(TARGET_DIRECTORY)\geninc.m4              \
		       ..\..\gre\$(TARGET_H_DIRECTORY)\geninc.m4
    set PASS0ONLY=
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) -DNTGDI_PATH=$(NTGDI_PATH) < ..\..\gre\$(TARGET_DIRECTORY)\geninc.m4 \
                            > $@

$(O)\gdi$(TARGET_DIRECTORY).$(ASM_INCLUDE_SUFFIX):			  \
		       $(O)\geninc.cxx                                    \
		       $(PUBLICINCS)					  \
		       $(PRIVATEINCS)					  \
		       $(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
    nmake $(O)\geninc.obj USE_MSVCRT=1 NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx $(O)\geninc.obj -s$(ASM_INCLUDE_SUFFIX) -o$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\kdexts2\viewer.cxx ===
/******************************Module*Header*******************************\
* Module Name: viewer.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#include <tchar.h>

LRESULT CALLBACK ViewerWndProc(HWND, UINT, WPARAM, LPARAM);


typedef struct {
    HWND            hViewerWnd;     // To be set by created thread
    PDEBUG_CLIENT   Client;
    PSURF_INFO      SurfInfo;
} ViewerThreadParams;

DWORD WINAPI ViewerThread(ViewerThreadParams *);

const _TCHAR    szClassName[] = _T("KD GDI Viewer");
const _TCHAR    szWindowName[] = _T("KD GDI Viewer");
ATOM            gViewerAtom;
HBRUSH          ghbrWhite;
HPEN            ghBorderPen;

const LONG DEFAULT_SCALE = 2;

class ViewerManager
{
public:
    ViewerManager(ULONG GrowLength = 4)
    {
        BeingDestroyed = FALSE;
        Wnds = 0;
        MaxWnds = 0;
        phWndList = NULL;
        GrowLen = (GrowLength == 0) ? 4 : GrowLength;
        __try {
            InitializeCriticalSection(&CritSect);
            CritOk = TRUE;
            Grow();
        }
        __except (STATUS_NO_MEMORY) {
            CritOk = FALSE;
        }
    }

    ~ViewerManager()
    {
        if (CritOk) EnterCriticalSection(&CritSect);
        BeingDestroyed = TRUE;
        if (CritOk) LeaveCriticalSection(&CritSect);

        DestroyAll();
        // If we have Wnds left at this point all of them
        // are now tracked as threads.  Wait for each
        // thread to completely finish.
        if (Wnds)
        {
            DWORD WaitReturn;
            DbgPrint("Waiting for remaining %lu threads...\n", Wnds);
            WaitReturn = WaitForMultipleObjects(Wnds, (HANDLE *)phWndList, TRUE, INFINITE);
            DbgPrint("WaitForMultipleObjects returned %lx.\n", WaitReturn);
            while (Wnds-- > 0)
            {
                CloseHandle(phWndList[Wnds]);
                DbgPrint("ViewerManager::~ViewerManager calling ExtRelease().\n");
                ExtRelease();
            }
        }

        HeapFree(hHeap, 0, phWndList);
        if (CritOk) DeleteCriticalSection(&CritSect);
    }

    BOOL Grow();

    BOOL Destroy(HWND);

    void DestroyAll()
    {
        ULONG i = Wnds;
        while (i-- > 0)
        {
            Destroy(phWndList[i]);
        }
    }

private:
    ULONG   Wnds;
    ULONG   MaxWnds;
    HWND   *phWndList;
    HANDLE  hHeap;
    ULONG   GrowLen;
    BOOL    BeingDestroyed;
    BOOL    CritOk;
    CRITICAL_SECTION    CritSect;

    friend DWORD WINAPI ViewerThread(ViewerThreadParams *);

    BOOL Track(HWND hWnd)
    {
        if (this == NULL || !CritOk) return FALSE;

        BOOL bTracked = FALSE;

        EnterCriticalSection(&CritSect);

        if (!BeingDestroyed &&
            ((Wnds < MaxWnds) || Grow()))
        {
            DbgPrint("ViewerManager: Tracking %lx.\n", hWnd);
            phWndList[Wnds++] = hWnd;
            bTracked = TRUE;
        }

        LeaveCriticalSection(&CritSect);

        return bTracked;
    }

    BOOL Untrack(HWND hWnd)
    {
        if (this == NULL || !CritOk) return FALSE;

        BOOL    bFound = FALSE;

        EnterCriticalSection(&CritSect);

        ULONG i = Wnds;

        while (i-- > 0)
        {
            if (phWndList[i] == hWnd)
            {
                DbgPrint("ViewerManager: No longer tracking %lx.\n", hWnd);
                phWndList[i] = phWndList[--Wnds];
                phWndList[Wnds] = NULL;
                bFound = TRUE;
                if (!BeingDestroyed)
                {
                    DbgPrint("ViewerManager::Untrack calling ExtRelease().\n");
                    ExtRelease();
                }
                break;
            }
        }

        if (!bFound)
            DbgPrint("ViewerManager::Untrack didn't find %lx.\n", hWnd);

        LeaveCriticalSection(&CritSect);

        return bFound;
    }

};

BOOL ViewerManager::Grow()
{
    if (MaxWnds > 0)
    {
        HWND *pNewList = (HWND *)HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, phWndList, (MaxWnds + GrowLen)*sizeof(HWND));

        if (pNewList != NULL)
        {
            phWndList = pNewList;
            MaxWnds += GrowLen;
            return TRUE;
        }
    }
    else
    {
        hHeap = GetProcessHeap();

        if (hHeap)
        {
            phWndList = (HWND *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, GrowLen*sizeof(HWND));
            if (phWndList != NULL)
            {
                MaxWnds = GrowLen;
                return TRUE;
            }
        }
    }

    DbgPrint("ViewerManager::Grow FAILED!\n");
    return FALSE;
}


BOOL ViewerManager::Destroy(HWND hWnd)
{
    ULONG i = Wnds;

    DbgPrint("Looking for window %lx in %lu entries.\n", hWnd, i);

    while (i-- > 0)
    {
        if (phWndList[i] == hWnd)
        {
            DbgPrint("Destroying window %lx at entry %lu.\n", hWnd, i);
            DWORD   ThreadID = GetWindowThreadProcessId(hWnd, NULL);
            HANDLE  hThread;
            if (hThread = OSCompat_OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION, FALSE, ThreadID))
            {
                BOOL    bCloseHandle = TRUE;

                DWORD   ExitCode = STILL_ACTIVE;
                while (!PostMessage(hWnd, WM_DESTROY, 0, 0))
                {
                    DbgPrint("Waiting on post msg to %lx...\n", hWnd);
                    Sleep(10);
                    if (GetExitCodeThread(hThread, &ExitCode) &&
                        ExitCode != STILL_ACTIVE)
                    {
                        break;
                    }
                }

                // Check thread exit status
                if (ExitCode == STILL_ACTIVE)
                {
                    if (!GetExitCodeThread(hThread, &ExitCode))
                    {
                        DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                    }
                }

                // Give the thread a chance to exit
                if (ExitCode == STILL_ACTIVE)
                {
                    DWORD WaitReturn;

                    DbgPrint("Waiting for hThread: %lx, ThreadID: %lx, hWnd: %lx.\n", hThread, ThreadID, hWnd);

                    if (WAIT_OBJECT_0 != (WaitReturn = WaitForSingleObject(hThread, 100)))
                    {
                        DbgPrint("WaitForSingleObject returned %lx.\n", WaitReturn);
                        // If it hasn't exited and it called untrack
                        // to remove the hWnd we're concerned with,
                        // replace it with the thread handle so we may
                        // wait on it later.
                        EnterCriticalSection(&CritSect);
                        if (phWndList[i] == hWnd)
                        {
                            phWndList[i] = (HWND)hThread;
                            bCloseHandle = FALSE;
                        }
                        LeaveCriticalSection(&CritSect);
                    }
                }

                if (bCloseHandle)
                {
                    // If the thread was still active, but the track entry
                    // has been removed, we have to wait for the thread to
                    // completely terminate.
                    if (ExitCode == STILL_ACTIVE)
                    {
                        DbgPrint("Inifinitely waiting for thread %lx to complete.\n", ThreadID);
                        WaitForSingleObject(hThread, INFINITE);

                        if (!GetExitCodeThread(hThread, &ExitCode))
                        {
                            DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                        }
                        else
                        {
                            DbgPrint("Thread exit code was %lx.\n", ExitCode);
                        }
                    }

                    DbgPrint("Closing hThread: %lx\n", hThread);
                    CloseHandle(hThread);

                    if (BeingDestroyed)
                    {
                        DbgPrint("ViewerManager::Destroy calling ExtRelease().\n");
                        ExtRelease();
                    }
                }
            }
            else
            {
                // This really hurts.
                // We have a tracked window, but we can't get 
                // information on it's thread, we have to stop
                // tracking it.

                DbgPrint("ViewerManager::Destroy: OpenThread returned error %lx!\n", GetLastError());

                EnterCriticalSection(&CritSect);
                if (phWndList[i] == hWnd)
                {
                    phWndList[i] = phWndList[--Wnds];
                    phWndList[Wnds] = NULL;
                }
                LeaveCriticalSection(&CritSect);
            }

            return TRUE;
        }
    }
    return FALSE;
}


ViewerManager *ViewerMgr;

void ViewerInit()
{
    if (ViewerMgr == NULL)
    {
        ViewerMgr = new ViewerManager;

        if (ViewerMgr == NULL) return;
    }

    if (! ghbrWhite)
    {
        DbgPrint("ViewerInit: Creating white brush\n");
        ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));
        DbgPrint("ViewerInit: Created brush %lx\n", ghbrWhite);
    }

    if (! ghBorderPen)
    {
        DbgPrint("ViewerInit: Creating redish pen\n");
        ghBorderPen = CreatePen(PS_SOLID, 1, RGB(0xF0, 0x00, 0x3F));
        DbgPrint("ViewerInit: Created pen %lx\n", ghBorderPen);
    }

    if (! gViewerAtom)
    {
        WNDCLASSEX  wcex;

        DbgPrint("ViewerInit: Registering Class\n");
        DbgPrint("ViewerInit: ghDllInst = %lx\n", ghDllInst);

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_VREDRAW | CS_HREDRAW;
        wcex.lpfnWndProc = ViewerWndProc;
        wcex.cbClsExtra = 0;
        wcex.cbWndExtra = 0;
        wcex.hInstance = ghDllInst;
        wcex.hIcon = NULL;
        wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = (HBRUSH)( COLOR_WINDOW+1 );
        wcex.lpszMenuName = NULL;
        wcex.lpszClassName = szClassName;
        wcex.hIconSm = NULL;

        gViewerAtom = RegisterClassEx( &wcex );
    }
}

void ViewerExit()
{
    if (ViewerMgr != NULL)
    {
        delete ViewerMgr;
        ViewerMgr = NULL;
    }

    if (gViewerAtom)
    {
        DbgPrint("ViewerExit: Unregistering Class\n");
        UnregisterClass((LPCSTR)gViewerAtom, 0);
        gViewerAtom = 0;
    }

    if (ghBorderPen)
    {
        DbgPrint("ViewerExit: Deleting border pen\n");
        DeleteObject(ghBorderPen);
        ghBorderPen = NULL;
    }

    if (ghbrWhite)
    {
        DbgPrint("ViewerInit: Deleting white brush\n");
        DeleteObject(ghbrWhite);
        ghbrWhite = NULL;
    }
}


BOOL
CALLBACK
ViewerWndEnumProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    HWND    *phWndParent = (HWND *)lParam;

    DbgPrint("Found hWnd %lx.\n", hWnd);

    if (*phWndParent == NULL)
    {
        *phWndParent = hWnd;
    }

    return TRUE;
}


DWORD
WINAPI
ViewerThread(
    ViewerThreadParams *Params
    )
{
    HWND    hWnd;
    BOOL    bGetMsg;
    MSG     msg;
    _TCHAR  ViewerWndName[sizeof(szWindowName) + sizeof(Params->SurfInfo->SurfName) + 20];
    _TCHAR *pszName = Params->SurfInfo->SurfName;

    if (!pszName[0]) pszName = _T("UNAMED");

    _stprintf(ViewerWndName, "%s: %s (%ldx%ldx%hubpp)", szWindowName, pszName,
              Params->SurfInfo->Width,
              Params->SurfInfo->Height,
              Params->SurfInfo->BitsPixel);


    hWnd = CreateWindowEx(WS_EX_LEFT,
                          (LPCSTR)gViewerAtom,
                          ViewerWndName,
                          WS_OVERLAPPEDWINDOW,// | WS_HSCROLL | WS_VSCROLL,
                          0,
                          0,
                          Params->SurfInfo->Width*DEFAULT_SCALE+10,//32,
                          Params->SurfInfo->Height*DEFAULT_SCALE+29,//48,
                          NULL,
                          NULL,
                          ghDllInst,
                          Params->SurfInfo  // lParam passed to WM_CREATE handler
                       );

    if (hWnd)
    {
        ViewerMgr->Track(hWnd);

        Params->hViewerWnd = hWnd;      // Params may no longer be valid.

        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        while( (bGetMsg = GetMessage(&msg, NULL, 0, 0 )) != 0 )
        {
            if (bGetMsg == -1)
            {
                DbgPrint("ViewerThread exiting due to GetMessage error 0x%lx.\n",
                         GetLastError());
                break;
            }
            else
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        DbgPrint("ViewerThread exiting properly.\n");

        ViewerMgr->Untrack(hWnd);
    }
    else
    {
        DbgPrint("CreateWindow returned error %lx.\n", GetLastError());

        msg.wParam = -1;
    }

    DbgPrint("ViewerThread calling ExitThread().\n");

    ExitThread((DWORD)msg.wParam);
}


DWORD
CreateViewer(
    PDEBUG_CLIENT   Client,
    PSURF_INFO      SurfInfo
    )
{
    ViewerThreadParams  NewThreadParams = { NULL, Client, SurfInfo };
    HRESULT Status;

    // Reference Debug Client for ViewerThread 
    // since dbgeng/dbghelp aren't thread safe.
    // ViewerManager will release client in a safe manner.
    if ((Status = ExtQuery(Client)) != S_OK) return 0;

    HWND hWndParent = NULL;
    EnumThreadWindows(GetCurrentThreadId(), (WNDENUMPROC)ViewerWndEnumProc, (LPARAM)&hWndParent);

    HANDLE  hThread;
    DWORD   ThreadID = 0;
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)ViewerThread,
                           &NewThreadParams,
                           0,
                           &ThreadID);

    if (hThread)
    {
        while (NewThreadParams.hViewerWnd == NULL)
        {
            DWORD ExitCode = 0;
            if (!GetExitCodeThread(hThread, &ExitCode))
                DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
            if (ExitCode != STILL_ACTIVE)
            {
                ThreadID = 0;
                break;
            }

            SleepEx(10, TRUE);
        }

        CloseHandle(hThread);
    }

    if (ThreadID == 0)
    {
        ExtRelease();
    }

    return ThreadID;
}


// DelPropProc is a callback function 
// that deletes a window property. 
 
BOOL CALLBACK DelPropProc( 
    HWND hwndSubclass,  // handle of window with property 
    LPCSTR lpszString,  // property string or atom 
    HANDLE hData)       // data handle 
{ 
    RemoveProp(hwndSubclass, lpszString); 
 
    return TRUE; 
}


LRESULT
CALLBACK
ViewerWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
//    DbgPrint("ViewerWndProc(%lx, %lx, , )\n", hWnd, msg);

    switch( msg )
    {
        case WM_CREATE:
            {
                LPCREATESTRUCT  CreateStruct = (LPCREATESTRUCT)lParam;
                PSURF_INFO SurfInfo = (PSURF_INFO) CreateStruct->lpCreateParams;

                DbgPrint("ViewerWndProc: WM_CREATE\n");

                if (SurfInfo)
                {
                    SetProp(hWnd, "hBitmap", SurfInfo->hBitmap);
                    SetProp(hWnd, "xOrigin", LongToHandle(SurfInfo->xOrigin));
                    SetProp(hWnd, "yOrigin", LongToHandle(SurfInfo->yOrigin));
                    SetProp(hWnd, "Width", LongToHandle(SurfInfo->Width));
                    SetProp(hWnd, "Height", LongToHandle(SurfInfo->Height));
                    SetProp(hWnd, "BPP", LongToHandle(SurfInfo->BitsPixel));
                    SetProp(hWnd, "Scale", LongToHandle(DEFAULT_SCALE));
//                    SetProp(hWnd, "", SurfInfo->);
                }
                else
                {
                    ExtErr("ViewerWindow created with NULL PSURF_INFO.\n");
                    return -1;
                }
            }
            return 0;

        case WM_KEYDOWN:
            if (wParam == VK_DOWN || wParam == VK_UP)
            {
                LONG Scale = HandleToLong(GetProp(hWnd, "Scale"));
                if (wParam == VK_DOWN)
                {
                    if (Scale > 1)
                    {
                        SetProp(hWnd, "Scale", LongToHandle((Scale-1)));
                        InvalidateRect(hWnd, NULL, TRUE);
                    }
                }
                else
                {
                    if (Scale < 16)
                    {
                        SetProp(hWnd, "Scale", LongToHandle((Scale+1)));
                        InvalidateRect(hWnd, NULL, TRUE);
                    }
                }
                return 0;
            }
            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC hdc;
                HBITMAP hBitmapOrg;
                HBRUSH  hBrushOrg;
                HPEN    hPenOrg;

                BeginPaint(hWnd, &ps);

                hdc = CreateCompatibleDC(ps.hdc);
                hBitmapOrg = (HBITMAP)SelectObject(hdc, (HBITMAP)GetProp(hWnd, "hBitmap"));
                if (hBitmapOrg == NULL)
                {
                    DbgPrint("Error from SelectObject(, HBITMAP): %lx\n", GetLastError());
                }
                hBrushOrg = (HBRUSH)SelectObject(ps.hdc, ghbrWhite);
                hPenOrg = (HPEN)SelectObject(ps.hdc, ghBorderPen);
                LONG xOrigin = HandleToLong(GetProp(hWnd, "xOrigin"));
                LONG yOrigin = HandleToLong(GetProp(hWnd, "yOrigin"));
                LONG Width = HandleToLong(GetProp(hWnd, "Width"));
                LONG Height = HandleToLong(GetProp(hWnd, "Height"));
                LONG Scale = HandleToLong(GetProp(hWnd, "Scale"));
                Rectangle(ps.hdc, 0, 0, Width*Scale+2, Height*Scale+2);
                if (!StretchBlt(ps.hdc, 1, 1, Width*Scale, Height*Scale, hdc, xOrigin, yOrigin, Width, Height, SRCCOPY))
                {
                    DbgPrint("Error from StrectBlt): %lx\n", GetLastError());
                }
                SelectObject(ps.hdc, hPenOrg);
                SelectObject(ps.hdc, hBrushOrg);
                SelectObject(hdc, hBitmapOrg);
                DeleteDC(hdc);

                EndPaint(hWnd, &ps);
            }
            return DefWindowProc( hWnd, msg, wParam, lParam );

        case WM_DESTROY:

            DbgPrint("ViewerWndProc: WM_DESTROY\n");

            DeleteObject((HBITMAP)GetProp(hWnd, "hBitmap"));

            EnumPropsEx(hWnd, (PROPENUMPROCEX)DelPropProc, NULL); 

            PostQuitMessage(0);
            break;

        default:
//            DbgPrint("ViewerWndProc: unhandled msg %lx\n", msg);
            break;
    }

    return DefWindowProc( hWnd, msg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\wow6432\i386\geninc.cxx ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\amd64\math.cxx ===
/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\i386\xform.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: xform.asm                                                ;
;                                                                       ;
; The assembly version of xformer.cxx.  Contains the transform related  ;
; calculation routines.  This is the NT version of ChuckWh's            ;
; xformers.asm for PM.                                                  ;
;                                                                       ;
; Created: 13-Nov-1990 13:42:27                                         ;
; Author: Wendy Wu [wendywu]                                            ;
;                                                                       ;
; Copyright (c) 1990 Microsoft Corporation                              ;
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        .list

        .code

EXTRNP  mulff,0
EXTRNP  addff,0

;-----------------------------------------------------------------------;
; MULEFBYDWORD
;
; Multiply an EFLOAT number by a 32-bit number.  The result is kept in
; the FIX type.  If the 32-bit number is a LONG integer, the EFLOAT is
; a "FIX number in EFLOAT type".  If the 32-bit is a FIX number, the
; EFLOAT is a "LONG integer in EFLOAT type".  Note that this macro can
; be invoked with eax and edx exchanged with the same result.
;
; Entry:
;       EDX = LONG integer      or             EDX = FIX number
;       EAX = EFLOAT.lMant                     EAX = EFLOAT.lMant
;       ECX = EFLOAT.lExp(already added by 4)  ECX = EFLOAT.lExp
; Returns:
;       EAX = product in FIX type
;
; Registers Destroyed:
;       ECX,EDX
;-----------------------------------------------------------------------;

; CR!!! If we can have a tight loop to check for overflow before we
; CR!!! do the conversion, it might be faster.  Not sure which way to
; CR!!! go.  Will have to decide at performance tuning time.

MULEFBYDWORD MACRO  err_out, NoRound
        LOCAL   shift31orfewer
	LOCAL	done
        neg     ecx
        imul    edx                 ; EDX.EAX
        add     ecx,32              ; If we shift EDX.EAX right by 32-exp
                                    ; then we get the final result in EAX

        jz 	short done	    ; no shift, we're done.
        jc 	short shift31orfewer
        js      err_out             ; overflow if 32-exp < 0

; we are here if ecx >= 32.  return 0 if ecx > 62.

        cmp     ecx,63		    
        jb      @F
        xor     eax,eax		    ; shift by too much, result will be zero
	jmp	short done
@@:
        shrd	eax, edx, 31
	sar	edx, 31
	sub	ecx, 31

shift31orfewer:                            

        shrd    eax,edx,cl          ; shift edx:eax right by cl bits
    IFB <NoRound>
	adc	eax, 0		    ; and round appropriately
	jo	err_out		    ; overflow?
    ENDIF

        sar     edx,cl              ; check for overflow
        adc     edx,0
	jnz	err_out

done:
ENDM

;-----------------------------Public-Routine----------------------------;
; lCvt (ef,ll)                                                          ;
;                                                                       ;
; A simple routine to scale a long by an EFLOAT.                        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
;   EFLOAT ef       The floating point multiplier.                      ;
;   LONG   ll       The long to multiply.                               ;
;                                                                       ;
; Entry:                                                                ;
;       None                                                            ;
; Returns:                                                              ;
;       EAX = product                                                   ;
; Error Returns:                                                        ;
;       None.                                                           ;
; Registers Destroyed:                                                  ;
;       ECX,EDX                                                         ;
; Calls:                                                                ;
;       None                                                            ;
; History:                                                              ;
;  Wed 26-May-1993 00:00:00 -by- Paul Butzi and Charles Whitmer
; changed to call MULEFBYDWORD, which we recently fixed
;
;  Wed 18-Mar-1992 07:31:13 -by- Charles Whitmer [chuckwh]              ;
; Added the simple shifting case.  I think we can call this case faster ;
; than we could recognize in C that a shift is required.                ;
;                                                                       ;
;  Thu 12-Mar-1992 20:35:03 -by- Charles Whitmer [chuckwh]              ;
; Created by pirating MULEFBYDWORD.                                     ;
;-----------------------------------------------------------------------;

lCvt_frame struc
pRet    dd      ?                   ; Return address
ef      db      size EFLOAT dup (?) ; EFLOAT multiplier
ll      dd      ?                   ; LONG multiplier
lCvt_frame ends

cvtargs equ (size lCvt_frame / 4 - 1)

cPublicProc lCvt,cvtargs
        mov     eax,dword ptr [esp].ef.ef_lMant
        mov     ecx,dword ptr [esp].ef.ef_lExp
	mov	edx, dword ptr [esp].ll
	MULEFBYDWORD lCvtNext
lCvtNext:
        stdRET  lCvt
stdENDP lCvt


;-----------------------------Public-Routine----------------------------;
; bCvtPts1
;
;   Apply the given transform matrix to a list of points.
;
; Arguments:
;       pmx       points to the matrix
;       pptl      points to the list of points
;       cptl      number of points in the list
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  17-Dec-1992 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtPts1,3,<        \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pptl:      ptr POINTL,  \
        cptl:      dword        >

        local   fxResult:dword

        mov     esi,pptl
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_FORMAT_LTOFX
        jmp     accelerator_table_pts1[ecx*4]

.errnz (size POINTL) - 8

xform_non_units_ltofx_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

        align   4
xform_non_units_ltofx_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx
        add     eax,8                       ; FXTOLROUND
        sar     eax,4

; compute y'

        mov     edx,[esi].ptl_y             ; get source y
        mov     [esi].ptl_x,eax             ; store x'
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        add     eax,8                       ; FXTOLROUND
        sar     eax,4
        mov     [esi].ptl_y,eax             ; store y'
        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_non_units_lTofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

        align   4
xform_units_ltofx_pts1::
        mov     eax,[ebx].mx_fxDx
        mov     edx,[ebx].mx_fxDy
        add     eax,8                       ; FXTOLROUND
        add     edx,8
        sar     eax,4
        sar     edx,4

        mov     ecx,cptl

; ESI = points to the array of points
; ECX = number of points in the array
; EAX = x translation
; EDX = y translation

        align   4
xform_units_ltofx_loop_pts1:
        add     [esi].ptl_x,eax                 ; x' = x + Dx
        add     [esi].ptl_y,edx                 ; y' = y + Dy
        add     esi,SIZE POINTL

        dec     ecx
        jnz short   xform_units_ltofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

xform_general_ltofx_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

xform_general_ltofx_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx
        add     eax,8                       ; FXTOLROUND
        sar     eax,4

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [esi].ptl_x,eax             ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy
        add     eax,8                       ; FXTOLROUND
        sar     eax,4
        mov     [esi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_general_ltofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

xform_non_units_fxtol_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

        align   4
xform_non_units_fxtol_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx

; compute y'

        mov     edx,[esi].ptl_y             ; get source y
        mov     [esi].ptl_x,eax             ; store x'
        sal     edx,4                       ; LTOFX
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        mov     [esi].ptl_y,eax             ; store y'
        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_non_units_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

        align   4
xform_units_fxtol_pts1::
        mov     eax,[ebx].mx_fxDx
        mov     edx,[ebx].mx_fxDy

        mov     ecx,cptl

; ESI = points to the array of points
; ECX = number of points in the array
; EAX = x translation
; EDX = y translation

        align   4
xform_units_fxtol_loop_pts1:
        add     [esi].ptl_x,eax                 ; x' = x + Dx
        add     [esi].ptl_y,edx                 ; y' = y + Dy
        add     esi,SIZE POINTL

        dec     ecx
        jnz short   xform_units_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1


xform_general_fxtol_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

xform_general_fxtol_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [esi].ptl_x,eax             ; store x'

        sal     edx,4                       ; LTOFX
        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy
        mov     [esi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_general_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

overflow_pts1:
        xor     eax,eax
        stdRET  bCvtPts1


ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts1  label   dword                   ;   ltofx    -y   units scale
        dd      offset FLAT:xform_general_fxtol_pts1    ;     0       0     0     0
        dd      offset FLAT:xform_non_units_fxtol_pts1  ;     0       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     0
        dd      offset FLAT:xform_units_fxtol_pts1      ;     0       0     1     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     0     0
        dd      offset FLAT:xform_rip_pts               ;     0       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     0
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     1

        dd      offset FLAT:xform_general_ltofx_pts1    ;     1       0     0     0
        dd      offset FLAT:xform_non_units_ltofx_pts1  ;     1       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     1       0     1     0
        dd      offset FLAT:xform_units_ltofx_pts1      ;     1       0     1     1
        dd      offset FLAT:xform_rip_pts               ;     1       1     0     0
        dd      offset FLAT:xform_rip_pts               ;     1       1     0     1
        dd      offset FLAT:xform_rip_pts               ;     1       1     1     0
        dd      offset FLAT:xform_rip_pts               ;     1       1     1     1

endif;  DOS_PLATFORM

stdENDP bCvtPts1


ifndef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts   label   dword       ;   ltofx    -y   units scale
        dd      xform_general_pts           ;     0       0     0     0
        dd      xform_non_units_pts         ;     0       0     0     1
        dd      xform_rip_pts               ;     0       0     1     0
        dd      xform_units_fxtol_pts       ;     0       0     1     1
        dd      xform_rip_pts               ;     0       1     0     0
        dd      xform_rip_pts               ;     0       1     0     1
        dd      xform_rip_pts               ;     0       1     1     0
        dd      xform_units_neg_y_fxtol_pts ;     0       1     1     1

        dd      xform_general_pts           ;     1       0     0     0
        dd      xform_non_units_pts         ;     1       0     0     1
        dd      xform_rip_pts               ;     1       0     1     0
        dd      xform_units_ltofx_pts       ;     1       0     1     1
        dd      xform_rip_pts               ;     1       1     0     0
        dd      xform_rip_pts               ;     1       1     0     1
        dd      xform_rip_pts               ;     1       1     1     0
        dd      xform_units_neg_y_ltofx_pts ;     1       1     1     1

accelerator_table_pts1  label   dword       ;   ltofx    -y   units scale
        dd      xform_general_fxtol_pts1    ;     0       x     0     0
        dd      xform_non_units_fxtol_pts1  ;     0       x     0     1
        dd      xform_rip_pts               ;     0       x     1     0
        dd      xform_units_fxtol_pts1      ;     0       x     1     1
        dd      xform_rip_pts               ;     0       x     0     0
        dd      xform_rip_pts               ;     0       x     0     1
        dd      xform_rip_pts               ;     0       x     1     0
        dd      xform_rip_pts               ;     0       x     1     1

        dd      xform_general_ltofx_pts1    ;     1       x     0     0
        dd      xform_non_units_ltofx_pts1  ;     1       x     0     1
        dd      xform_rip_pts               ;     1       x     1     0
        dd      xform_units_ltofx_pts1      ;     1       x     1     1
        dd      xform_rip_pts               ;     1       x     0     0
        dd      xform_rip_pts               ;     1       x     0     1
        dd      xform_rip_pts               ;     1       x     1     0
        dd      xform_rip_pts               ;     1       x     1     1

accelerator_table_vts   label   dword       ;    -y     units scale
        dd      xform_general_vts           ;     0       0     0
        dd      xform_non_units_vts         ;     0       0     1
        dd      xform_rip_vts               ;     0       1     0
        dd      xform_rip_vts               ;     0       1     1 handled by caller
        dd      xform_rip_vts               ;     1       0     0
        dd      xform_rip_vts               ;     1       0     1
        dd      xform_rip_vts               ;     1       1     0
        dd      xform_units_neg_y_ltofx_vts ;     1       1     1


endif;  DOS_PLATFORM

;-----------------------------Public-Routine----------------------------;
; bCvtPts
;
;   Apply the given transform matrix to a list of points.
;
; Arguments:
;       pmx       points to the matrix
;       pptlSrc   points to the source list of points
;       pptlDst   points to the dest list of points
;       cptl      number of points in the list
;       pptlSrc, pptlDst can both point to the same array of points
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  13-Nov-1990 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtPts,4,<         \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pptlSrc:   ptr POINTL,  \
        pptlDst:   ptr POINTL,  \
        cptl:      dword        >

        local   fxResult      :dword

        mov     esi,pptlSrc
        mov     edi,pptlDst
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_Y_NEG+XFORM_FORMAT_LTOFX
        jmp     accelerator_table_pts[ecx*4]

.errnz (size POINTL) - 8

        align   4
xform_non_units_pts::

; ESI = points to the source array of points
; EDI = points to the destination array of points
; EBX = points to the matrix

        align   4
xform_non_units_loop_pts:

; compute x'

        mov     edx,[esi]                   ; get source x
        add     esi,4
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts           ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

; compute y'

        mov     edx,[esi]                   ; get source y
        add     esi,4
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts           ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     cptl
        jnz     xform_non_units_loop_pts
        mov     eax,1
        stdRET  bCvtPts

xform_rip_pts::
; should RIP here!!!

overflow_pts:
        xor     eax,eax
        stdRET  bCvtPts

        align   4
xform_units_ltofx_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_ltofx_loop_pts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,edx                     ; y' = y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_ltofx_loop_pts
        mov     eax,1
        stdRET  bCvtPts

        align   4
xform_units_neg_y_ltofx_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_neg_y_ltofx_loop_pts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        neg     eax                         ; y' = -y + Dy
        add     eax,edx
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_ltofx_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow1_pts:
        jmp     overflow_pts

        align   4
xform_units_fxtol_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_fxtol_loop_pts:
        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,edx                     ; y' = y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_fxtol_loop_pts
        mov     eax,1
        stdRET  bCvtPts

        align   4
xform_units_neg_y_fxtol_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_neg_y_fxtol_loop_pts:
        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        neg     eax                         ; y' = -y
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,edx                     ; y' = -y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_fxtol_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow2_pts:
        jmp     overflow_pts

xform_general_pts::

; ESI = points to the source array of points
; EDI = points to the dest array of points
; EBX = points to the matrix

xform_general_loop_pts:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow2_pts          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow2_pts          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [edi].ptl_x,eax             ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow3_pts          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow3_pts          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy

        mov     [edi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL
        add     edi,SIZE POINTL

        dec     cptl
        jnz     xform_general_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow3_pts:
        jmp     overflow_pts

ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts   label   dword                   ; ltofx -y units simple
        dd      offset FLAT:xform_general_pts           ;   0    0   0     0
        dd      offset FLAT:xform_non_units_pts         ;   0    0   0     1
        dd      offset FLAT:xform_rip_pts               ;   0    0   1     0
        dd      offset FLAT:xform_units_fxtol_pts       ;   0    0   1     1
        dd      offset FLAT:xform_rip_pts               ;   0    1   0     0
        dd      offset FLAT:xform_rip_pts               ;   0    1   0     1
        dd      offset FLAT:xform_rip_pts               ;   0    1   1     0
        dd      offset FLAT:xform_units_neg_y_fxtol_pts ;   0    1   1     1

        dd      offset FLAT:xform_general_pts           ;   1    0   0     0
        dd      offset FLAT:xform_non_units_pts         ;   1    0   0     1
        dd      offset FLAT:xform_rip_pts               ;   1    0   1     0
        dd      offset FLAT:xform_units_ltofx_pts       ;   1    0   1     1
        dd      offset FLAT:xform_rip_pts               ;   1    1   0     0
        dd      offset FLAT:xform_rip_pts               ;   1    1   0     1
        dd      offset FLAT:xform_rip_pts               ;   1    1   1     0
        dd      offset FLAT:xform_units_neg_y_ltofx_pts ;   1    1   1     1
endif;  DOS_PLATFORM

stdENDP bCvtPts

;-----------------------------Public-Routine----------------------------;
; bCvtVts
;
;   Apply the given transform matrix to a list of vectors.
;
; Arguments:
;       pmx       points to the matrix
;       pvtlSrc   points to the source list of vectors
;       pvtlDst   points to the dest list of vectors
;       cvtl      number of vectors in the list
;       pvtlSrc, pvtlDst can both point to the same array of vectors
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtVts,4,<         \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pvtlSrc:   ptr VECTORL, \
        pvtlDst:   ptr VECTORL, \
        cvtl:      dword        >

        local   fxResult      :dword

        mov     esi,pvtlSrc
        mov     edi,pvtlDst
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_Y_NEG
        jmp     accelerator_table_vts[ecx*4]

.errnz (size POINTL) - 8

        align   4
xform_non_units_vts::

; ESI = points to the source array of vectors
; EDI = points to the destination array of vectors
; EBX = points to the matrix

xform_non_units_loop_vts:

        mov     edx,[esi]                   ; get source x
        add     esi,4
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_vts           ; x*M11
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     edx,[esi]                   ; get source y
        add     esi,4
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_vts           ; y*M22
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     cvtl
        jnz     xform_non_units_loop_vts
        mov     eax,1
        stdRET  bCvtVts

xform_rip_vts::
; should RIP here!!!

overflow_vts:
        xor     eax,eax
        stdRET  bCvtVts

        align   4
xform_units_neg_y_ltofx_vts::
        mov     ecx,cvtl

; ESI = points to the source array of vectors
; EDI = points to the destination array of vectors
; ECX = number of points in the array

        align   4
xform_units_neg_y_ltofx_loop_vts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        neg     eax                         ; y' = -y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_ltofx_loop_vts
        mov     eax,1
        stdRET  bCvtVts

overflow1_vts:
        jmp     overflow_vts

xform_general_vts::

; ESI = points to the source array of vectors
; EDI = points to the dest array of vectors
; EBX = points to the matrix

xform_general_loop_vts:

; compute x'

        mov     edx,[esi].vl_x              ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow1_vts          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].vl_y              ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow1_vts          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21

; compute y'

        mov     edx,[esi].vl_x              ; get source x
        mov     [edi].vl_x,eax              ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow2_vts          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].vl_y              ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow2_vts          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22

        mov     [edi].vl_y,eax              ; store y'

        add     esi,SIZE VECTORL
        add     edi,SIZE VECTORL

        dec     cvtl
        jnz     xform_general_loop_vts
        mov     eax,1
        stdRET  bCvtVts

overflow2_vts:
        jmp     overflow_vts

ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4

accelerator_table_vts   label   dword                   ;   -y   units simple
        dd      offset FLAT:xform_general_vts           ;    0     0     0
        dd      offset FLAT:xform_non_units_vts         ;    0     0     1
        dd      offset FLAT:xform_rip_vts               ;    0     1     0
        dd      offset FLAT:xform_rip_vts               ;    0     1     1
        dd      offset FLAT:xform_rip_vts               ;    1     0     0
        dd      offset FLAT:xform_rip_vts               ;    1     0     1
        dd      offset FLAT:xform_rip_vts               ;    1     1     0
        dd      offset FLAT:xform_units_neg_y_ltofx_vts ;    1     1     1
endif;  DOS_PLATFORM

stdENDP bCvtVts

;-----------------------------Public-Routine----------------------------;
; bCvtVts_FlToFl
;
;   Apply the given transform matrix to a list of vectors.  The source
;   and dest vectors are of VECTORFL types.
;   The coefficients of the matrix are "LONG integers in EFLOAT type".
;
; Arguments:
;       pmx       points to the matrix
;       pvtflSrc  points to the source list of vectors
;       pvtflDest points to the dest list of vectors
;       cvtl      number of vectors in the list
;
;       ptflSrc, ptflDest can both point to the same array of vectors
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       mulff, addff
; History:
;  13-Nov-1990 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtVts_FlToFl,4,<         \
        uses       ebx esi edi,        \
        pmx:       ptr MATRIX,         \
        pvtflSrc:  ptr VECTORFL,       \
        pvtflDest: ptr VECTORFL,       \
        cvtl:      dword               >

        local   lMantResult   :dword
        local   lExpResult    :dword

        mov     esi,pvtflSrc
        mov     edi,pmx

; ESI -> source array of vectors
; EDI -> matrix

convert_vectors_loop:

; compute x'

        mov     edx,[esi].vfl_x.ef_lMant    ; get x
        mov     ebx,[esi].vfl_x.ef_lExp

        mov     eax,[edi].mx_efM11.ef_lMant
        mov     ecx,[edi].mx_efM11.ef_lExp
        stdCall mulff                       ; x * M11

        mov     lMantResult,eax
        mov     lExpResult,ecx

        mov     edx,[esi].vfl_y.ef_lMant    ; get y
        mov     ebx,[esi].vfl_y.ef_lExp

        mov     eax,[edi].mx_efM21.ef_lMant
        mov     ecx,[edi].mx_efM21.ef_lExp
        stdCall mulff                       ; y * M21

        mov     edx,lMantResult
        mov     ebx,lExpResult
        stdCall addff                       ; x*M11 + y*M21

; compute y'

        mov     ebx,pvtflDest               ; get x before storing x'

        mov     edx,[esi].vfl_x.ef_lMant    ; x.lMant
        mov     [ebx].vfl_x.ef_lMant,eax

        mov     eax,[esi].vfl_x.ef_lExp     ; x.lExp
        mov     [ebx].vfl_x.ef_lExp,ecx
        mov     ebx,eax                     ; edx:ebx = x.lMant:x.lExp

        mov     eax,[edi].mx_efM12.ef_lMant
        mov     ecx,[edi].mx_efM12.ef_lExp
        stdCall mulff                       ; x * M12

        mov     lMantResult,eax
        mov     lExpResult,ecx

        mov     edx,[esi].vfl_y.ef_lMant    ; get y
        mov     ebx,[esi].vfl_y.ef_lExp

        mov     eax,[edi].mx_efM22.ef_lMant
        mov     ecx,[edi].mx_efM22.ef_lExp
        stdCall mulff                       ; y * M22

        mov     edx,lMantResult
        mov     ebx,lExpResult
        stdCall addff                       ; x*M12 + y*M22

        mov     ebx, pvtflDest
        mov     [ebx].vfl_y.ef_lMant,eax
        mov     [ebx].vfl_y.ef_lExp,ecx

        add     esi,SIZE VECTORFL
        add     pvtflDest,SIZE VECTORFL

        dec     cvtl
        jnz     convert_vectors_loop
        mov     eax,1
        stdRET  bCvtVts_FlToFl

overflow:
        xor     eax,eax
        stdRET  bCvtVts_FlToFl

stdENDP bCvtVts_FlToFl

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\ia64\xformer.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\i386\math.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: math.asm                                                 ;
;                                                                       ;
; This module contains the arithmetics routines for the engine internal ;
; floating point type EFLOAT.  It is mostly adapted from ChuckWh's      ;
; math.asm for PM.                                                      ;
;                                                                       ;
; Created: 14-Nov-1990                                                  ;
; Author: Wendy Wu [wendywu]                                            ;
;                                                                       ;
; Copyright (c) 1990 Microsoft Corporation                              ;
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        .list

        .data
if DBG
  MATH_DivideError  db      'divff3_c - Divide overflow',10,0
endif

        .code

if DBG
  extrn   DbgPrint:proc
endif

NUMBER_OF_INTEGER_BITS_LONG equ 32
NUMBER_OF_INTEGER_BITS_FIX  equ 28
IEEE_NAN     equ     7FFFFFFFh          ; not a number exp = 255 mant != 0
EXPONENT_OF_ONE equ 2
MANTISSA_OF_ONE equ 040000000h

BOOL_TRUNCATE   equ     0
BOOL_ROUND      equ     1

RESULT_NEGATIVE     equ 1

        public  cmp_table_1
        public  cmp_table_2
        public  cmp_table_3
        public  cmp_table_4

cmp_table_1     label   dword
        dd      01000000h
        dd      00000100h

cmp_table_2     label   dword
        dd      10000000h
        dd      00100000h
        dd      00001000h
        dd      00000010h

cmp_table_3     label   dword
        dd      40000000h
        dd      04000000h
        dd      00400000h
        dd      00040000h
        dd      00004000h
        dd      00000400h
        dd      00000040h
        dd      00000004h

cmp_table_4     label   dword
        dd      80000000h
        dd      20000000h
        dd      08000000h
        dd      02000000h
        dd      00800000h
        dd      00200000h
        dd      00080000h
        dd      00020000h
        dd      00008000h
        dd      00002000h
        dd      00000800h
        dd      00000200h
        dd      00000080h
        dd      00000020h
        dd      00000008h
        dd      00000002h

;---------------------------Private-Routine-----------------------------;
; dNormalize
;
;   Normalizes a DWORD so that its absolute value has 0 in sign bit and
;   1 in the highest order non-sign bit.  Return the number of shifts done.
;
; Entry:
;       EAX = DWORD
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = normalized DWORD
;       ECX = shift count
; Registers Destroyed:
;       EDX
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   dNormalize

        cdq                             ; save the sign
        xor     ecx,ecx

        xor     eax,edx                 ; absolute eax
        sub     eax,edx
        jz      dNormalize_zero
        js      dNormalize_80000000

        cmp     eax,10000h
        adc     cl,cl                   ; cl = 0 if eax >= 10000h
                                        ; cl = 1 if eax < 10000h
        cmp     eax,cmp_table_1[4*ecx]
        adc     cl,cl                   ; cl = 0 if eax > 1000000h
                                        ; cl = 1 if 1000000h > eax > 10000h
                                        ; cl = 2 if 10000h > eax > 100h
                                        ; cl = 3 if eax < 100h

        cmp     eax,cmp_table_2[4*ecx]
        adc     cl,cl                   ; 0 <= cl <= 7

        cmp     eax,cmp_table_3[4*ecx]
        adc     cl,cl                   ; 0 <= cl <= 15

        cmp     eax,cmp_table_4[4*ecx]
        adc     cl,cl                   ; 1 <= cl <= 31
                                        ; cl will never be 0 since eax > 0

        dec     cl                      ; offset to highest non-sign bit
        shl     eax,cl                  ; shift to highest non-sign bit

        xor     eax,edx                 ; negate eax if was negative number
        sub     eax,edx

dNormalize_zero:
        cRet    dNormalize

dNormalize_80000000:
        sar     eax,1
        mov     ecx,-1
        cRet    dNormalize
endProc dNormalize

;-----------------------------Private-Routine---------------------------;
; ltoef
;
;   Convert a LONG integer to an EFLOAT format number.
;
; Entry:
;       EAX = LONG integer to be converted
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = mantissa of the EFLOAT number
;       ECX = exponent of the EFLOAT number
; Registers Destroyed:
;       EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ltoef

        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_LONG ; exp = 32 - shift count

@@:
        cRet    dNormalize
endproc ltoef

;---------------------------Public-Routine------------------------------;
; ltoef_c
;
;   Convert a LONG integer to an EFLOAT format number.
;
; Arguments:
;       IN  l    LONG integer to be converted
;       OUT pef  points to the EFLOAT number
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ltoef_c,8,<             \
        l:      dword,          \
        pef:    ptr EFLOAT      >

        mov     eax,l
        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_LONG ; exp = 32 - shift count

@@:
        mov     edx,pef
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    ltoef_c
endProc ltoef_c

;-----------------------------Private-Routine---------------------------;
; fxtoef
;
;   Convert a FIX number to an EFLOAT format number.
;
; Entry:
;       EAX = FIX number to be converted
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = mantissa of the EFLOAT number
;       ECX = exponent of the EFLOAT number
; Registers Destroyed:
;       EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   fxtoef

        cCall   dNormalize                      ; mant = normalized fIX number
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_FIX  ; exp = 28 - shift count

@@:
        cRet    fxtoef
endProc fxtoef

;---------------------------Public-Routine------------------------------;
; fxtoef_c
;
;   Convert a FIX number to an EFLOAT format number.
;
; Arguments:
;       IN  fx   FIX number to be converted
;       OUT pEf  points to the EFLOAT number
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   fxtoef_c,8,<            \
        fx:     dword,          \
        pEf:    ptr EFLOAT      >

        mov     eax,fx
        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_FIX  ; exp = 28 - shift count

@@:
        mov     edx,pEf
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    fxtoef_c
endProc fxtoef_c

;---------------------------Public-Routine------------------------------;
; ftoef_c
;
;   Convert an IEEE FLOAT format number to an EFLOAT format number.
;
; Arguments:
;       IN  e    IEEE FLOAT number to be converted
;       OUT pEf  points to the EFLOAT number
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ftoef_c,8,<              \
        e:      dword,           \
        pEf:    ptr EFLOAT       >

        mov     eax,e
        shld    ecx,eax,9
        and     ecx,0FFh                ; ecx = e.exponent
        jnz     @F

        xor     eax,eax                 ; return 0 if (exp == 0)
        jmp     ftoef_zero

@@:

; We got a non-zero number
; EFLOAT.mantissa = FLOAT.mantissa + hidden one

        cdq                             ; sign extend eax to edx
        and     eax,07FFFFFh            ; mask off sign bit and exponent
        shl     eax,7                   ; shift to its position
        or      eax,040000000h          ; or in the hidden one

        ;ASSERT(((eax & 080000000h) == 0),"ftoef_c error");

        xor     eax,edx                 ; negate mantissa if (e < 0)
        sub     eax,edx

; ef.exp = e.exp + 2 - 127

        sub     ecx,125

ftoef_zero:
        mov     edx,pEf
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    ftoef_c
endProc ftoef_c

;-----------------------------Public-Routine----------------------------;
; eftofx
;
;   Convert an EFLOAT number to a FIX number.  Fractions of 1/32 or greater
;   are rounded up.
;
; Entry:
;       EAX = mantissa
;       ECX = exponent
; Returns:
;       OF = 0
;       EAX = converted long integer
; Error Returns:
;       OF = 1
; Registers Destroyed:
;       EDX,ECX
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftofx

        add     ecx,4                   ; so we can call eftol
        mov     edx,BOOL_ROUND

eftofx_fall_through::

endProc eftofx                          ; fall through to eftol

;-----------------------------Public-Routine----------------------------;
; eftol
;
;   Convert an EFLOAT number to a LONG integer.  Fractions are either
;   rounded or truncated depending on the flag in EDX.
;
; Entry:
;       EAX = mantissa
;       ECX = exponent
;       EDX = roundoff boolean
; Returns:
;       OF = 0
;       EAX = converted long integer
; Error Returns:
;       OF = 1
; Registers Destroyed:
;       ECX
; Calls:
;       None

; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftol

.errnz  $-eftofx_fall_through

; if exp < 1, return 0.

        cmp     ecx,1
        jl      eftol_exp_small
        cmp     ecx,32
        jg      eftol_exp_big
        jz      @F                      ; return mantissa if (exp == 32)

        ;ASSERT((1 <= ecx <= 31),"eftol exponent error")

        xor     cl,31                   ; 31 - exp

; EDX = 1 if we'll do truncation, LONG = ((mant >> (31 - exp)) + 1) >> 1
; EDX = 0 if we'll do rounding, LONG = (mant >> (31 - exp)) >> 1

        ;ASSERT(((edx & FFFFFFFEh) == 0),"eftol rounding boolean error")

        sar     eax,cl
        add     eax,edx
        jo      eftol_7fffffff          ; overflow if mant = 7fffffff, exp = 31
        sar     eax,1
@@:
        cRet    eftol                   ; normal return

eftol_exp_small:
        xor     eax,eax                 ; exponent too small, return 0
        cRet    eftol                   ; OF = 0 by xor

eftol_exp_big:
        mov     cl,1                    ; OF = 1 if exp > 32
        add     cl,7fh
        cRet    eftol

eftol_7fffffff:
        shr     eax,1                   ; return 40000000h
        xor     cl,cl                   ; OF = 0
        cRet    eftol

endProc eftol

;---------------------------Public-Routine------------------------------;
; eftol_c
;
;   Convert an EFLOAT number to a LONG integer.  Fractions are rounded
;   or truncated depending on the passed in flag.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
;       OUT pL      points to the LONG integer
;       IN  bRound  roundoff boolean
; Returns:
;       EAX = 1 if success
; Error Returns:
;       EAX = 0 if overflow
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;
;CR!!! Delete this if nobody uses it.
;-----------------------------------------------------------------------;

cProc   eftol_c,12,<        \
        pEf:    ptr EFLOAT, \
        pL:     ptr LONG,   \
        bRound: dword       >

        mov     edx,pEf
        mov     eax,[edx].ef_lMant
        mov     ecx,[edx].ef_lExp
        mov     edx,bRound

        cCall   eftol

        mov     edx,pL
        mov     [edx],eax

        mov     eax,0
        setno   al

        cRet    eftol_c
endProc eftol_c

;---------------------------Public-Routine------------------------------;
; eftofx_c
;
;   Convert an EFLOAT number to a FIX number.  Fractions of 1/32 or greater
;   are rounded up.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
;       OUT pFx     points to the FIX number
; Returns:
;       EAX = 1 if success
; Error Returns:
;       EAX = 0 if overflow
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;
;CR!!! Delete this if nobody uses it.
;-----------------------------------------------------------------------;

cProc   eftofx_c,8,<        \
        pEf:    ptr EFLOAT, \
        pFx:    ptr FIX     >

        mov     edx,pEf
        mov     eax,[edx].ef_lMant
        mov     ecx,[edx].ef_lExp
        add     ecx,4

        mov     edx,BOOL_ROUND
        cCall   eftol

        mov     edx,pFx
        mov     [edx],eax

        mov     eax,0
        setno   al

        cRet    eftofx_c
endProc eftofx_c

;---------------------------Public-Routine------------------------------;
; eftof_c
;
;   Convert an EFLOAT number to an IEEE FLOAT format number.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
; Returns:
;       EAX = resulting IEEE FLOAT number
; Error Returns:
;       EAX = NAN if overflow
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftof_c,4,<                 \
        pEf:    ptr EFLOAT          >

        xor     eax,eax                 ; assume result is 0
        mov     edx,pEf
        mov     ecx,[edx].ef_lMant
        or      ecx,ecx                 ; faster than jcxz
        jz      eftof_zero

        mov     edx,[edx].ef_lExp

        jns     eftof_positive
        or      eax,080000000h          ; turn on sign bit if negative number
        neg     ecx                     ; make it positive

eftof_positive:

        and     ecx,3FFFFFFFh           ; mask off sign bit and hidden one
        shr     ecx,7                   ; shift mantissa to its position
        adc     ecx,0                   ; round the result
        test    ecx,0800000h
        jnz     eftof_rounding_overflow

eftof_mant_done:
        add     edx,125                 ; FLOAT.exp = EFLOAT.exp + 127 - 2
        jo      eftof_NAN

        shl     edx,23                  ; shift exponent to its position

        or      eax,ecx
        or      eax,edx                 ; or sign, mant, exp bits together
eftof_zero:
        cRet    eftof_c

eftof_rounding_overflow:
        xor     ecx,ecx
        inc     edx
        jno     eftof_mant_done

eftof_NAN:
        mov     eax,IEEE_NAN
        cRet    eftof_c

endProc eftof_c

;---------------------------Public-Routine------------------------------;
; fraction_c
;
;   Get the fraction part of an EFLOAT number.
;
; Arguments:
;       IN  pEfIn   points to the EFLOAT number its fractional part is
;                   to be computed
;       OUT pEfOut  points to the EFLOAT number that stores the fractional
;                   part result
; Returns:
;       Nothing
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

;!!!CR Does Andrew use this?  Is the result correct when a negative number
;!!!CR is passed in?

cProc   fraction_c,8,<       \
        pEfOut:  ptr EFLOAT, \
        pEfIn:   ptr EFLOAT  >

        mov     edx,pEfIn

        mov     eax,[edx].ef_lMant         ; EAX = mantissa
        mov     ecx,[edx].ef_lExp          ; ECX = exponent
        cmp     ecx,0
        jle     got_fractions           ; if (exp <= 1) return itself

        cmp     ecx,32
        jge     no_fraction

; shift off integer part

have_fraction:
        shl     eax,cl                  ; shift off the integer bits
        shr     eax,1                   ; make it positive
        cCall   dNormalize
        jz      no_fraction
        neg     ecx                     ; exp = 1 - left shift count
        inc     ecx

; We get here either because the number is too big, no fraction is stored
; in the mantissa or this number is an integer.

store_results:
        mov     edx,pEfOut
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx
        mov     eax,edx
        cRet    fraction_c

got_fractions:                          ; take care of negative fractions here
        or      eax,eax
        jge     store_results
        neg     ecx
        sar     eax,cl
        shr     eax,1                   ; make it positive
        neg     ecx
        inc     ecx
        jmp short   store_results

no_fraction:
        xor     eax,eax                 ; exp >= 32 return 0
        xor     ecx,ecx
        jmp     store_results

endProc fraction_c

;-----------------------------Public-Routine----------------------------;
; addff
;
;   Add two EFLOAT numbers together.
;
; Entry:
;       EDX = mant
;       EBX = exp
;       EAX = mant
;       ECX = exp
; Returns:
;       EAX = mant
;       ECX = exp
;       OF = 0
;       ZF = 1 if zero
; Error Returns:
;       OF = 1 if overflow
; Registers Destroyed:
;       EBX,EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   addff

        or      edx,edx                 ; early out if either one is 0
        jz      addff_exit
        or      eax,eax
        jz      addff_xchg_exit

        cmp     ecx,ebx
        jge     second_summand_larger
        xchg    eax,edx
        xchg    ecx,ebx

second_summand_larger:
        sub     ecx,ebx
        cmp     ecx,30                  ; only 30 bits of pre-adding precision
        jbe     first_summand_not_small ;
        add     ecx,ebx                 ; clear overflow flag
        jmp     addff_exit

first_summand_not_small:
        add     ebx,ecx                 ; restore the bigger exp in ebx
        sar     edx,cl                  ; shift the smaller number right by
                                        ; difference in exp bit
        sar     eax,1                   ; prevent overflow
;        adc     eax,0                   ; round the bigger number
        sar     edx,1                   ; prevent overflow
;        adc     edx,0                   ; round the smaller number

        add     eax,edx                 ; add mantissa together
        cCall   dNormalize
        jz      addff_exit

; sum's exponent = EBX - ECX + 1

        neg     ecx
        add     ecx,ebx
        inc     ecx                     ; compensate for the right shift

addff_exit:
        cRet    addff

addff_xchg_exit:
        mov     eax,edx
        mov     ecx,ebx
        cRet    addff

endProc addff

;---------------------------Public-Routine------------------------------;
; subff_c                                                               ;
;                                                                       ;
;   Subtract an EFLOAT number from another.  The result overwrites the  ;
;   subtrahend.                                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pSub  points to the EFLOAT subtrahend                    ;
;       IN     pMin  points to the EFLOAT minuend                       ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       addff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   subff_c,8,<         \
        uses    ebx,        \
        pSub:   ptr EFLOAT, \
        pMin:   ptr EFLOAT  >

        mov     ebx, pSub
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pMin
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp
        neg     eax

        cCall   addff

        mov     ebx,pSub
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    subff_c

endProc subff_c

cProc   subff3_c,12,<        \
        uses    ebx,        \
        pRes:   ptr EFLOAT, \
        pSub:   ptr EFLOAT, \
        pMin:   ptr EFLOAT  >

        mov     ebx, pSub
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pMin
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp
        neg     eax

        cCall   addff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    subff3_c
endProc subff3_c

;---------------------------Public-Routine------------------------------;
; addff_c                                                               ;
;                                                                       ;
;   Add two EFLOAT numbers together.  The result overwrites the first   ;
;   summand.                                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pSum1  points to the first EFLOAT summand                ;
;       IN     pSum2  points to the second EFLOAT summand               ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       addff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   addff_c,8,<         \
        uses    ebx,        \
        pSum1:  ptr EFLOAT, \
        pSum2:  ptr EFLOAT  >

        mov     ebx, pSum2
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pSum1
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp

        cCall   addff

        mov     ebx,pSum1
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    addff_c
endProc addff_c

cProc   addff3_c,12,<        \
        uses    ebx,        \
        pRes:   ptr EFLOAT, \
        pSum1:  ptr EFLOAT, \
        pSum2:  ptr EFLOAT  >

        mov     ebx, pSum2
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pSum1
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp

        cCall   addff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    addff3_c
endProc addff3_c

;-----------------------------Public-Routine----------------------------;
; mulff                                                                 ;
;                                                                       ;
;   Multiply two EFLOAT numbers together.                               ;
;                                                                       ;
; Entry:                                                                ;
;       EDX = first multiplicand's mant                                 ;
;       EBX = first multiplicand's exp                                  ;
;       EAX = second multiplicand's mant                                ;
;       ECX = second multiplicand's exp                                 ;
; Returns:                                                              ;
;       EAX = mant                                                      ;
;       ECX = exp                                                       ;
;       OF = 0                                                          ;
;       ZF = 1 if zero                                                  ;
; Error Returns:                                                        ;
;       OF = 1 if overflow                                              ;
; Registers Destroyed:                                                  ;
;       EDX,EBX                                                         ;
; Calls:                                                                ;
;       None                                                            ;
; History:                                                              ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

mul_shift_table label   byte            ; highest 4 bits
        db      0                       ; 0000 should have been early out
        db      2                       ; 0001
        db      1                       ; 0010
        db      1                       ; 0011

cProc   mulff

        add     ebx,ecx                 ; add exponent together
        jo      mul_exit

        xor     ecx,ecx
        imul    edx                     ; edx:eax = edx * eax

; the product of two mantissas is now in edx:eax. Since on entry
; to this function both mantissas were normalized the absolute value
; of this product is <= 7fffffff * 7fffffff = 3fffffff:00000001;
; The legal values of the most significant nibble in edx are 0, 1, 2, 3.

        or      edx,edx
        jz      mul_exit                ; eax == 0 if (edx == 0), so it's
                                        ; safe to early out here
        js      mul_neg

        shld    ecx,edx,4               ; normalize the result
        mov     cl,mul_shift_table[ecx] ; find the shift count from the table
        shld    edx,eax,cl
        shl     eax,cl

; now do the rounding. We should  add the most significant bit of eax to edx.
; Adding this extra bit to edx could result in the
; loss of normalization of edx which should then be restored by shr edx,1
; and adjusting the exponent accordingly.

        add     eax,80000000h
        adc     edx,0
        js      mul_restore_normalization

mul_store_result:
        neg     ecx
        mov     eax,edx                 ; return mantissa in eax
        add     ecx,ebx                 ; exponent = ebx - ecx

mul_exit:
        cRet    mulff

mul_restore_normalization:

        shr edx,1                       ; edx now normalized == 40000000h
        dec ecx                         ; adjust exponent
        jmp mul_store_result

; the result is negative:

mul_neg:

; We can't normalize a negative number.  e.g. the shift count for 1110
; can be either 1 or 2.

        neg     eax                     ; negate edx:eax
        adc     edx,0
        neg     edx

        shld    ecx,edx,4               ; normalize the result
        mov     cl,mul_shift_table[ecx] ; find the shift count from the table
        shld    edx,eax,cl
        shl     eax,cl

; do the rounding as in the positive case

        add     eax,80000000h
        adc     edx,0
        js      mul_restore_normalization_neg

; all the information is now in edx, including least significant bit

mul_store_result_neg:

        neg     edx                     ; restore the sign
        neg     ecx                     ; finish off as in the positive case
        add     ecx,ebx                 ; exponent = ebx - ecx
        mov     eax,edx                 ; return mantissa in eax

        cRet    mulff

mul_restore_normalization_neg:

        shr edx,1                       ; edx now normalized == 40000000h
        dec ecx                         ; adjust exponent
        jmp mul_store_result_neg

endProc mulff

;---------------------------Public-Routine------------------------------;
; mulff_c                                                               ;
;                                                                       ;
;   Multiply two EFLOAT numbers together.  The result overwrites the    ;
;   first multiplicand.                                                 ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pMult1  points to the first EFLOAT multiplicand.         ;
;       IN     pMult2  points to the second EFLOAT multiplicand.        ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       mulff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   mulff_c,8,<             \
        uses    ebx,            \
        pMult1: ptr EFLOAT,     \
        pMult2: ptr EFLOAT      >

        mov     ebx,pMult2
        mov     eax,[ebx].ef_lMant
        mov     ecx,[ebx].ef_lExp
        mov     ebx,pMult1
        mov     edx,[ebx].ef_lMant
        mov     ebx,[ebx].ef_lExp

        cCall   mulff

        mov     ebx,pMult1
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    mulff_c
endProc mulff_c

cProc   mulff3_c,12,<            \
        uses    ebx,            \
        pRes:   ptr EFLOAT,     \
        pMult1: ptr EFLOAT,     \
        pMult2: ptr EFLOAT      >

        mov     ebx,pMult2
        mov     eax,[ebx].ef_lMant
        mov     ecx,[ebx].ef_lExp
        mov     ebx,pMult1
        mov     edx,[ebx].ef_lMant
        mov     ebx,[ebx].ef_lExp

        cCall   mulff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    mulff3_c
endProc mulff3_c

;---------------------------Private-Routine-----------------------------;
; divff                                                                 ;
;                                                                       ;
;   Divide an EFLOAT number by another.                                 ;
;                                                                       ;
; Entry:                                                                ;
;       EDX = dividend's mantissa                                       ;
;       EBX = dividend's exponent                                       ;
;       EAX = divisor's mantissa, should never be 0                     ;
;       ECX = divisor's exponent                                        ;
; Returns:                                                              ;
;       EAX = quotient's mantissa                                       ;
;       ECX = quotient's exponent                                       ;
;       OF = 0                                                          ;
;       ZF = 1 if zero                                                  ;
; Error Returns:                                                        ;
;       OF = 1 if overflow                                              ;
; Registers Destroyed:                                                  ;
;       EDX,EBX                                                         ;
; Calls:                                                                ;
;       dNormalize                                                      ;
; History:                                                              ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;
;
;   cProc   divff
;
;           ;assert((eax != 0), "divff error: divide by 0")
;
;           sub     ebx,ecx                 ; subtract divisor's exp from dividend's
;           jo      divff_exit
;
;           mov     ecx,eax                 ; save divisor's mantissa
;           xor     eax,eax
;           shrd    eax,edx,2               ; prevent overflow, shift dividend
;           sar     edx,2                   ; right by 2
;
;           idiv    ecx
;           cCall   dNormalize
;           jz      divff_exit              ; eax = ecx = 0 if ZF = 1
;
;           neg     ecx
;           inc     ecx                     ; compensate for right shift by 2
;           inc     ecx
;           add     ecx,ebx                 ; add the exponent of the dividend
;
;   divff_exit:
;           cRet    divff
;   endProc divff
;
;---------------------------Public-Routine------------------------------;
; divff_c                                                               ;
;                                                                       ;
;   Divide an EFLOAT number by another.  The result overwrites the      ;
;   dividend.                                                           ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pDvdend  points to the EFLOAT dividend.                  ;
;       IN     pDvsor   points to the EFLOAT divisor.                   ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow or zero divisor                             ;
; Calls:                                                                ;
;       divff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;
;
;   cProc   divff_c,8,<          \
;           uses     ebx,        \
;           pDvdend: ptr EFLOAT, \
;           pDvsor:  ptr EFLOAT  >
;
;           mov     ebx,pDvsor
;           mov     eax,[ebx].ef_lMant
;           or      eax,eax
;           jz      divff_error
;
;           mov     ecx,[ebx].ef_lExp
;           mov     ebx,pDvdend
;           mov     edx,[ebx].ef_lMant
;           mov     ebx,[ebx].ef_lExp
;
;           cCall   divff
;
;           mov     edx,pDvdend
;           mov     [edx].ef_lMant,eax
;           mov     [edx].ef_lExp,ecx
;
;           mov     eax,0
;           setno   al
;
;           cRet    divff_c
;
;   divff_error:
;           xor     eax,eax
;           cRet    divff_c
;
;   endProc divff_c
;
;   cProc   divff_old3_c,12,<         \
;           uses     ebx,        \
;           pRes:    ptr EFLOAT, \
;           pDvdend: ptr EFLOAT, \
;           pDvsor:  ptr EFLOAT  >
;
;           mov     ebx,pDvsor
;           mov     eax,[ebx].ef_lMant
;           or      eax,eax
;           jz      short divff_old3_error
;
;           mov     ecx,[ebx].ef_lExp
;           mov     ebx,pDvdend
;           mov     edx,[ebx].ef_lMant
;           mov     ebx,[ebx].ef_lExp
;
;           cCall   divff
;
;           mov     edx,pRes
;           jo      short @F
;           mov     [edx].ef_lMant,eax
;           mov     [edx].ef_lExp,ecx
;   @@:     mov     eax,edx
;           cRet    divff_old3_c
;
;   divff_old3_error:
;           mov     eax,pRes
;           cRet    divff_old3_c
;   endProc divff_old3_c
;
;------------------------------Public-Routine------------------------------;
; divff3_c                                                                 ;
;                                                                          ;
; A newer concept for EFLOAT division.  This makes maximal use of the      ;
; assumption that the given numbers are normalized.  I think the older     ;
; method spends a lot of time in dNormalize for no reason.                 ;
;                                                                          ;
;  Fri 14-Jan-1994 -by- Bodin Dresevic [BodinD]                            ;
; update: added all the comments while trying to debug this routine        ;
;                                                                          ;
;  Sun 22-Mar-1992 02:04:09 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   divff3_c,12,<         \
        uses     ebx esi,    \
        pRes:    ptr EFLOAT, \
        pNum:    ptr EFLOAT, \
        pDenom:  ptr EFLOAT  >

        mov     ebx,pNum
        mov     esi,[ebx].ef_lExp
        mov     ecx,[ebx].ef_lMant
        or      ecx,ecx
        jz      short divff3_zero
        mov     eax,ecx
        cdq
        xor     ecx,edx
        sub     ecx,edx             ; ecx = |MantN|
        mov     ebx,pDenom
        sub     esi,[ebx].ef_lExp   ; esi = ExpN - ExpD == expR
        jo      short divff3_error
        mov     eax,[ebx].ef_lMant
        mov     ebx,edx             ; save sgn(MantN) into ebx
        cdq
        xor     eax,edx
        sub     eax,edx             ; eax = |MantD|
        xor     ebx,edx             ; ebx = sgn(MantN) * sgn(MantD)
        mov     edx,ecx
        mov     ecx,eax
        add     ecx,ecx             ; ecx = 2 * |MantD|
        jz      short divff3_error
        xor     eax,eax             ; edx:eax = |MantN|:0, ecx = 2 * |MantD|
        div     ecx                 ; the result in eax, remainder in edx
        shr     ecx,1               ; ecx = |MantD|
        cmp     ecx,edx             ; if remainder <= |MantD| need roundoff bit
        sbb     edx,edx
        neg     edx                 ; edx = roundoff bit
        xor     ecx,ecx             ; ecx = 0, ecx will be used to store correction to ExpR
        or      eax,eax             ; eax = unnormalized |MantR|, may need to clear sign bit
        setns   cl                  ; cl = 1 iff sign bit in eax NOT set
        and     edx,ecx             ; fix roundoff bit
        xor     cl,1                ; cl = 1 iff sign bit in eax IS set
        shr     eax,cl              ; normalize eax, will set CF iff least significant bit is set in eax before shr
        adc     eax,edx             ; round the |MantR|, add CF if it is set
        inc     ecx                 ; because we divided by 2 * |MantD| above
        add     esi,ecx             ; adjust expR
        jo      short divff3_error
        xor     eax,ebx             ; restore the sign of MantR
        sub     eax,ebx             ; eax = MantR
        mov     ebx,pRes
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,esi
        mov     eax,ebx
        cRet    divff3_c

divff3_zero:
        mov     eax,pRes
        mov     [eax].ef_lMant,ecx
        mov     [eax].ef_lExp,ecx
        cRet    divff3_c

divff3_error:
  if DBG
        push    offset MATH_DivideError
        call    DbgPrint
        add     esp,4
        int     3
  endif
        mov     eax,pRes
        cRet    divff3_c
endProc divff3_c

;------------------------------Public--Routine-----------------------------;
; void sqrtf2_c (pRes,pef)                                                 ;
;                                                                          ;
; Takes the square root of an EFLOAT                                       ;
;                                                                          ;
; History:                                                                 ;
;  Thu 19-Mar-1992 17:38:58 -by- Charles Whitmer [chuckwh]                 ;
; Added result pointer.  Removed 9 instructions from the calculation.      ;
; Doesn't change return value on error.                                    ;
;                                                                          ;
;   Tue 02-Apr-1991 11:45:09 -by- Kirk Olynyk [kirko]                      ;
; Uses Newton's method now.                                                ;
;                                                                          ;
;   Mon 25-Mar-1991 14:08:47 -by- Kirk Olynyk [kirko]                      ;
; Uses a loop instead of IREPT                                             ;
;                                                                          ;
;   Fri 01-Mar-1991 07:34:05 -by- Kirk Olynyk [kirko]                      ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   sqrtf2_c,8,<             \
        uses  esi edi ebx,       \
        pRes: ptr EFLOAT,        \
        pef:  ptr EFLOAT         >

        mov     esi,pef
        mov     edi,[esi].ef_lMant
        mov     ebx,[esi].ef_lExp          ; EDI:EBX = mant,exp

; quick out for zero

        mov     esi,pRes                ; ESI -> Result
        or      edi,edi
        js      short sqrtf_error
        jz      short sqrtf_early_out

; quick out for one

        mov     eax,ebx
        mov     edx,edi
        sub     eax,EXPONENT_OF_ONE
        sub     edx,MANTISSA_OF_ONE
        or      edx,eax
        jz      short sqrtf_early_out

; Calculate the exponent of the square root

        sar     ebx,1
        sbb     ecx,ecx             ; ECX = (exp is odd) ? FFFFFFFFh : 0h
        inc     ebx
        mov     [esi].ef_lExp,ebx      ; return the exponent

; The mantissa must be shifted. Calculate the shift factor
; CL = (exp is odd) ? 1 : 2

        add     cl,2

; Shift the mantissa, keep extra bits in ESI.

        xor     esi,esi             ; esi = 0
        shrd    esi,edi,cl
        shr     edi,cl              ; EDI = M / 2^shift_factor = P

; extract high and low word of the mantissa

        shld    ecx,edi,16          ; DI = lo word of P, CX = hi word of P

; recursion formula is x(n+1) = [x(n) + t/x(n)]/2, where we are trying to
; compute sqrt(t),  the value below has empirically proven to be a good guess for
; x(0) in our range of results [bodind]

; form zero'th guess for square root

        lea     ebx,[ecx+4000h]     ; BX:0000 = zeroth guess

; calculate 1'st guess to 16 bit accuracy

        mov     edx,ecx
        mov     eax,edi
        div     bx
        add     bx,ax
        rcr     bx,1                ; BX:0000 = 1'st guess

; calculate 2'nd guess to 16 bit accuracy

        mov     edx,ecx
        mov     eax,edi
        div     bx
        add     bx,ax
        rcr     bx,1                ; BX:0000 = 2'nd guess

; calculate 3'rd guess to 32 bit accuracy, division done with
; proper rounding [bodind]

        shl     ebx,16
        mov     edx,edi
        mov     eax,esi             ; recover the lost bits

; do division with  rounding, make sure that after adding 1/2 denom
; that carry bit if ehists is added properly to edx [bodind]

        mov     ecx,ebx
        shr     ecx,1
        add     eax,ecx
        adc     edx,0
        div     ebx

        add     ebx,eax
        rcr     ebx,1               ; EBX = 3'rd guess

        mov     esi,pRes            ; ESI -> to the result

; done except that maybe our result is not normalized properly

        or      ebx,ebx             ; too big a number, adjust mant and exp
        jns     short sqrtf_return_mantissa
        shr     ebx,1                         ; divide mantissa by 2
        inc     dword ptr [esi].ef_lExp       ; add one to the exponent

; return the mantissa

sqrtf_return_mantissa:

        mov     [esi].ef_lMant,ebx

sqrtf_error:
        mov     eax,esi
        cRet    sqrtf2_c

; Do early outs.

sqrtf_early_out:
        mov     [esi].ef_lMant,edi
        mov     [esi].ef_lExp,ebx
        mov     eax,esi
        cRet    sqrtf2_c
endProc sqrtf2_c

;------------------------------Public--Routine-----------------------------;
; VOID vEfToLfx(pefloat,plfx)                                              ;
;                                                                          ;
; Converts an EFLOAT to a 32.32 fix point number.                          ;
;                                                                          ;
; Warning:                                                                 ;
;   No checks are made to see if the EFLOAT can fit.                       ;
;                                                                          ;
; History:                                                                 ;
;  Tue 17-Mar-1992 00:32:48 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc    vEfToLfx,8,<                   \
    pefloat:    ptr EFLOAT,             \
    plfx:       ptr LARGE_INTEGER       >

; Load the EFLOAT.

    mov     ecx,pefloat
    mov     eax,[ecx].ef_lMant
    mov     ecx,[ecx].ef_lExp

; Sign extend into EDX.  The EFLOAT is now EDX.EAX * 2^ECX.

    cdq

; Decide about shifting.

    or      ecx,ecx
    jz      short saveit
    jl      short shift_right

; Shift it left.

    shld    edx,eax,cl
    shl     eax,cl
saveit:
    mov     ecx,plfx
    mov     [ecx].li_LowPart,eax
    mov     [ecx].li_HighPart,edx
    cRet    vEfToLfx

; Shift it right.

shift_right:
    neg     ecx
    shrd    eax,edx,cl
    sar     edx,cl
    mov     ecx,plfx
    mov     [ecx].li_LowPart,eax
    mov     [ecx].li_HighPart,edx
    cRet    vEfToLfx
endProc vEfToLfx

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\amd64\xformer.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToL(lx);
            y.bEfToL(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToL(lx);
            y.bEfToL(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\wow6432\i386\math.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\daytona\ia64\math.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\wow6432\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\math\wow6432\i386\xformer.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\apientry.c ===
/*****************************************************************************
 *
 * apientry.c - This module contains the API entry points for the
 *              Win32 to Win16 metafile converter.
 *
 * Date: 8/29/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL     bMemUpdateCheckSum(PLOCALDC pLocalDC) ;
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags) ;
VOID     vFreeLocalDC(PLOCALDC pLocalDC);


extern VOID __cdecl _cfltcvt_init(VOID) ;

// This critical section structure is shared by all the threads of a given
// process.

CRITICAL_SECTION CriticalSection ;

// Constant definition for internal static string(s).

BYTE    szDisplay[] = "DISPLAY" ;

/*****************************************************************************
 * Entry point for translation
 *****************************************************************************/
UINT ConvertEmfToWmf(PVOID pht, PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                 INT iMapMode, HDC hdcRef, UINT flags)
{
BOOL        b ;
DWORD       lret = 0;
PLOCALDC    pLocalDC ;


        // We funnel through one exit to make sure we leave the
        // critical section.

        EnterCriticalSection(&CriticalSection) ;

        // Check the requested map mode and if it's valid

        if (iMapMode < MM_MIN || iMapMode > MM_MAX)
        {
            RIP("MF3216:ConvertEmfToWmf - Invalid MapMode\n") ;
            goto ErrorExit;
        }

        // Check for a reference DC.  If one is not supplied we fail.

        if (hdcRef == (HDC) 0)
        {
            RIP("MF3216:ConvertEmfToWmf - Invalid RefDC\n") ;
            goto ErrorExit;
        }

        // Check the validity of the flags.

        if ((flags & ~MF3216_INCLUDE_WIN32MF) != 0)
        {
            RIP("MF3216: ConvertEmfToWmf - Invalid flags\n") ;
            goto ErrorExit ;
        }

        // Allocate the LocalDC and initialize some of it's fields.

        pLocalDC = pldcInitLocalDC(hdcRef, iMapMode, flags) ;
        if (pLocalDC == (PLOCALDC) 0)
        {
            goto ErrorExit ;
        }

        // If pDest is NULL then we just return the size of the buffer required
        // to hold the Win16 metafile bits.
        
        pLocalDC->pht = pht;

        if (pDest == (PBYTE) 0)
        {
            pLocalDC->flags |= SIZE_ONLY ;
            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                lret = pLocalDC->ulBytesEmitted ;
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Size Only failed\n") ;
            }
        }
        else
        {

            // Put the user specified Win16 buffer pointer and buffer length
            // into the localDC.

            pLocalDC->pMf16Bits = pDest ;
            pLocalDC->cMf16Dest = cDest ;

            //  Translate the Win32 metafile to a Win16 metafile.

            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                // Update the Win16 metafile header.

                b = bUpdateMf16Header(pLocalDC) ;
                if (b == TRUE)
                {
                    // Only acknowledge that we have translated some bits
                    // if everything has gone well.

                    lret = pLocalDC->ulBytesEmitted ;

                    // If we're including the Win32 metafile then update the
                    // checksum field in the "Win32Comment header" record.

                    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
                        bMemUpdateCheckSum(pLocalDC) ;
                }
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Metafile conversion failed\n") ;
            }
        }

        // Free the LocalDC and its resources.

        vFreeLocalDC(pLocalDC);

ErrorExit:
        LeaveCriticalSection(&CriticalSection) ;

        return (lret) ;
}


/*****************************************************************************
 * pldcInitLocalDC - Initialize the Local DC.
 *****************************************************************************/
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags)
{
PLOCALDC    pLocalDC;
PLOCALDC    pldcRet = (PLOCALDC) NULL;  // assume error

        // Allocate and initialize memory for the LocalDC.

        pLocalDC = (PLOCALDC) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                         sizeof(LOCALDC));
        if (!pLocalDC)
        {
            PUTS("MF3216:pldcInitLocalDC - LocalAlloc failure\n") ;
            return((PLOCALDC) NULL);
        }

        // Record the size of the DC.

        pLocalDC->nSize = sizeof(LOCALDC) ;

        // Set the LocalDC boolean that controls whether or not we include
        // the Win32 metafile as one or more comment records.

        if (flags & MF3216_INCLUDE_WIN32MF)
            pLocalDC->flags |= INCLUDE_W32MF_COMMENT ;

#if 0
        // Need to create a hdc for the display.
        // Initially this will be used by the bitblt translation code
        // to get a reasonable set of palette entries.
        // The reference DC only has a black & white palette.

        pLocalDC->hdcDisp = CreateDCA((LPCSTR)szDisplay, (LPCSTR)NULL, (LPCSTR)NULL, (CONST DEVMODEA *)NULL) ;
        if (pLocalDC->hdcDisp == (HDC) 0)
        {
            RIP("MF3216:pldcInitLocalDC - CreateDCA(hdcDisp) failed\n") ;
            goto pldcInitLocalDC_exit;
        }
#endif // 0

        //  Create the HelperDC.

        pLocalDC->hdcHelper = CreateICA((LPCSTR) szDisplay,
                                       (LPCSTR) NULL,
                                       (LPCSTR) NULL,
                                       (LPDEVMODEA) NULL) ;
        if (pLocalDC->hdcHelper == (HDC)0)
        {
            PUTS("MF3216: pldcInitLocalDC, Create Helper DC failed\n") ;
            goto pldcInitLocalDC_exit;
        }

        // Initialize the counters we need to keep for updating the header,
        // and keeping track of the object table.

        pLocalDC->nObjectHighWaterMark = -1;

        // Get the play-time device dimensions in millimeters and in pels.

        pLocalDC->cxPlayDevMM   = GetDeviceCaps(hdcRef, HORZSIZE) ;
        pLocalDC->cyPlayDevMM   = GetDeviceCaps(hdcRef, VERTSIZE) ;
        pLocalDC->cxPlayDevPels = GetDeviceCaps(hdcRef, HORZRES) ;
        pLocalDC->cyPlayDevPels = GetDeviceCaps(hdcRef, VERTRES) ;

        // Record the requested map mode and reference DC.

        pLocalDC->iMapMode = iMapMode ;
        pLocalDC->hdcRef   = hdcRef ;

        // Init Arc Direction.

        pLocalDC->iArcDirection = AD_COUNTERCLOCKWISE ;

        // Make current position invalid so that a moveto will be
        // emitted when it is first used.  See comments in DoMoveTo.

        pLocalDC->ptCP.x = MAXLONG ;
        pLocalDC->ptCP.y = MAXLONG ;

        // Default pen is a black pen.

        pLocalDC->lhpn32  = BLACK_PEN | ENHMETA_STOCK_OBJECT;

        // Default brush is a white brush.

        pLocalDC->lhbr32  = WHITE_BRUSH | ENHMETA_STOCK_OBJECT;

    // Default palette.

    pLocalDC->ihpal32 = DEFAULT_PALETTE | ENHMETA_STOCK_OBJECT;
    pLocalDC->ihpal16 = (DWORD) -1; // no W16 palette created yet

        pLocalDC->crBkColor = RGB(0xFF,0xFF,0xFF);

//      pLocalDC->pW16ObjHndlSlotStatus = NULL;
//      pLocalDC->cW16ObjHndlSlotStatus = 0;
//      pLocalDC->piW32ToW16ObjectMap = NULL;
//      pLocalDC->cW32ToW16ObjectMap = 0;
//      pLocalDC->crTextColor = RGB(0x0,0x0,0x0);
//      pLocalDC->iLevel = 0;
//      pLocalDC->pLocalDCSaved = NULL;
//      pLocalDC->ulBytesEmitted = 0;
//      pLocalDC->ulMaxRecord = 0;
//      pLocalDC->pW32hPal = NULL;

        // Set the advanced graphics mode in the helper DC.  This is needed
        // to notify the helper DC that rectangles and ellipses are
        // inclusive-inclusive etc., especially when rendering them in a path.
    // Also, the world transform can only be set in the advanced mode.

        (void) SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

        // We are golden.

        pldcRet = pLocalDC;

pldcInitLocalDC_exit:

        if (!pldcRet)
            vFreeLocalDC(pLocalDC);

        return(pldcRet) ;
}

/*****************************************************************************
 * vFreeLocalDC - Free the Local DC and its resources.
 *****************************************************************************/
VOID vFreeLocalDC(PLOCALDC pLocalDC)
{
    UINT i;

// Free the helper DCs.

    if (pLocalDC->hdcHelper)
        if (!DeleteDC(pLocalDC->hdcHelper))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#if 0
    if (pLocalDC->hdcDisp)
        if (!DeleteDC(pLocalDC->hdcDisp))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#endif // 0

// Free the storage for the object translation map.

    if (pLocalDC->piW32ToW16ObjectMap)
    {
#if 0
        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
        {
            if (pLocalDC->piW32ToW16ObjectMap[i] != UNMAPPED)
                if (i > STOCK_LAST)
                    PUTS1("MF3216: vFreeLocalDC, object32 %ld is not freed\n", i - STOCK_LAST - 1);
                else
                    PUTS1("MF3216: vFreeLocalDC, stock object32 %ld is mapped\n",i);
        }
#endif // 0

        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the W32 palette handles.

    if (pLocalDC->pW32hPal)
    {
    for (i = 0; i < pLocalDC->cW32hPal; i++)
    {
        if (pLocalDC->pW32hPal[i])
                if (!DeleteObject(pLocalDC->pW32hPal[i]))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, delete palette failed");
    }

        if (LocalFree(pLocalDC->pW32hPal))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the w32 handles in the pW16ObjHndlSlotStatus array.
// We free the handles after we have deleted the helper DC so that
// the w32 handles are not selected into any DC.

    if (pLocalDC->pW16ObjHndlSlotStatus)
    {
        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
#if 0
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use
                != OPEN_AVAILABLE_SLOT)
                PUTS1("MF3216: vFreeLocalDC, object16 %ld is not freed\n", i);
#endif // 0

            if (pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle)
            {
                ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].use
                          != OPEN_AVAILABLE_SLOT,
                          "MF3216: error in object handle table");

                if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteObject failed");
            }
        }

        if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// The DC level should be balanced.

    if (pLocalDC->pLocalDCSaved != NULL)
    {
    PLOCALDC pNext, pTmp;

        for (pNext = pLocalDC->pLocalDCSaved; pNext; )
    {
        PUTS("MF3216: vFreeLocalDC, unbalanced DC level\n");

        pTmp = pNext->pLocalDCSaved;
        if (LocalFree(pNext))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
        pNext = pTmp;
    }
    }

// Finally, free the LocalDC.

    if (LocalFree(pLocalDC))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
}


/***************************************************************************
 *  Handle emitting the Win32  metafile comment  record(s).
 **************************************************************************/
BOOL bHandleWin32Comment(PLOCALDC pLocalDC)
{
INT     i;
BOOL    b ;
META_ESCAPE_ENHANCED_METAFILE mfeEnhMF;

    // Win30 may have problems with large (over 8K) escape records.
    // We will limit the size of each Win32 Comment record to
    // MAX_WIN32_COMMENT_REC_SIZE.

    // Initialize the record header.

    mfeEnhMF.rdFunction = META_ESCAPE;
    mfeEnhMF.wEscape    = MFCOMMENT;
    mfeEnhMF.ident      = MFCOMMENT_IDENTIFIER;
    mfeEnhMF.iComment   = MFCOMMENT_ENHANCED_METAFILE;
    mfeEnhMF.nVersion   = ((PENHMETAHEADER) pLocalDC->pMf32Bits)->nVersion;
    mfeEnhMF.wChecksum  = 0;   // updated by bMemUpdateCheckSum
    mfeEnhMF.fFlags     = 0;
    mfeEnhMF.nCommentRecords
    = (pLocalDC->cMf32Bits + MAX_WIN32_COMMENT_REC_SIZE - 1)
      / MAX_WIN32_COMMENT_REC_SIZE;
    mfeEnhMF.cbEnhMetaFile = pLocalDC->cMf32Bits;

    mfeEnhMF.cbRemainder = pLocalDC->cMf32Bits;
    i = 0 ;
    while (mfeEnhMF.cbRemainder)
    {
    mfeEnhMF.cbCurrent = min(mfeEnhMF.cbRemainder, MAX_WIN32_COMMENT_REC_SIZE);
    mfeEnhMF.rdSize = (sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent) / 2;
    mfeEnhMF.wCount = (WORD)(sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent - sizeof(METARECORD_ESCAPE));
    mfeEnhMF.cbRemainder -= mfeEnhMF.cbCurrent;

    b = bEmitWin16EscapeEnhMetaFile(pLocalDC,
        (PMETARECORD_ESCAPE) &mfeEnhMF, &pLocalDC->pMf32Bits[i]);

    if (!b)
        break;
    i += mfeEnhMF.cbCurrent;
    }

    return(b) ;
}


/*****************************************************************************
 * bMemUpdateCheckSum - Update the checksum
 *****************************************************************************/
BOOL bMemUpdateCheckSum(PLOCALDC pLocalDC)
{
INT         i, k ;
PWORD       pword ;
WORD        CheckSum ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;


    // CheckSum the file.
    // Do a 16 bit checksum

    pword = (PWORD) pLocalDC->pMf16Bits ;
    k = pLocalDC->ulBytesEmitted / 2 ;

    CheckSum = 0 ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    // Update the checksum record value with the real checksum.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
            &pLocalDC->pMf16Bits[sizeof(METAHEADER)];

    ASSERTGDI(IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)
       && pmfeEnhMF->wChecksum  == 0
       && pmfeEnhMF->fFlags     == 0,
    "MF3216: bMemUpdateCheckSum: Bad pmfeEnhMF");

    pmfeEnhMF->wChecksum = -CheckSum;

#if DBG
    // Now test the checksum.  The checksum of the entire file
    // should be 0.

    CheckSum = 0 ;
    pword = (PWORD) pLocalDC->pMf16Bits ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    if (CheckSum != 0)
    {
    RIP("MF3216: MemUpdateCheckSum, (CheckSum != 0)\n") ;
    }
#endif
    return (TRUE) ;
}


/******************************Public*Routine******************************\
* Mf3216DllInitialize                                                      *
*                                                                          *
* This is the init procedure for MF3216.DLL,                               *
* which is called each time a new                                          *
* process links to it.                                                     *
\**************************************************************************/

BOOL Mf3216DllInitialize(PVOID pvDllHandle, DWORD ulReason, PCONTEXT pcontext)
{



        NOTUSED(pvDllHandle) ;
        NOTUSED(pcontext) ;

        if ( ulReason == DLL_PROCESS_ATTACH )
        {
            // This does the critical section initialization for a single
            // process.  Each process does this.  The CriticalSection data
            // structure is one of the very few (if not the only one) data
            // structures in the data segment.

            InitializeCriticalSection(&CriticalSection) ;
        }
        else if ( ulReason == DLL_PROCESS_DETACH )
        {
            DeleteCriticalSection(&CriticalSection) ;
        }

        return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\debug.h ===
/*************************************************************************\
* Module Name: debug.h
*
*   This module contains debug support definitions
*   The debug support is Win32 specific.  It does not use NT base functions.
*
* Created: 13-June-1991 9:50:00
* Author: Jeffrey Newman c-jeffn
*
* Copyright (c) Microsoft Corporation
\*************************************************************************/

#ifndef _DEBUG_
#define _DEBUG_

//Turn on firewalls unless we are told not to.

void DbgBreakPoint();
DWORD DbgPrint(PSZ Format, ...);

// Define the RIP and ASSERT macros.

#ifdef  RIP
#undef  RIP
#endif

#ifdef  ASSERTGDI
#undef  ASSERTGDI
#endif

#ifdef  PUTS
#undef  PUTS
#endif

#ifdef  USE
#undef  USE
#endif

#if DBG
#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) {if(!(x)) RIP(y)}
#define PUTS(x) DbgPrint(x)
#define PUTS1(x, p1) DbgPrint(x, p1)
#define USE(x)  x = x
#define NOTUSED(a) USE(a)
#define EMFVALFAIL(x) DbgPrint x
#else
#define RIP(x)
#define ASSERTGDI(x,y)
#define PUTS(x)
#define PUTS1(x, p1)
#define USE(x)
#define NOTUSED(a)
#define EMFVALFAIL(x) DbgPrint x
#endif  

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\bitmaps.c ===
/*****************************************************************************
 *
 * bitmaps - Entry points for Win32 to Win 16 converter
 *
 * History:
 *  Sep 1992    -by-    Hock San Lee    [hockl]
 * Big rewrite.
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

HDC hdcMakeCompatibleDC(LPXFORM lpxform);

HBITMAP CreateMonoDib(LPBITMAPINFO pbmi, CONST BYTE * pjBits, UINT iUsage);

BOOL bEmitBitmap(PLOCALDC pLocalDC, HBITMAP hbm,
        LONG xDst, LONG yDst, LONG cxDst, LONG cyDst,
        LONG xSrc, LONG ySrc, LONG cxSrc, LONG cySrc, DWORD rop);

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
);

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
);

BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
);



/***************************************************************************
 * SetDIBitsToDevice - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR2: Notes...
 *      The xDib, yDib, cxDib, & cyDib are in device units.  These must be
 *      converted to logical units for the stretchblt.
 **************************************************************************/
BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
)
{
    BOOL    b ;
    LPBITMAPINFO pbmi;
    POINTL       ptlDst;
    RECTL        rclDst;
    LONG         height;

    b = FALSE;

    if (!cbBitmapInfo)
    return(FALSE);

    // Adjust the height of the bitmap we're going to Blt.

    pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (pbmi == (LPBITMAPINFO) NULL)
        goto dsdbd_exit;

    RtlCopyMemory(pbmi, lpBitmapInfo, cbBitmapInfo);
    pbmi->bmiHeader.biHeight = cScans;
    pbmi->bmiHeader.biSizeImage = cbBits;

// We will convert it into a StretchBlt call.  But first we have to
// transform the destination rectangle.  In SetDIBitsToDevice, the destination
// rectangle is in device units but in StretchBlt, it is in logical units.

// Transform the destination origin to the device units on the original device.

    ptlDst.x = xDst;
    ptlDst.y = yDst;
    if (!bXformRWorldToRDev(pLocalDC, &ptlDst, 1))
        goto dsdbd_exit;

// Transform the destination rectangle to record time world coordinates.

    rclDst.left   = ptlDst.x;
    rclDst.top    = ptlDst.y;
    rclDst.right  = ptlDst.x + cxDib;
    rclDst.bottom = ptlDst.y + cyDib;
    if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &rclDst, 2))
        goto dsdbd_exit;

    // WINBUG #99421 4-17-2000 bhouse Top-Down DIBs are not supported properly
    // We need to check for negative heights and adjust appropriately
    height = ABS(pbmi->bmiHeader.biHeight);

    b = DoStretchBlt
    (
        pLocalDC,
        rclDst.left,
        rclDst.top,
        rclDst.right - rclDst.left,
        rclDst.bottom - rclDst.top,
        SRCCOPY,
        xDib,
                    // dib to bitmap units
        height - yDib - cyDib + (LONG) iStartScan,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        pbmi,
        cbBitmapInfo,
        lpBits,
        cbBits
    );

dsdbd_exit:
    if (pbmi)
        LocalFree(pbmi);

    return(b);
}


/***************************************************************************
 * StretchDIBits - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
)
{
    BOOL    b ;
    LONG    height;

    // WINBUG #99421 4-17-2000 bhouse Top-Down DIBs are not supported properly
    // We need to check for negative heights and adjust appropriately
    height = ABS(lpBitmapInfo->bmiHeader.biHeight);

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xDib,
            ISSOURCEINROP3(rop)
                    // dib to bitmap units
          ? height  - yDib - cyDib
          : 0,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

        return(b) ;
}


/***************************************************************************
 *  StretchBltAlt
 **************************************************************************/
BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
)
{
BITMAPINFOHEADER bmih;
DWORD            cbBitmapInfo;
LPBITMAPINFO     lpBitmapInfo;
DWORD            cbBits;
LPBYTE           lpBits;
BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    if (!ISSOURCEINROP3(rop))
        return
        (
        DoStretchBlt
        (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            rop,
            0,
            0,
            0,
            0,
            (PXFORM) NULL,
            0,
            (PBITMAPINFO) NULL,
            0,
            (LPBYTE) NULL,
            0
        )
        );

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;

    if (!GetDIBits(hdcSrc,
               hbmSrc,
               0,
               0,
               (LPBYTE) NULL,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
        goto dsba_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biBitCount == 16 || bmih.biBitCount == 32)
        cbBitmapInfo += 3 * sizeof(DWORD);
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
            cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
                    ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto dsba_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto dsba_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(hdcSrc,
               hbmSrc,
               0,
               (UINT) bmih.biHeight,
               lpBits,
               lpBitmapInfo,
               DIB_RGB_COLORS))
        goto dsba_exit;

    // Call DoStretchBlt.

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        DIB_RGB_COLORS,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsba_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
 *  StretchBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
)
{
BOOL    b;
RECTL   rclDst,
        rclSrc;

// Handle strange destination transform separately.

    if (pLocalDC->flags & STRANGE_XFORM)
        return
        (
        DoRotatedStretchBlt
        (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            rop,
            xSrc,
            ySrc,
            cxSrc,
            cySrc,
            pxformSrc,
            iUsageSrc,
            lpBitmapInfo,
            cbBitmapInfo,
            lpBits
        )
        );

// Do stretchblt with a simple destination transform.

    // Translate the dest rectangle

    rclDst.left   = xDst;
    rclDst.top    = yDst;
    rclDst.right  = xDst + cxDst;
    rclDst.bottom = yDst + cyDst;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rclDst, 2))
        return(FALSE);

// Handle stretchblt without source

    if (!ISSOURCEINROP3(rop))
    {
        // Emit the Win16 metafile record.

        b = bEmitWin16BitBltNoSrc(pLocalDC,
                      (SHORT) rclDst.left,
                      (SHORT) rclDst.top,
                      (SHORT) (rclDst.right - rclDst.left),
                      (SHORT) (rclDst.bottom - rclDst.top),
                      rop);
        return(b);
    }

// Handle stretchblt with source

        // Note: Both Win32 and Win16 DIB Bitmaps are DWord aligned.

        // Make sure the source xform is valid.
        // The source is not allowed to have a rotation or shear.

        if (bRotationTest(pxformSrc) == TRUE)
        {
            RIP("MF3216: DoStretchBlt - Invalid source xform\n");
            SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
        }

    // Translate the source rectangle.  Win3.1 assumes that the
    // source rectangle is in bitmap units.

    rclSrc.left   = xSrc;
    rclSrc.top    = ySrc;
    rclSrc.right  = xSrc + cxSrc;
    rclSrc.bottom = ySrc + cySrc;
    if (!bXformWorkhorse((PPOINTL) &rclSrc, 2, pxformSrc))
        return(FALSE);

// The win3.1 StretchBlt metafile record only accepts win3.1 standard
// bitmap with DIB_RGB_COLORS usage.  If this is not the case, we have
// to convert it to a standard bitmap.

    if (iUsageSrc != DIB_RGB_COLORS
     || lpBitmapInfo->bmiHeader.biPlanes != 1
     || !(lpBitmapInfo->bmiHeader.biBitCount == 1
       || lpBitmapInfo->bmiHeader.biBitCount == 4
       || lpBitmapInfo->bmiHeader.biBitCount == 8
       || lpBitmapInfo->bmiHeader.biBitCount == 24)
     || lpBitmapInfo->bmiHeader.biCompression != BI_RGB)
    {
        HBITMAP hbmSrc;
        DWORD fdwInit;

        b = FALSE;
        hbmSrc = (HBITMAP) 0;

        if( ( lpBitmapInfo->bmiHeader.biCompression == BI_RGB ) ||
            ( lpBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS ) )
        {
            fdwInit = CBM_INIT | CBM_CREATEDIB;
        }
        else
        {
            fdwInit = CBM_INIT;
        }

// Create the source bitmap.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(
                pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) lpBitmapInfo,
                fdwInit,
                lpBits,
                lpBitmapInfo,
                (UINT) iUsageSrc)))
        goto dsb_internal_exit;

// Emit the bitmap.

        b = bEmitBitmap(pLocalDC,
                hbmSrc,
                rclDst.left,
                rclDst.top,
                rclDst.right - rclDst.left,
                rclDst.bottom - rclDst.top,
                rclSrc.left,
                rclSrc.top,
                rclSrc.right - rclSrc.left,
                rclSrc.bottom - rclSrc.top,
                rop);

    dsb_internal_exit:
        if (hbmSrc)
        DeleteObject(hbmSrc);
    }
    else
    {
// Handle the standard formats.

        // Emit a Win16 metafile record.

        // Recalculate size of bitmap info with color
        // table to trim any extra data that wouldn't
        // be skipped properly during playback.

        cbBitmapInfo = lpBitmapInfo->bmiHeader.biSize;

        if (lpBitmapInfo->bmiHeader.biClrUsed <= 256)
            cbBitmapInfo += lpBitmapInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD);
        else if (lpBitmapInfo->bmiHeader.biBitCount < 16)
            cbBitmapInfo += (1 << lpBitmapInfo->bmiHeader.biBitCount) * sizeof(RGBQUAD);

        b = bEmitWin16StretchBlt(pLocalDC,
                (SHORT) rclDst.left,
                (SHORT) rclDst.top,
                (SHORT) (rclDst.right - rclDst.left),
                (SHORT) (rclDst.bottom - rclDst.top),
                (SHORT) rclSrc.left,
                (SHORT) rclSrc.top,
                (SHORT) (rclSrc.right - rclSrc.left),
                (SHORT) (rclSrc.bottom - rclSrc.top),
                rop,
                lpBitmapInfo,
                cbBitmapInfo,
                lpBits,
                cbBits);
    }

    return(b);
}

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
)
{
BOOL    b;
POINTL  aptlDst[4];
RECTL   rclBndDst;
HDC     hdcShadow, hdcSrc;
HBITMAP hbmShadow, hbmShadowOld, hbmSrc, hbmSrcOld;
PBITMAPINFO pbmiShadow;

    b = FALSE;
    hdcShadow = hdcSrc = (HDC) 0;
    hbmShadow = hbmShadowOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;
    pbmiShadow = (PBITMAPINFO) NULL;

// First, compute the bounds of the destination rectangle.

    aptlDst[0].x = xDst;
    aptlDst[0].y = yDst;
    aptlDst[1].x = xDst + cxDst;
    aptlDst[1].y = yDst;
    aptlDst[2].x = xDst + cxDst;
    aptlDst[2].y = yDst + cyDst;
    aptlDst[3].x = xDst;
    aptlDst[3].y = yDst + cyDst;

    if (!bXformRWorldToPPage(pLocalDC, aptlDst, 4))
        goto drsb_exit;

    rclBndDst.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndDst.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

// Prepare the source if any.

    if (ISSOURCEINROP3(rop))
    {
// Create a compatible shadow DC with the destination transform.

        if (!(hdcShadow = hdcMakeCompatibleDC(&pLocalDC->xformRWorldToPPage)))
        goto drsb_exit;

// Create a shadow bitmap the size of the destination rectangle bounds.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        pbmiShadow = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
        if (pbmiShadow == (PBITMAPINFO) NULL)
        goto drsb_exit;
        RtlCopyMemory(pbmiShadow, lpBitmapInfo, cbBitmapInfo);
        pbmiShadow->bmiHeader.biWidth  = rclBndDst.right - rclBndDst.left;
        pbmiShadow->bmiHeader.biHeight = rclBndDst.bottom - rclBndDst.top;
        pbmiShadow->bmiHeader.biSizeImage = 0;
        if (!(hbmShadow = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) pbmiShadow, CBM_CREATEDIB,
            (LPBYTE) NULL, pbmiShadow, iUsageSrc)))
        goto drsb_exit;

// Select the bitmap.

        if (!(hbmShadowOld = (HBITMAP) SelectObject(hdcShadow, hbmShadow)))
        goto drsb_exit;

// Create a compatible source DC with the given source transform.

        if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
        goto drsb_exit;

// Create the source bitmap.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) lpBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                lpBits,
                (LPBITMAPINFO) lpBitmapInfo,
                (UINT) iUsageSrc)))
        goto drsb_exit;

// Select the bitmap.

        if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
        goto drsb_exit;

// Set up the viewport origin of the shadow DC so that the destination
// rectangle will map into coordinates within the shadow bitmap.

        OffsetViewportOrgEx(hdcShadow, (int) -rclBndDst.left,
         (int) -rclBndDst.top, (LPPOINT) NULL);

// Stretch the source to the shadow.

        if (!StretchBlt
           (
               hdcShadow,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               SRCCOPY
           )
        )
        goto drsb_exit;

// Deselect the shadow bitmap.

        if (!SelectObject(hdcShadow, hbmShadowOld))
        goto drsb_exit;

    }

// Save the DC so that we can restore the clipping when we are done

    if (!DoSaveDC(pLocalDC))
        goto drsb_exit;

// Set up the clipping rectangle on the destination.

        if (!DoClipRect(pLocalDC, xDst, yDst,
                        xDst + cxDst, yDst + cyDst, EMR_INTERSECTCLIPRECT))
    {
            (void) DoRestoreDC(pLocalDC, -1);
        goto drsb_exit;
    }

// Blt the shadow to the destination.

    // Emit a Win16 metafile record.

    if (ISSOURCEINROP3(rop))
        b = bEmitBitmap(pLocalDC,
                hbmShadow,
                rclBndDst.left,
                rclBndDst.top,
                rclBndDst.right - rclBndDst.left,
                rclBndDst.bottom - rclBndDst.top,
                0,
                0,
                rclBndDst.right - rclBndDst.left,
                rclBndDst.bottom - rclBndDst.top,
                rop);
    else
        b = bEmitWin16BitBltNoSrc(pLocalDC,
                (SHORT) rclBndDst.left,
                (SHORT) rclBndDst.top,
                (SHORT) (rclBndDst.right - rclBndDst.left),
                (SHORT) (rclBndDst.bottom - rclBndDst.top),
                rop);

// Restore the clipping region.

        (void) DoRestoreDC(pLocalDC, -1);

// Cleanup

drsb_exit:

    if (hbmShadowOld)
        SelectObject(hdcShadow, hbmShadowOld);
    if (hbmShadow)
        DeleteObject(hbmShadow);
    if (hdcShadow)
        DeleteDC(hdcShadow);

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hdcSrc)
        DeleteDC(hdcSrc);

    if (pbmiShadow)
        LocalFree((HANDLE) pbmiShadow);
    return(b);
}

/*****************************************************************************
 * hdcMakeCompatibleDC
 *   Create a compatible DC with the given transform.
 ****************************************************************************/
HDC hdcMakeCompatibleDC(LPXFORM lpxform)
{
HDC     hdc;

    hdc = CreateCompatibleDC((HDC) 0);
    if(hdc == 0)
    {
        RIP("MF3216: hdcMakeCompatibleDC, CreateCompatibleDC failed\n");
        return (HDC)0;
    }

    // Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdc, GM_ADVANCED);

    // Set the transform.

    if (!SetWorldTransform(hdc, lpxform))
    {
    DeleteDC(hdc);
        RIP("MF3216: hdcMakeCompatibleDC, SetWorldTransform failed\n");
    return((HDC) 0);
    }

    return(hdc);
}

/***************************************************************************
 * bEmitBitmap
 **************************************************************************/
BOOL bEmitBitmap
(
PLOCALDC pLocalDC,
HBITMAP  hbm,
LONG     xDst,
LONG     yDst,
LONG     cxDst,
LONG     cyDst,
LONG     xSrc,
LONG     ySrc,
LONG     cxSrc,
LONG     cySrc,
DWORD    rop
)
{
BITMAPINFOHEADER bmih;
DWORD            cbBitmapInfo;
LPBITMAPINFO     lpBitmapInfo;
DWORD            cbBits;
LPBYTE           lpBits;
BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;
    if (!GetDIBits(pLocalDC->hdcHelper, hbm, 0, 0,
               (LPBYTE) NULL, (LPBITMAPINFO) &bmih, DIB_RGB_COLORS))
        goto eb_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biPlanes != 1 || bmih.biBitCount == 16 || bmih.biBitCount == 32)
    {
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;
    }
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
            cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
                    ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto eb_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto eb_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) ABS(bmih.biHeight),
               lpBits,
               lpBitmapInfo,
               DIB_RGB_COLORS))
        goto eb_exit;

    // Emit the metafile record.

    b = bEmitWin16StretchBlt(pLocalDC,
                (SHORT) xDst,
                (SHORT) yDst,
                (SHORT) cxDst,
                (SHORT) cyDst,
                (SHORT) xSrc,
                (SHORT) ySrc,
                (SHORT) cxSrc,
                (SHORT) cySrc,
                rop,
                lpBitmapInfo,
                cbBitmapInfo,
                lpBits,
                cbBits);
eb_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
 *  MaskBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
)
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask, hdcSrc;
    HBITMAP hbmMask, hbmMaskOld, hbmSrc, hbmSrcOld;
    RECTL   rclMask;

    b    = FALSE;
    hdcMask = hdcSrc = (HDC) 0;
    hbmMask = hbmMaskOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

// If no mask is given, the mask is assumed to contain all 1's.
// This is equivalent to a BitBlt using the low rop.

    if (!cbBitmapInfoMask)
    return
    (
        DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop1,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        pxformSrc,
        iUsageSrc,
        lpBitmapInfoSrc,
        cbBitmapInfoSrc,
        lpBitsSrc,
        cbBitsSrc
        )
    );

// Handle MaskBlt with no source bitmap.

    if (!ISSOURCEINROP3(rop4))
    return
    (
        DoMaskBltNoSrc
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop4,
        pxformSrc,
        xMask,
        yMask,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
    );

// Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
    goto dmb_exit;

// Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdcMask, GM_ADVANCED);

// Create the mask bitmap.
// Make it as big as the source and initialize it.

    // Create the mask bitmap as big as the source bitmap.

    if (!(hbmMask = CreateBitmap((int) lpBitmapInfoSrc->bmiHeader.biWidth,
             (int) lpBitmapInfoSrc->bmiHeader.biHeight,
             1, 1, (CONST VOID *) NULL)))
    goto dmb_exit;

    // Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
    goto dmb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcMask,0,0,(int) lpBitmapInfoSrc->bmiHeader.biWidth,
        (int) lpBitmapInfoSrc->bmiHeader.biHeight,BLACKNESS))
    goto dmb_exit;

    // Compute the mask rectangle.
    // The mask bitmap is aligned against the source device rectangle.

    rclMask.left   = xSrc;
    rclMask.top    = ySrc;
    rclMask.right  = xSrc + cxDst;
    rclMask.bottom = ySrc + cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
    goto dmb_exit;

    if (rclMask.left > rclMask.right)
    rclMask.left = rclMask.right /* + 1 */;// align the mask against the left edge

    if (rclMask.top > rclMask.bottom)
    rclMask.top = rclMask.bottom /* + 1 */;// align the mask against the top edge

    // Set the mask bits.

    if (!StretchDIBits(hdcMask,
           (int) rclMask.left - xMask,
           (int) rclMask.top  - yMask,
           (int) lpBitmapInfoMask->bmiHeader.biWidth,
           (int) lpBitmapInfoMask->bmiHeader.biHeight,
           (int) 0,
           (int) 0,
           (int) lpBitmapInfoMask->bmiHeader.biWidth,
           (int) lpBitmapInfoMask->bmiHeader.biHeight,
           (CONST VOID *) lpBitsMask,
           (LPBITMAPINFO) lpBitmapInfoMask,
           (UINT) iUsageMask,
           SRCCOPY))
    goto dmb_exit;

// Set the source transform in the mask DC.

    if (!SetWorldTransform(hdcMask, pxformSrc))
    goto dmb_exit;

// Create a compatible source DC with the given source transform.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
    goto dmb_exit;

// Create the source bitmap.
// We cannot use CBM_CREATEDIB option here because index 0 does not
// neccesarily contain black and index 15 or 255 does not have to be white.
// We need a compatible bitmap that contain the standard color table so
// that we can perform the following rop operations to emulate the maskblt.
// Gdi uses rgb colors to perform rop operations in dibs, not color indices!
// The helper DC is needed to create the compatible format bitmap.

    if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
            CBM_INIT,
            lpBitsSrc,
            (LPBITMAPINFO) lpBitmapInfoSrc,
            (UINT) iUsageSrc)))
    goto dmb_exit;

// Select the bitmap.

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
    goto dmb_exit;

// We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
// separately.  For each rop, we need to go through two passes.
//
// For the low rop (mask bit 1), we use the following rop table:
//
//  P S D | R1  R2
//  ------+--------
//  0 0 0 | 0   x
//  0 0 1 | 1   x
//  0 1 0 | x   0
//  0 1 1 | x   1
//  1 0 0 | 0   x
//  1 0 1 | 1   x
//  1 1 0 | x   0
//  1 1 1 | x   1
//
// In the first pass, we AND the mask to the source bitmap to remove
// the mask 0 bits.  This is then used to get the result (R1) for the
// bitblt involving source 1's.
//
// In the second pass, we OR the NOT of the mask to the source bitmap
// to obtain the source 0 bits.  This is then used to get the result (R2)
// for the bitblt involving source 0's.

// AND the mask to the source bitmap to remove the mask 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               SRCAND))
    goto dmb_exit;

// Get the result (R1) for the bits involving source 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// OR the NOT of the mask to the source bitmap to obtain the source 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               MERGEPAINT))
    goto dmb_exit;

// Get the result (R2) for the bitblt involving source 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0x330000) | 0x880000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// For the high rop (mask bit 0), we use the following rop table:
//
//  P S D | R1  R2
//  ------+--------
//  0 0 0 | 0   x
//  0 0 1 | 1   x
//  0 1 0 | x   0
//  0 1 1 | x   1
//  1 0 0 | 0   x
//  1 0 1 | 1   x
//  1 1 0 | x   0
//  1 1 1 | x   1
//
// In the first pass, we AND the NOT of the mask to the source bitmap to remove
// the mask 1 bits.  This is then used to get the result (R1) for the
// bitblt involving source 1's.
//
// In the second pass, we OR the mask to the source bitmap
// to obtain the source 0 bits.  This is then used to get the result (R2)
// for the bitblt involving source 0's.

// Restore the source bits.

    if (!SelectObject(hdcSrc, hbmSrcOld))
    goto dmb_exit;

    if (!SetDIBits(pLocalDC->hdcHelper,
           hbmSrc,
           0,
           (UINT) lpBitmapInfoSrc->bmiHeader.biHeight,
           (CONST VOID *) lpBitsSrc,
           (LPBITMAPINFO) lpBitmapInfoSrc,
           (UINT) iUsageSrc))
    goto dmb_exit;

    if (!SelectObject(hdcSrc, hbmSrc))
    goto dmb_exit;

// AND the NOT of the mask to the source bitmap to remove the mask 1 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               0x220326))       // DSna
    goto dmb_exit;

// Get the result (R1) for the bits involving source 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0xCC0000) | 0x220000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// OR the mask to the source bitmap to obtain the source 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               SRCPAINT))
    goto dmb_exit;

// Get the result (R2) for the bitblt involving source 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

    b = TRUE;

// Cleanup.

dmb_exit:

    if (hbmMaskOld)
    SelectObject(hdcMask, hbmMaskOld);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hdcMask)
    DeleteDC(hdcMask);

    if (hbmSrcOld)
    SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
    DeleteObject(hbmSrc);
    if (hdcSrc)
    DeleteDC(hdcSrc);

    return(b);
}

/***************************************************************************
 *  MaskBltNoSrc
 **************************************************************************/
BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
)
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask;
    HBITMAP hbmMask, hbmMaskOld;
    RECTL   rclMask;
    LONG    cxMask, cyMask;

    b    = FALSE;
    hdcMask = (HDC) 0;
    hbmMask = hbmMaskOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

// When no source bitmap is required in the rop4, the mask is used
// as the source in that the low rop is applied to the corresponding
// mask 1 bits and the high rop is applied to mask 0 bits.  The source
// transform is used to determine the mask rectangle to be used.

// Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
    goto dmbns_exit;

// Create the mask bitmap.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
    goto dmbns_exit;

// Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
    goto dmbns_exit;

// Compute the mask extents.

    rclMask.left   = 0;
    rclMask.top    = 0;
    rclMask.right  = cxDst;
    rclMask.bottom = cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
    goto dmbns_exit;

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

// Align the mask rectangle.

    if (cxMask < 0)
    xMask = xMask - cxMask + 1;
    if (cyMask < 0)
    yMask = yMask - cyMask + 1;

// We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
// separately.
//
// For the low rop (mask bit 1), we use the following rop table:
//
//  P M D | R
//  ------+---
//  0 0 0 | 0
//  0 0 1 | 1
//  0 1 0 | x
//  0 1 1 | x
//  1 0 0 | 0
//  1 0 1 | 1
//  1 1 0 | x
//  1 1 1 | x
//
// The above rop will give us the result for bits that correspond to 1's
// in the mask bitmap.  The destination bits that correspond to the 0 mask
// bits will not be changed.  We effectively treat the mask as the source
// in the operation.

// Get the result (R) for the bits involving mask 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
     )
       )
    goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

// For the high rop (mask bit 0), we use the following rop table:
//
//  P M D | R
//  ------+---
//  0 0 0 | x
//  0 0 1 | x
//  0 1 0 | 0
//  0 1 1 | 1
//  1 0 0 | x
//  1 0 1 | x
//  1 1 0 | 0
//  1 1 1 | 1
//
// The above rop will give us the result for bits that correspond to 0's
// in the mask bitmap.  The destination bits that correspond to the 1 mask
// bits will not be changed.  We effectively treat the mask as the source
// in the operation.

// Get the result (R) for the bits involving mask 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
     )
       )
    goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

    b = TRUE;

// Cleanup.

dmbns_exit:

    if (hbmMaskOld)
    SelectObject(hdcMask, hbmMaskOld);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hdcMask)
    DeleteDC(hdcMask);

    return(b);
}


/***************************************************************************
 *  PlgBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoPlgBlt
(
 PLOCALDC    pLocalDC,
 PPOINTL     pptlDst,
 LONG        xSrc,
 LONG        ySrc,
 LONG        cxSrc,
 LONG        cySrc,
 PXFORM      pxformSrc,
 DWORD       iUsageSrc,
 PBITMAPINFO lpBitmapInfoSrc,
 DWORD       cbBitmapInfoSrc,
 LPBYTE      lpBitsSrc,
 DWORD       cbBitsSrc,
 LONG        xMask,
 LONG        yMask,
 DWORD       iUsageMask,
 PBITMAPINFO lpBitmapInfoMask,
 DWORD       cbBitmapInfoMask,
 LPBYTE      lpBitsMask,
 DWORD       cbBitsMask
)
{
    BOOL    b, bMask;
    DWORD   rop4;
    HDC     hdcSrc, hdcSrcRDev;
    PBITMAPINFO pbmiSrcRDev, pbmiMaskRDev;
    LPBYTE  lpBitsSrcRDev, lpBitsMaskRDev;
    DWORD   cbBitsSrcRDev, cbBitsMaskRDev;
    HBITMAP hbmMask, hbmMaskRDev, hbmSrc, hbmSrcRDev, hbmSrcOld, hbmSrcRDevOld;
    RECTL   rclBndRDev;
    POINTL  aptlDst[4];
    POINT   ptMask;
    BITMAPINFOHEADER bmihMask;

// We are going to convert the PlgBlt into a MaskBlt.  This can be done
// by converting the source and mask bitmaps to the device space of the
// recording device and then maskblt the result.

    b      = FALSE;
    hdcSrc = hdcSrcRDev = (HDC) 0;
    hbmMask = hbmMaskRDev = hbmSrc = hbmSrcRDev = hbmSrcOld = hbmSrcRDevOld = (HBITMAP) 0;
    pbmiSrcRDev = pbmiMaskRDev = (PBITMAPINFO) NULL;
    lpBitsSrcRDev = lpBitsMaskRDev = (LPBYTE) NULL;
    bMask = (cbBitmapInfoMask != 0);

    rop4 = 0xAACC0000;          // rop for MaskBlt

// First, we transform the destination parallelogram to the device space
// of the recording device.  This device parallelogram is then used in
// plgblt'ing the source and mask bitmaps to the device space of the
// recording device.

    aptlDst[0] = pptlDst[0];
    aptlDst[1] = pptlDst[1];
    aptlDst[2] = pptlDst[2];
    aptlDst[3].x = aptlDst[1].x + aptlDst[2].x - aptlDst[0].x;
    aptlDst[3].y = aptlDst[1].y + aptlDst[2].y - aptlDst[0].y;

    if (!bXformRWorldToRDev(pLocalDC, aptlDst, 4))
    goto dpb_exit;

// Find the bounding rectangle of the parallelogram in the recording
// device space.  This rectangle is used as the basis of the MaskBlt call.

    rclBndRDev.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndRDev.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

// Offset the device parallelogram to the origin.

    aptlDst[0].x -= rclBndRDev.left; aptlDst[0].y -= rclBndRDev.top;
    aptlDst[1].x -= rclBndRDev.left; aptlDst[1].y -= rclBndRDev.top;
    aptlDst[2].x -= rclBndRDev.left; aptlDst[2].y -= rclBndRDev.top;
    aptlDst[3].x -= rclBndRDev.left; aptlDst[3].y -= rclBndRDev.top;

// Create the source bitmap in the recording device space for MaskBlt.
// The size of the source bitmap is that of rclBndRDev.
// The source image is then plgblt'd into the device parallelogram.
// PlgBlt always takes a source bitmap.

    // Create the original source.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
    goto dpb_exit;

    if (!(hbmSrc = CreateDIBitmap(hdcSrc,
            (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
            CBM_INIT | CBM_CREATEDIB,
            lpBitsSrc,
            (LPBITMAPINFO) lpBitmapInfoSrc,
            (UINT) iUsageSrc)))
    goto dpb_exit;

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
    goto dpb_exit;

    // Create the source for MaskBlt.

    if (!(hdcSrcRDev = CreateCompatibleDC((HDC) 0)))
    goto dpb_exit;

    pbmiSrcRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoSrc);
    if (pbmiSrcRDev == (PBITMAPINFO) NULL)
    goto dpb_exit;
    RtlCopyMemory(pbmiSrcRDev, lpBitmapInfoSrc, cbBitmapInfoSrc);
    pbmiSrcRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiSrcRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiSrcRDev->bmiHeader.biSizeImage = 0;
    if (!(hbmSrcRDev = CreateDIBitmap(hdcSrcRDev, (LPBITMAPINFOHEADER) pbmiSrcRDev,
            CBM_CREATEDIB, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc)))
    goto dpb_exit;

    if (!(hbmSrcRDevOld = (HBITMAP) SelectObject(hdcSrcRDev, hbmSrcRDev)))
    goto dpb_exit;

    // PlgBlt the original source bitmap into the source bitmap for MaskBlt.

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
    goto dpb_exit;

// Retrieve the source bits for MaskBlt.

    // Get biSizeImage!

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, 0, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc))
    goto dpb_exit;

    // Compute size of the buffer required for source bits.

    if (pbmiSrcRDev->bmiHeader.biSizeImage)
    cbBitsSrcRDev = pbmiSrcRDev->bmiHeader.biSizeImage;
    else
        cbBitsSrcRDev = CJSCAN(pbmiSrcRDev->bmiHeader.biWidth,
                   pbmiSrcRDev->bmiHeader.biPlanes,
                   pbmiSrcRDev->bmiHeader.biBitCount)
             * ABS(pbmiSrcRDev->bmiHeader.biHeight);

    lpBitsSrcRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsSrcRDev);
    if (lpBitsSrcRDev == (LPBYTE) NULL)
    goto dpb_exit;

    // Get the source bits.

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, (UINT) pbmiSrcRDev->bmiHeader.biHeight,
           lpBitsSrcRDev, pbmiSrcRDev, iUsageSrc))
    goto dpb_exit;

// Create the mask bitmap in the recording device space for MaskBlt.
// The size of the mask bitmap is that of rclBndRDev.
// The mask image is then plgblt'd into the device parallelogram.
// If a mask is not given, create one that describes the parallelogram
// for the source.

    if (bMask)
    {
    // Create the original mask.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
        goto dpb_exit;

    if (!SelectObject(hdcSrc, hbmMask))
        goto dpb_exit;
    }
    else
    {
    // Create a mask describing the original source bitmap.

    ASSERTGDI(sizeof(BITMAPINFOHEADER) == 0x28,
        "MF3216: DoPlgBlt, BITMAPINFOHEADER has changed!\n");

    iUsageMask       = DIB_PAL_INDICES;
    cbBitmapInfoMask = 0x28;
    lpBitmapInfoMask = (PBITMAPINFO) &bmihMask;

    bmihMask.biSize          = 0x28;
    bmihMask.biWidth         = lpBitmapInfoSrc->bmiHeader.biWidth;
    bmihMask.biHeight        = lpBitmapInfoSrc->bmiHeader.biHeight;
    bmihMask.biPlanes        = 1;
    bmihMask.biBitCount      = 1;
    bmihMask.biCompression   = BI_RGB;
    bmihMask.biSizeImage     = 0;
    bmihMask.biXPelsPerMeter = 0;
    bmihMask.biYPelsPerMeter = 0;
    bmihMask.biClrUsed       = 0;
    bmihMask.biClrImportant  = 0;

    if (!(hbmMask = CreateBitmap((int) bmihMask.biWidth,
             (int) bmihMask.biHeight, 1, 1, (CONST VOID *) NULL)))
        goto dpb_exit;

    if (!SelectObject(hdcSrc, hbmMask))
        goto dpb_exit;

    // Initialize the mask bitmap to 1's.

    if (!PatBlt(hdcSrc,0,0,(int)bmihMask.biWidth,(int)bmihMask.biHeight,WHITENESS))
        goto dpb_exit;
    }

    // Create the mask for MaskBlt.

    pbmiMaskRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoMask);
    if (pbmiMaskRDev == (PBITMAPINFO) NULL)
    goto dpb_exit;
    RtlCopyMemory(pbmiMaskRDev, lpBitmapInfoMask, cbBitmapInfoMask);
    pbmiMaskRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiMaskRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiMaskRDev->bmiHeader.biSizeImage = 0;
    pbmiMaskRDev->bmiHeader.biCompression = BI_RGB;
    if (!(hbmMaskRDev = CreateBitmap(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biHeight, 1, 1, (CONST VOID *) NULL)))
    goto dpb_exit;

    if (!SelectObject(hdcSrcRDev, hbmMaskRDev))
    goto dpb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcSrcRDev,0,0,(int)pbmiMaskRDev->bmiHeader.biWidth,
        (int)pbmiMaskRDev->bmiHeader.biHeight,BLACKNESS))
    goto dpb_exit;

    // PlgBlt the original mask bitmap into the mask bitmap for MaskBlt.

    if (bMask)
    {
    ptMask.x = xMask;
    ptMask.y = yMask;
    if (!DPtoLP(hdcSrc, &ptMask, 1))
        goto dpb_exit;
    }
    else
    {
    ptMask.x = xSrc;
    ptMask.y = ySrc;
    }

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, ptMask.x, ptMask.y, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
    goto dpb_exit;

// Retrieve the mask bits for MaskBlt.

    // Compute size of the buffer required for mask bits.

    cbBitsMaskRDev = CJSCAN(pbmiMaskRDev->bmiHeader.biWidth,
                pbmiMaskRDev->bmiHeader.biPlanes,
                pbmiMaskRDev->bmiHeader.biBitCount)
              * ABS(pbmiMaskRDev->bmiHeader.biHeight);

    lpBitsMaskRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsMaskRDev);
    if (lpBitsMaskRDev == (LPBYTE) NULL)
    goto dpb_exit;

    // Get the mask bits.

    if (!GetDIBits(hdcSrcRDev, hbmMaskRDev, 0, (UINT) pbmiMaskRDev->bmiHeader.biHeight,
           lpBitsMaskRDev, pbmiMaskRDev, iUsageMask))
    goto dpb_exit;

// Prepare for the MaskBlt.
// The destination for the MaskBlt is rclBndRDev.  Since the extents for
// the destination and source share the same logical values in MaskBlt,
// we have to set the transform in the destination DC to identity.

    // Save the DC so that we can restore the transform when we are done

    if (!DoSaveDC(pLocalDC))
    goto dpb_exit;

    // Set the transforms to identity.

    if (!DoSetMapMode(pLocalDC, MM_TEXT)
     || !DoModifyWorldTransform(pLocalDC, (PXFORM) NULL, MWT_IDENTITY)
     || !DoSetWindowOrg(pLocalDC, 0, 0)
     || !DoSetViewportOrg(pLocalDC, 0, 0))
    goto dpb_restore_exit;

// Now do the MaskBlt.

    b = DoMaskBlt
    (
        pLocalDC,
        rclBndRDev.left,        // xDst
        rclBndRDev.top,     // yDst
        rclBndRDev.right - rclBndRDev.left + 1,
        rclBndRDev.bottom - rclBndRDev.top + 1,
        rop4,
        0,              // xSrc
        0,              // ySrc
        &xformIdentity,
        iUsageSrc,
        pbmiSrcRDev,
        cbBitmapInfoSrc,
        lpBitsSrcRDev,
        cbBitsSrcRDev,
        0,              // xMask
        0,              // yMask
        iUsageMask,
        pbmiMaskRDev,
        cbBitmapInfoMask,
        lpBitsMaskRDev,
        cbBitsMaskRDev
    );

// Restore the transforms.

dpb_restore_exit:

    (void) DoRestoreDC(pLocalDC, -1);

// Cleanup.

dpb_exit:

    if (hbmSrcOld)
    SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrcRDevOld)
    SelectObject(hdcSrcRDev, hbmSrcRDevOld);

    if (hbmSrc)
    DeleteObject(hbmSrc);
    if (hbmSrcRDev)
    DeleteObject(hbmSrcRDev);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hbmMaskRDev)
    DeleteObject(hbmMaskRDev);

    if (hdcSrc)
    DeleteDC(hdcSrc);
    if (hdcSrcRDev)
    DeleteDC(hdcSrcRDev);

    if (pbmiSrcRDev)
    LocalFree((HANDLE) pbmiSrcRDev);
    if (pbmiMaskRDev)
    LocalFree((HANDLE) pbmiMaskRDev);
    if (lpBitsSrcRDev)
    LocalFree((HANDLE) lpBitsSrcRDev);
    if (lpBitsMaskRDev)
    LocalFree((HANDLE) lpBitsMaskRDev);

    return(b);
}


/***************************************************************************
 *  SetPixel  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPixel
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor
)
{
POINTL  ptl ;
BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
        if (b == FALSE)
            goto exit1 ;

    b = bEmitWin16SetPixel(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor) ;
exit1:
    return(b) ;
}


/***************************************************************************
 *  SetStretchBltMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetStretchBltMode
(
 PLOCALDC  pLocalDC,
 DWORD   iStretchMode
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetStretchBltMode(pLocalDC, LOWORD(iStretchMode)) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\beziers.c ===
/*****************************************************************************
 *
 * beziers - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType) ;


/***************************************************************************
 *  PolyDraw  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyDraw
(
PLOCALDC pLocalDC,
LPPOINT pptl,
PBYTE   pb,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, pb, cptl, EMR_POLYDRAW));
}

/***************************************************************************
 *  PolyBezier  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezier
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIER));
}

/***************************************************************************
 *  PolyBezierTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezierTo
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIERTO));
}

/***************************************************************************
 *  PolyBezierCommon  - Common code for PolyDraw, PolyBezier and PolyBezierTo
 **************************************************************************/
BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType)
{
BOOL    b ;

// If we're recording the drawing order for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            switch (mrType)
            {
                case EMR_POLYBEZIER:
                    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYBEZIERTO:
                    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYDRAW:
                    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                    break ;

		default:
                    b = FALSE;
	            RIP("MF3216: PolyBezierCommon, bad mrType\n") ;
                    break ;
            }

            ASSERTGDI(b, "MF3216: PolyBezierCommon, in path render failed\n") ;
            return (b) ;
        }

// Call the common curve renderer.

	return
	(
	    bRenderCurveWithPath(pLocalDC, pptl, pb, cptl,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, mrType)
	);
}


/***************************************************************************
 *  bRenderCurveWithPath - Renders a curve or area using the path api.
 *     The supported curves and areas are PolyDraw, PolyBezier, PolyBezierTo,
 *     AngleArc, Arc, Chord, Pie, Ellipse, Rectangle, and RoundRect.
 **************************************************************************/
BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
)
{
    BOOL     b;
    INT      iPathType;

// We don't do curves in a path bracket here.  They should be
// taken care of by the caller.

    ASSERTGDI(!(pLocalDC->flags & RECORDING_PATH),
	"MF3216: bRenderCurveWithPath, cannot be in a path bracket\n");

// Save the helper DC first.
// This is to prevent us from accidentally deleteing the current path
// in the helper DC when we create another path to render the curve.
// E.g. BeginPath, Polyline, EndPath, PolyBezier, StrokePath.

    if (!SaveDC(pLocalDC->hdcHelper))
    {
	RIP("MF3216: bRenderCurveWithPath, SaveDC failed\n");
	return(FALSE);
    }

// Create the path for the curve and stroke it.
// Be careful not to modify the states of the LocalDC especially in
// DoRenderPath below.
// Note that BeginPath uses the previous current position.  So this
// code will work correctly in the case of PolyBezierTo, PolyDraw
// and AngleArc.

    // Begin the path.

    b = BeginPath(pLocalDC->hdcHelper);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, BeginPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // Do the curve.

    switch (mrType)
    {
	case EMR_POLYBEZIER:
	    iPathType = EMR_STROKEPATH;
	    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl);
	    break;

	case EMR_POLYBEZIERTO:
	    iPathType = EMR_STROKEPATH;
	    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl);
	    break;

	case EMR_POLYDRAW:
	    iPathType = EMR_STROKEPATH;
	    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl);
	    break;

	case EMR_ANGLEARC:
	    iPathType = EMR_STROKEPATH;
	    b = AngleArc(pLocalDC->hdcHelper, x1, y1, nRadius, eStartAngle, eSweepAngle);
	    break;

	case EMR_ARC:
	    iPathType = EMR_STROKEPATH;
	    b = Arc(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4);
	    break;

	case EMR_CHORD:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Chord(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4);
	    break;

	case EMR_PIE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Pie(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
	    break;

	case EMR_ELLIPSE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Ellipse(pLocalDC->hdcHelper, x1, y1, x2, y2);
	    break;

	case EMR_RECTANGLE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Rectangle(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
	    break;

	case EMR_ROUNDRECT:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = RoundRect(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3) ;
	    break;

	default:
            b = FALSE;
	    RIP("MF3216: bRenderCurveWithPath, bad mrType");
	    break;
    }

    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, render failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // End the path

    b = EndPath(pLocalDC->hdcHelper);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, EndPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // Stroke or fill the path.

    b = DoRenderPath(pLocalDC, iPathType);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, DoRenderPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

exit_bRenderCurveWithPath:

// Restore the helper DC.

    if (!RestoreDC(pLocalDC->hdcHelper, -1))
	ASSERTGDI(FALSE, "MF3216: bRenderCurveWithPath, RestoreDC failed\n") ;

// If this is a PolyBezeirTo, PolyDraw or AngleArc, make the call to the
// helper DC to update its current position.

    if (b)
    {
	switch (mrType)
	{
	    case EMR_POLYBEZIER:
	    case EMR_ARC:
	    case EMR_CHORD:
	    case EMR_PIE:
	    case EMR_ELLIPSE:
	    case EMR_RECTANGLE:
	    case EMR_ROUNDRECT:	// no need to update the helper DC
		break ;

	    case EMR_POLYBEZIERTO:
		(void) PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
		break ;

	    case EMR_POLYDRAW:
		(void) PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
		break ;

	    case EMR_ANGLEARC:
		(void) AngleArc(pLocalDC->hdcHelper, x1, y1, nRadius, eStartAngle, eSweepAngle);
		break ;

	    default:
		RIP("MF3216: bRenderCurveWithPath, bad mrType");
		break;
	}
    }

// Return the result.

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\emit.c ===
/*****************************************************************************
 *
 * emit - Emit routines for MF3216
 *
 * Date: 7/17/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 *  01-Feb-1992     -by-        c-jeffn
 *
 *      Major code cleanup from Code review 1.
 *
 * Copyright (c) 1991,92 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*----------------------------------------------------------------------------
 *  Emit (copy) nCount Bytes in pBuffer to the user supplied output buffer.
 *
 *  If this is a size only request, send the bits to the bit-bucket and
 *  just keep track of the size.
 *
 *  Note: ERROR_BUFFER_OVERFLOW flag is set in pLocalDC if output buffer
 *  is overrun.
 *---------------------------------------------------------------------------*/
BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount)
{
BOOL    b ;
UINT    ulBytesEmitted ;

        b = TRUE ;

        // Test for a size only request.

        if (!(pLocalDC->flags & SIZE_ONLY))
        {
            ulBytesEmitted = pLocalDC->ulBytesEmitted ;
            if ((ulBytesEmitted + nCount) <= pLocalDC->cMf16Dest)
            {
                memcpy(&(pLocalDC->pMf16Bits[ulBytesEmitted]), pBuffer, nCount) ;
                b = TRUE ;
            }
            else
            {
                // Signal output buffer overflow error.

                pLocalDC->flags |= ERR_BUFFER_OVERFLOW;
                b = FALSE ;
                RIP("MF3216: bEmit, (pLocalDC->ulBytesEmitted + nCount) > cMf16Dest \n") ;
            }


        }

        // Update the local DC byte count

        pLocalDC->ulBytesEmitted += nCount ;

        return(b) ;

}



/*----------------------------------------------------------------------------
 * Update the max record size.  Used to update the metafile header.
 *---------------------------------------------------------------------------*/
VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr)
{

    if (pLocalDC->ulMaxRecord < pmr->rdSize)
        pLocalDC->ulMaxRecord = pmr->rdSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\colors.c ===
/*****************************************************************************
 *
 * colors - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * History:
 *  Sep 1992	-by-	Hock San Lee	[hockl]
 * Complete rewrite.
 *
 *  The following implementation takes into account that all 16-bit metafile
 *  palette records reference the current palette.
 *
 *  CreatePalette
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 *  SelectPalette
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 *  RealizePalette
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 *  ResizePalette
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  SetPaletteEntries
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  DeleteObject
 *      Don't emit the 16-bit record for palettes since all palettes are
 *      deleted in SelectPalette above.  Similarly, don't emit palette delete
 *      records at the end of conversion.  However, you need to delete the
 *      private copy of the palette maintained by the converter here and at
 *      the end of conversion.
 *
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  SelectPalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 **************************************************************************/
BOOL WINAPI DoSelectPalette
(
PLOCALDC pLocalDC,
DWORD	 ihpal
)
{
BOOL	     b = FALSE;
WORD         cEntries;
LPLOGPALETTE lpLogPal = (LPLOGPALETTE) NULL;
HPALETTE     hpalW32;
INT	     ihW16, ihW32Norm;

	// No need to do anything if selecting the same palette.

	if (pLocalDC->ihpal32 == ihpal)
	    return(TRUE);

	// Validate the palette index.

	if ((ihpal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	 && (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal]))
	{
            RIP("MF3216: DoSelectPalette - ihpal invalid");
            goto error_exit;
	}

	// Get the W32 handle.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    hpalW32 = GetStockObject(DEFAULT_PALETTE) ;
	else
	    hpalW32 = pLocalDC->pW32hPal[ihpal];

        if(hpalW32 == 0)
        {
            RIP("MF3216: DoSelectPalette - hpalW32 == 0\n");
            goto error_exit;
        }
	// Emit a CreatePalette record.

	if (!GetObjectA(hpalW32, sizeof(WORD), &cEntries))
	{
	    RIP("MF3216: DoSelectPalette - GetObjectA failed\n");
            goto error_exit;
	}

	if (!(lpLogPal = (LPLOGPALETTE) LocalAlloc(
				LMEM_FIXED,
				sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
				 + sizeof(PALETTEENTRY) * cEntries)))
            goto error_exit;

	lpLogPal->palVersion    = 0x300;
        lpLogPal->palNumEntries = cEntries;

	GetPaletteEntries(hpalW32, 0, cEntries, lpLogPal->palPalEntry);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihpal, REALIZED_PALETTE);
        if (ihW16 == -1)
            goto error_exit;

	if (!bEmitWin16CreatePalette(pLocalDC, lpLogPal))
            goto error_exit;

	// Emit a SelectPalette record.

	if (!SelectPalette(pLocalDC->hdcHelper, hpalW32, TRUE))
	    goto error_exit;

	if (!bEmitWin16SelectPalette(pLocalDC, (WORD) ihW16))
	    goto error_exit;

	// Emit a DeleteObject record to delete the previous palette.

	if (pLocalDC->ihpal16 != -1)
	{
	    ihW32Norm = iNormalizeHandle(pLocalDC, pLocalDC->ihpal32);
	    if (ihW32Norm == -1)
		goto error_exit;

	    pLocalDC->pW16ObjHndlSlotStatus[pLocalDC->ihpal16].use
		= OPEN_AVAILABLE_SLOT;
	    pLocalDC->piW32ToW16ObjectMap[ihW32Norm]
		= UNMAPPED;

	    bEmitWin16DeleteObject(pLocalDC, (WORD) pLocalDC->ihpal16);
	}

	pLocalDC->ihpal32 = ihpal;
	pLocalDC->ihpal16 = ihW16;

	b = TRUE;

error_exit:

        if (lpLogPal)
	    LocalFree((HANDLE) lpLogPal);

	return(b);
}

/***************************************************************************
 *  ResizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoResizePalette
(
PLOCALDC  pLocalDC,
DWORD     ihpal,
DWORD     cEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIP("MF3216: DoResizePalette - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!ResizePalette(pLocalDC->pW32hPal[ihpal], cEntries))
	{
            RIP("MF3216: DoResizePalette - ResizePalette failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16ResizePalette(pLocalDC, (WORD) cEntries));

        return(TRUE);
}

/***************************************************************************
 *  SetPaletteEntries  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoSetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD 	       ihpal,
DWORD 	       iStart,
DWORD 	       cEntries,
LPPALETTEENTRY pPalEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIP("MF3216: DoSetPaletteEntries - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!SetPaletteEntries(pLocalDC->pW32hPal[ihpal], iStart, cEntries, pPalEntries))
	{
            RIP("MF3216: DoSetPaletteEntries - SetPaletteEntries failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16SetPaletteEntries(pLocalDC, iStart, cEntries, pPalEntries));

        return(TRUE);
}

/***************************************************************************
 *  RealizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 **************************************************************************/
BOOL WINAPI DoRealizePalette
(
PLOCALDC pLocalDC
)
{
        // Emit the Win16 metafile drawing order.

        return(bEmitWin16RealizePalette(pLocalDC));
}

/***************************************************************************
 *  CreatePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 **************************************************************************/
BOOL WINAPI DoCreatePalette
(
PLOCALDC     pLocalDC,
DWORD        ihPal,
LPLOGPALETTE lpLogPal
)
{
	if (ihPal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        {
            LOGPALETTE *lpLogPalNew;

        // Validate the palette index.

	    if (ihPal >= pLocalDC->cW32hPal || pLocalDC->pW32hPal[ihPal])
                return(FALSE);

        // Allocate size of log palette + 2 entries for black and white.

            lpLogPalNew = LocalAlloc(LMEM_FIXED, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) + sizeof(DWORD)));

            if (lpLogPalNew == NULL)
            {
                return(FALSE);
            }

            RtlMoveMemory(lpLogPalNew, lpLogPal, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) - sizeof(DWORD)));
            lpLogPalNew->palNumEntries += 2;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 1].peRed   = 0;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 1].peGreen = 0;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 1].peBlue  = 0;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 1].peFlags = 0;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 2].peRed   = 0xff;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 2].peGreen = 0xff;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 2].peBlue  = 0xff;
            lpLogPalNew->palPalEntry[lpLogPalNew->palNumEntries - 2].peFlags = 0;

        // Create a private copy of the logical palette and keep it
        // in the converter palette table.

            pLocalDC->pW32hPal[ihPal] = CreatePalette(lpLogPalNew);
            LocalFree(lpLogPalNew);

            if (!(pLocalDC->pW32hPal[ihPal]))
            {
                RIP("MF3216: DoCreatePalette - CreatePalette failed\n") ;
                return(FALSE);
            }
        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\conics.c ===
/*****************************************************************************
 *
 * conics - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


FLOAT   eRadsPerDegree = (FLOAT) (ePI / (FLOAT) 180.0) ;

BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    PPOINT pptStart, PPOINT pptEnd) ;

BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl) ;

VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl) ;


/***************************************************************************
 * DoSetArcDirection - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection)
{
        pLocalDC->iArcDirection = iArcDirection ;

        return(SetArcDirection(pLocalDC->hdcHelper, iArcDirection) != 0);
}


/***************************************************************************
 *  AngleArc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAngleArc
(
PLOCALDC pLocalDC,
int     x,
int     y,
DWORD   ulRadius,
FLOAT   eStartAngle,
FLOAT   eSweepAngle
)
{
BOOL    b ;
POINTL  aptl[4] ;
FLOAT   eEndAngle;
INT     iArcDirection;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
        b = AngleArc(pLocalDC->hdcHelper, x, y, ulRadius, eStartAngle, eSweepAngle) ;
            ASSERTGDI(b, "MF3216: DoAngleArc, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM
     || eSweepAngle >  360.0f   // more than one revolution
     || eSweepAngle < -360.0f
       )
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// Calculate the ARC bounding box.

        aptl[0].x = x - ulRadius ;
        aptl[0].y = y - ulRadius ;
        aptl[1].x = x + ulRadius ;
        aptl[1].y = y + ulRadius ;

// Calculate the begin and end points for ARC from the
// eStartAngle and eSweepAngle.

        aptl[2].x = x + (LONG) ((double) (ulRadius) * cos(eStartAngle * eRadsPerDegree) + 0.5f) ;
        aptl[2].y = y - (LONG) ((double) (ulRadius) * sin(eStartAngle * eRadsPerDegree) + 0.5f) ;

        eEndAngle = eStartAngle + eSweepAngle ;

        aptl[3].x = x + (LONG) ((double) (ulRadius) * cos(eEndAngle * eRadsPerDegree) + 0.5f) ;
        aptl[3].y = y - (LONG) ((double) (ulRadius) * sin(eEndAngle * eRadsPerDegree) + 0.5f) ;

// If the endpoints are identical, we cannot represent the AngleArc as
// an ArcTo.  Use path to render it instead.

    if (aptl[2].x == aptl[3].x && aptl[2].y == aptl[3].y)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// At this point we have the same parameters that would apply to
// a standard ArcTo.  However, we still need to determine the arc
// direction to apply.  If the sweep angle is positive, it is counter-
// clockwise.  If the sweep angle is negative, it is clockwise.

// Save the current arc direction.

        iArcDirection = pLocalDC->iArcDirection;

// Prepare the arc direction for the ArcTo.

        (void) DoSetArcDirection
        (pLocalDC, eSweepAngle < 0.0f ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

// Do the ArcTo.

        b = DoArcTo(pLocalDC, aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y,
                              aptl[2].x, aptl[2].y, aptl[3].x, aptl[3].y) ;

// Restore the current arc direction.

        (void) DoSetArcDirection(pLocalDC, iArcDirection);

        return (b) ;
}

/***************************************************************************
 *  Arc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArc
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_ARC) ;

        return(b) ;
}

/***************************************************************************
 *  ArcTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArcTo
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;
POINT   ptStart,
        ptEnd ;

    // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            b = ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
            return(b) ;
        }


        b = bFindRadialEllipseIntersection(pLocalDC,
                                           x1, y1, x2, y2,
                                           x3, y3, x4, y4,
                                           &ptStart, &ptEnd) ;
        if (b == FALSE)
            return(b) ;

        b = DoLineTo(pLocalDC, ptStart.x, ptStart.y) ;
        if (b == FALSE)
            return(b) ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;
        if (b == FALSE)
            return(b) ;

        b = DoMoveTo(pLocalDC, ptEnd.x, ptEnd.y) ;

        return(b) ;
}


/***************************************************************************
 *  Chord  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoChord
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_CHORD) ;

        return(b) ;
}


/***************************************************************************
 *  Ellipse  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEllipse
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_ELLIPSE) ;

        return(b) ;
}


/***************************************************************************
 *  Pie  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPie
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_PIE) ;

        return(b) ;
}


/***************************************************************************
 * bConicCommon - The mother of all conic translations.
 *                They are Arc, Chord, Pie, Ellipse, Rectangle and RoundRect.
 **************************************************************************/
BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                      INT x3, INT y3, INT x4, INT y4,
                                      DWORD mrType)
{
SHORT       sx1, sx2, sx3, sx4,
        sy1, sy2, sy3, sy4 ;
LONG        nPointls ;
POINTL      aptl[4] ;
BOOL        b ;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            switch(mrType)
            {
                case EMR_ARC:
                    b = Arc(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                 x3, y3, x4, y4) ;
                    break ;

                case EMR_CHORD:
                    b = Chord(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                   x3, y3, x4, y4) ;
                    break ;

                case EMR_ELLIPSE:
                    b = Ellipse(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
                    break ;

                case EMR_PIE:
                    b = Pie(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                 x3, y3, x4, y4) ;
                    break ;

                case EMR_RECTANGLE:
                    b = Rectangle(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
                    break ;

                case EMR_ROUNDRECT:
                    b = RoundRect(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3) ;
                    break ;

        default:
                    b = FALSE;
            RIP("MF3216: bConicCommon, bad mrType");
                    break ;
            }

            ASSERTGDI(b, "MF3216: bConicCommon, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x1, y1, x2, y2, x3, y3, x4, y4, 0, 0.0f, 0.0f, mrType);

        return(b);
    }

// Do the simple transform case.

        // Compute the number of points

        nPointls = (LONG) (sizeof(aptl) / sizeof(POINTL)) ;

        // Assign all the coordinates into an array for conversion.

        aptl[0].x = x1 ;
        aptl[0].y = y1 ;
        aptl[1].x = x2 ;
        aptl[1].y = y2 ;
        aptl[2].x = x3 ;
        aptl[2].y = y3 ;
        aptl[3].x = x4 ;
        aptl[3].y = y4 ;

        // Take care of the arc direction.

        switch (mrType)
        {
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
                vDoArcReflection(pLocalDC, &aptl[2]) ;
                break ;

            default:
                break ;
        }

        // Do the Record-time World to Play-time Page transformations.
        // The radial definitions need only a world to page xform,
        // and the ellipse definitions for roundrects only require
        // a magnitude transformation.

        if (mrType != EMR_ROUNDRECT)
        {
        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, nPointls) ;
            if (!b)
                goto exit1 ;
        }
        else
        {
            /*
                For roundrects do a Record-time-World to Play-time-Page
                transform of the bounding box only.  Then a magnatude only
                transform of the corner ellipse definitions.
            */

        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2) ;
            if (!b)
                goto exit1 ;

            aptl[2].x = iMagnitudeXform(pLocalDC, aptl[2].x, CX_MAG) ;
            aptl[2].y = iMagnitudeXform(pLocalDC, aptl[2].y, CY_MAG) ;
            aptl[3].x = iMagnitudeXform(pLocalDC, aptl[3].x, CX_MAG) ;
            aptl[3].y = iMagnitudeXform(pLocalDC, aptl[3].y, CY_MAG) ;
        }

        // The bounding boxes for
        // all the conics and rectangles that are handled by this
        // common routine are inclusive-inclusive, and they must
        // be transformed to the inclusive-exclusive Win16 form.

        b = bIncIncToIncExcXform(pLocalDC, (PRECTL) &aptl[0]) ;
    if (!b)
            goto exit1 ;

        // Assign the converted coordinates variables suited to
        // the Win16 metafile.

    sx1 = LOWORD(aptl[0].x) ;
    sy1 = LOWORD(aptl[0].y) ;
    sx2 = LOWORD(aptl[1].x) ;
    sy2 = LOWORD(aptl[1].y) ;
    sx3 = LOWORD(aptl[2].x) ;
    sy3 = LOWORD(aptl[2].y) ;
    sx4 = LOWORD(aptl[3].x) ;
    sy4 = LOWORD(aptl[3].y) ;

        // Emit the Win16 drawing orders to the Win16 metafile.

        switch(mrType)
        {
            case EMR_ARC:
                b = bEmitWin16Arc(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_CHORD:
                b = bEmitWin16Chord(pLocalDC, sx1, sy1, sx2, sy2,
                                              sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_ELLIPSE:
                b = bEmitWin16Ellipse(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_PIE:
                b = bEmitWin16Pie(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_RECTANGLE:
                b = bEmitWin16Rectangle(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_ROUNDRECT:
                b = bEmitWin16RoundRect(pLocalDC, sx1, sy1, sx2, sy2, sx3, sy3) ;
                break ;

        default:
        RIP("MF3216: bConicCommon, bad mrType");
                break ;
        }

exit1:
        return (b) ;
}


/*****************************************************************************
 * vDoArcReflection - Test for an inversion in the RWorld to PPage matrix.
 *                    If one and only one is found then swap the start
 *                    and  end position for the conics.
 *****************************************************************************/
VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl)
{
FLOAT   eM11,
        eM22 ;
POINTL  ptl ;
BOOL    bFlip ;

    // Win16 assumes the counter-clockwise arc direction in the
    // device coordinates.  Win32 defines the arc direction in the
    // world coordinates.

    // Assume no flipping of start and end points.

    bFlip = FALSE ;

    // Account for current arc direction.

    if (pLocalDC->iArcDirection == AD_CLOCKWISE)
        bFlip = !bFlip;

        // If there is an inversion in the xform matrix then invert
        // the arc direction.

        eM11 = pLocalDC->xformRWorldToPPage.eM11 ;
        eM22 = pLocalDC->xformRWorldToPPage.eM22 ;

        if (  (eM11 < 0.0f && eM22 > 0.0f)
            ||(eM11 > 0.0f && eM22 < 0.0f)
           )
        bFlip = !bFlip;

        // If the REQUESTED Win16 mapmode is fixed, then invert the
    // arc direction.

        switch(pLocalDC->iMapMode)
        {
            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
        bFlip = !bFlip;
                break ;
        }

    if (bFlip)
        SWAP(pptl[0], pptl[1], ptl);

        return ;
}


/*****************************************************************************
 * bIncIncToIncExcXform - Inclusize Inclusive To Inclusive Exclusize
 *                        transform in play time coordinate space.
 *****************************************************************************/
BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl)
{
LONG     l;

        // Convert the points from Playtime Page to Playtime Device space.

        if (!bXformPPageToPDev(pLocalDC, (PPOINTL) prcl, 2))
        return(FALSE);

    // Reorder the rectangle

    if (prcl->left > prcl->right)
        SWAP(prcl->left, prcl->right, l);

    if (prcl->top > prcl->bottom)
        SWAP(prcl->top, prcl->bottom, l);

        // Expand the right and bottom by one pixel.

        prcl->right++ ;
        prcl->bottom++ ;

        // Convert the points back to Playtime Page space

        return(bXformPDevToPPage(pLocalDC, (PPOINTL) prcl, 2));
}


/*****************************************************************************
 * bFindRadialEllipseIntersection - Calculate the intersection of a radial
 *                                   and an Ellipse.
 *
 *  Play the ArcTo into a path then query the path for the first and
 *  last points on the Arc.
 *****************************************************************************/
BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    LPPOINT pptStart, LPPOINT pptEnd)
{
BOOL    b;
POINT   ptCP;

    b = FALSE;          // assume failure

// Save the current position in the helper DC.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

// Do an ArcTo with the same start radial line.

        if (!ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x3, y3))
        goto exit_bFindRadialEllipseIntersection;

// Get the start point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptStart))
        goto exit_bFindRadialEllipseIntersection;

// Continue with the ArcTo with the same end radial line this time.

        if (!ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x4, y4, x4, y4))
        goto exit_bFindRadialEllipseIntersection;

// Get the end point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptEnd))
        goto exit_bFindRadialEllipseIntersection;

// Everything is golden.

    b = TRUE;

exit_bFindRadialEllipseIntersection:

// Restore the current position in the helper DC.

    if (!MoveToEx(pLocalDC->hdcHelper, ptCP.x, ptCP.y, (LPPOINT) NULL))
        RIP("MF3216: bFindRadialEllipseIntersection, MoveToEx failed");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\fonts.c ===
/*****************************************************************************
 *
 * fonts - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  ExtCreateFont  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreateFont
(
PLOCALDC  pLocalDC,
INT       ihFont,
PLOGFONTW plfw
)
{
BOOL    b ;
INT     ihW16 ;
WIN16LOGFONT Win16LogFont;

        b = FALSE;

	// Create a win16 logfont(a)

	Win16LogFont.lfHeight = (SHORT) iMagnitudeXform(pLocalDC, plfw->lfHeight, CY_MAG);
	if (plfw->lfHeight < 0)		// preserve sign
	    Win16LogFont.lfHeight = -Win16LogFont.lfHeight;
	Win16LogFont.lfWidth  = (SHORT) iMagnitudeXform(pLocalDC, plfw->lfWidth, CX_MAG);
	if (plfw->lfWidth < 0)		// preserve sign
	    Win16LogFont.lfWidth = -Win16LogFont.lfWidth;
	Win16LogFont.lfEscapement     = (SHORT) plfw->lfEscapement;
	Win16LogFont.lfOrientation    = (SHORT) plfw->lfOrientation;
	Win16LogFont.lfWeight         = (SHORT) plfw->lfWeight;
	Win16LogFont.lfItalic         = plfw->lfItalic;
	Win16LogFont.lfUnderline      = plfw->lfUnderline;
	Win16LogFont.lfStrikeOut      = plfw->lfStrikeOut;
	Win16LogFont.lfCharSet        = plfw->lfCharSet;
	Win16LogFont.lfOutPrecision   = plfw->lfOutPrecision;
	Win16LogFont.lfClipPrecision  = plfw->lfClipPrecision;
	Win16LogFont.lfQuality        = plfw->lfQuality;
	Win16LogFont.lfPitchAndFamily = plfw->lfPitchAndFamily;

        vUnicodeToAnsi((PCHAR) Win16LogFont.lfFaceName,
		       (PWCH)  plfw->lfFaceName,
		       LF_FACESIZE);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihFont, REALIZED_FONT) ;
        if (ihW16 == -1)
            goto error_exit ;

	// Create the w32 font and store it in the w16 slot table.
	// This font is needed by the helper DC for TextOut simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
	    = CreateFontIndirectW(plfw);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
	    "MF3216: CreateFontIndirectW failed");

        // Emit the Win16 CreateFont metafile record.

        b = bEmitWin16CreateFontIndirect(pLocalDC, &Win16LogFont);

error_exit:
        return(b);
}

/***************************************************************************
 *  SetMapperFlags  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetMapperFlags
(
 PLOCALDC pLocalDC,
 DWORD   f
)
{
BOOL    b ;

	// Do it to the helper DC.

	SetMapperFlags(pLocalDC->hdcHelper, (DWORD) f);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetMapperFlags(pLocalDC, f) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\entry.h ===
#ifndef _MF3216_ENTRY_
#define _MF3216_ENTRY_

BOOL APIENTRY DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection) ;
BOOL APIENTRY DoGdiComment(PLOCALDC pLocalDC, PEMR pEMR);

BOOL APIENTRY DoAngleArc
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y,
     DWORD   ulRadius,
     FLOAT   eStartAngle,
     FLOAT   eSweepAngle
) ;


BOOL APIENTRY DoArcTo
(
     PLOCALDC pLocalDC,
     int x1,
     int y1,
     int x2,
     int y2,
     int x3,
     int y3,
     int x4,
     int y4
) ;

BOOL APIENTRY DoArc
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoStretchBlt(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xSrc,
LONG         ySrc,
LONG         cxSrc,
LONG         cySrc,
PXFORM       pxformSrc,
DWORD        iUsageSrc,
PBITMAPINFO  lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
);

BOOL APIENTRY DoChord
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoEllipse
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2
) ;

BOOL APIENTRY DoExtCreateFont
(
    PLOCALDC  pLocalDC,
    INT       ihFont,
    PLOGFONTW plfw
) ;

BOOL APIENTRY DoExtFloodFill
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor,
     DWORD       iFillType
) ;

BOOL APIENTRY DoLineTo
(
     PLOCALDC  pLocalDC,
     LONG    x,
     LONG    y
) ;

BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
) ;

BOOL APIENTRY DoPlgBlt
(
    PLOCALDC	pLocalDC,
    PPOINTL	pptlDst,
    LONG	xSrc,
    LONG	ySrc,
    LONG	cxSrc,
    LONG	cySrc,
    PXFORM      pxformSrc,
    DWORD	iUsageSrc,
    PBITMAPINFO lpBitmapInfoSrc,
    DWORD       cbBitmapInfoSrc,
    LPBYTE      lpBitsSrc,
    DWORD       cbBitsSrc,
    LONG	xMask,
    LONG	yMask,
    DWORD       iUsageMask,
    PBITMAPINFO lpBitmapInfoMask,
    DWORD       cbBitmapInfoMask,
    LPBYTE      lpBitsMask,
    DWORD       cbBitsMask
) ;

BOOL APIENTRY DoMoveTo
(
     PLOCALDC pLocalDC,
     LONG    x,
     LONG    y
) ;


BOOL APIENTRY DoPie
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoPolyBezier
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyBezierTo
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL WINAPI DoPolyDraw
(
    PLOCALDC pLocalDC,
    LPPOINT pptl,
    PBYTE   pb,
    DWORD   cptl
) ;

BOOL APIENTRY DoPoly
(
     PLOCALDC pLocalDC,
     PPOINTL  pptl,
     DWORD    cptl,
     INT      mrType
) ;

BOOL APIENTRY DoPolylineTo
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyPolygon
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   cptl,
     DWORD   ccptl
) ;

BOOL APIENTRY DoPolyPolyline
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   ccptl
) ;

BOOL APIENTRY DoRectangle
(
     PLOCALDC pLocalDC,
     INT    x1,
     INT    y1,
     INT    x2,
     INT    y2
) ;

BOOL APIENTRY DoRestoreDC
(
     PLOCALDC pLocalDC,
     INT nSavedDC
) ;

BOOL APIENTRY DoRoundRect
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3
) ;

BOOL APIENTRY DoSaveDC
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSetPixel
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor
) ;

BOOL APIENTRY DoExtTextOut
(
     PLOCALDC pLocalDC,
     INT     x,                  // Initial x position
     INT     y,                  // Initial y position
     DWORD   flOpts,             // Options
     PRECTL  prcl,               // Clipping rectangle
     PWCH    awch,               // Wide Character array
     DWORD   cch,                // Character count
     PLONG   pDx,                // Character positioning
     DWORD   iGraphicsMode,	 // Graphics mode
     INT     mrType              // Either unicode or ANSI
) ;

BOOL APIENTRY DoBeginPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoEndPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoFlattenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoAbortPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoCloseFigure
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoRenderPath
(
     PLOCALDC pLocalDC,
     INT      mrType
);

BOOL APIENTRY DoWidenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoClipRect
(
 PLOCALDC pLocalDC,
 INT xLeft,
 INT yTop,
 INT xRight,
 INT yBottom,
 INT mrType
) ;

BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT	   nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
) ;

BOOL APIENTRY DoOffsetClipRgn
(
     PLOCALDC pLocalDC,
     INT x,
     INT y
) ;

BOOL APIENTRY DoSetMetaRgn
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSelectClipPath
(
     PLOCALDC pLocalDC,
     INT    iMode
) ;

BOOL APIENTRY DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
) ;

BOOL APIENTRY DoModifyWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf,
     DWORD   imode
) ;

BOOL APIENTRY DoSetMapMode
(
     PLOCALDC pLocalDC,
     DWORD   ulMapMode
) ;

BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;

BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;



BOOL APIENTRY DoSetViewportExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetViewportOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf
) ;

BOOL APIENTRY DoDeleteObject
(
     PLOCALDC pLocalDC,
     INT hObject
) ;

BOOL APIENTRY DoSelectObject
(
     PLOCALDC pLocalDC,
     LONG   ihObject
) ;

BOOL APIENTRY DoSetBkColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoSetBkMode
(
     PLOCALDC pLocalDC,
     DWORD   iBkMode
) ;

BOOL APIENTRY DoSetMapperFlags
(
     PLOCALDC pLocalDC,
     DWORD   f
) ;

BOOL APIENTRY DoSetPolyFillMode
(
     PLOCALDC pLocalDC,
     DWORD   iPolyFillMode
) ;

BOOL APIENTRY DoSetRop2
(
     PLOCALDC pLocalDC,
     DWORD   rop
) ;

BOOL APIENTRY DoSetStretchBltMode
(
     PLOCALDC pLocalDC,
     DWORD   iStretchMode
) ;

BOOL APIENTRY DoSetTextAlign
(
     PLOCALDC pLocalDC,
     DWORD   fMode
) ;

BOOL APIENTRY DoSetTextColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoCreateBrushIndirect
(
     PLOCALDC      pLocalDC,
     INT         ihBrush,
     LPLOGBRUSH  lpLogBrush
) ;

BOOL WINAPI DoCreateDIBPatternBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;

BOOL WINAPI DoCreateMonoBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;


BOOL WINAPI DoCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PLOGPEN     pLogPen
) ;

BOOL WINAPI DoExtCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PEXTLOGPEN  pExtLogPen
) ;

BOOL APIENTRY DoCreatePalette
(
    PLOCALDC	 pLocalDC,
    DWORD        ihPal,
    LPLOGPALETTE lpLogPal
) ;

BOOL APIENTRY DoSelectPalette
(
    PLOCALDC	pLocalDC,
    DWORD 	ihpal
) ;

BOOL APIENTRY DoSetPaletteEntries
(
    PLOCALDC	   pLocalDC,
    DWORD	   ihPal,
    DWORD	   iStart,
    DWORD	   cEntries,
    LPPALETTEENTRY pPalEntries
);

BOOL APIENTRY DoResizePalette
(
    PLOCALDC    pLocalDC,
    DWORD       ihpal,
    DWORD       cEntries
) ;

BOOL APIENTRY DoRealizePalette
(
    PLOCALDC	pLocalDC
);

BOOL APIENTRY DoHeader
(
    PLOCALDC pLocalDC,
    PENHMETAHEADER pemfheader
) ;

BOOL APIENTRY DoEOF
(
    PLOCALDC  pLocalDC
) ;


#endif  // _MF3216_ENTRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\mf3216\handlers.c ===
/****************************************************************************
 *  Handlers.c - Handlers for the Win32 metafile  records
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Co