 - invalid header size\n");
        return(0);
    }

    if (uiCompression == BI_BITFIELDS)
    {
        // Handle 16 and 32 bit per pel bitmaps.

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            #if DBG
                DbgPrint("GreGetBitmapSize %lu\n", uiBitCount);
            #endif
            WARNING("GreGetBitmapSize failed for BI_BITFIELDS\n");
            return(0);
        }

        if (uiHeaderSize <= sizeof(BITMAPINFOHEADER))
        {
            uiPalUsed = cColorsMax = 3;
        }
        else
        {
            //
            // masks are imbedded in BITMAPV4 +
            //

            uiPalUsed = cColorsMax = 0;
        }
    }
    else if (uiCompression == BI_RGB)
    {
        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        default:

            if (iUsage == DIB_PAL_COLORS)
            {
                iUsage = DIB_RGB_COLORS;
            }

            cColorsMax = 0;

            switch (uiBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING("GreGetBitmapSize failed invalid bitcount in bmi BI_RGB\n");
                return(0);
            }
        }
    }
    else if (uiCompression == BI_CMYK)
    {
        ASSERTGDI (iUsage == DIB_RGB_COLORS, "BI_CMYK:iUsage should be DIB_RGB_COLORS\n");

        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        case 32:
            cColorsMax = 0;
            break;
        default:
            WARNING("GreGetBitmapSize failed invalid bitcount in bmi BI_CMYK\n");
            return(0);
        }
    }
    else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
    {
        if (uiBitCount != 4)
        {
            return(0);
        }

        cColorsMax = 16;
    }
    else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
    {
        if (uiBitCount != 8)
        {
            return(0);
        }

        cColorsMax = 256;
    }
    else if ((uiCompression == BI_JPEG) || (uiCompression == BI_PNG))
    {
        cColorsMax = 0;
    }
    else
    {
        WARNING("GreGetBitmapSize failed invalid Compression in header\n");
        return(0);
    }

    if (uiPalUsed != 0)
    {
        if (uiPalUsed <= cColorsMax)
            cColors = uiPalUsed;
        else
            cColors = cColorsMax;
    }
    else
        cColors = cColorsMax;

    if (iUsage == DIB_PAL_COLORS)
        cjRGB = sizeof(USHORT);
    else if (iUsage == DIB_PAL_INDICES)
        cjRGB = 0;

    cjRet = ((cjHeader + (cjRGB * cColors)) + 3) & ~3;

    // (cjRGB * cColors) has a maximum of 256*sizeof(USHORT) so it will not
    // overflow, but we need to check the sum.

    if (cjRet < cjHeader)
        return 0;
    else
        return cjRet;

    return(((cjHeader + (cjRGB * cColors)) + 3) & ~3);
}


/******************************Public*Routine******************************\
* noOverflowCJSCAN
*
*   compute the amount of memory used by a bitmap
*
* Arguments:
*
*   ulWidth -- The width of the bitmap
*   wPlanes -- The number of color planes
*   wBitCount -- The number of bits per color
*   ulHeight -- The height of the bitmap
*
* Return Value:
*
*   The storage required (assuming each scanline is DWORD aligned) if less than
*   ULONG_MAX, 0 otherwise.
*
* History:
*
*    27-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/

ULONG
noOverflowCJSCAN(
    ULONG ulWidth,
    WORD  wPlanes,
    WORD  wBitCount,
    ULONG ulHeight
    )
{
    ULONGLONG product;

    //
    // Note that the following cannot overflow: 32+16+16=64
    // (even after adding 31!)
    //
    product = (((ULONGLONG) ulWidth) * wPlanes * wBitCount);
    product = ((product + 31) & ((ULONGLONG) ~31)) / 8;

    if (product > MAXULONG)
    {
        //
        // Already too large, final result will not fit in a ULONG
        //
        return 0;  // Overflow
    }

    product *= ulHeight;

    if (product > MAXULONG)
    {
        return 0;  // Overflow
    }
    else
    {
        return ((ULONG) product);
    }
}


/******************************Public*Routine******************************\
* noOverflowCJSCANW
*
*   compute the amount of memory used by a bitmap
*
* Arguments:
*
*   ulWidth -- The width of the bitmap
*   wPlanes -- The number of color planes
*   wBitCount -- The number of bits per color
*   ulHeight -- The height of the bitmap
*
* Return Value:
*
*   The storage required (assuming each scanline is WORD aligned) if less than
*   ULONG_MAX, 0 otherwise.
*
* History:
*
*    27-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/

ULONG
noOverflowCJSCANW(
    ULONG ulWidth,
    WORD  wPlanes,
    WORD  wBitCount,
    ULONG ulHeight
    )
{
    ULONGLONG product;

    //
    // Note that the following cannot overflow: 32+16+16=64
    // (even after adding 31!)
    //
    product = (((ULONGLONG) ulWidth) * wPlanes * wBitCount);
    product = ((product + 15) & ((ULONGLONG) ~15)) / 8;

    if (product > MAXULONG)
    {
        //
        // Already too large, final result will not fit in a ULONG
        //
        return 0;  // Overflow
    }

    product *= ulHeight;

    if (product > MAXULONG)
    {
        return 0;  // Overflow
    }
    else
    {
        return ((ULONG) product);
    }
}




/******************************Public*Routine******************************\
* GreGetBitmapBitsSize()
*
*   copied from gdi\client
*
* History:
*  20-Feb-1995 -by-  Eric Kutter [erick]
*  14-Apr-1998 FritzS make Gre call for use by ntuser
* Wrote it.
\**************************************************************************/

ULONG GreGetBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
    // Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(noOverflowCJSCAN(pbmci->bmciHeader.bcWidth,
                                pbmci->bmciHeader.bcPlanes,
                                pbmci->bmciHeader.bcBitCount,
                                pbmci->bmciHeader.bcHeight));
    }

    // not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB)  ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK)
        )
    {
        return(noOverflowCJSCAN(pbmi->bmiHeader.biWidth,
                                (WORD) pbmi->bmiHeader.biPlanes,
                                (WORD) pbmi->bmiHeader.biBitCount,
                                ABS(pbmi->bmiHeader.biHeight)));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

/******************************Public*Routine******************************\
* BOOL bCaptureBitmapInfo (LPBITMAPINFO pbmi, INT *pcjHeader)
*
* Capture the Bitmapinfo struct.  The header must be a BITMAPINFOHEADER
* or BITMAPV4HEADER
* converted at the client side already.
*
* Note: this has to be called inside a TRY-EXCEPT.
*
*  23-Mar-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL bCaptureBitmapInfo (
    LPBITMAPINFO pbmi,
    DWORD        dwUsage,
    UINT         cjHeader,
    LPBITMAPINFO *ppbmiTmp)
{
    ASSERTGDI(ppbmiTmp != NULL,"bCaptureBitmapInfo(): pbmiTmp == NULL\n");

    //
    // Make sure we have at least the biSize field of header.
    //

    if ((cjHeader < sizeof(DWORD)) || (pbmi == (LPBITMAPINFO) NULL))
    {
        WARNING("bCaptureBitmapInfo - header too small or NULL\n");
        return FALSE;
    }
    else
    {
        *ppbmiTmp = PALLOCNOZ(cjHeader,'pmtG');

        if (*ppbmiTmp)
        {
            ProbeAndReadBuffer (*ppbmiTmp,pbmi,cjHeader);

            //
            // First, make sure that cjHeader is at least as
            // big as biSize so that the captured header
            // has sufficient data for GreGetBitmapSize to use.
            // Note that the first thing GreGetBitmapSize does is
            // validate biSize, so it isn't necessary for us
            // to check cjHeader against BITMAPCOREHEADER, etc.
            //
            // Next, recompute the header size from the captured
            // header: it better still match.  Otherwise, we have
            // failed to safely capture the entire header (i.e.,
            // another thread changed the data changed during
            // capture or bogus data was passed to the API).
            //

            if (((*ppbmiTmp)->bmiHeader.biSize < sizeof(BITMAPINFOHEADER)) ||
                (cjHeader < (*ppbmiTmp)->bmiHeader.biSize) ||
                (cjHeader != GreGetBitmapSize(*ppbmiTmp, dwUsage)))
            {
                WARNING("bCapturebitmapInfo - bad header size\n");

                VFREEMEM(*ppbmiTmp);
                *ppbmiTmp = NULL;
                return FALSE;
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}

/******************************Public*Routine******************************\
* NtGdiSetDIBitsToDeviceInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  23-Mar-1995 -by-  Lingyun Wang [lingyunw]
* call CaptureBitmapInfo to convert BITMAPCOREINFO if it is so.
\**************************************************************************/

int
APIENTRY
NtGdiSetDIBitsToDeviceInternal(
    HDC          hdcDest,
    int          xDst,
    int          yDst,
    DWORD        cx,
    DWORD        cy,
    int          xSrc,
    int          ySrc,
    DWORD        iStartScan,
    DWORD        cNumScan,
    LPBYTE       pInitBits,
    LPBITMAPINFO pbmi,
    DWORD        iUsage,
    UINT         cjMaxBits,
    UINT         cjMaxInfo,
    BOOL         bTransformCoordinates,
    HANDLE       hcmXform
    )
{
    int   iRet     = 1;
    HANDLE hSecure = 0;
    ULONG cjHeader = cjMaxInfo;
    LPBITMAPINFO pbmiTmp = NULL;

    iUsage &= (DIB_PAL_INDICES | DIB_PAL_COLORS | DIB_RGB_COLORS);

    try
    {
        if (bCaptureBitmapInfo(pbmi,iUsage,cjHeader,&pbmiTmp))
        {
            if (pInitBits)
            {
                //
                // Use cjMaxBits passed in, this size takes cNumScan
                // into account. pInitBits has already been aligned
                // in user mode.
                //

                ProbeForRead(pInitBits,cjMaxBits,sizeof(DWORD));

                hSecure = MmSecureVirtualMemory(pInitBits,cjMaxBits, PAGE_READONLY);

                if (hSecure == 0)
                {
                    iRet = 0;
                }
            }
        }
        else
        {
            iRet = 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(4);
        // SetLastError(GetExceptionCode());

        iRet = 0;
    }

    // if we didn't hit an error above

    if (iRet == 1)
    {
        iRet = GreSetDIBitsToDeviceInternal(
                        hdcDest,
                        xDst,
                        yDst,
                        cx,
                        cy,
                        xSrc,
                        ySrc,
                        iStartScan,
                        cNumScan,
                        pInitBits,
                        pbmiTmp,
                        iUsage,
                        cjMaxBits,
                        cjHeader,
                        bTransformCoordinates,
                        hcmXform
                        );
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    if (pbmiTmp)
        VFREEMEM(pbmiTmp);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiPolyPolyDraw()
*
* History:
*  22-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiFastPolyPolyline(HDC, CONST POINT*, ULONG*, ULONG); // drawgdi.cxx

ULONG_PTR
APIENTRY
NtGdiPolyPolyDraw(
    HDC    hdc,
    PPOINT ppt,
    PULONG pcpt,
    ULONG  ccpt,
    int    iFunc
    )
{
    ULONG  cpt;
    PULONG pulCounts;
    ULONG_PTR ulRet = 1;
    ULONG  ulCount;
    POINT  apt[10];
    PPOINT pptTmp;

    if (ccpt > 0)
    {
        // If a PolyPolyline, first try the fast-path polypolyline code.

        if ((iFunc != I_POLYPOLYLINE) ||
            (!NtGdiFastPolyPolyline(hdc, ppt, pcpt, ccpt)))
        {
            if (ccpt > 1)
            {
                // If ccpt > 1 we cant have I_POLYLINETO/I_POLYBEZIERTO/I_POLYBEZIER
                if (iFunc == I_POLYLINETO || iFunc == I_POLYBEZIERTO || iFunc == I_POLYBEZIER)
                {
                    return 0;
                }
                //
                // make sure allocation is within reasonable limits
                //

                if (!BALLOC_OVERFLOW1(ccpt,ULONG))
                {
                    pulCounts = PALLOCNOZ(ccpt * sizeof(ULONG),'pmtG');
                }
                else
                {
                    EngSetLastError(ERROR_INVALID_PARAMETER);
                    pulCounts = NULL;
                }
            }
            else
            {
                pulCounts = &ulCount;
            }

            if (pulCounts)
            {
                pptTmp = apt;

                try
                {
                    UINT i;

                    //
                    // we did make sure ccpt * sizeof(ULONG) will not overflow
                    // in above. then here is safe.
                    //

                    ProbeAndReadBuffer(pulCounts,pcpt,ccpt * sizeof(ULONG));

                    cpt = 0;

                    for (i = 0; i < ccpt; ++i)
                        cpt += pulCounts[i];

                    // we need to make sure that the cpt array won't overflow
                    // a DWORD in terms of number of bytes

                    if (!BALLOC_OVERFLOW1(cpt,POINT))
                    {
                        if (cpt > 10)
                        {
                            pptTmp = AllocFreeTmpBuffer(cpt * sizeof(POINT));
                        }

                        if (pptTmp)
                        {
                            ProbeAndReadBuffer(pptTmp,ppt,cpt*sizeof(POINT));
                        }
                        else
                        {
                            ulRet = 0;
                        }
                    }
                    else
                    {
                        ulRet = 0;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(5);
                    // SetLastError(GetExceptionCode());

                    ulRet = 0;
                }

                if (ulRet != 0)
                {
                    switch(iFunc)
                    {
                    case I_POLYPOLYGON:
                        ulRet =
                          (ULONG_PTR) GrePolyPolygonInternal
                                  (
                                    hdc,
                                    pptTmp,
                                    (LPINT)pulCounts,
                                    ccpt,
                                    cpt
                                  );
                        break;

                    case I_POLYPOLYLINE:
                        ulRet =
                          (ULONG_PTR) GrePolyPolylineInternal
                                  (
                                    hdc,
                                    pptTmp,
                                    pulCounts,
                                    ccpt,
                                    cpt
                                  );
                        break;


                    case I_POLYBEZIER:
                        ulRet =
                          (ULONG_PTR) GrePolyBezier
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYLINETO:
                        ulRet =
                          (ULONG_PTR) GrePolylineTo
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYBEZIERTO:
                        ulRet =
                          (ULONG_PTR) GrePolyBezierTo
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYPOLYRGN:
                        ulRet =
                          (ULONG_PTR) GreCreatePolyPolygonRgnInternal
                                  (
                                    pptTmp,
                                    (LPINT)pulCounts,
                                    ccpt,
                                    (INT)(ULONG_PTR)hdc, // the mode
                                    cpt
                                  );
                        break;

                    default:
                        ulRet = 0;
                    }

                }

                if (pptTmp && (pptTmp != apt))
                    FreeTmpBuffer(pptTmp);

                if (pulCounts != &ulCount)
                    VFREEMEM(pulCounts);


            }
            else
            {
                ulRet = 0;
            }
        }
    }
    else
    {
        ulRet = 0;
    }
    return(ulRet);
}


/******************************Public*Routine******************************\
* NtGdiStretchDIBitsInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  04-MAR-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

int
APIENTRY
NtGdiStretchDIBitsInternal(
    HDC          hdc,
    int          xDst,
    int          yDst,
    int          cxDst,
    int          cyDst,
    int          xSrc,
    int          ySrc,
    int          cxSrc,
    int          cySrc,
    LPBYTE       pjInit,
    LPBITMAPINFO pbmi,
    DWORD        dwUsage,
    DWORD        dwRop4,
    UINT         cjMaxInfo,
    UINT         cjMaxBits,
    HANDLE       hcmXform
    )
{
    LPBITMAPINFO pbmiTmp = NULL;
    INT          iRet = 1;
    ULONG        cjHeader = cjMaxInfo;
    ULONG        cjBits   = cjMaxBits;
    HANDLE       hSecure = 0;

    if (pjInit && pbmi && cjHeader)
    {
        try
        {
            if (bCaptureBitmapInfo(pbmi, dwUsage, cjHeader, &pbmiTmp))
            {
                if (pjInit)
                {
                     ProbeForRead(pjInit, cjBits, sizeof(DWORD));

                     hSecure = MmSecureVirtualMemory(pjInit, cjBits, PAGE_READONLY);

                     if (!hSecure)
                     {
                        iRet = 0;
                     }
                }
            }
            else
            {
                iRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(6);
            // SetLastError(GetExceptionCode());
            iRet = 0;
        }
    }
    else
    {
        // it is completely valid to pass in NULL here if the ROP doesn't use
        // a source.

        pbmiTmp = NULL;
        pjInit  = NULL;
        pjInit  = NULL;
    }

    if (iRet)
    {
        iRet = GreStretchDIBitsInternal(
                    hdc,
                    xDst,
                    yDst,
                    cxDst,
                    cyDst,
                    xSrc,
                    ySrc,
                    cxSrc,
                    cySrc,
                    pjInit,
                    pbmiTmp,
                    dwUsage,
                    dwRop4,
                    cjHeader,
                    cjBits,
                    hcmXform
                    );

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }

    if (pbmiTmp)
    {
        VFREEMEM(pbmiTmp);
    }

    return (iRet);

}

/******************************Public*Routine******************************\
* NtGdiGetOutlineTextMetricsInternalW
*
* Arguments:
*
*   hdc   - device context
*   cjotm - size of metrics data array
*   potmw - pointer to array of OUTLINETEXTMETRICW structures or NULL
*   ptmd  - pointer to  TMDIFF strcture
*
* Return Value:
*
*   If potmw is NULL, return size of buffer needed, else TRUE.
*   If the function fails, the return value is FALSE;
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetOutlineTextMetricsInternalW(
    HDC                 hdc,
    ULONG               cjotm,
    OUTLINETEXTMETRICW *potmw,
    TMDIFF             *ptmd
    )
{

    DWORD dwRet = (DWORD)1;
    OUTLINETEXTMETRICW *pkmOutlineTextMetricW;
    TMDIFF kmTmDiff;


    if ((cjotm == 0) || (potmw == (OUTLINETEXTMETRICW *)NULL))
    {
        cjotm = 0;
        pkmOutlineTextMetricW = (OUTLINETEXTMETRICW *)NULL;
    }
    else
    {
        pkmOutlineTextMetricW = AllocFreeTmpBuffer(cjotm);

        if (pkmOutlineTextMetricW == (OUTLINETEXTMETRICW *)NULL)
        {
            dwRet = (DWORD)-1;
        }
    }

    if (dwRet != (DWORD)-1)
    {

        dwRet = GreGetOutlineTextMetricsInternalW(
                                            hdc,
                                            cjotm,
                                            pkmOutlineTextMetricW,
                                            &kmTmDiff);

        if (dwRet != (DWORD)-1 && dwRet != (DWORD) 0)
        {
            try
            {
                //
                // copy TMDIFF structure out
                //
                ProbeAndWriteAlignedBuffer(ptmd, &kmTmDiff, sizeof(TMDIFF), sizeof(DWORD));

                //
                // copy OTM out if needed
                //

                if (cjotm != 0)
                {
                    ProbeAndWriteAlignedBuffer(potmw, pkmOutlineTextMetricW, cjotm, sizeof(DWORD));
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(7);
                // SetLastError(GetExceptionCode());
                dwRet = (DWORD)-1;
            }
        }
    }

    if (pkmOutlineTextMetricW != (OUTLINETEXTMETRICW *)NULL)
    {
        FreeTmpBuffer(pkmOutlineTextMetricW);
    }

    return(dwRet);
}

// PUBLIC

/******************************Public*Routine******************************\
* NtGdiGetBoundsRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
NtGdiGetBoundsRect(
    HDC    hdc,
    LPRECT prc,
    DWORD  f
    )
{
    DWORD dwRet;

    RECT rc = {0, 0, 0, 0};

    dwRet = GreGetBoundsRect(hdc,&rc,f);

    if (dwRet)
    {
        try
        {
            ProbeAndWriteStructure(prc,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(8);
            // SetLastError(GetExceptionCode());

            dwRet = 0;
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetBitmapBits()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  03-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

LONG
APIENTRY
NtGdiGetBitmapBits(
    HBITMAP hbm,
    ULONG   cjMax,
    PBYTE   pjOut
   )
{
    LONG    lRet = 1;
    HANDLE  hSecure = 0;
    LONG    lOffset = 0;

    ULONG   cjBmSize = 0;

    //
    // get the bitmap size, just in case they pass
    // in a cjMax greater than the bitmap size
    //
    cjBmSize = GreGetBitmapBits(hbm,0,NULL,&lOffset);

    if (cjMax > cjBmSize)
    {
        cjMax = cjBmSize;
    }

    if (pjOut)
    {
        try
        {
            // WINBUG #83051 2-8-2000 bhouse Investigate possible stale comment
            // The below old comment mentions how this is ideal for try execept block ...
            // hmmm ... but we are in a try except block... this needs verifying that
            // it is just an old stale comment.
            // Old Comment:
            //       - this would be a prime candidate for a try/except
            //         instead of MmSecureVirtualMemory

            ProbeForWrite(pjOut,cjMax,sizeof(BYTE));
            hSecure = MmSecureVirtualMemory (pjOut, cjMax, PAGE_READWRITE);
            if (hSecure == 0)
            {
                lRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(9);
            // SetLastError(GetExceptionCode());

            lRet = 0;
       }
    }

    if (lRet)
    {
        lRet = GreGetBitmapBits(hbm,cjMax,pjOut,&lOffset);
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return (lRet);

}

/******************************Public*Routine******************************\
* NtGdiCreateDIBitmapInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*
* History:
*  03-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
*
* Difference from  NtGdiCreateDIBitmapInternal():
* Takes in cx, cy
*
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateDIBitmapInternal(
    HDC                hdc,
    INT                cx,     //Bitmap width
    INT                cy,     //Bitmap Height
    DWORD              fInit,
    LPBYTE             pjInit,
    LPBITMAPINFO       pbmi,
    DWORD              iUsage,
    UINT               cjMaxInitInfo,
    UINT               cjMaxBits,
    FLONG              f,
    HANDLE             hcmXform
    )
{
    LPBITMAPINFO       pbmiTmp = NULL;
    ULONG              cjHeader = cjMaxInitInfo;
    ULONG              cjBits = cjMaxBits;
    ULONG_PTR           iRet = 1;
    HANDLE             hSecure = 0;

    if (pbmi && cjHeader)
    {
        try
        {
            if (bCaptureBitmapInfo(pbmi, iUsage, cjHeader, &pbmiTmp))
            {
                if (pjInit)
                {
                    ProbeForRead(pjInit,cjBits,sizeof(DWORD));

                    hSecure = MmSecureVirtualMemory(pjInit, cjBits, PAGE_READONLY);

                    if (!hSecure)
                    {
                        iRet = 0;
                    }
                }
            }
            else
            {
                iRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(10);
            // SetLastError(GetExceptionCode());
            iRet = 0;
        }

   }

   // if we didn't hit an error above

   if (iRet == 1)
   {

        if (!(fInit & CBM_CREATEDIB))
        {
            //create an compatible bitmap
            iRet = (ULONG_PTR)GreCreateDIBitmapComp(
                            hdc,
                            cx,
                            cy,
                            fInit,
                            pjInit,
                            pbmiTmp,
                            iUsage,
                            cjHeader,
                            cjBits,
                            0,
                            hcmXform);
        }
        else
        {
            iRet = (ULONG_PTR)GreCreateDIBitmapReal(
                                        hdc,
                                        fInit,
                                        pjInit,
                                        pbmiTmp,
                                        iUsage,
                                        cjHeader,
                                        cjBits,
                                        (HANDLE)0,
                                        0,
                                        (HANDLE)0,
                                        0,
                                        0,
                                        NULL);
        }
   }

   //free up
   if (pbmiTmp)
   {
       VFREEMEM(pbmiTmp);
   }

   if (hSecure)
   {
        MmUnsecureVirtualMemory(hSecure);
   }

   return((HBITMAP)iRet);
}


/******************************Public*Routine******************************\
* NtGdiCreateDIBSection
*
* Arguments:
*
* hdc      - Handle to a device context.  If the value of iUsage is
*            DIB_PAL_COLORS, the function uses this device context's logical
*            palette to initialize the device-independent bitmap's colors.
*
*
* hSection - Handle to a file mapping object that the function will use to
*            create the device-independent bitmap.  This parameter can be
*            NULL.  If hSection is not NULL, it must be a handle to a file
*            mapping object created by calling the CreateFileMapping
*            function.  Handles created by other means will cause
*            CreateDIBSection to fail.  If hSection is not NULL, the
*            CreateDIBSection function locates the bitmap's bit values at
*            offset dwOffset in the file mapping object referred to by
*            hSection.  An application can later retrieve the hSection
*            handle by calling the GetObject function with the HBITMAP
*            returned by CreateDIBSection.
*
*
*
* dwOffset - Specifies the offset from the beginning of the file mapping
*            object referenced by hSection where storage for the bitmap's
*            bit values is to begin. This value is ignored if hSection is
*            NULL. The bitmap's bit values are aligned on doubleword
*            boundaries, so dwOffset must be a multiple of the size of a
*            DWORD.
*
*            If hSection is NULL, the operating system allocates memory for
*            the device-independent bitmap.  In this case, the
*            CreateDIBSection function ignores the dwOffset parameter.  An
*            application cannot later obtain a handle to this memory: the
*            dshSection member of the DIBSECTION structure filled in by
*            calling the GetObject function will be NULL.
*
*
* pbmi     - Points to a BITMAPINFO structure that specifies various
*            attributes of the device-independent bitmap, including the
*            bitmap's dimensions and colors.iUsage
*
* iUsage   - Specifies the type of data contained in the bmiColors array
*            member of the BITMAPINFO structure pointed to by pbmi: logical
*            palette indices or literal RGB values.
*
* cjMaxInfo - Maximum size of pbmi
*
* cjMaxBits - Maximum size of bitamp
*
*
* Return Value:
*
*   handle of bitmap or NULL
*
* History:
*
*    28-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateDIBSection(
    IN  HDC          hdc,
    IN  HANDLE       hSectionApp,
    IN  DWORD        dwOffset,
    IN  LPBITMAPINFO pbmi,
    IN  DWORD        iUsage,
    IN  UINT         cjHeader,
    IN  FLONG        fl,
    IN  ULONG_PTR     dwColorSpace,
    OUT PVOID       *ppvBits
    )
{
    HBITMAP hRet    = NULL;
    BOOL    bStatus = FALSE;

    if (pbmi != NULL)
    {
        LPBITMAPINFO pbmiTmp = NULL;
        PVOID        pvBase  = NULL;

        try
        {
            bCaptureBitmapInfo(pbmi, iUsage, cjHeader, &pbmiTmp);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(11);

            EngSetLastError(ERROR_INVALID_PARAMETER);

            if (pbmiTmp != NULL)
            {
                VFREEMEM(pbmiTmp);
                pbmiTmp = NULL;
            }
        }

        if (pbmiTmp)
        {
            NTSTATUS Status;
            ULONG cjBits = GreGetBitmapBitsSize(pbmiTmp);
            SIZE_T cjView = (SIZE_T)cjBits;

            if (cjBits)
            {
                HANDLE hDIBSection = hSectionApp;

                //
                // if the app's hsection is NULL, then just
                // allocate the proper range of virtual memory
                //

                if (hDIBSection == NULL)
                {
                    Status = ZwAllocateVirtualMemory(
                                            NtCurrentProcess(),
                                            &pvBase,
                                            0L,
                                            &cjView,
                                            MEM_COMMIT | MEM_RESERVE,
                                            PAGE_READWRITE
                                            );

                    dwOffset = 0;

                    if (!NT_SUCCESS(Status))
                    {
                       EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else
                {
                    LARGE_INTEGER SectionOffset;
                    PVOID pObj;

                    SectionOffset.LowPart = dwOffset & 0xFFFF0000;
                    SectionOffset.HighPart = 0;

                    //
                    // Notice, header is not included in section as it is
                    // in client-server.  We do need to leave room for
                    // the offset, however.
                    //

                    cjView += (dwOffset & 0x0000FFFF);


                    Status = ObReferenceObjectByHandle(hDIBSection,
                                              SECTION_MAP_READ|SECTION_MAP_WRITE,
                                              *(POBJECT_TYPE *)MmSectionObjectType,
                                              PsGetCurrentThreadPreviousMode(),
                                              &pObj,
                                              0L);

                    if(NT_SUCCESS(Status))
                    {
                        Status = MmMapViewOfSection(
                                         pObj,
                                         PsGetCurrentProcess(),
                                         (PVOID *) &pvBase,
                                         0L,
                                         cjView,
                                         &SectionOffset,
                                         &cjView,
                                         ViewShare,
                                         0L,
                                         PAGE_READWRITE);

                        if (!NT_SUCCESS(Status))
                        {
                           EngSetLastError(ERROR_INVALID_PARAMETER);
                        }

                        //
                        // we're not going to use this again
                        //

                        ObDereferenceObject(pObj);
                    }
                    else
                    {
                        WARNING("NtGdiCreateDIBSection: ObReferenceObjectByHandle failed\n");

                        EngSetLastError(ERROR_INVALID_PARAMETER);

                        //
                        //This will now fall through to the cleanup code at the end of the routine
                        //to free pbmiTmp
                        //
                    }
                }
                // set the pointer to the beginning of the bits

                if (NT_SUCCESS(Status))
                {
                    HANDLE hSecure     = NULL;
                    PBYTE  pDIB        = NULL;

                    pDIB = (PBYTE)pvBase + (dwOffset & 0x0000FFFF);

                    //
                    // try to secure memory, keep secure until bitmap
                    // is deleted
                    //

                    hSecure = MmSecureVirtualMemory(
                                                pvBase,
                                                cjView,
                                                PAGE_READWRITE);

                    if (hSecure)
                    {
                        //
                        // Make the GDI Bitmap
                        //

                        hRet = GreCreateDIBitmapReal(
                                                hdc,
                                                CBM_CREATEDIB,
                                                pDIB,
                                                pbmiTmp,
                                                iUsage,
                                                cjHeader,
                                                cjBits,
                                                hDIBSection,
                                                dwOffset,
                                                hSecure,
                                                (fl & CDBI_NOPALETTE) | CDBI_DIBSECTION,
                                                dwColorSpace,
                                                NULL);

                        if (hRet != NULL)
                        {
                            try
                            {
                                ProbeAndWriteStructure(ppvBits,pDIB,PVOID);
                                bStatus = TRUE;
                            }
                            except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                WARNINGX(12);
                                EngSetLastError(ERROR_INVALID_PARAMETER);
                            }
                        }
                        else
                        {
                           EngSetLastError(ERROR_INVALID_PARAMETER);
                        }
                    }
                    else
                    {
                       EngSetLastError(ERROR_INVALID_PARAMETER);
                    }

                    // if we failed, we need to do cleanup.

                    if (!bStatus)
                    {

                        //
                        // The bDeleteSurface call will free DIBSection memory,
                        // only do cleanup if MmSecureVirtualMemory or GreCreateDIBitmapReal
                        // failed
                        //

                        if (hRet)
                        {
                            bDeleteSurface((HSURF)hRet);
                            hRet = NULL;
                        }
                        else
                        {
                            // do we need to unsecure the memory?

                            if (hSecure)
                            {
                                MmUnsecureVirtualMemory(hSecure);
                            }

                            // free the memory based on allocation

                            if (hSectionApp == NULL)
                            {
                                cjView = 0;

                                ZwFreeVirtualMemory(
                                            NtCurrentProcess(),
                                            &pDIB,
                                            &cjView,
                                            MEM_RELEASE);
                            }
                            else
                            {
                                //
                                // unmap view of section
                                //

                                ZwUnmapViewOfSection(
                                            NtCurrentProcess(),
                                            pvBase);
                            }
                        }
                    }
                }
            }

            // the only way to have gotten here is if we did allocate the pbmiTmp

            VFREEMEM(pbmiTmp);
        }
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* NtGdiExtCreatePen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiExtCreatePen(
    ULONG  flPenStyle,
    ULONG  ulWidth,
    ULONG  iBrushStyle,
    ULONG  ulColor,
    ULONG_PTR  lClientHatch,
    ULONG_PTR   lHatch,
    ULONG  cstyle,
    PULONG pulStyle,
    ULONG  cjDIB,
    BOOL   bOldStylePen,
    HBRUSH hbrush
    )
{
    PULONG pulStyleTmp = NULL;
    PULONG pulDIB      = NULL;
    HPEN hpenRet = (HPEN)1;

    if (pulStyle)
    {
        if (!BALLOC_OVERFLOW1(cstyle,ULONG))
        {
            pulStyleTmp = PALLOCNOZ(cstyle * sizeof(ULONG),'pmtG');
        }

        if (!pulStyleTmp)
            hpenRet = (HPEN)0;
    }

    if (iBrushStyle == BS_DIBPATTERNPT)
    {
        pulDIB = AllocFreeTmpBuffer(cjDIB);

        if (!pulDIB)
            hpenRet = (HPEN)0;
    }

    if (hpenRet)
    {
        try
        {
            if (pulStyle)
            {
                ProbeAndReadAlignedBuffer(pulStyleTmp,pulStyle,cstyle * sizeof(ULONG), sizeof(ULONG));
            }

            // if it is a DIBPATTERN type, the lHatch is a pointer to the BMI

            if (iBrushStyle == BS_DIBPATTERNPT)
            {
                ProbeAndReadAlignedBuffer(pulDIB,(PVOID)lHatch,cjDIB,sizeof(ULONG));
                lHatch = (ULONG_PTR)pulDIB;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(13);
            // SetLastError(GetExceptionCode());

            hpenRet = (HPEN)0;
        }

        // if all has succeeded

        if (hpenRet)
        {
            hpenRet = GreExtCreatePen(
                        flPenStyle,ulWidth,iBrushStyle,
                        ulColor,lClientHatch,lHatch,cstyle,
                        pulStyleTmp,cjDIB,bOldStylePen,hbrush
                        );
        }
    }
    else
    {
        // SetLastError(GetExceptionCode());
    }

    // cleanup

    if (pulDIB)
        FreeTmpBuffer(pulDIB);

    if (pulStyleTmp)
        VFREEMEM(pulStyleTmp);

    return(hpenRet);
}



/******************************Public*Routine******************************\
* NtGdiHfontCreate()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HFONT
APIENTRY
NtGdiHfontCreate(
    ENUMLOGFONTEXDVW * plfw,
    ULONG              cjElfw,
    LFTYPE        lft,
    FLONG         fl,
    PVOID         pvCliData
    )
{
    ULONG_PTR iRet = 1;

// check for bad parameter

    if (plfw && cjElfw && (cjElfw <= sizeof(ENUMLOGFONTEXDVW)))
    {
        ENUMLOGFONTEXDVW elfwTmp; // too big a structure on the stack?

        try
        {
            ProbeAndReadBuffer(&elfwTmp, plfw, cjElfw);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(15);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }

    // Ignore the DV because adobe said they will never ship a mm otf font
    // This is a hack to avoid changing lot of code to remove mm support from the system

        elfwTmp.elfDesignVector.dvNumAxes = 0;

        if (iRet)
        {
            iRet = (ULONG_PTR)hfontCreate(&elfwTmp, lft, fl, pvCliData);
        }
    }
    else
    {
        iRet = 0;
    }

    return ((HFONT)iRet);
}

/******************************Public*Routine******************************\
* NtGdiExtCreateRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by-  Lingyun Wang [lingyunw]
* expanded it.
\**************************************************************************/

HRGN
APIENTRY
NtGdiExtCreateRegion(
    LPXFORM   px,
    DWORD     cj,
    LPRGNDATA prgn
    )
{
    LPRGNDATA prgnTmp;
    XFORM     xf;
    HRGN      hrgn = (HRGN)NULL;

    // check for bad parameter

    if (cj >= sizeof(RGNDATAHEADER))
    {
        // do the real work

        prgnTmp = AllocFreeTmpBuffer(cj);

        if (prgnTmp)
        {
            BOOL bConvert = TRUE;

            if (px)
            {
                bConvert = ProbeAndConvertXFORM ((XFORML *)px, (XFORML *)&xf);
                px = &xf;
            }

            if (bConvert)
            {
               try
               {

                    ProbeAndReadBuffer(prgnTmp, prgn, cj);
                    hrgn = (HRGN)1;

               }
               except(EXCEPTION_EXECUTE_HANDLER)
               {
                   WARNINGX(16);
                   // SetLastError(GetExceptionCode());
               }
            }

            if (hrgn)
                hrgn = GreExtCreateRegion((XFORML *)px,cj,prgnTmp);

            FreeTmpBuffer(prgnTmp);
        }
        else
        {
            // fail to allocate memory
            // SetLastError();
        }
    }

    return(hrgn);
}

/******************************Public*Routine******************************\
* NtGdiPolyDraw()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyDraw(
    HDC     hdc,
    LPPOINT ppt,
    LPBYTE  pjAttr,
    ULONG   cpt
    )
{
    BOOL   bRet = TRUE;
    BOOL   bLocked = FALSE;
    HANDLE hSecure1 = 0;
    HANDLE hSecure2 = 0;

    try
    {
        // Make sure lengths do not overflow.
        //
        // Note: sizeof(BYTE) < sizeof(POINT), so the single test
        //       suffices for both lengths
        //
        // Note: using MAXULONG instead of MAXIMUM_POOL_ALLOC (or the
        //       BALLOC_ macros) because we are not allocating memory.

        if (cpt <= (MAXULONG / sizeof(POINT)))
        {
            ProbeForRead(ppt,   cpt * sizeof(POINT), sizeof(DWORD));
            ProbeForRead(pjAttr,cpt * sizeof(BYTE),  sizeof(BYTE));

            hSecure1 = MmSecureVirtualMemory(ppt, cpt * sizeof(POINT), PAGE_READONLY);
            hSecure2 = MmSecureVirtualMemory(pjAttr, cpt * sizeof(BYTE), PAGE_READONLY);
        }

        if (!hSecure1 || !hSecure2)
        {
            bRet = FALSE;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(17);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GrePolyDraw(hdc,ppt,pjAttr,cpt);
    }

    if (hSecure1)
    {
        MmUnsecureVirtualMemory(hSecure1);
    }

    if (hSecure2)
    {
        MmUnsecureVirtualMemory(hSecure2);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiPolyTextOutW
*
* Arguments:
*
*   hdc  - Handle to device context
*   pptw - pointer to array of POLYTEXTW
*   cStr - number of POLYTEXTW
*
* Return Value:
*
*   Status
*
* History:
*
*   24-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyTextOutW(
    HDC        hdc,
    POLYTEXTW *pptw,
    UINT       cStr,
    DWORD      dwCodePage
    )
{
    BOOL bStatus = TRUE;
    ULONG  ulSize = sizeof(POLYTEXTW) * cStr;
    ULONG  ulIndex;
    PPOLYTEXTW pPoly = NULL;
    PBYTE pjBuffer;
    PBYTE pjBufferEnd;
    ULONG cjdx;

    //
    // Check for overflow
    //

    if (!BALLOC_OVERFLOW1(cStr,POLYTEXTW))
    {
        //
        // add up size off all array elements
        //

        try
        {
            ProbeForRead(pptw,cStr * sizeof(POLYTEXTW),sizeof(ULONG));

            for (ulIndex=0;ulIndex<cStr;ulIndex++)
            {
                int n = pptw[ulIndex].n;
                ULONG ulTmp;                // used to check for
                                            // overflow of ulSize

                //
                // Pull count from each, also check for
                // non-zero length and NULL string
                //

                ulTmp = ulSize;
                ulSize += n * sizeof(WCHAR);
                if (BALLOC_OVERFLOW1(n, WCHAR) || (ulSize < ulTmp))
                {
                    bStatus = FALSE;
                    break;
                }

                if (pptw[ulIndex].pdx != (int *)NULL)
                {
                    cjdx = n * sizeof(int);
                    if (pptw[ulIndex].uiFlags & ETO_PDY)
                    {
                        if (BALLOC_OVERFLOW1(n*2,int))
                            bStatus = FALSE;

                        cjdx *= 2;
                    }
                    else
                    {
                        if (BALLOC_OVERFLOW1(n,int))
                            bStatus = FALSE;
                    }

                    ulTmp = ulSize;
                    ulSize += cjdx;
                    if (!bStatus || (ulSize < ulTmp))
                    {
                        bStatus = FALSE;
                        break;
                    }
                }

                if (n != 0)
                {
                    if (pptw[ulIndex].lpstr == NULL)
                    {
                        bStatus = FALSE;
                        break;
                    }
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(18);
            // SetLastError(GetExceptionCode());
            bStatus = FALSE;
        }
    }
    else
    {
        bStatus = FALSE;
    }

    if (bStatus && ulSize)
    {
        pPoly = (PPOLYTEXTW)AllocFreeTmpBuffer(ulSize);

        if (pPoly != (POLYTEXTW *)NULL)
        {
            try
            {
                // Note: pptw already read probed

                RtlCopyMemory(pPoly,pptw,sizeof(POLYTEXTW) * cStr);
                pjBuffer = ((PBYTE)pPoly) + sizeof(POLYTEXTW) * cStr;
                pjBufferEnd = ((PBYTE)pPoly) + ulSize;

                //
                // copy strings and pdx into kernel mode
                // buffer and update pointers. Copy all pdx
                // values first, then copy strings to avoid
                // unaligned accesses due to odd length strings...
                //

                for (ulIndex=0;ulIndex<cStr;ulIndex++)
                {
                    //
                    // Pull count from each, also check for
                    // non-zero length and NULL string
                    //

                    if (pPoly[ulIndex].n != 0)
                    {
                        if (pPoly[ulIndex].pdx != (int *)NULL)
                        {
                            cjdx = pPoly[ulIndex].n * sizeof(int);

                            if (pPoly[ulIndex].uiFlags & ETO_PDY)
                            {
                                typedef struct _TWOINT
                                {
                                    int i1;
                                    int i2;
                                } TWOINT;


                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n,TWOINT))
                                {
                                    bStatus = FALSE;
                                }
                                cjdx *= 2;
                            }
                            else
                            {
                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n,int))
                                {
                                    bStatus = FALSE;
                                }
                            }

                            //
                            // Check for cjdx overflow and check that kernel
                            // mode buffer still has space.
                            //

                            if (!bStatus || ((pjBuffer + cjdx) > pjBufferEnd))
                            {
                                bStatus = FALSE;    // need set if past end of
                                                    // KM buffer but compuation                                                    // overflowed but computa
                                                    // of cjdx didn't overflow
                                break;
                            }

                            ProbeAndReadAlignedBuffer(
                                    pjBuffer,
                                    pPoly[ulIndex].pdx,
                                    cjdx, sizeof(int));

                            pPoly[ulIndex].pdx = (int *)pjBuffer;
                            pjBuffer += cjdx;
                        }
                    }
                }

                //
                // now copy strings
                //

                if (bStatus)
                {
                    for (ulIndex=0;ulIndex<cStr;ulIndex++)
                    {
                        //
                        // Pull count from each, also check for
                        // non-zero length and NULL string
                        //

                        if (pPoly[ulIndex].n != 0)
                        {
                            if (pPoly[ulIndex].lpstr != NULL)
                            {
                                ULONG StrSize = pPoly[ulIndex].n * sizeof(WCHAR);

                                //
                                // Check for overflow of StrSize and check
                                // that kernel mode buffer has space.
                                //

                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n, WCHAR) ||
                                    ((pjBuffer + StrSize) > pjBufferEnd))
                                {
                                    bStatus = FALSE;
                                    break;
                                }

                                ProbeAndReadAlignedBuffer(
                                        pjBuffer,
                                        (PVOID)pPoly[ulIndex].lpstr,
                                        StrSize,
                                        sizeof(WCHAR));

                                pPoly[ulIndex].lpstr = (LPWSTR)pjBuffer;
                                pjBuffer += StrSize;
                            }
                            else
                            {
                                //
                                // data error, n != 0 but lpstr = NULL
                                //

                                bStatus = FALSE;
                                break;
                            }
                        }
                    }
                }
            } except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(19);
                // SetLastError(GetExceptionCode());
                bStatus = FALSE;
            }

            if (bStatus)
            {

                //
                // Finally ready to call gre function
                //

                bStatus = GrePolyTextOutW(hdc,pPoly,cStr,dwCodePage);

            }

            FreeTmpBuffer(pPoly);
        }
        else
        {
            WARNING("NtGdiPolyTextOut failed to allocate memory\n");
            bStatus = FALSE;
        }
    }

    return(bStatus);
}




/******************************Public*Routine******************************\
* NtGdiRectVisible()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRectVisible(
    HDC    hdc,
    LPRECT prc
    )
{
    DWORD dwRet;
    RECT rc;

    try
    {
        rc = ProbeAndReadStructure(prc,RECT);
        dwRet = 1;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(22);
        // SetLastError(GetExceptionCode());

        dwRet = 0;
    }

    if (dwRet)
    {
        dwRet = GreRectVisible(hdc,&rc);
    }

    return(dwRet);


}


/******************************Public*Routine******************************\
* NtGdiSetMetaRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiSetMetaRgn(
    HDC hdc
    )
{
    return(GreSetMetaRgn(hdc));
}

/******************************Public*Routine******************************\
* NtGdiGetAppClipBox()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetAppClipBox(
    HDC    hdc,
    LPRECT prc
    )
{
    int iRet;

    RECT rc;

    iRet = GreGetAppClipBox(hdc,&rc);

    if (iRet != ERROR)
    {
        try
        {
            ProbeAndWriteStructure(prc,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(23);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextExtentEx()
*
* History:
*  Fri 06-Oct-1995 -by- Bodin Dresevic [BodinD]
* Rewrote it.
*  07-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

#define LOCAL_CWC_MAX   16

BOOL
APIENTRY
NtGdiGetTextExtentExW(
    HDC     hdc,
    LPWSTR  lpwsz,
    ULONG   cwc,
    ULONG   dxMax,
    ULONG  *pcCh,
    PULONG  pdxOut,
    LPSIZE  psize,
    FLONG   fl
    )
{

    SIZE size;
    ULONG cCh = 0;
    ULONG Localpdx[LOCAL_CWC_MAX];
    WCHAR Localpwsz[LOCAL_CWC_MAX];
    PWSZ pwszCapt = NULL;
    PULONG pdxCapt = NULL;
    BOOL UseLocals = FALSE;

    BOOL bRet = FALSE;
    BOOL b;

    if ( (b = (psize != NULL)) )
    {
        if (cwc == 0)
        {
            cCh = 0;
            size.cx = 0;
            size.cy = 0;
            bRet = TRUE;
        }
        else
        {
        // capture the string
        // NULL string causes failiure.

            if ( cwc > LOCAL_CWC_MAX ) {
                UseLocals = FALSE;
            } else {
                UseLocals = TRUE;
            }

            if (lpwsz != NULL)
            {
                try
                {
                    if ( UseLocals ) {
                        pwszCapt = Localpwsz;
                        pdxCapt = Localpdx;
                    } else {
                        if (cwc && !BALLOC_OVERFLOW2(cwc,ULONG,WCHAR))
                        {
                            pdxCapt = (PULONG) AllocFreeTmpBuffer(cwc * (sizeof(ULONG) + sizeof(WCHAR)));
                        }
                        pwszCapt = (PWSZ) &pdxCapt[cwc];
                    }

                    if (pdxCapt)
                    {
                    // Capture the string into the buffer.

                        ProbeAndReadBuffer(pwszCapt, lpwsz, cwc*sizeof(WCHAR));
                        bRet = TRUE;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(24);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                bRet = GreGetTextExtentExW(hdc,
                                           pwszCapt,
                                           cwc,
                                           pcCh ? dxMax : ULONG_MAX,
                                           &cCh,
                                           pdxOut ? pdxCapt : NULL,
                                           &size, fl);
            }
        }

    // Write the value back into the user mode buffer if the call succeded

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,size,SIZE);

                if (pcCh)
                {
                    ProbeAndWriteUlong(pcCh,cCh);
                }

                // We will only try to copy the data if pcCh is not zero,
                // and it is set to zero if cwc is zero.

                if (cCh)
                {
                // only copy if the caller requested the data, and the
                // data is present.

                    if (pdxOut && pdxCapt)
                    {
                        ProbeAndWriteAlignedBuffer(pdxOut, pdxCapt, cCh * sizeof(ULONG), sizeof(ULONG));
                    }
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(25);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }

        if (!UseLocals && pdxCapt)
        {
            FreeTmpBuffer(pdxCapt);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetCharABCWidthsW()
*
* Arguments:
*
*   hdc      - handle to device context
*   wchFirst - first char (if pwch is NULL)
*   cwch     - Number of chars to get ABC widths for
*   pwch     - array of WCHARs (mat be NULL)
*   bInteger - return int or float ABC values
*   pvBuf    - results buffer
*
* Return Value:
*
*   BOOL Status
*
* History:
*
*   14-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetCharABCWidthsW(
    HDC    hdc,
    UINT   wchFirst,
    ULONG  cwch,
    PWCHAR pwch,
    FLONG  fl,
    PVOID  pvBuf
    )
{
    BOOL    bStatus = FALSE;
    PVOID   pTemp_pvBuf = NULL;
    PWCHAR  pTemp_pwc = (PWCHAR)NULL;
    BOOL    bUse_pwc  = FALSE;
    ULONG   OutputBufferSize = 0;

    if (pvBuf == NULL)
    {
        return(bStatus);
    }

    //
    // allocate memory for buffers, pwch may be NULL
    //

    if (pwch != (PWCHAR)NULL)
    {
        bUse_pwc  = TRUE;

        if (cwch && !BALLOC_OVERFLOW1(cwch,WCHAR))
        {
            pTemp_pwc = (PWCHAR)PALLOCNOZ(cwch * sizeof(WCHAR),'pmtG');
        }
    }

    if ((!bUse_pwc) || (pTemp_pwc != (PWCHAR)NULL))
    {
        if (fl & GCABCW_INT)
        {
            if (!BALLOC_OVERFLOW1(cwch,ABC))
            {
                pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwch * sizeof(ABC));
                OutputBufferSize = cwch * sizeof(ABC);
            }
        }
        else
        {
            if (!BALLOC_OVERFLOW1(cwch,ABCFLOAT))
            {
                pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwch * sizeof(ABCFLOAT));
                OutputBufferSize = cwch * sizeof(ABCFLOAT);
            }
        }

        if (pTemp_pvBuf != NULL)
        {
            BOOL bErr = FALSE;
            //
            // copy input data to kernel mode buffer, if needed
            //

            if (bUse_pwc)
            {
                try
                {
                    ProbeAndReadBuffer(pTemp_pwc,pwch,cwch * sizeof(WCHAR));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(26);
                    // SetLastError(GetExceptionCode());
                    bErr = TRUE;
                }
            }

            if (!bErr)
            {
                bStatus = GreGetCharABCWidthsW(hdc,wchFirst,cwch,pTemp_pwc,fl,pTemp_pvBuf);

                //
                // copy results from kernel mode buffer to user buffer
                //

                if (bStatus)
                {
                    try
                    {
                        ProbeAndWriteBuffer(pvBuf,pTemp_pvBuf,OutputBufferSize);
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(27);
                        // SetLastError(GetExceptionCode());
                        bStatus = FALSE;
                    }

                }
            }

            FreeTmpBuffer(pTemp_pvBuf);
        }

        if (bUse_pwc)
        {
            if (pTemp_pwc)
                VFREEMEM(pTemp_pwc);
        }
    }

    return(bStatus);
}




/******************************Public*Routine******************************\
* NtGdiAngleArc()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiAngleArc(
    HDC   hdc,
    int   x,
    int   y,
    DWORD dwRadius,
    DWORD dwStartAngle,
    DWORD dwSweepAngle
    )
{
    FLOATL l_eStartAngle;
    FLOATL l_eSweepAngle;

    // Validate arguments and cast to floats
    BOOL bRet = (bConvertDwordToFloat(dwStartAngle, &l_eStartAngle) &&
                 bConvertDwordToFloat(dwSweepAngle ,&l_eSweepAngle));

    if (bRet)
    {
        bRet = GreAngleArc(hdc,x,y,dwRadius,l_eStartAngle,l_eSweepAngle);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiSetMiterLimit()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetMiterLimit(
    HDC    hdc,
    DWORD  dwNew,
    PDWORD pdwOut
    )
{
    BOOL   bRet = TRUE;
    FLOATL l_e;
    FLOATL l_eNew;

    ASSERTGDI(sizeof(FLOATL) == sizeof(DWORD),"sizeof(FLOATL) != sizeof(DWORD)\n");

    // Validate argument and cast to float
    bRet = bConvertDwordToFloat(dwNew, &l_eNew);

    if (bRet)
    {
        bRet = GreSetMiterLimit(hdc,l_eNew,&l_e);
    }

    if (bRet && pdwOut)
    {
        try
        {
           ProbeAndWriteAlignedBuffer(pdwOut, &l_e, sizeof(DWORD), sizeof(DWORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(113);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetFontXform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetFontXform(
    HDC   hdc,
    DWORD dwxScale,
    DWORD dwyScale
    )
{
    FLOATL l_exScale;
    FLOATL l_eyScale;

    // Validate arguments and cast to floats
    BOOL bRet = (bConvertDwordToFloat (dwxScale, &l_exScale) &&
                 bConvertDwordToFloat (dwyScale, &l_eyScale));

    if (bRet)
    {
        bRet = GreSetFontXform(hdc,l_exScale,l_eyScale);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiGetMiterLimit()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetMiterLimit(
    HDC    hdc,
    PDWORD pdwOut
    )
{
    BOOL   bRet;
    FLOATL l_e;

    bRet = GreGetMiterLimit(hdc,&l_e);

    if (bRet)
    {
        try
        {
           ProbeAndWriteAlignedBuffer(pdwOut, &l_e, sizeof(DWORD), sizeof(DWORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(29);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiMaskBlt()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiMaskBlt(
    HDC     hdc,
    int     xDst,
    int     yDst,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   dwRop4,
    DWORD   crBackColor
    )
{
    return(GreMaskBlt(
        hdc,xDst,yDst,cx,cy,
        hdcSrc,xSrc,ySrc,
        hbmMask,xMask,yMask,
        dwRop4,crBackColor
        ));
}


/******************************Public*Routine******************************\
* NtGdiGetCharWidthW
*
* History:
*
*   10-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetCharWidthW(
    HDC    hdc,
    UINT   wcFirst,
    UINT   cwc,
    PWCHAR pwc,
    FLONG  fl,
    PVOID  pvBuf
    )
{
    BOOL    bStatus = FALSE;
    PVOID   pTemp_pvBuf = NULL;
    PWCHAR  pTemp_pwc = (PWCHAR)NULL;
    BOOL    bUse_pwc  = FALSE;

    //
    // allocate memory for buffers, pwc may be NULL
    //

    if (!cwc)
    {
        return(FALSE);
    }

    if (pwc != (PWCHAR)NULL)
    {
        bUse_pwc = TRUE;

        if (!BALLOC_OVERFLOW1(cwc,WCHAR))
        {
            pTemp_pwc = (PWCHAR)PALLOCNOZ(cwc * sizeof(WCHAR),'pmtG');
        }
    }

    if ((!bUse_pwc) || (pTemp_pwc != (PWCHAR)NULL))
    {
        if (!BALLOC_OVERFLOW1(cwc,ULONG))
        {
            pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwc * sizeof(ULONG));
        }

        if (pTemp_pvBuf != NULL)
        {
            //
            // copy input data to kernel mode buffer, if needed
            //

            if (bUse_pwc)
            {
                try
                {
                    ProbeAndReadBuffer(pTemp_pwc,pwc,cwc * sizeof(WCHAR));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(30);
                    // SetLastError(GetExceptionCode());
                    bStatus = FALSE;
                }
            }

            bStatus = GreGetCharWidthW(hdc,wcFirst,cwc,pTemp_pwc,fl,pTemp_pvBuf);

            //
            // copy results from kernel mode buffer to user buffer
            //

            if (bStatus)
            {
                try
                {
                    ProbeAndWriteBuffer(pvBuf,pTemp_pvBuf,cwc * sizeof(ULONG));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(31);
                    // SetLastError(GetExceptionCode());
                    bStatus = FALSE;
                }

            }

            FreeTmpBuffer(pTemp_pvBuf);
        }

        if (bUse_pwc)
        {
            VFREEMEM(pTemp_pwc);
        }
    }

    return(bStatus);
}


/******************************Public*Routine******************************\
* NtGdiDrawEscape
*
* Arguments:
*
*   hdc  - handle of device context
*   iEsc - specifies escape function
*   cjIn - size of structure for input
*   pjIn - address of structure for input
*
* Return Value:
*
*   >  0 if successful
*   == 0 if function not supported
*   <  0 if error
*
* History:
*
*   16-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define DRAWESCAPE_BUFFER_SIZE 64

int
APIENTRY
NtGdiDrawEscape(
    HDC   hdc,
    int   iEsc,
    int   cjIn,
    LPSTR pjIn
    )
{
    int   cRet = 0;
    ULONG AllocSize;
    UCHAR StackBuffer[DRAWESCAPE_BUFFER_SIZE];
    LPSTR pCallBuffer = pjIn;
    HANDLE hSecure = 0;

    //
    // Validate.
    //

    if (cjIn < 0)
    {
        return -1;
    }

    //
    // Check cjIn is 0 for NULL pjIn
    //

    if (pjIn == (LPSTR)NULL)
    {
        if (cjIn != 0)
        {
            cRet = -1;
        }
        else
        {
            cRet = GreDrawEscape(hdc,iEsc,0,(LPSTR)NULL);
        }
    }
    else
    {
        //
        // Try to alloc off stack, otherwise lock buffer
        //

        AllocSize = (cjIn + 3) & ~0x03;

        if (AllocSize <= DRAWESCAPE_BUFFER_SIZE)
        {
            pCallBuffer = (LPSTR)StackBuffer;

            //
            // copy data into buffer
            //

            try
            {
                ProbeAndReadBuffer(pCallBuffer,pjIn,cjIn);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(32);
                // SetLastError(GetExceptionCode());
                cRet = -1;
            }
        }
        else
        {
            hSecure = MmSecureVirtualMemory(pjIn, cjIn, PAGE_READONLY);

            if (hSecure == 0)
            {
                cRet = -1;
            }
        }

        if (cRet >= 0)
        {
            cRet = GreDrawEscape(hdc,iEsc,cjIn,pCallBuffer);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    return(cRet);
}

/******************************Public*Routine******************************\
* NtGdiExtEscape
*
* Arguments:
*
*   hdc      - handle of device context
*   pDriver  - buffer containing name of font driver
*   nDriver  - length of driver name
*   iEsc     - escape function
*   cjIn     - size, in bytes, of input data structure
*   pjIn     - address of input structure
*   cjOut    - size, in bytes, of output data structure
*   pjOut    - address of output structure
*
* Return Value:
*
*   >  0 : success
*   == 0 : escape not implemented
*   <  0 : error
*
* History:
*
*   17-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define EXT_STACK_DATA_SIZE 32

int
APIENTRY
NtGdiExtEscape(
    HDC     hdc,
    PWCHAR  pDriver,     // only used for NamedEscape call
    int     nDriver,     // only used for NamedEscape call
    int     iEsc,
    int     cjIn,
    LPSTR   pjIn,
    int     cjOut,
    LPSTR   pjOut
    )

{
    UCHAR  StackInputData[EXT_STACK_DATA_SIZE];
    UCHAR  StackOutputData[EXT_STACK_DATA_SIZE];
    WCHAR  StackDriver[EXT_STACK_DATA_SIZE];
    HANDLE hSecureIn;
    LPSTR  pkmIn, pkmOut;
    BOOL   bAllocOut, bAllocIn, bAllocDriver;
    PWCHAR pkmDriver = NULL;
    BOOL   bStatus = TRUE;
    BOOL   iRet = -1;

    bAllocOut = bAllocIn = bAllocDriver = FALSE;
    hSecureIn = NULL;
    pkmIn = pkmOut = NULL;

    if ((cjIn < 0) || (cjOut < 0) || (nDriver < 0))
    {
        WARNING("NtGdiExtEscape: negative count passed in\n");
        bStatus = FALSE;
    }

    if (pDriver && bStatus)
    {
        if (nDriver <= EXT_STACK_DATA_SIZE-1)
        {
            pkmDriver = StackDriver;
        }
        else
        {
            if (!BALLOC_OVERFLOW1((nDriver+1),WCHAR))
            {
                pkmDriver = (WCHAR*)PALLOCNOZ((nDriver+1) * sizeof(WCHAR),'pmtG');
            }

            // even if we fail this is okay because we check for NULL before FREE

            bAllocDriver = TRUE;
        }

        if (pkmDriver != NULL)
        {
            try
            {
                ProbeAndReadAlignedBuffer(pkmDriver,pDriver,nDriver*sizeof(WCHAR), sizeof(WCHAR));
                pkmDriver[nDriver] = 0;  // NULL terminate the string
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(94);
                bStatus = FALSE;
            }
        }
        else
        {
            bStatus = FALSE;
        }
    }

    if ((cjIn != 0) && bStatus)
    {
        try
        {
            if (cjIn <= EXT_STACK_DATA_SIZE)
            {
                pkmIn = (LPSTR) StackInputData;
                ProbeAndReadBuffer(pkmIn, pjIn, cjIn);
            }
            else if (pkmDriver != NULL)
            {
                //
                // make kernel copies for the fontdrv
                // otherwise just secure the memory
                //
                pkmIn = (LPSTR)PALLOCNOZ(cjIn,'pmtG');

                 if (pkmIn != (LPSTR)NULL)
                 {
                    bAllocIn = TRUE;

                     try
                     {
                         ProbeAndReadBuffer(pkmIn,pjIn,cjIn);
                     }
                     except(EXCEPTION_EXECUTE_HANDLER)
                     {
                         WARNINGX(33);
                         // SetLastError(GetExceptionCode());
                         bStatus = FALSE;
                     }
                 }
                 else
                 {
                     bStatus = FALSE;
                 }

            }
            else
            {
                ProbeForRead(pjIn,cjIn,sizeof(BYTE));

                if (hSecureIn = MmSecureVirtualMemory(pjIn, cjIn, PAGE_READONLY))
                {
                    pkmIn = pjIn;
                }
                else
                {
                    bStatus = FALSE;
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(33);
            bStatus = FALSE;
        }
    }

    if ((cjOut != 0) && bStatus)
    {
        if (cjOut <= EXT_STACK_DATA_SIZE)
            pkmOut = (LPSTR) StackOutputData;
        else if (pkmOut = (LPSTR) PALLOCNOZ(cjOut, 'pmtG'))
            bAllocOut = TRUE;
        else
            bStatus = FALSE;

        // Security: zero initialize the return buffer or we may open
        // a hole that returns old pool data or old kernel stack data.

        if (pkmOut)
        {
            RtlZeroMemory((PVOID) pkmOut, cjOut);
        }

    }

    if (bStatus)
    {

        iRet = (pkmDriver) ?
                GreNamedEscape(pkmDriver, iEsc, cjIn, pkmIn, cjOut, pkmOut) :
                GreExtEscape(hdc, iEsc, cjIn, pkmIn, cjOut, pkmOut);

        if (cjOut != 0)
        {
            try
            {
                ProbeAndWriteBuffer(pjOut, pkmOut, cjOut);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(34);
                iRet = -1;
            }
        }
    }

    if (hSecureIn)
        MmUnsecureVirtualMemory(hSecureIn);

    if (bAllocOut && pkmOut)
        VFREEMEM(pkmOut);

    if (bAllocIn && pkmIn)
        VFREEMEM(pkmIn);


    if (bAllocDriver && pkmDriver)
        VFREEMEM(pkmDriver);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetFontData()
*
* Arguments:
*
*   hdc      - handle to device context
*   dwTable  - name of a font metric table
*   dwOffset - ffset from the beginning of the font metric table
*   pvBuf    - buffer to receive the font information
*   cjBuf    - length, in bytes, of the information to be retrieved
*
* Return Value:
*
*   Count of byte written to buffer, of GDI_ERROR for failure
*
* History:
*
*   14-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetFontData(
    HDC    hdc,
    DWORD  dwTable,
    DWORD  dwOffset,
    PVOID  pvBuf,
    ULONG  cjBuf
    )
{
    PVOID  pvkmBuf = NULL;
    ULONG  ReturnBytes = GDI_ERROR;

    if (cjBuf == 0)
    {
        ReturnBytes = ulGetFontData(
                                hdc,
                                dwTable,
                                dwOffset,
                                pvkmBuf,
                                cjBuf);
    }
    else
    {
        pvkmBuf = AllocFreeTmpBuffer(cjBuf);

        if (pvkmBuf != NULL)
        {

            ReturnBytes = ulGetFontData(
                                    hdc,
                                    dwTable,
                                    dwOffset,
                                    pvkmBuf,
                                    cjBuf);

            if (ReturnBytes != GDI_ERROR)
            {
                try
                {
                    ProbeAndWriteBuffer(pvBuf,pvkmBuf,ReturnBytes);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(35);
                    // SetLastError(GetExceptionCode());
                    ReturnBytes = GDI_ERROR;
                }
            }

            FreeTmpBuffer(pvkmBuf);
        }
    }

    return(ReturnBytes);
}

/******************************Public*Routine******************************\
* NtGdiGetGlyphOutline
*
* Arguments:
*
*   hdc             - device context
*   wch             - character to query
*   iFormat         - format of data to return
*   pgm             - address of structure for metrics
*   cjBuf           - size of buffer for data
*   pvBuf           - address of buffer for data
*   pmat2           - address of transformation matrix structure
*   bIgnoreRotation - internal rotation flag
*
* Return Value:
*
*   If the function succeeds, and GGO_BITMAP or GGO_NATIVE is specified,
*       then return value is greater than zero.
*   If the function succeeds, and GGO_METRICS is specified,
*       then return value is zero.
*   If GGO_BITMAP or GGO_NATIVE is specified,
*       and the buffer size or address is zero,
*       then return value specifies the required buffer size.
*       If GGO_BITMAP or GGO_NATIVE is specified,
*       and the function fails for other reasons,
*       then return value is GDI_ERROR.
*   If GGO_METRICS is specified, and the function fails,
*       then return value is GDI_ERROR.
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetGlyphOutline(
    HDC            hdc,
    WCHAR          wch,
    UINT           iFormat,
    LPGLYPHMETRICS pgm,
    ULONG          cjBuf,
    PVOID          pvBuf,
    LPMAT2         pmat2,
    BOOL           bIgnoreRotation
    )
{
    // error return value of -1 from server.inc

    DWORD   dwRet = (DWORD)-1;
    PVOID   pvkmBuf;
    MAT2    kmMat2;
    GLYPHMETRICS kmGlyphMetrics;

// try to allocate buffer

    pvkmBuf = (cjBuf) ? AllocFreeTmpBuffer(cjBuf) : NULL;

    if ((pvkmBuf != NULL) || !cjBuf)
    {
        BOOL bStatus = TRUE;

    // copy input structures

        try
        {
            kmMat2 = ProbeAndReadStructure(pmat2,MAT2);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(36);
            // SetLastError(GetExceptionCode());
            bStatus = FALSE;
        }

        if (bStatus)
        {
            dwRet = GreGetGlyphOutlineInternal(
                                        hdc,
                                        wch,
                                        iFormat,
                                        &kmGlyphMetrics,
                                        cjBuf,
                                        pvkmBuf,
                                        &kmMat2,
                                        bIgnoreRotation);

            if (dwRet != (DWORD)-1)
            {
                try
                {
                    if( pvkmBuf )
                    {
                        ProbeAndWriteBuffer(pvBuf,pvkmBuf,cjBuf);
                    }
                    ProbeAndWriteStructure(pgm,kmGlyphMetrics,GLYPHMETRICS);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(37);
                    // SetLastError(GetExceptionCode());
                    dwRet = (DWORD)-1;
                }
            }
        }

        if( pvkmBuf )
        {
            FreeTmpBuffer(pvkmBuf);
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetRasterizerCaps()
*
* History:
*  08-Mar-1995 -by-  Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetRasterizerCaps(
    LPRASTERIZER_STATUS praststat,
    ULONG               cjBytes
    )
{

    BOOL              bStatus = FALSE;
    RASTERIZER_STATUS tempRasStatus;

    if (praststat && cjBytes)
    {
        cjBytes = min(cjBytes, sizeof(RASTERIZER_STATUS));

        if (GreGetRasterizerCaps(&tempRasStatus))
        {
            try
            {
                ProbeAndWriteAlignedBuffer(praststat, &tempRasStatus, cjBytes, sizeof(DWORD));
                bStatus = TRUE;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(38);
                // SetLastError(GetExceptionCode());
            }
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* NtGdiGetKerningPairs
*
* Arguments:
*
*   hdc    - device context
*   cPairs - number of pairs to retrieve
*   pkpDst - Pointer to buffer to recieve kerning pairs data or NULL
*
* Return Value:
*
*   If pkpDst is NULL, return number of Kerning pairs in font,
*   otherwise return number of kerning pairs written to buffer.
*   If failure, return 0
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetKerningPairs(
    HDC          hdc,
    ULONG        cPairs,
    KERNINGPAIR *pkpDst
    )
{
    ULONG cRet = 0;
    KERNINGPAIR *pkmKerningPair = (KERNINGPAIR *)NULL;

    if (pkpDst != (KERNINGPAIR *)NULL)
    {
         if (!BALLOC_OVERFLOW1(cPairs,KERNINGPAIR))
         {
             pkmKerningPair = AllocFreeTmpBuffer(sizeof(KERNINGPAIR) * cPairs);
         }
    }

    if ((pkpDst == (KERNINGPAIR *)NULL) ||
        (pkmKerningPair != (KERNINGPAIR *)NULL))
    {
        cRet = GreGetKerningPairs(hdc,cPairs,pkmKerningPair);

        //
        // copy data out if needed
        //

        if (pkpDst != (KERNINGPAIR *)NULL)
        {
            if (cRet != 0)
            {
                try
                {
                    ProbeAndWriteBuffer(pkpDst,pkmKerningPair,sizeof(KERNINGPAIR) * cRet);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(39);
                    // SetLastError(GetExceptionCode());
                    cRet = 0;
                }
            }

            FreeTmpBuffer(pkmKerningPair);
        }
    }
    return(cRet);
}


/******************************Public*Routine******************************\
* NtGdiGetObjectBitmapHandle()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiGetObjectBitmapHandle(
    HBRUSH hbr,
    UINT  *piUsage
    )
{
    UINT iUsage;
    HBITMAP hbitmap = (HBITMAP)1;

    // error checking
    int iType = LO_TYPE(hbr);

    if ((iType != LO_BRUSH_TYPE) &&
        (iType != LO_EXTPEN_TYPE))
    {
        return((HBITMAP)hbr);
    }

    hbitmap = GreGetObjectBitmapHandle(hbr,&iUsage);

    if (hbitmap)
    {
        try
        {
            ProbeAndWriteUlong(piUsage,iUsage);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(40);
            // SetLastError(GetExceptionCode());

            hbitmap = (HBITMAP)0;
        }
    }

    return (hbitmap);
}

/******************************Public*Routine******************************\
* NtGdiResetDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  26-Feb-1995 -by- Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiResetDC(
    HDC             hdc,
    LPDEVMODEW      pdm,
    BOOL           *pbBanding,
    DRIVER_INFO_2W *pDriverInfo2,
    PVOID           ppUMdhpdev
    )
{
    LPDEVMODEW      pdmTmp = NULL;
    DWORD           dwTmp;
    INT             iRet = 1;
    INT             cj;
    DRIVER_INFO_2W *pKmDriverInfo2 = NULL;

    try
    {
        // Make a kernel mode copy of DEVMODEW structure

        iRet = (pdm == NULL) ||
               (pdmTmp = CaptureDEVMODEW(pdm)) != NULL;


        // Make a kernel mode copy of DRIVER_INFO_2W structure

        iRet = iRet &&
               ((pDriverInfo2 == NULL) ||
                (pKmDriverInfo2 = CaptureDriverInfo2W(pDriverInfo2)) != NULL);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(41);
        iRet = 0;
    }

    if (iRet)
    {
        iRet = GreResetDCInternal(hdc,pdmTmp,&dwTmp, pKmDriverInfo2, ppUMdhpdev);

        if (iRet)
        {
            try
            {
                ProbeAndWriteUlong(pbBanding,dwTmp);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(42);
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }

        }
    }

    if (pdmTmp)
    {
        VFREETHREADMEM(pdmTmp);
    }

    vFreeDriverInfo2(pKmDriverInfo2);

    return (iRet);

}

/******************************Public*Routine******************************\
* NtGdiSetBoundsRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
NtGdiSetBoundsRect(
    HDC    hdc,
    LPRECT prc,
    DWORD  f
    )
{
    DWORD dwRet=0;
    RECT rc;

    if (prc)
    {
        try
        {
            rc    = ProbeAndReadStructure(prc,RECT);
            prc   = &rc;
            dwRet = 1;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(43);
            // SetLastError(GetExceptionCode());

            dwRet = 0;
        }
    }
    else
    {
        // can't use the DCB_ACCUMULATE without a rectangle

        f &= ~DCB_ACCUMULATE;
        dwRet = 1;
    }

    if (dwRet)
        dwRet = GreSetBoundsRect(hdc,prc,f);

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetColorAdjustment()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetColorAdjustment(
    HDC              hdc,
    PCOLORADJUSTMENT pcaOut
    )
{
    BOOL bRet;
    COLORADJUSTMENT ca;

    bRet = GreGetColorAdjustment(hdc,&ca);

    if (bRet)
    {
        try
        {
            ProbeAndWriteStructure(pcaOut,ca,COLORADJUSTMENT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(44);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetColorAdjustment()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetColorAdjustment(
    HDC              hdc,
    PCOLORADJUSTMENT pca
    )
{
    BOOL bRet;
    COLORADJUSTMENT ca;

    try
    {
        ca = ProbeAndReadStructure(pca,COLORADJUSTMENT);
        bRet = 1;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(45);
        // SetLastError(GetExceptionCode());

        bRet = 0;
    }

    if (bRet)
    {
        // Range check all the adjustment values.  Return FALSE if any of them
        // is out of range.

        if ((ca.caSize != sizeof(COLORADJUSTMENT)) ||
            (ca.caIlluminantIndex > ILLUMINANT_MAX_INDEX) ||
            ((ca.caRedGamma > RGB_GAMMA_MAX) ||
             (ca.caRedGamma < RGB_GAMMA_MIN)) ||
            ((ca.caGreenGamma > RGB_GAMMA_MAX) ||
             (ca.caGreenGamma < RGB_GAMMA_MIN)) ||
            ((ca.caBlueGamma > RGB_GAMMA_MAX) ||
             (ca.caBlueGamma < RGB_GAMMA_MIN)) ||
            ((ca.caReferenceBlack > REFERENCE_BLACK_MAX) ||
             (ca.caReferenceBlack < REFERENCE_BLACK_MIN)) ||
            ((ca.caReferenceWhite > REFERENCE_WHITE_MAX) ||
             (ca.caReferenceWhite < REFERENCE_WHITE_MIN)) ||
            ((ca.caContrast > COLOR_ADJ_MAX) ||
             (ca.caContrast < COLOR_ADJ_MIN)) ||
            ((ca.caBrightness > COLOR_ADJ_MAX) ||
             (ca.caBrightness < COLOR_ADJ_MIN)) ||
            ((ca.caColorfulness > COLOR_ADJ_MAX) ||
             (ca.caColorfulness < COLOR_ADJ_MIN)) ||
            ((ca.caRedGreenTint > COLOR_ADJ_MAX) ||
             (ca.caRedGreenTint < COLOR_ADJ_MIN)))
        {
            bRet = 0;
        }
        else
        {
            bRet = GreSetColorAdjustment(hdc,&ca);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiCancelDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiCancelDC(
    HDC hdc
    )
{
    return(GreCancelDC(hdc));
}

//API's used by USER

/******************************Public*Routine******************************\
* NtGdiSelectBrush()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiSelectBrush(
    HDC    hdc,
    HBRUSH hbrush
    )
{
    return(GreSelectBrush(hdc,(HANDLE)hbrush));
}

/******************************Public*Routine******************************\
* NtGdiSelectPen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiSelectPen(
    HDC  hdc,
    HPEN hpen
    )
{
    return(GreSelectPen(hdc,hpen));
}

/******************************Public*Routine******************************\
* NtGdiSelectFont()
*
* History:
*  18-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

HFONT
APIENTRY
NtGdiSelectFont(HDC hdc, HFONT hf)
{
    return(GreSelectFont(hdc, hf));
}

/******************************Public*Routine******************************\
* NtGdiSelectBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiSelectBitmap(
    HDC     hdc,
    HBITMAP hbm
    )
{
    return(hbmSelectBitmap(hdc,hbm,FALSE));
}

/******************************Public*Routine******************************\
* NtGdiExtSelectClipRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExtSelectClipRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iMode
    )
{
    return(GreExtSelectClipRgn(hdc,hrgn,iMode));
}

/******************************Public*Routine******************************\
* NtGdiCreatePen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiCreatePen(
    int      iPenStyle,
    int      iPenWidth,
    COLORREF cr,
    HBRUSH   hbr
    )
{
    return(GreCreatePen(iPenStyle,iPenWidth,cr,hbr));
}


/******************************Public*Routine******************************\
*
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiStretchBlt(
    HDC   hdcDst,
    int   xDst,
    int   yDst,
    int   cxDst,
    int   cyDst,
    HDC   hdcSrc,
    int   xSrc,
    int   ySrc,
    int   cxSrc,
    int   cySrc,
    DWORD dwRop,
    DWORD dwBackColor
    )
{
    return(GreStretchBlt(
                    hdcDst,xDst,yDst,cxDst,cyDst,
                    hdcSrc,xSrc,ySrc,cxSrc,cySrc,
                    dwRop,dwBackColor));
}

/******************************Public*Routine******************************\
* NtGdiMoveTo()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiMoveTo(
    HDC     hdc,
    int     x,
    int     y,
    LPPOINT pptOut
    )
{
    BOOL bRet;
    POINT pt;

    bRet = GreMoveTo(hdc,x,y,&pt);

    if (bRet && pptOut)
    {
        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(47);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetDeviceCaps()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetDeviceCaps(
    HDC hdc,
    int i
    )
{
    return(GreGetDeviceCaps(hdc,i));
}

/******************************Public*Routine******************************\
* NtGdiSaveDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiSaveDC(
    HDC hdc
    )
{
    return(GreSaveDC(hdc));
}

/******************************Public*Routine******************************\
* NtGdiRestoreDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRestoreDC(
    HDC hdc,
    int iLevel
    )
{
    return(GreRestoreDC(hdc,iLevel));
}

/******************************Public*Routine******************************\
* NtGdiGetNearestColor()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF
APIENTRY
NtGdiGetNearestColor(
    HDC      hdc,
    COLORREF cr
    )
{
    return(GreGetNearestColor(hdc,cr));
}

/******************************Public*Routine******************************\
* NtGdiGetSystemPaletteUse()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiGetSystemPaletteUse(
    HDC hdc
    )
{
    return(GreGetSystemPaletteUse(hdc));
}

/******************************Public*Routine******************************\
* NtGdiSetSystemPaletteUse()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiSetSystemPaletteUse(
    HDC  hdc,
    UINT ui
    )
{
    return(GreSetSystemPaletteUse(hdc,ui));
}


/******************************Public*Routine******************************\
* NtGdiGetRandomRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetRandomRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iRgn
    )
{
    return(GreGetRandomRgn(hdc,hrgn,iRgn));
}

/******************************Public*Routine******************************\
* NtGdiIntersectClipRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiIntersectClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    return(GreIntersectClipRect(hdc,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiExcludeClipRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExcludeClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    return(GreExcludeClipRect(hdc,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiOpenDCW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  27-Feb-1995 -by- Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

HDC
APIENTRY
NtGdiOpenDCW(
    PUNICODE_STRING     pustrDevice,
    DEVMODEW *          pdm,
    PUNICODE_STRING     pustrLogAddr,
    ULONG               iType,
    HANDLE              hspool,
    DRIVER_INFO_2W     *pDriverInfo2,
    PVOID               ppUMdhpdev
    )
{
    HDC             hdc = NULL;
    ULONG           iRet = 0;
    PWSZ            pwszDevice = NULL;
    LPDEVMODEW      pdmTmp = NULL;
    INT             cjDevice;
    PWSTR           pwstrDevice;
    DRIVER_INFO_2W *pKmDriverInfo2 = NULL;

    //
    // This API overloads the pwszDevice parameter.
    //
    // If pustrDevice is NULL, it is equivalent to calling with "DISPLAY"
    // which means to get a DC on the current device, which is done by
    // calling USER
    //

    if (pustrDevice == NULL)
    {
        hdc = UserGetDesktopDC(iType, FALSE, TRUE);
    }
    else
    {
        try
        {
            ProbeForRead(pustrDevice,sizeof(UNICODE_STRING), sizeof(CHAR));
            cjDevice = pustrDevice->Length;
            pwstrDevice = pustrDevice->Buffer;

            if (cjDevice)
            {
                if (cjDevice <= (MAXIMUM_POOL_ALLOC - sizeof(WCHAR)))
                {
                    pwszDevice = AllocFreeTmpBuffer(cjDevice + sizeof(WCHAR));
                }

                if (pwszDevice)
                {
                    ProbeAndReadBuffer(pwszDevice,pwstrDevice,cjDevice);
                    pwszDevice[(cjDevice/sizeof(WCHAR))] = L'\0';
                }

            }

            // Make a kernel copy of DEVMODEW structure

            iRet = (pdm == NULL) ||
                   (pdmTmp = CaptureDEVMODEW(pdm)) != NULL;

            // Make a kernel copy of DRIVER_INFO_2W structure

            iRet = iRet &&
                   ((pDriverInfo2 == NULL) ||
                    (pKmDriverInfo2 = CaptureDriverInfo2W(pDriverInfo2)) != NULL);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(48);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }

        if (iRet)
        {
            hdc = hdcOpenDCW(pwszDevice,
                             pdmTmp,
                             iType,
                             hspool,
                             NULL,
                             pKmDriverInfo2,
                             ppUMdhpdev);

        }

        if (pwszDevice)
            FreeTmpBuffer(pwszDevice);

        if (pdmTmp)
            VFREETHREADMEM(pdmTmp);

        vFreeDriverInfo2(pKmDriverInfo2);
    }

    return (hdc);
}

/******************************Public*Routine******************************\
* NtGdiCreateCompatibleBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateCompatibleBitmap(
    HDC hdc,
    int cx,
    int cy
    )
{
    return(GreCreateCompatibleBitmap(hdc,cx,cy));
}

/******************************Public*Routine******************************\
* NtGdiCreateBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  04-MAR-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateBitmap(
    int    cx,
    int    cy,
    UINT   cPlanes,
    UINT   cBPP,
    LPBYTE pjInit
    )
{
    ULONG_PTR iRet = 1;
    HANDLE hSecure = 0;

    INT cj;

    if (pjInit == (VOID *) NULL)
    {
        cj = 0;
    }
    else
    {
        // only needs to word aligned and sized

        cj = noOverflowCJSCANW(cx,(WORD) cPlanes,(WORD) cBPP,cy);
        
        if (cj == 0)
            iRet = 0;
    }

    if (cj)
    {
        try
        {
            ProbeForRead(pjInit,cj,sizeof(BYTE));

            hSecure = MmSecureVirtualMemory(pjInit, cj, PAGE_READONLY);

            if (hSecure == 0)
            {
                iRet = 0;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(49);
            iRet = 0;
        }
    }

    // if we didn't hit an error above

    if (iRet)
    {
        iRet = (ULONG_PTR)GreCreateBitmap(cx,cy,cPlanes,cBPP,pjInit);

    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return((HBITMAP)iRet);
}

/******************************Public*Routine******************************\
* NtGdiSetBitmapAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiSetBitmapAttributes(
    HBITMAP hbm,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBitmapStock(hbm));
    return (HBITMAP)0;
}

/******************************Public*Routine******************************\
* NtGdiClearBitmapAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiClearBitmapAttributes(
    HBITMAP hbm,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBitmapNonStock(hbm));
    return (HBITMAP)0;
}

/******************************Public*Routine******************************\
* NtGdiSetBrushAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiSetBrushAttributes(
    HBRUSH hbr,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBrushStock(hbr));
    return (HBRUSH)0;
}

/******************************Public*Routine******************************\
* NtGdiClearBrushAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiClearBrushAttributes(
    HBRUSH hbr,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBrushNonStock(hbr));
    return (HBRUSH)0;
}

/******************************Public*Routine******************************\
* NtGdiCreateHalftonePalette()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
NtGdiCreateHalftonePalette(
    HDC hdc
    )
{
    return(GreCreateCompatibleHalftonePalette(hdc));
}

/******************************Public*Routine******************************\
* NtGdiGetStockObject()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
NtGdiGetStockObject(
    int iObject
    )
{
    return(GreGetStockObject(iObject));
}

/******************************Public*Routine******************************\
* NtGdiExtGetObjectW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExtGetObjectW(
    HANDLE h,
    int    cj,
    LPVOID pvOut
    )
{
    int iRet = 0;
    union
    {
        BITMAP          bm;
        DIBSECTION      ds;
        EXTLOGPEN       elp;
        LOGPEN          l;
        LOGBRUSH        lb;
        LOGFONTW        lf;
        ENUMLOGFONTEXDVW elf;
        LOGCOLORSPACEEXW lcsp;
    } obj;
    int iType = LO_TYPE(h);
    int ci;

    if ((cj < 0) || (cj > sizeof(obj)))
    {
        WARNING("GetObject size too big\n");
        cj = sizeof(obj);
    }
    ci = cj;

    //
    // make the getobject call on brush
    // still work even the app passes in
    // a cj < sizeof(LOGBRUSH)
    //
    if (iType == LO_BRUSH_TYPE)
    {
        cj = sizeof(LOGBRUSH);
    }

    iRet = GreExtGetObjectW(h,cj,pvOut ? &obj : NULL);

    if (iType == LO_BRUSH_TYPE)
    {
        cj = min(cj, ci);
    }

    if (iRet && pvOut)
    {
        try
        {
            ProbeAndWriteAlignedBuffer(pvOut,&obj,MIN(cj,iRet), sizeof(WORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(50);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiSetBrushOrg()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetBrushOrg(
    HDC     hdc,
    int     x,
    int     y,
    LPPOINT pptOut
    )
{
    BOOL bRet;
    POINT pt;

    bRet = GreSetBrushOrg(hdc,x,y,&pt);

    if (bRet && pptOut)
    {
        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(51);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiUnrealizeObject()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiUnrealizeObject(
    HANDLE h
    )
{
    return(GreUnrealizeObject(h));
}

/******************************Public*Routine******************************\
*
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiCombineRgn(
    HRGN hrgnDst,
    HRGN hrgnSrc1,
    HRGN hrgnSrc2,
    int  iMode
    )
{
    return(GreCombineRgn(hrgnDst,hrgnSrc1,hrgnSrc2,iMode));
}

/******************************Public*Routine******************************\
* NtGdiSetRectRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetRectRgn(
    HRGN hrgn,
    int  xLeft,
    int  yTop,
    int  xRight,
    int  yBottom
    )
{
    return(GreSetRectRgn(hrgn,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiSetBitmapBits()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG
APIENTRY
NtGdiSetBitmapBits(
    HBITMAP hbm,
    ULONG   cj,
    PBYTE   pjInit
    )
{
    LONG    lRet = 1;
    LONG    lOffset = 0;
    HANDLE hSecure = 0;

    try
    {
        //  Each scan is copied seperately

        ProbeForRead(pjInit,cj,sizeof(BYTE));
        hSecure = MmSecureVirtualMemory(pjInit, cj, PAGE_READONLY);

        if (hSecure == 0)
        {
            lRet = 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(52);
        // SetLastError(GetExceptionCode());

        lRet = 0;
    }

    if (lRet)
        lRet = GreSetBitmapBits(hbm,cj,pjInit,&lOffset);

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return (lRet);
}

/******************************Public*Routine******************************\
* NtGdiOffsetRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiOffsetRgn(
    HRGN hrgn,
    int  cx,
    int  cy
    )
{
    return(GreOffsetRgn(hrgn,cx,cy));
}

/******************************Public*Routine******************************\
* NtGdiGetRgnBox()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by- Lingyun Wang [lingyunw]
* expanded it.
\**************************************************************************/

int
APIENTRY
NtGdiGetRgnBox(
    HRGN   hrgn,
    LPRECT prcOut
    )
{
    RECT rc;
    int iRet;

    iRet = GreGetRgnBox(hrgn,&rc);

    if (iRet)
    {
        try
        {
            ProbeAndWriteStructure(prcOut,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(53);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiRectInRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRectInRegion(
    HRGN   hrgn,
    LPRECT prcl
    )
{
    RECT rc;
    BOOL bRet;

    if (prcl)
    {
        RECT   rclTmp;
        bRet = TRUE;

        try
        {
            rclTmp = ProbeAndReadStructure(prcl,RECT);

            //
            // Order the rectangle
            //

            if (rclTmp.left > rclTmp.right)
            {
                rc.left = rclTmp.right;
                rc.right = rclTmp.left;
            }
            else
            {
                rc.left = rclTmp.left;
                rc.right = rclTmp.right;
            }

            if (rclTmp.top > rclTmp.bottom)
            {
                rc.top = rclTmp.bottom;
                rc.bottom = rclTmp.top;
            }
            else
            {
                rc.top = rclTmp.top;
                rc.bottom = rclTmp.bottom;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(54);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }

        if (bRet)
        {
            bRet = GreRectInRegion(hrgn,&rc);

            if (bRet)
            {
                try
                {
                    ProbeAndWriteStructure(prcl,rc,RECT);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(55);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiPtInRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiPtInRegion(
    HRGN hrgn,
    int  x,
    int  y
    )
{
    return(GrePtInRegion(hrgn,x,y));
}



/******************************Public*Routine******************************\
* NtGdiGetDIBitsInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetDIBitsInternal(
    HDC          hdc,
    HBITMAP      hbm,
    UINT         iStartScan,
    UINT         cScans,
    LPBYTE       pBits,
    LPBITMAPINFO pbmi,
    UINT         iUsage,
    UINT         cjMaxBits,
    UINT         cjMaxInfo
    )
{
    int   iRet = 0;
    ULONG cjHeader = 0;
    BOOL  bNullWidth = TRUE;
    HANDLE hSecure = 0;

    union
    {
        BITMAPINFOHEADER bmih;
        BITMAPCOREHEADER bmch;
    } bmihTmp;

    PBITMAPINFO pbmiTmp = (PBITMAPINFO)&bmihTmp.bmih;

    // do some up front validation

    if (((iUsage != DIB_RGB_COLORS) &&
         (iUsage != DIB_PAL_COLORS) &&
         (iUsage != DIB_PAL_INDICES)) ||
        (pbmi == NULL) ||
        (hbm  == NULL))
    {
        return(0);
    }

    if (cScans == 0)
        pBits = (PVOID) NULL;

    try
    {
        //
        // pbmi might not be aligned.
        // First probe to get the size of the structure
        // located in the first DWORD. Later, probe the
        // actual structure size
        //

        ProbeForRead(pbmi,sizeof(DWORD),sizeof(BYTE));

        // If the bitcount is zero, we will return only the bitmap info or core
        // header without the color table.  Otherwise, we always return the bitmap
        // info with the color table.

        {
            ULONG StructureSize = pbmi->bmiHeader.biSize;

            //
            // probe the correct structure size,
            // so that we can read/write entire of bitmap header.
            //

            ProbeForWrite(pbmi,StructureSize,sizeof(BYTE));

            if (pBits == (PVOID) NULL)
            {
                if ((StructureSize == sizeof(BITMAPCOREHEADER)) &&
                    (((PBITMAPCOREINFO) pbmi)->bmciHeader.bcBitCount == 0))
                {
                    cjHeader = sizeof(BITMAPCOREHEADER);
                }
                else if ((StructureSize >= sizeof(BITMAPINFOHEADER)) &&
                         (pbmi->bmiHeader.biBitCount == 0))
                {
                    cjHeader = sizeof(BITMAPINFOHEADER);
                }
            }
        }

        // we just need the header so copy it.

        if (cjHeader)
        {
            RtlCopyMemory(pbmiTmp,pbmi,cjHeader);
            pbmiTmp->bmiHeader.biSize = cjHeader;
        }
        else
        {
            // We need to set biClrUsed to 0 so GreGetBitmapSize computes
            // the correct values.  biClrUsed is not a input, just output.

            if (pbmi->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
            {
                // NOTE: We are going to modify bitmap header
                // in user mode memory here
                // that's why we need to do ProbeWrite()

                pbmi->bmiHeader.biClrUsed = 0;
            }

            // We need more than just the header.  This may include bits.
            // Compute the the full size of the BITMAPINFO

            cjHeader = GreGetBitmapSize(pbmi,iUsage);

            if (cjHeader)
            {
                pbmiTmp = PALLOCMEM(cjHeader,'pmtG');

                if (pbmiTmp)
                {
                    // The earlier write probe does not probe all of the
                    // memory we might read in this case.

                    ProbeAndReadBuffer(pbmiTmp,pbmi,cjHeader);

                    // Now that it is safe, make sure it hasn't changed

                    if (GreGetBitmapSize(pbmiTmp,iUsage) != cjHeader)
                    {
                        cjHeader = 0;
                    }
                    else
                    {
                        // We need to set biClrUsed to 0 so GreGetBitmapSize computes
                        // the correct values.  biClrUsed is not a input, just output.

                        if (pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
                        {
                            pbmiTmp->bmiHeader.biClrUsed = 0;
                        }

                        // Get iStartScan and cNumScan in a valid range.

                        if (cScans)
                        {
                            if (pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
                            {
                                ULONG ulHeight = ABS(pbmiTmp->bmiHeader.biHeight);

                                iStartScan = MIN(ulHeight, iStartScan);
                                cScans     = MIN((ulHeight - iStartScan), cScans);

                                bNullWidth = (pbmiTmp->bmiHeader.biWidth    == 0) ||
                                             (pbmiTmp->bmiHeader.biPlanes   == 0) ||
                                             (pbmiTmp->bmiHeader.biBitCount == 0);
                            }
                            else
                            {
                                LPBITMAPCOREHEADER pbmc = (LPBITMAPCOREHEADER)pbmiTmp;

                                iStartScan = MIN((UINT)pbmc->bcHeight, iStartScan);
                                cScans     = MIN((UINT)(pbmc->bcHeight - iStartScan), cScans);

                                bNullWidth = (pbmc->bcWidth    == 0) ||
                                             (pbmc->bcPlanes   == 0) ||
                                             (pbmc->bcBitCount == 0);
                            }
                        }
                    }
                }
            }
        }

        if (cjHeader && pBits && pbmiTmp)
        {
            // if they passed a buffer and it isn't BI_RGB,
            // they must supply buffer size, 0 is an illegal value

            if ((pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) &&
                ((pbmiTmp->bmiHeader.biCompression == BI_RLE8) ||
                 (pbmiTmp->bmiHeader.biCompression == BI_RLE4))       &&
                (pbmiTmp->bmiHeader.biSizeImage == 0))
            {
                cjHeader = 0;
            }
            else
            {
                if (cjMaxBits == 0)
                    cjMaxBits = GreGetBitmapBitsSize(pbmiTmp);

                if (cjMaxBits)
                {
                    ProbeForWrite(pBits,cjMaxBits,sizeof(DWORD));
                    hSecure = MmSecureVirtualMemory(pBits, cjMaxBits, PAGE_READWRITE);
                }

                if (hSecure == 0)
                {
                    cjHeader = 0;
                }
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(56);
        cjHeader = 0;
    }

    // did we have an error

    if ((pBits && bNullWidth) || (cjHeader == 0) || (pbmiTmp == NULL))
    {
        //GdiSetLastError(ERROR_INVALID_PARAMETER);
        iRet = 0;
    }
    else
    {
        // do the work

        iRet = GreGetDIBitsInternal(
                            hdc,hbm,
                            iStartScan,cScans,
                            pBits,pbmiTmp,
                            iUsage,cjMaxBits,cjHeader
                            );

        // copy out the header

        if (iRet)
        {
            try
            {
                RtlCopyMemory(pbmi,pbmiTmp,cjHeader);

                // WINBUG #83055 2-7-2000 bhouse Investigate need to unlock bits
                // Old Comment:
                //    - we also need to unlock the bits
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(57);
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }

        }
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    if (pbmiTmp && (pbmiTmp != (PBITMAPINFO)&bmihTmp.bmih))
        VFREEMEM(pbmiTmp);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextExtent(
*
* History:
*  07-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTextExtent(
    HDC     hdc,
    LPWSTR  lpwsz,
    int     cwc,
    LPSIZE  psize,
    UINT    flOpts
    )
{
    SIZE size;
    PWSZ pwszCapt = NULL;
    WCHAR Localpwsz[LOCAL_CWC_MAX];
    BOOL UseLocals;

    BOOL bRet = FALSE;

    if (cwc >= 0)
    {
        if (cwc == 0)
        {
            size.cx = 0;
            size.cy = 0;

            bRet = TRUE;
        }
        else
        {
            if ( cwc > LOCAL_CWC_MAX ) {
                UseLocals = FALSE;
            } else {
                UseLocals = TRUE;
            }

            //
            // capture the string
            //

            if (lpwsz != NULL)
            {
                try
                {
                    if ( UseLocals )
                    {
                        pwszCapt = Localpwsz;
                    }
                    else
                    {
                        if (!BALLOC_OVERFLOW1(cwc,WCHAR))
                        {
                            pwszCapt = (PWSZ) AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
                        }
                    }

                    if (pwszCapt)
                    {
                        ProbeAndReadAlignedBuffer(pwszCapt, lpwsz, cwc*sizeof(WCHAR), sizeof(WCHAR));
                        bRet = TRUE;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(58);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                bRet = GreGetTextExtentW(hdc, pwszCapt, cwc, &size, flOpts);
            }

            if (!UseLocals && pwszCapt)
            {
                FreeTmpBuffer(pwszCapt);
            }
        }

        //
        // Write the value back into the user mode buffer
        //

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,size,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(59);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return (bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetTextMetricsW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTextMetricsW(
    HDC            hdc,
    TMW_INTERNAL * ptm,
    ULONG cj
    )
{

    BOOL bRet = FALSE;
    TMW_INTERNAL tmw;

    if (cj <= sizeof(tmw))
    {
        bRet = GreGetTextMetricsW(hdc,&tmw);

        if (bRet)
        {
            try
            {
                ProbeAndWriteAlignedBuffer(ptm,&tmw,cj, sizeof(DWORD));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(60);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextFaceW()
*
* History:
* 10-Mar-1995 -by- Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetTextFaceW(
    HDC    hdc,
    int    cChar,
    LPWSTR pszOut,
    BOOL   bAliasName
    )
{
    int    cRet = 0;
    BOOL   bStatus = TRUE;
    PWCHAR pwsz_km = (PWCHAR)NULL;

    if ((cChar > 0) && (pszOut))
    {
        if (!BALLOC_OVERFLOW1(cChar,WCHAR))
        {
            pwsz_km = AllocFreeTmpBuffer(cChar * sizeof(WCHAR));
        }

        if (pwsz_km == (PWCHAR)NULL)
        {
            bStatus = FALSE;
        }
    }

    if (bStatus)
    {
        cRet = GreGetTextFaceW(hdc,cChar,pwsz_km, bAliasName);

        if ((cRet > 0) && (pszOut))
        {

            ASSERTGDI(cRet <= cChar, "GreGetTextFaceW, cRet too big\n");
            try
            {
                ProbeAndWriteBuffer(pszOut,pwsz_km,cRet * sizeof(WCHAR));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(61);
                // SetLastError(GetExceptionCode());
                cRet = 0;
            }
        }

        if (pwsz_km != (PWCHAR)NULL)
        {
            FreeTmpBuffer(pwsz_km);
        }
    }
    return(cRet);
}
/******************************Public*Routine******************************\
* NtGdiFontIsLinked()
*
* History:
* 9-July-1998 -by- Yung-Jen Tony Tsai [marke]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiFontIsLinked(
    HDC    hdc
    )
{
    return GreFontIsLinked(hdc);
}

/****************************************************************************
*  NtGdiQueryFonts
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

INT NtGdiQueryFonts(
    PUNIVERSAL_FONT_ID pufiFontList,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
    )
{
    INT iRet = 0;
    PUNIVERSAL_FONT_ID pufi = NULL;
    LARGE_INTEGER TimeStamp;

    if( ( nBufferSize > 0 ) && ( pufiFontList != NULL ) )
    {
        if (!BALLOC_OVERFLOW1(nBufferSize,UNIVERSAL_FONT_ID))
        {
            pufi = AllocFreeTmpBuffer(nBufferSize * sizeof(UNIVERSAL_FONT_ID));
        }

        if( pufi == NULL )
        {
            iRet = -1 ;
        }
    }

    if( iRet != -1 )
    {
        iRet = GreQueryFonts(pufi, nBufferSize, &TimeStamp );

        if( iRet != -1 )
        {
            try
            {
                ProbeAndWriteStructure(pTimeStamp,TimeStamp,LARGE_INTEGER);

                if( pufiFontList )
                {
                    ProbeAndWriteAlignedBuffer(pufiFontList,pufi,
                                  sizeof(UNIVERSAL_FONT_ID)*nBufferSize, sizeof(DWORD));
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(62);
                iRet = -1;
            }

        }
    }

    if( pufi != NULL )
    {
        FreeTmpBuffer( pufi );
    }

    if( iRet == -1 )
    {
        // We need to set the last error here to something because the spooler
        // code that calls this relies on there being a non-zero error code
        // in the case of failure.  Since we really have no idea I will just
        // set this to ERROR_NOT_ENOUGH_MEMORY which would be the most likely
        // reason for a failure

        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(iRet);

}

BOOL
GreExtTextOutRect(
    HDC     hdc,
    LPRECT  prcl
    );


/******************************Public*Routine******************************\
* NtGdiExtTextOutW()
*
* History:
*  06-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL NtGdiExtTextOutW
(
    HDC     hdc,
    int     x,                  // Initial x position
    int     y,                  // Initial y position
    UINT    flOpts,             // Options
    LPRECT  prcl,               // Clipping rectangle
    LPWSTR  pwsz,               // UNICODE Character array
    int     cwc,                // char count
    LPINT   pdx,                // Character spacing
    DWORD   dwCodePage          // Code page
)
{
    RECT newRect;
    BOOL bRet;
    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    BYTE *pjAlloc;
    BYTE *pjCapture;
    BYTE *pjStrobj;
    LONG cjDx;
    LONG cjStrobj;
    LONG cjString;
    LONG cj;

// huge values of cwc will lead to an overflow below causing the system to
// crash

    if ((cwc < 0) || (cwc > 0xffff))
    {
        return(FALSE);
    }

    if (prcl)
    {
        if (flOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            try
            {
                newRect = ProbeAndReadStructure(prcl,RECT);
                prcl = &newRect;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(63);
                // SetLastError(GetExceptionCode());

                return FALSE;
            }
        }
        else
            prcl = NULL;
    }

    // 0 char case, pass off to special case code.

    if (cwc == 0)
    {
        if ((prcl != NULL) && (flOpts & ETO_OPAQUE))
        {
            bRet = GreExtTextOutRect(hdc, prcl);
        }
        else
        {
            // Bug fix, we have to return TRUE here, MS Publisher
            // doesn't work otherwise.  Not really that bad, we
            // did succeed to draw nothing.

            bRet = TRUE;
        }
    }
    else
    {
        //
        // Make sure there is a rectangle or a string if we need them:
        //

        if ( ((flOpts & (ETO_CLIPPED | ETO_OPAQUE)) && (prcl == NULL)) ||
             (pwsz == NULL) )
        {
            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;

            //
            // We allocate a single buffer to hold the captured copy of
            // the pdx array (if there is one), room for the STROBJ,
            // and to hold the captured copy of the string (in that
            // order).
            //
            // NOTE: With the appropriate exception handling in the
            //       body of ExtTextOutW, we might not need to copy
            //       these buffers:
            //

            //
            // see if it is for a user mode printer driver
            //

            cjDx     = 0;                             // dword sized
            cjStrobj = SIZEOF_STROBJ_BUFFER(cwc);     // dword sized
            cjString = cwc * sizeof(WCHAR);           // not dword sized

            if (pdx)
            {
                cjDx = cwc * sizeof(INT);             // dword sized
                if (flOpts & ETO_PDY)
                    cjDx *= 2; // space for pdy array
            }
            cj = ALIGN_PTR(cjDx) + cjStrobj + cjString;

            if (cj <= TEXT_CAPTURE_BUFFER_SIZE)
            {
                pjAlloc   = NULL;
                pjCapture = CaptureBuffer;
            }
            else
            {
                pjAlloc   = AllocFreeTmpBuffer(cj);
                pjCapture = pjAlloc;
                if (pjAlloc == NULL)
                    return(FALSE);
            }

            if (pdx)
            {
                try
                {
                // NOTE: Works95 passes byte aligned pointers for
                // this.  Since we copy it any ways, this is not
                // really a problem and it is compatible with NT 3.51.

                    ProbeForRead(pdx, cjDx, sizeof(BYTE));
                    RtlCopyMemory(pjCapture, pdx, cjDx);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(64);
                    bRet = FALSE;
                }

                pdx = (INT*) pjCapture;
                pjCapture += ALIGN_PTR(cjDx);
            }

            pjStrobj = pjCapture;
            pjCapture += cjStrobj;

            ASSERTGDI((((ULONG_PTR) pjCapture) & (sizeof(PVOID)-1)) == 0,
                      "Buffers should be ptr aligned");

            try
            {
                ProbeForRead(pwsz, cwc*sizeof(WCHAR), sizeof(WCHAR));
                RtlCopyMemory(pjCapture, pwsz, cwc*sizeof(WCHAR));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(65);
                bRet = FALSE;
            }

            if (bRet)
            {
                bRet = GreExtTextOutWInternal(hdc,
                                      x,
                                      y,
                                      flOpts,
                                      prcl,
                                      (LPWSTR) pjCapture,
                                      cwc,
                                      pdx,
                                      pjStrobj,
                                      dwCodePage);
            }

            if (pjAlloc)
            {
                FREEALLOCTEMPBUFFER(pjAlloc);
            }
        }
    }

    return bRet;
}


/************************Public*Routine**************************\
* NtGdiConsoleTextOut()
*
* History:
*  23-Mar-1998 -by-  Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

#define CONSOLE_BUFFER 128

BOOL NtGdiConsoleTextOut(
    HDC        hdc,
    POLYTEXTW *lpto,            // Ptr to array of polytext structures
    UINT       nStrings,        // number of polytext structures
    RECTL     *prclBounds
)
{
    BOOL        bStatus = TRUE;
    ULONG       ulSize = nStrings * sizeof(POLYTEXTW);
    POLYTEXTW   *lptoTmp = NULL, *ppt;
    RECTL       rclBoundsTmp;
    PBYTE       pjBuffer, pjBufferEnd;
    ULONG       aulTmp[CONSOLE_BUFFER];

    if (nStrings == 0)
        return TRUE;

    if (!lpto)
        return FALSE;

    if (prclBounds)
    {
        try
        {
            rclBoundsTmp = ProbeAndReadStructure(prclBounds, RECTL);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiConsoleTextOut invalid prclBounds\n");
            return FALSE;
        }
    }

    if (!BALLOC_OVERFLOW1(nStrings,POLYTEXTW))
    {
        try
        {
            ProbeForRead(lpto, nStrings * sizeof(POLYTEXTW), sizeof(ULONG));

            for (ppt = lpto; ppt < lpto + nStrings; ppt++)
            {
                int n = ppt->n;
                ULONG ulTmp;                // used to check for
                                            // overflow of ulSize

                //
                // Pull count from each, also check for
                // non-zero length and NULL string
                //

                ulTmp = ulSize;
                ulSize += n * sizeof(WCHAR);

                if (BALLOC_OVERFLOW1(n, WCHAR) ||
                    (ulSize < ulTmp) ||
                    (ppt->pdx != (int *)NULL) ||
                    ((n != 0) && (ppt->lpstr == NULL)))
                {
                    bStatus = FALSE;
                    break;
                }
            }

        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            bStatus = FALSE;
            WARNING("NtGdiConsoleTextOut invalid lpto\n");
        }
    }
    else
    {
        bStatus = FALSE;
    }

    if (bStatus)
    {
        if (ulSize > (CONSOLE_BUFFER * sizeof(ULONG)))
        {
            lptoTmp = AllocFreeTmpBuffer(ulSize);
        }
        else
        {
            lptoTmp = (POLYTEXTW *)aulTmp;
        }

        if (lptoTmp)
        {
            try
            {
                ProbeAndReadBuffer(lptoTmp, lpto, nStrings * sizeof(POLYTEXTW));
                pjBuffer = ((BYTE*)lptoTmp) + nStrings * sizeof(POLYTEXTW);
                pjBufferEnd = pjBuffer + ulSize;

                for (ppt = lptoTmp; ppt < lptoTmp + nStrings; ppt++)
                {
                    if (ppt->n)
                    {
                        ULONG StrSize = ppt->n * sizeof(WCHAR);

                        if (ppt->pdx || (ppt->lpstr == NULL))
                        {
                            bStatus = FALSE;
                            break;
                        }

                        if (BALLOC_OVERFLOW1(ppt->n, WCHAR) || ((pjBuffer + StrSize) > pjBufferEnd))
                        {
                            bStatus = FALSE;
                            break;
                        }

                        ProbeAndReadAlignedBuffer(pjBuffer, ppt->lpstr, StrSize, sizeof(WCHAR));
                        ppt->lpstr = (LPWSTR)pjBuffer;
                        pjBuffer += StrSize;
                    }
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bStatus = FALSE;
                WARNING("NtGdiConsoleTextOut() failed to copy lpto\n");
            }

            if (bStatus)
            {
                bStatus = GreConsoleTextOut(hdc, lptoTmp, nStrings, prclBounds ? &rclBoundsTmp : NULL);
            }

            if (lptoTmp != (POLYTEXTW *)aulTmp)
                FreeTmpBuffer(lptoTmp);
        }
        else
        {
            WARNING("NtGdiConsoleTextOut() failed to alloc mem\n");
        }
    }

    return bStatus;
}


/******************************Public*Routine******************************\
*
* BOOL bCheckAndCapThePath, used in add/remove font resoruce
*
* History:
*  11-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bCheckAndCapThePath (
    WCHAR          *pwszUcPath,   // output
    WCHAR          *pwszFiles,    // input
    ULONG           cwc,
    ULONG           cFiles
    )
{
    ULONG cFiles1 = 1; // for consistency checking
    BOOL  bRet = TRUE;
    ULONG iwc;

    ASSERTGDI(!BALLOC_OVERFLOW1(cwc,WCHAR),
              "caller should check for overflow\n");

    ProbeForRead(pwszFiles, cwc * sizeof(WCHAR), sizeof(CHAR));

    if (pwszFiles[cwc - 1] == L'\0')
    {
    // this used to be done later, in gdi code which now expects capped string

        cCapString(pwszUcPath, pwszFiles, cwc);

    // replace separators by zeros, want zero terminated strings in
    // the engine

        for (iwc = 0; iwc < cwc; iwc++)
        {
            if (pwszUcPath[iwc] == PATH_SEPARATOR)
            {
                pwszUcPath[iwc] = L'\0';
                cFiles1++;
            }
        }

    // check consistency

        if (cFiles != cFiles1)
            bRet = FALSE;

    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}



// MISC FONT API's

/******************************Public*Routine******************************\
* NtGdiAddFontResourceW()
*
* History:
*  Wed 11-Oct-1995 -by- Bodin Dresevic [BodinD]
*  Rewrote it
\**************************************************************************/

#define CWC_PATH 80

int
APIENTRY
NtGdiAddFontResourceW(
    WCHAR          *pwszFiles,
    ULONG           cwc,
    ULONG           cFiles,
    FLONG           f,
    DWORD           dwPidTid,
    DESIGNVECTOR   *pdv
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    int    iRet = 0;
    ULONG  iwc;
    DESIGNVECTOR   dvTmp;
    DWORD  cjDV = 0;
    DWORD  dvNumAxes = 0;

    try
    {
        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (cwc <= 4 * (MAX_PATH + 1))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }
            else
            {
                iRet = 0;
                WARNING("NtGdiAddFontResourceW: pwszFiles longer than 4*(MAX_PATH+1)\n");
            }

            if (pwszPath)
            {
                // RtlUpcaseUnicodeString() doesn't initialize the buffer
                // if it is bigger than 0x7FFF

                iRet = (int)bCheckAndCapThePath(pwszPath,pwszFiles,cwc,cFiles);
            }
        }

        if (iRet && pdv)
        {
            // get the dvNumAxes first
            ProbeForRead(pdv, offsetof(DESIGNVECTOR,dvValues) , sizeof(BYTE));
            dvNumAxes = pdv->dvNumAxes;

            if ((dvNumAxes > 0) && (dvNumAxes <= MM_MAX_NUMAXES))
            {
                cjDV = SIZEOFDV(dvNumAxes);
                if (!BALLOC_OVERFLOW1(cjDV, BYTE))
                {
                    ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                    pdv = &dvTmp;
                }
                else
                    iRet = 0;
            }
            else if (dvNumAxes == 0)
            {
                pdv = 0;
            }
            else
            {
                iRet = 0;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = 0;
        WARNINGX(95);
    }

    if (iRet)
        iRet = GreAddFontResourceWInternal(pwszPath, cwc, cFiles,f,dwPidTid, pdv, cjDV);

    if (iRet)   //Increase global time stamp for realization info
        (gpGdiSharedMemory->timeStamp)++;

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    TRACE_FONT(("Leaving: NtGdiAddFontResourceW"));

    return iRet;
}


/*************Public*Routine***************************\
* BOOL APIENTRY NtGdiUnmapMemFont                      *
*                                                      *
* History:                                             *
*  Jul-03-1996   -by-    Xudong Wu [TessieW]           *
*                                                      *
* Wrote it.                                            *
*******************************************************/
BOOL APIENTRY NtGdiUnmapMemFont(PVOID pvView)
{
// we may need this if we ever figure out how to map the memory font to
// the application's address space

    return 1;
}


/***************Public*Routine**************************\
* HANDLE NtGdiAddFontMemResourceEx()                    *
*                                                       *
* History:                                              *
*  09-Jun-1996   -by-    Xudong Wu [TessieW]            *
*                                                       *
* Wrote it.                                             *
********************************************************/
HANDLE APIENTRY NtGdiAddFontMemResourceEx
(
    PVOID   pvBuffer,
    ULONG   cjBuffer,
    DESIGNVECTOR    *pdv,
    DWORD   cjDV,
    DWORD   *pNumFonts
)
{
    BOOL          bOK = TRUE;
    HANDLE        hMMFont = 0;
    DESIGNVECTOR  dvTmp;

    // check the size and pointer

    if ((cjBuffer == 0) || (pvBuffer == NULL) || (pNumFonts == NULL))
    {
        return 0;
    }

    __try
    {
        if (cjDV)
        {
            if (cjDV <= SIZEOFDV(MM_MAX_NUMAXES))
            {
                ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                pdv = &dvTmp;
            }
            else
            {
                bOK = FALSE;
            }
        }
        else
        {
            pdv = NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bOK = FALSE;
        WARNING("NtGdiAddFontMemResource() try-except\n");
    }

    if (bOK)
    {
        DWORD   cFonts;

        if (hMMFont = GreAddFontMemResourceEx(pvBuffer, cjBuffer, pdv, cjDV, &cFonts))
        {
            __try
            {
                ProbeAndWriteUlong(pNumFonts, cFonts);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                GreRemoveFontMemResourceEx(hMMFont);
                hMMFont = 0;
            }
        }
    }

    return hMMFont;
}


/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiRemoveFontResourceW
*
* History:
*  28-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRemoveFontResourceW(
    WCHAR  *pwszFiles,
    ULONG   cwc,
    ULONG   cFiles,
    ULONG   fl,
    DWORD   dwPidTid,
    DESIGNVECTOR   *pdv
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    BOOL   bRet = FALSE;
    DESIGNVECTOR   dvTmp;
    DWORD  cjDV = 0, dvNumAxes = 0;

    TRACE_FONT(("Entering: NtGdiRemoveFontResourceW(\"%ws\",%-#x,%-#x)\n",pwszFiles, cwc,cFiles));
    try
    {

        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (!BALLOC_OVERFLOW1(cwc,WCHAR))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }

            if (pwszPath)
            {
                bRet = bCheckAndCapThePath(pwszPath, pwszFiles, cwc, cFiles);
            }
        }

        if (bRet && pdv)
        {
            // get the dvNumAxes first
            ProbeForRead(pdv, offsetof(DESIGNVECTOR,dvValues) , sizeof(BYTE));
            dvNumAxes = pdv->dvNumAxes;

            if ((dvNumAxes > 0) && (dvNumAxes <= MM_MAX_NUMAXES))
            {
                cjDV = SIZEOFDV(dvNumAxes);
                if (!BALLOC_OVERFLOW1(cjDV, BYTE))
                {
                    ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                    pdv = &dvTmp;
                }
                else
                    bRet = FALSE;
            }
            else if (dvNumAxes == 0)
            {
                pdv = 0;
            }
            else
            {
                bRet = FALSE;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        WARNINGX(96);
    }

    if (bRet)
        bRet = GreRemoveFontResourceW(pwszPath, cwc, cFiles, fl, dwPidTid, pdv, cjDV);

    if (bRet)   //Increase global time stamp for realization info
        (gpGdiSharedMemory->timeStamp)++;

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    TRACE_FONT(("Leaving: NtGdiRemoveFontResourceW"));

    return bRet;
}


/***************Public*Routine**************************\
* NtGdiRemoveFontMemResourceEx()                        *
*                                                       *
* History:                                              *
*  09-Jun-1996   -by-    Xudong Wu [TessieW]             *
*                                                       *
* Wrote it.                                             *
********************************************************/
BOOL
APIENTRY
NtGdiRemoveFontMemResourceEx(HANDLE hMMFont)
{
    BOOL    bRet = TRUE;

    if (hMMFont == 0)
    {
        return FALSE;
    }

    if (bRet)
    {
        bRet = GreRemoveFontMemResourceEx(hMMFont);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiEnumFontClose()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiEnumFontClose(
    ULONG_PTR idEnum
    )
{
    return(bEnumFontClose(idEnum));
}

/******************************Public*Routine******************************\
* NtGdiEnumFontChunk()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiEnumFontChunk(
    HDC            hdc,
    ULONG_PTR       idEnum,
    ULONG          cjEfdw,
    ULONG         *pcjEfdw,
    PENUMFONTDATAW pefdw
    )
{
    HANDLE hSecure;
    BOOL   bRet = TRUE;
    ULONG  cjEfdwRet = 0;

    try
    {
         ProbeForWrite(pefdw, cjEfdw, sizeof(DWORD));

         hSecure = MmSecureVirtualMemory(pefdw, cjEfdw, PAGE_READWRITE);

         if (!hSecure)
         {
            bRet = FALSE;
         }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(66);
        // SetLastError(GetExceptionCode());
        bRet = FALSE;
    }

    if (bRet)
    {
        try
        {
            bRet = bEnumFontChunk(hdc,idEnum,cjEfdw,&cjEfdwRet,pefdw);
            ProbeAndWriteUlong(pcjEfdw,cjEfdwRet);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(105);
            bRet = FALSE;
        }

        MmUnsecureVirtualMemory(hSecure);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiEnumFontOpen()
*
* History:
*  08-Mar-1995 Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

ULONG_PTR
APIENTRY
NtGdiEnumFontOpen(
    HDC     hdc,
    ULONG   iEnumType,
    FLONG   flWin31Compat,
    ULONG   cwchMax,
    LPWSTR  pwszFaceName,
    ULONG   lfCharSet,
    ULONG   *pulCount
    )
{
    ULONG       cwchFaceName;
    PWSTR       pwszKmFaceName = NULL;
    ULONG_PTR    ulRet = 0;
    BOOL        bRet = TRUE;
    ULONG       ulCount = 0;


    if (pwszFaceName != (PWSZ)NULL)
    {
        if ((cwchMax == 0) || (cwchMax > LF_FACESIZE))
            return FALSE;

        if (!BALLOC_OVERFLOW1(cwchMax,WCHAR))
        {
            pwszKmFaceName = (PWSZ)AllocFreeTmpBuffer(cwchMax * sizeof(WCHAR));
        }

        if (pwszKmFaceName != (PWSZ)NULL)
        {
            try
            {
                ProbeAndReadAlignedBuffer(pwszKmFaceName,pwszFaceName, cwchMax * sizeof(WCHAR), sizeof(WCHAR));

            // GreEnumFontOpen expects zero terminated sting

                pwszKmFaceName[cwchMax-1] = 0;

            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(66);
                // SetLastError(GetExceptionCode());
                bRet = FALSE;
            }
        }
        else
        {
            // SetLastError(GetExceptionCode());
                bRet = FALSE;
        }
    }
    else
    {
        pwszKmFaceName = (PWSZ)NULL;
        cwchMax   = 0;
    }

    if (bRet)
    {

        ulRet = GreEnumFontOpen(hdc,iEnumType,flWin31Compat,cwchMax,
                                (PWSZ)pwszKmFaceName, lfCharSet,&ulCount);

        if (ulRet)
        {
            try
            {
                 ProbeAndWriteUlong(pulCount,ulCount);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(67);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }

    }

    if (pwszKmFaceName != (PWSTR)NULL)
    {
        FreeTmpBuffer(pwszKmFaceName);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* NtGdiGetFontResourceInfoInternalW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetFontResourceInfoInternalW(
    LPWSTR   pwszFiles,
    ULONG    cwc,
    ULONG    cFiles,
    UINT     cjIn,
    LPDWORD  pdwBytes,
    LPVOID   pvBuf,
    DWORD    iType
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    BOOL   bRet = FALSE;

    SIZE_T dwBytesTmp;

    LOGFONTW lfw;
    LPVOID   pvBufTmp = NULL;

    TRACE_FONT(("Entering: NtGdiGetFontResourceInfoInternalW(\"%ws\",%-#x,%-#x)\n",pwszFiles, cwc,cFiles));

    try
    {
        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (!BALLOC_OVERFLOW1(cwc,WCHAR))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }

            if (pwszPath)
            {
                bRet = bCheckAndCapThePath(pwszPath, pwszFiles, cwc, cFiles);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(97);
    }

    if (cjIn > sizeof(LOGFONTW))
    {
        if (!BALLOC_OVERFLOW1(cjIn, BYTE))
        {
            pvBufTmp = PALLOCMEM(cjIn, 'pmtG');

            if (!pvBufTmp)
            {
                WARNING("NtGdiGetFontResourceInfoInternalW: failed to allocate memory\n");
                bRet = FALSE;
            }
        }
    }
    else
    {
        pvBufTmp = (PVOID)&lfw;
    }

    if (bRet && (bRet = GetFontResourceInfoInternalW(pwszPath,cwc, cFiles, cjIn,
                                            &dwBytesTmp, pvBufTmp, iType)))
    {
        try
        {
            ProbeAndWriteUlong(pdwBytes, (ULONG) dwBytesTmp);

            if (cjIn)
            {
                ProbeAndWriteBuffer(pvBuf, pvBufTmp, cjIn);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(110);
        }
    }

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    if (pvBufTmp && (pvBufTmp != (PVOID)&lfw))
    {
        VFREEMEM(pvBufTmp);
    }

    TRACE_FONT(("Leaving: NtGdiGetFontResourceInfoInternalW\n"));

    return bRet;

}


ULONG
APIENTRY
NtGdiGetEmbedFonts()
{
    return GreGetEmbedFonts();
}

BOOL
APIENTRY
NtGdiChangeGhostFont(KERNEL_PVOID *pfontID, BOOL bLoad)
{
    BOOL bRet = TRUE;
    VOID *fontID;

    try
    {
        ProbeAndReadBuffer(&fontID, pfontID, sizeof(VOID*));
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    bRet = bRet && GreChangeGhostFont(fontID, bLoad);

    return bRet;
}


/******************************Public*Routine******************************\
* NtGdiGetUFI()
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*  01-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetUFI(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi,
    DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
    FLONG  *pfl
    )
{
    UNIVERSAL_FONT_ID ufiTmp;
    BOOL  bRet = TRUE;
    FLONG flTmp;
    DESIGNVECTOR dvTmp;
    ULONG        cjDVTmp;
    ULONG        ulBaseCheckSum = 0;

    bRet = GreGetUFI(hdc, &ufiTmp, &dvTmp, &cjDVTmp, &ulBaseCheckSum, &flTmp, NULL);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pufi,ufiTmp,UNIVERSAL_FONT_ID);
            ProbeAndWriteUlong(pfl, flTmp);

            if ((flTmp & FL_UFI_DESIGNVECTOR_PFF) && pdv)
            {
                ProbeAndWriteBuffer(pdv, &dvTmp, cjDVTmp);
                ProbeAndWriteUlong(pcjDV, cjDVTmp);
                ProbeAndWriteUlong(pulBaseCheckSum, ulBaseCheckSum);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


BOOL
APIENTRY
NtGdiGetEmbUFI(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi,
    DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
    FLONG  *pfl,
    KERNEL_PVOID *pEmbFontID
    )
{
    UNIVERSAL_FONT_ID ufiTmp;
    BOOL  bRet = TRUE;
    FLONG flTmp;
    DESIGNVECTOR dvTmp;
    ULONG        cjDVTmp;
    ULONG        ulBaseCheckSum = 0;
    VOID        *fontID;

    bRet = GreGetUFI(hdc, &ufiTmp, &dvTmp, &cjDVTmp, &ulBaseCheckSum, &flTmp, &fontID);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pufi,ufiTmp,UNIVERSAL_FONT_ID);
            ProbeAndWriteUlong(pfl, flTmp);
            ProbeAndWriteBuffer(pEmbFontID, &fontID, sizeof(VOID*));

            if ((flTmp & FL_UFI_DESIGNVECTOR_PFF) && pdv)
            {
                ProbeAndWriteBuffer(pdv, &dvTmp, cjDVTmp);
                ProbeAndWriteUlong(pcjDV, cjDVTmp);
                ProbeAndWriteUlong(pulBaseCheckSum, ulBaseCheckSum);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


/**************************Public*Routine**************************\
* NtGdiGetUFIPathname()
*
* Return the font file path name according to the input ufi.
*
* History:
*  Feb-04-1997  Xudong Wu   [tessiew]
* Wrote it.
*
\*******************************************************************/
BOOL
APIENTRY
NtGdiGetUFIPathname
(
    PUNIVERSAL_FONT_ID pufi,
    ULONG* pcwc,
    LPWSTR pwszPathname,
    ULONG* pcNumFiles,
    FLONG fl,
    BOOL  *pbMemFont,
    ULONG *pcjView,
    PVOID  pvView,
    BOOL  *pbTTC,
    ULONG *piTTC
)
{
    UNIVERSAL_FONT_ID ufiTmp;
    WCHAR    awszTmp[MAX_PATH], *pwszTmp = NULL;
    COUNT   cwcTmp, cNumFilesTmp;
    BOOL  bRet = TRUE;
    BOOL  bMemFontTmp;
    PVOID  pvViewTmp = pvView;
    ULONG  cjViewTmp;
    BOOL   bTTC;
    ULONG  iTTC;

    try
    {
        ufiTmp = ProbeAndReadStructure(pufi, UNIVERSAL_FONT_ID);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(105);
        bRet = FALSE;
    }

    if (bRet && (bRet = GreGetUFIPathname(&ufiTmp,
                                          &cwcTmp,
                                          NULL, // just ask for the size
                                          &cNumFilesTmp,
                                          fl,
                                          &bMemFontTmp,
                                          &cjViewTmp,
                                          pvViewTmp,
                                          pbTTC ? &bTTC : NULL,
                                          piTTC ? &iTTC : NULL)))
    {
        if (cwcTmp <= MAX_PATH)
        {
            pwszTmp = awszTmp;
        }
        else
        {
            if (!BALLOC_OVERFLOW1(cwcTmp,WCHAR))
            {
                pwszTmp = AllocFreeTmpBuffer(cwcTmp * sizeof(WCHAR));
            }
            if (!pwszTmp)
                bRet = FALSE;
        }
    }

    if (bRet && (!bMemFontTmp) && pwszTmp)
    {
        bRet = GreGetUFIPathname(&ufiTmp,
                                 &cwcTmp,
                                 pwszTmp,
                                 &cNumFilesTmp,
                                 fl,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pbTTC ? &bTTC : NULL,
                                 piTTC ? &iTTC : NULL
                                 );
    }

    if (bRet)
    {
        try
        {
            if (pcwc)
            {
                ProbeAndWriteStructure(pcwc, cwcTmp, ULONG);
            }

            if (pwszPathname)
            {
                ProbeAndWriteBuffer(pwszPathname, pwszTmp, cwcTmp * sizeof(WCHAR));
            }

            if (pcNumFiles)
            {
                ProbeAndWriteStructure(pcNumFiles, cNumFilesTmp, ULONG);
            }

            if (bMemFontTmp)
            {
                if (pbMemFont)
                {
                    ProbeAndWriteStructure(pbMemFont, bMemFontTmp, BOOL);
                }

                if (pcjView)
                {
                    ProbeAndWriteUlong(pcjView, cjViewTmp);
                }
            }

            if (pbTTC)
            {
                ProbeAndWriteStructure(pbTTC, bTTC, BOOL);
            }

            if (piTTC)
            {
                ProbeAndWriteUlong(piTTC, iTTC);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(107);
            bRet = FALSE;
        }
    }

    if (pwszTmp && (pwszTmp != awszTmp))
    {
        FreeTmpBuffer(pwszTmp);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetLayout
*
* History:
*  29-Oct-1997 -by-  Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
DWORD
APIENTRY
NtGdiSetLayout(
    HDC hdc,
    LONG wox,
    DWORD dwLayout)
{
    return GreSetLayout(hdc, wox, dwLayout);
}

BOOL
APIENTRY
NtGdiMirrorWindowOrg(
    HDC hdc)
{
    return GreMirrorWindowOrg(hdc);
}

LONG
APIENTRY
NtGdiGetDeviceWidth(
    HDC hdc)
{
    return GreGetDeviceWidth(hdc);
}

/******************************Public*Routine******************************\
* NtGdiGetDCPoint()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetDCPoint(
    HDC     hdc,
    UINT    iPoint,
    PPOINTL pptOut
    )
{
    BOOL bRet;
    POINTL pt;

    if (bRet = GreGetDCPoint(hdc,iPoint,&pt))
    {

        // modify *pptOut only if successful

        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(71);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiScaleWindowExtEx()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiScaleWindowExtEx(
    HDC    hdc,
    int    xNum,
    int    xDenom,
    int    yNum,
    int    yDenom,
    LPSIZE pszOut
    )
{
    BOOL bRet;
    SIZE sz;

    bRet = GreScaleWindowExtEx(hdc,xNum,xDenom,yNum,yDenom,&sz);

    if (bRet && pszOut)
    {
        try
        {
            ProbeAndWriteStructure(pszOut,sz,SIZE);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(73);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTransform(
    HDC     hdc,
    DWORD   iXform,
    LPXFORM pxf
    )
{
    BOOL bRet;
    XFORM xf;

    bRet = GreGetTransform(hdc,iXform,(XFORML *)&xf);

    if (bRet)
    {
        try
        {
            ProbeAndWriteStructure(pxf,xf,XFORM);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(74);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiCombineTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiCombineTransform(
    LPXFORM  pxfDst,
    LPXFORM pxfSrc1,
    LPXFORM pxfSrc2
    )
{
    BOOL bRet;
    XFORM xfSrc1;
    XFORM xfSrc2;
    XFORM xfDst;

    bRet = ProbeAndConvertXFORM ((XFORML *)pxfSrc1, (XFORML *)&xfSrc1)
           && ProbeAndConvertXFORM ((XFORML *)pxfSrc2, (XFORML *)&xfSrc2);

    if (bRet)
    {
        bRet = GreCombineTransform((XFORML *)&xfDst,(XFORML *)&xfSrc1,(XFORML *)&xfSrc2);

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(pxfDst,xfDst,XFORM);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(76);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiTransformPoints()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiTransformPoints(
    HDC    hdc,
    PPOINT pptIn,
    PPOINT pptOut,
    int    c,
    int    iMode
    )
{
    BOOL bRet = TRUE;
    POINT  apt[10];
    PPOINT pptTmp = apt;

    //
    // validate
    //
    if (c <= 0)
    {
        //
        // GetTransformPoints returns TRUE for this condition, as does
        // the DPtoLP and LPtoDP APIs.
        //

        return bRet;
    }

    //
    // we will just use the the stack if there are less than 10 points
    // otherwise allocate mem from heap
    //
    if (c > 10)
    {
        //
        // local stack is not enough, invalidate pointer and try to allocate.
        //
        pptTmp = NULL;

        if (!BALLOC_OVERFLOW1(c,POINT))
        {
            pptTmp = AllocFreeTmpBuffer(c * sizeof(POINT));
        }
    }

    //
    // copy pptIn into pptTmp
    //
    if (pptTmp)
    {
        try
        {
            ProbeForRead(pptIn,c * sizeof(POINT), sizeof(BYTE));

            RtlCopyMemory(pptTmp,pptIn,c*sizeof(POINT));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(77);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GreTransformPoints(hdc,pptTmp,pptTmp,c,iMode);
    }

    //
    // copy pptTmp out to pptOut
    //
    if (bRet)
    {
        try
        {
            ProbeAndWriteBuffer(pptOut,pptTmp,c*sizeof(POINT));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(77);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    if (pptTmp && (pptTmp != apt))
        FreeTmpBuffer(pptTmp);

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextCharsetInfo()
*
* History:
*  Thu 23-Mar-1995 -by- Bodin Dresevic [BodinD]
* update: fixed it.
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetTextCharsetInfo(
    HDC             hdc,
    LPFONTSIGNATURE lpSig,
    DWORD           dwFlags
    )
{
    FONTSIGNATURE fsig;
    int iRet = GDI_ERROR;

    fsig.fsUsb[0] = 0;
    fsig.fsUsb[1] = 0;
    fsig.fsUsb[2] = 0;
    fsig.fsUsb[3] = 0;
    fsig.fsCsb[0] = 0;
    fsig.fsCsb[1] = 0;

    iRet = GreGetTextCharsetInfo(hdc, lpSig ? &fsig : NULL , dwFlags);

    if (iRet != GDI_ERROR)
    {
        if (lpSig)
        {
            try
            {
                ProbeAndWriteStructure(lpSig, fsig, FONTSIGNATURE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(78);
                // SetLastError(GetExceptionCode());

            // look into gtc.c win95 source file, this is what they return
            // in case of bad write pointer [bodind],
            // cant return 0 - that's ANSI_CHARSET!

                iRet = DEFAULT_CHARSET;
            }
        }
    }
    return iRet;
}


/******************************Public*Routine******************************\
* NtGdiGetBitmapDimension()
*
* History:
*  23-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetBitmapDimension(
    HBITMAP hbm,
    LPSIZE  psize
    )
{
    BOOL bRet;
    SIZE tmpsize;


    // check for null handle
    if (hbm == 0)
    {
        bRet = FALSE;
    }
    // do the real work
    else
    {

        bRet = GreGetBitmapDimension(hbm,&tmpsize);

        // if Gre call is successful do this, otherwise
        // we don't bother
        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,tmpsize,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(81);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return (bRet);

}


/******************************Public*Routine******************************\
* NtGdiSetBitmapDimension()
*
* History:
*  23-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetBitmapDimension(
    HBITMAP hbm,
    int     cx,
    int     cy,
    LPSIZE  psizeOut
    )
{
    BOOL bRet;
    SIZE tmpsize;

    // check for null handle
    if (hbm == 0)
    {
        bRet = FALSE;
    }
    // do the real work
    else
    {
        bRet = GreSetBitmapDimension(hbm,cx, cy, &tmpsize);

        // if the Gre call is successful, we copy out
        // the original size
        if (bRet && psizeOut)
        {

            try
            {
                ProbeAndWriteStructure(psizeOut,tmpsize,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(82);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }

        }
    }

    return (bRet);

}



BOOL
APIENTRY
NtGdiForceUFIMapping(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi
    )
{
    BOOL bRet = FALSE;

    if( pufi )
    {
        try
        {
            UNIVERSAL_FONT_ID ufi;

            ufi  = ProbeAndReadStructure( pufi, UNIVERSAL_FONT_ID);
            bRet = GreForceUFIMapping( hdc, &ufi);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(87);
            bRet = FALSE;
        }
    }

    return bRet;
}


typedef LONG (*NTGDIPALFUN)(HPALETTE,UINT,UINT,PPALETTEENTRY);
NTGDIPALFUN palfun[] =
{
    (NTGDIPALFUN)GreAnimatePalette,
    (NTGDIPALFUN)GreSetPaletteEntries,
    (NTGDIPALFUN)GreGetPaletteEntries,
    (NTGDIPALFUN)GreGetSystemPaletteEntries,
    (NTGDIPALFUN)GreGetDIBColorTable,
    (NTGDIPALFUN)GreSetDIBColorTable
};

/******************************Public*Routine******************************\
* NtGdiDoPalette
*
* History:
*  08-Mar-1995 Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

LONG
APIENTRY
NtGdiDoPalette(
    HPALETTE hpal,
    WORD  iStart,
    WORD  cEntries,
    PALETTEENTRY *pPalEntries,
    DWORD iFunc,
    BOOL  bInbound)
{

    LONG lRet = 0;
    BOOL bStatus = TRUE;
    PALETTEENTRY *ppalBuffer = (PALETTEENTRY*)NULL;

    if (iFunc <= 5)
    {
        if (bInbound)
        {
            //
            // copy  pal entries to temp buffer if needed
            //

            if ((cEntries > 0))
            {
                if (!BALLOC_OVERFLOW1(cEntries,PALETTEENTRY))
                {
                    ppalBuffer = (PALETTEENTRY *)AllocFreeTmpBuffer(cEntries * sizeof(PALETTEENTRY));
                }

                if (ppalBuffer == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    try
                    {
                        ProbeAndReadBuffer(ppalBuffer,pPalEntries,cEntries * sizeof(PALETTEENTRY));
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(88);
                        bStatus = FALSE;
                        //SetLastError(GetExceptionCode());
                    }
                }
            }

            if (bStatus)
            {
                lRet = (*palfun[iFunc])(
                                hpal,
                                iStart,
                                cEntries,
                                ppalBuffer);
            }
        }
        else
        {
            LONG lRetEntries;

            //
            // Query of palette information
            //

            if (pPalEntries != (PALETTEENTRY*)NULL)
            {
                if (cEntries == 0)
                {
                    // if there is a buffer but no entries, we're done.

                    bStatus = FALSE;
                    lRet = 0;
                }
                else
                {
                    if (!BALLOC_OVERFLOW1(cEntries,PALETTEENTRY))
                    {
                        ppalBuffer = (PALETTEENTRY *)AllocFreeTmpBuffer(cEntries * sizeof(PALETTEENTRY));
                    }

                    if (ppalBuffer == NULL)
                    {
                        bStatus = FALSE;
                    }
                }
            }

            if (bStatus)
            {
                lRet = (*palfun[iFunc])(
                                hpal,
                                iStart,
                                cEntries,
                                ppalBuffer);

                //
                // copy data back (if there is a buffer)
                //

                lRetEntries = min((LONG)cEntries,lRet);

                if ((lRetEntries > 0) && (pPalEntries != (PALETTEENTRY*)NULL))
                {
                    try
                    {
                        ProbeAndWriteBuffer(pPalEntries, ppalBuffer, lRetEntries * sizeof(PALETTEENTRY));
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(89);
                        // SetLastError(GetExceptionCode());
                        lRet = 0;
                    }
                }
            }
        }

        if (ppalBuffer != (PALETTEENTRY*)NULL)
        {
            FreeTmpBuffer(ppalBuffer);
        }

    }
    return(lRet);
}


/******************************Public*Routine******************************\
* NtGdiGetSpoolMessage()
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG NtGdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG     cjMsg,
    PULONG    pulOut,
    ULONG     cjOut
    )
{
    ULONG     ulRet = 0;
    HANDLE    hSecure = 0;

    // psesc contains two pieces.  The header which includes data going
    // in and out and the variable length data which is only output.  We
    // divide the message into two pieces here since we only need to validate
    // the header up front.  We just put a try/except around the output buffer
    // when we copy it in later.

    if (psesc && (cjMsg >= offsetof(SPOOLESC,ajData)))
    {
        try
        {
            ProbeForWrite(psesc,cjMsg,PROBE_ALIGNMENT(SPOOLESC));

            hSecure = MmSecureVirtualMemory (psesc, cjMsg, PAGE_READWRITE);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(90);
        }

        if (hSecure)
        {
            ulRet = GreGetSpoolMessage(
                        psesc,
                        psesc->ajData,
                        cjMsg - offsetof(SPOOLESC,ajData),
                        pulOut,
                        cjOut );

            MmUnsecureVirtualMemory (hSecure);
        }
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* NtGdiUnloadPrinterDriver()
*
* This function is called by the spooler when the printer driver has to be
* unloaded for upgrade purposes. The driver will be marked to be unloaded when
* the DC count goes to zero.
*
* History:
*  11/18/97  Ramanathan Venkatapathy
* Wrote it.
\**************************************************************************/
BOOL APIENTRY NtGdiUnloadPrinterDriver(
    LPWSTR  pDriverName,
    ULONG   cbDriverName)
{
    BOOL    bReturn = FALSE;
    WCHAR   pDriverFile[MAX_PATH + 1];

    RtlZeroMemory(pDriverFile, (MAX_PATH + 1) * sizeof(WCHAR));

    // Check for invalid driver name.
    if (cbDriverName > (MAX_PATH * sizeof(WCHAR)))
    {
        return bReturn;
    }

    __try
    {
        ProbeAndReadAlignedBuffer(pDriverFile, pDriverName, cbDriverName, sizeof(WCHAR) );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiUnloadPrinterDriver: bad driver file name.\n");
        return bReturn;
    }

    bReturn = ldevArtificialDecrement(pDriverFile);

    return bReturn;
}

/******************************Public*Routine******************************\
*
* NtGdiDescribePixelFormat
*
* Returns information about pixel formats for driver-managed surfaces
*
* History:
*  Thu Nov 02 18:16:26 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int NtGdiDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                             PPIXELFORMATDESCRIPTOR ppfd)
{
    PIXELFORMATDESCRIPTOR pfdLocal;
    int iRet;

    if (cjpfd > 0 && ppfd == NULL)
    {
        return 0;
    }

    // Make sure we cannot overrun our local structure.
    cjpfd = min(cjpfd, sizeof(pfdLocal));

    // Retrieve information into a local copy because the
    // devlock is held when the driver fills it in.  If there
    // was an access violation then the lock wouldn't be cleaned
    // up
    iRet = GreDescribePixelFormat(hdc, ipfd, cjpfd, &pfdLocal);

    // Copy data back if necessary
    if (iRet != 0 && cjpfd > 0)
    {
        try
        {
            ProbeAndWriteAlignedBuffer(ppfd, &pfdLocal, cjpfd, sizeof(ULONG));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(92);
            iRet = 0;
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* NtGdiFlush: Stub onle
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    1-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
NtGdiFlush()
{
    GreFlush();
}

/******************************Public*Routine*****************************\
* NtGdiGetCharWidthInfo
*
* Get the lMaxNegA lMaxNegC and lMinWidthD
*
* History:
*  14-Feb-1996  -by-  Xudong Wu [tessiew]
* Wrote it.
\*************************************************************************/

BOOL
APIENTRY
NtGdiGetCharWidthInfo(
   HDC  hdc,
   PCHWIDTHINFO  pChWidthInfo
)
{
   BOOL  bRet = FALSE;
   CHWIDTHINFO   tempChWidthInfo;

   bRet = GreGetCharWidthInfo( hdc, &tempChWidthInfo );

   if (bRet)
   {
        try
        {
            ProbeAndWriteBuffer( pChWidthInfo, &tempChWidthInfo, sizeof(CHWIDTHINFO) );
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            WARNINGX(93);
            bRet = FALSE;
        }
   }

   return ( bRet );
}


ULONG
APIENTRY
NtGdiMakeFontDir(
    FLONG    flEmbed,            // mark file as "hidden"
    PBYTE    pjFontDir,          // pointer to structure to fill
    unsigned cjFontDir,          // >= CJ_FONTDIR
    PWSZ     pwszPathname,       // path of font file to use
    unsigned cjPathname          // <= sizeof(WCHAR) * (MAX_PATH+1)
    )
{
    ULONG ulRet;
    WCHAR awcPathname[MAX_PATH+1];  // safe buffer for path name
    BYTE  ajFontDir[CJ_FONTDIR];    // safe buffer for return data

    ulRet = 0;
    if ( (cjPathname <= (sizeof(WCHAR) * (MAX_PATH+1))) &&
         (cjFontDir >= CJ_FONTDIR) )
    {
        ulRet = 1;
        __try
        {
            ProbeAndReadAlignedBuffer( awcPathname, pwszPathname, cjPathname, sizeof(*pwszPathname));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiMakeFondDir: bad pwszPathname\n");
            ulRet = 0;
        }
        if ( ulRet )
        {
            awcPathname[MAX_PATH] = 0;
            ulRet = GreMakeFontDir( flEmbed, ajFontDir, awcPathname );
            if ( ulRet )
            {
                __try
                {
                    ProbeAndWriteBuffer( pjFontDir, ajFontDir,  CJ_FONTDIR   );
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiMakeFondDir: bad pjFontDir\n");
                    ulRet = 0;
                }
            }
        }
    }
    return( ulRet );
}


DWORD   APIENTRY NtGdiGetGlyphIndicesWInternal(
    HDC    hdc,
    LPWSTR pwc,
    int    cwc,
    LPWORD pgi,
    DWORD iMode,
    BOOL   bSubset
    )
{

    WORD awBuffer[2*LOCAL_CWC_MAX];
    LPWSTR pwcTmp;
    LPWORD pgiTmp = NULL;
    DWORD  dwRet = GDI_ERROR;

    if (cwc < 0)
        return dwRet;

// test for important special case

    if ((cwc == 0) && (pwc == NULL) && (pgi == NULL) && (iMode == 0))
        return GreGetGlyphIndicesW(hdc, NULL, 0, NULL, 0, bSubset);

    if (cwc <= LOCAL_CWC_MAX)
    {
        pgiTmp = awBuffer;
    }
    else
    {
        if (!BALLOC_OVERFLOW2(cwc,WORD,WCHAR))
        {
            pgiTmp = (LPWORD)AllocFreeTmpBuffer(cwc * (sizeof(WORD)+sizeof(WCHAR)));
        }
    }

    if (pgiTmp)
    {
    // make a temp buffer for the string in the same buffer, after the indices

        pwcTmp = &pgiTmp[cwc];

        try
        {
            ProbeAndReadBuffer(pwcTmp, pwc, cwc * sizeof(WCHAR));
            dwRet = cwc; // indicate that we did not hit the exception
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(98);
            dwRet = GDI_ERROR;
        }

        if (dwRet != GDI_ERROR)
            dwRet = GreGetGlyphIndicesW(hdc, pwcTmp, cwc, pgiTmp, iMode, bSubset);

        if (dwRet != GDI_ERROR)
        {
            try
            {
                ProbeAndWriteBuffer(pgi, pgiTmp, cwc * sizeof(WORD));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(99);
                dwRet = GDI_ERROR;
            }
        }

        if (pgiTmp != awBuffer)
            FreeTmpBuffer(pgiTmp);
    }

    return dwRet;
}


DWORD   APIENTRY NtGdiGetGlyphIndicesW(
    HDC    hdc,
    LPWSTR pwc,
    int    cwc,
    LPWORD pgi,
    DWORD iMode
    )
{
    return NtGdiGetGlyphIndicesWInternal(hdc, pwc, cwc, pgi, iMode, FALSE);
}


/******************************Public*Routine******************************\
*
* NtGdi stub for GetFontUnicodeRanges
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD NtGdiGetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgs)
{
    DWORD dwRet, dwRet1;
    LPGLYPHSET pgsTmp = NULL;

    dwRet = GreGetFontUnicodeRanges(hdc, NULL);

    if (dwRet && pgs)
    {
        if (pgsTmp = (LPGLYPHSET)AllocFreeTmpBuffer(dwRet))
        {
            dwRet1 = GreGetFontUnicodeRanges(hdc, pgsTmp);
            if (dwRet1 && (dwRet == dwRet1)) // consistency check
            {
                try
                {
                    ProbeAndWriteBuffer(pgs, pgsTmp, dwRet);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(102);
                    dwRet = 0;
                }
            }
            else
            {
                WARNINGX(101);
                dwRet = 0;
            }

            FreeTmpBuffer(pgsTmp);
        }
        else
        {
            WARNINGX(100);
            dwRet = 0;
        }
    }

    return dwRet;
}

#ifdef LANGPACK
BOOL
APIENTRY
NtGdiGetRealizationInfo(
    HDC hdc,
    PREALIZATION_INFO pri,
    KHFONT hf
    )
{
    REALIZATION_INFO riTmp;
    BOOL  bRet = TRUE;
    int     ii;

    bRet = GreGetRealizationInfo(hdc, &riTmp);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pri,riTmp,REALIZATION_INFO);
        }

        if (bRet)
        {
            if (hf)
            {
                // Find CFONT Location
                for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
                    if (gpGdiSharedMemory->acfPublic[ii].hf == (HFONT)hf)
                        break;

                if (ii < MAX_PUBLIC_CFONT){
                    CFONT* pcf = &gpGdiSharedMemory->acfPublic[ii];

                    pcf->ri = riTmp;

                    pcf->fl |= CFONT_CACHED_RI;

                    pcf->timeStamp = gpGdiSharedMemory->timeStamp;
                }
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(104);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


#endif

/******************************Public*Routine******************************\
* NtGdiDrawStream
*
* Arguments:
*
*   hdc      - handle to primary destination device context
*   cjIn     - size, in bytes, of input draw stream
*   pjIn     - address of input draw stream
*
* Return Value:
*
*   TRUE : success
*   FALSE : faiure
*
* History:
*
*   3-19-2001 bhouse Created it
*
\**************************************************************************/

#define DS_STACKBUFLENGTH  256

BOOL
APIENTRY
NtGdiDrawStream(
    HDC                 hdcDst,
    ULONG               cjIn,
    PVOID               pvIn
    )
{
    BYTE                pbScratchBuf[DS_STACKBUFLENGTH];
    BOOL                bRet = FALSE;
    PVOID               pvScratch = NULL;

    if(cjIn > sizeof(pbScratchBuf))
    {
        if (BALLOC_OVERFLOW1(cjIn,BYTE))
        {
            WARNING("NtGdiDrawStream: input stream is too large\n");
            goto exit;
        }
        
        pvScratch = AllocFreeTmpBuffer(cjIn);

        if (pvScratch == NULL)
        {
            WARNING("NtGdiDrawStream: unable to allocate temp buffer\n");
            goto exit;
        }
        
    }
    else
    {
        pvScratch = (PVOID) pbScratchBuf;
    }

    // copy the stream from user mode
    // NOTE: we can get rid of the copy if we try/except in all appropriate
    //       places during the handling of the stream.

    try 
    {
        ProbeAndReadBuffer(pvScratch, pvIn,cjIn);
    }

    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiDrawStream: exception occured reading stream\n");
        goto exit;
    }

    bRet = GreDrawStream(hdcDst, cjIn, pvScratch);

exit:

    if(pvScratch != NULL && pvScratch != pbScratchBuf)
    {
        FreeTmpBuffer(pvScratch);
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\palobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: palobj.cxx
*
* Palette user object functions
*
* Created: 07-Nov-1990 21:30:19
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitPALOBJ();

#pragma alloc_text(INIT, bInitPALOBJ)

#define MAX_PAL_ERROR (3 * (256*256))

// ulXlatePalUnique is used for the uniquess of the xlates and palettes.

ULONG ulXlatePalUnique = 3;

// gpRGBXlate is a global RGBXlate for the rainbow palette

PBYTE gpRGBXlate = NULL;

UINT *pArrayOfSquares;
UINT aArrayOfSquares[511];

typedef BYTE  FAR  *PIMAP;
typedef struct {BYTE r,g,b,x;} RGBX;
BOOL MakeITable(PIMAP lpITable, RGBX FAR *prgb, int nColors);

/******************************Public*Data*********************************\
* Default Monochrome Palette
*
* History:
*  16-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG gaulMono[2] =
{
    0,
    0xFFFFFF
};

/******************************Public*Data*********************************\
* Default Logical Palette
*
*  Default Palette Data Structure, Taken straight from Win 3.1
*  This is the default palette, the stock palette.
*  This contains the 20 default colors.
*  This is the default logical palette put in every DC when it is created.
*
* History:
*  16-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PAL_LOGPALETTE logDefaultPal =
{
    0x300,   // version number
    20,      // number of entries
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0xC0,0xC0,0xC0,0  },  // 7

    { 192, 220, 192, 0  },  // 8
    { 166, 202, 240, 0  },  // 9
    { 255, 251, 240, 0  },  // 10
    { 160, 160, 164, 0  },  // 11

    { 0x80,0x80,0x80,0  },  // 12
    { 0xFF,0,   0,   0  },  // 13
    { 0,   0xFF,0,   0  },  // 14
    { 0xFF,0xFF,0,   0  },  // 15
    { 0,   0,   0xFF,0  },  // 16
    { 0xFF,0,   0xFF,0  },  // 17
    { 0,   0xFF,0xFF,0  },  // 18
    { 0xFF,0xFF,0xFF,0  }   // 19
}
};

/******************************Public*Data**********************************\
*
* This is the same as color table as logDefaultPal except
* entries for magic colors. These are 0x0 to prevent a match.
* We now only match magic colors exactly, otherwise nearest-match
* to this palette
*
\**************************************************************************/

PAL_ULONG aPalDefaultVGA[20] =
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0xC0,0xC0,0xC0,0  },  // 7

    { 000, 000, 000, 0  },  // 8
    { 000, 000, 000, 0  },  // 9
    { 000, 000, 000, 0  },  // 10
    { 000, 000, 000, 0  },  // 11

    { 0x80,0x80,0x80,0  },  // 12
    { 0xFF,0,   0,   0  },  // 13
    { 0,   0xFF,0,   0  },  // 14
    { 0xFF,0xFF,0,   0  },  // 15
    { 0,   0,   0xFF,0  },  // 16
    { 0xFF,0,   0xFF,0  },  // 17
    { 0,   0xFF,0xFF,0  },  // 18
    { 0xFF,0xFF,0xFF,0  }   // 19
};

/******************************Public*Data*********************************\
* This is the default 16 color palette which matches the VGA palette
* exactly.
*
* History:
*  05-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PAL_ULONG aPalVGA[16] =
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0x80,0x80,0x80,0  },  // 7
    { 0xC0,0xC0,0xC0,0  },  // 8
    { 0xFF,0,   0,   0  },  // 9
    { 0,   0xFF,0,   0  },  // 10
    { 0xFF,0xFF,0,   0  },  // 11
    { 0,   0,   0xFF,0  },  // 12
    { 0xFF,0,   0xFF,0  },  // 13
    { 0,   0xFF,0xFF,0  },  // 14
    { 0xFF,0xFF,0xFF,0  }   // 15
};


/******************************Public*Routine******************************\
*
*   win95 halftone palette
*
* History:
*
*    11/27/1996 Mark Enstrom [marke]
*
*   03-Feb-1999 Wed 01:47:31 updated  -by-  Daniel Chou (danielc)
*       Even though this is the one copy from win95, it is wrong for halftone
*       to be use correctly, it missing high luminance green color, I added
*       this back, and the low r/b/m/c luminance color (20% of that color) are
*       patch into gray color.  All window system halftone does not use any
*       gray color in 256 color mode any more.
*
*           Index 10: 0x04:0x04:0x04 --> 0x00:0x00:0x33
*           Index 11: 0x08:0x08:0x08 --> 0x33:0x00:0x00
*           Index 12: 0x0c:0x0c:0x0c --> 0x33:0x00:0x33
*           Index 13: 0x11:0x11:0x11 --> 0x00:0x33:0x33
*           Index 39: 0x33:0x00:0x00 --> 0x33:0xFF:0x00
*           Index 60: 0x00:0x00:0x33 --> 0x00:0xFF:0x33
*           Index 61: 0x33:0x00:0x33 --> 0x33:0x00:0xFF
*           Index 66: 0x00:0x33:0x33 --> 0x00:0x33:0xFF
*
\**************************************************************************/

PAL_ULONG  aPalHalftone[256] =
{
    {0x00,0x00,0x00,0x00},{0x80,0x00,0x00,0x00},{0x00,0x80,0x00,0x00},{0x80,0x80,0x00,0x00},
    {0x00,0x00,0x80,0x00},{0x80,0x00,0x80,0x00},{0x00,0x80,0x80,0x00},{0xc0,0xc0,0xc0,0x00},
    {0xc0,0xdc,0xc0,0x00},{0xa6,0xca,0xf0,0x00},{0x00,0x00,0x33,0x04},{0x33,0x00,0x00,0x04},
    {0x33,0x00,0x33,0x04},{0x00,0x33,0x33,0x04},{0x16,0x16,0x16,0x04},{0x1c,0x1c,0x1c,0x04},
    //1
    {0x22,0x22,0x22,0x04},{0x29,0x29,0x29,0x04},{0x55,0x55,0x55,0x04},{0x4d,0x4d,0x4d,0x04},
    {0x42,0x42,0x42,0x04},{0x39,0x39,0x39,0x04},{0xFF,0x7C,0x80,0x04},{0xFF,0x50,0x50,0x04},
    {0xD6,0x00,0x93,0x04},{0xCC,0xEC,0xFF,0x04},{0xEF,0xD6,0xC6,0x04},{0xE7,0xE7,0xD6,0x04},
    {0xAD,0xA9,0x90,0x04},{0x33,0xFF,0x00,0x04},{0x66,0x00,0x00,0x04},{0x99,0x00,0x00,0x04},
    //2
    {0xcc,0x00,0x00,0x04},{0x00,0x33,0x00,0x04},{0x33,0x33,0x00,0x04},{0x66,0x33,0x00,0x04},
    {0x99,0x33,0x00,0x04},{0xcc,0x33,0x00,0x04},{0xff,0x33,0x00,0x04},{0x00,0x66,0x00,0x04},
    {0x33,0x66,0x00,0x04},{0x66,0x66,0x00,0x04},{0x99,0x66,0x00,0x04},{0xcc,0x66,0x00,0x04},
    {0xff,0x66,0x00,0x04},{0x00,0x99,0x00,0x04},{0x33,0x99,0x00,0x04},{0x66,0x99,0x00,0x04},
    //3
    {0x99,0x99,0x00,0x04},{0xcc,0x99,0x00,0x04},{0xff,0x99,0x00,0x04},{0x00,0xcc,0x00,0x04},
    {0x33,0xcc,0x00,0x04},{0x66,0xcc,0x00,0x04},{0x99,0xcc,0x00,0x04},{0xcc,0xcc,0x00,0x04},
    {0xff,0xcc,0x00,0x04},{0x66,0xff,0x00,0x04},{0x99,0xff,0x00,0x04},{0xcc,0xff,0x00,0x04},
    {0x00,0xFF,0x33,0x04},{0x33,0x00,0xFF,0x04},{0x66,0x00,0x33,0x04},{0x99,0x00,0x33,0x04},
    //4
    {0xcc,0x00,0x33,0x04},{0xff,0x00,0x33,0x04},{0x00,0x33,0xFF,0x04},{0x33,0x33,0x33,0x04},
    {0x66,0x33,0x33,0x04},{0x99,0x33,0x33,0x04},{0xcc,0x33,0x33,0x04},{0xff,0x33,0x33,0x04},
    {0x00,0x66,0x33,0x04},{0x33,0x66,0x33,0x04},{0x66,0x66,0x33,0x04},{0x99,0x66,0x33,0x04},
    {0xcc,0x66,0x33,0x04},{0xff,0x66,0x33,0x04},{0x00,0x99,0x33,0x04},{0x33,0x99,0x33,0x04},
    //5
    {0x66,0x99,0x33,0x04},{0x99,0x99,0x33,0x04},{0xcc,0x99,0x33,0x04},{0xff,0x99,0x33,0x04},
    {0x00,0xcc,0x33,0x04},{0x33,0xcc,0x33,0x04},{0x66,0xcc,0x33,0x04},{0x99,0xcc,0x33,0x04},
    {0xcc,0xcc,0x33,0x04},{0xff,0xcc,0x33,0x04},{0x33,0xff,0x33,0x04},{0x66,0xff,0x33,0x04},
    {0x99,0xff,0x33,0x04},{0xcc,0xff,0x33,0x04},{0xff,0xff,0x33,0x04},{0x00,0x00,0x66,0x04},
    //6
    {0x33,0x00,0x66,0x04},{0x66,0x00,0x66,0x04},{0x99,0x00,0x66,0x04},{0xcc,0x00,0x66,0x04},
    {0xff,0x00,0x66,0x04},{0x00,0x33,0x66,0x04},{0x33,0x33,0x66,0x04},{0x66,0x33,0x66,0x04},
    {0x99,0x33,0x66,0x04},{0xcc,0x33,0x66,0x04},{0xff,0x33,0x66,0x04},{0x00,0x66,0x66,0x04},
    {0x33,0x66,0x66,0x04},{0x66,0x66,0x66,0x04},{0x99,0x66,0x66,0x04},{0xcc,0x66,0x66,0x04},
    //7
    {0x00,0x99,0x66,0x04},{0x33,0x99,0x66,0x04},{0x66,0x99,0x66,0x04},{0x99,0x99,0x66,0x04},
    {0xcc,0x99,0x66,0x04},{0xff,0x99,0x66,0x04},{0x00,0xcc,0x66,0x04},{0x33,0xcc,0x66,0x04},
    {0x99,0xcc,0x66,0x04},{0xcc,0xcc,0x66,0x04},{0xff,0xcc,0x66,0x04},{0x00,0xff,0x66,0x04},
    {0x33,0xff,0x66,0x04},{0x99,0xff,0x66,0x04},{0xcc,0xff,0x66,0x04},{0xff,0x00,0xcc,0x04},
    //8
    {0xcc,0x00,0xff,0x04},{0x00,0x99,0x99,0x04},{0x99,0x33,0x99,0x04},{0x99,0x00,0x99,0x04},
    {0xcc,0x00,0x99,0x04},{0x00,0x00,0x99,0x04},{0x33,0x33,0x99,0x04},{0x66,0x00,0x99,0x04},
    {0xcc,0x33,0x99,0x04},{0xff,0x00,0x99,0x04},{0x00,0x66,0x99,0x04},{0x33,0x66,0x99,0x04},
    {0x66,0x33,0x99,0x04},{0x99,0x66,0x99,0x04},{0xcc,0x66,0x99,0x04},{0xff,0x33,0x99,0x04},
    //9
    {0x33,0x99,0x99,0x04},{0x66,0x99,0x99,0x04},{0x99,0x99,0x99,0x04},{0xcc,0x99,0x99,0x04},
    {0xff,0x99,0x99,0x04},{0x00,0xcc,0x99,0x04},{0x33,0xcc,0x99,0x04},{0x66,0xcc,0x66,0x04},
    {0x99,0xcc,0x99,0x04},{0xcc,0xcc,0x99,0x04},{0xff,0xcc,0x99,0x04},{0x00,0xff,0x99,0x04},
    {0x33,0xff,0x99,0x04},{0x66,0xcc,0x99,0x04},{0x99,0xff,0x99,0x04},{0xcc,0xff,0x99,0x04},
    //a
    {0xff,0xff,0x99,0x04},{0x00,0x00,0xcc,0x04},{0x33,0x00,0x99,0x04},{0x66,0x00,0xcc,0x04},
    {0x99,0x00,0xcc,0x04},{0xcc,0x00,0xcc,0x04},{0x00,0x33,0x99,0x04},{0x33,0x33,0xcc,0x04},
    {0x66,0x33,0xcc,0x04},{0x99,0x33,0xcc,0x04},{0xcc,0x33,0xcc,0x04},{0xff,0x33,0xcc,0x04},
    {0x00,0x66,0xcc,0x04},{0x33,0x66,0xcc,0x04},{0x66,0x66,0x99,0x04},{0x99,0x66,0xcc,0x04},
    //b
    {0xcc,0x66,0xcc,0x04},{0xff,0x66,0x99,0x04},{0x00,0x99,0xcc,0x04},{0x33,0x99,0xcc,0x04},
    {0x66,0x99,0xcc,0x04},{0x99,0x99,0xcc,0x04},{0xcc,0x99,0xcc,0x04},{0xff,0x99,0xcc,0x04},
    {0x00,0xcc,0xcc,0x04},{0x33,0xcc,0xcc,0x04},{0x66,0xcc,0xcc,0x04},{0x99,0xcc,0xcc,0x04},
    {0xcc,0xcc,0xcc,0x04},{0xff,0xcc,0xcc,0x04},{0x00,0xff,0xcc,0x04},{0x33,0xff,0xcc,0x04},
    //c
    {0x66,0xff,0x99,0x04},{0x99,0xff,0xcc,0x04},{0xcc,0xff,0xcc,0x04},{0xff,0xff,0xcc,0x04},
    {0x33,0x00,0xcc,0x04},{0x66,0x00,0xff,0x04},{0x99,0x00,0xff,0x04},{0x00,0x33,0xcc,0x04},
    {0x33,0x33,0xff,0x04},{0x66,0x33,0xff,0x04},{0x99,0x33,0xff,0x04},{0xcc,0x33,0xff,0x04},
    {0xff,0x33,0xff,0x04},{0x00,0x66,0xff,0x04},{0x33,0x66,0xff,0x04},{0x66,0x66,0xcc,0x04},
    //d
    {0x99,0x66,0xff,0x04},{0xcc,0x66,0xff,0x04},{0xff,0x66,0xcc,0x04},{0x00,0x99,0xff,0x04},
    {0x33,0x99,0xff,0x04},{0x66,0x99,0xff,0x04},{0x99,0x99,0xff,0x04},{0xcc,0x99,0xff,0x04},
    {0xff,0x99,0xff,0x04},{0x00,0xcc,0xff,0x04},{0x33,0xcc,0xff,0x04},{0x66,0xcc,0xff,0x04},
    {0x99,0xcc,0xff,0x04},{0xcc,0xcc,0xff,0x04},{0xff,0xcc,0xff,0x04},{0x33,0xff,0xff,0x04},
    //e
    {0x66,0xff,0xcc,0x04},{0x99,0xff,0xff,0x04},{0xcc,0xff,0xff,0x04},{0xff,0x66,0x66,0x04},
    {0x66,0xff,0x66,0x04},{0xff,0xff,0x66,0x04},{0x66,0x66,0xff,0x04},{0xff,0x66,0xff,0x04},
    {0x66,0xff,0xff,0x04},{0xA5,0x00,0x21,0x04},{0x5f,0x5f,0x5f,0x04},{0x77,0x77,0x77,0x04},
    {0x86,0x86,0x86,0x04},{0x96,0x96,0x96,0x04},{0xcb,0xcb,0xcb,0x04},{0xb2,0xb2,0xb2,0x04},
    //f
    {0xd7,0xd7,0xd7,0x04},{0xdd,0xdd,0xdd,0x04},{0xe3,0xe3,0xe3,0x04},{0xea,0xea,0xea,0x04},
    {0xf1,0xf1,0xf1,0x04},{0xf8,0xf8,0xf8,0x04},{0xff,0xfb,0xf0,0x00},{0xa0,0xa0,0xa4,0x00},
    {0x80,0x80,0x80,0x00},{0xff,0x00,0x00,0x00},{0x00,0xff,0x00,0x00},{0xff,0xff,0x00,0x00},
    {0x00,0x00,0xff,0x00},{0xff,0x00,0xff,0x00},{0x00,0xff,0xff,0x00},{0xff,0xff,0xff,0x00}
};


// ppalDefault is the pointer to the default palette info
// We lock the default palette down at creation and never unlock
// it so that multiple apps can access the default palette simultaneously.

PPALETTE ppalDefault = (PPALETTE) NULL;
PPALETTE gppalRGB    = (PPALETTE) NULL;

// ppalDefaultSurface8bpp is the pointer to the default 8bpp surface palette.
// This is used for dynamic mode changes when converting a Device Dependent
// Bitmap, which has no color table, to a Device Indepdent Bitmap, which
// has a color table -- this is what we use for the color table.
// We lock the default palette down at creation and never unlock
// it so that multiple surface  can access the default palette simultaneously.

PPALETTE ppalDefaultSurface8bpp = (PPALETTE) NULL;

// This is the global palette for the monochrome bitmaps.

HPALETTE hpalMono = (HPALETTE) 0;
PPALETTE ppalMono = (PPALETTE) NULL;

/******************************Public*Routine******************************\
* RGB_ERROR
*
* Returns a measure of error between two RGB entries.
*
* History:
*  14-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

inline ULONG RGB_ERROR(PALETTEENTRY palDst, PALETTEENTRY palSrc)
{
    INT lTemp, lTemp1;

    lTemp = ((INT) (UINT) (palDst.peRed))     -
                ((INT) (UINT) (palSrc.peRed));

    lTemp1 = lTemp * lTemp;

    lTemp =     ((INT) (UINT) (palDst.peGreen))   -
                ((INT) (UINT) (palSrc.peGreen));

    lTemp1 +=  lTemp * lTemp;

    lTemp =     ((INT) (UINT) (palDst.peBlue))       -
                ((INT) (UINT) (palSrc.peBlue));

    lTemp1 += lTemp * lTemp;

    return((ULONG) lTemp1);
}

/******************************Public*Routine******************************\
* BOOL XEPALOBJ::bSwap(ppalSrc)
*
* This is for swapping palettes, necesary for ResizePalette.
*
* History:
*  Sun 21-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Make it a Safe swap under MLOCK.
*
*  Fri 18-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL
XEPALOBJ::bSwap(
    PPALETTE *pppalSrc,
    ULONG cShareCountDst,
    ULONG cShareCountSrc
    )
{
    PPALETTE ppalSrc = *pppalSrc;
    BOOL bRet;

    bRet = HmgSwapLockedHandleContents((HOBJ)ppal->hGet(),
                                 cShareCountDst,
                                 (HOBJ)ppalSrc->hGet(),
                                 cShareCountSrc,
                                 PAL_TYPE);

    //
    // swap user pointers to palette objects
    //

    if (bRet)
    {
        *pppalSrc = ppal;
        ppal = ppalSrc;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulBitfieldToRGB
*
* Converts an index into an RGB for Bitfield palettes.
*
* History:
*  Tue 31-Mar-1992 -by- Patrick Haluptzok [patrickh]
* Does better mapping.
*
*  08-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulBitfieldToRGB(ULONG ulIndex)
{
    ASSERTGDI(bIsBitfields(), "Error ulBitfieldToRGB not bitfields");

    ULONG ulRed = (ulIndex & flRed()) >> cRedRight();

    if (cRedMiddle() < 8)
    {
        ulRed = ulRed << (8 - cRedMiddle());
        ulRed = ulRed | (ulRed >> cRedMiddle());
    }

    ULONG ulGre = (ulIndex & flGre()) >> cGreRight();

    if (cGreMiddle() < 8)
    {
        ulGre = ulGre << (8 - cGreMiddle());
        ulGre = ulGre | (ulGre >> cGreMiddle());
    }

    ulGre = ulGre << 8;

    ULONG ulBlu = (ulIndex & flBlu()) >> cBluRight();

    if (cBluMiddle() < 8)
    {
        ulBlu = ulBlu << (8 - cBluMiddle());
        ulBlu = ulBlu | (ulBlu >> cBluMiddle());
    }

    ulBlu = ulBlu << 16;

    return(ulRed | ulBlu | ulGre);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulIndexToRGB
*
* Converts an index to an RGB for a palette.
*
* History:
*  05-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulIndexToRGB(ULONG ulIndex)
{
    if (bIsIndexed())
    {
        if (cEntries() > ulIndex)
            ulIndex = (ulEntryGet(ulIndex) & 0xFFFFFF);
        else
            ulIndex = 0;
    }
    else if (bIsBitfields())
    {
        ulIndex = ulBitfieldToRGB(ulIndex);
    }
    else if (bIsBGR())
    {
        BGR_ULONG palOld;
        PAL_ULONG palNew;

        palOld.ul = ulIndex;
        palNew.pal.peRed   = palOld.rgb.rgbRed;
        palNew.pal.peGreen = palOld.rgb.rgbGreen;
        palNew.pal.peBlue  = palOld.rgb.rgbBlue;
        palNew.pal.peFlags = 0;
        ulIndex = palNew.ul;
    }
    else
    {
    // 0 out the flags.

        ASSERTGDI(bIsRGB(), "ERROR another type not accounted for\n");
        ulIndex &= 0xFFFFFF;
    }

    return(ulIndex);
}

/******************************Public*Routine******************************\
* ParseBits
*
* This routine computes how much the left and right shifts are for
* PAL_BITFIELDS 16 and 32 bit masks.
*
* History:
*  09-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID ParseBits(FLONG flag, ULONG *pcRight, ULONG *pcLeft, ULONG *pcMiddle, ULONG cForColor)
{
    ULONG ulRight = 0;
    ULONG ulMiddle;

    ASSERTGDI(flag != 0, "ERROR flag");

    while((flag & 1) == 0)
    {
        flag >>= 1;
        ulRight++;
    }

    ulMiddle = ulRight;

    do
    {
        flag >>= 1;
        ulMiddle++;
    } while(flag & 1);

    *pcMiddle = ulMiddle = ulMiddle - ulRight;
    *pcRight = (ulMiddle > 8) ? (ulRight + ulMiddle - 8) : (ulRight);
    *pcLeft  = (ulMiddle > 8) ? (cForColor) : (cForColor + (8 - ulMiddle));
}

/******************************Public*Routine******************************\
* PALMEMOBJ::bCreatePalette
*
* Constructor for creating palettes.
*
* Returns: True for success, False for error.
*
* History:
*  18-Feb-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
PALMEMOBJ::bCreatePalette(
    ULONG iMode,         // The mode the palette is.
    ULONG cColors,       // Number of RGB's if indexed palette.
    ULONG *pulColors,    // Pointer to RGB's if indexed.
    FLONG flRedd,        // Mask for Red if bitfields
    FLONG flGreen,       // Mask for Green if bitfields
    FLONG flBlue,        // Mask for Blue if bitfields
    ULONG iType)         // The type it will be, fixed, free, managed, DC.
{

    ASSERTGDI(bKeep == FALSE, "ERROR bCreatePalette bKeep is not False");
    ASSERTGDI(ppal == (PPALETTE) NULL, "ERROR bCreatePalette ppal is NULL");
    PAL_ULONG palul;
    BOOL bDataStatus = TRUE;

// This data may be coming accross the DDI from a newer driver or from a
// journal file or from a app, so we must validate everything, make sure
// only valid iType flags are set for the iMode.

// Validate the iMode, calculate the size needed into palul.

    palul.ul = sizeof(PALETTE);

    switch(iMode)
    {
    case PAL_BITFIELDS:

    // Bitfields palette is always fixed, we ASSERT values that should
    // be correct to detect bad code in testing, but still assign correct
    // values so that corrupt journal files don't create bad palettes.

        ASSERTGDI(iType & PAL_FIXED, "ERROR bCreatePalette PAL_BITFIELDS");
        ASSERTGDI(cColors == 0, "ERROR GDI EngCreatePalette PAL_BITFIELDS");
        iType = iType & (PAL_FIXED | PAL_HT | PAL_DC);
        cColors = 0;

    // We need to check these so we don't fault ourselves.

        if ((flRedd == 0) || (flBlue == 0) || (flGreen == 0))
        {
            WARNING1("ERROR bCreatePalette 0 flags for PAL_BITFIELDS\n");
            return(FALSE);
        }

        palul.ul += sizeof(P_BITFIELDS);
        break;

    case PAL_BGR:
    case PAL_RGB:
    case PAL_CMYK:

    // RGB and CMYK palette is always fixed.

        ASSERTGDI(iType & PAL_FIXED, "bCreatePalette PAL_RGB/PAL_CMYK: iType not PAL_FIXED");
        ASSERTGDI((iType & ~(PAL_FIXED | PAL_DC | PAL_HT)) == 0, "bCreatePal PAL_RGB/PAL_CMYK: extra flags in iType ");
        ASSERTGDI(cColors == 0, "bCreatePalette PAL_RGB/PAL_CMYK: cColors not 0");
        iType = (iType & (PAL_DC | PAL_HT)) | PAL_FIXED;
        cColors = 0;
        if (iMode != PAL_CMYK)
        {
            if (iMode == PAL_RGB)
            {
                flRedd  = 0x0000FF;
                flGreen = 0x00FF00;
                flBlue  = 0xFF0000;
            }
            else if (iMode == PAL_BGR)
            {
                flRedd  = 0xFF0000;
                flGreen = 0x00FF00;
                flBlue  = 0x0000FF;
            }
            palul.ul += sizeof(P_BITFIELDS);
        }

        break;

    case PAL_INDEXED:

        palul.ul += (sizeof(PAL_ULONG) * cColors);

    // ASSERT for valid flags to detect bad code, mask off invalid flags so in
    // retail we work fine with journal files, bad drivers.

        ASSERTGDI((iType & ~(PAL_MONOCHROME | PAL_DC | PAL_FREE | PAL_FIXED | PAL_MANAGED | PAL_HT)) == 0,
                              "ERROR bCreatePal PAL_INDEXED iType");

        iType = iType & (PAL_MONOCHROME | PAL_DC | PAL_FREE | PAL_FIXED | PAL_MANAGED | PAL_HT);

        if (cColors == 0)
        {
            RIP("ERROR PAL_INDEXED bCreatePalette cColors 0\n");
            return(FALSE);
        }

        break;

    default:
        RIP("bCreatePalette theses modes are not supported at this time\n");
        return(FALSE);
    }

// Allocate the palette.

    PPALETTE ppalTemp;

    ppal = ppalTemp = (PPALETTE) ALLOCOBJ(palul.ul, PAL_TYPE, FALSE);

    if (ppalTemp == (PPALETTE)NULL)
    {
        WARNING("bCreatePalette failed memory allocation\n");
        return(FALSE);
    }

    //
    // Initialize the palette.
    //

    ppalTemp->flPal          = iMode | iType;
    ppalTemp->cEntries       = cColors;
    ppalTemp->ulTime         = ulGetNewUniqueness(ulXlatePalUnique);
    ppalTemp->hdcHead        = (HDC) 0;
    ppalTemp->hSelected.ppal = (PPALETTE) NULL;
    ppalTemp->cRefRegular    = 0;
    ppalTemp->cRefhpal       = 0;
    ppalTemp->ptransFore     = NULL;
    ppalTemp->ptransCurrent  = NULL;
    ppalTemp->ptransOld      = NULL;
    ppalTemp->ulRGBTime      = 0;
    ppalTemp->pRGBXlate      = NULL;
    ppalTemp->ppalColor      = ppalTemp;
    ppalTemp->apalColor      = &ppalTemp->apalColorTable[0];

    switch(iMode)
    {
    case PAL_BITFIELDS:
    case PAL_RGB:
    case PAL_BGR:

    {
    // It won't kill us if any of these flags are 0, but it is
    // definitely an error on someones behalf.

        ASSERTGDI(flRedd   != 0, "ERROR flGre");
        ASSERTGDI(flGreen  != 0, "ERROR flGre");
        ASSERTGDI(flBlue   != 0, "ERROR flBlu");

    // Save away the Masks

        flRed(flRedd);
        flGre(flGreen);
        flBlu(flBlue);

        if ((flRedd  == 0x0000ff) &&
            (flGreen == 0x00ff00) &&
            (flBlue  == 0xff0000))
        {
            ppalTemp->flPal |= PAL_RGB;
        }
        else if ((flRedd  == 0xf800) &&
                 (flGreen == 0x07e0) &&
                 (flBlue  == 0x001f))
        {
            ppalTemp->flPal |= PAL_RGB16_565;
        }
        else if ((flRedd  == 0x7c00) &&
                 (flGreen == 0x03e0) &&
                 (flBlue  == 0x001f))
        {
            ppalTemp->flPal |= PAL_RGB16_555;
        }

    // Let ParseBits calculate the left and right shifts we need.

        ParseBits(flRedd,  &cRedRight(), &cRedLeft(), &cRedMiddle(), 0);
        ParseBits(flGreen, &cGreRight(), &cGreLeft(), &cGreMiddle(), 8);
        ParseBits(flBlue,  &cBluRight(), &cBluLeft(), &cBluMiddle(), 16);
    }

    break;

    case PAL_INDEXED:

    {
        UINT uiTemp;
        PAL_ULONG *ppalstruc = apalColorGet();

        if (pulColors != (PULONG) NULL)
        {
            //
            // Copy the palette values in.
            // Make sure only valid entries are copied.
            //

            __try
            {
                for (uiTemp = 0; uiTemp < cColors; uiTemp++)
                {
                    palul.ul = *(pulColors++);
                    (ppalstruc++)->pal = palul.pal;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());
                bDataStatus = FALSE;
            }
        }
        else
        {
        // Initialize the palette with 0's.

            for (uiTemp = 0; uiTemp < cColors; uiTemp++)
                (ppalstruc++)->ul = 0;
        }
    }

    } // switch

// Now that all the other appropriate fields have been computed, compute
// the call tables.

    XEPALOBJ pal(ppalTemp);
    pal.vComputeCallTables();

// Add it to the handle table.

    if (bDataStatus)
    {
        if (HmgInsertObject(ppalTemp,
                            HMGR_MAKE_PUBLIC | HMGR_ALLOC_ALT_LOCK,
                            PAL_TYPE) != (HOBJ) 0)
        {
            return(TRUE);
        }
        WARNING("bCreatePalette failed HmgInsertObject\n");
    }
    else
    {
        WARNING("bCreatePalette failed Copying user data\n");
    }

// Clean up the allocated memory.

    FREEOBJ(ppalTemp, PAL_TYPE);
    ppal = NULL;
    return(FALSE);
}

PALETTEENTRY apalMono[2] =
{
    { 0,   0,   0,   0  },
    { 0xFF,0xFF,0xFF,0  }
};

PALETTEENTRY apal3BPP[8] =
{
    {0,   0,   0,    0 },
    {0,   0,   0xFF, 0 },
    {0,   0xFF,0,    0 },
    {0,   0xFF,0xFF, 0 },
    {0xFF,0,   0,    0 },
    {0xFF,0,   0xFF, 0 },
    {0xFF,0xFF,0,    0 },
    {0xFF,0xFF,0xFF, 0 }
};

PALETTEENTRY apalVGA[16] =
{
    {0,   0,   0,    0 },
    {0x80,0,   0,    0 },
    {0,   0x80,0,    0 },
    {0x80,0x80,0,    0 },
    {0,   0,   0x80, 0 },
    {0x80,0,   0x80, 0 },
    {0,   0x80,0x80, 0 },
    {0x80,0x80,0x80, 0 },

    {0xC0,0xC0,0xC0, 0 },
    {0xFF,0,   0,    0 },
    {0,   0xFF,0,    0 },
    {0xFF,0xFF,0,    0 },
    {0,   0,   0xFF, 0 },
    {0xFF,0,   0xFF, 0 },
    {0,   0xFF,0xFF, 0 },
    {0xFF,0xFF,0xFF, 0 }
};

#define COLOR_SWAP_BC       0x01
#define COLOR_SWAP_AB       0x02
#define COLOR_SWAP_AC       0x04

/******************************Member*Function*****************************\
* PALMEMOBJ::bCreateHTPalette
*
* Constructor for creating halftone palettes.
*
* Returns: True for success, False for error.
*
* History:
*  04-Jun-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL PALMEMOBJ::bCreateHTPalette(LONG iFormatHT, GDIINFO *pGdiInfo)
{
    if ((iFormatHT == HT_FORMAT_32BPP)  ||
        (iFormatHT == HT_FORMAT_24BPP)  ||
        (iFormatHT == HT_FORMAT_16BPP)) {

    // 32BPP halftone use lower 3 bytes as RGB, same as 24bpp, but with extra
    // pad byte at end, the order can be any of PRIMARY_ORDER_xxx

        ULONG   ulPrimaryOrder = pGdiInfo->ulPrimaryOrder;
        ULONG   ulR;
        ULONG   ulG;
        ULONG   ulB;
        ULONG   ulTmp;

        if (iFormatHT == HT_FORMAT_16BPP) {

            //
            // 16BPP_555 for now, we should also do 16bpp_565

            ulR = 0x00007c00;
            ulG = 0x000003e0;
            ulB = 0x0000001f;

        } else {

            ulR = 0x00FF0000;
            ulG = 0x0000FF00;
            ulB = 0x000000FF;
        }

        if (ulPrimaryOrder & COLOR_SWAP_BC) {

            ulTmp = ulG;
            ulG   = ulB;
            ulB   = ulTmp;
        }

        if (ulPrimaryOrder & COLOR_SWAP_AB) {

            ulTmp = ulR;
            ulR   = ulG;
            ulG   = ulTmp;

        } else if (ulPrimaryOrder & COLOR_SWAP_AC) {

            ulTmp = ulR;
            ulR   = ulB;
            ulB   = ulTmp;
        }

        if (!bCreatePalette(PAL_BITFIELDS, 0, (PULONG)NULL,
                            ulR, ulG, ulB, PAL_FIXED|PAL_HT)) {

            return(FALSE);
        }
#if 0
    } else if (iFormatHT == HT_FORMAT_24BPP) {

    // 24BPP halftone always does BGR

        if (!bCreatePalette(PAL_BGR, 0, (PULONG)NULL,
                            0x0,0x0,0x0,PAL_FIXED|PAL_HT))
        {
            return(FALSE);
        }

    } else if (iFormatHT == HT_FORMAT_16BPP) {

    // 16BPP halftone always does 555 for red, green, and blue.

        if (!bCreatePalette(PAL_BITFIELDS, 0, (PULONG)NULL,
                            0x7c00,0x3e0,0x1f,PAL_FIXED|PAL_HT))
        {
            return(FALSE);
        }
#endif
    }
    else
    {
        ULONG   cEntries;
        BOOL    bAlloc = FALSE;
        PPALETTEENTRY   ppalentry;
        PALETTEENTRY    apalentry[8];

        switch(iFormatHT)
        {
        case HT_FORMAT_1BPP:
            cEntries = 2;
            ppalentry = &apalMono[0];
            if (pGdiInfo->flHTFlags & HT_FLAG_OUTPUT_CMY)
            {
                ppalentry = &apalentry[0];
                *((ULONG *)&apalentry[0]) = 0x0FFFFFF;
                *((ULONG *)&apalentry[1]) = 0;
            }
            break;

        case HT_FORMAT_4BPP_IRGB:
            cEntries = 16;
            ppalentry = &apalVGA[0];
            break;

        default:
            WARNING("unsupported halftone format, use default VGA format\n");
        case HT_FORMAT_4BPP:
        {
            cEntries = 8;
            ppalentry = &apalentry[0];
            RtlCopyMemory(apalentry, apal3BPP, sizeof(PALETTEENTRY) * 8);

            ULONG ulPrimaryOrder = pGdiInfo->ulPrimaryOrder;
            BYTE jTmp;
            int i;

            if (ulPrimaryOrder & COLOR_SWAP_BC)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Green and Blue entries.

                    jTmp = apalentry[i].peGreen;
                    apalentry[i].peGreen = apalentry[i].peBlue;
                    apalentry[i].peBlue = jTmp;
                }
            }

            if (ulPrimaryOrder & COLOR_SWAP_AB)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Red and Green.

                    jTmp = apalentry[i].peRed;
                    apalentry[i].peRed = apalentry[i].peGreen;
                    apalentry[i].peGreen = jTmp;
                }
            }
            else if (ulPrimaryOrder & COLOR_SWAP_AC)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Red and Blue entries.

                    jTmp = apalentry[i].peRed;
                    apalentry[i].peRed = apalentry[i].peBlue;
                    apalentry[i].peBlue = jTmp;
                }
            }

            if (pGdiInfo->flHTFlags & HT_FLAG_OUTPUT_CMY)
            {
            // Substrative device.

                for (int i = 0; i < 8; i++)
                    *((ULONG *)&apalentry[i]) ^= 0x0FFFFFF;
            }
        }
        break;

        case HT_FORMAT_8BPP:
        // Query the palette entries from Daniel's halftone library.
        // Query the number of entries on the first call.  Get the
        // color entries on the second.

            PCOLORINFO  pci = &pGdiInfo->ciDevice;

            cEntries = HT_Get8BPPMaskPalette((LPPALETTEENTRY)NULL,
                                             (BOOL)(pGdiInfo->flHTFlags &
                                                     HT_FLAG_USE_8BPP_BITMASK),
                                             (BYTE)((pGdiInfo->flHTFlags &
                                                     HT_FLAG_8BPP_CMY332_MASK)
                                                                >> 24),
                                             (UDECI4)pci->RedGamma,
                                             (UDECI4)pci->GreenGamma,
                                             (UDECI4)pci->BlueGamma);

            ppalentry = (PPALETTEENTRY)
                    PALLOCNOZ (sizeof(PALETTEENTRY) * cEntries, 'laPG');

            if (ppalentry == (PPALETTEENTRY)NULL)
                return(FALSE);

            if (pGdiInfo->flHTFlags & HT_FLAG_INVERT_8BPP_BITMASK_IDX) {

                HT_SET_BITMASKPAL2RGB(ppalentry);

            } else {

                ppalentry->peRed   =
                ppalentry->peGreen =
                ppalentry->peBlue  =
                ppalentry->peFlags = 0;
            }

            HT_Get8BPPMaskPalette(ppalentry,
                                  (BOOL)(pGdiInfo->flHTFlags &
                                         HT_FLAG_USE_8BPP_BITMASK),
                                  (BYTE)((pGdiInfo->flHTFlags &
                                          HT_FLAG_8BPP_CMY332_MASK) >> 24),
                                  (UDECI4)pci->RedGamma,
                                  (UDECI4)pci->GreenGamma,
                                  (UDECI4)pci->BlueGamma);

            bAlloc = TRUE;
            break;
        }

        if (!bCreatePalette(PAL_INDEXED, cEntries,
                            (PULONG)ppalentry,0,0,0,PAL_FREE|PAL_HT))
        {
            if (bAlloc)
                VFREEMEM(ppalentry);

            return(FALSE);
        }

        if (bAlloc)
        {
        // 8bpp case.  halftone palette is not the same as the device palette.

            VFREEMEM(ppalentry);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* PALMEMOBJ destructor
*
* destructor for palette memory objects
*
* History:
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PALMEMOBJ::~PALMEMOBJ()
{
    PVOID pvRemove;

    if (ppal != (PPALETTE) NULL)
    {
        if (bKeep)
        {
            DEC_SHARE_REF_CNT(ppal);
        }
        else
        {
            if (ppal != ppalColor())
            {
                //
                // Remove a reference to the palette who owns the color
                // table.
                //

                XEPALOBJ palColor(ppalColor());
                palColor.vUnrefPalette();
            }

            if (ppal->pRGBXlate != NULL)
            {
                if (ppal->pRGBXlate != gpRGBXlate)
                    VFREEMEM(ppal->pRGBXlate);

                ppal->pRGBXlate = NULL;
            }

            pvRemove = HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, TRUE, PAL_TYPE);
            ASSERTGDI(pvRemove != NULL, "Remove failed.  Havoc will result.");

            FREEOBJ(ppal,PAL_TYPE);
        }

        ppal = (PPALETTE) NULL;      // prevent ~PALOBJ from doing anything
    }
}

/******************************Public*Routine******************************\
* ulGetNearestFromPalentryNoExactMatchFirst
*
* Given a palette entry finds the index of the closest matching entry.
*
* History:
*  02-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
*
*  16-Jan-1993 -by- Michael Abrash [mikeab]
* Checked for exact match first.
\**************************************************************************/

ULONG XEPALOBJ::ulGetNearestFromPalentryNoExactMatchFirst(
    CONST PALETTEENTRY palentry)
{
    if (!bIsIndexed())
    {
        return(ulGetMatchFromPalentry(palentry));
    }

    //
    // We should only be called when there wouldn't be an exact match.
    // We don't need to check BGR, RGB, bitfields, or explicit
    // index, because those always produce an exact match.
    // We assume the palette is non-explicitly indexed at this point.
    //

    ASSERTGDI(bIsIndexed(),     "ERROR ulGetNearestFromPalentry not indexed");
    ASSERTGDI(cEntries() != 0,  "ERROR ulGetNearestFromPalentry cEntries is 0");

    PALETTEENTRY *ppalTemp, *ppalMax, *ppalBase;
    PALETTEENTRY *ppalBest;

    if (ppal == ppalDefault)
    {
        ppalTemp = &aPalDefaultVGA[0].pal;
    }
    else
    {
        ppalTemp = &ppal->apalColor[0].pal;
    }

    //
    // last palette entry.
    //

    ppalBase = ppalTemp;
    ppalMax  = ppalTemp + cEntries();

#if defined(_X86_)

    ULONG ulRed = palentry.peRed;
    ULONG ulGre = palentry.peGreen;
    ULONG ulBlu = palentry.peBlue;

_asm
{

   ;eax is a work buffer
    mov ebx, ulBlu
    mov ecx,ppalTemp
    mov edx,MAX_PAL_ERROR
    mov esi,ppalMax
   ;edi is used to accum ulErrTemp

    jmp Begin_Loop

align 16

Check_For_Done:

    add     ecx, 4
    cmp     ecx, esi
    jz      short Done

Begin_Loop:

    mov     edi, edx                // Put best error so far in
    movzx   eax, BYTE PTR [ecx+2]   // Get the blue byte from log pal
    sub     eax, ebx                // Subtract out the blue component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub the square of the
                                    // the red diff from the best so far
    jbe     short Check_For_Done    // If it's 0 or below jump to done
    movzx   eax, BYTE PTR [ecx+1]   // Get green byte from log pal
    sub     eax, ulGre              // Subtract out the green component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub the square of the
                                    // blue diff with the best so far.
    jbe     short Check_For_Done    // If it's 0 or below jump to done
    movzx   eax, BYTE PTR [ecx]     // Put red byte from log pal
    sub     eax, ulRed              // Subtract out red component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub square of diff
    jbe     short Check_For_Done    // If it's 0 or below jump to done

// New_Best:

    mov     ppalBest, ecx       // Remember our best entry so far
    sub     edx,edi             // Subtract out what remains to
                                // get our new best error.
    jnz     Check_For_Done      // If it's 0 error we are done.

Done:
}

#else

#if defined(_MIPS_)

    ppalBest = ppalSearchNearestEntry(ppalTemp,
                                      palentry,
                                      cEntries(),
                                      pArrayOfSquares);

#else

    ULONG ulError;   // The least error for ppalBest
    ULONG ulErrTemp;
    ulError = MAX_PAL_ERROR;

    do
    {
        if ((ulErrTemp =
                     pArrayOfSquares[ppalTemp->peRed - palentry.peRed] +
                     pArrayOfSquares[ppalTemp->peGreen - palentry.peGreen] +
                     pArrayOfSquares[ppalTemp->peBlue - palentry.peBlue]) < ulError)
        {
            ppalBest = ppalTemp;

            if ((ulError = ulErrTemp) == 0)
            {
                break;
            }
        }

    } while (++ppalTemp < ppalMax);

#endif // #if defined(_MIPS_)
#endif // #if defined(_X86_)

    ASSERTGDI( ((ULONG)(ppalBest - ppalBase) < cEntries()), "index too big ulGetNearestFromPalentry");

    // Sundown safe truncation
    return (ULONG)(ppalBest - ppalBase);
}


/******************************Public*Routine******************************\
* ulIndexedGetMatchFromPalentry
*
* Given a PALETTEENTRY, finds the index of the matching entry in the
* specified palette, or returns 0xFFFFFFFF if there's no exact match.
*
* Note: This function does not use any semaphoring, nor does it expect the
* calling code to have done so. Palettes belong to DCs, and DCs are unique
* on a per-process basis; therefore, the only risk is that a multithreaded
* app acting on a palette-managed DC (because non-palette-managed palettes
* can never change) might have one thread change the palette while another
* thread is creating a brush or doing something similar that reads the
* palette. In that case, the app's in trouble anyway, because unless it
* does its own synchronization (and if it does, there's no issue here at all),
* then it can't be sure which palette will be in effect for the brush, and
* it would get indeterminate results even if we did protect the palette
* while we did this.
*
* History:
*  Sun 27-Dec-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL ulIndexedGetMatchFromPalentry(PALETTE* ppal, ULONG ulRGB)
{
    ULONG ulIndex;
    PAL_ULONG palentryTemp, *ppalTemp, *ppalMax;

    XEPALOBJ pal(ppal);

    //
    // make a copy we can access as a ULONG
    //

    palentryTemp.ul = ulRGB;

    ASSERTGDI(pal.cEntries() != 0, "ERROR ulGetNearestFromPalentry cEntries==0");

    if (palentryTemp.pal.peFlags == PC_EXPLICIT)
    {
        //
        // This is an explicit index, so we can just use it directly.
        // Explicit indices are limited to 8 bits, so mask off high three bytes,
        // then keep within the number of palette entries, if necessary
        //

        ulIndex = palentryTemp.ul & 0x000000FF;

        if (ulIndex >= pal.cEntries())
        {
            ulIndex = ulIndex % pal.cEntries();
        }

        return(ulIndex);
    }

    //
    // We only care about the RGB fields from now on
    //

    palentryTemp.ul &= 0x00FFFFFF;

    //
    // Scan through the palette until we either find an exact match or have
    // rejected all the palette entries
    //

    ppalTemp = pal.apalColorGet(); // point to the first palette entry
    ppalMax = ppalTemp + pal.cEntries();  // last palette entry

    while (ppalTemp != ppalMax)
    {
        //
        // Does the current palette entry match the color we're searching for?
        //

        if ((ppalTemp->ul & 0x00FFFFFF) == palentryTemp.ul)
        {
            //
            // Yes, we've found an exact match.
            //

            goto ExactMatch;
        }

        ppalTemp++;
    }

    //
    // We didn't find an exact match.
    //

    return(0xFFFFFFFF);

    //
    // We've found an exact match.
    //

ExactMatch:

    //Sundown safe truncation
    return(ULONG)(ppalTemp - pal.apalColorGet());
}

/******************************Public*Routine******************************\
* ulIndexedGetNearestFromPalentry
*
* For an indexed palette, finds the index of the matching entry in the
* specified palette by first doing an exact search, then doing a nearest
* search.
*
* Note that this routine isn't in-line because it is sometimes the target
* of indirect calls.
\**************************************************************************/

ULONG FASTCALL ulIndexedGetNearestFromPalentry(PALETTE* ppal, ULONG ulRGB)
{
    ULONG ul = ulIndexedGetMatchFromPalentry(ppal, ulRGB);
    if (ul == 0xffffffff)
    {
        XEPALOBJ pal(ppal);

        ul = pal.ulGetNearestFromPalentryNoExactMatchFirst(*((PALETTEENTRY*) &ulRGB));
    }
    return(ul);
}

/******************************Public*Routine******************************\
* ulRGBToBitfield
*
* Converts an RGB into an index for Bitfield palettes.
*
* History:
*  08-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL ulRGBToBitfield(PALETTE* ppal, ULONG ulRGB)
{
    XEPALOBJ pal(ppal);
    ASSERTGDI(pal.bIsBitfields(), "Error ulRGBToBitfield not bitfields");

    return((((ulRGB >> pal.cRedLeft()) << pal.cRedRight()) & pal.flRed()) |
           (((ulRGB >> pal.cGreLeft()) << pal.cGreRight()) & pal.flGre()) |
           (((ulRGB >> pal.cBluLeft()) << pal.cBluRight()) & pal.flBlu()));
}

/******************************Public*Routine******************************\
* ulRGBTo565
*
* Converts an RGB into an index for 5-6-5 bitfield palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBTo565(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI((((XEPALOBJ) ppal).bIsBitfields()) &&
              (((XEPALOBJ) ppal).flRed() == 0xf800) &&
              (((XEPALOBJ) ppal).flGre() == 0x07e0) &&
              (((XEPALOBJ) ppal).flBlu() == 0x001f), "Error not 5-6-5");

    return(((ulRGB >> 19) & 0x001f) |
           ((ulRGB >> 5)  & 0x07e0) |
           ((ulRGB << 8)  & 0xf800));
}

/******************************Public*Routine******************************\
* ulRGBTo555
*
* Converts an RGB into an index for 5-5-5 bitfield palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBTo555(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI((((XEPALOBJ) ppal).bIsBitfields()) &&
              (((XEPALOBJ) ppal).flRed() == 0x7c00) &&
              (((XEPALOBJ) ppal).flGre() == 0x03e0) &&
              (((XEPALOBJ) ppal).flBlu() == 0x001f), "Error not 5-5-5");

    return(((ulRGB >> 19) & 0x001f) |
           ((ulRGB >> 6)  & 0x03e0) |
           ((ulRGB << 7)  & 0x7c00));
}

/******************************Public*Routine******************************\
* ulRGBToBGR
*
* Converts an RGB into an index for BGR palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBToBGR(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI(((XEPALOBJ) ppal).bIsBGR(), "Error not BGR");

    return(((ulRGB & 0x0000ff) << 16) |
           ((ulRGB & 0x00ff00)) |
           ((ulRGB & 0xff0000) >> 16));
}

/******************************Public*Routine******************************\
* ulRGBToRGB
*
* Converts an RGB into an index for RGB palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBToRGB(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI(((XEPALOBJ) ppal).bIsRGB(), "Error not RGB");

    return(ulRGB & 0xffffff);
}

/******************************Public*Routine******************************\
* ulRawToRaw
*
* No Converts, just pass through original data
\**************************************************************************/

ULONG FASTCALL ulRawToRaw(PALETTE* ppal, ULONG ulRGB)
{
    UNREFERENCED_PARAMETER(ppal);

    return(ulRGB);
}

/******************************Public*Routine******************************\
* vComputeCallTables
*
* Updates the pfnGetMatchFromPalentry and pfnGetNearestFromPalentry
* function pointers to reflect the current palette settings.
\**************************************************************************/

VOID XEPALOBJ::vComputeCallTables()
{
    PFN_GetFromPalentry pfnGetMatchFromPalentry;
    PFN_GetFromPalentry pfnGetNearestFromPalentry;

    if (bIsIndexed())
    {
        pfnGetMatchFromPalentry = ulIndexedGetMatchFromPalentry;
        pfnGetNearestFromPalentry = ulIndexedGetNearestFromPalentry;
    }
    else
    {
        if (bIsBitfields())
        {
            if ((flBlu() == 0x001f) &&
                (flGre() == 0x07e0) &&
                (flRed() == 0xf800))
            {
                pfnGetMatchFromPalentry = ulRGBTo565;
            }
            else if ((flBlu() == 0x001f) &&
                     (flGre() == 0x03e0) &&
                     (flRed() == 0x7c00))
            {
                pfnGetMatchFromPalentry = ulRGBTo555;
            }
            else
            {
                pfnGetMatchFromPalentry = ulRGBToBitfield;
            }
        }
        else if (bIsBGR())
        {
            pfnGetMatchFromPalentry = ulRGBToBGR;
        }
        else if (bIsCMYK())
        {
            //
            // In CMYK color case, Palette index == CMYK color data.
            //
            pfnGetMatchFromPalentry = ulRawToRaw;
        }
        else
        {
            ASSERTGDI(bIsRGB(), "ERROR invalid type in palette");
            pfnGetMatchFromPalentry = ulRGBToRGB;
        }

        //
        // For non-indexed palettes, an exact match can always be found,
        // so GetMatch and GetNearest can be the same function:
        //

        pfnGetNearestFromPalentry = pfnGetMatchFromPalentry;
    }

    ppal->pfnGetMatchFromPalentry = pfnGetMatchFromPalentry;
    ppal->pfnGetNearestFromPalentry = pfnGetNearestFromPalentry;
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulGetEntries
*
* This function copies the requested palette entries out.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" ULONG PALOBJ_cGetColors(
    PALOBJ *ppo,
    ULONG iStart,
    ULONG cEntry,
    ULONG *ppalentry
    )
{
    XEPALOBJ *ppal = (XEPALOBJ *)ppo;

    //
    // Get color data from PALOBJ
    //
    ULONG ulRet = ppal->ulGetEntries(iStart, cEntry, (PPALETTEENTRY)ppalentry,FALSE);

    //
    // Correct GammaRamp if nessesary.
    //
    if (ppal->bNeedGammaCorrection())
    {
        //
        // Correct color based on GammaRamp table
        //
        ppal->CorrectColors((PPALETTEENTRY)ppalentry,ulRet);
    }

    return (ulRet);
}

ULONG XEPALOBJ::ulGetEntries(ULONG iStart, ULONG cEntry,
                             PPALETTEENTRY ppalentry, BOOL bZeroFlags)
{
// See if the number of entries in the palette is being requested.

    if (ppalentry == (PPALETTEENTRY) NULL)
        return(ppal->cEntries);

// Make sure the start index is valid, this checks RGB case also.

    if (iStart >= ppal->cEntries)
        return(0);

// Make sure we don't ask for more than we have

    if (cEntry > (ppal->cEntries - iStart))
        cEntry = ppal->cEntries - iStart;

// Copy them to the buffer

    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &(ppal->apalColor[iStart]);

    RtlCopyMemory(ppalentry, ppalstruc, cEntry*sizeof(PALETTEENTRY));

    if (bZeroFlags)
    {
        ppalstruc = ppalentry + cEntry;
        while (ppalentry < ppalstruc)
        {
            ppalentry->peFlags = 0;
            ppalentry++;
        }
    }

    return(cEntry);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulSetEntries
*
* This function copies the requested palette entries into the palette
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulSetEntries(ULONG iStart, ULONG cEntry, CONST PALETTEENTRY *ppalentry)
{
    ASSERTGDI(bIsPalDC(), "ERROR: ulSetEntries called on non-DC palette");

// Make sure they aren't trying to change the default or halftone palette.
// Make sure they aren't trying to pass us NULL.
// Make sure the start index is valid, this checks the RGB case also.

    if ((ppal == ppalDefault)               ||
        bIsHTPal()                          ||
        (ppalentry == (PPALETTEENTRY) NULL) ||
        (iStart >= ppal->cEntries))
    {
        return(0);
    }

// Make sure we don't try to copy off the end of the buffer

    if (iStart + cEntry > ppal->cEntries)
        cEntry = ppal->cEntries - iStart;

// Let's not update the palette time if we don't have to.

    if (cEntry == 0)
        return(0);

// Copy the new values in

    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &(ppal->apalColor[iStart]);
    PBYTE pjFore     = NULL;
    PBYTE pjCurrent  = NULL;

// Mark the foreground translate dirty so we get a new realization done
// in the next RealizePaletette.

    if (ptransFore() != NULL)
    {
        ptransFore()->iUniq = 0;
        pjFore = &(ptransFore()->ajVector[iStart]);
    }

    if (ptransCurrent() != NULL)
    {
        ptransCurrent()->iUniq = 0;
        pjCurrent = &(ptransCurrent()->ajVector[iStart]);
    }

// Hold the orginal values in temporary vars.

    ULONG ulReturn = cEntry;

    while(cEntry--)
    {
        *ppalstruc = *ppalentry;

        if (pjFore)
        {
            *pjFore = 0;
            pjFore++;
        }

        if (pjCurrent)
        {
            *pjCurrent = 0;
            pjCurrent++;
        }

        ppalentry++;
        ppalstruc++;
    }

// Set in the new palette time.

    vUpdateTime();

// Mark foreground translate and current translate invalid so they get rerealized.

    return(ulReturn);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vUnrefPalette()
*
* Palettes are referenced when put into a surface.  If the reference count
* is one when vUnreference is called it mean the last surface using the
* palette is being deleted so the palette should be deleted.  Otherwise the
* reference count should just be decremented.
*
* History:
*  09-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vUnrefPalette()
{
    if (ppal != (PPALETTE) NULL)
    {
        ASSERTGDI(!bIsPalDC(), "ERROR should not be called on DC palette");

        if (HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, FALSE, PAL_TYPE))
        {
            if (bIsPalManaged() && ppalOriginal())
            {
                //
                // We have to delete the original palette.
                //

                PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                FREEOBJ(ppalOriginal(), PAL_TYPE);
            }

            if (ppal != ppalColor())
            {
                //
                // Remove a reference to the palette who owns the color
                // table.
                //

                XEPALOBJ palColor(ppalColor());
                palColor.vUnrefPalette();
            }

            if (ppal->pRGBXlate != NULL)
            {
                if (ppal->pRGBXlate != gpRGBXlate)
                    VFREEMEM(ppal->pRGBXlate);

                ppal->pRGBXlate = NULL;
            }

            ASSERTGDI(ppal != ppalMono, "ERROR mono palette went to 0");
            FREEOBJ(ppal, PAL_TYPE);
        }
        else
        {
            //
            // Just decrement the reference count.
            //

            DEC_SHARE_REF_CNT(ppal);
        }

        ppal = (PPALETTE) NULL;
    }
}

/******************************Public*Routine******************************\
* bDeletePalette
*
* This attempts to delete a palette.  It will fail if the palette
* is currently selected into more than one DC or is busy.
*
* History:
*  Wed 04-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Simplified and renamed.
*
*  27-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bDeletePalette(HPAL hpal, BOOL bCleanup, CLEANUPTYPE cutype)
{
    //
    // Need to grab the palette semaphore so this guy can't get selected in
    // anymore.  Only once we know he isn't selected anywhere and we hold the
    // semaphore so he can't be selected anywhere can we delete the translates.
    // This is because to access the translates you must either hold the palette
    // semaphore or have a lock on a DC that the palette is selected in.
    // Grab the semaphore so ResizePalette doesn't change the palette out from
    // under you.
    //

    SEMOBJ  semo(ghsemPalette);

    EPALOBJ palobj((HPALETTE)hpal);
    return(palobj.bDeletePalette(bCleanup,cutype));
}

/******************************Public*Routine******************************\
* XEPALOBJ::bDeletePalette()
*
* This attempts to delete a palette.  It will fail if the palette
* is currently selected into more than one DC or is busy.
*
* History:
*  27-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bDeletePalette(BOOL bCleanup, CLEANUPTYPE cutype)
{
    BOOL bReturn = TRUE;

    if ((ppal != ppalDefault) &&
        (ppal != (PPALETTE) NULL) &&
        (ppal != ppalMono))
    {
        if (ppal->pRGBXlate != NULL)
        {
            if (ppal->pRGBXlate != gpRGBXlate)
                VFREEMEM(ppal->pRGBXlate);

            ppal->pRGBXlate = NULL;
        }

        if (bIsPalDC())
        {
            if (ppal->cRefhpal != 0)
            {
                WARNING("bDelete failed palette is selected into a DC\n");
                return(FALSE);
            }

            vMakeNoXlate();
        }

        ASSERTGDI(HmgQueryLock((HOBJ)ppal->hGet()) == 0, "bDeletePalette cLock != 0");

        //
        // Need to make sure we are not being used in a palette API somewhere.
        //

        if (HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, FALSE, PAL_TYPE))
        {
            if (cutype != CLEANUP_SESSION)
            {

                if (bIsPalManaged() && ppalOriginal())
                {
                    //
                    // We have to delete the original palette.
                    //

                    PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                    ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                    FREEOBJ(ppalOriginal(), PAL_TYPE);
                }

                if (ppal != ppalColor())
                {
                    //
                    // Remove a reference to the palette who owns the color
                    // table.
                    //

                    XEPALOBJ palColor(ppalColor());
                    palColor.vUnrefPalette();
                }

            }

            FREEOBJ(ppal, PAL_TYPE);
            ppal = (PPALETTE) NULL;
        }
        else
        {
            //
            // force deletion of palette at cleanup time
            //
            if (bCleanup)
            {
                WARNING ("DRIVER is leaking palette, we force cleanup here\n");

                if (cutype != CLEANUP_SESSION)
                {
                    //
                    // HmgFree will call FREEOBJ after the handle manager entry is freed
                    //
                    if (bIsPalManaged() && ppalOriginal())
                    {
                       //
                       // We have to delete the original palette.
                       //

                       PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                       ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                       FREEOBJ(ppalOriginal(), PAL_TYPE);
                    }


                    if (ppal != ppalColor())
                    {
                       //
                       // Remove a reference to the palette who owns the color
                       // table.
                       //

                       XEPALOBJ palColor(ppalColor());
                       palColor.vUnrefPalette();
                    }
                }

                HmgFree((HOBJ)ppal->hGet());

                ppal = (PPALETTE) NULL;

                bReturn = TRUE;
        }
        else
        {
         #if DBG
            DbgPrint("The count is %lu\n", HmgQueryLock((HOBJ)ppal->hGet()));
        #endif
            WARNING("App error, trying to delete palette that's in use\n");
            bReturn = FALSE;
        }
    }
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vCopy_rgbquad
*
* copies in rgbquad values, used by CreateDIBitmap
*
* History:
*  10-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vCopy_rgbquad(RGBQUAD *prgbquad, ULONG iStart, ULONG cEntries)
{
    ASSERTGDI(iStart < ppal->cEntries,"vCopy_rgbquad iStart > cEntries\n");
    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &ppal->apalColor[iStart];

    if (iStart + cEntries > ppal->cEntries)
        cEntries =  ppal->cEntries - iStart;

#if defined(_X86_)

_asm
{
    mov ecx, cEntries
    mov esi, prgbquad
    mov edi, ppalstruc
    shr ecx, 1
    jz Done_Unroll

Begin_Loop:
    mov eax, [esi]
    mov edx, [esi+4]
    bswap eax
    bswap edx
    shr eax, 8
    shr edx, 8
    mov [edi], eax
    mov [edi+4], edx
    add esi, 8
    add edi, 8
    dec ecx
    jnz Begin_Loop

Done_Unroll:
    test cEntries, 1
    jz Done

    mov eax, [esi]
    bswap eax
    shr eax, 8
    mov [edi], eax

Done:
}

#else

    while(cEntries--)
    {
        ppalstruc->peFlags = 0;
        ppalstruc->peBlue = prgbquad->rgbBlue;
        ppalstruc->peRed = prgbquad->rgbRed;
        ppalstruc->peGreen = prgbquad->rgbGreen;
        ppalstruc++;
        prgbquad++;
    }

#endif

    vUpdateTime();
}

/******************************Public*Routine******************************\
* XEPALOBJ::vCopy_cmykquad
*
* copies in cmykquad values, used by CreateDIBitmap
*
* History:
*  24-Mar-1997 -by- Hideyuki Nagase hideyukn
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vCopy_cmykquad(ULONG *pcmykquad, ULONG iStart, ULONG cEntries)
{
    ASSERTGDI(iStart < ppal->cEntries,"vCopy_cmykquad iStart > cEntries\n");
    PULONG ppalCMYK = (PULONG) &ppal->apalColor[iStart];

    if (iStart + cEntries > ppal->cEntries)
        cEntries =  ppal->cEntries - iStart;

    RtlCopyMemory(ppalCMYK,pcmykquad,cEntries*sizeof(ULONG));

    vUpdateTime();
}

/******************************Public*Routine******************************\
* BOOL XEPALOBJ::bSet_hdev
*
* Attempts to set the hdev owner of a DC palette.
*
* Returns: True if successful, False for failure.
*
* This operation must be protected by the palette semaphore.
*
* History:
*  08-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bSet_hdev(HDEV hdevNew)
{
    ASSERTGDI(ppal->flPal & PAL_DC, "bSet_() passed invalid palette type\n");
    ASSERTGDI(hdevNew != (HDEV) 0, "ERROR hdev is 0");

    if (hdev() != hdevNew)
    {
        if (ppal->cRefhpal == 0)
        {
        // It is not selected into a DC yet so it is safe to delete xlates
        // without holding the DEVLOCK for the device.  because no output
        // can be occuring now.

            vMakeNoXlate();
            hdev(hdevNew);
        }
        else
            return(FALSE);
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XEPALOBJ::bEqualEntries
*
*  Return TRUE if the given two palettes have same color entries.
*
* History:
*  04-Jun-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bEqualEntries(XEPALOBJ pal)
{
    if (!pal.bValid())
        return(FALSE);

    if (cEntries() == pal.cEntries())
    {
        if (flPal() & PAL_INDEXED)
        {
            if (!(pal.flPal() & PAL_INDEXED))
                return(FALSE);

            ULONG ulTemp, ulSource, ulDest;
            ULONG cComp = cEntries();

            for (ulTemp = 0; ulTemp < cComp; ulTemp++)
            {
                ulSource = apalColorGet()[ulTemp].ul;
                ulDest = pal.apalColorGet()[ulTemp].ul;

                if ((ulSource ^ ulDest) << 8)
                {
                    return(FALSE);
                }
            }

            return(TRUE);
        }
        else if (flPal() & PAL_BITFIELDS)
        {
            if (!(pal.flPal() & PAL_BITFIELDS))
                return(FALSE);

            return(!memcmp(apalColorGet(), pal.apalColorGet(),
                       sizeof(PALETTEENTRY) * 3));
        }
        else if (flPal() & PAL_RGB)
        {
            if (pal.flPal() & PAL_RGB)
                return(TRUE);
            else
                return(FALSE);
        }
        else if (flPal() & PAL_BGR)
        {
            if (pal.flPal() & PAL_BGR)
                return(TRUE);
            else
                return(FALSE);
        }
        else
            RIP("There is another type we didn't know about");
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* bInitPALOBJ
*
* Initialize the PALOBJ component
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitPALOBJ()
{
    INT iTemp;

    pArrayOfSquares = &(aArrayOfSquares[255]);

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        pArrayOfSquares[iTemp] =
        pArrayOfSquares[-(iTemp)] = iTemp * iTemp;
    }

    if ((ghsemPalette = GreCreateSemaphore()) == NULL)
        return(FALSE);

// Now initialize 20 color default DC palette

    if (!bSetStockObject(GreCreatePalette((LOGPALETTE *) &logDefaultPal),DEFAULT_PALETTE))
    {
        return(FALSE);
    }

    {
        EPALOBJ palDefault((HPALETTE) STOCKOBJ_PAL);
        ASSERTGDI(palDefault.bValid(), "ERROR invalid default palette");

        palDefault.vSetPID(OBJECT_OWNER_PUBLIC);
        ppalDefault = palDefault.ppalGet();
        dclevelDefault.hpal = STOCKOBJ_PAL;
        dclevelDefault.ppal = ppalDefault;

    // Now initialize default surface palette for 8bpp displays

        PALMEMOBJ palDefaultSurface8bpp;
        if (!palDefaultSurface8bpp.bCreatePalette(PAL_INDEXED,
                                                  256,
                                                  NULL,
                                                  0,
                                                  0,
                                                  0,
                                                  PAL_FREE))
        {
            return(FALSE);
        }

        ppalDefaultSurface8bpp = palDefaultSurface8bpp.ppalGet();

    // Copy the 20 default colours.  The middle entries will be black

        PALETTEENTRY palEntry;
        ULONG ulReturn;
        ULONG ulNumReserved = palDefault.cEntries() >> 1;

        for (ulReturn = 0; ulReturn < ulNumReserved; ulReturn++)
        {
            palEntry = palDefault.palentryGet(ulReturn);
            palDefaultSurface8bpp.palentrySet(ulReturn, palEntry);
        }

        ULONG ulCurrentPal = 256;
        ULONG ulCurrentDef = 20;

        for (ulReturn = 0; ulReturn < ulNumReserved; ulReturn++)
        {
            ulCurrentPal--;
            ulCurrentDef--;

            palEntry = palDefault.palentryGet(ulCurrentDef);
            palDefaultSurface8bpp.palentrySet(ulCurrentPal, palEntry);
        }

    // Leave a reference count of 1 so that it never gets deleted

        palDefaultSurface8bpp.ppalSet(NULL);
    }

// Now initialize default monochrome surface palette.

    PALMEMOBJ palMono;

    if (!palMono.bCreatePalette(PAL_INDEXED, 2, gaulMono,
                           0, 0, 0, PAL_FIXED | PAL_MONOCHROME))
    {
        WARNING("GDI failed mono palette create\n");
        return(FALSE);
    }

    palMono.vKeepIt();
    hpalMono = palMono.hpal();
    ppalMono = palMono.ppalGet();

    //
    // Now initialize default RGB palette for gradient fill source
    //

    PALMEMOBJ palRGB;

    if (!palRGB.bCreatePalette(
                                PAL_BGR,
                                0,
                                NULL,
                                0,
                                0,
                                0,
                                PAL_FIXED))
    {
        WARNING("GDI failed RGB palette create\n");
        return(FALSE);
    }

    gppalRGB = palRGB.ppalGet();

    // Leave a reference count of 1 so that it never gets deleted

    palRGB.ppalSet(NULL);


    return(TRUE);
}

/******************************Public*Routine******************************\
* ULONG XEPALOBJ::ulAnimatePalette
*
* This function changes the requested palette entries in the palette.
*
* History:
*  16-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulAnimatePalette(ULONG iStart, ULONG cEntry, CONST PALETTEENTRY *ppalSrc)
{
    ASSERTGDI(bIsPalDC(), "ERROR this is not a DC palette");

// Make sure they aren't trying to change the default palette.
// Make sure they aren't trying to pass us NULL.
// Make sure the start index is valid, this checks the RGB case also.

    if ((ppal == ppalDefault)               ||
        (ppalSrc == (PPALETTEENTRY) NULL) ||
        (iStart >= ppal->cEntries))
    {
        return(0);
    }

// Make sure we don't try to copy off the end of the buffer

    if (iStart + cEntry > ppal->cEntries)
        cEntry = ppal->cEntries - iStart;

// Let's not update the palette if we don't have to.

    if (cEntry == 0)
        return(0);

// Save the Original values

    ULONG ulReturn = 0;
    ULONG ulTemp = cEntry;

// Copy the new values in

    PAL_ULONG *ppalLogical = (PAL_ULONG *) &(ppal->apalColor[iStart]);
    PAL_ULONG palentry, palPhys;
    TRANSLATE *ptransCurrent = NULL;
    PBYTE pjCurrent = NULL;
    XEPALOBJ palSurf;

// Grab the SEMOBJ so you can access the translates, and can look at cEntries.
{
    SEMOBJ  semo(ghsemPalette);

    if (cRefhpal())
    {
        PDEVOBJ po(hdev());
        ASSERTGDI(po.bValid(), "ERROR invalid pdev");

        if (po.bIsPalManaged())
        {
            palSurf.ppalSet(po.ppalSurf());
            ASSERTGDI(palSurf.bValid(), "ERROR GDI ulAnimatePalette dc");
            ASSERTGDI(palSurf.bIsPalManaged(), "ERROR pdev palmanaged but not palette ???");

            if (ppal->ptransCurrent != NULL)
            {
                ptransCurrent = ppal->ptransCurrent;
                pjCurrent = &(ppal->ptransCurrent->ajVector[iStart]);
            }
        }
    }

    while(ulTemp--)
    {
        palentry.pal = *ppalSrc;

        if (ppalLogical->pal.peFlags & PC_RESERVED)
        {
            ppalLogical->ul = palentry.ul;
            ulReturn++;

            if (pjCurrent != NULL)
            {
                palPhys.ul = palSurf.ulEntryGet((ULONG) *pjCurrent);

                if (palPhys.pal.peFlags & PC_RESERVED)
                {
                    palentry.pal.peFlags = palPhys.pal.peFlags;
                    palSurf.ulEntrySet(*pjCurrent, palentry.ul);
                }
            }
        }
        if (pjCurrent != NULL)
            pjCurrent++;

        ppalSrc++;
        ppalLogical++;
    }

// Release the palette semaphore, we are done accessing protected stuff.
}

// Don't set in a new time, Animate doesn't do that.

    if (pjCurrent)
    {
        PDEVOBJ po(hdev());

    // Lock the screen semaphore so that we don't get flipped into
    // full screen after checking the bit.

        GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
        GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    // Make sure we're still a palettized device -- a dynamic mode change
    // may have occured between the time we released the palette semaphore
    // and acquired the devlock.

        if (po.bIsPalManaged())
        {
            SEMOBJ so(po.hsemPointer());

            if (!po.bDisabled())
            {
                po.pfnSetPalette()(
                    po.dhpdevParent(),
                    (PALOBJ *) &palSurf,
                    0,
                    0,
                    palSurf.cEntries());
            }
        }

        GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
        GreReleaseSemaphoreEx(po.hsemDevLock());
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* VOID XEPALOBJ::vMakeNoXlate()
*
* deletes the pxlate if it exists
*
* History:
*  19-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vMakeNoXlate()
{
    ASSERTGDI(bIsPalDC(), "ERROR trying to delete pxlate from non-dc palette");

// Caller should grab the DEVLOCK to ensure the engine
// isn't in the middle of blt before calling.

    if (ppal->ptransOld)
    {
        if (ppal->ptransOld != ppal->ptransFore)
            VFREEMEM(ppal->ptransOld);

        ppal->ptransOld = NULL;
    }

    if (ppal->ptransCurrent)
    {
        if (ppal->ptransCurrent != ppal->ptransFore)
            VFREEMEM(ppal->ptransCurrent);

        ppal->ptransCurrent = NULL;
    }

    if (ppal->ptransFore)
    {
        VFREEMEM(ppal->ptransFore);

        ppal->ptransFore = NULL;
    }
}

/******************************Public*Routine******************************\
* vAddToList
*
* Add DC to linked list of DC's attached to palette.  The MLOCKOBJ must be
* grabbed before calling this function.
*
* History:
*  16-Dec-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vAddToList(XDCOBJ& dco)
{
    ASSERTGDI(dco.bLocked(), "ERROR 14939");
    ASSERTGDI(bValid(), "ERROR dj945kd");
    ASSERTGDI(bIsPalDC(), "ERROR 234343");

    if (!bIsPalDefault())
    {
    // Well it's a new live hpal.  Add the DC to it's linked list
    // and inc it's cRef count.

        vInc_cRef();
        dco.pdc->hdcNext(hdcHead());
        hdcHead(dco.hdc());
        dco.pdc->hdcPrev((HDC) 0);

        if (dco.pdc->hdcNext() != (HDC) 0)
        {
            MDCOBJA dcoNext(dco.pdc->hdcNext());
            dcoNext.pdc->hdcPrev(dco.hdc());
        }
    }
    else
    {
        dco.pdc->hdcNext((HDC) 0);
        dco.pdc->hdcPrev((HDC) 0);
    }
}

/******************************Public*Routine******************************\
* vRemoveFromList
*
* Remove DC from linked list of DC's.  MLOCKOBJ must be grabbed before call.
*
* History:
*  16-Dec-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vRemoveFromList(XDCOBJ& dco)
{
    ASSERTGDI(dco.bLocked(), "ERROR 1");
    ASSERTGDI(bIsPalDC(), "ERROR 2");

// Take care of the old hpal.  Remove from linked list.  Decrement cRef.
// Remove the hdc from the linked list of DC's associated with palette.

    if (!bIsPalDefault())
    {
    // Remove this DC from the linked list.

        if (dco.pdc->hdcNext() != (HDC) 0)
        {
            MDCOBJA dcoNext(dco.pdc->hdcNext());
            dcoNext.pdc->hdcPrev(dco.pdc->hdcPrev());
        }

        if (dco.pdc->hdcPrev() == (HDC) 0)
        {
        // New head of hdc list for hpal

            hdcHead(dco.pdc->hdcNext());
        }
        else
        {
            MDCOBJA dcoPrev(dco.pdc->hdcPrev());
            dcoPrev.pdc->hdcNext(dco.pdc->hdcNext());
        }

    // Decrement the reference count correctly.

        vDec_cRef();
    }

    dco.pdc->hdcPrev((HDC) 0);
    dco.pdc->hdcNext((HDC) 0);
}

/******************************Public*Routine******************************\
* vFill_triples
*
* For GetDIBits we need to copy a palette out to triples.
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vFill_triples(
RGBTRIPLE *prgb,        // array of quads to fill
ULONG iStart,           // first index in palette to copy out
ULONG cEntry)           // max # of entries to copy out
{
    PALETTEENTRY palentry;
    RGBTRIPLE rgbtrip;
    cEntry = MIN((iStart + cEntry), cEntries());

    ASSERTGDI(cEntries() != 0, "ERROR cEntries");
    ASSERTGDI(!bIsBitfields(), "ERROR bIsBitfields");
    ASSERTGDI(!bIsRGB(), "ERROR bIsRGB");
    ASSERTGDI(!bIsBGR(), "ERROR bIsBGR");

    while (iStart < cEntry)
    {
        palentry = palentryGet(iStart);
        rgbtrip.rgbtRed = palentry.peRed;
        rgbtrip.rgbtBlue = palentry.peBlue;
        rgbtrip.rgbtGreen = palentry.peGreen;
        *prgb++ = rgbtrip;
        iStart++;
    }
}

/******************************Public*Routine******************************\
* vFill_rgbquads
*
* For GetDIBits we need to copy a palette out to rgbquads
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vFill_rgbquads(
RGBQUAD *prgb,          // array of quads to fill
ULONG iStart,           // first index in palette to copy out
ULONG cEntry)           // max # of entries to copy out
{
    if (bIsBGR())
    {
        ((PDWORD) prgb)[0] = 0x00FF0000;
        ((PDWORD) prgb)[1] = 0x0000FF00;
        ((PDWORD) prgb)[2] = 0x000000FF;
    }
    else if (bIsBitfields() && cEntry == 3)
    {
        ((PDWORD) prgb)[0] = flRed();
        ((PDWORD) prgb)[1] = flGre();
        ((PDWORD) prgb)[2] = flBlu();
    }
    else if (bIsRGB())
    {
        ((PDWORD) prgb)[0] = 0x000000FF;
        ((PDWORD) prgb)[1] = 0x0000FF00;
        ((PDWORD) prgb)[2] = 0x00FF0000;
    }
    else
    {
        PALETTEENTRY palentry;
        RGBQUAD  rgbquad;
        cEntry = MIN((iStart + cEntry), cEntries());

        while (iStart < cEntry)
        {
            palentry = palentryGet(iStart);
            rgbquad.rgbRed = palentry.peRed;
            rgbquad.rgbBlue = palentry.peBlue;
            rgbquad.rgbGreen = palentry.peGreen;
            rgbquad.rgbReserved = 0;
            *prgb++ = rgbquad;
            iStart++;
        }
    }
}

/******************************Public*Routine******************************\
* vGetEntriesFrom
*
* This is for the DIB_PAL_COLORS case of CreateDIBitmap.
* This uses the array of ushorts in bmiColors and the DC palette to
* initialize the surface palette.  You need to create a palette that
* represents the essence of a DC palette.  That means if DC palette
* has a PC_EXPLICIT in it, reach down into the surface palette for the
* palette entry.
*
* History:
*  Thu 03-Feb-1994 -by- Patrick Haluptzok [patrickh]
* Chicago compatability, grab the colors out of the VGA palette if the
* system palette is not available.
*
*  09-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vGetEntriesFrom(XEPALOBJ palDC, XEPALOBJ palSurf, PUSHORT pusIndices, ULONG cEntry)
{
    //
    // We assume if the palette was invalid (which indicates it was a compatible
    // bitmap on a palette managed device) then the caller has passed the
    // PDEV surface palette instead which is valid.
    //

    ASSERTGDI(palDC.bValid(), "ERROR palDC not valid");
    ASSERTGDI(palSurf.bValid(), "ERROR palSurf not valid");
    ASSERTGDI(palDC.cEntries() != 0, "ERROR 0 entry palDC");
    ASSERTGDI(cEntry <= cEntries(), "ERROR bGetEntriesFrom cEntry too big");

    PAL_ULONG palentry;
    ULONG cEntryDC;
    ULONG cEntrySurf;

    cEntryDC = palDC.cEntries();

    //
    // We need the PDEV palette for the screen if this is a compatible
    // bitmap on a palette managed device which is indicated by have a
    // NULL ppalSurf.
    //

    cEntrySurf = palSurf.bIsPalManaged() ? palSurf.cEntries() : 0;

    while (cEntry--)
    {
        palentry.ul = (ULONG) pusIndices[cEntry];

        if (palentry.ul >= cEntryDC)
            palentry.ul = palentry.ul % cEntryDC;

        palentry.pal = palDC.palentryGet(palentry.ul);

        if (palentry.pal.peFlags == PC_EXPLICIT)
        {
            if (cEntrySurf)
            {
            // Grab the RGB out of the system palette.

                palentry.ul = palentry.ul & 0x0000FFFF;

                if (palentry.ul >= cEntrySurf)
                    palentry.ul = palentry.ul % cEntrySurf;

                palentry.pal = palSurf.palentryGet(palentry.ul);
            }
            else
            {
            // Get color entries from the VGA palette.  This
            // is Chicago compatible.

                palentry.ul = palentry.ul & 0x0000F;
                palentry.pal = apalVGA[palentry.ul];
            }
        }

        //
        // Always 0 out the flags.
        //

        palentry.pal.peFlags = 0;
        palentrySet(cEntry, palentry.pal);
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInitMono
*
* This initializes a monochrome palette.
*
* History:
*  24-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInitMono()
{
    PAL_ULONG palentry;

    palentry.ul = 0;
    palentrySet(0, palentry.pal);

    palentry.ul = 0x00FFFFFF;
    palentrySet(1, palentry.pal);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInitVGA
*
* This initializes a 16 color palette to be just like the VGA.
*
* History:
*  Wed 02-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Re-did to be Win3.0 compatible.
*
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInitVGA()
{
    ULONG ulIndex;

    for (ulIndex = 0; ulIndex < 16; ulIndex++)
    {
        palentrySet(ulIndex, aPalVGA[ulIndex].pal);
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInit256Rainbow
*
* This initializes a 256 color palette with the default colors at the ends
* and a rainbow in the middle.
*
* History:
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInit256Rainbow()
{
    ULONG ulIndex;
    PAL_ULONG palentry;
    PBYTE gTmp;

// Generate 256 (= 8*8*4) RGB combinations to fill
// in the palette.

    BYTE red, green, blue;
    red = green = blue = 0;

    for (ulIndex = 0; ulIndex < 256; ulIndex++)
    {
        palentry.pal.peRed = red;
        palentry.pal.peGreen = green;
        palentry.pal.peBlue = blue;
        palentry.pal.peFlags = 0;
        palentrySet(ulIndex, palentry.pal);

        if (!(red += 32))
        if (!(green += 32))
        blue += 64;
    }

    vInit256Default();

    if (gpRGBXlate == NULL)
    {
        gTmp = (PBYTE)PALLOCNOZ(32768,'bgrG');

        if (gTmp)
        {
           //
           // use InterlockedCompareExchangePointer to set
           // gpRGBXlate, so that another thread won't
           // try to do this at the same time
           //

           MakeITable(gTmp,(RGBX *)ppal->apalColor,256);

           if (InterlockedCompareExchangePointer((PVOID *)&gpRGBXlate,
                                             gTmp,
                                             NULL) != NULL)

           {
               //
               // if we failed the InterlockedCompareExchangePointer,
               // it means gpRGBXlate is already set by another thread
               // free the temp buffer here
               //

               if (gTmp)
               {
                  VFREEMEM(gTmp);
               }
           }
        }
        else
        {
           WARNING("Failed to allocate memory in  XEPALOBJ::vInit256Rainbow\n");

           // set this to NULL to be safe

           ppal->pRGBXlate = NULL;
           return;
        }
    }

    ppal->ulRGBTime = ulTime();

    ASSERTGDI(gpRGBXlate, "gpRGBXlate == NULL!\n");
    ppal->pRGBXlate = gpRGBXlate;

}

/******************************Public*Routine******************************\
* XEPALOBJ::vInit256Default
*
* Initialize 256 color palette with the default colors.
*
* History:
*  02-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInit256Default()
{
// Fill in 20 reserved colors at beginning and end.

    UINT uiIndex;

    for (uiIndex = 0; uiIndex < 10; uiIndex++)
    {
        palentrySet(uiIndex, logDefaultPal.palPalEntry[uiIndex]);
        palentrySet((ULONG)(255 - uiIndex), logDefaultPal.palPalEntry[19 - uiIndex]);
    }
}


/**************************************************************************\
* XEPALOBJ::pGetRGBXlate
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/19/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PRGB555XLATE
XEPALOBJ::pGetRGBXlate()
{
    //
    // palette semaphore?
    //

    PRGB555XLATE prgb555 = NULL;

    if (ppal != NULL)
    {
        prgb555 = ppal->pRGBXlate;

        if (
             (prgb555 == NULL) ||
             (ppal->ulRGBTime != ulTime())
           )
        {
            if (bGenColorXlate555())
            {
                prgb555 = ppal->pRGBXlate;
            }
            else
            {
                prgb555 = NULL;
            }
        }
    }
    else
    {
        WARNING("XEPALOBJ::pGetRGBXlate called with NULL ppal\n");
    }

    return(prgb555);
}




/**************************************************************************\
* XEPALOBJ::bGenColorXlate555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/
BOOL
XEPALOBJ::bGenColorXlate555()
{
    BOOL bRet = FALSE;

    //
    // allocate rgb555 xlate table if needed
    //
    if ((ppal->pRGBXlate == NULL) || (ppal->pRGBXlate == gpRGBXlate))
    {
        ppal->pRGBXlate = (PRGB555XLATE)PALLOCNOZ(32768,'bgrG');
    }

    if (ppal->pRGBXlate)
    {
        MakeITable((PIMAP)ppal->pRGBXlate,(RGBX *)apalColorGet(),cEntries());
        bRet = TRUE;
        ppal->ulRGBTime = ulTime();
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorMatch
*
* Direct from Win3.1 to you.  This function returns the best index to use
* when realizing a palette.  It also returns the error incurred with using
* that index.
*
* Converted from Win3.1 colormat.asm - the ColorMatch function
*
* The only difference is we return a 32-bit error difference, and a 32-bit
* index.  They compress both into 16-bit ax,dx.
*
* History:
*  11-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG ColorMatch(XEPALOBJ palSurf, PAL_ULONG palRGB, ULONG *pulError)
{
    if (palRGB.pal.peFlags & PC_EXPLICIT)
    {
    // Return the low word index.

        palRGB.ul &= 0x0000FFFF;

    // This is an error case Win3.1 does not test for, but we do.

        if (palRGB.ul >= palSurf.cEntries())
        {
            palRGB.ul = 0;
        }

        *pulError = 0;
        return(palRGB.ul);
    }

    if (palRGB.pal.peFlags & PC_RESERVED)
    {
        *pulError = 0x0FFFFFFF;
        return(0);
    }

    ULONG ulTemp, ulError, ulBestIndex, ulBestError;
    PAL_ULONG palTemp;

    ulBestIndex = 0;
    ulBestError = 0x0FFFFFFF;

    for (ulTemp = 0; ulTemp < palSurf.cEntries(); ulTemp++)
    {
        palTemp.ul = palSurf.ulEntryGet(ulTemp);

        if (palTemp.pal.peFlags & PC_USED)
        {
            if (!(palTemp.pal.peFlags & PC_RESERVED))
            {
                ulError = RGB_ERROR(palTemp.pal, palRGB.pal);

                if (ulError < ulBestError)
                {
                    ulBestIndex = ulTemp;
                    ulBestError = ulError;
                }

                if (ulBestError == 0)
                    break;
            }
        }
    }

    if (palRGB.pal.peFlags & PC_NOCOLLAPSE)
    {
    // He doesn't really want to match, so give it a big error.

        *pulError = 0x0FFFFFFF;
    }
    else
        *pulError = ulBestError;

    return(ulBestIndex);
}

/******************************Public*Routine******************************\
* ptransMatchAPal
*
* Direct from Win3.1 to you.  Builds a foreground translate just like Windows
* does.
*
* History:
*  12-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PTRANSLATE
ptransMatchAPal(
    PDC      pdc,
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    BOOL     bForeground,
    ULONG   *pulnPhysChanged,
    ULONG   *pulnTransChanged
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid DC pal");
    ASSERTGDI(palSurf.bValid(), "ERROR invalid Surface pal");
    ASSERTGDI(!palDC.bIsPalDefault(), "ERROR ptransMapIn default palette");
    ASSERTGDI(palSurf.cEntries() == 256, "Error: dinky palette in");
    ASSERTGDI(palDC.bIsPalDC(), "Error: palDC is not a DC");
    ASSERTGDI(*pulnPhysChanged == 0, "ERROR 1349456 ptransMapIn");
    ASSERTGDI(*pulnTransChanged == 0, "ERROR not 0");

    //
    // Determine how many entries are reserved
    //

    ULONG ulReserved;

    if (palSurf.bIsNoStatic())
    {
        ulReserved = 1;
    }
    else if (palSurf.bIsNoStatic256())
    {
        ulReserved = 0;
    }
    else
    {
        ulReserved = palSurf.ulNumReserved() >> 1;
    }

    ULONG ulStartFill = ulReserved;
    ULONG ulMaxInsert = 256 - ulReserved;
    PAL_ULONG palLog, palPhys;
    ULONG ulTemp;
    ULONG iInsertIndex, iLogPal;
    ULONG nPhysChanged = 0;
    ULONG nTransChanged = 0;

    //
    // We allocate the vector that converts logical palette indices to physical
    // palette indices.  Note we subtract out the extra ULONG at compile time
    // rather than run-time.
    //

    PTRANSLATE pTrans = (PTRANSLATE)
            PALLOCNOZ((sizeof(TRANSLATE) - sizeof(BYTE)) +
                       (palDC.cEntries() * sizeof(BYTE)), 'laPG');

    if (pTrans == NULL)
    {
        WARNING("Allocation for pTransMapIn failed\n");
        return(NULL);
    }

    nTransChanged = palDC.cEntries();

    if (bForeground)
    {
        //
        // This is a foreground realize. Clear all PC_FOREGROUND and PC_RESERVED
        // flags in the non-reserved entries of the surface palette.
        //

        //
        // Update the time because we are removing foreground entries.
        //

        palSurf.vUpdateTime();

        //
        // match_fore_pal:
        //

        for (ulTemp = ulReserved; ulTemp < ulMaxInsert; ulTemp++)
        {
            palPhys.ul = palSurf.ulEntryGet(ulTemp);
            
            // WINBUG #2621 5-4-2000 bhouse Foreground realization does not match Win9X

            // We now clear PC_USED thus allowing us to match Win9X palette realization
            // behavior.  Note, we really should not clear PC_USED if we are in a WOW
            // thread but have decided it is not necessary to maintain WOW compat.

            palPhys.pal.peFlags &= (~(PC_FOREGROUND | PC_RESERVED | PC_USED));
            palSurf.ulEntrySet(ulTemp, palPhys.ul);
        }
    }

    BYTE fNotOverwritable = PC_FOREGROUND | PC_USED;

    //
    // match_back_loop:
    //

    for (iLogPal = 0; iLogPal < palDC.cEntries(); iLogPal++)
    {
        palLog.ul = palDC.ulEntryGet(iLogPal);

        iInsertIndex = ColorMatch(palSurf, palLog, &ulTemp);

        if (ulTemp == 0)
        {
            //
            // Awesome, nothing to change.
            //

            if (!(palLog.pal.peFlags & PC_EXPLICIT))
            {
                //
                // Mark it used if not PC_EXPLICIT log pal entry.
                //

                palPhys.ul = palSurf.ulEntryGet(iInsertIndex);
                palPhys.pal.peFlags |= (PC_USED | PC_FOREGROUND);
                palSurf.ulEntrySet(iInsertIndex, palPhys.ul);
            }
        }
        else
        {
            //
            // imperfect_match:
            //

            if (ulStartFill || palSurf.bIsNoStatic256())
            {
                //
                // There is room to jam in an entry.
                //
                //  look_for_overwrite:
                //

look_for_overwriteable_loop:

                for (ulTemp = ulStartFill; ulTemp < ulMaxInsert; ulTemp++)
                {
                    palPhys.ul = palSurf.ulEntryGet(ulTemp);

                    if (!(palPhys.pal.peFlags & fNotOverwritable))
                    {
                        //
                        // replace_opening:
                        //

                        iInsertIndex = ulStartFill = ulTemp;  // New start point for search.
                        palLog.pal.peFlags |= (PC_USED | PC_FOREGROUND);
                        palSurf.ulEntrySet(ulTemp, palLog.ul);
                        nPhysChanged++;
                        goto entry_back_matched;
                    }
                }

                if (fNotOverwritable & PC_USED)
                {
                    //
                    // Can't be so picky, kick out used entries.
                    //

                    fNotOverwritable &= (~PC_USED);
                    ulStartFill = ulReserved;
                    goto look_for_overwriteable_loop;
                }
                else
                {
                    //
                    // all_filled_for_back:
                    //

                    ulStartFill = 0;
                }
            }
        }

entry_back_matched:

        pTrans->ajVector[iLogPal] = (BYTE) iInsertIndex;
    }

    //
    // finished_back_match
    //

    palDC.vUpdateTime();
    pTrans->iUniq = palSurf.ulTime();
    *pulnPhysChanged = nPhysChanged;
    *pulnTransChanged = nTransChanged;
    return(pTrans);
}

/******************************Public*Routine******************************\
* vMatchAPal
*
* This maps the foreground realization into the palette.
*
* History:
*  23-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
vMatchAPal(
    PDC      pdc,
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG   *pulnPhysChanged,
    ULONG   *pulnTransChanged
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid DC pal");
    ASSERTGDI(palSurf.bValid(), "ERROR invalid Surface pal");
    ASSERTGDI(!palDC.bIsPalDefault(), "ERROR ptransMapIn default palette");
    ASSERTGDI(palSurf.cEntries() == 256, "Error: dinky palette in");
    ASSERTGDI(palDC.bIsPalDC(), "Error: palDC is not a DC");
    ASSERTGDI(*pulnPhysChanged == 0, "ERROR 1349456 ptransMapIn");
    ASSERTGDI(*pulnTransChanged == 0, "ERROR not 0");

    //
    // Determine how many entries are reserved
    //

    ULONG ulReserved;

    if (palSurf.bIsNoStatic())
    {
        ulReserved = 1;
    }
    else if (palSurf.bIsNoStatic256())
    {
        ulReserved = 0;
    }
    else
    {
        ulReserved = palSurf.ulNumReserved() >> 1;
    }

    ULONG ulMaxInsert = 256 - ulReserved;
    PAL_ULONG palLog, palPhys;
    ULONG iLogPal;
    ULONG nPhysChanged = 0;
    ULONG nTransChanged = 0;

    PTRANSLATE pTransFore = palDC.ptransFore();
    PTRANSLATE pTransCur  = palDC.ptransCurrent();

    ASSERTGDI(pTransFore != NULL, "ERROR this NULL");

    //
    // un_use_palette_loop: Remove all foreground and reserved flags.
    //

    for (iLogPal = ulReserved; iLogPal < ulMaxInsert; iLogPal++)
    {
        palPhys.ul = palSurf.ulEntryGet(iLogPal);

        palPhys.pal.peFlags &= (~(PC_FOREGROUND | PC_RESERVED));
        palSurf.ulEntrySet(iLogPal, palPhys.ul);
    }

    for (iLogPal = 0; iLogPal < palDC.cEntries(); iLogPal++)
    {
        //
        // slam_foreground_palette_loop
        //

        if ((pTransCur == NULL) ||
            (pTransCur->ajVector[iLogPal] != pTransFore->ajVector[iLogPal]))
        {
            nTransChanged++;
        }

        //
        // fore_no_trans_change:
        //

        palPhys.ul = palSurf.ulEntryGet(pTransFore->ajVector[iLogPal]);

        if (!(palPhys.pal.peFlags & PC_FOREGROUND))
        {
            //
            // Index is not foreground, we have to at least mark it.
            //

            palLog.ul = palDC.ulEntryGet(iLogPal);

            if (!(palLog.pal.peFlags & PC_EXPLICIT))
            {
                //
                // Not explicit, we better make sure it's the same entry.
                //

                if ((palLog.pal.peRed   != palPhys.pal.peRed)   ||
                    (palLog.pal.peGreen != palPhys.pal.peGreen) ||
                    (palLog.pal.peBlue  != palPhys.pal.peBlue)  ||
                    ((palLog.pal.peFlags & PC_RESERVED) != (palPhys.pal.peFlags & PC_RESERVED)))
                {
                    //
                    // Not the same as logical palette, stick it in the palette.
                    //

                    palLog.pal.peFlags &= PC_RESERVED;
                    palPhys.ul = palLog.ul;
                    nPhysChanged++;
                }
            }

            //
            // fore_entry_slammed
            //

            palPhys.pal.peFlags |= (PC_FOREGROUND | PC_USED);

            palSurf.ulEntrySet((ULONG) pTransFore->ajVector[iLogPal], palPhys.ul);
        }
    }

    //
    // Increment the palette's time, we changed removed the foreground flags.
    //

    palSurf.vUpdateTime();
    palDC.vUpdateTime();
    pTransFore->iUniq = palSurf.ulTime();
    *pulnPhysChanged = nPhysChanged;
    *pulnTransChanged = nTransChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\patblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: patblt.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with solid color and patterns.
*
* Created: 03-Mar-1991 22:01:14
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// The amount to shift cx and xDstStart left by

ULONG aulShiftFormat[7] =
{
    0,  // BMF_DEVICE
    0,  // BMF_1BPP
    2,  // BMF_4BPP
    3,  // BMF_8BPP
    4,  // BMF_16BPP
    0,  // BMF_24BPP
    5   // BMF_32BPP
};

PFN_PATBLT apfnPatBlt[][3] =
{
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 }
};

ULONG aulMulFormat[] =
{
    0,   // BMF_DEVICE
    0,   // BMF_1BPP
    0,   // BMF_4BPP
    1,   // BMF_8BPP
    2,   // BMF_16BPP
    3,   // BMF_24BPP
    4    // BMF_32BPP
};

/******************************Public*Routine******************************\
* vDIBSolidBlt
*
* This does solid color and DstInvert blts.
*
* History:
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Improved it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vDIBSolidBlt(
SURFACE    *pSurfDst,
RECTL     *prclDst,
CLIPOBJ   *pco,
ULONG      iColor,    // the index to use for color.
BOOL       bInvert)
{
    PFN_SOLIDBLT pfnDibSolid;
    ULONG        cShift;       // Shift by this for format conversion
    ULONG        ircl;
    PBYTE        pjDstBits;
    LONG         lDeltaDst;
    BOOL         bMore = FALSE;
    BOOL         bClip = FALSE;
    CLIPENUMRECT clenr;

    //ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibSo");

// Set ircl to be the format of the dst surface.

    ircl = pSurfDst->iFormat();

// Assert the world is in order for our switch

    ASSERTGDI((ircl >= BMF_1BPP) && (ircl <= BMF_32BPP), "ERROR GDI vDibPatBlt");

// Set up cShift, pfnDibSolid, and iColor.

    cShift = aulShiftFormat[ircl];

    if (bInvert)
    {
        if (ircl == BMF_24BPP)
            pfnDibSolid = vSolidXorRect24;
        else
            pfnDibSolid = vSolidXorRect1;
    }
    else
    {
        if (ircl == BMF_24BPP)
            pfnDibSolid = vSolidFillRect24;
        else
            pfnDibSolid = vSolidFillRect1;
    }

// Note cascaded fall through on switch to build up iColor.
// Also note that 24BPP doesn't change.
// Finally, note that the non-significant bits have to be masked off because
// we generate Pn in the calling routine with ~.

    switch(ircl)
    {
    case BMF_1BPP:

        if ((iColor &= 1) != 0)
            iColor = 0xFFFFFFFF;
        break;

    case BMF_4BPP:

        iColor &= 0x0F;
        iColor = iColor | (iColor << 4);

    case BMF_8BPP:

        iColor &= 0xFF;
        iColor = iColor | (iColor << 8);

    case BMF_16BPP:

        iColor &= 0xFFFF;
        iColor = iColor | (iColor << 16);
    }

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            break;
        case DC_RECT:
            bClip = TRUE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping
            break;
        case DC_COMPLEX:
            bClip = TRUE;
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,CT_RECTANGLES,CD_ANY,CLIPOBJ_ENUM_LIMIT);
            break;
        default:
            RIP("ERROR: vDIBSolidBlt - bad clipping type");
        }
    }

    pjDstBits = (PBYTE) pSurfDst->pvScan0();
    lDeltaDst = pSurfDst->lDelta();

    if (!bClip)
    {
        (*pfnDibSolid)(
                    prclDst,
                    1,
                    pjDstBits,
                    lDeltaDst,
                    iColor,
                    cShift);
    }
    else
        do
        {
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;

                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;

                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;

                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

            // We check for NULL or inverted rectanges because we may get them.

                if ((prcl->top < prcl->bottom) &&
                    (prcl->left < prcl->right))
                {
                    (*pfnDibSolid)(
                                    prcl,
                                    1,
                                    pjDstBits,
                                    lDeltaDst,
                                    iColor,
                                    cShift);
                }

            }
        } while (bMore);
}

/******************************Public*Routine******************************\
* vDIBPatBlt
*
* This does pattern blts
*
* History:
*  20-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vDIBPatBlt(
SURFACE    *pSurfDst,
CLIPOBJ   *pco,
RECTL     *prclDst,
BRUSHOBJ  *pbo,
POINTL    *pptlBrush,
ULONG      iMode)
{
    PFN_PATBLT   pfnPat;
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    ULONG        ircl;
    BOOL         bMore = FALSE;
    BOOL         bClip = FALSE;

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

// Set ircl to be the format of the dst surface.

    ircl = pSurfDst->iFormat();

// Assert the world is in order for our switch

    ASSERTGDI((ircl >= BMF_1BPP) && (ircl <= BMF_32BPP), "ERROR GDI vDibPatBlt");

// Set up pfnPat and cMul.

    pfnPat = apfnPatBlt[ircl][iMode];
    pbf.cMul = aulMulFormat[ircl];

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            break;
        case DC_RECT:
            bClip = TRUE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping
            break;
        case DC_COMPLEX:
            bClip = TRUE;
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,CT_RECTANGLES,CD_ANY,CLIPOBJ_ENUM_LIMIT);
            break;
        default:
            RIP("ERROR: vDibPatBlt - bad clipping type");
        }
    }

    pbf.pvTrg     = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat     = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;
    pbf.lDeltaPat = ((EBRUSHOBJ *) pbo)->pengbrush()->lDeltaPat;
    pbf.cxPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cxPat * pbf.cMul;
    pbf.cyPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cyPat;
    pbf.xPat      = pptlBrush->x * pbf.cMul;
    pbf.yPat      = pptlBrush->y;

    if (!bClip)
    {
        pbf.pvObj = (PVOID) prclDst;
        (*pfnPat)(&pbf);
    }
    else
        do
        {
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;

                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;

                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;

                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

            // We check for NULL or inverted rectanges because we may get them.

                if ((prcl->top < prcl->bottom) &&
                    (prcl->left < prcl->right))
                {
                    pbf.pvObj = (PVOID) prcl;
                    (*pfnPat)(&pbf);
                }
            }
        } while (bMore);
}

/******************************Public*Routine******************************\
* vDIBPatBltSrccopy8x8
*
* This does only SRCCOPY blts of 8x8 patterns to DIBs.
* lDelta for the pattern must be exactly # of bytes per pixel * 8.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vDIBPatBltSrccopy8x8(
SURFACE    *pSurfDst,
CLIPOBJ   *pco,
RECTL     *prclDst,
BRUSHOBJ  *pbo,
POINTL    *pptlBrush,
PFN_PATBLT2 pfnPat)
{
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    BOOL         bMore;
    PRECTL       prcl;
    INT          ircl;

// Assert this is the right sort of destination

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

    pbf.pvTrg = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;
    pbf.lDeltaPat = ((EBRUSHOBJ *) pbo)->pengbrush()->lDeltaPat;

    //
    // Force the X and Y pattern origin coordinates into the ranges 0-7 and 0-7,
    // so we don't have to do modulo arithmetic all over again at a lower level
    //

    pbf.xPat = pptlBrush->x & 0x07;
    pbf.yPat = pptlBrush->y & 0x07;

    if (pco == (CLIPOBJ *) NULL)
    {

    // Unclipped

        pbf.pvObj = (PVOID) prclDst;
        pfnPat(&pbf, 1);
        return;
    }
    else
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:                    // unclipped

            pbf.pvObj = (PVOID) prclDst;
            pfnPat(&pbf, 1);
            return;

        case DC_RECT:                       // rectangle clipped

            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping

        // Clip the destination rectangle to the clip rectangle; it's
        // guaranteed that the resulting rectangle will never be null

            if (clenr.arcl[0].left <= prclDst->left)
                clenr.arcl[0].left = prclDst->left;

            if (clenr.arcl[0].right >= prclDst->right)
                clenr.arcl[0].right = prclDst->right;

            if (clenr.arcl[0].top <= prclDst->top)
                clenr.arcl[0].top = prclDst->top;

            if (clenr.arcl[0].bottom >= prclDst->bottom)
                clenr.arcl[0].bottom = prclDst->bottom;

            if ((clenr.arcl[0].left < clenr.arcl[0].right) &&
                (clenr.arcl[0].top  < clenr.arcl[0].bottom))
            {
                pbf.pvObj = (PVOID) clenr.arcl;
                pfnPat(&pbf, 1);
            }

            return;

        case DC_COMPLEX:                // complex region clipped

            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,
                                           CT_RECTANGLES,
                                           CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);

            do
            {

            // Get the next batch of rectangles in the clip region

                bMore =
                    ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            // If there are any rectangles in this enumeration, clip the
            // destination rectangle to each clip region rectangle, then
            // fill all the rectangles at once

                if (clenr.c > 0)
                {

                // Clip the rectangles

                    for (ircl = 0, prcl = clenr.arcl; ircl < (INT) clenr.c;
                            ircl++, prcl++)
                    {
                        if (prcl->left < prclDst->left)
                            prcl->left = prclDst->left;

                        if (prcl->right > prclDst->right)
                            prcl->right = prclDst->right;

                        if (prcl->top < prclDst->top)
                            prcl->top = prclDst->top;

                        if (prcl->bottom > prclDst->bottom)
                            prcl->bottom = prclDst->bottom;

                        //
                        // make sure rectangle is not inverted,
                        // this can happen for single scan line
                        // clip regions clipped to dst. If found,
                        // set to NULL rectangle
                        //

                        if (prcl->right < prcl->left)
                        {
                            prcl->right = prcl->left;
                        }

                        if (prcl->bottom < prcl->top)
                        {
                            prcl->bottom = prcl->top;
                        }

                    }

                // Draw the rectangles

                    pbf.pvObj = (PVOID) clenr.arcl;
                    pfnPat(&pbf, (INT) clenr.c);
                }

            } while (bMore);

            return;

        default:
            RIP("ERROR: vDIBPatBltSrccopy8x8 - bad clipping type");
        }
    }
}

/******************************Public*Routine******************************\
* vDIBnPatBltSrccopy6x6
*
* This does SRCCOPY pattern blts to 6x6 4-bpp DIBs and 1-bpp DIBs.
* lDelta for the pattern must be exactly 6 pixels (4 bytes).
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
*
*  17-Nov-1992 -by- Stephen Estrop [StephenE]
* Made it take a pointer to a
\**************************************************************************/

VOID vDIBnPatBltSrccopy6x6(
SURFACE              *pSurfDst,
CLIPOBJ             *pco,
RECTL               *prclDst,
BRUSHOBJ            *pbo,
POINTL              *pptlBrush,
PFN_PATBLT2 pfnPatBlt)
{
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    BOOL         bMore;
    PRECTL       prcl;
    ULONG        ircl;

// Assert this is the right sort of destination

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

    pbf.pvTrg = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;

// Force the X and Y pattern origin coordinates into the ranges 0-5 and 0-5,
// so we don't have to do modulo arithmetic all over again at a lower level

    if (pptlBrush->x >= 0)
        pbf.xPat = pptlBrush->x % 0x06;
    else
        pbf.xPat = (6 - 1) - ((-pptlBrush->x - 1) % 6);

    if (pptlBrush->y >= 0)
        pbf.yPat = pptlBrush->y % 0x06;
    else
        pbf.yPat = (6 - 1) - ((-pptlBrush->y - 1) % 6);

    if (pco == (CLIPOBJ *) NULL)
    {

    // Unclipped

        pbf.pvObj = (PVOID) prclDst;
        (*pfnPatBlt)(&pbf, 1);
        return;
    }
    else
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:                    // unclipped

            pbf.pvObj = (PVOID) prclDst;
            (*pfnPatBlt)(&pbf, 1);
            return;

        case DC_RECT:                       // rectangle clipped

            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping

        // Clip the destination rectangle to the clip rectangle

            if (clenr.arcl[0].left <= prclDst->left)
                clenr.arcl[0].left = prclDst->left;

            if (clenr.arcl[0].right >= prclDst->right)
                clenr.arcl[0].right = prclDst->right;

            if (clenr.arcl[0].top <= prclDst->top)
                clenr.arcl[0].top = prclDst->top;

            if (clenr.arcl[0].bottom >= prclDst->bottom)
                clenr.arcl[0].bottom = prclDst->bottom;

            if ((clenr.arcl[0].left < clenr.arcl[0].right) &&
                (clenr.arcl[0].top  < clenr.arcl[0].bottom))
            {
                pbf.pvObj = (PVOID) clenr.arcl;
                (*pfnPatBlt)(&pbf, 1);
            }

            return;

        case DC_COMPLEX:                // complex region clipped

            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,
                                           CT_RECTANGLES,
                                           CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);

            do
            {

            // Get the next batch of rectangles in the clip region

                bMore =
                    ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            // If there are any rectangles in this enumeration, clip the
            // destination rectangle to each clip region rectangle, then
            // fill all the rectangles at once

                if (clenr.c > 0)
                {

                // Clip the rectangles

                    for (ircl = 0, prcl = clenr.arcl; ircl < clenr.c;
                            ircl++, prcl++)
                    {
                        if (prcl->left < prclDst->left)
                            prcl->left = prclDst->left;

                        if (prcl->right > prclDst->right)
                            prcl->right = prclDst->right;

                        if (prcl->top < prclDst->top)
                            prcl->top = prclDst->top;

                        if (prcl->bottom > prclDst->bottom)
                            prcl->bottom = prclDst->bottom;
                    }

                // Draw the rectangles

                    pbf.pvObj = (PVOID) clenr.arcl;
                    (*pfnPatBlt)(&pbf, clenr.c);
                }

            } while (bMore);

            return;

        default:
            RIP("ERROR: vDIBnSrccopyPatBlt - bad clipping type");
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\panning.cxx ===
/******************************Module*Header*******************************\
* Module Name: panning.cxx
*
* Contains the code for a layered 'virtual' driver that emulates panning
* by switching the display device to the requested panning dimensions, and
* creating a shadow buffer the size of the desktop to which GDI does all
* the drawing.  To update the physical display, we employ a 'dirty
* rectangles' technique where we simply blt from the shadow buffer to the
* screen for the affected areas.
*
* Created: 15-Sep-96
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern BOOL G_fDoubleDpi;

// The panning layer's equivalent of a 'PDEV':

typedef struct _PANDEV
{
    LONG        cxScreen;           // The smaller dimensions (the dimensions of
    LONG        cyScreen;           //   the physical screen)
    LONG        cxDesktop;          // The larger dimensions (the dimensions of
    LONG        cyDesktop;          //   the virtual desktop)
    RECTL       rclVisible;         // Position of panning window on virtual
                                    //   desktop
    DHPDEV      dhpdevDevice;       // The device's 'dhpdev'
    ULONG       iBitmapFormat;      // Bitmap format of surface
    FLONG       flOriginalCaps;     // Driver's original flGraphicsCaps setting
    HDEV        hdev;               // Handle to GDI's PDEV
    HSURF       hsurfScreen;        // Handle to GDI's surface
    SURFOBJ*    psoShadow;          // Pointer to our shadow surface
    SURFOBJ*    psoDevice;          // Pointer to device's surface
    SURFOBJ*    psoShrink;          // Pointer to shrink scratch buffer surface
    REGION*     prgnDirty;          // Points to the current dirty region
    REGION*     prgnOld;            // Points to the previous dirty region
    REGION*     prgnRect;           // Points to a rectangular region we cache
    BOOL        bDirty;             // If TRUE, we have some dirty rectangles
                                    //   that should be updated at the next tick
    PFN         apfn[INDEX_LAST];   // Dispatch table to device
} PANDEV;

/******************************Public*Routine******************************\
* VOID vPanningUpdate(ppan, prcl, pco)
*
* Updates the screen from the DIB surface for the given rectangle.
*
\**************************************************************************/

VOID vPanningUpdate(PANDEV* ppan, RECTL* prcl, CLIPOBJ* pco)
{
    RECTL rcl;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        rcl = *prcl;
    }
    else
    {
        // We may as well save ourselves some blting by clipping to
        // the clip object's maximum extent.  The clip object's bounds
        // are guaranteed to be contained within the dimensions of the
        // desktop:

        rcl.left   = max(pco->rclBounds.left,   prcl->left);
        rcl.top    = max(pco->rclBounds.top,    prcl->top);
        rcl.right  = min(pco->rclBounds.right,  prcl->right);
        rcl.bottom = min(pco->rclBounds.bottom, prcl->bottom);
    }

    if (ppan->psoShrink)
    {
        rcl.left >>= 1;
        rcl.top  >>= 1;
        rcl.right  = (rcl.right + 1) >> 1;
        rcl.bottom = (rcl.bottom + 1) >> 1;
    }

    if ((rcl.left < rcl.right) && (rcl.top < rcl.bottom))
    {
        // Merge this rectangle into the dirty region.  We swap the 'old'
        // and 'current' dirty regions in the process, so that we don't
        // have to do an extra allocation:
    
        RGNOBJ roRect(ppan->prgnRect);
        RGNOBJ roDirty(ppan->prgnOld);
        RGNOBJ roOld(ppan->prgnDirty);
    
        roRect.vSet(&rcl);
        if (!roDirty.bMerge(roOld, roRect, gafjRgnOp[RGN_OR]))
        {
            roDirty.vSet();
        }
    
        ppan->prgnOld   = roOld.prgnGet();
        ppan->prgnDirty = roDirty.prgnGet();
        ppan->bDirty    = TRUE;
    }
}

/******************************Public*Routine******************************\
* vFiltered2xShrinkRectangle32bpp
*
* Quick and dirty single rectangle 0.5x shrink with simple color averaging.
*
\**************************************************************************/

VOID vFilteredShrinkRectangle2x32bpp(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    RECTL*      prclDst)
{
    LONG        cx;
    LONG        cy;
    LONG        lSrcDelta;
    BYTE*       pjSrc;
    LONG        lSrcSkip;
    LONG        lDstDelta;
    BYTE*       pjDst;
    LONG        lDstSkip;
    LONG        i;
    ULONG       ulDst;

    ASSERTGDI((psoDst->iBitmapFormat == BMF_32BPP) &&
              (psoSrc->iBitmapFormat == BMF_32BPP),
        "Unexpected type");

    cy = prclDst->bottom - prclDst->top;
    cx = prclDst->right - prclDst->left;

    lSrcDelta = psoSrc->lDelta;
    pjSrc = (BYTE*) psoSrc->pvScan0 + (prclDst->top * 2) * lSrcDelta
                                    + (prclDst->left * 2) * sizeof(ULONG);
    lSrcSkip = 2 * lSrcDelta - (cx * 2 * sizeof(ULONG));

    lDstDelta = psoDst->lDelta;
    pjDst = (BYTE*) psoDst->pvScan0 + prclDst->top * lDstDelta
                                    + prclDst->left * sizeof(ULONG);
    lDstSkip = lDstDelta - (cx * sizeof(ULONG));

    do {
        i = cx;
        do {
            ulDst = *(pjSrc) 
                  + *(pjSrc + 4) 
                  + *(pjSrc + lSrcDelta) 
                  + *(pjSrc + 4 + lSrcDelta);

            *(pjDst) = (BYTE) (ulDst >> 2);

            ulDst = *(pjSrc + 1) 
                  + *(pjSrc + 5) 
                  + *(pjSrc + 1 + lSrcDelta) 
                  + *(pjSrc + 5 + lSrcDelta);

            *(pjDst + 1) = (BYTE) (ulDst >> 2);

            ulDst = *(pjSrc + 2) 
                  + *(pjSrc + 6) 
                  + *(pjSrc + 2 + lSrcDelta) 
                  + *(pjSrc + 6 + lSrcDelta);

            *(pjDst + 2) = (BYTE) (ulDst >> 2);

            pjDst += 4;
            pjSrc += 8;

        } while (--i != 0);

        pjDst += lDstSkip;
        pjSrc += lSrcSkip;

    } while (--cy != 0);
}

/******************************Public*Routine******************************\
* vFiltered2xShrink32bpp
*
* Quick and dirty bilinear filtered 2x shrink routine.
*
\**************************************************************************/

VOID vFilteredShrink2x32bpp(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    ECLIPOBJ*   pco,
    RECTL*      prclDst)
{
    BOOL            bMore;
    ULONG           i;
    CLIPENUMRECT    clenr;
    RECTL           rclDst;

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do {
        bMore = pco->bEnum(sizeof(clenr), &clenr);

        for (i = 0; i < clenr.c; i++)
        {
            if (bIntersect(&clenr.arcl[i], prclDst, &rclDst))
            {
                vFilteredShrinkRectangle2x32bpp(psoDst, psoSrc, &rclDst);
            }
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* PanSynchronize
*
* Dumps the list of dirty rectangles to the screen.  Because we set
* GCAPS2_SYNCTIMER, this routine is called by User 20 times a second.
*
\**************************************************************************/

VOID PanSynchronize(
DHPDEV  dhpdev,
RECTL*  prcl)
{
    PANDEV*             ppan;
    SURFACE*            psurfDevice;
    RECTL*              prclVisible;
    RECTL               rclDevice;
    RECTL               rclSrc;
    PFN_DrvCopyBits     pfnCopyBits;
    PFN_DrvStretchBlt   pfnStretchBlt;
    SURFOBJ*            psoCopySrc;
    SURFOBJ*            psoDst;
    SURFOBJ*            psoDevice;

    ppan = (PANDEV*) dhpdev;
    if (ppan->bDirty)
    {
        ECLIPOBJ eco;
        
        ASSERTGDI((ppan->rclVisible.right == ppan->rclVisible.left + ppan->cxScreen) &&
                  (ppan->rclVisible.bottom == ppan->rclVisible.top + ppan->cyScreen),
                  "Unexpected rclVisible dimensions");

        prclVisible = &ppan->rclVisible;

        eco.vSetup(ppan->prgnDirty, *(ERECTL*)prclVisible);
        if (!eco.erclExclude().bEmpty())
        {
            // Now reset the device surface 'dhpdev' field that the any device's
            // EngAssociateSurface call so rudely overwrote with the pointer
            // to *our* 'ppan' structure!

            ppan->psoDevice->dhpdev = ppan->dhpdevDevice;

            psurfDevice = SURFOBJ_TO_SURFACE(ppan->psoDevice);

            rclDevice.left   = 0;
            rclDevice.top    = 0;
            rclDevice.right  = psurfDevice->sizl().cx;
            rclDevice.bottom = psurfDevice->sizl().cy;

            // Assume we'll be calling CopyBits straight from the shadow
            // buffer:

            psoCopySrc = ppan->psoShadow;

            if (ppan->psoShrink)
            {
                ASSERTGDI(ppan->iBitmapFormat == BMF_32BPP,
                    "Expected psoShrink only when 32bpp");

                // As a small optimization, we can draw directly to the
                // frame buffer (and bypass the shrink buffer) if the primary 
                // surface was created as a GDI-managed surface:

                if (psurfDevice->iType() == STYPE_BITMAP)
                {
                    psoDst = psurfDevice->pSurfobj();
                    psoCopySrc = NULL;
                }
                else
                {
                    psoDst = ppan->psoShrink;
                    psoCopySrc = ppan->psoShrink;
                }

                vFilteredShrink2x32bpp(psoDst,
                                       ppan->psoShadow,
                                       &eco,
                                       &rclDevice);
            }

            if (psoCopySrc)
            {
                // Call the device's DrvCopyBits routine to do the copy (noting that
                // if it's an engine managed surface, we may have to call EngCopyBits):
    
                pfnCopyBits = (psurfDevice->flags() & HOOK_COPYBITS)
                            ? PPFNTABLE(ppan->apfn, CopyBits)
                            : EngCopyBits;
            
                (*pfnCopyBits)(psurfDevice->pSurfobj(),
                               psoCopySrc,
                               &eco,
                               NULL,
                               &rclDevice,
                               (POINTL*) prclVisible);
            }
        }

        // Mark the fact that we have no dirty rectangles, and clear the
        // dirty region:

        ppan->bDirty = FALSE;

        RGNOBJ ro(ppan->prgnDirty);
        ro.vSet();
    }
}

/******************************Public*Routine******************************\
* PanStrokePath
*
\**************************************************************************/

BOOL PanStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL    b;
    PANDEV* ppan;
    RECTFX  rcfxBounds;
    RECTL   rclBounds;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngStrokePath(ppan->psoShadow, ppo, pco, pxo, pbo, pptlBrush, pla, mix);

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    vPanningUpdate(ppan, &rclBounds, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanTransparentBlt
*
\**************************************************************************/

BOOL PanTransparentBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
RECTL*      prclSrc,
ULONG       iTransColor,
ULONG       ulReserved)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngTransparentBlt(ppan->psoShadow, psoSrc, pco, pxlo, prclDst,
                          prclSrc, iTransColor, ulReserved);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanAlphaBlend
*
\**************************************************************************/

BOOL PanAlphaBlend(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
BLENDOBJ*           pBlendObj)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngAlphaBlend(ppan->psoShadow, psoSrc, pco, pxlo, prclDst,
                      prclSrc, pBlendObj);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanGradientFill
*
\**************************************************************************/

BOOL PanGradientFill(
SURFOBJ*            pso,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
TRIVERTEX*          pVertex,
ULONG               nVertex,
PVOID               pMesh,
ULONG               nMesh,
RECTL*              prclExtents,
POINTL*             pptlDitherOrg,
ULONG               ulMode)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngGradientFill(ppan->psoShadow, pco, pxlo, pVertex, nVertex, pMesh,
                        nMesh, prclExtents, pptlDitherOrg, ulMode);

    vPanningUpdate(ppan, prclExtents, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanStretchBlt
*
\**************************************************************************/

BOOL PanStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngStretchBlt(ppan->psoShadow, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMsk, iMode);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanBitBlt
*
\**************************************************************************/

BOOL PanBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL    bUpdate;
    BOOL    b;
    PANDEV* ppan;

    bUpdate = FALSE;
    if (psoDst->iType == STYPE_DEVICE)
    {
        bUpdate = TRUE;
        ppan    = (PANDEV*) psoDst->dhpdev;
        psoDst  = ppan->psoShadow;
    }
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ppan    = (PANDEV*) psoSrc->dhpdev;
        psoSrc  = ppan->psoShadow;
    }

    b = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc,
                  pptlMask, pbo, pptlBrush, rop4);

    if (bUpdate)
    {
        vPanningUpdate(ppan, prclDst, pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* PanCopyBits
*
\**************************************************************************/

BOOL PanCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL    bUpdate;
    BOOL    b;
    PANDEV* ppan;

    return(PanBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc,
                     NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* PanTextOut
*
\**************************************************************************/

BOOL PanTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngTextOut(ppan->psoShadow, pstro, pfo, pco, prclExtra, prclOpaque,
                   pboFore, pboOpaque, pptlOrg, mix);

    vPanningUpdate(ppan,
                   (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                   pco);

    return(b);
}

/******************************Public*Routine******************************\
* VOID PanMovePointer
*
\**************************************************************************/

VOID PanMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PANDEV*             ppan;
    BOOL                bUpdate;
    PFN_DrvMovePointer  pfnMovePointer;

    ppan = (PANDEV*) pso->dhpdev;

    // A negative 'y' coordinate indicates a positional notification.
    // Use this to move the panning coordinates if need be:

    ASSERTGDI((y < 0) && (x >= 0), "Unexpected coordinates");

    // It's weird, but the display driver may actually be panning
    // underneath our virtual panning display driver!  (This will
    // only happen when all the video driver's accelerations are
    // disabled.)

    pfnMovePointer = PPFNTABLE(ppan->apfn, MovePointer);
    if ((pfnMovePointer != NULL) &&
        (ppan->flOriginalCaps & GCAPS_PANNING))
    {
        (*pfnMovePointer)(ppan->psoDevice,
                          x,
                          y,
                          prcl);
    }

    // Adjust to positive space:

    y += pso->sizlBitmap.cy;

    bUpdate = FALSE;

    if (x < ppan->rclVisible.left)
    {
        ppan->rclVisible.left  = x;
        ppan->rclVisible.right = x + ppan->cxScreen;
        bUpdate = TRUE;
    }
    if (x > ppan->rclVisible.right)
    {
        ppan->rclVisible.right = x;
        ppan->rclVisible.left  = x - ppan->cxScreen;
        bUpdate = TRUE;
    }
    if (y < ppan->rclVisible.top)
    {
        ppan->rclVisible.top    = y;
        ppan->rclVisible.bottom = y + ppan->cyScreen;
        bUpdate = TRUE;
    }
    if (y > ppan->rclVisible.bottom)
    {
        ppan->rclVisible.bottom = y;
        ppan->rclVisible.top    = y - ppan->cyScreen;
        bUpdate = TRUE;
    }

    ASSERTGDI((ppan->rclVisible.left >= 0) &&
              (ppan->rclVisible.top  >= 0) &&
              (ppan->rclVisible.right  <= ppan->cxDesktop) &&
              (ppan->rclVisible.bottom <= ppan->cyDesktop),
              "unexpected pointer coordinates");

    if (bUpdate)
    {
        // The panning coordinates changed, so update the display.
        //
        // NOTE: A screen-to-screen blt could be done as an optimization.

        vPanningUpdate(ppan,
                       &ppan->rclVisible,
                       NULL);
    }

    // Flush anything pending.  We do this for a couple of reasons:
    //
    //    1. To flush the vPanningUpdate we may have just done;
    //    2. For smoother mouse movement.

    PanSynchronize((DHPDEV) ppan, NULL);
}

/******************************Public*Routine******************************\
* PanDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colors.
*
\**************************************************************************/

ULONG APIENTRY PanDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PANDEV* ppan;
    ULONG   iRet;

    ppan = (PANDEV*) dhpdev;

    // EngDitherColor supports dithers only for 8bpp and higher, so at 
    // anything lower we have to call the driver.

    if (ppan->iBitmapFormat >= BMF_8BPP)
    {
        iRet = EngDitherColor(ppan->hdev, iMode, rgb, pul);
    }
    else
    {
        iRet = PPFNTABLE(ppan->apfn, DitherColor)(ppan->dhpdevDevice, 
                                                  iMode, 
                                                  rgb, 
                                                  pul);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL PanSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL PanSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppal,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    return((*PPFNTABLE(ppan->apfn, SetPalette))(ppan->dhpdevDevice,
                                                ppal,
                                                fl,
                                                iStart,
                                                cColors));
}

/******************************Public*Routine******************************\
* VOID PanAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL PanAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PANDEV* ppan;
    BOOL    b;

    ppan = (PANDEV*) dhpdev;

    b = (*PPFNTABLE(ppan->apfn, AssertMode))(ppan->dhpdevDevice,
                                             bEnable);

    return(b);
}

/******************************Public*Routine******************************\
* DHPDEV PanEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after PanEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; PanEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV PanEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PANDEV*     ppan;
    PFN*        ppfnDevice;
    DHPDEV      dhpdevDevice;
    GDIINFO*    pGdiInfo;
    DEVMODEW    dmTmp;

    ASSERTGDI((pdm->dmPanningWidth  <= pdm->dmPelsWidth) &&
              (pdm->dmPanningHeight <= pdm->dmPelsHeight),
              "Bad devmode sizes");

    ppan = (PANDEV*) PALLOCMEM(sizeof(PANDEV), 'napG');
    if (ppan != NULL)
    {
        PPDEV ppdev = (PPDEV)hdev;

        // Snag a copy of the device's dispatch table, from
        // the private PDEV structure, which is the hdev.

        ppfnDevice = &ppdev->pldev->apfn[0];

        RtlCopyMemory(ppan->apfn, ppfnDevice, sizeof(PFN) * INDEX_LAST);

        // Remember our dimensions:

        ppan->cxDesktop = pdm->dmPelsWidth;
        ppan->cyDesktop = pdm->dmPelsHeight;

        if (pdm->dmPanningWidth != 0)
        {
            ppan->cxScreen = pdm->dmPanningWidth;
            ppan->cyScreen = pdm->dmPanningHeight;
        }
        else
        {
            ppan->cxScreen = pdm->dmPelsWidth;
            ppan->cyScreen = pdm->dmPelsHeight;
        }

        // Ask the driver to set its physical mode to the panning
        // dimensions:

        dmTmp = *pdm;
        dmTmp.dmPelsWidth  = ppan->cxScreen;
        dmTmp.dmPelsHeight = ppan->cyScreen;

        // But wait, if we're being asked to double the DPI and the
        // mode is 32bpp, drvsup.cxx already set up the Devmode so
        // that it's double the actual resolution.  That means that we
        // then have to halve the resolution that we request of the
        // driver:

        if ((G_fDoubleDpi) && (dmTmp.dmBitsPerPel == 32))
        {
            dmTmp.dmPelsWidth >>= 1;
            dmTmp.dmPelsHeight >>= 1;
        }

        dhpdevDevice = (*PPFNTABLE(ppan->apfn, EnablePDEV))
                            (&dmTmp,
                             pwszLogAddr,
                             cPat,
                             phsurfPatterns,
                             cjCaps,
                             (GDIINFO*) pdevcaps,
                             cjDevInfo,
                             pdi,
                             hdev,
                             pwszDeviceName,
                             hDriver);

        if (dhpdevDevice != NULL)
        {
            ppan->iBitmapFormat  = pdi->iDitherFormat;
            ppan->dhpdevDevice   = dhpdevDevice;
            ppan->hdev           = hdev;
            ppan->flOriginalCaps = pdi->flGraphicsCaps;

            // The display driver will have set the desktop coordinates
            // to the smaller screen coordinates, so we'll have to
            // overwrite that:

            pGdiInfo = (GDIINFO*) pdevcaps;

            pGdiInfo->ulHorzRes = ppan->cxDesktop;
            pGdiInfo->ulVertRes = ppan->cyDesktop;

            // Overwrite some of the driver's capabilities:

            pdi->flGraphicsCaps &= (GCAPS_PALMANAGED  |
                                    GCAPS_MONO_DITHER |
                                    GCAPS_COLOR_DITHER);
            pdi->flGraphicsCaps |= GCAPS_PANNING;

            // Enable synchronization calls:

            pdi->flGraphicsCaps2 = (GCAPS2_SYNCFLUSH |
                                    GCAPS2_SYNCTIMER);

            return((DHPDEV) ppan);
        }

        VFREEMEM(ppan);
    }

    return(0);
}

/******************************Public*Routine******************************\
* PanDisablePDEV
*
* Release the resources allocated in PanEnablePDEV.  If a surface has been
* enabled PanDisableSurface will have already been called.
*
\**************************************************************************/

VOID PanDisablePDEV(
DHPDEV  dhpdev)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    (*PPFNTABLE(ppan->apfn, DisablePDEV))(ppan->dhpdevDevice);

    VFREEMEM(ppan);
}

/******************************Public*Routine******************************\
* VOID PanCompletePDEV
*
\**************************************************************************/

VOID PanCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    ppan->hdev = hdev;

    (*PPFNTABLE(ppan->apfn, CompletePDEV))(ppan->dhpdevDevice,
                                           hdev);
}

/******************************Public*Routine******************************\
* HSURF PanEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after PanEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF PanEnableSurface(
DHPDEV dhpdev)
{
    PANDEV*     ppan;
    HSURF       hsurfDevice;
    HSURF       hsurfScreen;
    HSURF       hsurfShadow;
    HSURF       hsurfShrink;
    SIZEL       sizl;
    SIZEL       sizlShrink;
    SURFOBJ*    psoShadow;
    SURFOBJ*    psoDevice;
    SURFOBJ*    psoShrink;
    BOOL        bShrink;

    ppan = (PANDEV*) dhpdev;

    // Initialize the paning position:

    ppan->rclVisible.left   = (ppan->cxDesktop - ppan->cxScreen) >> 1;
    ppan->rclVisible.top    = (ppan->cyDesktop - ppan->cyScreen) >> 1;
    ppan->rclVisible.right  = (ppan->rclVisible.left + ppan->cxScreen);
    ppan->rclVisible.bottom = (ppan->rclVisible.top  + ppan->cyScreen);

    // Call the device to enable its surface:

    hsurfDevice = (*PPFNTABLE(ppan->apfn, EnableSurface))(ppan->dhpdevDevice);
    if (hsurfDevice)
    {
        psoDevice = EngLockSurface(hsurfDevice);
        if (psoDevice)
        {
            SURFACE* pDevSurface = SURFOBJ_TO_SURFACE(psoDevice);

            pDevSurface->flags(pDevSurface->flags() & ~(HOOK_SYNCHRONIZE));

            ppan->psoDevice = psoDevice;

            // Now reset the device's 'dhpdev' field that the device's
            // EngAssociateSurface call so rudely overwrote with the pointer
            // to *our* 'ppan' structure!

            psoDevice->dhpdev = ppan->dhpdevDevice;

            // Have GDI create the actual SURFOBJ.
            //
            // Our drawing surface is going to be 'device-managed', meaning
            // that GDI cannot draw on the framebuffer bits directly, and as
            // such we create the surface via EngCreateSurface.  By doing
            // this, we ensure that GDI will only ever access the bitmaps
            // bits via the Pan calls that we've HOOKed.

            sizl.cx = ppan->cxDesktop;
            sizl.cy = ppan->cyDesktop;

            hsurfScreen = EngCreateDeviceSurface(NULL,
                                                 sizl,
                                                 ppan->iBitmapFormat);
            if (hsurfScreen != 0)
            {
                ppan->hsurfScreen = hsurfScreen;

                // Now associate the surface and the PANDEV.
                //
                // We have to associate the surface we just created with our
                // physical device so that GDI can get information related to
                // the PANDEV when it's drawing to the surface (such as, for
                // example, the length of styles on the device when simulating
                // styled lines).

                if (EngAssociateSurface(hsurfScreen,
                                        ppan->hdev,
                                        (HOOK_BITBLT         |
                                         HOOK_TEXTOUT        |
                                         HOOK_COPYBITS       |
                                         HOOK_STRETCHBLT     |
                                         HOOK_ALPHABLEND     |
                                         HOOK_TRANSPARENTBLT |
                                         HOOK_GRADIENTFILL   |
                                         HOOK_STROKEPATH     |
                                         HOOK_SYNCHRONIZE)))
                {
                    // Create the shadow DIB on which we'll have GDI do all
                    // the drawing.  We'll merely occasionally blt portions
                    // to the screen to update.

                    hsurfShadow = (HSURF) EngCreateBitmap(sizl,
                                                          sizl.cx,
                                                          ppan->iBitmapFormat,
                                                          BMF_TOPDOWN,
                                                          NULL);

                    psoShadow = EngLockSurface(hsurfShadow);
                    if (psoShadow != NULL)
                    {
                        ppan->psoShadow = psoShadow;

                        // If we're doing the double-dpi thing, we need to
                        // create a scratch buffer for the shrink:

                        hsurfShrink = NULL;
                        psoShrink = NULL;
                        bShrink = ((G_fDoubleDpi) && 
                                   (ppan->iBitmapFormat == BMF_32BPP));

                        if (bShrink)
                        {
                            // Create a temporary surface used as the scratch 
                            // buffer destination for our 'shrink' blt:

                            sizlShrink.cx = sizl.cx >> 1;
                            sizlShrink.cy = sizl.cy >> 1;
    
                            hsurfShrink = (HSURF) EngCreateBitmap(sizlShrink,
                                                                  sizlShrink.cx,
                                                                  ppan->iBitmapFormat,
                                                                  BMF_TOPDOWN,
                                                                  NULL);
                            psoShrink = EngLockSurface(hsurfShrink);
                        }

                        // If shrinking and couldn't allocate 'psoShrink', 
                        // then fail:

                        if ((!bShrink) || (psoShrink != NULL))
                        {
                            ppan->psoShrink = psoShrink;

                            if (EngAssociateSurface(hsurfShadow,
                                                    ppan->hdev,
                                                    0))
                            {
                                RGNMEMOBJ rmoDirty;
                                RGNMEMOBJ rmoOld;
                                RGNMEMOBJ rmoRect;
    
                                if ((rmoOld.bValid()) && 
                                    (rmoDirty.bValid()) && 
                                    (rmoRect.bValid()))
                                {
                                    rmoDirty.vSet();
                                    rmoOld.vSet();
    
                                    ppan->prgnDirty = rmoDirty.prgnGet();
                                    ppan->prgnOld   = rmoOld.prgnGet();
                                    ppan->prgnRect  = rmoRect.prgnGet();
    
                                    // Blank the screen:
    
                                    PanSynchronize(dhpdev, NULL);
        
                                    // Success!
        
                                    return(hsurfScreen);
                                }
    
                                rmoOld.vDeleteRGNOBJ();
                                rmoDirty.vDeleteRGNOBJ();
                                rmoRect.vDeleteRGNOBJ();
                            }
                        }

                        EngUnlockSurface(psoShrink);
                        EngDeleteSurface(hsurfShrink);
                    }

                    EngUnlockSurface(psoShadow);
                    EngDeleteSurface(hsurfShadow);
                }

                EngDeleteSurface(hsurfScreen);
            }

            EngUnlockSurface(psoDevice);
        }

        (*PPFNTABLE(ppan->apfn, DisableSurface))(ppan->dhpdevDevice);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID PanDisableSurface
*
* Free resources allocated by PanEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID PanDisableSurface(
DHPDEV dhpdev)
{
    PANDEV*   ppan;
    HSURF     hsurfShadow;
    HSURF     hsurfShrink;

    ppan = (PANDEV*) dhpdev;

    RGNOBJ roDirty(ppan->prgnDirty);
    RGNOBJ roOld(ppan->prgnOld);
    RGNOBJ roRect(ppan->prgnRect);

    roOld.vDeleteRGNOBJ();
    roDirty.vDeleteRGNOBJ();
    roRect.vDeleteRGNOBJ();

    hsurfShadow = ppan->psoShadow->hsurf;
    EngUnlockSurface(ppan->psoShadow);
    EngDeleteSurface(hsurfShadow);

    if (ppan->psoShrink)
    {
        hsurfShrink = ppan->psoShrink->hsurf;
        EngUnlockSurface(ppan->psoShrink);
        EngDeleteSurface(hsurfShrink);
    }

    EngDeleteSurface(ppan->hsurfScreen);
    EngUnlockSurface(ppan->psoDevice);

    (*PPFNTABLE(ppan->apfn, DisableSurface))(ppan->dhpdevDevice);
}

/******************************Public*Structure****************************\
* DFVFN gadrvfnPanning[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

DRVFN gadrvfnPanning[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) PanEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) PanCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) PanDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) PanEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) PanDisableSurface         },
    {   INDEX_DrvDitherColor,           (PFN) PanDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) PanAssertMode             },
    {   INDEX_DrvBitBlt,                (PFN) PanBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) PanTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) PanStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) PanCopyBits               },
    {   INDEX_DrvTransparentBlt,        (PFN) PanTransparentBlt         },
    {   INDEX_DrvAlphaBlend,            (PFN) PanAlphaBlend             },
    {   INDEX_DrvGradientFill,          (PFN) PanGradientFill           },
    {   INDEX_DrvStretchBlt,            (PFN) PanStretchBlt             },
    {   INDEX_DrvSetPalette,            (PFN) PanSetPalette             },
    {   INDEX_DrvMovePointer,           (PFN) PanMovePointer            },
    {   INDEX_DrvSynchronize,           (PFN) PanSynchronize            },
};

ULONG gcdrvfnPanning = sizeof(gadrvfnPanning) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL PanEnableDriver
*
* Standard driver DrvEnableDriver function
*
\**************************************************************************/

BOOL PanEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnPanning;
    pded->c              = gcdrvfnPanning;
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pathgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathgdi.cxx
*
* Contains the path APIs.
*
* Created: 12-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "pathwide.hxx"

// Default line attributes used for WidenPath:

static LINEATTRS glaNominalGeometric =
{
    LA_GEOMETRIC,           // fl
    JOIN_ROUND,             // iJoin
    ENDCAP_ROUND,           // iEndCap
    {IEEE_0_0F},            // elWidth
    IEEE_0_0F,              // eMiterLimit
    0,                      // cstyle
    (FLOAT_LONG*) NULL,     // pstyle
    {IEEE_0_0F}             // elStyleState
};

/******************************Public*Routine******************************\
* BOOL NtGdiCloseFigure(hdc)
*
* Closes the figure in an active path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiCloseFigure(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bActive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid() || !epath.bCloseFigure())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiAbortPath(hdc)
*
* Aborts a path bracket, or discards the path from a closed path bracket.
*
* History:
*  19-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiAbortPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

// Delete the previous path if there was one:

    if (dco.hpath() != HPATH_INVALID)
    {
    // If we did a SaveDC, we don't actually have to delete the entire path:

        if (dco.pdc->bLazySave())
            dco.pdc->vClearLazySave();
        else
        {
            XEPATHOBJ epath(dco);
            ASSERTGDI(epath.bValid(), "Invalid DC path");

            epath.vDelete();
        }

        dco.pdc->vDestroy();
    }

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiBeginPath(hdc)
*
* Starts a path bracket; subsequent drawing calls are added to the path
* until GreEndPath is called.  Destroys the old one if there was one.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiBeginPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

// Delete the previous path if there was one:

    if (dco.hpath() != HPATH_INVALID)
    {
    // If we did a SaveDC, we don't actually have to delete the entire path:

        if (dco.pdc->bLazySave())
            dco.pdc->vClearLazySave();
        else
        {
            XEPATHOBJ epath(dco);
            ASSERTGDI(epath.bValid(), "Invalid DC path");

            epath.vDelete();
        }

        dco.pdc->vDestroy();
    }

// Create a new path:

    PATHMEMOBJ pmo;
    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

// Tell the path we're keeping it, store the handle in the DC, and
// set the flag that we're now accumulating a path:

    pmo.vKeepIt();
    dco.pdc->hpath(pmo.hpath());
    dco.pdc->vSetActive();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiEndPath(hdc)
*
* Ends an active path bracket.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiEndPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

    if (!dco.pdc->bActive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// Mark the path handle as no longer active:

    dco.pdc->vClearActive();

    bRet = TRUE;
    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL NtGdiFlattenPath(hdc)
*
* Flattens an inactive path.  Path must be inactive, by calling GreEndPath.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiFlattenPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid() || !epath.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    bRet = TRUE;
    return(bRet);
}


/******************************Public*Routine******************************\
* HRGN NtGdiWidenPath(hdc, pac)
*
* Widens the inactive path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiWidenPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    LINEATTRS *pla = dco.plaRealize(xfo);

    if (!(pla->fl & LA_GEOMETRIC))
    {
    // If the pen is an extended pen, it has to be geometric to be used
    // for widening.  If we have an old style pen and the transform says
    // we would normally draw it using a cosmetic pen, substitute a stock
    // solid geometric pen for it instead.  Thus if pens created via
    // CreatePen are used for the widening, we won't suddenly fail the
    // call when the transform gets small enough.

        if (!((PPEN)dco.pdc->pbrushLine())->bIsOldStylePen())
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
            return(bRet);
        }

        pla = &glaNominalGeometric;
    }

    if (!epath.bComputeWidenedBounds((XFORMOBJ *) &xfo, pla))
    {
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
        return(bRet);
    }

    if (!epath.bWiden((XFORMOBJ *) &xfo, pla))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

// The computed widened bounds were only a guess, so recompute based
// on the widened result:

    epath.vReComputeBounds();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiSelectClipPath(hdc, iMode)
*
* Selects a path as the DC clip region.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSelectClipPath(HDC hdc, int iMode)
{
    GDITraceMultiBegin("NtGdiSelectClipPath(%X, %d)\n", (va_list)&hdc);
        GDITraceMultiHandle(hdc);
        GDITraceMulti(NtGdiSelectClipPath);
        GDITraceMulti(PATH);
    GDITraceMultiEnd();

    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid() || ((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    RGNMEMOBJTMP rmo(epath, dco.pdc->jFillMode());

    bRet = (rmo.bValid()  &&
            dco.pdc->iSelect(rmo.prgnGet(), iMode));

// Destroy the path (the region will be destroyed automatically):

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL NtGdiFillPath(hdc, pac)
*
* Fills an inactive path.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiFillPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    // sync the client side cached brush

    if (dco.pdc->ulDirty() & DC_BRUSH_DIRTY)
    {
       GreDCSelectBrush(dco.pdc, dco.pdc->hbrush());
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    epath.vCloseAllFigures();

    bRet = epath.bFill(dco);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiPathToRegion(hdc)
*
* Creates a region from the inactive path.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HRGN APIENTRY NtGdiPathToRegion(HDC hdc)
{
    DCOBJ dco(hdc);
    HRGN  hrgnRet = (HRGN) 0;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(hrgnRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(hrgnRet);
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(hrgnRet);
    }

    RGNMEMOBJ rmo(epath, dco.pdc->jFillMode());

    if (rmo.bValid())
    {
        hrgnRet = rmo.hrgnAssociate();

        if (hrgnRet == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }
    }
    else
    {
        hrgnRet = NULL;
    }

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(hrgnRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiStrokeAndFillPath(hdc, pac)
*
* StrokeAndFill's the inactive path.  Destroys it.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStrokeAndFillPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// sync the client side cached brush and pen

    SYNC_DRAWING_ATTRS(dco.pdc);

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    epath.vCloseAllFigures();

    bRet = epath.bStrokeAndFill(dco, dco.plaRealize(xfo), &xfo);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiStrokePath(hdc)
*
* Stroke's the inactive path.  Destroys it.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStrokePath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// sync the client side cached pen

    if (dco.pdc->ulDirty() & DC_PEN_DIRTY)
    {
       GreDCSelectPen(dco.pdc, dco.pdc->hpen());
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    bRet = epath.bStroke(dco, dco.plaRealize(xfo), &xfo);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreSetMiterLimit(hdc, eNewLimit, peOldLimit)
*
* Sets the DC's miter limit for wide lines.  Optionally returns the old one.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetMiterLimit
(
HDC     hdc,
FLOATL  l_eNewLimit,
FLOATL *pl_eOldLimit
)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid() || l_eNewLimit < IEEE_1_0F)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (pl_eOldLimit != (FLOATL *) NULL)
    {
        *pl_eOldLimit = dco.pdc->l_eMiterLimit();
    }

    dco.pdc->l_eMiterLimit(l_eNewLimit);

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetMiterLimit(hdc, peMiterLimit)
*
* Returns the DC's miter limit for wide lines.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetMiterLimit(
HDC     hdc,
FLOATL *pl_eMiterLimit)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    *pl_eMiterLimit = dco.pdc->l_eMiterLimit();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetPath()
*
* Gets the path data.  pcptPath will contain the number of points in the
* path, even if the supplied buffer is too small.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetPath(
    HDC     hdc,
    LPPOINT pptlBuf,
    LPBYTE  pjTypes,
    int     cptBuf
    )
{
    int cptPath = -1;

    DCOBJ dco(hdc);

    if (dco.bValid() && cptBuf >= 0)
    {
        if (dco.pdc->bInactive())
        {
            EXFORMOBJ exfoDtoW(dco, DEVICE_TO_WORLD);

            if (exfoDtoW.bValid())
            {
                //
                // We're not going to modify the path, so we don't have to worry
                // about copying it if a SaveDC is pending:
                //

                XEPATHOBJ epath(dco.hpath());
                ASSERTGDI(epath.bValid(), "Invalid DC path");

                cptPath = (int) epath.cTotalPts();

                //
                // if cptBuf == 0, this is not an error.  This is a request
                // for the size of the path.
                //

                if (cptBuf != 0)
                {
                    //
                    // Return an error if the buffer is too small:
                    //
                    // Note: sizeof(BYTE) < sizeof(POINT), so the single test
                    //       suffices to check for overflow in both write
                    //       probes; also, using MAXULONG instead of
                    //       MAXIMUM_POOL_ALLOC because checking for overflow,
                    //       not allocating memory
                    //

                    ASSERTGDI(sizeof(BYTE) <= sizeof(POINT),
                              "NtGdiGetPath: bad overflow check\n");

                    if ((cptBuf >= cptPath) &&
                        (cptBuf <= (MAXULONG/sizeof(POINT))))
                    {
                        PATHDATA pd;
                        PBYTE    pjEnd;
                        BYTE     jType;
                        BOOL     bMore;

                        epath.vEnumStart();

                        __try {

                            ProbeForWrite(pptlBuf,
                                          cptBuf * sizeof(POINT),
                                          sizeof(DWORD));

                            ProbeForWrite(pjTypes,
                                          cptBuf * sizeof(BYTE),
                                          sizeof(DWORD));

                            do {

                                bMore = epath.bEnum(&pd);

                                // We can get a zero point record if it's an empty path:

                                if (pd.count > 0)
                                {
                                    // Copy points:

                                    if (!exfoDtoW.bXform(pd.pptfx,
                                                         (PPOINTL) pptlBuf,
                                                         (SIZE_T) pd.count))
                                    {
                                        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                                        cptPath = -1;
                                        break;
                                    }

                                    pptlBuf += pd.count;

                                    // Determine types:

                                    pjEnd = pjTypes + pd.count;

                                    // First point in a subpath is always a MoveTo:

                                    if (pd.flags & PD_BEGINSUBPATH)
                                    {
                                        *pjTypes++ = PT_MOVETO;
                                    }

                                    // Other points are LineTo's or BezierTo's:

                                    jType = (pd.flags & PD_BEZIERS)
                                             ? (BYTE) PT_BEZIERTO
                                             : (BYTE) PT_LINETO;

                                    while (pjTypes < pjEnd)
                                    {
                                        *pjTypes++ = jType;
                                    }

                                    // Set CloseFigure bit for last point in a subpath:

                                    if (pd.flags & PD_CLOSEFIGURE)
                                    {
                                        ASSERTGDI(pd.flags & PD_ENDSUBPATH, "Expected on last pd");
                                        *(pjTypes - 1) |= PT_CLOSEFIGURE;
                                    }
                                }

                            } while (bMore);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            // SetLastError(GetExceptionCode());

                            cptPath = -1;
                        }
                    }
                    else
                    {
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        cptPath = -1;
                    }
                }
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(cptPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pathobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathobj.cxx
*
* Non inline PATHOBJ methods
*
* Created: 28-Sep-1990 12:36:30
* Author: Paul Butzi [paulb]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PBRUSH gpbrBackground;
extern PPEN gpPenNull;
extern PBRUSH gpbrNull;
extern LINEATTRS glaNominalGeometric;

// Default LINEATTRS for bSimpleStroke:

LA glaSimpleStroke =
{
    0,                      // fl
    0,                      // iJoin
    0,                      // iEndCap
    {1L},                   // elWidth
    IEEE_0_0F,              // eMiterLimit
    0,                      // cstyle
    (LONG_FLOAT*) NULL,     // pstyle
    {0L}                    // elStyleState
};

#define XFORMNULL ((EXFORMOBJ *) NULL)

// The following declarations are required by the native c8 compiler.

HSEMAPHORE PATHALLOC::hsemFreelist;        // Semaphore for freelist
PATHALLOC *PATHALLOC::freelist;            // Free-list of pathallocs
COUNT      PATHALLOC::cFree;               // Count of free pathallocs
COUNT      PATHALLOC::cAllocated;          // Count of pathallocs allocated

/******************************Public*Routine******************************\
* XEPATHOBJ::XEPATHOBJ(hpath)
*
* Path user object constructor
*
* History:
*  28-Sep-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::XEPATHOBJ(HPATH hPath)
{
    ppath = (PPATH)HmgShareLock((HOBJ) hPath, PATH_TYPE);

    if (ppath != (PATH*) NULL)
    {

        // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;
    }

    return;
}

/******************************Public*Routine******************************\
* XEPATHOBJ::XEPATHOBJ(dco)
*
* Path user object constructor to get at the DC's path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::XEPATHOBJ(XDCOBJ& dco)
{
    ASSERTGDI(dco.hpath() != HPATH_INVALID, "Invalid path");

// If a SaveDC was done, we may have to copy the path before mucking
// with it:

    if (dco.pdc->bLazySave())
    {
        dco.pdc->vClearLazySave();

        XEPATHOBJ epath(dco.hpath());

        ASSERTGDI (epath.bValid(),"hpath invalid when bLazySave is set");

        PATHMEMOBJ pmo;

        if (pmo.bValid() && epath.bValid() && pmo.bClone(epath))
        {
            pmo.vKeepIt();
            dco.pdc->hpath(pmo.hpath());
        }
        else
        {
        // Error case simply deletes the path if we managed to allocate
        // one, and marks the DC path as invalid:

            pmo.vDelete();
            dco.pdc->hpath(HPATH_INVALID);
        }
    }

    ppath = (PPATH)HmgShareLock((HOBJ) dco.hpath(), PATH_TYPE);
    if (ppath != (PATH*) NULL)
    {

        // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;
    }

    return;
}

/******************************Public*Routine******************************\
* EPATHFONTOBJ::vInit(ULONG)
*
* Initialize a chunk of memory to be a font pathobj
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHFONTOBJ::vInit(ULONGSIZE_T size)
{
    ppath = &path;

    path.ppachain              = &pa;
    path.ptfxSubPathStart.x    = 0;
    path.ptfxSubPathStart.y    = 0;
    path.flags                 = PD_BEGINSUBPATH;
    path.pprfirst              = (PATHRECORD*) NULL;
    path.pprlast               = (PATHRECORD*) NULL;
    path.rcfxBoundBox.xLeft    = 0;
    path.rcfxBoundBox.xRight   = 0;
    path.rcfxBoundBox.yTop     = 0;
    path.rcfxBoundBox.yBottom  = 0;
    path.flType                = PATHTYPE_STACK;

    pa.ppanext       = (PATHALLOC*) NULL;
    pa.pprfreestart  = pa.apr;
    pa.siztPathAlloc = size - offsetof(EPATHFONTOBJ,pa);

    fl      = 0;
    cCurves = 0;
}

/******************************Public*Routine******************************\
* XEPATHOBJ::~XEPATHOBJ()
*
* Path user object destructor
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::~XEPATHOBJ()
{
    if (ppath != (PPATH) NULL)
    {

        // Since we're keeping the object, save the accelerator values
        // away and unlock the object:

        ppath->cCurves = cCurves;
        ppath->fl      = fl;
        DEC_SHARE_REF_CNT(ppath);
    }

    return;
}

/******************************Public*Routine******************************\
* PATHMEMOBJ::PATHMEMOBJ()
*
* Create a new path object.
*
* Note: Using this constructor, the path will not inherit the current
* point from the DC!
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PATHMEMOBJ::PATHMEMOBJ()
{
    PPATH ppathTemp;

    ppath = ppathTemp = (PPATH)HmgAlloc(sizeof(PATH) ,PATH_TYPE, HMGR_ALLOC_ALT_LOCK);

    if (ppathTemp != (PATH*) NULL)
    {
        // Private debug code to catch invalid hpath handle in DC
        // 6/24/98 - davidx

        ASSERTGDI(HmgObjtype(ppath->hGet()) == PATH_TYPE,
                  "Private debug breakpoint. Please contact ntgdi.");

        //
        // Since we 0 init in the Alloc we don't need to do most of this.
        //

        // pPathTemp->ppachain              = (PATHALLOC*) NULL;
        // pPathTemp->pprfirst              = (PATHRECORD*) NULL;
        // pPathTemp->pprlast               = (PATHRECORD*) NULL;
        // pPathTemp->rcfxBoundBox.xLeft    = 0;
        // pPathTemp->rcfxBoundBox.xRight   = 0;
        // pPathTemp->rcfxBoundBox.yTop     = 0;
        // pPathTemp->rcfxBoundBox.yBottom  = 0;
        // pPathTemp->ptfxSubPathStart.x    = 0;
        // pPathTemp->ptfxSubPathStart.y    = 0;
        // pPathTemp->flType                = 0;
        // pPathTemp->fl                    = 0;
        // pPathTemp->cCurves               = 0;

        ppathTemp->flags                 = PD_BEGINSUBPATH | PD_ENDSUBPATH;
        fl                               = 0;
        cCurves                          = 0;
    }

    return;
}

/******************************Public*Routine******************************\
* PATHMEMOBJ::~PATHMEMOBJ()
*
* Release a path object unless made permanent.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PATHMEMOBJ::~PATHMEMOBJ()
{
// ppath may have been made NULL by vDelete(), or by a failed PATH
// allocation in the constructor:

    if (ppath != (PATH*) NULL)
    {
        if (!(ppath->flType & PATHTYPE_KEEPMEM))
        {
        // Free all the blocks in the path:

            vFreeBlocks();

        // Free the handle too:

            HmgFree((HOBJ) ppath->hGet());
        }
        else
        {
        // Since we're keeping the object, save the accelerator values away
        // and unlock the object:

            ppath->cCurves = cCurves;
            ppath->fl      = fl;
            DEC_SHARE_REF_CNT(ppath);
        }
    }
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::PATHSTACKOBJ()
*
* Create a new path object on the stack.  The path can hold only a small
* number of points on the stack, and will overflow onto the heap if
* necessary.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::PATHSTACKOBJ()
{
    ppath = &path;

    path.ppachain              = &paBuf.pa;
    path.ptfxSubPathStart.x    = 0;
    path.ptfxSubPathStart.y    = 0;
    path.flags                 = PD_BEGINSUBPATH;
    path.pprfirst              = (PATHRECORD*) NULL;
    path.pprlast               = (PATHRECORD*) NULL;
    path.rcfxBoundBox.xLeft    = 0;
    path.rcfxBoundBox.xRight   = 0;
    path.rcfxBoundBox.yTop     = 0;
    path.rcfxBoundBox.yBottom  = 0;
    path.flType                = PATHTYPE_STACK;

    paBuf.pa.ppanext           = (PATHALLOC*) NULL;
    paBuf.pa.pprfreestart      = paBuf.pa.apr;
    paBuf.pa.siztPathAlloc     = PATHSTACKALLOCSIZE;

    cCurves = 0;
    fl      = 0;
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::PATHSTACKOBJ(dco, bUseCP)
*
* Create a new path object on the stack or locate an old one.  If the DC
* is currently in a path bracket, we use the active path (which will NOT
* be on the path).  Otherwise, we create a new path on the stack (it will
* overflow onto the heap if necessary).  If we create a new path, we use
* some of the state from the DC to initialize the path, most notably the
* current position (ptfxSubPathStart).
*
* If bUseCP is set, the current position in the DC will be used to set the
* current position in the path.  Calls that don't use the current position
* (i.e., immediately do a bMoveTo) shouldn't set bUseCP because it may
* require a transform call to set it (we need the value in device space).
*
* SaveDC's do lazy saves of paths.  If a lazy save is pending, we have
* to copy the path and update the DC's path handle before we can modify
* it.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::PATHSTACKOBJ(XDCOBJ& dco, BOOL bUseCP)
{
    if (!dco.pdc->bActive())
    {
        cCurves = 0;
        fl      = 0;

    // There's no active path in the DC, so we create a temporary
    // path on the stack to hold our points:

        ppath = &path;

        path.ppachain              = &paBuf.pa;
        path.flags                 = PD_BEGINSUBPATH;
        path.pprfirst              = (PATHRECORD*) NULL;
        path.pprlast               = (PATHRECORD*) NULL;
        path.rcfxBoundBox.xLeft    = 0;
        path.rcfxBoundBox.xRight   = 0;
        path.rcfxBoundBox.yTop     = 0;
        path.rcfxBoundBox.yBottom  = 0;
        path.flType                = PATHTYPE_STACK;

        paBuf.pa.ppanext           = (PATHALLOC*) NULL;
        paBuf.pa.pprfreestart      = paBuf.pa.apr;
        paBuf.pa.siztPathAlloc     = PATHSTACKALLOCSIZE;

        if (bUseCP)
        {
            if (!dco.pdc->bValidPtfxCurrent())
            {
                ASSERTGDI(dco.pdc->bValidPtlCurrent(), "Both CPs invalid?");

                EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

                exo.bXformRound(&dco.ptlCurrent(), &dco.ptfxCurrent(), 1);
                dco.pdc->vValidatePtfxCurrent();
            }

            path.ptfxSubPathStart = dco.ptfxCurrent();

            // If we're not in a path, and a previous call to MoveToEx means
            // that the style state should be reset, we do it now:

            if (dco.ulDirty() & DIRTY_STYLESTATE)
            {
                dco.ulDirtySub(DIRTY_STYLESTATE);

                LINEATTRS* pla = dco.plaRealized();

                if (pla->fl & LA_GEOMETRIC)
                    pla->elStyleState.e = IEEE_0_0F;
                else
                    pla->elStyleState.l = 0L;
            }
        }
    }
    else
    {
    // If a SaveDC was done, we may have to copy the path before we can
    // muck with it:

        if (dco.pdc->bLazySave())
        {
            dco.pdc->vClearLazySave();

            XEPATHOBJ epath(dco.hpath());

            ASSERTGDI (epath.bValid(),"hpath invalid when bLazySave is set");

            PATHMEMOBJ pmo;

            if (pmo.bValid() && epath.bValid() && pmo.bClone(epath))
            {
                pmo.vKeepIt();
                dco.pdc->hpath(pmo.hpath());
            }
            else
            {
                pmo.vDelete();
                dco.pdc->hpath(HPATH_INVALID);
            }
        }

    // There is an active path bracket, so just add to it:

        ppath = (PPATH)HmgShareLock((HOBJ) dco.hpath(), PATH_TYPE);
        if (ppath == (PATH*) NULL)
            return;

        ASSERTGDI(ppath->flType & PATHTYPE_KEEPMEM, "Path not kept?");

    // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;

        if (bUseCP)
        {
            if (!dco.pdc->bValidPtfxCurrent())
            {
            // If the device space current position has been invalidated
            // (meaning that it's moved), always do a bMoveTo to the new
            // device space point:

                ASSERTGDI(dco.pdc->bValidPtlCurrent(), "Both CPs invalid?");

                EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

                exo.bXformRound(&dco.ptlCurrent(), &dco.ptfxCurrent(), 1);
                dco.pdc->vValidatePtfxCurrent();

                bMoveTo(&dco.ptfxCurrent());
            }
            else
            {
            // See if what we think is the current position matches the DC's
            // value (this code will be used when there is a path bracket
            // and the path is being added to for the first time):

                POINTFIX ptfx = ptfxGetCurrent();

                if (dco.ptfxCurrent().x != ptfx.x ||
                    dco.ptfxCurrent().y != ptfx.y)
                    bMoveTo(&dco.ptfxCurrent());
            }
        }
    }
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::~PATHSTACKOBJ()
*
* Deletes the path if it isn't the DC path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::~PATHSTACKOBJ()
{
// If we ran out of memory allocating blocks, we would have deleted the path,
// in which case ppath may be NULL:

    if (ppath != (PATH*) NULL)
    {
        ASSERTGDI(ppath->flType == PATHTYPE_KEEPMEM ||
                  ppath->flType == PATHTYPE_STACK, "Unexpected path type");

        if (ppath->flType & PATHTYPE_STACK)
        {
        // Path was only temporary; free any additional blocks if there
        // are any:

            if (ppath->ppachain != (PATHALLOC*) NULL)
                vFreeBlocks();
        }
        else
        {
        // Path is a permanent path, so unlock object and save some
        // accelerator values:

            ppath->cCurves = cCurves;
            ppath->fl      = fl;
            DEC_SHARE_REF_CNT(ppath);
        }
    }
}

/******************************Public*Routine******************************\
* RECTANGLEPATHOBJ::vInit(prcfx, bClockwise)
*
* Initializes the path with a single rectangle.  Should probably only ever
* be called from Rectangle.
*
* History:
*  13-Dec-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID RECTANGLEPATHOBJ::vInit(
    RECTL*  prcl,               // Must be well-ordered
    BOOL    bClockwise)         // Direction rectangle is to be drawn
{
    prRect.pr.pprnext = (PATHRECORD*) NULL;
    prRect.pr.pprprev = (PATHRECORD*) NULL;
    prRect.pr.flags   = (PD_BEGINSUBPATH | PD_ENDSUBPATH |
                         PD_RESETSTYLE   | PD_CLOSEFIGURE);
    prRect.pr.count   = 4;

    path.pprfirst     = &prRect.pr;
    path.pprlast      = &prRect.pr;
    path.flags        = 0;

    ppath             = &path;
    cCurves           = 4;
    fl                = 0;

// Initialize PATHRECORD variables.  When drawing in the counter-
// clockwise direction, we draw the vertices in the following order
// (this must match the EBOX constructor):
//
//       1 ___ 0
//        |   |
//        |___|
//       2     3

    path.rcfxBoundBox.xLeft   = LTOFX(prcl->left);
    prRect.pr.aptfx[1].x      = path.rcfxBoundBox.xLeft;
    prRect.pr.aptfx[2].x      = path.rcfxBoundBox.xLeft;

    path.rcfxBoundBox.xRight  = LTOFX(prcl->right);
    prRect.pr.aptfx[0].x      = path.rcfxBoundBox.xRight;
    prRect.pr.aptfx[3].x      = path.rcfxBoundBox.xRight;

    path.rcfxBoundBox.yTop    = LTOFX(prcl->top);
    path.rcfxBoundBox.yBottom = LTOFX(prcl->bottom);

    if (!bClockwise)
    {
        prRect.pr.aptfx[0].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[1].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[2].y  = path.rcfxBoundBox.yBottom;
        prRect.pr.aptfx[3].y  = path.rcfxBoundBox.yBottom;
    }
    else
    {
        prRect.pr.aptfx[2].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[3].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[0].y  = path.rcfxBoundBox.yBottom;
        prRect.pr.aptfx[1].y  = path.rcfxBoundBox.yBottom;
    }
}

/******************************Public*Routine******************************\
* EngCreatePath()
*
* DDI entry point to create a temporary path.
*
* History:
*  17-Feb-1992 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

PATHOBJ* EngCreatePath()
{
    PATHMEMOBJ pmo;

    if (!pmo.bValid())
        return((PATHOBJ*) NULL);

    EPATHOBJ* pepo = (EPATHOBJ*) PALLOCMEM(sizeof(EPATHOBJ), 'tapG');

    if (pepo == (EPATHOBJ*) NULL)
        return((PATHOBJ*) NULL);

    pmo.vKeepIt();

    pepo->vLock(pmo.hpath());

    return(pepo);
}

/******************************Public*Routine******************************\
* EngDeletePath()
*
* DDI entry point to delete a path allocated by EngCreatePath().
*
* History:
*  17-Feb-1992 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

VOID EngDeletePath(PATHOBJ* ppo)
{
    if (ppo != (PATHOBJ*) NULL)
    {
        ((EPATHOBJ*) ppo)->vDelete();
        VFREEMEM((PVOID) ppo);
    }
    else
        WARNING("ERROR: EngDeletePath given NULL pointer");
}


/******************************Public*Routine******************************\
* EPATHOBJ::vFreeBlocks()
*
* Frees all the heap blocks in a path.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vFreeBlocks()
{
    ASSERTGDI(ppath != (PATH*) NULL, "Trying to free freed path!");

// Free all the blocks in the path:

    PATHALLOC* ppa = ppath->ppachain;

    while (ppa != (PATHALLOC*) NULL)
    {
        PATHALLOC* ppasave = ppa->ppanext;

    // Don't free blocks that aren't PATHALLOCSIZE in size because
    // those were created on the stack:

        if (ppa->siztPathAlloc == PATHALLOCSIZE)
        {
            ASSERTGDI(ppa->siztPathAlloc != PATHSTACKALLOCSIZE,
                "PATHALLOCSIZE and PATHSTACKALLOCSIZE can't be the same!");

            freepathalloc(ppa);
        }

        ppa = ppasave;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::vDelete()
*
* Delete the path and free the handle if there is one.  It's polymorphic
* and can handle path type EPATHOBJ or PATHMEMOBJ.
*
* It can't handle PATHSTACKOBJ's or journal paths.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vDelete()
{
    if (ppath != (PATH*) NULL)
    {
        ASSERTGDI(!(ppath->flags & PATH_JOURNAL), "Can't delete journal path");

    // Free all the blocks in the path:

        vFreeBlocks();

        if (ppath->flType != PATHTYPE_STACK)
        {
        // Free the handle too (stack paths don't have handles):

            HmgFree((HOBJ) ppath->hGet());
            ppath = (PATH*) NULL;      // Prevent destructors from doing anything
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bClone(epo)
*
* Copy the specified path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bClone(EPATHOBJ& epo)
{
// First, copy path information:

    fl      = epo.fl;
    cCurves = epo.cCurves;

    ppath->pprfirst         = (PATHRECORD*) NULL;
    ppath->pprlast          = (PATHRECORD*) NULL;
    ppath->rcfxBoundBox     = epo.ppath->rcfxBoundBox;
    ppath->ptfxSubPathStart = epo.ppath->ptfxSubPathStart;
    ppath->flags            = epo.ppath->flags;

// Copy rest of path on a PATHRECORD by PATHRECORD basis:

    PATHRECORD* ppr     = epo.ppath->pprfirst;
    PATHRECORD* pprPrev = (PATHRECORD*) NULL;
    PATHRECORD* pprNew;

    while (ppr != (PATHRECORD*) NULL)
    {
        FLONG     fl    = ppr->flags;
        POINTFIX* pptfx = ppr->aptfx;
        COUNT     cpt   = ppr->count;
        COUNT     cptMax;

        while (cpt > 0)
        {
            if (!newpathrec(&pprNew,&cptMax,cpt))
                return(FALSE);

            pprNew->flags   = fl;
            pprNew->pprprev = pprPrev;
            pprNew->pprnext = (PATHRECORD*) NULL;

            if (cpt <= cptMax)
                pprNew->count = cpt;
            else
            {
            // Have to copy this PATHRECORD into two separate PATHRECORDs,
            // so adjust the count and clean up the flags:

            // Adjust cptMax for Beziers.

                if (fl & PD_BEZIERS)
                {
                    if (fl & PD_BEGINSUBPATH)
                        cptMax -= (cptMax-1) % 3;
                    else
                        cptMax -= cptMax % 3;
                }

                pprNew->count = cptMax;
                pprNew->flags &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
                fl            &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);
            }

            ppath->pprlast  = pprNew;
            if (pprPrev == (PATHRECORD*) NULL)
                ppath->pprfirst = pprNew;
            else
                pprPrev->pprnext = pprNew;

            RtlCopyMemory(pprNew->aptfx,
                          pptfx,
                          (SIZE_T) pprNew->count * sizeof(POINTFIX));
            pptfx += pprNew->count;
            cpt   -= pprNew->count;

        // Adjust the PATHALLOC record:

            ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);
            pprPrev = pprNew;
        }

        ppr = ppr->pprnext;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::cjSize(epo)
*
* Compute the size needed if a single PATHALLOC was to hold the entire
* path.
*
* History:
*  20-May-1992 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

ULONGSIZE_T EPATHOBJ::cjSize()
{
    ULONGSIZE_T cjRV = 0;

// Run down the path, adding up the sizes of the pathrecords.

    PATHRECORD* ppr     = ppath->pprfirst;

    while (ppr != (PATHRECORD*) NULL)
    {
        cjRV += offsetof(PATHRECORD, aptfx)
              + (ULONGSIZE_T)ppr->count * sizeof(POINTFIX);

        ppr = ppr->pprnext;
    }

    return(cjRV);
}

/******************************Member*Function*****************************\
* ULONG EPATHOBJ::cTotalCurves()
*
*  Figure out the number of curves in the path for the path's cCurves
*  field.
*
* History:
*  6-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG EPATHOBJ::cTotalCurves()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_CLOSEFIGURE)
            count++;

        if (ppr->flags & PD_BEZIERS)
            count += ppr->count / 3;
        else
        {
            count += ppr->count;
            if (ppr->flags & PD_BEGINSUBPATH)
                count--;
        }
    }

    return(count);
}

/******************************Member*Function*****************************\
* ULONG EPATHOBJ::cTotalPts()
*
*  Figure out the number of control points in a path.
*
* History:
*  20-Feb-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG EPATHOBJ::cTotalPts()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        count += ppr->count;
    }

    return(count);
}

/******************************Public*Routine******************************\
* EPATHOBJ::bAppend (ppoNew,pptfxDelta)                                    *
*                                                                          *
* Appends an offset version of the given path (ppoNew) to the target path. *
*                                                                          *
*  Wed 17-Jun-1992 00:21:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EPATHOBJ::bAppend(EPATHOBJ *ppoNew,POINTFIX *pptfxDelta)
{
    PATHDATAL   pd;       // Needed to call growlastrec and createrec.
    PATHRECORD *ppr;      // For enumeration.
    POINTFIX    ptfx;

    for
    (
        ppr = ppoNew->ppath->pprfirst;
        ppr != (PPATHREC) NULL;
        ppr = ppr->pprnext
    )
    {
        pd.count = ppr->count;
        pd.flags = ppr->flags & PD_BEZIERS;
        pd.pptl = (POINTL *) &(ppr->aptfx[0]);

    // Call bMoveTo if we are starting a new subpath.

        if (ppr->flags & PD_BEGINSUBPATH)
        {
            ptfx.x = ppr->aptfx[0].x + pptfxDelta->x;
            ptfx.y = ppr->aptfx[0].y + pptfxDelta->y;

            bMoveTo(XFORMNULL,(POINTL *) &ptfx);
            pd.count--;
            pd.pptl++;
        }

    // Copy all the control points.

        while (pd.count > 0)
        {
            if (!createrec(XFORMNULL,&pd,pptfxDelta))
                return(FALSE);
        }

    // Set the CloseFigure flag to close it.

        if (ppr->flags & PD_CLOSEFIGURE)
        {
            ppath->pprlast->flags |= PD_CLOSEFIGURE;

        // Indicate that we are starting a new subpath:

            ppath->flags |= PD_BEGINSUBPATH;
        }
    }

// Always reset the PO_ELLIPSE flag (the Ellipse call will set it
// appropriately) and turn on the PO_BEZIERS flag if we added Beziers:

    fl &= ~PO_ELLIPSE;
    if (ppoNew->fl & PO_BEZIERS)
        fl |= PO_BEZIERS;

// Add in the count of curves.

    cCurves += ppoNew->cCurves;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vOffsetPoints (pptfxDest,pptfxSrc,c,dx,dy)                               *
*                                                                          *
* A simple routine that moves points while offsetting them.  This is much  *
* faster than calling the transform code!                                  *
*                                                                          *
*  Wed 17-Jun-1992 00:54:32 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vOffsetPoints
(
    POINTFIX *pptfxDest,
    POINTFIX *pptfxSrc,
    UINT      c,
    LONG      dx,
    LONG      dy
)
{
    while (c--)
    {
        pptfxDest->x = pptfxSrc->x + dx;
        pptfxDest->y = pptfxSrc->y + dy;
        pptfxDest++;
        pptfxSrc++;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::addpts()
*
*   We add the specified points to the path.  If possible, we tack the
*   points onto the last record ('grow the last record') otherwise we
*   create one or more records and stash the points in them.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::addpoints(EXFORMOBJ *pxfo, PATHDATAL *ppd)
{
// No points always succeeds!

    if (ppd->count == 0)
        return(TRUE);

// Try to add to end of last record.  Can't do it if:
//
//      - beginsubpath flag set in ppath (must be new record)
//
//  growlastrec may do nothing, in which case we just
//  fall thru and add records.

    if ((ppath->flags & PD_BEGINSUBPATH) == 0)
        growlastrec(pxfo,ppd,(POINTFIX *) NULL);

// Now add new records until we're done.  Note that if BEGINSUBPATH is
// set in the path, it means that we must add in the current position
// before the points in the ppd; this is handled by createrec.

    while (ppd->count > 0)
    {
        if (!createrec(pxfo,ppd,(POINTFIX *) NULL))    // Adds a new pathalloc
            return(FALSE);                             //   when needed.
    }

// Always reset the PO_ELLIPSE flag (the Ellipse call will set it
// appropriately) and turn on the PO_BEZIERS flag if we added Beziers:

    fl &= ~PO_ELLIPSE;
    if (ppd->flags & PD_BEZIERS)
        fl |= PO_BEZIERS;

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::growlastrec()                                                  *
*                                                                          *
*   growlastrec - add data to the already existing last record in path.    *
*                                                                          *
*   Note:                                                                  *
*       If the PD_BEGINSUBPATH flag is set in the path header, then        *
*       it means that the current position has *not* been put in the path, *
*       and it must be added to the path before we begin adding more       *
*       control points.  Note that this cannot happen in this routine,     *
*       since we cannot both start a new path and extend an existing       *
*       record at the same time.                                           *
*                                                                          *
* History:                                                                 *
*  Wed 17-Jun-1992 00:15:06 -by- Charles Whitmer [chuckwh]                 *
* Added the pptfxDelta parameter.                                          *
*                                                                          *
*  1-Oct-1990 -by- Paul Butzi [paulb]                                      *
* Wrote it.                                                                *
\**************************************************************************/

void EPATHOBJ::growlastrec(EXFORMOBJ *pxfo,PATHDATAL *ppd,POINTFIX *pptfxDelta)
{
    PATHALLOC *ppa = ppath->ppachain;
    PATHRECORD *ppr = ppath->pprlast;

// Check conditions for adding to last record
//
//  1. there must be a last record
//  2. there must be an existing pathalloc
//  3. the path data to be added must not start a new
//     sub-path
//  4. the other flags must match (bezier, etc.)

    if ( ppr == (PPATHREC) NULL )
        return;

    if ( ppa == (PATHALLOC*) NULL )
        return;

    if (ppd->flags !=
       (ppr->flags & ~(PD_BEGINSUBPATH | PD_ENDSUBPATH)))
    {
        return;
    }

// Figure out how much we can expand the current last record.
//
//  NOTE: pointer casts are below are safe, since both the
//        start and end of a pathalloc block are aligned on
//        the most restrictive boundary.  These alignment points
//          are the *only* safe points to cast between types, since
//        only there are we guaranteed to be safely aligned.

    POINTFIX *oldend = &(ppr->aptfx[ppr->count]);
    POINTFIX *newend = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

    ULONGSIZE_T maxadd = 0;
    if ( newend > oldend )
    {
        //Sundown truncation
        ASSERT4GB((ULONGLONG)(newend - oldend));
        maxadd = (ULONG)(newend - oldend);
    }

// Don't add more than we need!

    if ( maxadd > ppd->count )
        maxadd =  (ULONGSIZE_T)ppd->count;

// We must add a multiple of 3 points for Beziers.

    if (ppd->flags & PD_BEZIERS)
        maxadd -= maxadd % 3;

    if (maxadd == 0)
        return;

// Copy the points:

    if (pptfxDelta != (POINTFIX *) NULL)
    {
        vOffsetPoints(
                      &(ppr->aptfx[ppr->count]),
                      (POINTFIX *) ppd->pptl,
                      maxadd,
                      pptfxDelta->x,
                      pptfxDelta->y
                     );
    }
    else if (pxfo == XFORMNULL)
        RtlCopyMemory(&(ppr->aptfx[ppr->count]),
                      ppd->pptl,
                      (SIZE_T) maxadd * sizeof(POINTFIX));
    else
        pxfo->bXformRound(ppd->pptl, &(ppr->aptfx[ppr->count]), maxadd);

    ASSERTGDI((CHAR*) &ppr->aptfx[ppr->count + maxadd] <=
              (CHAR*) ppa + ppa->siztPathAlloc,
              "Overwrote bounds!");
    ASSERTGDI((CHAR*) &(ppr->aptfx[ppr->count]) > (CHAR*) ppa, "Bad bound");

// Adjust the bounding box:

    register POINTFIX *pptfx = &ppr->aptfx[ppr->count];
    for ( register ULONG i = 0; i < maxadd; i += 1, pptfx += 1 )
    {
        ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx);
    }

// adjust the path record

    ppr->count += maxadd;

// adjust the pathalloc record

    ppa->pprfreestart = NEXTPATHREC(ppr);

    ASSERTGDI((CHAR*) ppa->pprfreestart <= (CHAR*) ppa + ppa->siztPathAlloc,
              "Weird freestart");

// adjust the pathdata record

    ppd->count -= maxadd;
    ppd->pptl += maxadd;
}


/******************************Public*Routine******************************\
* EPATHOBJ::reinit()                                                       *
*     Reinitialize an existing path so that it becomes an empty path.      *
*     This is useful in error cases when the path cannot be restored,      *
*     but also cannot be deleted (because the handle is in a DC).  See     *
*     bug 177612 for details.                                              *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  11-Aug-1998 -by- Ori Gershony [orig]                                    *
* Wrote it.                                                                *
\**************************************************************************/
VOID EPATHOBJ::reinit()
{
    if (ppath != (PATH *) NULL)
    {
        ASSERTGDI(!(ppath->flags & PATH_JOURNAL), "Can't delete journal path");
    
    // Free all the blocks in the path:

        vFreeBlocks();

    // And reinitialize the path data

        ppath->ppachain              = (PATHALLOC*) NULL;
        ppath->pprfirst              = (PATHRECORD*) NULL;
        ppath->pprlast               = (PATHRECORD*) NULL;
        ppath->rcfxBoundBox.xLeft    = 0;
        ppath->rcfxBoundBox.xRight   = 0;
        ppath->rcfxBoundBox.yTop     = 0;
        ppath->rcfxBoundBox.yBottom  = 0;
        ppath->ptfxSubPathStart.x    = 0;
        ppath->ptfxSubPathStart.y    = 0;
        ppath->flags                 = PD_BEGINSUBPATH | PD_ENDSUBPATH;
        ppath->pprEnum               = (PATHRECORD *) NULL;
        // Don't clear flType - it's used by the destructor to determine
        // how we allocated the memory and hence how to dispose of it correctly.
        //ppath->flType                = 0;
        ppath->fl                    = 0;
        ppath->cCurves               = 0;
        // don't need to initialize ppath->cle, because it will be initialized by vEnumPathStart
        
        fl                           = 0;
        cCurves                      = 0;
    }
}



/******************************Public*Routine******************************\
* EPATHOBJ::createrec()                                                    *
*                                                                          *
*   Add a new path record to the path, taking control points and flags     *
*   from the pathdata struct passed.  We try to fit things in the          *
*   last pathdata block if we can sensibly do it, but otherwise we         *
*   allocate a new pathdata and tack it on the end.  Note that a pathdata  *
*   may not be filled completely if it isn't convenient.                   *
*                                                                          *
* History:                                                                 *
*  Wed 17-Jun-1992 00:15:06 -by- Charles Whitmer [chuckwh]                 *
* Added the pptfxDelta parameter.                                          *
*                                                                          *
*  1-Oct-1990 -by- Paul Butzi [paulb]                                      *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EPATHOBJ::createrec(EXFORMOBJ *pxfo,PATHDATAL *ppd,POINTFIX *pptfxDelta)
{
    PATHALLOC *ppa = ppath->ppachain;
    ULONGSIZE_T maxadd = 0;  // # of pts we can fit into zero space

    if ( ppa != (PATHALLOC*) NULL )
    {
    // We have a current pathalloc, see how much will fit.
    // Computation done into temps to avoid compiler assertion!

        POINTFIX *start = &(ppa->pprfreestart->aptfx[0]);
        POINTFIX *end = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

        if (end > start)
        //Sundown safe truncation
            maxadd =(ULONG)(end - start);
    }

// Decide if we need to enter the current position before adding
// the points in the pathdata. cPoints gets the count of how many
// we add; either zero or one.

    COUNT cPoints = (ppath->flags & PD_BEGINSUBPATH) ? 1 : 0;

// We must add a multiple of 3 points for Beziers.

    if ((ppd->flags & PD_BEZIERS) && (maxadd > 0))
        maxadd -= (maxadd - (ULONGSIZE_T)cPoints) % 3;

// At this point, 'maxadd' indicates how many points we could get
// into a record if we added it in the current pathalloc.
// Now we can decide if we need a new pathalloc

    if ( (maxadd < (cPoints + ppd->count)) && (maxadd < PATHALLOCTHRESHOLD) )
    {
    // allocate a new pathalloc, link it into path

        ppa = newpathalloc();
        if (ppa == (PATHALLOC*) NULL)
        {

        // We're out of memory.
        //
        // At this point, our PATHALLOC chain is intact (so we can safely
        // traverse the chain to free the blocks), but the rest of the path
        // data can be corrupt (it's not worth trying to recover in this
        // case), so we can't allow the path to be used anymore.
        //
        // But paths are persistent between API calls when there is an
        // active path; we have to mark that the path is invalid, and not
        // let any subsequent APIs try to do any operation on it other than
        // to delete it.

            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

        // We free all blocks and re-initialize the path.  We don't want to delete
        // it here because the handle might be stored in a DC (see bug 177612)

            reinit();

            return(FALSE);
        }

        ppa->ppanext = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

        ASSERTGDI((CHAR*) ppa + ppa->siztPathAlloc > (CHAR*) ppa->pprfreestart,
                  "Invalid pprfreeestart");

        //Sundown truncation
        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONGSIZE_T numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);
        maxadd = (ULONGSIZE_T)(numbytes - offsetof(PATHRECORD, aptfx)) /
                          sizeof(POINTFIX);

    // We must add a multiple of 3 points for Beziers.

        if (ppd->flags & PD_BEZIERS)
            maxadd -= (maxadd - (ULONGSIZE_T)cPoints) % 3;
    }

// Don't add more points than we need:

    if ( maxadd > (ppd->count + cPoints) )
        maxadd = (ULONGSIZE_T)(ppd->count + cPoints);

// Create new pathrec header:

    PATHRECORD *ppr = ppa->pprfreestart;

    ppr->flags = ppd->flags | PD_ENDSUBPATH;
    ppr->count = maxadd;
    ppr->pprnext = (PPATHREC)NULL;
    ppr->pprprev = ppath->pprlast;

    if ( cPoints == 0 )
    {
    // This new record is a continuation of the old one, so clear
    // the previous record's end-subpath flag

        if (ppath->pprlast != (PPATHREC) NULL)
            ppath->pprlast->flags &= ~PD_ENDSUBPATH;
    }
    else
    {
    // This is a new sub-path, so add in the current point

        *(ppr->aptfx) = ppath->ptfxSubPathStart;
        maxadd -= 1;
        ppr->flags |= (ppath->flags & (PD_BEGINSUBPATH | PD_RESETSTYLE));
        ppath->flags &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);;
    }

// Copy in the points:

    if (pptfxDelta != (POINTFIX *) NULL)
    {
        vOffsetPoints(
                      &(ppr->aptfx[cPoints]),
                      (POINTFIX *) ppd->pptl,
                      maxadd,
                      pptfxDelta->x,
                      pptfxDelta->y
                     );
    }
    else if (pxfo == XFORMNULL)
        RtlCopyMemory(&(ppr->aptfx[cPoints]),
                      ppd->pptl,
                      maxadd * sizeof(POINTFIX));
    else
        pxfo->bXformRound(ppd->pptl, &(ppr->aptfx[cPoints]), maxadd);

    ASSERTGDI((CHAR*) &ppr->aptfx[cPoints + maxadd] <=
              (CHAR*) ppa + ppa->siztPathAlloc,
              "Overwrote bounds!");

// Adjust the bounding box:

    register POINTFIX *pptfx = ppr->aptfx;
    if ( ppath->pprlast == (PPATHREC) NULL )
    {
    // if path was empty, set the bound box to a single pt.

        ppath->rcfxBoundBox.xLeft = ppath->rcfxBoundBox.xRight = pptfx->x;
        ppath->rcfxBoundBox.yTop = ppath->rcfxBoundBox.yBottom = pptfx->y;
    }

    for ( register ULONG i = 0; i < maxadd + cPoints; i += 1, pptfx += 1 )
    {
        ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx);
    }

// Now that we know we have succeeded, add the pathrec to the path chain
// Prior to doing this, we can back out it's as if we hadn't changed anything.

    if (ppath->pprlast == (PPATHREC) NULL )
    {
    // first pathrec in path!

        ppath->pprfirst = ppath->pprlast = ppr;
    }
    else
    {
    // add to pathrec chain

        ppath->pprlast->pprnext = ppr;
        ppath->pprlast = ppr;
    }

// Adjust the pathalloc record:

    ppa->pprfreestart = NEXTPATHREC(ppr);

    ASSERTGDI((CHAR*) ppa->pprfreestart <= (CHAR*) ppa + ppa->siztPathAlloc,
              "Weird freestart");

// Adjust a bunch of state:

    ppd->count -= maxadd;
    ppd->pptl  += maxadd;
    ppd->flags &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* PATHOBJ_vGetBounds(ppo, prcfx)
*
*   Gets the path bounds.
*
* History:
*  19-Aug-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID PATHOBJ_vGetBounds(PATHOBJ* ppo, PRECTFX prcfx)
{
    *prcfx = ((EPATHOBJ *) ppo)->rcfxBoundBox();

// Make the box lower-right exclusive if not empty (i.e., not {0,0,0,0}):

    if (prcfx->yTop || prcfx->xLeft || prcfx->yBottom || prcfx->xRight)
    {
        prcfx->yBottom += 1;
        prcfx->xRight  += 1;
    }
}

VOID PATHOBJ_vEnumStart(PATHOBJ* ppo)
{
    ((EPATHOBJ*) ppo)->vEnumStart();
}

/******************************Public*Routine******************************\
* EPATHOBJ::bEnum()
*
*   Enumerate the path
*
* History:
*  19-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bEnum(PATHDATA *ppd)
{
    return(PATHOBJ_bEnum(this, ppd));
}

BOOL PATHOBJ_bEnum(PATHOBJ* ppo, PATHDATA* ppd)
{
    PATH*       ppath;
    LONG        i;
    PATHRECORD* ppr;
    POINTFIX*   pptfx;

    ppath = ((EPATHOBJ*) ppo)->ppath;

// Detect case where he didn't call bStartEnum()

    if (ppath->pprEnum == NULL)
    {
        if (ppath->pprfirst == NULL)
        {
        // It's an empty path:

            ppd->count = 0;
            ppd->flags = 0;
            ppd->pptfx = (PPOINTFIX) NULL;
            return(FALSE);
        }
        else
        {
        // Start again at first record:

            ppath->pprEnum = ppath->pprfirst;
        }
    }

    ppr = ppath->pprEnum;

    ppd->count = ppr->count;
    ppd->flags = ppr->flags;
    ppd->pptfx = ppr->aptfx;

    ppath->pprEnum = ppr->pprnext;

// By setting PO_ENUM_AS_INTEGERS in the PATHOBJ before calling bEnum,
// the driver signals that it saw the PO_ALL_INTEGERS flag and wants
// the coordinates as integers instead of fixed point.  That's great
// because if PO_ALL_INTEGERS was set, that means we recorded the path
// in integer coordinates.

    if ((ppo->fl & (PO_ALL_INTEGERS | PO_ENUM_AS_INTEGERS)) == PO_ALL_INTEGERS)
    {
    // Uh oh, the driver didn't ask for integer coordinates.  So we'll
    // simply convert the path to fixed coordinates and remove the
    // PO_ALL_INTEGERS flag:

        ppo->fl &= ~PO_ALL_INTEGERS;

        for (ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
        {
            for (pptfx = ppr->aptfx, i = ppr->count; i != 0; pptfx++, i--)
            {
                pptfx->x <<= 4;
                pptfx->y <<= 4;
            }
        }
    }

    if ((ppo->fl & (PO_ALL_INTEGERS | PO_ENUM_AS_INTEGERS)) == PO_ENUM_AS_INTEGERS)
    {
    // The driver set PO_ENUM_AS_INTEGERS when PO_ALL_INTEGERS wasn't
    // set.  Tsk, tsk.

        RIP("Driver mustn't set PO_ENUM_AS_INTEGERS unless PO_ALL_INTEGERS was set by GDI");
    }

    return(ppath->pprEnum != (PPATHREC) NULL);
}

/******************************Public*Routine******************************\
* EPATHOBJ::vOffset()
*
*   Enumerate the path
*
* History:
*  29-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vOffset(EPOINTL &eptl)
{
    LONG xOffset = LTOFX(eptl.x);
    LONG yOffset = LTOFX(eptl.y);

    RECTFX *prcfxBoundBox = &ppath->rcfxBoundBox;

    prcfxBoundBox->xLeft   += xOffset;
    prcfxBoundBox->xRight  += xOffset;
    prcfxBoundBox->yTop    += yOffset;
    prcfxBoundBox->yBottom += yOffset;

    if (fl & PO_ALL_INTEGERS)
    {
    // If 'PO_ALL_INTEGERS' is set, the path has been recorded as integers
    // instead of 28.4 fixed point.  So convert the offsets back to integers
    // again:

        xOffset = FXTOL(xOffset);
        yOffset = FXTOL(yOffset);
    }

    register PATHRECORD* ppr;
    for (ppr = ppath->pprfirst; ppr != (PPATHREC) NULL; ppr = ppr->pprnext)
    {
        for (register EPOINTFIX *peptfx = (EPOINTFIX *)ppr->aptfx;
             peptfx < (EPOINTFIX *)&ppr->aptfx[ppr->count];
             peptfx += 1)
        {
            peptfx->x += xOffset;
            peptfx->y += yOffset;
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bMoveTo()
*
*   Set the current position in the path.  Note that the following effects
*   also occur:
*       - last existing record in path is marked as ending the subpath
*       - flag is set indicating that next path record will start a new
*         subpath.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bMoveTo(EXFORMOBJ *pxfo, PPOINTL pptl)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    if (pxfo == XFORMNULL)
        ppath->ptfxSubPathStart = *((PPOINTFIX) pptl);
    else
    {
        pxfo->bXformRound(pptl, &ppath->ptfxSubPathStart, 1);
    }

    ppath->flags |= (PD_BEGINSUBPATH | PD_RESETSTYLE);

    return(TRUE);
}

BOOL PATHOBJ_bMoveTo(PATHOBJ* ppo, POINTFIX ptfx)
{
    return(((EPATHOBJ*) ppo)->bMoveTo(XFORMNULL, (PPOINTL) &ptfx));
}

/******************************Public*Routine******************************\
* EPATHOBJ::bCloseFigure()
*
*   close the current subpath in the path.
*
* History:
*  8-Nov-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bCloseFigure()
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    if (ppath->pprlast != (PATHRECORD*) NULL)
    {
        if (!(ppath->pprlast->flags & PD_CLOSEFIGURE))
        {
            ppath->pprlast->flags |= PD_CLOSEFIGURE;
            cCurves++;
        }
    }

// Indicate that we are starting a new subpath:

    ppath->flags |= PD_BEGINSUBPATH;

// We don't have to update ptfxSubPathStart because the current position
// after a CloseFigure is set to the sub-path start point.

    return(TRUE);
}

BOOL PATHOBJ_bCloseFigure(PATHOBJ* ppo)
{
    return(((EPATHOBJ*) ppo)->bCloseFigure());
}

/******************************Public*Routine******************************\
* EPATHOBJ::vCloseAllFigures()
*
*   Closes any open figures in the path.  Used for FillPath and
*   StrokeAndFillPath.
*
* History:
*  17-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vCloseAllFigures()
{
    PPATHREC ppr = ppath->pprfirst;
    while (ppr != (PPATHREC) NULL)
    {
        if (ppr->flags & PD_ENDSUBPATH)
        {
            if (!(ppr->flags & PD_CLOSEFIGURE))
            {
                ppr->flags |= PD_CLOSEFIGURE;
                cCurves++;
            }
        }
        ppr = ppr->pprnext;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bPolyLineTo()
*
*   Draw lines from the current position in the path thru the specified
*   points.  Sets the current position to the last specified point.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bPolyLineTo(EXFORMOBJ *pxfo, PPOINTL pptl, ULONG cPts)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    PATHDATAL pd;
    BOOL      bRet;

    pd.flags = 0;
    pd.pptl  = pptl;
    pd.count = cPts;

    bRet = addpoints(pxfo, &pd);
    if (bRet)
        cCurves += cPts;

    return(bRet);
}

BOOL PATHOBJ_bPolyLineTo(PATHOBJ* ppo, PPOINTFIX pptfx, ULONG cptfx)
{
// NULL transform indicates that the points are already in device space:

    return(((EPATHOBJ*) ppo)->bPolyLineTo(XFORMNULL,
                                          (PPOINTL) pptfx,
                                          cptfx));
}

/******************************Public*Routine******************************\
* EPATHOBJ::bPolyBezierTo()
*
*   Draw curves from the current position in the path thru the specified
*   points.  Sets the current position to the last specified point.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bPolyBezierTo(EXFORMOBJ *pxfo, PPOINTL pptl, ULONG cPts)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    PATHDATAL pd;
    BOOL      bRet;

    ASSERTGDI(cPts % 3 == 0, "Weird number of Bezier points");
    pd.flags = PD_BEZIERS;
    pd.pptl  = pptl;
    pd.count = cPts;

    bRet = addpoints(pxfo, &pd);
    if (bRet)
        cCurves += cPts / 3;

    return(bRet);
}

BOOL PATHOBJ_bPolyBezierTo(PATHOBJ* ppo, PPOINTFIX pptfx, ULONG cptfx)
{
// NULL transform indicates that the points are already in device space:

    return(((EPATHOBJ*) ppo)->bPolyBezierTo(XFORMNULL,
                                            (PPOINTL) pptfx,
                                            cptfx));
}


BOOL EPATHOBJ::bTextOutSimpleFill(
XDCOBJ&     dco,
RFONTOBJ&   rfo,
PDEVOBJ*    pdo,
SURFACE*    pSurf,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrushOrg,
MIX         mix,
FLONG       flOptions)
{
    BOOL bSem = FALSE, bRet;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;

    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCace acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    if (dco.bPrinter() && dco.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    bRet = bSimpleFill(dco.flGraphicsCaps(),
                       pdo,
                       pSurf,
                       pco,
                       pbo,
                       pptlBrushOrg,
                       mix,
                       flOptions);
    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);

        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }
    }

    return bRet;
}

BOOL EPATHOBJ::bTextOutSimpleStroke1(
XDCOBJ& dco,
RFONTOBJ& rfo,
PDEVOBJ*   plo,
SURFACE*   pSurface,
CLIPOBJ*   pco,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
MIX        mix)
{
    BOOL bSem = FALSE, bRet;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;

    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCace acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    if (dco.bPrinter() && dco.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    LINEATTRS laTmp = glaSimpleStroke.la;

    bRet = bSimpleStroke(dco.flGraphicsCaps(),
                         plo,
                         pSurface,
                         pco,
                         (XFORMOBJ*) NULL,
                         pbo,
                         pptlBrushOrg,
                         &laTmp,
                         mix);

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);

        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }
    }

    return bRet;
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleFill(flCaps, plo, pSurf, pco, pbo, pptlBrushOrg,
*                       mix, flOptions)
*
* Fill the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleFill(
FLONG     flCaps,              // For device graphics caps
PDEVOBJ*  pdo,
SURFACE*  pSurf,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL  bRet;

#if DBG
    ASSERTGDI(bAllClosed(), "A sub-path in the filled path wasn't closed.");
#endif
    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

    if (pSurf->flags() & HOOK_FillPath)
    {
        if (((flOptions & WINDING) && (flCaps & GCAPS_WINDINGFILL)) ||
            (!(flOptions & WINDING) && (flCaps & GCAPS_ALTERNATEFILL)))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,FillPath),
                        "Driver hooked FillPath but didn't supply routine");

                    INC_SURF_UNIQ(pSurf);

                    bRet = (*PPFNDRV(*pdo,FillPath)) (
                                       pSurf->pSurfobj(),
                                       (PATHOBJ*) this,
                                       pco,
                                       pbo,
                                       pptlBrushOrg,
                                       mix,
                                       flOptions);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,FillPath),
                "Driver hooked FillPath but didn't supply routine");

            INC_SURF_UNIQ(pSurf);

            bRet = (*PPFNDRV(*pdo,FillPath)) (
                               pSurf->pSurfobj(),
                               (PATHOBJ*) this,
                               pco,
                               pbo,
                               pptlBrushOrg,
                               mix,
                               flOptions);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    INC_SURF_UNIQ(pSurf);

    return(EngFillPath(pSurf->pSurfobj(),
                       (PATHOBJ*) this,
                       pco,
                       pbo,
                       pptlBrushOrg,
                       mix,
                       flOptions));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleStroke(flCaps, pdo, pSurf, pco, pxo, pbo, pptlBrushOrg,
*                         pla, mix)
*
* Stroke the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleStroke(
FLONG      flCaps,             // For device graphics caps
PDEVOBJ*   pdo,
SURFACE*   pSurf,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    BOOL  bRet;

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

// the real thing

    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

    INC_SURF_UNIQ(pSurf);

    if (pSurf->flags() & HOOK_StrokePath)
    {
    // Pass the path to the driver if it's not a wide line, or if the driver
    // says it can take wide lines:

        if (!(pla->fl & LA_GEOMETRIC) || (flCaps & GCAPS_GEOMETRICWIDE))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,StrokePath),
                        "Driver hooked StrokePath but didn't supply routine");

                    bRet = (*PPFNDRV(*pdo,StrokePath)) (
                                         pSurf->pSurfobj(),
                                         (PATHOBJ*) this,
                                         pco,
                                         pxo,
                                         pbo,
                                         pptlBrushOrg,
                                         pla,
                                         mix);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,StrokePath),
                "Driver hooked StrokePath but didn't supply routine");

            bRet = (*PPFNDRV(*pdo,StrokePath)) (
                                 pSurf->pSurfobj(),
                                 (PATHOBJ*) this,
                                 pco,
                                 pxo,
                                 pbo,
                                 pptlBrushOrg,
                                 pla,
                                 mix);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    if (pla->fl & LA_GEOMETRIC)
    {
        //
        // Handle wide lines, remembering that the widened bounds have
        // already been computed:
        //

        if (!bWiden(pxo, pla))
            return(FALSE);

        return(bSimpleFill(flCaps,
                           pdo,
                           pSurf,
                           pco,
                           pbo,
                           pptlBrushOrg,
                           mix,
                           WINDING));
    }

    //
    // Pass it off to the engine:
    //

    return(EngStrokePath(pSurf->pSurfobj(),
                         (PATHOBJ*) this,
                         pco,
                         pxo,
                         pbo,
                         pptlBrushOrg,
                         pla,
                         mix));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleStrokeAndFill(flCaps, pdo, pSurf, pco, pxo, pboStroke,
*                                pla, pboFill, pptlBrushOrg, mix, flOptions)
*
* Stroke and fill the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleStrokeAndFill(
FLONG      flCaps,             // For device graphics caps
PDEVOBJ*   pdo,
SURFACE*   pSurf,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pboStroke,
LINEATTRS* pla,
BRUSHOBJ*  pboFill,
POINTL*    pptlBrushOrg,
MIX        mix,
FLONG      flOptions)
{
    BOOL  bRet;

#if DBG
    ASSERTGDI(bAllClosed(), "A sub-path in the filled path wasn't closed.");
#endif
    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

    INC_SURF_UNIQ(pSurf);

    if (pSurf->flags() & HOOK_StrokeAndFillPath)
    {
    // Pass the path to the driver if either it's not a wide line, or
    // if the driver says it can take wide lines:

        if (!(pla->fl & LA_GEOMETRIC) || (flCaps & GCAPS_GEOMETRICWIDE))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,StrokeAndFillPath),
                         "Driver hooked StrokeAndFillPath but didn't supply routine");

                    bRet = (*PPFNDRV(*pdo,StrokeAndFillPath)) (
                                                pSurf->pSurfobj(),
                                                (PATHOBJ*) this,
                                                pco,
                                                pxo,
                                                pboStroke,
                                                pla,
                                                pboFill,
                                                pptlBrushOrg,
                                                mix,
                                                flOptions);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,StrokeAndFillPath),
                 "Driver hooked StrokeAndFillPath but didn't supply routine");

            bRet = (*PPFNDRV(*pdo,StrokeAndFillPath)) (
                                        pSurf->pSurfobj(),
                                        (PATHOBJ*) this,
                                        pco,
                                        pxo,
                                        pboStroke,
                                        pla,
                                        pboFill,
                                        pptlBrushOrg,
                                        mix,
                                        flOptions);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    BOOL bDemote = FALSE;

// Can demote into separate Fill and Stroke calls if we're not doing a
// wide-line, or if we're doing a SRCCOPY and the display is raster, we
// can also demote (because in that case, we don't mind if we re-light
// pixels):

    if (!(pla->fl & LA_GEOMETRIC))
        bDemote = TRUE;
    else if ((mix & 0xFF) == R2_COPYPEN)
    {
        PDEVOBJ po(pSurf->hdev());
        if (po.ulTechnology() == DT_RASDISPLAY ||
            po.ulTechnology() == DT_RASPRINTER)
            bDemote = TRUE;
    }

    if (bDemote)
    {
        MIX mixFill, mixStroke;

        mixFill = mixStroke = mix;

        if (!((EBRUSHOBJ *)pboFill)->bIsMasking())
        {
            mixFill = (mix & 0xff) | ((mix & 0xff) << 8);
        }

        if (!((EBRUSHOBJ *)pboStroke)->bIsMasking())
        {
            mixStroke = (mix & 0xff) | ((mix & 0xff) << 8);
        }

        return(bSimpleFill(flCaps,
                           pdo,
                           pSurf,
                           pco,
                           pboFill,
                           pptlBrushOrg,
                           mixFill,
                           flOptions) &&
               bSimpleStroke(flCaps,
                             pdo,
                             pSurf,
                             pco,
                             pxo,
                             pboStroke,
                             pptlBrushOrg,
                             pla,
                             mixStroke));
    }

// Hand off to the engine simulation, which will nicely subtract the regions
// if necessary:

    return(EngStrokeAndFillPath(pSurf->pSurfobj(),
                                (PATHOBJ*) this,
                                pco,
                                pxo,
                                pboStroke,
                                pla,
                                pboFill,
                                pptlBrushOrg,
                                mix,
                                flOptions));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bStrokeAndOrFill(dco, pla, pexo, flType)
*
* Stroke and/or fills the path, depending on flType and the current pen
* and brush.
*
* Note that unless the only output operations you're doing is with the
* path, you probably want to do your own locking, pointer exclusion, etc.
* and call bSimpleStroke, bSimpleFill or bSimpleStrokeAndFill.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bStrokeAndOrFill(
XDCOBJ&    dco,
LINEATTRS* pla,
EXFORMOBJ* pexo,
FLONG      flType)
{
    ASSERTGDI(bValid(), "Invalid Path");
    ASSERTGDI(dco.bValid(), "Invalid DC");

    BOOL  bRet = FALSE;
    BOOL  bOpaqueStyle = FALSE;
    LONG  lOldStyleState;
    MIX   mix;
    BOOL  bCanDither;
    FLONG flOriginal;

// If there aren't any points (as may happen with consecutive calls to
// BeginPath and EndPath), we're all done -- don't let this get down to
// the driver, which won't expect it.

    if (cCurves == 0)
    {
        return(TRUE);
    }

    flOriginal = flType;

// Simplify if NULL pen or NULL brush:

    if (dco.pdc->pbrushLine() == gpPenNull)
    {
        flType &= ~PATH_STROKE;
    }

    if (dco.pdc->pbrushFill() == gpbrNull)
    {
        flType &= ~PATH_FILL;
    }

// If doing a wide line, have to adjust bounds:

    if (flType & PATH_STROKE)
    {
        if (pla->fl & LA_GEOMETRIC)
        {
            if (!bComputeWidenedBounds((XFORMOBJ*) pexo, pla))
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(bRet);
            }

        // We don't support preserving the style state accross DrvStrokePaths
        // in Product One for geometric lines, so make sure we always reset
        // the style state value:

            if (pla->pstyle != (PFLOAT_LONG) NULL)
                pla->elStyleState.e = IEEE_0_0F;
        }
    }

// Compute bound box and make it lower-right exclusive:

    ERECTL erclBoundsDevice(ppath->rcfxBoundBox);
    erclBoundsDevice.bottom++;
    erclBoundsDevice.right++;

    if (dco.fjAccum())
        dco.vAccumulate(erclBoundsDevice);

// If we're in FULLSCREEN mode, exit with success.

    if (dco.bFullScreen())                  // If in FULLSCREEN mode, exit.
        return(TRUE);

// Lock Rao region, VisRgn.  We would really like to do all the flattening,
// widening and converting to regions before we grab this, because they
// are time intensive and the DEVLOCK prevents any other screen updating.
// This might have to change if it becomes a performance issue.

    DEVLOCKOBJ dlo(dco);
    if (!dlo.bValid())
    {
        return(dco.bFullScreen());
    }

    if (dco.bDisplay() && !dco.bRedirection() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

    ERECTL erclBoundsScreen = erclBoundsDevice;
    erclBoundsScreen += dco.eptlOrigin();
    vOffset(dco.eptlOrigin());

    ECLIPOBJ eco(dco.prgnEffRao(), erclBoundsScreen);

// Might be able to do a quick-out:

    if ((dco.dctp() == DCTYPE_INFO) || eco.erclExclude().bEmpty())
    {
        if (flType & PATH_STROKE)
        {
            if ((pla->pstyle != (PFLOAT_LONG) NULL && !(pla->fl & LA_GEOMETRIC))
                || pla->fl & LA_ALTERNATE)
            {
                vUpdateCosmeticStyleState(dco.pSurface(), pla);
            }
        }

        bRet = TRUE;
        return(bRet);
    }

// Lock the destination surface and the ldev:

    SURFACE  *pSurfDest = dco.pSurface();
    PDEVOBJ   po(dco.hdev());
    XEPALOBJ  epalDest(pSurfDest->ppal());
    XEPALOBJ  epalDestDC(dco.ppal());

// Realize the brushes:

    EBRUSHOBJ  *peboPen = dco.peboLine();
    EBRUSHOBJ  *peboBrush = dco.peboFill();
    EBRUSHOBJ  *peboStroke = peboPen;

    if (flType & PATH_STROKE)
    {
        ASSERTGDI(pla != (LINEATTRS*) NULL, "Invalid LineAttrs for stroke");
        ASSERTGDI(!(pla->fl & LA_GEOMETRIC) || pexo != (EXFORMOBJ*) NULL,
                  "Invalid xform on geometric line");

        if (pla->fl & LA_GEOMETRIC)
        {
        // The bCanDither flag actually means 'bCanDitherIfBrushSaysSo' --
        // the brush has to be marked as ditherable AND bCanDither has to be
        // set before the brush is dithered:

            bCanDither = TRUE;

        // Because of Win3.1 compatibility, when the PS_INSIDEFRAME pen
        // is treated as a wideline, we can dither the brush.  But the
        // dither/can't dither decision depends on the transform,
        // and the last time we used this brush we may have realized
        // it as non-ditherable.

        // PS_INSIDEFRAME pens are reasonably rare, and realizing a brush
        // is relatively quick (particularly compared to the wide-line
        // rendering time), so if the cached brush is a solid color, we
        // simply mark the brush so that it will be re-realized (but only
        // for PS_INSIDEFRAME pens):

        // if the driver says dither (mainly for 8 color printer devices) we
        // can dither even if it is not InsideFrame.

        // Note: If the pen is dirty, we'll actually be looking at
        // uninitialized fields!  But that's okay, because we'd only be
        // marking the pen dirty again:

            if ((peboPen->iSolidColor != (ULONG) -1) &&
                (peboPen->bIsInsideFrame() || po.bCapsForceDither()))
            {
                dco.ulDirty(dco.ulDirty() | DIRTY_LINE);
            }
        }
        else
        {
        // Here we've got the opposite case.  When the transform is such
        // that a PS_INSIDEFRAME pen is treated as a cosmetic pen,
        // the brush has to be solid colored:

            bCanDither = FALSE;
            if (peboPen->iSolidColor == (ULONG) -1)
            {
                dco.ulDirty(dco.ulDirty() | DIRTY_LINE);
            }
        }

        if (dco.bDirtyBrush(DIRTY_LINE))
        {
            dco.vCleanBrush(DIRTY_LINE);

            peboPen->vInitBrush(dco.pdc,
                                dco.pdc->pbrushLine(),
                                epalDestDC, epalDest,
                                pSurfDest,
                                bCanDither);
        }

        if (pla->pstyle != (PFLOAT_LONG) NULL &&
            peboPen->bIsOldStylePen() &&
            dco.pdc->jBkMode() == OPAQUE &&
            !(pla->fl & LA_GEOMETRIC)) // Don't style wide Win3 pens
        {
        // If the background mode is OPAQUE, and we're styling with an
        // old Win3-style pen, we have to note it.  We do this styling in
        // two passes.  On the first pass, we use the opaque pen.

            bOpaqueStyle = TRUE;
            ASSERTGDI(peboPen->bIsDefaultStyle(), "Expect only default style");

        // Change the sense of the first element in the style array:

            pla->fl ^= LA_STARTGAP;
            lOldStyleState = pla->elStyleState.l;
            peboStroke     = dco.peboBackground();

        // Initialize the opaque pen:

        // The opaquing brush must be solid colored.  If the cached version
        // isn't solid colored, mark the cached entry as invalid so that
        // we'll re-realize.  I don't expect this to ever happen (we merely
        // implmement this for completeness), so it's hardly a performance
        // hit.

            if (!(dco.ulDirty() & DIRTY_BACKGROUND))
            {
                if (peboStroke->iSolidColor == (ULONG) -1)
                {
                    dco.ulDirty(dco.ulDirty() | DIRTY_BACKGROUND);
                }
            }

            if (dco.bDirtyBrush(DIRTY_BACKGROUND))
            {
                if((dco.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) == 0)
                {
                    // BUGFIX #27335 2-18-2000 bhouse
                    // We can clear the DIRTY_BACKGROUND bit only if
                    // we would have otherwise realized it without
                    // dithering enabled.

                    dco.vCleanBrush(DIRTY_BACKGROUND);
                }


                peboStroke->vInitBrush(
                             dco.pdc,
                             (PBRUSH)gpbrBackground,
                             epalDestDC, epalDest,
                             pSurfDest,
                             FALSE);        // False means can't dither
            }
        }

        mix = peboPen->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());
    }

    if (flType & PATH_FILL)
    {
        if (dco.bDirtyBrush(DIRTY_FILL))
        {
            dco.vCleanBrush(DIRTY_FILL);

            peboBrush->vInitBrush(dco.pdc,
                                  dco.pdc->pbrushFill(),
                                  epalDestDC, epalDest,
                                  pSurfDest);
        }

    // For StrokeAndFill, we can pass down only a single 'mix' that applies
    // to both brushes (normally, we don't want to pass down a transparent
    // mix when the brush is not a hatch because the mix is what the display/
    // printer driver cues off of to know if it has to do a transparent fill,
    // which it typically does very slowly).
    //
    // If either brush is a hatched brush, and the BkMode is TRANSPARENT,
    // then 'mix' must indicate a transparent mix.  The way it works here
    // is that if a transparent mix was already initialized for the pen, we
    // don't recompute the mix:

        if (!(flType & PATH_STROKE) ||
            ((mix >> 8) == (mix & 0xff)))
        {
            mix = peboBrush->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());
        }
    }

// Reset the path for enumeration:

    ppath->pprEnum = (PATHRECORD*) NULL;

// Exclude the pointer:

    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

    if ((flType == 0) && (po.ulTechnology() != DT_RASDISPLAY))
    {
    // Microsoft Publisher and Adobe Persuasion draw colored pattern
    // and gradient fills on Postscript by doing the following sequence:
    //
    //    1.  Send BEGIN_PATH printer escape;
    //    2.  Draw a path using a hollow brush and a NULL pen;
    //    3.  Send END_PATH escape;
    //    4.  Send CLIP_TO_PATH.
    //
    // The problem is that we used to detect these path cases and
    // optimize out the calls to the driver, so the clipping path
    // would never get down to Postscript.
    //
    // To fix this, we now detect this case and subsitute R2_NOP for
    // the mix instead, and in this manner the path will still get down
    // to the driver.  If the driver is not currently accumulating a
    // path, the right thing will still be printed: that is, nothing.

        flType = flOriginal;
        mix = ((R2_NOP << 8) | R2_NOP);
        pla = &glaSimpleStroke.la;         // Give them something to look at
    }

// Finally, make the necessary calls:

    switch(flType)
    {
    case 0:
        bRet = TRUE;
        break;

    case PATH_FILL:
        bRet = bSimpleFill(dco.flGraphicsCaps(),
                           &po,
                           pSurfDest,
                           &eco,
                           peboBrush,
                           &dco.pdc->ptlFillOrigin(),
                           mix,
                           dco.pdc->jFillMode());
        break;

    case PATH_STROKE:
        bRet = bSimpleStroke(dco.flGraphicsCaps(),
                             &po,
                             pSurfDest,
                             &eco,
                             (XFORMOBJ *) pexo,
                             peboStroke,
                             &dco.pdc->ptlFillOrigin(),
                             pla,
                             mix);
        break;

    case PATH_STROKE | PATH_FILL:
        bRet = bSimpleStrokeAndFill(dco.flGraphicsCaps(),
                                    &po,
                                    pSurfDest,
                                    &eco,
                                    (XFORMOBJ *) pexo,
                                    peboStroke,
                                    pla,
                                    peboBrush,
                                    &dco.pdc->ptlFillOrigin(),
                                    mix,
                                    dco.pdc->jFillMode());
        break;

    default:
        RIP("Woah Nellie!");
    }

// Do a second pass to draw the dashes for opaque styled lines:

    if (bOpaqueStyle)
    {
        pla->fl ^= LA_STARTGAP;
        pla->elStyleState.l = lOldStyleState;
        ppath->pprEnum = (PATHRECORD*) NULL;

        bRet &= bSimpleStroke(dco.flGraphicsCaps(),
                              &po,
                              pSurfDest,
                              &eco,
                              (XFORMOBJ *) pexo,
                              peboPen,
                              &dco.pdc->ptlFillOrigin(),
                              pla,
                              mix);
    }

    return(bRet);
}

//
//  Pathalloc structure
//
// We allocate the space for paths in blocks that are essentially
// independent of the chain used to order the pathdata records.  Typically
// we will have several ( or many ) pathdata records packed into each
// pathalloc block.  The pathalloc blocks for a path are all chained together
// using the ppanext pointers; the end of the chain is marked with a NULL
// pointer.
//
// Each pathalloc structure has two fields which describe the space available
// in the block; the 'start' field is the pointer to the start of the
// available space, and the 'end' field is the pointer to the address
// *following* the last valid address in the pathalloc.  Thus, the space
// remaining in the pathalloc can be computed as end - start.
//
// Routines to allocate and free pathalloc structures

/******************************Public*Routine******************************\
* friend BOOL bInitPathAlloc()
*
*   Initialize the freelist for pathallocs.  Get a semaphore, set the
*   freelist to empty.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL bInitPathAlloc()
{
    if ((PATHALLOC::hsemFreelist = GreCreateSemaphore()) == NULL)
    {
        return(FALSE);
    }

    PATHALLOC::freelist   = (PATHALLOC*) NULL;
    PATHALLOC::cFree      = 0;
    PATHALLOC::cAllocated = 0;

    return(TRUE);
}


/******************************Public*Routine******************************\
* friend void freepathalloc()
*
*   Deallocate a pathalloc.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID freepathalloc(PATHALLOC *ppa)
{
    ASSERTGDI(ppa->siztPathAlloc == PATHALLOCSIZE, "Not a heap PATHALLOC");

    SEMOBJ  so(PATHALLOC::hsemFreelist);

    if (PATHALLOC::cFree >= FREELIST_MAX)
    {
    // Free the memory if we've already got enough blocks on the freelist.

        VFREEMEM(ppa);
        PATHALLOC::cAllocated--;
    }
    else
    {
    // Keep around a couple of blocks on the freelist for fast access.

        ppa->ppanext = PATHALLOC::freelist;
        PATHALLOC::freelist = ppa;
        PATHALLOC::cFree++;
    }
}

/******************************Public*Routine******************************\
* friend PATHALLOC *newpathalloc()
*
*   Allocate a new pathalloc, taking it off the freelist unless the
*   freelist is empty.  In that case, just allocate a new one
*
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PPATHALLOC newpathalloc()
{
    SEMOBJ  so(PATHALLOC::hsemFreelist);

    register PPATHALLOC ppaNew = PATHALLOC::freelist;

    if ( ppaNew != (PPATHALLOC) NULL )
    {
        PATHALLOC::freelist = ppaNew->ppanext;
        PATHALLOC::cFree--;
    }
    else
    {
        ppaNew = (PPATHALLOC) PALLOCMEM(PATHALLOCSIZE, 'tapG');

        if (ppaNew == (PPATHALLOC) NULL)
            return((PPATHALLOC) NULL);

        PATHALLOC::cAllocated++;
    }

// Initialize the pathalloc structure:

    ppaNew->pprfreestart  = &(ppaNew->apr[0]);
    ppaNew->ppanext       = (PATHALLOC*) NULL;
    ppaNew->siztPathAlloc = PATHALLOCSIZE;

    return(ppaNew);
}

/******************************Public*Routine******************************\
* BOOL bSavePath(dco, lSave)
*
* Lazily save the DC's active or inactive path.  We only actually copy
* the path when the user starts mucking around with it.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSavePath(XDCOBJ& dco, LONG lSave)
{
    DONTUSE(lSave);

// If there's a path in the DC (either active or inactive), make a note
// to save it when it's about to be modified:

    if (dco.hpath() != HPATH_INVALID)
        dco.pdc->vSetLazySave();

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vRestorePath(dco, lSave)
*
* Restore the active path.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vRestorePath(XDCOBJ& dco, LONG lSave)
{
    DONTUSE(lSave);

// If there's a path in the DC, and the bLazySave flag isn't set, it means
// that it's a new path created at this level, so we have to nuke it:

    if (dco.hpath() != HPATH_INVALID && !dco.pdc->bLazySave())
    {
        XEPATHOBJ epath(dco.hpath());
        ASSERTGDI(epath.bValid(), "Invalid DC path");

        epath.vDelete();
        dco.pdc->vDestroy();
    }
}

/******************************Member*Function*****************************\
* BOOL EPATHOBJ::bAllClosed()
*
*  If a fill is to be done on the path, every subpath must be have been
*  explicitly marked as closed.  This routine returns TRUE if all subpaths
*  have be closed.
*
*  Note: This is needed in checked builds only!
*
* History:
*  77-Nov-1993 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bAllClosed()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_ENDSUBPATH)
        {
            if (!(ppr->flags & PD_CLOSEFIGURE))
                return(FALSE);
        }
        else
        {
            ASSERTGDI(!(ppr->flags & PD_CLOSEFIGURE),
                      "Shouldn't be a close figure when not end of subpath");
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID EPATHOBJ::vPrint()
*
* Prints the path points, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vPrint()
{
    DbgPrint("cCurves: %li  fl: %lx\n", cCurves, fl);

    PPATHREC ppr;
    for (ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
    {
        DbgPrint("\n%li: ", ppr->flags);
        COUNT ii;
        for (ii = 0; ii < ppr->count; ii++)
            DbgPrint("(%li, %li) ", ppr->aptfx[ii].x, ppr->aptfx[ii].y);
    }
    DbgPrint("\n");
}

/******************************Public*Routine******************************\
* VOID EPATHOBJ::vPrint()
*
* Prints the path structure, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vDiag()
{
    DbgPrint("flType: %lx\n", ppath->flType);

    DbgPrint("Chain: %p  PprFirst: %p   PprLast: %p\n",
              ppath->ppachain, ppath->pprfirst, ppath->pprlast);

    for (PPATHALLOC ppa = ppath->ppachain; ppa != NULL; ppa = ppa->ppanext)
        DbgPrint("  ppa: %p  ppaNext: %p  pprFreeStart: %p  sizt: %li\n",
              ppa, ppa->ppanext, ppa->pprfreestart, ppa->siztPathAlloc);

    for (PPATHREC ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
        DbgPrint("    ppr: %p  pprNext: %p  pprPrev: %p  count: %li  flags: %li\n",
              ppr, ppr->pprnext, ppr->pprprev, ppr->count, ppr->flags);
}

/******************************Public*Routine******************************\
* VOID vPathDebug()
*
* Prints the number of currently allocated PATHALLOCs, and the number of
* PATHALLOCs available on the free list, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vPathDebug()
{
    SEMOBJ so(PATHALLOC::hsemFreelist);

    DbgPrint("F: %li A: %li\n", PATHALLOC::cFree, PATHALLOC::cAllocated);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pathwide.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathwide.cxx
*
* This module generates the outlines for geometric wide-lines.  Given
* a path for a line, it generates a new path that, when filled using
* a winding mode fill, yields the resulting widened line.
*
* Geometric wide-lines may have different end-cap and line-join
* attributes.  They may also be styled.
*
* THINGS TO NOTE
*
* The path is already in device coordinates, so the resulting wide-line
* is also calculated in device coordinates.
*
* The key thing to note is that the pen's shape is defined in world space, so
* its shape in device space depends on the current world-to-device
* transform (which may be an arbitrary 2 by 2 affine transform).  Pens
* are circular in world space, with their diameter there defined by the
* pen width.  However, in device space a pen shape is only guaranteed to be
* an ellipse symmetrical about some arbitrary axis.  And vectors that are
* perpendicular in world space are not necessarily perpendicular in device
* space (which is important for calculating flat and square end-caps, and
* bevel joins).
*
* HOW WE DO IT
*
* We implement wide-lines by first generating in device space a convex
* polygonal approximation to the pen's shape.  We 'drag' this polygon
* along the given path; the outline of a widened line is generated by
* the point on the pen polygon that is furthest from the line's ray
* (called the 'draw' vertex).  This point may be found by a simple
* binary search using entirely integer arithmetic.
*
* This approach makes round round joins and round caps very efficient:
* the points for the resulting round part is simply the points between
* draw vertices.
*
* To compute true perpendiculars (for flat and square end-caps, and
* bevel joins) we interpolate between vertices on the pen polygon
* (once again using only integer math).
*
* The lengths of the dashes and gaps for styled lines are defined in
* world space; to do styling we computed every line segment's length
* in world space, and divide it accordingly.
*
* HOBBY WIDE-LINES
*
* Rendering the wide-lines using a polygonized pen allows us to take
* advantage of Hobby wide-lines.  Hobby's wide-line algorithm
* generates 'optimally shaped' pens that will yield lines of constant-
* looking width, independent of the direction of the lines.  (OS/2's
* PM suffers from having its thin wide-lines appear not to be of
* constant width).
*
* Unfortunately, Hobby's algorithm is fairly expensive to generate an
* optimal pen shape polygon given its width and the current transform;
* it is significantly faster for us to generate a quick-and-dirty
* polygon approximation by creating the ellipse out of Bezier curves and
* flattening it.
*
* But Hobby pens are most important for small, near circular pens,
* where the eye can readily detect imperfections in the line.  So we
* support Hobby wide-lines only for small, near circular pens, and we
* keep these pen shapes in a pre-computed table.
*
* See:
*
*   John Hobby, "Digitized Brush Trajectories", PhD Dissertation,
*       Stanford University, August 1985
*
* GENERATING BOTH SIDES AT THE SAME TIME
*
* We also generate both sides of the wide-line outline as we traverse
* the path, keeping track of both sides in separate paths (the outlines
* of the 'left' and 'right' sides of the wide-line).  When the end of a
* figure (that is, the end of a sub-path) is reached, we reverse all the
* points in the 'left' path and append it to the 'right', and close the
* result.
*
* This could have been implemented by traversing the path once to generate
* one side, then traversing it again in the reverse direction to generate
* the other side.  However, most of the hard computations for perpendiculars
* and such would have to be done twice.  Our method is faster, although
* there is more book-keeping.
*
* BEZIERS
*
* We really only know how to widen lines, so we convert Beziers as we
* read them to their polyline approximations.  We 'flatten' Beziers to
* constant error, independent of pen width, and make sure we apply 'round'
* joins to the interior polylines comprising the Bezier.  The round join
* handles extreme cases such as cusps, so there really is no need to
* flatten to less error for larger pens.
*
* (This is in contrast to OS/2's PM which pre-flattens its curves prior
* to widening, and applies the regular joins to the interior of the curve.
* For wider pens, the allowed error in the flattening must be decreased
* because sharp curves would not look 'round' at cusp-points when using
* bevel or miter joins.)
*
* We flatten Bezier curves as we traverse path (instead of only widening
* paths that are already flattened) because it is useful to know the
* Bezier data.  We use the control points to calculate true perpendiculars
* at the end-points of curves, and we have to know when we're in the
* interior of the Bezier to always apply round joins.
*
* Advantages:  o We're much faster
*
*              o Produce better looking curves
*
* Disadvantages:  o More book-keeping
*
*                 o Have to be careful when mixing perpendiculars (such
*                   as from miter joins or flat caps) with round joins
*
*                 o Perpendiculars on styled curves may not be as accurate
*                   for wide-lines -- we use the approximating lines to
*                   calculate the perp, and more lines would give better
*                   perps.
*
*                   However, it can also be argued that due to the
*                   snapping effect of the device-space grid, approximating
*                   the curve into more small lines would actually make
*                   the perps _less_ accurate.
*
* LAZY EVALUATION
*
* Computing draw vectors and perpendiculars are very expensive operations,
* so we lazily evaluate them -- we compute them only when we need them.
* With styling, it may happen we completely skip over some lines (so we
* never do any evaluation), or that we break a line into many small pieces,
* and so re-use perps and draw-vectors (saving us time and ensuring that
* style ends are always perpendicular for styled segments).
*
* Created: 23-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "flhack.hxx"
#include "pathwide.hxx"

#ifdef DEBUG_WIDE
    #define INLINE
#else
    #define INLINE inline
#endif

#ifdef DEBUG_WIDE

LONG lConv(EFLOAT ef);

#endif

POINTFIX WIDEPENOBJ::aptfxHobby1[] = {
    {0, 8},    {8, 0},     {0, -8},    {-8, 0}
};

POINTFIX WIDEPENOBJ::aptfxHobby2[] = {
    {8, 16},   {16, 0},    {8, -16},   {-8, -16},
    {-16, 0}
};

POINTFIX WIDEPENOBJ::aptfxHobby3[] = {
    {24, 8},   {24, -8},   {8, -24},   {-8, -24},
    {-24, -8}, {-24, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby4[] = {
    {32, 8},   {32, -8},   {24, -24},  {8, -32},
    {-8, -32}, {-24, -24}, {-32, -8},  {-32, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby5[] = {
    {40, 8},   {40, -8},   {32, -24},  {24, -32},
    {8, -40},  {-8, -40},  {-24, -32}, {-32, -24},
    {-40, -8}, {-40, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby6[] = {
    {48, 8},   {48, -8},   {40, -24},  {24, -40},
    {8, -48},  {-8, -48},  {-24, -40}, {-40, -24},
    {-48, -8}, {-48, 8}
};

HOBBY WIDEPENOBJ::ahob[HOBBY_TABLE_SIZE] = {
    { aptfxHobby1, sizeof(aptfxHobby1) / sizeof(POINTFIX) },
    { aptfxHobby2, sizeof(aptfxHobby2) / sizeof(POINTFIX) },
    { aptfxHobby3, sizeof(aptfxHobby3) / sizeof(POINTFIX) },
    { aptfxHobby4, sizeof(aptfxHobby4) / sizeof(POINTFIX) },
    { aptfxHobby5, sizeof(aptfxHobby5) / sizeof(POINTFIX) },
    { aptfxHobby6, sizeof(aptfxHobby6) / sizeof(POINTFIX) }
};

/******************************Public*Routine******************************\
* bTurnLeftRandom(pa, pb)
*
* Returns TRUE if the sign of the cross product of a X b is positive.
* For simple minds like mine, it returns:
*
*    TRUE if b 'turns left' from a (cross product is < 0)
*    FALSE if b is parallel to or 'turns right' from a (cross is >= 0)
*
* When the vectors are random, half the time we take a short-cut by
* checking the signs.  Remember that we're in device space, where
* positive 'y' is down!
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bTurnLeftRandom(
PEVECTORFX pa,
PEVECTORFX pb)
{
    BOOL bRet;

// If the signs are correct, we don't even have to multiply:

    if ((pa->x ^ pa->y ^ pb->x ^ pb->y) < 0)
        bRet = ((pa->x ^ pb->y) < 0);
    else
    {
        LONGLONG ad;
        LONGLONG bc;

    // Check sign of (pa->x * pb->y - pa->y * pb->x) = (ad - bc)

        ad = Int32x32To64(pa->x, pb->y);
        bc = Int32x32To64(pa->y, pb->x);

        bRet = (ad < bc);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::bGrowPath()
*
* Creates a new path record.  Adds to the end of the path, and sets
* 'pptfxPathRecCurrent' and 'pptfxPathRecEnd'.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Stole it from PaulB's pprFlattenRec.
\**************************************************************************/

BOOL WIDEPATHOBJ::bGrowPath()
{
    PPATHALLOC ppa = ppath->ppachain;

    COUNT cMax = 0;

    if (ppa != (PPATHALLOC) NULL)
    {
    // We have a current pathalloc, see how much will fit
    // computation done into temps to avoid compiler assertion!

        PPOINTFIX pptfxStart = &(ppa->pprfreestart->aptfx[0]);
        PPOINTFIX pptfxEnd   = (PPOINTFIX) ((char *)ppa + ppa->siztPathAlloc);

        if (pptfxEnd > pptfxStart)
        {
            //Sundown truncation
            ASSERT4GB((ULONGLONG)(pptfxEnd - pptfxStart));
            cMax = (COUNT)(pptfxEnd - pptfxStart);
        }
    }

// Now we can decide if we need a new pathalloc

    if (cMax < PATHALLOCTHRESHOLD)
    {
    // allocate a new pathalloc, link it into path

        if ( (ppa = newpathalloc()) == (PPATHALLOC) NULL)
            return(FALSE);

        ppa->ppanext    = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

    // Sundown truncation
        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONGSIZE_T numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);
        cMax = (numbytes - offsetof(PATHRECORD, aptfx))/sizeof(POINTFIX);
    }

// Add pathrecord to end of path

    PPATHREC pprNew = ppa->pprfreestart;

    if (ppath->pprlast == (PPATHREC) NULL)
    {
        ppath->pprfirst = pprNew;
        pprNew->pprprev = (PPATHREC) NULL;
    }
    else
    {
        ppath->pprlast->pprnext = pprNew;
        pprNew->pprprev         = ppath->pprlast;
    }

    ppath->pprlast  = pprNew;
    pprNew->pprnext = (PPATHREC) NULL;
    pprNew->count = 0;

// pptfxPathRecCurrent points to first available spot.  pptfxPathRecEnd
// points to first spot *after* the last available spot.

    pptfxPathRecCurrent = &pprNew->aptfx[0];
    pptfxPathRecEnd     = &pprNew->aptfx[cMax];

    return(TRUE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vGrowPathAndAddPoint(pptfx)
*
* Adds to the current path by creating a new record and adding the
* specified point.  If this fails, the path is marked as being out-of-
* memory.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vGrowPathAndAddPoint(
PPOINTFIX  pptfx,
PEVECTORFX pvec,
BOOL       bInvert)
{
    ASSERT4GB((LONGLONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx));

    COUNT cpt = (COUNT)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ppath->pprlast->count         = cpt;
    ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);

    if (bValid())
    {
        if (!bGrowPath())
            vSetError();

        else
        {
            ppath->pprlast->flags = 0;
            *pptfxPathRecCurrent = *pptfx;

            if (pvec != (PEVECTORFX) NULL)
            {
                if (bInvert)
                {
                    pptfxPathRecCurrent->x -= pvec->x;
                    pptfxPathRecCurrent->y -= pvec->y;
                }
                else
                {
                    pptfxPathRecCurrent->x += pvec->x;
                    pptfxPathRecCurrent->y += pvec->y;
                }
            }

            pptfxPathRecCurrent++;
        }
    }
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::bBeginFigure()
*
* Creates the start of a new figure (sub-path) in the path.  Must be
* called before vAddPoint().
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPATHOBJ::bBeginFigure()
{
    if (bValid())
    {
        #ifdef DEBUG_WIDE
        ASSERTGDI(!bOpenPath, "BeginFigure on already open path!");
        bOpenPath = TRUE;
        #endif

        if (bGrowPath())
        {
            ppath->pprlast->flags = PD_BEGINSUBPATH;
            return(TRUE);
        }

        vSetError();
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vEndFigure()
*
* Ends the open figure.  Must be called after all vAddPoint()'s are done
* for the figure.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vEndFigure()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(bOpenPath, "vEndFigure on unopen path!");
    bOpenPath = FALSE;
#endif
    //Sundown truncation
    ASSERT4GB((ULONGLONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx));
    COUNT cpt = (COUNT)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ppath->pprlast->flags |= PD_ENDSUBPATH;
    ppath->pprlast->count = cpt;

// Adjust the pathalloc record:

    ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vPrependBeforeFigure()
*
* Moves the last figure in path and prepends to the first figure.
*
* History:
*  24-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDEPATHOBJ::vPrependBeforeFigure()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(!bOpenPath, "vPrependBeforeFigure on open path!");
#endif

    PPATHREC pprSrcStart;
    PPATHREC pprTargStart;

// Find the start of the last figure:

    pprSrcStart = ppath->pprlast;
    while (!(pprSrcStart->flags & PD_BEGINSUBPATH))
    {
        pprSrcStart = pprSrcStart->pprprev;
        ASSERTGDI(pprSrcStart != (PPATHREC) NULL, "Couldn't find start");
    }

// Find the start of the 2nd last figure:

    pprTargStart = pprFigureStart;
    ASSERTGDI(pprTargStart != (PPATHREC) NULL &&
             (pprTargStart->flags & PD_BEGINSUBPATH), "Funky pprFigureStart");

    PPATHREC pprTargEnd   = pprSrcStart->pprprev;
    PPATHREC pprSrcEnd    = ppath->pprlast;

// 'targ' is currently before 'src', and 'src' is the last figure in the
// path.  We'll move 'src' to be before 'targ':

    ppath->pprlast = pprTargEnd;

// Hmmm, seems to me we're guaranteed to have pprprev NULL here because
// we're looking at the start of the path:

    if (pprTargStart->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprSrcStart;
    else
        pprTargStart->pprprev->pprnext = pprSrcStart;

    pprSrcStart->pprprev  = pprTargStart->pprprev;
    pprSrcEnd->pprnext    = pprTargStart;
    pprTargStart->pprprev = pprSrcEnd;
    pprTargEnd->pprnext   = (PPATHREC) NULL;

// We're prepending this to the start of the first figure, so clean up
// the flags:

    pprTargStart->flags &= ~PD_BEGINSUBPATH;
    pprSrcEnd->flags    &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vPrependBeforeSubpath()
*
* Moves the last figure in path and prepends it to the previous subpath.
*
* History:
*  24-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDEPATHOBJ::vPrependBeforeSubpath()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(!bOpenPath, "vPrependBeforeSubpath on open path!");
#endif

    PPATHREC pprSrcStart;
    PPATHREC pprTargStart;

// Find the start of the last figure:

    pprSrcStart = ppath->pprlast;
    while (!(pprSrcStart->flags & PD_BEGINSUBPATH))
    {
        pprSrcStart = pprSrcStart->pprprev;
        ASSERTGDI(pprSrcStart != (PPATHREC) NULL, "Couldn't find start");
    }

// Find the start of the 2nd last figure:

    ASSERTGDI(pprSrcStart->pprprev != (PPATHREC) NULL, "Was no previous figure");

    pprTargStart = pprSrcStart->pprprev;
    while (!(pprTargStart->flags & PD_BEGINSUBPATH))
    {
        pprTargStart = pprTargStart->pprprev;
        ASSERTGDI(pprTargStart != (PPATHREC) NULL, "Couldn't find previous figure");
    }

    PPATHREC pprTargEnd   = pprSrcStart->pprprev;
    PPATHREC pprSrcEnd    = ppath->pprlast;

// 'targ' is currently before 'src', and 'src' is the last figure in the
// path.  We'll move 'src' to be before 'targ':

    ppath->pprlast = pprTargEnd;

    if (pprTargStart->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprSrcStart;
    else
        pprTargStart->pprprev->pprnext = pprSrcStart;

    pprSrcStart->pprprev  = pprTargStart->pprprev;
    pprSrcEnd->pprnext    = pprTargStart;
    pprTargStart->pprprev = pprSrcEnd;
    pprTargEnd->pprnext   = (PPATHREC) NULL;

// We're prepending this to the start of the first figure, so clean up
// the flags:

    pprTargStart->flags &= ~PD_BEGINSUBPATH;
    pprSrcEnd->flags    &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vReverseConcatenate(wpo)
*
* Reverses 'wpo' and adds all points to the end of this path.
* bBeginFigure() must have been called previously for this path, and
* 'wpo' must be ended by calling vEndFigure().
*
* The path records of 'wpo' are freed as they are copied (in order to
* decrease the total number of path records needed by both paths).  As such,
* 'wpo' must be entirely one figure!
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vReverseConcatenate(WIDEPATHOBJ& wpo)
{
#ifdef DEBUG_WIDE
    ASSERTGDI(bOpenPath, "vReverseConcatenate on closed target!");
    ASSERTGDI(!wpo.bOpenPath, "vReverseConcatenate on open source!");
#endif

    ASSERTGDI(bValid(), "Reverse invalid path");

    ASSERTGDI(wpo.ppath->pprfirst != (PPATHREC) NULL, "NULL path 1");
    ASSERTGDI(wpo.ppath->ppachain != (PPATHALLOC) NULL, "NULL path 2");
    ASSERTGDI(ppath->pprfirst != (PPATHREC) NULL, "NULL path 3");
    ASSERTGDI(ppath->ppachain != (PPATHALLOC) NULL, "NULL path 4");

// Reverse the path:

    PPATHREC ppr = wpo.ppath->pprlast;
    while (ppr != (PPATHREC) NULL)
    {
        PPATHREC pprPrev = ppr->pprprev;

        PPOINTFIX pptfxStart;
        PPOINTFIX pptfxEnd;

    // Copy all the points in reverse order:

        pptfxStart = &ppr->aptfx[0];
        pptfxEnd   = &ppr->aptfx[ppr->count];

        while (pptfxEnd > pptfxStart)
            vAddPoint(--pptfxEnd);

        PPATHALLOC ppaEnd = wpo.ppath->ppachain;

        ASSERTGDI(ppaEnd != (PPATHALLOC) NULL, "Null pathalloc");

        wpo.ppath->ppachain = ppaEnd->ppanext;

        ASSERTGDI(((PBYTE) pptfxStart > (PBYTE) ppaEnd) &&
           ((PBYTE) pptfxStart - (PBYTE) ppaEnd) < (LONG) ppaEnd->siztPathAlloc,
           "Last pathrec doesn't correspond to last pathalloc");

        freepathalloc(ppaEnd);

        ppr = pprPrev;
    }

    ASSERTGDI(wpo.ppath->ppachain == (PPATHALLOC) NULL,
              "Didn't delete entire chain");

// Clean up old path:

    wpo.ppath->ppachain = (PPATHALLOC) NULL;
    wpo.ppath->pprlast  = (PPATHREC) NULL;
    wpo.ppath->pprfirst = (PPATHREC) NULL;
}

/******************************Public*Routine******************************\
* vHalve(vec)
*
* Halves the vector, and always rounds 1/32 up.  Symmetric about zero.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vHalve(EVECTORFX& vec)
{
    if (vec.x >= 0)
        vec.x++;
    if (vec.y >= 0)
        vec.y++;

    vec.x >>= 1;
    vec.y >>= 1;
}


/******************************Public*Routine******************************\
* vVecSymmetricRound(pvec)
*
* Always rounds 1/2 up.  Symmetric about zero.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vVecSymmetricRound(PEVECTORFX pvec)
{
// Round 1/2 up:

    if (pvec->x >= 0)
        pvec->x = (pvec->x + 4) & ~7L;
    else
        pvec->x = (pvec->x + 3) & ~7L;

    if (pvec->y >= 0)
        pvec->y = (pvec->y + 4) & ~7L;
    else
        pvec->y = (pvec->y + 3) & ~7L;
}


/******************************Public*Routine******************************\
* vVecRound(pvec)
*
* Always rounds 1/2 down for 'x'.  Rounds 1/2 up for 'y'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vVecRound(PEVECTORFX pvec)
{
// Round 1/2 down:

    if (pvec->x >= 0)
        pvec->x = (pvec->x + 3) & ~7L;
    else
        pvec->x = (pvec->x + 4) & ~7L;

// Round 1/2 up:

    if (pvec->y >= 0)
        pvec->y = (pvec->y + 4) & ~7L;
    else
        pvec->y = (pvec->y + 3) & ~7L;
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bHobbyize(avecAxis[])
*
* Will copy a pre-computed Hobby pen polygon if the pen is small and
* circular.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bHobbyize(EVECTORFX avecAxis[])
{
    ASSERTGDI(((avecAxis[0].x == avecAxis[1].y) && (avecAxis[0].y == -avecAxis[1].x))
           || ((avecAxis[0].x == -avecAxis[1].y) && (avecAxis[0].y == avecAxis[1].x)),
        "Must be orthogonal and circular");

    ASSERTGDI((MAX(ABS(avecAxis[0].x), ABS(avecAxis[0].y))
           < LPLUSHALFTOFX(HOBBY_TABLE_SIZE)), "Must be Hobby sized");

// We now know that the transform was orthogonal, and that the pen is
// circular in device space.

// We now know that the vector coordinates have less than 15 bits
// signficance, so we can safely compute its Euclidean length in
// 32 bits:

    FIX fxPenWidthSquared = avecAxis[0].x * avecAxis[0].x
                          + avecAxis[0].y * avecAxis[0].y;

    if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(HOBBY_TABLE_SIZE)))
    {
    // Pen is small enough that it will be in our Hobby tables:

        LONG iHobbyPen;

        if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(1)))
            iHobbyPen = 0;                 // Width less than 1.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(2)))
            iHobbyPen = 1;                 // Width less than 2.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(3)))
            iHobbyPen = 2;                 // Width less than 3.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(4)))
            iHobbyPen = 3;                 // Width less than 4.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(5)))
            iHobbyPen = 4;                 // Width less than 5.5
        else
        {
            #if (HOBBY_TABLE_SIZE != 6L)
            #error "Table size changed, update routine"
            #endif

            iHobbyPen = 5;                 // Width less than 6.5
        }

    // Copy the Hobby pen from the table to our path:

        if (!bBeginFigure())
            return(FALSE);

        PPOINTFIX pptfx    = ahob[iHobbyPen].pptfx;
        PPOINTFIX pptfxEnd = pptfx + ahob[iHobbyPen].cptfx;

        while (pptfx < pptfxEnd)
            vAddPoint(pptfx++);

        vEndFigure();
        bIsHobby(TRUE);

        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bThicken(aptfxDiameter)
*
* Check if the pen is so thin in one dimension that it would be invisible
* for some lines.  If so, thicken it.
*
* History:
*  31-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define FX_HALF         (LTOFX(1) >> 1)
#define FX_HALF_SQUARED (FX_HALF * FX_HALF)

BOOL WIDEPENOBJ::bThicken(PPOINTFIX aptfxDiameter)
{
// The aptfxDiameter vectors passed to us were constructed from the
// diameter of the pen -- we actually want the vectors as based on
// the radius, so halve them:

    EVECTORFX aevecTmp[2];
    PPOINTFIX aptfx = (PPOINTFIX) aevecTmp;

    aevecTmp[0] = aptfxDiameter[0];
    aevecTmp[1] = aptfxDiameter[1];
    vHalve(aevecTmp[0]);
    vHalve(aevecTmp[1]);

// What I would like to do is compute the length of the minor-axis of
// the pen ellipse in device coordinates -- if its length is less than
// half a pixel, we know we have to thicken the pen.
//
// But it's a lot of computation to do that (see Knuth, "Metafont",
// p. 382).  So, we take the two vectors that described the axis of
// the ellipse in world space, and transform them to device space (call
// them 'avec').  The perpendicular distance from the smaller vector
// to the larger will be close to the minor-axis length.

// Make sure we won't overflow:

    if (((ABS(aptfx[0].x) | ABS(aptfx[0].y) | ABS(aptfx[1].x) | ABS(aptfx[1].y))
      & ~(0xfffL)) != 0)
        return(FALSE);

    FIX fxLengthSquared0 = aptfx[0].x * aptfx[0].x + aptfx[0].y * aptfx[0].y;
    FIX fxLengthSquared1 = aptfx[1].x * aptfx[1].x + aptfx[1].y * aptfx[1].y;

    POINTFIX ptfx;         // Will be the largest vector
    FIX      fxLength;     // Length of largest vector

//
// We use the forumla to compute the distance from a point to a line
// from the origin, where 'd' is the distance, 'B' is the vector,
// 'P' is the point:
//
//                                          2
//      2   4 [ (P.y * B.x) - (P.x * B.y) ]
//     d  = -------------------------------
//               B.x * B.x + B.y * B.y
//
// We want to exit early when the distance is more than 1/2 pixel (8 in
// FIX units), i.e. HALF < d or:
//
//          2     2      2                                   2
//      HALF  (B.x  + B.y ) < 4 [ (P.y * B.x) - (P.x * B.y) ]
//

    if (fxLengthSquared0 > fxLengthSquared1)
    {
    // Vector 0 is bigger than 1:

        FIX fxNum = aptfx[1].y * aptfx[0].x - aptfx[1].x * aptfx[0].y;

        LONGLONG eqLeft  = (LONGLONG) fxLengthSquared0 * (FX_HALF_SQUARED >> 2);
        LONGLONG eqRight = Int32x32To64((LONG) fxNum, (LONG) fxNum);

        if (eqLeft < eqRight)
            return(FALSE);

        ptfx = aptfx[0];
        fxLength = fxLengthSquared0;
    }
    else
    {
    // Vector 1 is bigger than (or equal to) 0:

        FIX fxNum = aptfx[0].y * aptfx[1].x - aptfx[0].x * aptfx[1].y;

        LONGLONG eqLeft = (LONGLONG) fxLengthSquared1 * (FX_HALF_SQUARED >> 2);
        LONGLONG eqRight = Int32x32To64((LONG) fxNum, (LONG) fxNum);

        if (eqLeft < eqRight)
            return(FALSE);

        ptfx = aptfx[1];
        fxLength = fxLengthSquared1;
    }

// Make sure that the largest vector extends outside the unit circle (if
// it's not, we'll make it so that we end up with the entire Hobby pen
// for width 1):

    if (fxLength < FX_HALF_SQUARED)
    {
        ptfx.x = FX_HALF;
        ptfx.y = 0;
    }

// Okay, we know the larger vector, and we have to fix the smaller one.
// Let's simply figure out the vertex on the Hobby pen of width 1 that
// would be used if we drew a line in the same direction as our large
// vector (which is when our given pen is its thinest).
//
// So let's compute the appropriate Hobby vector of size one (making
// sure it's to the 'left' of the big vector, because the vertices have to
// be in counter-clockwise order):

    POINTFIX ptfxHobby;

    if (ABS(ptfx.y) <= ptfx.x)
    {
        ptfxHobby.x = 0;
        ptfxHobby.y = -FX_HALF;
    }
    else if (ABS(ptfx.x) <= -ptfx.y)
    {
        ptfxHobby.x = -FX_HALF;
        ptfxHobby.y = 0;
    }
    else if (ABS(ptfx.y) <= -ptfx.x)
    {
        ptfxHobby.x = 0;
        ptfxHobby.y = FX_HALF;
    }
    else
    {
        ASSERTGDI(ABS(ptfx.x) <= ptfx.y, "Oops");
        ptfxHobby.x = FX_HALF;
        ptfxHobby.y = 0;
    }

// Put stuff into path, remembering that 'pptfx' points to either
// ppath->pprlast->aptfx[0] or [1].  Also, we have to be in counter-
// clockwise order.

    if (!bBeginFigure())
        return(FALSE);

    vAddPoint(&ptfx);
    vAddPoint(&ptfxHobby);

    ptfx.x = -ptfx.x;
    ptfx.y = -ptfx.y;
    ptfxHobby.x = -ptfxHobby.x;
    ptfxHobby.y = -ptfxHobby.y;

    vAddPoint(&ptfx);
    vAddPoint(&ptfxHobby);

    vEndFigure();
    return(TRUE);
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bPenFlatten(pptfxControl)
*
* Flattens a geometric pen object.  pptfxControl points to the 7 control
* points of a half-ellipse.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bPenFlatten(PPOINTFIX pptfxControl)
{
    if (!bGrowPath())
        return(FALSE);

    ASSERTGDI(pptfxPathRecEnd - pptfxPathRecCurrent > 2, "Path rec too small");

    ppath->pprlast->flags = PD_BEGINSUBPATH;

// Leave room to insert a point at the beginning of the path.  Also leave
// room for an additional point at the end of the path record:

    PPOINTFIX pptfxFirst = pptfxPathRecCurrent;
    pptfxPathRecCurrent++;
    pptfxPathRecEnd--;

// Don't forget the very first point:

    *pptfxPathRecCurrent++ = *pptfxControl;

// We'll crack 2 Beziers:

    for (LONG ll = 0; ll <= 1; ll++, pptfxControl += 3)
    {
        BOOL bMore;
        BEZIER bez;
        bez.vInit(pptfxControl);

        do
        {
            bMore = bez.bNext(pptfxPathRecCurrent++);

            if (!bMore)
                break;

        // Check if we have to create a new path record:

            if (pptfxPathRecCurrent > pptfxPathRecEnd)
            {
            // Wrap up old path record:

                ASSERTGDI(pptfxPathRecCurrent == pptfxPathRecEnd + 1,
                          "Cur != End + 1");

            // We want to repeat the last edge of this path record as the
            // first edge in the next.  That means repeating two points
            // (remember that we left room for one more point in this record):

                PPOINTFIX pptfxPrev = pptfxPathRecCurrent - 2;

            // Sundown truncation
                ppath->pprlast->count = (ULONG)(pptfxPathRecCurrent
                                      - ppath->pprlast->aptfx);

                ASSERTGDI(ppath->pprlast->count >= 3,
                          "Pen pathrecord doesn't have 3 vertices");

                ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);

            // Create a new path record:

                if (!bGrowPath())
                    return(FALSE);

                ppath->pprlast->flags = 0;

            // Repeat those two points in the new path record:

                *pptfxPathRecCurrent++ = *(pptfxPrev);
                *pptfxPathRecCurrent++ = *(pptfxPrev + 1);

            // Don't forget to leave room for an additional point at the
            // end of the record:

                pptfxPathRecEnd--;

            }
        } while (1);
    }

// The pen covers 180 degrees of the ellipse.  The first and last edges
// of the pen must be parallel, their vectors in opposite directions.
// The last point in the path is already the opposite of the first.  Now
// make the zeroth point the opposite of the second last and voila,
// parallel edges.

    pptfxFirst->x = - (pptfxPathRecCurrent - 2)->x;
    pptfxFirst->y = - (pptfxPathRecCurrent - 2)->y;

    ppath->pprlast->flags |= PD_ENDSUBPATH;
    // Sundown truncation
    ppath->pprlast->count = (ULONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ASSERTGDI(ppath->pprlast->count >= 3,
              "Final pen pathrecord doesn't have 3 vertices");

    return(TRUE);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::bPolygonizePen(exo, ulWidth)
*
* Creates a polyline approximation to the pen.
*
* If the pen is small and circular, we copy a pre-computed Hobby pen;
* otherwise, we approximate the pen using Bezier curves and convert this
* to lines.  Remembering that the pen is defined in world space, we
* construct the Bezier curves that approximate the pen circle in world
* space.  We then transform the coordinates to device space, and flatten.
*
* It makes life a lot easier if we can assume that the vertices of the pen
* are stored in counter-clockwise order.  So, we check the transform to
* see if it is inverting, and adjust the Bezier control points accordingly.
*
* Due to the half-symmetry property of ellipses, we only have to store
* the vertices for half the ellipse.  For the binary search, it is useful
* also to ensure that the last edge vector is the exact opposite of the
* first.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bPolygonizePen(
EXFORMOBJ& exo,          // World to device transform
LONG       lWidth)       // Pen width in world space
{
    EVECTORFX avecAxis[2];

    avecAxis[0].x =   (FIX) lWidth;
    avecAxis[0].y = 0;
    avecAxis[1].x = 0;
    avecAxis[1].y = - (FIX) lWidth;

    exo.bXform((PVECTORL) avecAxis, avecAxis, 2);

    if (((avecAxis[0].x == avecAxis[1].y) && (avecAxis[0].y == -avecAxis[1].x))
     || ((avecAxis[0].x == -avecAxis[1].y) && (avecAxis[0].y == avecAxis[1].x)))
    {

    // We now know that the transform was orthogonal, and that the pen is
    // circular in device space.

        if (MAX(ABS(avecAxis[0].x), ABS(avecAxis[0].y))
            < LPLUSHALFTOFX(HOBBY_TABLE_SIZE))
        {
            if (bHobbyize(avecAxis))
                return(TRUE);

            else if (!bValid())     // See if path still okay
                return(FALSE);
        }
    }

    if (bThicken((PPOINTFIX) avecAxis))
        return(TRUE);

    else if (!bValid())             // See if path still okay
        return(FALSE);

// The points must be ordered in a counter-clockwise direction.
// The half-ellipse we're creating starts at avecAxis[0], goes through
// avecAxis[1], and ends at -avecAxis[0].  As such, avecAxis[1] must
// lie to the left of avecAxis[0]:

    if (!bTurnLeftRandom(&avecAxis[0], &avecAxis[1]))
    {
        avecAxis[1].x = -avecAxis[1].x;
        avecAxis[1].y = -avecAxis[1].y;
    }

    vHalve(avecAxis[0]);
    vHalve(avecAxis[1]);

    VECTORFX vecRight;
    VECTORFX vecUp;

    LONGLONG eqTmp;
    vEllipseControlsOut(&avecAxis[0], &vecRight, &eqTmp);
    vEllipseControlsOut(&avecAxis[1], &vecUp,    &eqTmp);

//
//                  4       3       2
//             +----x-------E-------x----+
//             |                         |
//             |                         |
//             |                         |
//           5 x                         x 1  ^
//             |                         |    |
//             |                         |    |
//             |                         |    | vecUp
//             |            VecRight     |    |
//           6 E            O------->    E 0  |
//
// where 'O' is the origin,
//       'x' is a control point of a Bezier curve
//       'E' is an end point of a Bezier curve
//

    EVECTORFX avec[7];

    avec[6].x = -avecAxis[0].x;
    avec[6].y = -avecAxis[0].y;

    avec[5] = avec[6];
    avec[5] += vecUp;

    avec[4] = avecAxis[1];
    avec[4] -= vecRight;

    avec[3] = avecAxis[1];

    avec[2] = avecAxis[1];
    avec[2] += vecRight;

    avec[1] = avecAxis[0];
    avec[1] += vecUp;

    avec[0] = avecAxis[0];

    return(bPenFlatten((PPOINTFIX) avec));
}

/******************************Public*Routine******************************\
* bLeft(pvec, pptfx, pfxCross)
*
* Returns TRUE if the vector to 'pptfx' turns left from 'pvec'.  Returns
* the cross product in pfxCross.
*
* NOTE: Since only the low DWORD of the cross product is returned, *pfxCross
* is valid only when the vector '*(pptfx + 1) - *pptfx' is close to being
* parallel to 'pvec'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bLeft(
PEVECTORFX pvec,     // First vector
PPOINTFIX  pptfx,    // Second vector
PLONGLONG  pfxCross) // Result of pvec X pptfx
{
    LONGLONG ad;
    LONGLONG bc;

    ad = Int32x32To64(pvec->x, (pptfx + 1)->y - pptfx->y);
    bc = Int32x32To64(pvec->y, (pptfx + 1)->x - pptfx->x);

    ad -= bc;

    *pfxCross = ad;

    return(ad < 0);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::vDetermineDrawVertex(vec, ld)
*
* The core routine of wide-lines.  This routine determines the point
* on the pen that draws the wide-line outline for the given line vector.
*
* Think of the line as a ray, and imagine dragging an elliptical pen
* along it.  The point on the ellipse that is furthest from the
* ray defines the outline of the widened line.  It's a bit of work to
* determine the draw vertex on a true ellipse (involving a bunch of
* floating point calculations).
*
* We take a different approach: we've already computed a convex polygonal
* approximation of the true ellipse.  We search the vertices of the
* polygon to determine which is the farthest from the ray.
*
* We could do this by finding the maximum cross product of the line
* vector and the vectors from the center of the pen to each of its
* vertices, but this approach doesn't lend itself to a binary search.
*
* We accomplish a binary search by looking at the cross product of the
* line vector and the vector difference between successive vertices of the
* pen polygon -- we find the point on the pen polygon whose adjacent
* edge vector on one side turns to the 'left' of the line vector, and
* whose other edge vector turns to the 'right' of the line vector.
* That is, the vertex whose cross products of its adjacent edge vectors
* and the line vector have different signs.
*
* Our pen polygon is only half the ellipse -- under an affine transform,
* ellipses are always symmetrical about some axis.  Since we made sure
* the first edge is exactly opposite the last edge when we built the
* pen polygon, it follows that for any line vector, the cross product
* with the first and last edges have different signs (unless the line
* vector is parallel to that edge, which we sort of let fall through).
* So we start the binary search by considering the first and last edges
* of the half-ellipse.
*
* For the binary search, we maintain the invariant that the cross product
* of the first and last edges with our line vector has different signs, and
* we subdivide the interval between the first and last edge until they are
* adjacent edges on the polygon; the shared vertex is then our draw vertex.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPENOBJ::vDetermineDrawVertex(
EVECTORFX& vec,            // Direction of line
LINEDATA&  ld)             // Result goes here
{
    PPOINTFIX pptfxStart;
    PPOINTFIX pptfxEnd;
    PPOINTFIX pptfxMid;

    LONGLONG fxCrossMid;

    BOOL bLeftStart;
    BOOL bLeftEnd;

    ld.ppr = ppath->pprfirst;

    if (ppath->pprfirst == ppath->pprlast)
    {
        bLeftStart = bLeft(&vec, &ld.ppr->aptfx[0], &ld.fxCrossStart);
        ld.fxCrossEnd = -ld.fxCrossStart;
    }
    else
    {
    // El yucko, the pen is bigger than one PathRecord.  Scan through the
    // linked list until we find a PathRecord whose edges bracket our vector.
    //
    // NOTE: If our vector is parallel to and in the same direction as the
    //       last edge in the last pathrecord, then
    //
    //          bTurnLeft(vec, vecStart) == FALSE
    //      and bTurnLeft(vec, vecEnd) == FALSE

        while (TRUE)
        {
           bLeftStart = bLeft(&vec,
                              &ld.ppr->aptfx[0],
                              &ld.fxCrossStart);

           bLeftEnd   = bLeft(&vec,
                              &ld.ppr->aptfx[ld.ppr->count - 2],
                              &ld.fxCrossEnd);

           if ((bLeftStart ^ bLeftEnd) || ld.ppr->pprnext == (PPATHREC) NULL)
              break;

           ld.ppr = ld.ppr->pprnext;
        }
    }

    if (bLeftStart)
        ld.vSetInvert();
    else
        ld.vClearInvert();

// 'pptfxStart' is a pointer to the first point of the first edge in
// the path record.  'pptfxEnd' is a pointer to the first point of the
// last edge.

    pptfxStart = &ld.ppr->aptfx[0];
    pptfxEnd   = &ld.ppr->aptfx[ld.ppr->count - 2];

    while (TRUE)
    {
        pptfxMid = pptfxStart + ((pptfxEnd - pptfxStart) >> 1);

        if (bLeft(&vec, pptfxMid, &fxCrossMid) ^ bLeftStart)
        {
        // Signs are different, so the point we want must be between
        // 'start' and 'mid':

            ld.fxCrossEnd = fxCrossMid;
            if (pptfxMid == pptfxStart + 1)
            {
                ld.pptfx = pptfxMid;
                break;
            }

            pptfxEnd = pptfxMid;
        }
        else
        {
        // Signs are the same, so the point we want must be between
        // 'mid' and 'end':

            ld.fxCrossStart = fxCrossMid;
            if (pptfxEnd == pptfxMid + 1)
            {
                ld.pptfx = pptfxEnd;
                break;
            }

            pptfxStart = pptfxMid;
        }

        ASSERTGDI(pptfxStart < pptfxEnd, "Couldn't find draw vertex");
    }

// ld.pptfx is our draw vertex.

#ifdef DEBUG_WIDE
    ASSERTGDI((ld.fxCrossEnd >= 0 && ld.fxCrossStart < 0) ||
              (ld.fxCrossEnd <= 0 && ld.fxCrossStart >= 0),
              "Expected different cross products signs");
#endif

    ld.fxCrossStart = ABS(ld.fxCrossStart);
    ld.fxCrossEnd   = ABS(ld.fxCrossEnd);
}

/******************************Public*Routine******************************\
* vAddNice(wpath, pptfx, pvec, bInvert)
*
* This routine is for adding round joins and end-caps to the given path.
*
* It does a trick to make rounds look nicer: when the given point lies on
* the integer grid, it shrinks the pen vector by 1/16th of a pel in both
* coordinates.
*
* This works on the assumption that most often the pens are constructed
* from integer widths in device space -- when that happens, we will often
* get assymetric filling because our fill convention breaks ties when a
* scan-line has a line fall exactly on the integer grid by being lower-right
* exclusive.
*
* Note: Remember that the bounds calculation has to take this possible
*       size increase into account.
*
* History:
*  20-Nov-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vAddNice(
WIDEPATHOBJ&  wpath,           // Path to add to
PPOINTFIX     pptfx,         // Spine point about which the round is added
PEVECTORFX    pvec,          // The vector to add to pptfx
BOOL          bInvert)       // TRUE if pvec is to be subtracted from pptfx
{
    EVECTORFX vec;

    if (((pptfx->x | pptfx->y) & (LTOFX(1) - 1)) == 0)
    {
        if (bInvert)
        {
            vec.x = -pvec->x;
            vec.y = -pvec->y;
            bInvert = FALSE;
        }
        else
        {
            vec = *pvec;
        }

        if (vec.x > 0)
            vec.x -= 1;
        else if (vec.x < 0)
            vec.x += 1;

        if (vec.y > 0)
            vec.y -= 1;
        else if (vec.y < 0)
            vec.y += 1;

        pvec = &vec;
    }

    wpath.vAddPoint(pptfx, pvec, bInvert);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::cptAddRound(wid, ldIn, ldOut, bLeft, bInPerp, bOutPerp)
*
* Adds round joins to 'wid'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

COUNT WIDEPENOBJ::cptAddRound(
WIDENER&     wid,        // Path to which to add
LINEDATA&    ldIn,       // Vector entering the point
LINEDATA&    ldOut,      // Vector exiting the point
BOOL         bLeft,      // ldOut turns left from ldIn?
BOOL         bInPerp,    //
BOOL         bOutPerp)   //
{
    COUNT cpt = 0;

    ASSERTGDI(ldIn.bVecDrawComputed() && ldOut.bVecDrawComputed(),
              "Draw vertex not computed");

    if (ldIn.pptfx == ldOut.pptfx && ldIn.bInvert() == ldOut.bInvert())
        return(0);

    BOOL      bInvert  = ldIn.bInvert();
    PPATHREC  ppr      = ldIn.ppr;
    PPOINTFIX pptfx    = ldIn.pptfx;

    if (bLeft)
    {
    // Turns left, so add counter-clockwise to right side:

        if (bInPerp && !ldIn.bToLeftSide())
        {
            wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
        }

        pptfx++;

        while (ppr != ldOut.ppr ||
               pptfx > ldOut.pptfx ||
               bInvert != ldOut.bInvert())
        {
            PPOINTFIX pptfxEnd = &ppr->aptfx[ldIn.ppr->count - 1];

            while (pptfx < pptfxEnd)
            {
                wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);
                cpt++;
            }

            if (ppr->pprnext != (PPATHREC) NULL)
                ppr = ppr->pprnext;
            else
            {
                ppr = ppath->pprfirst;
                bInvert = !bInvert;
            }

            pptfx = &ppr->aptfx[1];
        }

        ASSERTGDI(ppr == ldOut.ppr, "Unmatched path record pointers");
        ASSERTGDI(ldOut.pptfx - pptfx < (PATHALLOCSIZE >> 3),
                "Clockwise join unsynced");

        while (pptfx < ldOut.pptfx)
        {
            wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);
            cpt++;
        }

        if (bOutPerp && ldOut.bToLeftSide())
        {
            wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
        }
    }
    else
    {
    // Turns right, so add clockwise to left side:

        if (bInPerp && ldIn.bToLeftSide())
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx, bInvert);
        }

        pptfx--;

        while (ppr != ldOut.ppr ||
               pptfx < ldOut.pptfx ||
               bInvert != ldOut.bInvert())
        {
            PPOINTFIX pptfxStart = &ppr->aptfx[1];

            while (pptfx > pptfxStart)
            {
                wid.vAddLeftNice((PEVECTORFX) pptfx--, bInvert);
                cpt++;
            }

            if (ppr->pprprev != (PPATHREC) NULL)
                ppr = ppr->pprprev;
            else
            {
                ppr = ppath->pprlast;
                bInvert = !bInvert;
            }

            pptfx = &ppr->aptfx[ppr->count - 1];
        }

        ASSERTGDI(ppr == ldOut.ppr, "Unmatched path record pointers");
        ASSERTGDI(pptfx - ldOut.pptfx < (PATHALLOCSIZE >> 3),
                  "Counterclockwise join unsynced");

        while (pptfx > ldOut.pptfx)
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx--, bInvert);
            cpt++;
        }

        if (bOutPerp && !ldOut.bToLeftSide())
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx, bInvert);
        }
    }

    return(cpt);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::vAddRoundEndCap(wid, ld, bStartCap, bRound)
*
* Adds round caps to the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPENOBJ::vAddRoundEndCap(
WIDENER&     wid,        // Path to which to add
LINEDATA&    ld,         // Vector entering the point
BOOL         bStartCap,  // TRUE if Start-cap
BOOL         bRound)     // TRUE if round joins
{
    ASSERTGDI(ld.bVecDrawComputed(), "Draw vertex not computed");

    BOOL      bInvert  = (bStartCap) ? !ld.bInvert() : ld.bInvert();
    PPATHREC  ppr      = ld.ppr;
    PPOINTFIX pptfx    = ld.pptfx;

// Turns left, so add counter-clockwise to right side:

    if (!bRound && !ld.bToLeftSide())
        wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);

    pptfx++;

    while (ppr != ld.ppr ||
           pptfx > ld.pptfx)
    {
        PPOINTFIX pptfxEnd = &ppr->aptfx[ld.ppr->count - 1];

        while (pptfx < pptfxEnd)
            wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);

        if (ppr->pprnext != (PPATHREC) NULL)
            ppr = ppr->pprnext;
        else
        {
            ppr = ppath->pprfirst;
            bInvert = !bInvert;
        }

        pptfx = &ppr->aptfx[1];
    }

    ASSERTGDI(ppr == ld.ppr, "Unmatched path record pointers");
    ASSERTGDI(ld.pptfx - pptfx < (PATHALLOCSIZE >> 3),
            "Clockwise join unsynced");

    while (pptfx < ld.pptfx)
        wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);

    if (!bRound && ld.bToLeftSide())
        wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
}

/******************************Public*Routine******************************\
* READER::bNextPoint(ptfx)
*
* Reads the next point from the spine of the path.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL READER::bNextPoint(POINTFIX& ptfx)
{
    BOOL bRet;

    if (pptfxRead < pptfxEnd)
    {
        ptfx = *pptfxRead++;
        bRet = TRUE;
    }
    else if (pd.flags & PD_ENDSUBPATH)
        bRet = FALSE;
    else
    {

    // Get next path record:

        vMoreToEnum(pepoSpine->bEnum(&pd));

        ASSERTGDI(pd.count > 0, "Empty path record");
        ASSERTGDI(!(pd.flags & PD_BEGINSUBPATH), "Unexpected begin subpath");

        ptfx = pd.pptfx[0];
        pptfxRead = &pd.pptfx[1];
        pptfxEnd  = &pd.pptfx[pd.count];

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* READER::bNextFigure()
*
* Goes to the next figure in the path.  Returns FALSE if there are none.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL READER::bNextFigure()
{
    BOOL bRet = bMoreToEnum();

    if (bRet)
    {
        vMoreToEnum(pepoSpine->bEnum(&pd));
        if (pd.count == 0)
        {
            ASSERTGDI(!bMoreToEnum(), "Empty path record in non-empty path");
            bRet = FALSE;
        }

        ASSERTGDI((pd.flags & PD_BEGINSUBPATH) || (pd.count == 0),
                  "bNextFig: Not at start of fig");

        pptfxRead = &pd.pptfx[0];
        pptfxEnd  = &pd.pptfx[pd.count];
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LINER::vNextPoint()
*
* This function reads the next point in a path.  It will break Bezier
* curves into lines as it goes.
*
* CONSTRUCTING THE PATH BY VERTEX INSTEAD OF BY LINE
*
* The widening system is point based and not line based.  That is, we
* read the original path one vertex at-a-time and construct the wide-lines
* by making the appropriate structures at each of those vertices (i.e.,
* at every vertex we either construct an end-cap or a join); we don't read
* the path a line at-a-time and add both ends of the line then do the
* join if there is one.
*
* This is a subtle but important distinction.
*
* RETURNING THE DATA
*
* To construct a join, we need 3 things from the original path:
*      1) The point of the join;
*      2) The vector of the line entering the join;
*      3) The vector of the line exiting the join.
*
* A start cap requires:
*      1) The point of the start cap;
*      2) The vector of the line exiting the start cap.
*
* An end cap requires:
*      1) The point of the end cap;
*      2) The vector of the line entering the end cap.
*
* This data is returned by setting 'ptfxThis' as the point of interest,
* 'pldIn' points to the entering vector, and 'pldOut' points to the
* exiting vector.
*
* We don't incur the cost of re-computing the same perpendicular or draw
* vector for both sides of a line because that's handled by the lazy
* evaluation of 'pldIn' and 'pldOut'.
*
* VARIABLES
*
* Internal:
*
*   ptfxNext - Next point after 'ptfxThis', used to compute 'ldOut'
*   ptfxStartFigure - Start point for current figure
*   ls - Internal state for reading path
*   ldStartFigure - Line vector data for first line in figure
*   ldStartTangent, ldEndTangent - Line vector data for start and end
*                                  tangents of current Bezier
*
* External:
*
*   ptfxThis - Current point
*   pldIn, pldOut - Entering and exiting vectors from 'ptfxThis'
*
*          pld->vecLine is the difference vector between 'ptfxThis' and 'ptfxNext'
*               (so its length is the length of that line; used by styler)
*          pld->vecTangent is the true tangent vector at the point
*               (this is used for calculating true perpendiculars, and
*               its length does NOT correspond to the line at that point)
*
*   we - Returns point type at 'ptfxThis':
*
*           WE_STARTFIGURE - Figure starts here
*           WE_JOIN - Do a normal join
*           WE_BEZIERJOIN - Do a Bezier join
*           WE_CLOSEFIGURE - Do the final CloseFigure join
*           WE_ENDFIGURE - Do the end-cap
*           WE_FINISHFIGURE - Do the start-cap for the figure we
*                             just finished
*           WE_DONEPATH - All done!
*
* The resulting language is:
*
*       {s{j|b}[c|ef]}d
*
* History:
*  1-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID LINER::vNextPoint()
{
// Assign 'pldOut' a new spot in the LINEDATA buffer.  Just make sure
// the location isn't already being used by 'pldIn':

    pldOut = &ldBuf[ (pldIn != &ldBuf[0]) ? 0 : 1 ];

    switch (ls)
    {

    case LS_READPATH:
    case LS_STARTFIGURE:
        if (ls == LS_READPATH)
            we = WE_JOIN;               // Normal join
        else
        {
            ASSERTGDI(ls == LS_STARTFIGURE, "Not start figure");

            we = WE_STARTFIGURE;        // The point starts a figure
            ls = LS_READPATH;
        }

        if (bNextPoint(ptfxNext))
        {
        // The next point in the path may be the second control point
        // of a Bezier curve.  If it is, we have to set up to crack the
        // curve into lines:

            if (bIsBezier())
            {
                POINTFIX aptfx[4];

                aptfx[0] = ptfxThis;
                aptfx[1] = ptfxNext;
                bNextPoint(aptfx[2]);
                bNextPoint(aptfx[3]);

                bez.vInit(aptfx);

                if (!bez.bNext(&ptfxNext))
                {
                // Okay, we have a real small Bezier curve (it got converted
                // into one line).  Don't bother trying to use the Bezier's
                // control points to get accurate perps (that is a heuristic
                // that only works when you have lotsa lines in the
                // approximation):

                    pldOut->vInit(ptfxNext, ptfxThis);

                    ls = LS_READPATH;
                    return;
                }

                pldOut->vInit(ptfxNext, ptfxThis);

                ldStartTangent = *pldOut;
                ldStartTangent.vecTangent  = aptfx[1];
                ldStartTangent.vecTangent -= aptfx[0];

            // Initialize end-tangent vector with the true end-tangent
            // (we will change 'ldEndTangent.vecLine' later):

                ldEndTangent.vInit(aptfx[3], aptfx[2]);

                pldOut = &ldStartTangent;

            // Set up to get the next point from the current Bezier:

                ls = LS_READBEZIER;
                return;
            }
        }
        else
        {
        // Since there is no 'ptfxNext', it follows that 'ptfxThis' is the
        // last point in the figure.  See if we have to close the figure.

            ls = LS_FINISHFIGURE;
            ptfxNext = ptfxStartFigure;

            if (bIsClosedFigure())
                we = WE_JOIN;
            else
            {
                we = WE_ENDFIGURE;
                return;
            }
        }
        break;

    case LS_FINISHFIGURE:
        we = bIsClosedFigure() ? WE_CLOSEFIGURE : WE_FINISHFIGURE;

        pldOut = &ldStartFigure;

        if (!bNextFigure())
            ls = LS_DONEPATH;
        else
        {
            bNextPoint(ptfxNext);
            ptfxStartFigure = ptfxNext;

            ls = LS_STARTFIGURE;
        }

        return;

    case LS_READBEZIER:
        we = WE_BEZIERJOIN;
        if (!bez.bNext(&ptfxNext))
        {
        // Since this is the last line in the Bezier, make sure we use
        // the tangent vector computed from the last two control points
        // when calculating perpendicular for the line:

            ls = LS_READPATH;
            pldOut->vInit(ptfxNext, ptfxThis);
            pldOut->vecTangent = ldEndTangent.vecTangent;
            return;
        }

        break;

    case LS_DONEPATH:
        we = WE_DONEPATH;
        return;

    default:
        RIP("Unknown line state");
    }

// Finally, compute the exit vector for those cases that made it here:

    pldOut->vInit(ptfxNext, ptfxThis);
}

/******************************Public*Routine******************************\
* LINER::vZeroFigure()
*
* Sets pldOut and pldIn for a zero-length figure.
*
* History:
*  31-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID LINER::vZeroFigure()
{
    ldStartFigure.vInit();
    ldStartFigure.vecLine.x    = LTOFX(1);
    ldStartFigure.vecTangent.x = LTOFX(1);
    ldStartFigure.vecLine.y    = 0;
    ldStartFigure.vecTangent.y = 0;

    pldIn  = &ldStartFigure;
    pldOut = &ldStartFigure;
}

/******************************Public*Routine******************************\
* LINER::vNextEvent()
*
* This function reads the next event from the path.
*
* History:
*  31-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID LINER::vNextEvent()
{
// Update some of our current point data:

    ptfxThis  = ptfxNext;
    pldIn = pldOut;

// Check out the next point:

    vNextPoint();

    WIDENEVENT weOld = we;

// Eat any zero-length lines.  This will stop automatically

    while (pldOut->vecLine.x == 0 && pldOut->vecLine.y == 0)
    {
        if (we != WE_STARTFIGURE && we != WE_JOIN && we != WE_BEZIERJOIN)
            break;

    // Due to rounding on the integer grid, for small Bezier curves
    // the first or last line segments may wind up being zero length.
    // In that case, 'vecLine' will be a zero-vector.  But we do know
    // the true tangents at that point.

        vNextPoint();

    }

// Have to watch for the case when the vecTagent is zero but vecLine is
// not (such as when the first two or last two control points of the
// Bezier are coincident):

    if (pldOut->vecTangent.x == 0 && pldOut->vecTangent.y == 0)
        pldOut->vecTangent = pldOut->vecLine;

    if (weOld == WE_STARTFIGURE)
    {
        if (we == WE_CLOSEFIGURE || we == WE_ENDFIGURE)
        {
            if (we == WE_ENDFIGURE)
            {
                vNextPoint();
                ASSERTGDI(we == WE_FINISHFIGURE, "Expected finish figure");
            }

            vZeroFigure();
            we = WE_ZEROFIGURE;
        }
        else
        {
            ldStartFigure = *pldOut;
            pldOut = &ldStartFigure;
            we = WE_STARTFIGURE;
        }
    }
}

/******************************Public*Routine******************************\
* STYLER::STYLER(epo, dco)
*
* Constructor for the styler.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

STYLER::STYLER(
  EPATHOBJ&   epo,                 // Path of spine
  PLINEATTRS  pla)
: LINER(epo),
  exoDeviceToWorld(&mxDeviceToWorld, DONT_COMPUTE_FLAGS)
{
    vDoingStyles((pla->pstyle != (PFLOAT_LONG) NULL) && (pla->cstyle > 0));

    if (bDoingStyles())
    {
        pstyleStart     = pla->pstyle;
        pstyleCurrent   = pstyleStart;
        pstyleEnd       = pstyleStart + pla->cstyle;

    // Next point comes from the path, not from a style:

        vStyleNext(FALSE);
    }
}

/******************************Public*Routine******************************\
* STYLER::efNextStyleLength()
*
* Reads next style array entry from user-supplied list.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE EFLOAT STYLER::efNextStyleLength()
{
    EFLOATEXT efResult(pstyleCurrent->e);

    pstyleCurrent++;

    if (pstyleCurrent >= pstyleEnd)
        pstyleCurrent = pstyleStart;

    ASSERTGDI(!efResult.bIsNegative(), "Negative style length");

    return(efResult);
}

/******************************Public*Routine******************************\
* STYLER::efWorldLength(vec)
*
* Computes the world space length of the vector.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EFLOAT STYLER::efWorldLength(EVECTORFX vec)
{
// Transform the vector from device FIX format to world space LONG:

    BOOL bRet = exoDeviceToWorld.bXform(&vec, (PVECTORL) &vec, 1);

    ASSERTGDI(bRet, "XForm failed");

// Now compute the Cartesian length:

    EFLOAT x;
    EFLOAT y;

// The Alpha computes an eensy-weensy length for zero-length vectors
// which causes later math to underflow, so we simply check for zero
// length here.  The next smallest possible vector has a length of 1.0,
// and that has no chance of underflow.

    if ((vec.x == 0) && (vec.y == 0))
    {
        x = FP_0_0;
    }
    else
    {
        x = vec.x;
        y = vec.y;

        x *= x;
        y *= y;

        x += y;
        x.vSqrt();
    }

    return(x);
}

/******************************Public*Routine******************************\
* ptfxFraction(ptfx, pld, efDistance, efLineLength)
*
* Returns ptfx + pld->vecLine * (efDistance / efLineLength).
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

POINTFIX ptfxFraction(
 POINTFIX   ptfx,
 PLINEDATA  pld,
 EFLOAT&    efDistance,
 EFLOAT&    efLineLength)
{
    ASSERTGDI(efDistance <= efLineLength, "More than line length");
    ASSERTGDI(efDistance >= FP_0_0, "Negative distance");

    POINTFIX ptfxResult;

    if (efLineLength.bIsZero())
        return(ptfx);

    if (!pld->bNormalizedComputed())
    {
        pld->ptflNormalized.x = (LONG) pld->vecLine.x;
        pld->ptflNormalized.y = (LONG) pld->vecLine.y;

    // Assume a floating point multiply is twice as fast as a divide:

        EFLOAT efFactor;
        efFactor = FP_1_0;
        efFactor /= efLineLength;

        pld->ptflNormalized.x *= efFactor;
        pld->ptflNormalized.y *= efFactor;

        pld->vSetNormalizedComputed();
    }

    POINTFL ptfl;
    ptfl = pld->ptflNormalized;
    ptfl.x *= efDistance;
    ptfl.y *= efDistance;

    LONG x;
    LONG y;

// bEfToL has to take a LONG argument (can't be a FIX cast to a LONG):

    BOOL bRet1 = ptfl.x.bEfToL(x);
    BOOL bRet2 = ptfl.y.bEfToL(y);

    ASSERTGDI(bRet1 && bRet2, "Unexpected overflow");

    ptfxResult = ptfx;
    ptfxResult.x += (FIX) x;
    ptfxResult.y += (FIX) y;

    return(ptfxResult);
}

/******************************Public*Routine******************************\
* STYLER::vNextStyleEvent()
*
* Gets next style event.  Could be a join, end-cap, start-cap, etc.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID STYLER::vNextStyleEvent()
{
    if (!bDoingStyles())
        vNextEvent();
    else
    {
        if (bStyleNext())
        {
            if (we == WE_STOPDASH)
            {
            // Handle gaps:

            // This following test includes equality in order to eat zero
            // length lines when on a zero length style:

                while (efStyleLength >= efRemainingLength)
                {
                    efStyleLength -= efRemainingLength;

                    vNextEvent();

                    if (we != WE_JOIN && we != WE_BEZIERJOIN)
                    {
                    // We've come to the end of the figure, and it's covered
                    // by a gap.  Since we've effectively already put an end-cap
                    // on the figure (we're in a gap, after all), we can eat
                    // an end-cap message.

                        ASSERTGDI(we == WE_CLOSEFIGURE || we == WE_ENDFIGURE,
                                  "Unexpected event");

                        if (we == WE_ENDFIGURE)
                        {
                        // We need the first point in the figure:

                            vNextEvent();
                            ASSERTGDI(we == WE_FINISHFIGURE, "Expected finish fig");
                        }

                        vStyleNext(FALSE);
                        we = WE_FINISHFIGURE;
                        return;
                    }

                    efDoneLength  = FP_0_0;
                    efLineLength  = efWorldLength(pldOut->vecLine);
                    efRemainingLength = efLineLength;
                    ptfxLineStart = ptfxThis;
                }

                efRemainingLength -= efStyleLength;
                efDoneLength += efStyleLength;

                ptfxThis = ptfxFraction(ptfxLineStart, pldOut, efDoneLength, efLineLength);

                efStyleLength = efNextStyleLength();

                we = WE_STARTDASH;
                return;
            }
            else
            {
            // Handle a dash:

            // If you do a Rectangle(100, 100, 200, 200) with flat caps
            // and a world transform set, with a style array of
            // {100, 30}, I don't want it to wrap around a corner --
            // i.e., both perps for the start and end of the first dash
            // should be calculated from the vector (-100, 0), and NOT
            // have the start calculated from (-100, 0) and the end
            // from (0, 100)..

                if (efStyleLength > efRemainingLength)
                {
                    efStyleLength -= efRemainingLength;
                }
                else
                {
                    efRemainingLength -= efStyleLength;
                    efDoneLength += efStyleLength;

                    ptfxThis = ptfxFraction(ptfxLineStart, pldOut, efDoneLength, efLineLength);
                    pldIn = pldOut;

                    efStyleLength = efNextStyleLength();

                    we = WE_STOPDASH;
                    return;
                }
            }
        }

    // Okay, we're done with the current line (we've completely styled it),
    // so get the next one from the path:

        vNextEvent();

        switch(we)
        {
        case WE_STARTFIGURE:
            vResetStyles();
            efStyleLength = efNextStyleLength();

            efDoneLength  = FP_0_0;
            efLineLength  = efWorldLength(pldOut->vecLine);
            efRemainingLength = efLineLength;
            ptfxLineStart = ptfxThis;
            vStyleNext(TRUE);
            break;

        case WE_JOIN:
        case WE_BEZIERJOIN:
            efDoneLength = FP_0_0;
            efLineLength = efWorldLength(pldOut->vecLine);
            efRemainingLength = efLineLength;
            ptfxLineStart = ptfxThis;

            vStyleNext(TRUE);
            break;

        default:
            vStyleNext(FALSE);
        }
    }
}

/******************************Public*Routine******************************\
* WIDENER::vVecDrawCompute(ld)
*
* Computes the draw vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecDrawCompute(LINEDATA& ld)
{
#ifdef DEBUG_WIDE
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute draw vertex for zero vector");
#endif

    wpen.vDetermineDrawVertex(ld.vecTangent, ld);

    if (!ld.bInvert())
        ld.vecDraw     = *ld.pptfx;
    else
    {
        ld.vecDraw.x   = - ld.pptfx->x;
        ld.vecDraw.y   = - ld.pptfx->y;
    }

    ld.vSetVecDrawComputed();

    vVecSymmetricRound(&ld.vecDraw);
}

/******************************Public*Routine******************************\
* WIDENER::vVecPerpCompute(ld)
*
* Computes the perp vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecPerpCompute(LINEDATA& ld)
{
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute perp for zero vector");

    if (!ld.bVecDrawComputed())
        vVecDrawCompute(ld);

    ASSERTGDI(ld.fxCrossStart >= 0 && ld.fxCrossEnd >= 0, "-ve cross");

    LONGLONG aa = ld.fxCrossStart;
    LONGLONG bb = ld.fxCrossEnd;

    EVECTORFX vec;

    if (aa <= bb)
    {
        vec.x = ld.pptfx->x - (ld.pptfx - 1)->x;
        vec.y = ld.pptfx->y - (ld.pptfx - 1)->y;
    }
    else
    {
        vec.x = (ld.pptfx + 1)->x - ld.pptfx->x;
        vec.y = (ld.pptfx + 1)->y - ld.pptfx->y;
    }

    POINTFIX ptfxMid;

    ptfxMid.x = ld.pptfx->x - (vec.x >> 1);
    ptfxMid.y = ld.pptfx->y - (vec.y >> 1);

    LONGLONG x;
    LONGLONG y;

    LONGLONG fxDivisor = aa + bb;

    x = aa * ABS(vec.x);
    y = aa * ABS(vec.y);

// This is actually only an unsigned divide:

    ULONG ulXRemainder;
    ULONG ulYRemainder;

    if (fxDivisor != 0)
    {
        if (fxDivisor < ULONG_MAX)
        {
            VDIV(x, (ULONG) fxDivisor, &ulXRemainder);
            VDIV(y, (ULONG) fxDivisor, &ulYRemainder);
        }
        else
        {
            // When the numbers are this big, phooie on the rounding:

            ulXRemainder = 0;
            x /= fxDivisor;
            ulYRemainder = 0;
            y /= fxDivisor;
        }
    }
    else
    {
        ulXRemainder = 0;
        ulYRemainder = 0;
    }

// Now adjust the signs:

    FIX xPrime = (LONG) x;
    FIX yPrime = (LONG) y;

// This is a safe conversion because fxDivisor is always positive:

    ULONG ulHalfDivisor = (ULONG) fxDivisor;
    ulHalfDivisor >>= 1;

// Round:

    if (ulXRemainder >= ulHalfDivisor)
        xPrime++;
    if (ulYRemainder >= ulHalfDivisor)
        yPrime++;

// Give it the correct sign:

    if (vec.x < 0)
        xPrime = -xPrime;
    if (vec.y < 0)
        yPrime = -yPrime;

    ld.vecPerp.x = xPrime + ptfxMid.x;
    ld.vecPerp.y = yPrime + ptfxMid.y;

    if (ld.bInvert())
    {
        ld.vecPerp.x = -ld.vecPerp.x;
        ld.vecPerp.y = -ld.vecPerp.y;
    }

    ld.vSetVecPerpComputed();

// Rounds to half integer:

    vVecRound(&ld.vecPerp);
}

/******************************Public*Routine******************************\
* WIDENER::vVecSquareCompute(ld)
*
* Computes the square cap vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecSquareCompute(LINEDATA& ld)
{
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute square vector for zero vector");

    EFLOAT efAlpha;
    EFLOAT efLength;

    efAlpha  = efHalfWidth;
    efLength = efWorldLength(ld.vecTangent);

    if (!efLength.bIsZero())
        efAlpha /= efLength;
    else
        efAlpha = FP_0_0;

    EFLOATEXT x(ld.vecTangent.x);
    EFLOATEXT y(ld.vecTangent.y);

    x *= efAlpha;
    y *= efAlpha;

// We can assert that these conversions won't fail because we already
// did bounds checking on the entire path.

    BOOL bRet1 = x.bEfToL(ld.vecSquare.x);
    BOOL bRet2 = y.bEfToL(ld.vecSquare.y);

    ASSERTGDI(bRet1 && bRet2, "Square vector out of bounds");

    ld.vSetVecSquareComputed();
}

/******************************Public*Routine******************************\
* bIs31Bits(fx)
*
* Returns TRUE if 'fx' is a 31-bit signed number (i.e., the upper 2 bits
* are the same).
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bIs31Bits(FIX fx)
{
    return(fx < ((LONG) LONG_MAX >> 1) && fx > ((LONG) LONG_MIN >> 1));
}

/******************************Public*Routine******************************\
* bComputeIntersect(pvecA, pvecB, pvecC, pvecD, pvecIntersect)
*
* Computes the intersection of the rays defined by the given line segments.
* Returns FALSE if the computation overflows or if the intersection is
* outside the 31 bit space.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bComputeIntersect(
 PEVECTORFX pvecA,               // Start point of first line segment
 PEVECTORFX pvecB,               // Direction of first line segment
 PEVECTORFX pvecC,               // Start point of second line segment
 PEVECTORFX pvecD,               // Direction of second line segment
PEVECTORFX pvecIntersect)       // Resulting point of intersection
{
//
// The intersection is computed by:
//
//            (Cx - Ax)(-Dy) + (Cy - Ay)(Dx)
//  lambda =  ------------------------------
//            (Bx)(-Dy)      + (By)(Dx)
//
//  intersect = A + lambda * B
//

    EFLOAT efTerm1;
    EFLOAT efTerm2;
    EFLOAT efNum;
    EFLOAT efDenom;

// (Cx - Ax)(-Dy)

    efNum = (pvecC->x - pvecA->x);
    efTerm2 = -pvecD->y;
    efNum *= efTerm2;

// (Cy - Ay)(Dx)

    efTerm1 = (pvecC->y - pvecA->y);
    efTerm2 = pvecD->x;
    efTerm1 *= efTerm2;
    efNum += efTerm1;

// (Bx)(-Dy)

    efDenom = pvecB->x;
    efTerm2 = -pvecD->y;
    efDenom *= efTerm2;

// (By)(Dx)

    efTerm1 = pvecB->y;
    efTerm2 = pvecD->x;
    efTerm1 *= efTerm2;
    efDenom += efTerm1;

    if (efDenom.bIsZero())
        return(FALSE);

// lambda

    efNum /= efDenom;

//  lambda * B

    EVECTORFX lambdaB;

    efTerm1 = pvecB->x;
    efTerm2 = pvecB->y;

    efTerm1 *= efNum;
    efTerm2 *= efNum;

    if (!efTerm1.bEfToL(lambdaB.x) || !efTerm2.bEfToL(lambdaB.y) ||
        !bIs31Bits(lambdaB.x) || !bIs31Bits(lambdaB.y))
    {
        return(FALSE);
    }

// A + lambda * B

    pvecIntersect->x = pvecA->x + lambdaB.x;
    pvecIntersect->y = pvecA->y + lambdaB.y;

// Check for overflow:

    if (!bIs31Bits(pvecIntersect->x) || !bIs31Bits(pvecIntersect->y))
    {
        WARNING("Miter would fall outside device space\n");
        return(FALSE);
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
* WIDENER::bMiterInLimit(vec)
*
* Determines if the resulting vector from the middle of the wideline to
* the outer corner would be within the specified miter limit.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDENER::bMiterInLimit(EVECTORFX vec)
{
// Note we change our local copy of 'vec':

    BOOL bRet = exoDeviceToWorld.bXform(&vec, (PVECTORL) &vec, 1);

    ASSERTGDI(bRet, "XForm failed");

// Now compute the square of the Cartesian length:

    EFLOAT x;
    EFLOAT y;

    x = vec.x;
    y = vec.y;

    x *= x;
    y *= y;

    x += y;

    return(x <= efHalfWidthMiterLimitSquared);
}

/******************************Public*Routine******************************\
* WIDENER:vAddRoundJoin(bBezierJoin)
*
* Adds a join.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddRoundJoin(BOOL bBezierJoin)
{
    BOOL bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

    BOOL bInPerp = FALSE;
    BOOL bOutPerp = FALSE;

    if (!bAllRound())
    {
        if (!bBezierJoin)
        {
            bInPerp = TRUE;
            bOutPerp = TRUE;
        }
//      else
//      {
//          if (pldIn->bSamePenSection(ldStartTangent)
//           || pldIn->bSamePenSection(ldEndTangent))
//              bInPerp = TRUE;
//
//          if (pldOut->bSamePenSection(ldStartTangent)
//           || pldOut->bSamePenSection(ldEndTangent))
//              bOutPerp = TRUE;
//      }
    }

    EVECTORFX vecIn  = bInPerp  ? vecInPerp()  : vecInDraw();
    EVECTORFX vecOut = bOutPerp ? vecOutPerp() : vecOutDraw();

    vAddRight(vecIn);
    vAddLeft(vecIn);

    if (vecIn != vecOut)
    {
        COUNT cpt;

        if (bTurnLeft)
        {
            cpt = wpen.cptAddRound(*this, *pldIn, *pldOut, bTurnLeft, bInPerp, bOutPerp);
            vAddLeft();

            if (!bAllRound())
//            if ((cpt > 0 || bInPerp || bOutPerp) && bBezierJoin) // hmmm and not all round?
            {
                vAddLeft(vecOut);
                if (cpt > 0)
                    wpen.cptAddRound(*this, *pldOut, *pldIn, !bTurnLeft, bOutPerp, bInPerp);
                vAddLeft(vecIn);
                vAddLeft();
            }
        }
        else
        {
            cpt = wpen.cptAddRound(*this, *pldIn, *pldOut, bTurnLeft, bInPerp, bOutPerp);
            vAddRight();

            if (!bAllRound())
//            if ((cpt > 0 || bInPerp || bOutPerp) && bBezierJoin) // hmmm and not all round?
            {
                vAddRight(vecOut);
                if (cpt > 0)
                    wpen.cptAddRound(*this, *pldOut, *pldIn, !bTurnLeft, bOutPerp, bInPerp);
                vAddRight(vecIn);
                vAddRight();
            }
        }

        vAddRight(vecOut);
        vAddLeft(vecOut);
    }
}


/******************************Public*Routine******************************\
* WIDENER:vAddJoin(bBezierJoin)
*
* Adds a join.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddJoin(BOOL bBezierJoin)
{
    BOOL bTurnLeft;

    if (iJoin == JOIN_ROUND || bBezierJoin)
        vAddRoundJoin(bBezierJoin);
    else if (iJoin == JOIN_BEVEL)
    {
        bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

        EVECTORFX vecIn  = vecInPerp();
        EVECTORFX vecOut = vecOutPerp();

        vAddLeft(vecIn);
        vAddRight(vecIn);

        if (vecIn != vecOut)
        {
            if (bTurnLeft)
                vAddLeft();
            else
                vAddRight();

            vAddRight(vecOut);
            vAddLeft(vecOut);
        }
    }
    else
    {
        ASSERTGDI(iJoin == JOIN_MITER, "Unexpected join type");

        bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

    // Use the 'perpendicular' vector rather than the 'draw' vector here for
    // computing the intersection point.  This is done to be consistent:
    // if the same path is redrawn but with a different miter limit, we will
    // still light the same pels except on the joins that change between
    // mitered and beveled.

        EVECTORFX vecIn  = vecInPerp();
        EVECTORFX vecOut = vecOutPerp();

        vAddLeft(vecIn);
        vAddRight(vecIn);

        if (vecIn != vecOut)
        {
            EVECTORFX vecIntersect;

            if (bComputeIntersect(&vecIn, &pldIn->vecLine,
                                  &vecOut, &pldOut->vecLine,
                                  &vecIntersect))

                if (bMiterInLimit(vecIntersect))
                {
                    if (bTurnLeft)
                        vAddRight(vecIntersect);
                    else
                        vAddLeft(vecIntersect);
                }

            if (bTurnLeft)
                vAddLeft();
            else
                vAddRight();

            vAddLeft(vecOut);
            vAddRight(vecOut);
        }
    }
}

/******************************Public*Routine******************************\
* WIDENER::vAddEndCap()
*
* Adds an end-cap.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddEndCap()
{
    switch(iEndCap)
    {
    case ENDCAP_SQUARE:
        EVECTORFX vecRight;
        EVECTORFX vecLeft;

        vecRight = vecInSquare();
        vecLeft  = vecRight;

        vecRight += vecInPerp();
        vecLeft  -= vecInPerp();

        vAddRight(vecRight);
        vAddRight(vecLeft);
        break;

    case ENDCAP_BUTT:
	EVECTORFX vecInP;

        vecInP = vecInPerp();
        vAddRight(vecInP, FALSE);
        vAddRight(vecInP, TRUE);
        break;

    case ENDCAP_ROUND:
        EVECTORFX vec;

        if (bAllRound())
            vec = vecInDraw();
        else
            vec = vecInPerp();

        vAddRight(vec, FALSE);
        wpen.vAddRoundEndCap(*this, *pldIn, FALSE, bAllRound());
        vAddRight(vec, TRUE);
        break;

    default:
        RIP("Unknown cap type");
    }
}

/******************************Public*Routine******************************\
* WIDENER::vAddStartCap()
*
* Adds a start cap.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddStartCap()
{
    switch(iEndCap)
    {
    case ENDCAP_SQUARE:
        {
            EVECTORFX vecRight = vecOutSquare();
            EVECTORFX vecLeft;

            vecRight.x = -vecRight.x;
            vecRight.y = -vecRight.y;

            vecLeft = vecRight;

            vecRight += vecOutPerp();
            vecLeft  -= vecOutPerp();

            vAddRight(vecLeft);
            vAddRight(vecRight);
        }
        break;

    case ENDCAP_BUTT:
        EVECTORFX vecOutP;

        vecOutP = vecOutPerp();
        vAddRight(vecOutP, TRUE);
        vAddRight(vecOutP, FALSE);
        break;

    case ENDCAP_ROUND:
        {
            EVECTORFX vec;

            if (bAllRound())
                vec = vecOutDraw();
            else
                vec = vecOutPerp();

            vAddRight(vec, TRUE);
            wpen.vAddRoundEndCap(*this, *pldOut, TRUE, bAllRound());
            vAddRight(vec, FALSE);
        }
        break;

    default:
        RIP("Unknown cap type");
    }
}

/******************************Public*Routine******************************\
* BOOL WIDENER::bWiden()
*
* Widens the path.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDENER::bWiden()
{
    while(TRUE)
    {
        vNextStyleEvent();

        switch (we)
        {
        case WE_ZEROFIGURE:

        // If the entire figure is comprised of one point, output the
        // pen circle at that point if we have round caps (we can't handle
        // square caps because we have no idea of the intended direction):

            if (iEndCap == ENDCAP_ROUND)
            {
                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                vAddStartCap();
                vAddEndCap();

            // Finish up:

                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();
            }

            break;

        case WE_STARTFIGURE:
            if (!wpathLeft.bBeginFigure() || !wpathRight.bBeginFigure())
                return(FALSE);

            vFigureStyled(FALSE);
            wpathRight.vMarkFigureStart();
            break;

        case WE_JOIN:
            vAddJoin(FALSE);
            break;

        case WE_BEZIERJOIN:
            vAddJoin(TRUE);
            break;

        case WE_STARTDASH:
            if (!wpathLeft.bBeginFigure() || !wpathRight.bBeginFigure())
                return(FALSE);

            vAddStartCap();
            break;

        case WE_ENDFIGURE:
        case WE_STOPDASH:
            vAddEndCap();

        // Finish up:

            wpathLeft.vEndFigure();

            if (!bValid())
                return(FALSE);

            wpathRight.vReverseConcatenate(wpathLeft);
            wpathRight.vEndFigure();
            wpathRight.vCloseFigure();

            vFigureStyled(TRUE);   // We hit a style dash
            break;

        case WE_FINISHFIGURE:

        // Prepend the start cap to the beginning of the figure:

            if (!wpathRight.bBeginFigure())
                return(FALSE);

            vAddStartCap();
            wpathRight.vEndFigure();
            wpathRight.vPrependBeforeFigure();
            break;

        case WE_CLOSEFIGURE:

            vAddJoin(FALSE);
            wpathLeft.vEndFigure();

            if (!bFigureStyled())
            {
                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();

                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                wpathRight.vReverseConcatenate(wpathLeft);

                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();
            }
            else
            {
                wpathRight.vEndFigure();
                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                wpathRight.vReverseConcatenate(wpathLeft);
                wpathRight.vEndFigure();

                wpathRight.vPrependBeforeSubpath();
                wpathRight.vPrependBeforeFigure();
                wpathRight.vCloseFigure();
            }

            break;

        case WE_DONEPATH:
            return(bValid());

        default:
            RIP("Unknown widen event");
        }
    }

    RIP("Shouldn't get here");
    return(FALSE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::vBecome(wpath)
*
* Free any data in our path, copy all the data from 'epo', and delete
* 'epo'.
*
* Our path can be a PATHMEMOBJ or PATHSTACKOBJ.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID EPATHOBJ::vBecome(WIDEPATHOBJ& wpath)
{
    ASSERTGDI(!(wpath.ppath->flType & PATHTYPE_STACK), "Can't do stacks");

// First, free all the path blocks in our destination path:

    vFreeBlocks();

// Now copy all the important stuff about the path from 'wpath', including
// the pointers to all its path data:

    cCurves         = wpath.cCurves;
    ppath->ppachain = wpath.ppath->ppachain;
    ppath->pprfirst = wpath.ppath->pprfirst;
    ppath->pprlast  = wpath.ppath->pprlast;

// The flags, ercfxBoundBox and ptfxCurrent fields should be the same for
// the widened result as they were for the spine, so don't copy them.

    ppath->flags    |= (PD_BEGINSUBPATH | PD_ENDSUBPATH);
    fl              &= ~(PO_BEZIERS | PO_ELLIPSE);

// Now delete the wpath path object:

    wpath.ppath->ppachain = (PATHALLOC*) NULL;
    wpath.vDelete();
}

/******************************Public*Routine******************************\
* WIDENER::vMakeItWide(epo)
*
* Replaces the path 'epo' with its widened result.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDENER::vMakeItWide(EPATHOBJ& epo)
{
    epo.vBecome(wpathRight);

// Recompute the total number of lines in the path:

    epo.cCurves = epo.cTotalCurves();
}

/******************************Public*Routine******************************\
* WIDENER::WIDENER(epo, exoWtoD, pla)
*
* Constructor for the widener.
*
* Coming in to here, we expect bounds checking to be already done via
* bComputeWidenedBounds(), so that we don't have to worry about over-
* flowing outside the 31 bit device space.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

WIDENER::WIDENER(
EPATHOBJ&  epo,
EXFORMOBJ& exoWtoD,
PLINEATTRS pla)
: STYLER(epo, pla)
{
    ASSERTGDI(pla->fl & LA_GEOMETRIC, "Not a geometric line");
    ASSERTGDI(epo.bValid(), "Invalid path");
    ASSERTGDI(exoWtoD.bValid(), "Invalid xform");

// Bail out here if we failed to allocate any objects.  The caller must also
// call WIDENER::bValid() immediately after invoking the WIDENER constructor:

    if (!bValid())
        return;

    iEndCap = pla->iEndCap;
    iJoin   = pla->iJoin;

// Set 'AllRound' flag if we don't have to ever worry about perpendiculars
// looking funny:

    vAllRound((iJoin == JOIN_ROUND) &&
              (iEndCap == ENDCAP_ROUND || iEndCap == ENDCAP_SQUARE));

    EFLOATEXT efWidth(pla->elWidth.e);
    LONG lWidth;
    BOOL bRet;

    bRet = efWidth.bEfToL(lWidth);
    ASSERTGDI(bRet, "Unexpected width overflow");

    efHalfWidth = efWidth;
    efHalfWidth.vDivBy2();

// Set up for miter limit:

    if (iJoin == JOIN_MITER)
    {
    // Compute (PenWidth * MiterLimit / 2) ^ 2:

        efHalfWidthMiterLimitSquared = pla->eMiterLimit;
        efHalfWidthMiterLimitSquared *= efHalfWidth;

    // *= operator probably can't handle dest and src being the same:

        EFLOAT efTemp = efHalfWidthMiterLimitSquared;
        efHalfWidthMiterLimitSquared *= efTemp;
    }

// Current transform has to be invertible for doing styling or mitering
// (miter limit is specified in world space).  Square caps too.

    if (pla->pstyle != (PFLOAT_LONG) NULL ||
        iEndCap == ENDCAP_SQUARE || iJoin == JOIN_MITER)
    {
    // Compute inverse of the current transform:

        if (exoDeviceToWorld.bInverse(exoWtoD))
        {
        // Ensure that every vector between every point in the path
        // could be transformed to world space:

            EVECTORFX avec[2];

            avec[0].x = epo.rcfxBoundBox().xRight - epo.rcfxBoundBox().xLeft;
            avec[0].y = epo.rcfxBoundBox().yBottom - epo.rcfxBoundBox().yTop;
            avec[1].x = -avec[0].x;
            avec[1].y =  avec[0].y;

            if (!exoDeviceToWorld.bXform(avec, (PVECTORL) avec, 2))
                vSetError();

        }
        else
        {
            SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
            vSetError();
        }
    }

    if (!bValid())
        return;

// Do most of the work:

    if (!wpen.bPolygonizePen(exoWtoD, lWidth) ||
        !bWiden())
    {
        vSetError();
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bWiden(epoSpine, exo, pla)
*
* Widens the specified path, overwriting the results of '*this'.
*
* History:
*  3-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bWiden(EPATHOBJ& epoSpine, XFORMOBJ* pxo, LINEATTRS* pla)
{
    WIDENER wid(epoSpine, *((EXFORMOBJ*) pxo), pla);

    BOOL bValid = wid.bValid();

    if (bValid)
        wid.vMakeItWide(*this);

    return(bValid);
}

/******************************Public*Routine******************************\
* EPATHOBJ::bComputeWidenedBounds(exo, pla)
*
* Adjusts the bounds of the path to allow for joins for geometric
* wide-lines.  We do this by transforming the bound box of the pen
* to device space and taking the corners as the extrema of the joins.
*
* For Miter joins, this is an even rougher guess since we assume we'll
* have the longest possible join allowed by the Miter limit.
*
* The values returned are the upper bounds if the path is to be widened
* (which is fine for pointer exclusion).
*
* FALSE is returned if any part of the widened result might fall outside
* the 31 bit device space.
*
* History:
*  3-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bComputeWidenedBounds(
EPATHOBJ& epoSpine,
XFORMOBJ  *pexo,
LINEATTRS *pla)
{
    ASSERTGDI(epoSpine.bValid(), "Not valid path");
    ASSERTGDI(bValid(), "Not valid path");
    ASSERTGDI(pla->fl & LA_GEOMETRIC, "Not geometric line");

    EFLOATEXT efWidth(pla->elWidth.e);
    LONG      lWidth;

    BOOL b = efWidth.bEfToL(lWidth);

    ASSERTGDI(b, "Width too large");
    ASSERTGDI(lWidth >= 0, "Negative pen radius");

    VECTORL avecl[2];

// We use the diameter and not the radius of the pen here because halving
// it in world space as an integer could possibly lose a lot of precision,
// and it's faster to call 'bXform' with an integer vector than an EFLOAT
// one:

    avecl[0].x =  lWidth;
    avecl[0].y =  lWidth;
    avecl[1].x =  lWidth;
    avecl[1].y = -lWidth;

    if (!((EXFORMOBJ*) pexo)->bXform(avecl, (PVECTORFX) avecl, 2))
        return(FALSE);

// Chop in half to get the maximums of the pen (we were using the diameter
// instead of the radius, remember?).  Add a pixel of slop too (remembering
// that there is rounding error, and vAddNice can increase the dimensions
// of the pen slightly):

    LONG xAdjust = (MAX(ABS(avecl[0].x), ABS(avecl[1].x)) >> 1) + LTOFX(1);
    LONG yAdjust = (MAX(ABS(avecl[0].y), ABS(avecl[1].y)) >> 1) + LTOFX(1);

// Account for square caps by multiplying by a coarse approximation to the
// square root of 2:

    if (pla->iEndCap == ENDCAP_SQUARE)
    {
        xAdjust += (xAdjust >> 1);
        yAdjust += (yAdjust >> 1);

    // Watch for overflow:

        if (!bIs31Bits(xAdjust) || !bIs31Bits(yAdjust))
            return(FALSE);
    }

// We know here that xAdjust and yAdjust have at most 31 bits significance.
// (Ok, so maybe we overflowed by adding 1).

    if (pla->iJoin == JOIN_MITER)
    {
        EFLOATEXT efMiterLimit(pla->eMiterLimit);

        ASSERTGDI(FP_1_0 <= efMiterLimit, "Miter limit less than one");

        EFLOATEXT ef(xAdjust);
        ef *= efMiterLimit;
        if (!ef.bEfToL(xAdjust))
            return(FALSE);

        ef = yAdjust;
        ef *= efMiterLimit;
        if (!ef.bEfToL(yAdjust))
            return(FALSE);

        if (!bIs31Bits(xAdjust) || !bIs31Bits(yAdjust))
            return(FALSE);
    }

    PATH *ppNew = ppath;
    PATH *ppOld = epoSpine.ppath;

    LONG xLeft   = ppOld->rcfxBoundBox.xLeft;
    LONG xRight  = ppOld->rcfxBoundBox.xRight;
    LONG yTop    = ppOld->rcfxBoundBox.yTop;
    LONG yBottom = ppOld->rcfxBoundBox.yBottom;

// Our widen code expects the coordinates to fix in a 27.4 space in order
// not to overflow (as guaranteed by the DDI spec, but not guaranteed by
// the code):

    if (!bIs31Bits(xLeft) || !bIs31Bits(xRight) ||
        !bIs31Bits(yTop)  || !bIs31Bits(yBottom))
    {
        return(FALSE);
    }

// Copy the bounds from the 'old' spine to the 'new' widened result,
// accounting for the resulting increase in size:

    xLeft   -= xAdjust;
    xRight  += xAdjust;
    yTop    -= yAdjust;
    yBottom += yAdjust;

// Make sure we the widened result doesn't fall outside the 31 bit space:

    if (!bIs31Bits(xLeft) || !bIs31Bits(xRight) ||
        !bIs31Bits(yTop)  || !bIs31Bits(yBottom))
    {
        return(FALSE);
    }

    ppNew->rcfxBoundBox.xLeft   = xLeft;
    ppNew->rcfxBoundBox.xRight  = xRight;
    ppNew->rcfxBoundBox.yTop    = yTop;
    ppNew->rcfxBoundBox.yBottom = yBottom;

    return(TRUE);
}


/******************************Public*Routine******************************\
* EPATHOBJ::vReComputeBounds()
*
* Updates the bounding rectangle, based on reading all the points in
* the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vReComputeBounds()
{
    ASSERTGDI(bValid(), "ReComputeWidenedBounds() in invalid path");

    PPATHREC ppr;

    if (ppath != (PPATH) NULL)
    {
        if (ppath->pprfirst != (PPATHREC) NULL)
        {
            ASSERTGDI(ppath->pprfirst->count > 0, "Shouldn't have empty pathrec");

            ppath->rcfxBoundBox.xLeft   = ppath->pprfirst->aptfx->x;
            ppath->rcfxBoundBox.yTop    = ppath->pprfirst->aptfx->y;
            ppath->rcfxBoundBox.xRight  = ppath->rcfxBoundBox.xLeft;
            ppath->rcfxBoundBox.yBottom = ppath->rcfxBoundBox.yTop;

            for (ppr = ppath->pprfirst; ppr != (PPATHREC) NULL; ppr = ppr->pprnext)
            {
                PPOINTFIX pptfx    = &ppr->aptfx[0];
                PPOINTFIX pptfxEnd = &ppr->aptfx[ppr->count];

                while (pptfx < pptfxEnd)
                    ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx++);
            }
        }
        else
        {
            ppath->rcfxBoundBox.xLeft   = 0;
            ppath->rcfxBoundBox.yTop    = 0;
            ppath->rcfxBoundBox.xRight  = 0;
            ppath->rcfxBoundBox.yBottom = 0;
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::vWidenSetupForFrameRgn(dco, cxPen, cyPen, pexo, pla)
*
* Initializes a LINEATTRS and EXFORMOBJ to be passed to bWiden to widen
* the path appropriately.  Used only for FrameRgn.
*
* The FrameRgn pen is elliptical in world space, whereas the Widen code
* expects it to be circular.  So we simply change the transform here.
*
* The FrameRgn ellipse may also have zero-length axis (unlike normal
* widened paths), so a flag must be set for that.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vWidenSetupForFrameRgn(
XDCOBJ&     dco,     // Used to get current world transform
LONG       cxPen,   // x dimension of pen in world space
LONG       cyPen,   // y dimension of pen
EXFORMOBJ* pexo,    // Must be initialized via 'vInit(&mx, DONT_COMPUTE_FLAGS)'
LINEATTRS* pla)
{
    ASSERTGDI(pexo->bValid(), "Xform must be initialized");

// FrameRgn can have zero-width or zero-height brush dimensions:

    pla->fl          = LA_GEOMETRIC | LA_ALLOW_ZERO_DIMENSIONS;
    pla->iJoin       = JOIN_MITER;
    pla->iEndCap     = ENDCAP_ROUND;
    pla->eMiterLimit = dco.pdc->l_eMiterLimit();
    pla->pstyle      = (FLOAT_LONG*) NULL;
    pla->cstyle      = 0;

// We need to double the pen dimensions because half of the pen
// will draw outside the region, and will be clipped away:

    ASSERTGDI(cxPen >= 0 && cyPen >= 0, "Illegal pen dimension");
    cxPen *= 2;
    cyPen *= 2;

// Make our calculations a little more numerically stable:

    BOOL bAdjustX = FALSE;
    if (cxPen < cyPen)
    {
        register LONG lTmp;
        SWAPL(cxPen, cyPen, lTmp);
        bAdjustX = !bAdjustX;
    }

// Figure out the y-value normalizing factor that will make a square
// of dimensions [cxPen, cxPen] become a rectangle [cxPen, cyPen]:

    ASSERTGDI(cxPen >= cyPen, "");

    EFLOATEXT efX(cxPen);
    efX.vEfToF(pla->elWidth.e);

    EFLOATEXT efNormalize(cyPen);
    if (!efX.bIsZero())
        efNormalize /= efX;

// Now copy the world transform and modify it:

    pexo->vSet(&dco.pdc->mxWorldToDevice());

    if (bAdjustX)
    {
        pexo->efM11() *= efNormalize;
        pexo->efM12() *= efNormalize;
    }
    else
    {
        pexo->efM21() *= efNormalize;
        pexo->efM22() *= efNormalize;
    }

    pexo->vComputeAccelFlags();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pathclip.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathclip.cxx
*
* This module handles the reading of the path for the line-clipping
* component (which resides mostly in clipline.cxx).
*
* Created: 02-Apr-1991 08:45:30
* Author: Eric Kutter [erick]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* PATHOBJ_vEnumStartClipLines
*
*   Engine helper function.
*
* History:
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID PATHOBJ_vEnumStartClipLines(
     PATHOBJ     *ppo,
     CLIPOBJ     *pco,
     SURFOBJ     *pso,
     PLINEATTRS   pla)
{
    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);


    ((ECLIPOBJ *)pco)->vEnumPathStart(ppo, pSurf, pla);
}

/******************************Public*Routine******************************\
* PATHOBJ_bEnumClipLines
*
*   Engine helper function.
*
* History:
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL PATHOBJ_bEnumClipLines(
     PATHOBJ    *ppo,
     ULONG       cj,
    PCLIPLINE   pcl)
{
    ECLIPOBJ *pco = (ECLIPOBJ *)((EPATHOBJ *)ppo)->pco;

    return(pco->bEnumPath(ppo,cj,pcl));
}

/******************************Member*Function*****************************\
* XCLIPOBJ::vEnumPathStart
*
* History:
*  24-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Added styling support.
*
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vEnumPathStart(PATHOBJ *ppo_, SURFACE *pSurf, PLINEATTRS pla)
{
    EPATHOBJ *ppo = (EPATHOBJ *)ppo_;
    pcle = ppo->pcleGet();

    ppo->vEnumStart();
    ppo->pco = (CLIPOBJ *)this;

    pcle->fl      = CLO_LINEDONE;  // need a new line segment
    pcle->cPoints = 0;

// spTotal2 will be non-zero when we're doing styling:

    pcle->spTotal2     = 0;
    pcle->plStyleState = &pla->elStyleState.l;
    pcle->xStep        = 1;
    pcle->yStep        = 1;
    pcle->xyDensity    = 1;

    if (pla->fl & LA_ALTERNATE)
    {
    // Alternate style is special and has every second pixel off, so
    // we pretend a style unit is a single pixel long, and that we
    // have the style array {1}:

        pcle->spTotal2   = 2;
        pcle->spStyleEnd = HIWORD(pla->elStyleState.l) & 1;
    }
    else if (pla->pstyle != (PFLOAT_LONG) NULL)
    {
        if (pSurf->hdev() == 0)
        {
            WARNING("Driver didn't call EngAssociateSurface before calling\n");
            WARNING("EngStrokePath or vEnumPathStart, so styles may be wrong\n");

            pcle->xyDensity = 3;    // Supply a default
        }
        else
        {
            PDEVOBJ po(pSurf->hdev());

            pcle->xStep     = po.xStyleStep();
            pcle->yStep     = po.yStyleStep();
            pcle->xyDensity = po.denStyleStep();
        }

    // Get ready for styling:

        PFLOAT_LONG pstyle = pla->pstyle + pla->cstyle;
        while (pstyle > pla->pstyle)
        {
            pstyle--;
            pcle->spTotal2 += pstyle->l;
        }

        ASSERTGDI((pcle->spTotal2 & ~0x7fffL) == 0, "Style array too long");
        pcle->spTotal2 <<= 1;
        pcle->spTotal2 *= pcle->xyDensity;

    // Construct our scaled style state, remembering that a driver could
    // have left the style state in a funky way:

        pcle->spStyleEnd = HIWORD(pla->elStyleState.l) * pcle->xyDensity +
                           LOWORD(pla->elStyleState.l);
        pcle->spStyleEnd %= (ULONG) pcle->spTotal2;

        if (pcle->spStyleEnd < 0)
        {
            WARNING("GDISRV vEnumPathStart: style state < 0\n");
            pcle->spStyleEnd = 0;
        }
    }

// get the first line.  We don't care about flOld because we
// don't care about last pel exclusion here.

    FLONG flOld;
    bGetLine(ppo,&flOld);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bEnumPath
*
*   bEnumPath fills the pcl data structure with a line and runs that
*   specify uncliped parts of the line.  If there are too many runs to
*   fit in the supplied structure, the next call to this function will
*   return the next set of runs.
*
*   This routine assumes that the line to be clipped is already set in
*   the XCLIPOBJ which initialy is done through vEnumStartPath.  After
*   that, this routine will always complete with the next line setup.
*
* returns
*   TRUE  - there are more runs to enumerate
*   FALSE - this is the last set of runs in the path
*
* History:
*
*  21-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Made lines exclusive of ends.
*
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bEnumPath(
     PATHOBJ    *ppo_,
     ULONG       cj,
    PCLIPLINE   pcl)
{
    pcl->c = 0;

// See if we're simply done the path:

    if (bEnumDone())
        return(FALSE);

    EPATHOBJ *ppo = (EPATHOBJ *) ppo_;

    BOOL bMore;

    do
    {
    // assume next line already setup.

    // get the run's for the current line.  If we have all the runs, do
    // last pel exclusion.  If we don't have all of the runs, we know
    // there is at least one unclipped pel after the current set of runs.

        bMore = bEnumLine(cj,pcl);

        if (!bMore)
        {
        // save information about current line

            FLONG  flOld   = pcle->fl;

            ASSERTGDI(pcle->dda.lX1 >= pcle->dda.lX0, "irunOld < 0");

        // get the next non-zero length line (bGetLine is FALSE if there aren't
        // any more lines in the path):

            bGetLine(ppo,&flOld);
        }

    } while ((pcl->c == 0) && !bEnumDone());

// if we made it to here with no runs, we must be done.

    if (bEnumDone() && bStyling())
    {
    // We're all done, so update style state in LINEATTRS:

        *pcle->plStyleState = lGetStyleState(pcle->spStyleEnd);
    }

    return(!bEnumDone());
}

/******************************Public*Routine******************************\
* XCLIPOBJ::bGetLine
*
*   Fill ppo with the next line segment in the path.  This may be a closing
*   segment of the current sub-path.
*
*   It may be necessary to ask the path for more points.
*
* returns
*   TRUE  - if there were more line segments
*   FALSE - if no more line segments.
*
* History:
*  16-Oct-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bGetLine(EPATHOBJ *ppo, FLONG *pflOld)
{
    DONTUSE(pflOld);

    FLONG fl;
    FLONG flBeginSub = 0;

// This for(;;) is for eating zero-length lines

    for (;;)
    {
        if (bEnumDone())
            return(FALSE);

    // if we still have more points in the current set

        if (pcle->cPoints > 1)
        {
            pcle->ptfx0 = *pcle->pptfx1;
            ++pcle->pptfx1;
            --pcle->cPoints;

            if (bEnumStartLine((PD_CLOSEFIGURE & pcle->fl) | flBeginSub))
                return(TRUE);
        }

    // otherwise, if we need to close the figure

        else if (bCloseFigure())
        {
            pcle->ptfx0  = *pcle->pptfx1;
            pcle->pptfx1 = &pcle->ptfxStartSub;

        // bEnumStartLine will turn off PD_CLOSFIGURE and turn on CLO_CLOSING:

            if (!bEnumStartLine(CLO_CLOSING) || flBeginSub)
                continue;

            return(TRUE);
        }

    // otherwise, lets get some more points

        else
        {
            if (!bGetMorePoints(ppo,&fl))
            {
                return(FALSE);
            }

            if (bEnumStartLine(fl | flBeginSub))
                return(TRUE);

        // Okay, the first line in the subpath was zero-length.  So remember
        // that we're really still at the start of a subpath, and get the
        // next line:

        // NOTE: We have to make sure we pass on the RESETSTYLE flag too!

            flBeginSub |= (pcle->fl & (PD_BEGINSUBPATH | PD_RESETSTYLE));
        }
    }
}

/******************************Public*Routine******************************\
* XCLIPOBJ::bGetMorePoints
*
*   This routine gets the next set of points from the path object.  If this
*   routine returns TRUE, it is guranteed that their are at least enough points
*   for one more line segment.
*
* returns
*   TRUE  - If there were more points to get
*   FALSE - if no more points
*
* History:
*  15-Oct-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bGetMorePoints(EPATHOBJ *ppo, FLONG *fl)
{
// if we have already gotten all points, return failure

    if (pcle->fl & CLO_PATHDONE)
    {
        pcle->fl |= CLO_ENUMDONE;

        return(FALSE);
    }

// if this is a continuation, we need to save the last point

    if (pcle->cPoints == 1)
        pcle->ptfx0 = *pcle->pptfx1;

// ask the path for some more points

    PATHDATA pd;

    if (!(ppo->bEnum(&pd)))
    {
    // this is the last chunk of points

        pcle->fl |= CLO_PATHDONE;

    // check if we actualy got any.  If no, we must be done!

        if (pd.count == 0)
        {
            pcle->fl |= CLO_ENUMDONE;
            return(FALSE);
        }
    }

// do a little debugging

    ASSERTGDI(pd.count > 0, "CLIPPATH: Path is Empty\n");
    ASSERTGDI(((pcle->cPoints == 0) ? (pd.flags & PD_BEGINSUBPATH) : TRUE),
	      "XCLIPOBJ::bGetMorePoints - 0 points not at BEGINSUBPATH \n");

// if it is the begining of a sub-path, remember the first point

    if (pd.flags & PD_BEGINSUBPATH)
    {
        pcle->ptfxStartSub = *pd.pptfx;

        pcle->ptfx0 = *pd.pptfx;

    // if we only got one point, we had better ask for more

        if (pd.count == 1)
        {
            ASSERTGDI(!(pcle->fl & CLO_PATHDONE),"One point in subpath");

            if (!ppo->bEnum(&pd))
            {
                pcle->fl |= CLO_PATHDONE;

            // check if we actualy got any.  If no, we must be done!

                if (pd.count == 0)
                {
                    pcle->fl |= CLO_ENUMDONE;
                    return(FALSE);
                }
            }
            pcle->pptfx1  = pd.pptfx;
            pcle->cPoints = pd.count;
        }
        else
        {
        // remember that we took two points out of the current set

            pcle->pptfx1  = pd.pptfx + 1;
            pcle->cPoints = pd.count - 1;
        }
    }
    else
    {
    // this is a continuation of the previous set of points

        pcle->pptfx1  = pd.pptfx;
        pcle->cPoints = pd.count;
    }

    *fl = pd.flags;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pathflat.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathflat.cxx
*
* Code to flatten paths
*
* Created: 3-Dec-1990 10:15:00
* Author: Paul Butzi [paulb]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "pathwide.hxx"

#define INLINE inline

INLINE BOOL bIntersect(RECTFX* prcfx1, RECTFX* prcfx2)
{
    BOOL bRet = (prcfx1->yTop <= prcfx2->yBottom &&
                 prcfx1->yBottom >= prcfx2->yTop &&
                 prcfx1->xLeft <= prcfx2->xRight &&
                 prcfx1->xRight >= prcfx2->xLeft);
    return(bRet);
}

INLINE VOID vBoundBox(POINTFIX* aptfx, RECTFX* prcfx)
{
    if (aptfx[0].x >= aptfx[1].x)
        if (aptfx[2].x >= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[2].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[3].x);
        }
    else
        if (aptfx[2].x <= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[3].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[2].x);
        }

    if (aptfx[0].y >= aptfx[1].y)
        if (aptfx[2].y >= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[2].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[3].y);
        }
    else
        if (aptfx[2].y <= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[3].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[2].y);
        }
}

INLINE VOID HFDBASIS32::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
//    ASSERTGDI(((p1 | p2 | p3 | p4) & 0xffffc000) == 0, "Range too big");

    #if (LTOFX(1) != 0x10)
    #error "FIX format changed, update flattener routine"
    #endif

// Change basis and convert from 28.4 to 18.14 format:

    e0 = (p1                     ) << 10;
    e1 = (p4 - p1                ) << 10;
    e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
    e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
}

INLINE VOID HFDBASIS32::vLazyHalveStepSize(LONG cShift)
{
    e2 = (e2 + e3) >> 1;
    e1 = (e1 - (e2 >> cShift)) >> 1;
}

INLINE VOID HFDBASIS32::vSteadyState(LONG cShift)
{
// We now convert from 18.14 fixed format to 15.17:

    e0 <<= 3;
    e1 <<= 3;

    register LONG lShift = cShift - 3;

    if (lShift < 0)
    {
        lShift = -lShift;
        e2 <<= lShift;
        e3 <<= lShift;
    }
    else
    {
        e2 >>= lShift;
        e3 >>= lShift;
    }
}

INLINE VOID HFDBASIS32::vHalveStepSize()
{
    e2 = (e2 + e3) >> 3;
    e1 = (e1 - e2) >> 1;
    e3 >>= 2;
}

INLINE VOID HFDBASIS32::vDoubleStepSize()
{
    e1 += e1 + e2;
    e3 <<= 2;
    e2 = (e2 << 3) - e3;
}

INLINE VOID HFDBASIS32::vTakeStep()
{
    e0 += e1;
    register LONG lTemp = e2;
    e1 += lTemp;
    e2 += lTemp - e3;
    e3 = lTemp;
}

typedef struct _BEZIERCONTROLS {
    POINTFIX ptfx[4];
} BEZIERCONTROLS;

BOOL BEZIER32::bInit(
POINTFIX* aptfxBez,     // Pointer to 4 control points
RECTFX* prcfxClip)      // Bound box of visible region (optional)
{
    POINTFIX aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register FIX fxOr;
        register FIX fxOffset;

        fxOffset = rcfxBound.xLeft;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.yTop;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

BOOL BEZIER32::bNext(POINTFIX* pptfx)
{
// Return current point:

    pptfx->x = x.fxValue() + rcfxBound.xLeft;
    pptfx->y = y.fxValue() + rcfxBound.yTop;

// If cSteps == 0, that was the end point in the curve!

    if (cSteps == 0)
        return(FALSE);

// Okay, we have to step:

    if (MAX(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
    {
        x.vHalveStepSize();
        y.vHalveStepSize();
        cSteps <<= 1;
    }

    ASSERTGDI(MAX(x.lError(), y.lError()) <= TEST_MAGNITUDE_NORMAL,
              "Please tell AndrewGo he was wrong");

    while (!(cSteps & 1) &&
           x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
           y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
    {
        x.vDoubleStepSize();
        y.vDoubleStepSize();
        cSteps >>= 1;
    }

    cSteps--;
    x.vTakeStep();
    y.vTakeStep();

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////
// BEZIER64
//
// All math is done using 64 bit fixed numbers in a 36.28 format.
//
// All drawing is done in a 31 bit space, then a 31 bit window offset
// is applied.  In the initial transform where we change to the HFD
// basis, e2 and e3 require the most bits precision: e2 = 6(p2 - 2p3 + p4).
// This requires an additional 4 bits precision -- hence we require 36 bits
// for the integer part, and the remaining 28 bits is given to the fraction.
//
// In rendering a Bezier, every 'subdivide' requires an extra 3 bits of
// fractional precision.  In order to be reversible, we can allow no
// error to creep in.  Since a FIX coordinate is 32 bits, and we
// require an additional 4 bits as mentioned above, that leaves us
// 28 bits fractional precision -- meaning we can do a maximum of
// 9 subdivides.  Now, the maximum absolute error of a Bezier curve in 27
// bit integer space is 2^29 - 1.  But 9 subdivides reduces the error by a
// guaranteed factor of 2^18, meaning we can crack down only to an error
// of 2^11 before we overflow, when in fact we want to crack error to less
// than 1.
//
// So what we do is HFD until we hit an error less than 2^11, reverse our
// basis transform to get the four control points of this smaller curve
// (rounding in the process to 32 bits), then invoke another copy of HFD
// on the reduced Bezier curve.  We again have enough precision, but since
// its starting error is less than 2^11, we can reduce error to 2^-7 before
// overflowing!  We'll start a low HFD after every step of the high HFD.
////////////////////////////////////////////////////////////////////////////

// The following is our 2^11 target error encoded as a 36.28 number
// (don't forget the additional 4 bits of fractional precision!) and
// the 6 times error multiplier:

LONGLONG geqErrorHigh = (LONGLONG)(6 * (1L << 15) >> (32 - FRACTION64)) << 32;

// The following is the default 2/3 error encoded as a 36.28 number,
// multiplied by 6, and leaving 4 bits for fraction:

LONGLONG geqErrorLow = (LONGLONG)4 << 32;

LONGLONG* gpeqErrorHigh = &geqErrorHigh;
LONGLONG* gpeqErrorLow  = &geqErrorLow;

INLINE FIX HFDBASIS64::fxValue()
{
// Convert from 36.28 and round:

    LONGLONG eq = e0;
    eq += (1L << (FRACTION64 - 1));
    eq >>= FRACTION64;
    return((FIX) (LONG) eq);
}

INLINE VOID HFDBASIS64::vParentError(LONGLONG* peq)
{
    *peq = MAX(ABS(e3 << 2), ABS((e2 << 3) - (e3 << 2)));
}

INLINE VOID HFDBASIS64::vError(LONGLONG* peq)
{
    *peq = MAX(ABS(e2), ABS(e3));
}


VOID HFDBASIS64::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
    LONGLONG eqTmp;
    LONGLONG eqP2 = (LONGLONG) p2;
    LONGLONG eqP3 = (LONGLONG) p3;

// e0 = p1
// e1 = p4 - p1
// e2 = 6(p2 - 2p3 + p4)
// e3 = 6(p1 - 2p2 + p3)

// Change basis:

    e0 = p1;                                        // e0 = p1
    e1 = p4;
    e2 = eqP2; e2 -= eqP3; e2 -= eqP3; e2 += e1;    // e2 = p2 - 2*p3 + p4
    e3 = e0;   e3 -= eqP2; e3 -= eqP2; e3 += eqP3;  // e3 = p1 - 2*p2 + p3
    e1 -= e0;                                       // e1 = p4 - p1

// Convert to 36.28 format and multiply e2 and e3 by six:

    e0 <<= FRACTION64;
    e1 <<= FRACTION64;
    eqTmp = e2; e2 += eqTmp; e2 += eqTmp; e2 <<= (FRACTION64 + 1);
    eqTmp = e3; e3 += eqTmp; e3 += eqTmp; e3 <<= (FRACTION64 + 1);
}

VOID HFDBASIS64::vUntransform(FIX* afx)
{
// Declare some temps to hold our operations, since we can't modify e0..e3.

    LONGLONG eqP0;
    LONGLONG eqP1;
    LONGLONG eqP2;
    LONGLONG eqP3;

// p0 = e0
// p1 = e0 + (6e1 - e2 - 2e3)/18
// p2 = e0 + (12e1 - 2e2 - e3)/18
// p3 = e0 + e1

    eqP0 = e0;

// NOTE PERF: Convert this to a multiply by 6: [andrewgo]

    eqP2 = e1;
    eqP2 += e1;
    eqP2 += e1;
    eqP1 = eqP2;
    eqP1 += eqP2;           // 6e1
    eqP1 -= e2;             // 6e1 - e2
    eqP2 = eqP1;
    eqP2 += eqP1;           // 12e1 - 2e2
    eqP2 -= e3;             // 12e1 - 2e2 - e3
    eqP1 -= e3;
    eqP1 -= e3;             // 6e1 - e2 - 2e3

// NOTE PERF: May just want to approximate these divides! [andrewgo]
// Or can do a 64 bit divide by 32 bit to get 32 bits right here.

    VDIV(eqP1, 18, 0);
    VDIV(eqP2, 18, 0);
    eqP1 += e0;
    eqP2 += e0;

    eqP3 = e0;
    eqP3 += e1;

// Convert from 36.28 format with rounding:

    eqP0 += (1L << (FRACTION64 - 1)); eqP0 >>= FRACTION64; afx[0] = (LONG) eqP0;
    eqP1 += (1L << (FRACTION64 - 1)); eqP1 >>= FRACTION64; afx[2] = (LONG) eqP1;
    eqP2 += (1L << (FRACTION64 - 1)); eqP2 >>= FRACTION64; afx[4] = (LONG) eqP2;
    eqP3 += (1L << (FRACTION64 - 1)); eqP3 >>= FRACTION64; afx[6] = (LONG) eqP3;
}

VOID HFDBASIS64::vHalveStepSize()
{
// e2 = (e2 + e3) >> 3
// e1 = (e1 - e2) >> 1
// e3 >>= 2

    e2 += e3; e2 >>= 3;
    e1 -= e2; e1 >>= 1;
    e3 >>= 2;
}

VOID HFDBASIS64::vDoubleStepSize()
{
// e1 = 2e1 + e2
// e3 = 4e3;
// e2 = 8e2 - e3

    e1 <<= 1; e1 += e2;
    e3 <<= 2;
    e2 <<= 3; e2 -= e3;
}

VOID HFDBASIS64::vTakeStep()
{
    e0 += e1;
    LONGLONG eqTmp = e2;
    e1 += e2;
    e2 += eqTmp; e2 -= e3;
    e3 = eqTmp;
}

VOID BEZIER64::vInit(
POINTFIX* aptfx,        // Pointer to 4 control points
RECTFX*   prcfxVis,     // Pointer to bound box of visible area (may be NULL)
LONGLONG*    peqError)     // Fractional maximum error (32.32 format)
{
    LONGLONG eqTmp;

    cStepsHigh = 1;
    cStepsLow  = 0;

    xHigh.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    yHigh.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

// Initialize error:

    eqErrorLow = *peqError;

    if (prcfxVis == (RECTFX*) NULL)
        prcfxClip = (RECTFX*) NULL;
    else
    {
        rcfxClip = *prcfxVis;
        prcfxClip = &rcfxClip;
    }

    while (((xHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh) ||
           ((yHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh))
    {
        cStepsHigh <<= 1;
        xHigh.vHalveStepSize();
        yHigh.vHalveStepSize();
    }
}

// Returns TRUE if there is another point after this one:

BOOL BEZIER64::bNext(POINTFIX* pptfx)
{
    POINTFIX aptfx[4];
    RECTFX   rcfxBound;
    LONGLONG    eqTmp;

    if (cStepsLow == 0)
    {
    // Optimization that if the bound box of the control points doesn't
    // intersect with the bound box of the visible area, render entire
    // curve as a single line:

        xHigh.vUntransform(&aptfx[0].x);
        yHigh.vUntransform(&aptfx[0].y);

        xLow.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
        yLow.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);
        cStepsLow = 1;

        if (prcfxClip != (RECTFX*) NULL)
            vBoundBox(aptfx, &rcfxBound);


        if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
        {
            while (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
                   ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
            {
                cStepsLow <<= 1;
                xLow.vHalveStepSize();
                yLow.vHalveStepSize();
            }
        }

    // This 'if' handles the case where the initial error for the Bezier
    // is already less than the target error:

        if (--cStepsHigh != 0)
        {
            xHigh.vTakeStep();
            yHigh.vTakeStep();

            if (((xHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh) ||
                ((yHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh))
            {
                cStepsHigh <<= 1;
                xHigh.vHalveStepSize();
                yHigh.vHalveStepSize();
            }

            while (!(cStepsHigh & 1) &&
                   ((xHigh.vParentError(&eqTmp), eqTmp) <= *gpeqErrorHigh) &&
                   ((yHigh.vParentError(&eqTmp), eqTmp) <= *gpeqErrorHigh))
            {
                xHigh.vDoubleStepSize();
                yHigh.vDoubleStepSize();
                cStepsHigh >>= 1;
            }
        }
    }

    xLow.vTakeStep();
    yLow.vTakeStep();

    pptfx->x = xLow.fxValue();
    pptfx->y = yLow.fxValue();

    cStepsLow--;
    if (cStepsLow == 0 && cStepsHigh == 0)
        return(FALSE);

    if (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
        ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
    {
        cStepsLow <<= 1;
        xLow.vHalveStepSize();
        yLow.vHalveStepSize();
    }

    while (!(cStepsLow & 1) &&
           ((xLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow) &&
           ((yLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow))
    {
        xLow.vDoubleStepSize();
        yLow.vDoubleStepSize();
        cStepsLow >>= 1;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* newpathrec (pppr,pcMax,cNeeded)					   *
*									   *
* Create a new pathrecord.						   *
*									   *
* History:								   *
*  Fri 19-Jun-1992 19:24:56 -by- Charles Whitmer [chuckwh]		   *
* Added the quick out if we get enough points.				   *
*									   *
*  5-Dec-1990 -by- Paul Butzi [paulb]					   *
* Wrote it.								   *
\**************************************************************************/

BOOL EPATHOBJ::newpathrec(PATHRECORD **pppr,COUNT *pcMax,COUNT cNeeded)
{
    PATHALLOC *ppa = ppath->ppachain;

    *pcMax = 0;

    if ( ppa != (PPATHALLOC) NULL )
    {
    // we have a current pathalloc, see how much will fit
    // computation done into temps to avoid compiler assertion!

        POINTFIX *start = &(ppa->pprfreestart->aptfx[0]);
        POINTFIX *end = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

        if ( end > start )
        {
            //Sundown safe truncation
            ASSERT4GB((ULONGLONG)(end - start));
            *pcMax = (ULONG)(end - start);
        }
    }

// Now we can decide if we need a new pathalloc

    if ((*pcMax < cNeeded) && (*pcMax < PATHALLOCTHRESHOLD))
    {
    // allocate a new pathalloc, link it into path

        if ( (ppa = newpathalloc()) == (PPATHALLOC) NULL)
            return FALSE;

        ppa->ppanext = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

    // Sundown safe truncation

        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONG numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);

        *pcMax = (numbytes - offsetof(PATHRECORD, aptfx))/sizeof(POINTFIX);
    }

// create new pathrec header

    *pppr = ppa->pprfreestart;

    return(TRUE);
}


/******************************Public*Routine******************************\
* EPATHOBJ::bFlatten()
*
* Cruise over a path, translating all of the beziers into sequences of lines.
*
* History:
*  5-Dec-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bFlatten()
{
// stress failure in RFONTOBJ::bInsertMetricsPlusPath caused by invalid
// ppath. After Beta2, we will pick up the fix from Adobe.

    if (!bValid())
    {
        return (FALSE);
    }

// Run down the path, looking for records that contain beziers.
// Skip over the records containing lines.

    for ( PATHRECORD *ppr = ppath->pprfirst;
          ppr != (PPATHREC) NULL;
          ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_BEZIERS)
        {
            ppr = pprFlattenRec(ppr);
            if (ppr == (PPATHREC) NULL)
                return(FALSE);
        }
    }

    fl &= ~PO_BEZIERS;

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::pprFlattenRec(ppr)
*
* Cruise over a path, translating all of the beziers into sequences of lines.
*
* History:
*  5-Dec-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PPATHREC EPATHOBJ::pprFlattenRec(PATHRECORD *ppr)
{
// Create a new record

    PATHRECORD *pprNew;
    COUNT maxadd;

    if ( newpathrec(&pprNew,&maxadd,MAXLONG) != TRUE )
        return (PPATHREC) NULL;

// Take record of Beziers out of path list, and put a new record
// in its place.  Update 'pprNew->pprnext' when we exit.

    pprNew->pprprev = ppr->pprprev;
    pprNew->count = 0;
    pprNew->flags = (ppr->flags & ~PD_BEZIERS);

    if (pprNew->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprNew;
    else
        pprNew->pprprev->pprnext = pprNew;

    POINTFIX  aptfxControl[4];   // If needed, temp buf for control points
    PPOINTFIX pptfxControl;      // Points to Bezier's 4 control points
    PPOINTFIX pptfxNext;         // Points to 2nd point of next Bezier

// Now, run down the beziers, flattening them into the record
// First, set up for the first bezier in record

    if ((ppr->flags & PD_BEGINSUBPATH) == 0)
    {
    // Because we are not starting a new subpath we don't need to
    // enter the first control point into the record of lines.  Since
    // all 4 control points for the first Bezier aren't contiguous in
    // memory, copy the points to aptfxControl[].

        aptfxControl[0] = ppr->pprprev->aptfx[ppr->pprprev->count - 1];
        pptfxNext = ppr->aptfx;

        for (LONG ii = 1; ii < 4; ii++)
        {

        // If the Bezier's control points are spread across two
        // pathrecords, then handle it.

            if (pptfxNext >= &ppr->aptfx[ppr->count])
            {
                ASSERTGDI(ppr->pprnext != NULL, "Lost the other control points");
                ppr = ppr->pprnext;
                ASSERTGDI((ppr->flags & (PD_BEZIERS | PD_BEGINSUBPATH)) != 0,
                          "Mucked up continuation");
                pptfxNext = ppr->aptfx;
            }
            aptfxControl[ii] = *pptfxNext++;
        }
        pptfxControl = aptfxControl;

        ASSERTGDI(PATHALLOCTHRESHOLD > 3, "Threshold too small.");
        ASSERTGDI(pptfxNext <= &ppr->aptfx[ppr->count], "Threshold too small");
    }
    else
    {
        pptfxNext = ppr->aptfx + 4;
        pptfxControl = ppr->aptfx;
        pprNew->aptfx[pprNew->count++] = ppr->aptfx[0];
    }

// Now run down the list of Beziers, flattening them out.

    while (TRUE)
    {
    // We've removing a curve, so adjust the curve count appropriately:

        cCurves--;

    // Crack Bezier described by points pointed to by pptfxControl:

        BEZIER bez;
        bez.vInit(pptfxControl);

        do
        {
            if ( pprNew->count >= maxadd )
            {
            // Since we're continuing this path record onto another,
            // we have to adjust this record's flags to note that:

                pprNew->flags &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);

            // Filled the record, get a new one.  Insert it after one we
            // just filled and adjust the pathalloc record.

                ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);

                PATHRECORD *pprNewNew;
		if (newpathrec(&pprNewNew,&maxadd,MAXLONG) != TRUE)
                    return((PPATHREC) NULL);

                pprNewNew->pprprev = pprNew;
                pprNew->pprnext = pprNewNew;
                pprNew = pprNewNew;

                pprNew->count = 0;
                pprNew->flags = (ppr->flags &
                              ~(PD_BEZIERS | PD_BEGINSUBPATH | PD_RESETSTYLE));
            }

        // Now that we've generated the next point, stash it into the
        // new path record:

            cCurves++;

        } while (bez.bNext(&pprNew->aptfx[pprNew->count++]));

    // Move on to the next bezier:

    // Sundown safe truncation
        COUNT cptfxRemaining = (COUNT)(&ppr->aptfx[ppr->count] - pptfxNext);

        if (cptfxRemaining <= 0)
            break;

        if (cptfxRemaining >= 3)
        {
            pptfxControl = pptfxNext - 1;
            pptfxNext += 3;
        }
        else
        {

        // Handle case where the Bezier's control points are spread
        // across two pathrecord's.  Copy all the points to
        // aptfxControl[].

            pptfxNext--;
            for (INT ii = 0; ii < 4; ii++)
            {
                if (pptfxNext >= &ppr->aptfx[ppr->count])
                {
                    ASSERTGDI(ppr != NULL, "Lost the other control points.");
                    ppr = ppr->pprnext;
                    ASSERTGDI((ppr->flags &
                              (PD_BEZIERS | PD_BEGINSUBPATH)) != 0,
                              "Mucked up continuation.");
                    pptfxNext = ppr->aptfx;
                }
                aptfxControl[ii] = *pptfxNext++;
            }
            pptfxControl = aptfxControl;
        }
    }

    ASSERTGDI(pptfxNext == &ppr->aptfx[ppr->count], "Lost some points");

// Adjust the pathalloc record:

    ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);

    pprNew->pprnext = ppr->pprnext;
    if (pprNew->pprnext == (PPATHREC) NULL)
        ppath->pprlast = pprNew;
    else
        pprNew->pprnext->pprprev = pprNew;

    return(pprNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pattern.cxx ===
/******************************Module*Header*******************************\
* Module Name: pattern.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with patterns.
*
* Created: 07-Mar-1992 13:12:58
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

ULONG aulLeftMask[] =
{
    0xFFFFFFFF,
    0xFFFFFF00,
    0xFFFF0000,
    0xFF000000
};

#define DBG_PAT_CPY 0

#if DBG_PAT_CPY
    ULONG   DbgPatCpy = 0;
#endif

/******************************Public*Routine******************************\
* vPatCpyRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];


    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD


// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0) 
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat); 
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;



// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

// Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulRght) | (FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatNotRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatNotRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];

    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD

// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0)
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;

// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

    // Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulLeft) | (~FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchNotAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftNotAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat   = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulRght) | (~FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatXorRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatXorRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];

    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD

// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0)
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;

// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

    // Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg ^= (FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat   = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchAndMerge(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftAndMerge(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat  = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg ^= (FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatCpyRow8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1) - ((-yPat-1) % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left  * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);

        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchAndCopy(&ff);
                }
                else
                    vFetchShiftAndCopy(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp  = (*pulTmp & ~ulRght) | (FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatCpyRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}

/******************************Public*Routine******************************\
* vPatNotRow8
*
* Tiles the NOT of a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   converted from traps to rows
*
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatNotRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1) - ((-yPat-1) % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp  = (*pulTmp & ~ulLeft) | (~FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchNotAndCopy(&ff);
                }
                else
                    vFetchShiftNotAndCopy(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp  = (*pulTmp & ~ulRght) | (~FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatNotRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}

/******************************Public*Routine******************************\
* vPatXorRow8
*
* XOR Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   Converted from traps to rows
*
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatXorRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1)  - ((-yPat-1)  % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp ^= (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp ^= (FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchAndMerge(&ff);
                }
                else
                    vFetchShiftAndMerge(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp ^= (FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatXorRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}



/******************************Public*Routine******************************\
* vPatternCopyLoopRow
*
* This is the inner loop of the 1 bpp and 4 bpp bitmap SrcCpy PatBlt-ing
* routines, this is were we finally write the DWORDs to the bitmap.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   Converted from rects to rows
*
*  19-2-93 checker
*       ported stephene's stuff
\**************************************************************************/

VOID vPatternCopyLoopRow(LONG lCurYTop, ULONG *pulTrg, PATBLTFRAME *ppbf,
    int ulFillType, ULONG ulRightPatMask, ULONG ulLeftPatMask,
    ULONG ulRightDestMask, ULONG ulLeftDestMask, LONG lMiddleDwords,
    PULONG pulBasePat)
{
    ULONG   *pulPatPtr;
    LONG    lMiddleBytes;
    ULONG   ulPattern;
    ULONG   ulRightDestMaskedPattern;
    ULONG   ulLeftDestMaskedPattern;

    lMiddleBytes = lMiddleDwords << 2;

    pulPatPtr = pulBasePat + ((lCurYTop - ppbf->yPat) & 0x07);

    // Set up the appropriately rotated version of the current pattern scan

    ulPattern = *pulPatPtr;

    // Draw all Y scans for this pattern byte

    switch(ulFillType)
    {
    case LEFT_MIDDLE_RIGHT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
        *(pulTrg+lMiddleDwords+1) =
                (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT_MIDDLE:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
        break;

    case MIDDLE_RIGHT:
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
        *(pulTrg+lMiddleDwords) =
                (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case MIDDLE:
        RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
        break;

    case LEFT_MIDDLE_RIGHT_SHORT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+9) = ulPattern;
            case 8:
                *(pulTrg+8) = ulPattern;
            case 7:
                *(pulTrg+7) = ulPattern;
            case 6:
                *(pulTrg+6) = ulPattern;
            case 5:
                *(pulTrg+5) = ulPattern;
            case 4:
                *(pulTrg+4) = ulPattern;
            case 3:
                *(pulTrg+3) = ulPattern;
            case 2:
                *(pulTrg+2) = ulPattern;
            case 1:
                *(pulTrg+1) = ulPattern;
                break;
        }
        *(pulTrg+lMiddleDwords+1) =
                (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT_MIDDLE_SHORT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+9) = ulPattern;
            case 8:
                *(pulTrg+8) = ulPattern;
            case 7:
                *(pulTrg+7) = ulPattern;
            case 6:
                *(pulTrg+6) = ulPattern;
            case 5:
                *(pulTrg+5) = ulPattern;
            case 4:
                *(pulTrg+4) = ulPattern;
            case 3:
                *(pulTrg+3) = ulPattern;
            case 2:
                *(pulTrg+2) = ulPattern;
            case 1:
                *(pulTrg+1) = ulPattern;
                break;
        }
        break;

    case MIDDLE_RIGHT_SHORT:
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+8) = ulPattern;
            case 8:
                *(pulTrg+7) = ulPattern;
            case 7:
                *(pulTrg+6) = ulPattern;
            case 6:
                *(pulTrg+5) = ulPattern;
            case 5:
                *(pulTrg+4) = ulPattern;
            case 4:
                *(pulTrg+3) = ulPattern;
            case 3:
                *(pulTrg+2) = ulPattern;
            case 2:
                *(pulTrg+1) = ulPattern;
            case 1:
                *(pulTrg) = ulPattern;
                break;
        }
        *(pulTrg+lMiddleDwords) =
                (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case MIDDLE_SHORT:
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+8) = ulPattern;
            case 8:
                *(pulTrg+7) = ulPattern;
            case 7:
                *(pulTrg+6) = ulPattern;
            case 6:
                *(pulTrg+5) = ulPattern;
            case 5:
                *(pulTrg+4) = ulPattern;
            case 4:
                *(pulTrg+3) = ulPattern;
            case 3:
                *(pulTrg+2) = ulPattern;
            case 2:
                *(pulTrg+1) = ulPattern;
            case 1:
                *(pulTrg) = ulPattern;
                break;
        }
        break;

    case LEFT_RIGHT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        *(pulTrg+1) = (*(pulTrg+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        break;
    }
}


/******************************Public*Routine******************************\
* vPatCpyRow4_8x8
*
* Tiles an 8x8 pattern to 4 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRow4_8x8(PATBLTFRAME *ppbf, LONG yStart, INT crow)
{
    PULONG pulTrgBase;
    LONG lMiddleDwords;
    LONG lMiddleBytes;
    int ulFillType;
    ULONG ulLeftDestMask;
    ULONG ulRightDestMask;
    ULONG ulLeftPatMask;
    ULONG ulRightPatMask;
    UCHAR ucPatRotateRight;
    UCHAR ucPatRotateLeft;
    ULONG ulTemp;
    ULONG *pulPatMax;
    ULONG *pulBasePat;
    ULONG *pulTempSrc;
    ULONG *pulTempDst;
    ULONG ulAlignedPat[8];  // temp storage for rotated pattern
    static ULONG aulMask[8] = { 0, 0x000000F0, 0x000000FF, 0x0000F0FF,
                                0x0000FFFF, 0x00F0FFFF, 0x00FFFFFF, 0xF0FFFFFF};

// Point to list of rectangles to fill

    PROW prow = (PROW) ppbf->pvObj;

// Rotate the pattern if needed, storing in a temp buffer. This way we only
// rotate once, no matter how many fills we perform per call

    if (ppbf->xPat == 0)
    {
        pulBasePat = (ULONG *)ppbf->pvPat;  // no rotation; that's easy

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;
    }
    else
    {

    // Set up the shifts to produce the rotation effect to align the pattern
    // as specified (the results of the two shifts are ORed together to emulate
    // the rotate, because C can't do rotations directly)

        ucPatRotateRight = (UCHAR) ppbf->xPat << 2;
        ucPatRotateLeft = (sizeof(ULONG) * 8) - ucPatRotateRight;
        pulTempSrc = (ULONG *)ppbf->pvPat;
        pulTempDst = ulAlignedPat;
        pulBasePat = pulTempDst;

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;

        while (pulTempDst < pulPatMax)
        {

        // Go through this mess to convert to big endian, so we can rotate

            *(((UCHAR *)&ulTemp) + 3) = *(((UCHAR *)pulTempSrc) + 0);
            *(((UCHAR *)&ulTemp) + 2) = *(((UCHAR *)pulTempSrc) + 1);
            *(((UCHAR *)&ulTemp) + 1) = *(((UCHAR *)pulTempSrc) + 2);
            *(((UCHAR *)&ulTemp) + 0) = *(((UCHAR *)pulTempSrc) + 3);

        // Rotate the pattern into position

            ulTemp = (ulTemp >> ucPatRotateRight) |
                (ulTemp << ucPatRotateLeft);

        // Convert back to little endian, so we can store the pattern for
        // use in drawing

            *(((UCHAR *)pulTempDst) + 3) = *(((UCHAR *)&ulTemp) + 0);
            *(((UCHAR *)pulTempDst) + 2) = *(((UCHAR *)&ulTemp) + 1);
            *(((UCHAR *)pulTempDst) + 1) = *(((UCHAR *)&ulTemp) + 2);
            *(((UCHAR *)pulTempDst) + 0) = *(((UCHAR *)&ulTemp) + 3);

            pulTempSrc++;
            pulTempDst++;
        }
    }

    // advance to the first scan

    PBYTE pjBase = (BYTE *) ppbf->pvTrg + (ppbf->lDeltaTrg * yStart);

// Loop through all rectangles to fill

    do
    {

    // Set up AND/OR masks for partial-dword edges, for masking both the
    // pattern dword and the destination dword (the pattern and destination
    // masks are complementary). A solid dword is 0 for dest, -1 for pattern

        ulLeftDestMask = aulMask[prow->left & 0x07];
        ulLeftPatMask = ~ulLeftDestMask;

        if ((ulRightPatMask = aulMask[prow->right & 0x07]) == 0)
        {
            ulRightPatMask = 0xFFFFFFFF; // force solid to -1 for pattern
        }
        ulRightDestMask = ~ulRightPatMask;

    // Point to the first dword to fill

        pulTrgBase = (ULONG *) (pjBase + ((prow->left >> 1) & ~3));

    // Number of whole middle dwords/bytes to fill a dword at a time

        lMiddleDwords = (((LONG)(prow->right >> 1) & ~0x03) -
                (((LONG)(prow->left + 7) >> 1) & ~0x03)) >> 2;
        lMiddleBytes = lMiddleDwords << 2;

    // Set up for the appropriate fill, given partial dwords at edges and
    // narrow cases

        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        vPatternCopyLoopRow(yStart,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            pulBasePat);

    // Point to the next rectangle to fill, if there is one

        prow++;
        yStart++    ;
        pjBase += ppbf->lDeltaTrg;
    }
    while (--crow);
}

/******************************Public*Routine******************************\
* vPatCpyRect4_8x8
*
* Tiles an 8x8 pattern to 4 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRect4_8x8(PATBLTFRAME *ppbf, INT crcl)
{

    PULONG pulTrgBase;
    PRECTL prcl;
    LONG lDelta;
    LONG lDeltaX8;
    LONG lMiddleDwords;
    LONG lMiddleBytes;
	int ulFillType;
    ULONG ulLeftDestMask;
    ULONG ulRightDestMask;
    ULONG ulLeftPatMask;
    ULONG ulRightPatMask;
    UCHAR ucPatRotateRight;
    UCHAR ucPatRotateLeft;
    ULONG ulTemp;
    ULONG *pulPatMax;
    ULONG *pulBasePat;
    ULONG *pulTempSrc;
    ULONG *pulTempDst;
    ULONG ulAlignedPat[8];  // temp storage for rotated pattern
    static ULONG aulMask[8] = { 0, 0x000000F0, 0x000000FF, 0x0000F0FF,
                                0x0000FFFF, 0x00F0FFFF, 0x00FFFFFF, 0xF0FFFFFF};

// Point to list of rectangles to fill

    prcl = (RECTL *) ppbf->pvObj;

// Offset to next scan, offset to every eighth scan

    lDeltaX8 = (lDelta = ppbf->lDeltaTrg) << 3;

// Rotate the pattern if needed, storing in a temp buffer. This way we only
// rotate once, no matter how many fills we perform per call

    if (ppbf->xPat == 0)
    {
        pulBasePat = (ULONG *)ppbf->pvPat;  // no rotation; that's easy

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;
    }
    else
    {

    // Set up the shifts to produce the rotation effect to align the pattern
    // as specified (the results of the two shifts are ORed together to emulate
    // the rotate, because C can't do rotations directly)

        ucPatRotateRight = (UCHAR) ppbf->xPat << 2;
        ucPatRotateLeft = (sizeof(ULONG) * 8) - ucPatRotateRight;
        pulTempSrc = (ULONG *)ppbf->pvPat;
        pulTempDst = ulAlignedPat;
        pulBasePat = pulTempDst;

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;

        while (pulTempDst < pulPatMax)
        {

        // Go through this mess to convert to big endian, so we can rotate

            *(((UCHAR *)&ulTemp) + 3) = *(((UCHAR *)pulTempSrc) + 0);
            *(((UCHAR *)&ulTemp) + 2) = *(((UCHAR *)pulTempSrc) + 1);
            *(((UCHAR *)&ulTemp) + 1) = *(((UCHAR *)pulTempSrc) + 2);
            *(((UCHAR *)&ulTemp) + 0) = *(((UCHAR *)pulTempSrc) + 3);

        // Rotate the pattern into position

            ulTemp = (ulTemp >> ucPatRotateRight) |
                (ulTemp << ucPatRotateLeft);

        // Convert back to little endian, so we can store the pattern for
        // use in drawing

            *(((UCHAR *)pulTempDst) + 3) = *(((UCHAR *)&ulTemp) + 0);
            *(((UCHAR *)pulTempDst) + 2) = *(((UCHAR *)&ulTemp) + 1);
            *(((UCHAR *)pulTempDst) + 1) = *(((UCHAR *)&ulTemp) + 2);
            *(((UCHAR *)pulTempDst) + 0) = *(((UCHAR *)&ulTemp) + 3);

            pulTempSrc++;
            pulTempDst++;
        }
    }


// Loop through all rectangles to fill

    do
    {

    // Set up AND/OR masks for partial-dword edges, for masking both the
    // pattern dword and the destination dword (the pattern and destination
    // masks are complementary). A solid dword is 0 for dest, -1 for pattern

        ulLeftDestMask = aulMask[prcl->left & 0x07];
        ulLeftPatMask = ~ulLeftDestMask;

        if ((ulRightPatMask = aulMask[prcl->right & 0x07]) == 0)
        {
            ulRightPatMask = 0xFFFFFFFF; // force solid to -1 for pattern
        }
        ulRightDestMask = ~ulRightPatMask;

    // Point to the first dword to fill

        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                (ppbf->lDeltaTrg * prcl->top) + ((prcl->left >> 1) & ~3));

    // Number of whole middle dwords/bytes to fill a dword at a time

        lMiddleDwords = (((LONG)(prcl->right >> 1) & ~0x03) -
                (((LONG)(prcl->left + 7) >> 1) & ~0x03)) >> 2;
        lMiddleBytes = lMiddleDwords << 2;

    // Set up for the appropriate fill, given partial dwords at edges and
    // narrow cases

        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        vPatternCopyLoop(prcl,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            lDelta,lDeltaX8,pulBasePat,pulPatMax);

    // Point to the next rectangle to fill, if there is one

        prcl++;

    }
    while (--crcl);
}

/******************************Public*Routine******************************\
* vPatternCopyLoop
*
* This is the inner loop of the 1 bpp and 4 bpp bitmap SrcCpy PatBlt-ing
* routines, this is were we finally write the DWORDs to the bitmap.
*
* History:
*  19-2-93 checker
*       ported stephene's stuff
\**************************************************************************/

VOID vPatternCopyLoop( PRECTL prcl, ULONG *pulTrgBase, PATBLTFRAME *ppbf,
    int ulFillType, ULONG ulRightPatMask, ULONG ulLeftPatMask,
    ULONG ulRightDestMask, ULONG ulLeftDestMask, LONG lMiddleDwords,
    LONG lDelta, LONG lDeltaX8, PULONG pulBasePat, PULONG pulPatMax )
{
    ULONG   ulUniqueScans;
    LONG    lCurYTop;
    ULONG   *pulPatPtr;
    LONG    lMiddleBytes;
    ULONG   ulPattern;
    ULONG   ulNumScans;
    ULONG   *pulTrg;
    ULONG   ulRightDestMaskedPattern;
    ULONG   ulLeftDestMaskedPattern;


    lMiddleBytes = lMiddleDwords << 2;

    lCurYTop = prcl->top;
    pulPatPtr = pulBasePat + ((lCurYTop - ppbf->yPat) & 0x07);

    // Loop through up to all 8 pattern bytes, rotating into dword alignment,
    // generating the left and right masked versions, and drawing all lines
    // that use each pattern byte before proceeding to the next pattern byte

    // Do either all 8 pattern scans or the number of scans the fill is high,
    // whichever is less

    ulUniqueScans = 8;
    if ((prcl->bottom - prcl->top) < 8)
    {
        ulUniqueScans = prcl->bottom - prcl->top;
    }

    while (ulUniqueScans--)
    {

        // Point to scan to fill, then advance to next scan for next time

        pulTrg = pulTrgBase;
        pulTrgBase = (ULONG *)(((UCHAR *)pulTrgBase) + lDelta);

        // Set up the number of scans to fill with this pattern scan, given
        // that we'll do every eighth scan

        ulNumScans = (prcl->bottom - lCurYTop + 7) >> 3;
        lCurYTop++;     // we'll start on the next destination scan for the
                        //  next pattern scan

        // Set up the appropriately rotated version of the current pattern scan

        ulPattern = *pulPatPtr;


        // Advance the pattern pointer to the next pattern scan

        if (++pulPatPtr == pulPatMax)
        {
            pulPatPtr = pulBasePat;
        }

        // Draw all Y scans for this pattern byte

        switch(ulFillType)
        {
        case LEFT_MIDDLE_RIGHT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
                *(pulTrg+lMiddleDwords+1) =
                        (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_RIGHT:
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
                *(pulTrg+lMiddleDwords) =
                        (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE:
            do
            {
                RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE_RIGHT_SHORT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+9) = ulPattern;
                    case 8:
                        *(pulTrg+8) = ulPattern;
                    case 7:
                        *(pulTrg+7) = ulPattern;
                    case 6:
                        *(pulTrg+6) = ulPattern;
                    case 5:
                        *(pulTrg+5) = ulPattern;
                    case 4:
                        *(pulTrg+4) = ulPattern;
                    case 3:
                        *(pulTrg+3) = ulPattern;
                    case 2:
                        *(pulTrg+2) = ulPattern;
                    case 1:
                        *(pulTrg+1) = ulPattern;
                        break;
                }
                *(pulTrg+lMiddleDwords+1) =
                        (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE_SHORT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+9) = ulPattern;
                    case 8:
                        *(pulTrg+8) = ulPattern;
                    case 7:
                        *(pulTrg+7) = ulPattern;
                    case 6:
                        *(pulTrg+6) = ulPattern;
                    case 5:
                        *(pulTrg+5) = ulPattern;
                    case 4:
                        *(pulTrg+4) = ulPattern;
                    case 3:
                        *(pulTrg+3) = ulPattern;
                    case 2:
                        *(pulTrg+2) = ulPattern;
                    case 1:
                        *(pulTrg+1) = ulPattern;
                        break;
                }
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_RIGHT_SHORT:
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+8) = ulPattern;
                    case 8:
                        *(pulTrg+7) = ulPattern;
                    case 7:
                        *(pulTrg+6) = ulPattern;
                    case 6:
                        *(pulTrg+5) = ulPattern;
                    case 5:
                        *(pulTrg+4) = ulPattern;
                    case 4:
                        *(pulTrg+3) = ulPattern;
                    case 3:
                        *(pulTrg+2) = ulPattern;
                    case 2:
                        *(pulTrg+1) = ulPattern;
                    case 1:
                        *(pulTrg) = ulPattern;
                        break;
                }
                *(pulTrg+lMiddleDwords) =
                        (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_SHORT:
            do
            {
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+8) = ulPattern;
                    case 8:
                        *(pulTrg+7) = ulPattern;
                    case 7:
                        *(pulTrg+6) = ulPattern;
                    case 6:
                        *(pulTrg+5) = ulPattern;
                    case 5:
                        *(pulTrg+4) = ulPattern;
                    case 4:
                        *(pulTrg+3) = ulPattern;
                    case 3:
                        *(pulTrg+2) = ulPattern;
                    case 2:
                        *(pulTrg+1) = ulPattern;
                    case 1:
                        *(pulTrg) = ulPattern;
                        break;
                }
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_RIGHT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                *(pulTrg+1) = (*(pulTrg+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        }
    }
}


/******************************Public*Routine******************************\
* vPatCpyRect1_8x8
*
* Tiles an 8x8 pattern to 1 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  17-Nov-1992 -by- Stephen Estrop [StephenE]
* Wrote it.
\**************************************************************************/
VOID vPatCpyRect1_8x8(PATBLTFRAME *ppbf, INT crcl)
{
    PRECTL          prcl;
    ULONG           *pulTrgBase;
    int              ulFillType;
    ULONG           ulRightPatMask;
    ULONG           ulLeftPatMask;
    ULONG           ulRightDestMask;
    ULONG           ulLeftDestMask;
    LONG            lMiddleDwords;
    LONG            lDelta;
    LONG            lDeltaX8;
    ULONG           aulRotatedPat[8];

    UCHAR                   ucPatRotateRight;
    UCHAR                   ucPatRotateLeft;
    ULONG                   ulPattern;
    ULONG                   *pulPatPtr;
    ULONG                   *pulPatRot;
    ULONG                   *pulPatMax;
    extern ULONG            aulMsk[];    // Defined in solid.cxx

    //
    // Point to list of rectangles to fill
    //
    prcl = (RECTL *)ppbf->pvObj;

    //
    // Offset to next scan, offset to every eighth scan
    //
    lDeltaX8 = (lDelta = ppbf->lDeltaTrg) << 3;

    //
    // Loop through all rectangles to fill
    //
    do {
        //
        // Set up AND/OR masks for partial-dword edges, for masking both the
        // pattern dword and the destination dword (the pattern and destination
        // masks are complementary). A solid dword is 0 for dest, -1 for
        // pattern
        //
        ulLeftPatMask = aulMsk[prcl->left & 31];
        ulLeftDestMask = ~ulLeftPatMask;

        if ((ulRightDestMask = aulMsk[prcl->right & 31]) == 0xFFFFFFFF)
        {
            ulRightDestMask = 0x00; // force solid to -1 for pattern
        }
        ulRightPatMask = ~ulRightDestMask;

        //
        // Point to the first dword to fill
        //
        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                     (ppbf->lDeltaTrg * prcl->top)) + (prcl->left >> 5);

        //
        // Number of whole middle dwords/bytes to fill a dword at a time
        //
        lMiddleDwords = (LONG)(prcl->right >> 5) -
                          ((LONG)(prcl->left + 31 ) >> 5);

        //
        // Set up for the appropriate fill, given partial dwords at edges and
        // narrow cases
        //
        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        //
        // Set up the shifts to produce the rotation effect to align the
        // pattern as specified (the results of the two shifts are ORed
        // together to emulate the rotate, because C can't do rotations
        // directly)
        //
        ucPatRotateRight = (UCHAR) ppbf->xPat;
        ucPatRotateLeft  = (sizeof(ULONG) * 8) - ucPatRotateRight;

        //
        // Construct a replicated and aligned pattern.
        //
        pulPatPtr = (ULONG *)ppbf->pvPat,
        pulPatMax = (ULONG *)ppbf->pvPat + 8,
        pulPatRot = aulRotatedPat;

        while ( pulPatPtr < pulPatMax ) {

            //
            // Assume only the first 8 bits are good, so replicate these.
            //
            ulPattern  = *pulPatPtr++  >> 24;
            ulPattern |= ulPattern << 8;
            ulPattern |= ulPattern << 16;

            //
            // Rotate the pattern to align it correctly
            //
            if (ucPatRotateRight) {
                ulPattern = (ulPattern >> ucPatRotateRight) |
                            (ulPattern << ucPatRotateLeft);
            }
            *pulPatRot++ = ulPattern;
        }

        //
        // Do the PatBlt to this rectangle
        //

        pulPatMax = aulRotatedPat + 8;

        vPatternCopyLoop(prcl,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            lDelta,lDeltaX8,aulRotatedPat,pulPatMax);

        //
        // Point to the next rectangle to fill, if there is one
        //
        prcl++;

    }
    while (--crcl);

}

/******************************Public*Routine******************************\
* vPatCpyRect1_6x6
*
* Tiles an 6x6 pattern to 1 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 8).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-5.
* Assumes there is at least one rectangle to fill.
*
* History:
*  23-Nov-1992 -by- Stephen Estrop [StephenE]
* Wrote it.
*
\**************************************************************************/
VOID vPatCpyRect1_6x6(PATBLTFRAME *ppbf, INT crcl)
{
    UCHAR                   ucPatRotateRight;
    UCHAR                   ucPatRotateLeft;
    PRECTL                  prcl;

    /*
    ** lDelta is offset to the next scan in bytes, lDelta6 is the offset to
    ** the next repeated scan in bytes.
    */
    LONG                    lDelta;
    LONG                    lDelta6;

    /*
    ** pulTrgBase points to the first DWORD of the target rectangle in the
    ** bitmap.
    */
    ULONG                   *pulTrgBase;
    ULONG                   *pulTrg;
    ULONG                   *pulTrgStart; // ptr to first DWORD in scan

    /*
    ** The pattern repeats in the LCM of 32 and 6 bits, which is 96 bits or
    ** 3 Dwords.  We actually repeat the pattern into 4 Dwords, this makes it
    ** easier to handle the LEFT_MIDLLE and LEFT_MIDDLE_RIGHT cases.
    */
    ULONG                   aulPatternRepeat[4];

    ULONG                   ulLeftPatMask;
    ULONG                   ulLeftDestMask;
    ULONG                   ulLeftDestMaskedPattern;
    ULONG                   ulRightPatMask;
    ULONG                   ulRightDestMask;
    ULONG                   ulRightDestMaskedPattern;

    int ulFillType;

    LONG                    lMiddleBytes;
    LONG                    lMiddleDwords;
    LONG                    lMidDwords_div3;
    LONG                    lMidDwords_mod3;
    LONG                    lStartingDword;

    ULONG                   *pulPatSrc;
    ULONG                   *pulPatPtr;
    ULONG                   *pulPatMax;
    ULONG                   ulPattern;
    LONG                    lCurYTop;

    ULONG                   ulUniqueScans;
    ULONG                   ulNumScans;
    ULONG                   ulTemp;
    UCHAR                   *pucTemp = (UCHAR *)&ulTemp;

    LONG                    count;
    extern ULONG            aulMsk[];    // Defined in solid.cxx

    /*
    ** Point to list of rectangles to fill
    */
    prcl = (RECTL *)ppbf->pvObj;


    /*
    ** Offset to next scan, offset to every sixth scan
    */
    lDelta  = ppbf->lDeltaTrg;
    lDelta6 = lDelta * 6;


    /*
    ** Loop through all rectangles to fill
    */
    do {

        /*
        ** Set up AND/OR masks for partial-dword edges, for masking both the
        ** pattern dword and the destination dword (the pattern and destination
        ** masks are complementary). A solid dword is 0 for dest, -1 for
        ** pattern
        */
        ulLeftPatMask = aulMsk[prcl->left & 31];
        ulLeftDestMask = ~ulLeftPatMask;

        if ((ulRightDestMask = aulMsk[prcl->right & 31]) == 0xFFFFFFFF)
        {
            ulRightDestMask = 0x00; // force solid to -1 for pattern
        }
        ulRightPatMask = ~ulRightDestMask;

        /*
        ** Point to the first dword to fill
        */
        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                     (ppbf->lDeltaTrg * prcl->top)) + (prcl->left >> 5);

        /*
        ** Number of whole middle dwords/bytes to fill a dword at a time
        */
        lMiddleDwords = (LONG)(prcl->right >> 5) -
                       ((LONG)(prcl->left + 31 ) >> 5);


        switch ( lMiddleDwords + 1 ) {

        case 1:
            if ( (ulLeftDestMask != 0) && (ulRightDestMask != 0) ) {
                /*
                ** left and right but no middle, or possible just one partial
                ** dword.
                */
                ulFillType = LEFT_RIGHT;
                break;
            }


        /*
        ** Note fall thru in case where one off the masks is 0, meaning that we
        ** have a single partial dword which we will treat as a LEFT fill type.
        */

        case 0:
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;


        /*
        ** Won't bother with short cases yet!
        */

        default:
            if ( ulLeftDestMask == 0 ) {
                if ( ulRightDestMask == 0 ) {
                    ulFillType = MIDDLE;
                }
                else {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else {
                if ( ulRightDestMask == 0 ) {
                    ulFillType = LEFT_MIDDLE;
                }
                else {
                    /* most likely case ?? */
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
        }


        /*
        ** Pre-calculate some inner loop constants
        **
        ** Set up the shifts to produce the rotation effect to align the
        ** pattern as specified (the results of the two shifts are ORed
        ** together to emulate the rotate, because C can't do rotations
        ** directly)
        */
        lCurYTop = prcl->top;

        /*
        ** Look for the case when (lCurYTop - ppbf->yPat) is less than zero.
        ** (Note: ppbf->yPat can only be in the range 0-5).  If we don't do
        ** this we could end up with a negative value being added to the
        ** pattern pointer.  What we really want here is a modulus operator
        ** (C only has a remainder operator), we cannot use the & operator
        ** to fake modulus because 6 is not a power of two.
        ** When (lCurYTop - ppbf->yPat) == 0 the pattern is already correctly
        ** aligned in the Y axis.
        */
        if ( count = lCurYTop - ppbf->yPat ) {

            count %= 6;
            count += 6;
            count %= 6;
            pulPatPtr = (ULONG *)ppbf->pvPat + (2 * count);

        } else {

            pulPatPtr = (ULONG *)ppbf->pvPat;
        }

        pulPatMax = (ULONG *)ppbf->pvPat + 12;

        lMidDwords_div3 = lMiddleDwords / 3;
        lMidDwords_mod3 = lMiddleDwords % 3;
        lMiddleBytes    = lMiddleDwords << 2;
        lStartingDword  = (prcl->left >> 5) % 3;

        ucPatRotateRight = (UCHAR)ppbf->xPat;
        ucPatRotateLeft  = 6 - ucPatRotateRight;


        ulUniqueScans = 6;
        if ( (prcl->bottom - prcl->top) < 6 ) {
            ulUniqueScans = prcl->bottom - prcl->top;
        }


        while ( ulUniqueScans-- ) {

            /*
            ** Point to the scan to fill then advance to the next scan for
            ** next time thru the loop.
            */
            pulTrgStart = pulTrg = pulTrgBase;
            pulTrgBase = (ULONG *)((PBYTE)pulTrgBase + lDelta);


            /*
            ** Set up the number of scans to fill with this pattern scan, given
            ** that we'll do every 6th scan.
            */
            ulNumScans = (prcl->bottom - lCurYTop + 5) / 6;
            lCurYTop++;


            /*
            ** Load the first 8 bits of the pattern in to *pucTemp and at the
            ** same time right justify the 6 bit pattern.
            */
            *pucTemp = *(UCHAR *)pulPatPtr >> 2;


            /*
            ** Horizontaly align the 6 bit pattern.
            */
            if ( ucPatRotateRight ) {
                ulPattern = (ULONG)((*pucTemp >> ucPatRotateRight) |
                                    (*pucTemp << ucPatRotateLeft)) & 0x3F;
            }
            else {
                ulPattern = (ULONG)*pucTemp;
            }


            pulPatSrc = aulPatternRepeat;

            /*
            ** Basically, we shift the pattern to correctly fill the 32 bit
            ** DWORD.  We then rearrange the bytes within the DWORD to account
            ** for little endianess.  I special case the LEFT fill type as it
            ** only requires 1 DWORDs worth of pattern it seems a little over
            ** the top to replicate 96 bits of pattern, this saving in
            ** execution time is at the expense of slightly larger code size.
            */
            if ( ulFillType == LEFT ) {

                /*
                ** Select the correct left edge from the 3 pattern DWORDs.
                */
                if( lStartingDword == 0 ) {

                    *pulPatSrc = ((ulPattern << 26) | (ulPattern << 20) |
                                  (ulPattern << 14) | (ulPattern <<  8) |
                                  (ulPattern <<  2) | (ulPattern >>  4));
                }
                else if( lStartingDword == 1 ) {

                    *pulPatSrc = ((ulPattern << 28) | (ulPattern << 22) |
                                  (ulPattern << 16) | (ulPattern << 10) |
                                  (ulPattern <<  4) | (ulPattern >>  2));
                }
                else {          // lStartingDword must be 2

                    *pulPatSrc = ((ulPattern << 30) | (ulPattern << 24) |
                                  (ulPattern << 18) | (ulPattern << 12) |
                                  (ulPattern <<  6) | (ulPattern      ));
                }

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc   = *((ULONG *)pucTemp);


                /*
                ** Draw all the Y scans for this pattern
                */
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                do {
                    *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;
                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                } while ( --ulNumScans  );

            }

            /*
            ** Otherwise, we replicate the 6 bit pattern into a 96 bit pattern.
            ** We use the same pattern generating principle as that described
            ** above.
            */
            else {

                /*
                ** Pattern bits 0 - 31
                */
                *pulPatSrc   = ((ulPattern << 26) | (ulPattern << 20) |
                                (ulPattern << 14) | (ulPattern <<  8) |
                                (ulPattern <<  2) | (ulPattern >>  4));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG *)pucTemp);



                /*
                ** Pattern bits 32 - 63
                */
                *pulPatSrc   = ((ulPattern << 28) | (ulPattern << 22) |
                                (ulPattern << 16) | (ulPattern << 10) |
                                (ulPattern <<  4) | (ulPattern >>  2));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG *)pucTemp);



                /*
                ** Pattern bits 64 - 95
                */
                *pulPatSrc   = ((ulPattern << 30) | (ulPattern << 24) |
                                (ulPattern << 18) | (ulPattern << 12) |
                                (ulPattern <<  6) | (ulPattern      ));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG  *)pucTemp);


                /*
                ** Select the correct left edge from the 3 pattern DWORDs.
                ** A case of 0 means that we already have the correct edge
                ** of the pattern aligned.
                */
                if ( lStartingDword == 1 ) {

                    ulTemp                  = *aulPatternRepeat;
                    *aulPatternRepeat       = *(aulPatternRepeat + 1);
                    *(aulPatternRepeat + 1) = *(aulPatternRepeat + 2);
                    *(aulPatternRepeat + 2) = ulTemp;

                }
                else if ( lStartingDword == 2 ) {

                    ulTemp                  = *(aulPatternRepeat + 2);
                    *(aulPatternRepeat + 2) = *(aulPatternRepeat + 1);
                    *(aulPatternRepeat + 1) = *aulPatternRepeat;
                    *aulPatternRepeat       = ulTemp;

                }


                /*
                ** Finally the 4th DWORD is just a copy of the first.
                */
                *pulPatSrc = *aulPatternRepeat;
            }




            /*
            ** Draw all the Y scans for this pattern
            */
            switch ( ulFillType ) {

            /*
            ** We include this case to force the i386 compiler to use a
            ** jump table.
            */
            case LEFT:
                ulTemp = 0;
                break;


            case LEFT_RIGHT:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                ulRightDestMaskedPattern = *(aulPatternRepeat + 1) &
                                                ulRightPatMask;

                do {
                    *pulTrg = (*pulTrg & ulLeftDestMask) |
                                ulLeftDestMaskedPattern;
                    *(pulTrg + 1) = (*(pulTrg + 1) & ulRightDestMask) |
                                    ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);

                } while ( --ulNumScans  );
                break;


            case LEFT_MIDDLE_RIGHT:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                ulRightDestMaskedPattern =
                    *(aulPatternRepeat + 1 + lMidDwords_mod3) & ulRightPatMask;

                /*
                ** Do the first LEFT edge
                */
                *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;

                /*
                ** Now do first CENTER stripe
                **
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1,
                                   (UINT)(lMidDwords_mod3 << 2) );
                    pulTrg += lMidDwords_mod3;
                }


                /*
                ** Now do the first RIGHT edge
                */

                *(pulTrg + 1) = (*(pulTrg + 1) & ulRightDestMask) |
                                ulRightDestMaskedPattern;


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;

                    RtlCopyMemory( pulTrg + 1, pulTrgStart + 1,
                                   (UINT)lMiddleBytes );

                    *(pulTrg + 1 + lMiddleDwords) =
                        (*(pulTrg + 1 + lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }

                break;


            case LEFT_MIDDLE:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;

                /*
                ** Do the first LEFT edge
                */
                *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;


                /*
                ** Now do first CENTER stripe
                **
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1,
                                   (UINT)(lMidDwords_mod3 << 2) );
                }


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    *pulTrg = (*pulTrg & ulLeftDestMask) |
                                ulLeftDestMaskedPattern;
                    RtlCopyMemory( pulTrg + 1, pulTrgStart + 1,
                                   (UINT)lMiddleBytes );

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }
                break;


            case MIDDLE:
                /*
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg, aulPatternRepeat,
                                   (UINT)(lMidDwords_mod3 << 2) );
                }


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    RtlCopyMemory( pulTrg, pulTrgStart, (UINT)lMiddleBytes );
                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }
                break;


            case MIDDLE_RIGHT:
                ulRightDestMaskedPattern =
                    *(aulPatternRepeat + lMidDwords_mod3) & ulRightPatMask;


                /*
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat,
                                   (UINT)(lMidDwords_mod3 << 2) );
                    pulTrg += lMidDwords_mod3;
                }


                /*
                ** Now do the first RIGHT edge
                */
                *pulTrg = (*pulTrg & ulRightDestMask) |
                            ulRightDestMaskedPattern;


                /*
                ** Now copy the previously drawn scan line into all
                ** common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    RtlCopyMemory( pulTrg, pulTrgStart, (UINT)lMiddleBytes );

                    *(pulTrg + lMiddleDwords) =
                        (*(pulTrg + lMiddleDwords) & ulRightDestMask) |
                            ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);

                }
                break;
            }

            /*
            ** Advance the pattern pointer for the next pattern scan
            */
            pulPatPtr += 2;
            if ( pulPatPtr == pulPatMax ) {
                pulPatPtr = (ULONG *)ppbf->pvPat;
            }
        }


        /*
        ** Point to the next rectangle to fill, if there is one
        */
        prcl++;

    }
    while (--crcl);

}



/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPatCpyRect8_8x8
*
* Routine Description:
*
*   Tiles an 8x8 pattern to 8 bpp bitmaps, for SRCCOPY rasterop only.
*   Fills however many rectangles are specified by crcl
*   Assumes pattern bytes are contiguous.
*   Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
*   Assumes there is at least one rectangle to fill.
*
* NOTE: We will sometimes be passed empty rectangles!
*
* Arguments
*
*   ppbf    -   pointer to PATBLTFRAME pattern information
*   crcl    -   Rectangle count
*
* Returns
*
*   VOID, this functions may not fail
*
* History:
*  18-Oct-1993 -by- Mark Enstrom [marke]  - simplified for 8bpp
*  17-Nov-1992 -by- Reza Baghai [rezab]
* Adapted from vPatCpyRect4_8x8.
*
\**************************************************************************/
VOID vPatCpyRect8_8x8(PATBLTFRAME *ppbf, INT crcl)
{
    PULONG  pulTrg;
    PULONG  pulTrgTmp;
    LONG    lDeltaTrg8;
    ULONG   PatRotate;
    ULONG   PatRotateRight;
    ULONG   PatRotateLeft;
    PRECTL  prcl;
    LONG    lDeltaPat;
    ULONG   cyPatternTop;
    ULONG   cyVenetianTop;
    ULONG   cyVenetian;
    ULONG   ulPatternEven;
    ULONG   ulPatternOdd;
    ULONG   ulffPattern[2];
    ULONG   ulTmp;
    ULONG  *pulPat;
    ULONG  *pulPatMax;
    ULONG  *pulPatBase;
    ULONG   PatOffsetY;
    FETCHFRAME  ff;

    #if DBG_PAT_CPY

        if (DbgPatCpy >= 1) {
            DbgPrint("vPatCpyRect8_8x8   @ppbf = 0x%p   crcl = %li\n",ppbf,crcl);
            DbgPrint("pvTrg = 0x%p, pvPat = 0x%p\n",ppbf->pvTrg,ppbf->pvPat);
            DbgPrint("xPat = %li, yPat = %li\n",ppbf->xPat,ppbf->yPat);
        }

    #endif

    //
    // Point to list of rectangles to fill
    //

    prcl = (RECTL *) ppbf->pvObj;

    //
    // set up pattern access vars and rotation
    //

    pulPatBase = (ULONG *)ppbf->pvPat;

    PatRotate      = (ppbf->xPat & 7);
    PatRotateLeft  = (ppbf->xPat & 3);
    PatRotateRight = 4 - PatRotateLeft;

    //
    // mupliply by 8 to get byte shift values
    //

    PatRotateRight <<= 3;
    PatRotateLeft  <<= 3;

    //
    // Remember where the pattern ends, for wrapping
    //

    lDeltaPat = 12;
    pulPatMax = (ULONG *)(((BYTE *)pulPatBase) + (lDeltaPat << 3));


    #if DBG_PAT_CPY
        if (DbgPatCpy >= 2) {
            DbgPrint("  Pattern Base   = 0x%p\n",pulPatBase);
            DbgPrint("  Pattern Max    = 0x%p\n",pulPatMax);
            DbgPrint("  Pattern Delta  = 0x%lx\n",lDeltaPat);
            DbgPrint("  Pattern Rotate = 0x%lx\n",PatRotate);
        }
    #endif

    //
    // Loop through all rectangles to fill
    //

    do {

        //
        // are these gaurenteed to be well ordered rectangles?
        //
        //
        // set up begin and end cases as well as middle case for
        // each rect as well as wether to start on even or odd
        //

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 1)
            {
                DbgPrint("  Fill Rect %li,%li to %li,%li\n",
                                prcl->left,
                                prcl->top,
                                prcl->right,
                                prcl->bottom
                                );
            }

        #endif

        LONG    cy = prcl->bottom - prcl->top;
        LONG    cx = prcl->right  - prcl->left;

        //
        // determine start and end cases for the entire rect
        //
        //
        // Simple start cases:          End cases:
        //
        //                          
        //          123   1            0        1
        //                          
        //                            
        //            23   2            01      2
        //                            
        //                              
        //              3   3            012    3
        //                              
        //
        // Start/end  combination
        //
        //          
        //          1       1 + 3
        //          
        //          
        //          12     1 + 4
        //          
        //            
        //            2     2 + 4
        //            
        //
        //

        LONG StartCase = prcl->left  & 0x03;
        LONG EndCase   = prcl->right & 0x03;
        LONG cxDword   = cx - EndCase - ((4-StartCase) & 0x03);

        if (cxDword < 0) {
            cxDword = 0;
        } else {
            cxDword >>= 2;
        }

        if (StartCase == 1)
        {
            if (cx == 1)
            {
                StartCase = 4;
                EndCase   = 0;
            } else if (cx == 2) {
                StartCase = 5;
                EndCase   = 0;
            }

        } else if (StartCase == 2)
        {
            if (cx == 1) {
            StartCase = 6;
            EndCase   = 0;
            }
        }

        //
        // calc the index for loading even and odd pattern DWORDS
        //

        LONG StartOffset    = (prcl->left  & 0x04) >> 2;
        LONG StartOffsetNot = (~StartOffset) & 0x01;

        //
        // calculate the DWORD address of pat scan line and
        // of the destination
        //

        PatOffsetY = (ULONG)((prcl->top - ppbf->yPat) & 0x07);

        pulPat = (PULONG)((PBYTE)pulPatBase + lDeltaPat * PatOffsetY);

        pulTrgTmp = (PULONG)(((PBYTE)ppbf->pvTrg                  +
                                     ppbf->lDeltaTrg * prcl->top  +
                                     (prcl->left & ~0x03)));

        //
        // The first 'cyPatternTop' scans of the pattern will each be tiled
        // 'cyVenetianTop' times into the destination rectangle.  Then, the
        // next '8 - cyPatternTop' scans of the pattern will each be tiled
        // 'cyVenetianTop - 1' times into the destination rectangle.
        //

        cyPatternTop  = (cy & 7);
        cyVenetianTop = (cy >> 3) + 1;

        //
        // lDeltaTrg8 is the offset for 8 Trg scan lines
        //

        lDeltaTrg8 = ppbf->lDeltaTrg << 3;


        #if DBG_PAT_CPY
            if (DbgPatCpy >= 2)
            {
                DbgPrint("  Start Case  = %li, EndCase = %li cxDword = %li\n",StartCase,EndCase,cxDword);
                DbgPrint("  StartOffset = %li\n",StartOffset);
                DbgPrint("  pulPat      = 0x%p\n",pulPat);
                DbgPrint("  Pat Y       = %li\n",PatOffsetY);
                DbgPrint("  pulTrg      = 0x%p\n",pulTrgTmp);
            }
        #endif

        //
        // for each scan line
        //

        ff.pvPat = (PVOID)&ulffPattern;
        ff.xPat  = 0;
        ff.cxPat = 8;
        ff.culWidth = 2;

        //
        // fill every eigth scan line at the same time.
        //

        if (cy > 8) {
            cy = 8;
        }

        while (cy--) {

            PULONG  pulScanTrg;
            ULONG   ulTmpPatEven;
            ULONG   ulTmpPatOdd;

            //
            // load up even and odd pat, rotate into dst alignment
            //

            if (ppbf->xPat == 0) {

                //
                // pattern is aligned
                //

                ulPatternEven = *(pulPat + StartOffset);
                ulPatternOdd  = *(pulPat + StartOffsetNot);

            } else {


                //
                // pattern must be rotated
                //

                ulTmpPatEven = *(pulPat);
                ulTmpPatOdd  = *(pulPat + 1);

                #if DBG_PAT_CPY
                    if (DbgPatCpy >= 2)
                    {
                        DbgPrint("  TmpPatEven    = 0x%lx\n",ulTmpPatEven);
                        DbgPrint("  TmpPatOdd     = 0x%lx\n",ulTmpPatOdd);
                    }
                #endif

                if (PatRotate < 4) {

                    ulPatternEven   = (ulTmpPatEven << PatRotateLeft)  |
                                      (ulTmpPatOdd  >> PatRotateRight);

                    ulPatternOdd    = (ulTmpPatOdd  << PatRotateLeft) |
                                      (ulTmpPatEven >> PatRotateRight);

                } else if (PatRotate == 4) {

                    ulPatternEven   = ulTmpPatOdd;
                    ulPatternOdd    = ulTmpPatEven;

                } else {

                    ulPatternEven   = (ulTmpPatEven >> PatRotateRight) |
                                      (ulTmpPatOdd  << PatRotateLeft);

                    ulPatternOdd    = (ulTmpPatOdd  >> PatRotateRight)  |
                                      (ulTmpPatEven << PatRotateLeft);

                }

                if (StartOffset != 0) {

                    //
                    // swap even and odd
                    //

                    ulTmpPatEven    = ulPatternEven;
                    ulPatternEven   = ulPatternOdd;
                    ulPatternOdd    = ulTmpPatEven;
                }
            }

            #if DBG_PAT_CPY

                if (DbgPatCpy >= 2)
                {
                    DbgPrint("  PatEven    = 0x%lx\n",ulPatternEven);
                    DbgPrint("  PatOdd     = 0x%lx\n",ulPatternOdd);
                }

            #endif

            pulScanTrg = pulTrgTmp;

            //
            // do every eighth scan line
            //

            if (cyPatternTop-- == 0)
                cyVenetianTop--;

            cyVenetian = cyVenetianTop;
            while (cyVenetian-- != 0) {

                ULONG   cxTmp = cxDword;

                //
                // pulTrg = beginning of next scan line
                //

                //
                // assign temp patterns
                //

                ulTmpPatEven = ulPatternEven;
                ulTmpPatOdd  = ulPatternOdd;

                pulTrg = pulScanTrg;

                if (StartCase != 0)
                {
                    switch (StartCase)
                    {
                    case 1:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                        break;
                    case 2:
                        *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                        break;
                    case 3:
                        *((PBYTE)pulTrg+3)   = (BYTE)(ulTmpPatEven  >> 24);
                        break;
                    case 4:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        break;
                    case 5:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                        break;
                    case 6:
                        *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                        break;
                    }

                    pulTrg++;

                    //
                    // swap patterns
                    //

                    ulTmp = ulTmpPatEven;
                    ulTmpPatEven = ulTmpPatOdd;
                    ulTmpPatOdd  = ulTmp;
                }

                if (cxDword > 7) {

                    ulffPattern[0] = ulTmpPatEven;
                    ulffPattern[1] = ulTmpPatOdd;
                    ff.culFill = cxDword;
                    ff.pvTrg = (PVOID)pulTrg;
                    vFetchAndCopy(&ff);
                    pulTrg += cxDword;

                } else {

                    //
                    // dword pairs
                    //

                    while (cxTmp >= 2) {

                        *pulTrg     = ulTmpPatEven;
                        *(pulTrg+1) = ulTmpPatOdd;

                        pulTrg  += 2;
                        cxTmp -= 2;
                    }

                    //
                    // possible last dword
                    //

                    if (cxTmp) {
                        *pulTrg = ulTmpPatEven;
                        pulTrg++;
                    }

                }

                //
                // end case if needed
                //

                if (EndCase != 0) {

                    //
                    // if cxDword is odd then the patterns must be swapped
                    //

                    if (cxDword & 0x01) {
                        ulTmpPatEven = ulTmpPatOdd;
                    }


                    switch (EndCase) {
                    case 1:
                        *(PBYTE)pulTrg = (BYTE)ulTmpPatEven;
                        break;
                    case 2:
                        *(PUSHORT)pulTrg = (USHORT)ulTmpPatEven;
                        break;
                    case 3:
                        *(PUSHORT)pulTrg   = (USHORT)ulTmpPatEven;
                        *((PBYTE)pulTrg+2) = (BYTE)(ulTmpPatEven >> 16);
                        break;
                    }
                }

                pulScanTrg = (PULONG)((PBYTE)pulScanTrg + lDeltaTrg8);
            }

            //
            // inc dst and pat pointers
            //

            pulPat    = (PULONG)((PBYTE)pulPat + lDeltaPat);

            if (pulPat >= pulPatMax) {
                pulPat = pulPatBase;
            }

            pulTrgTmp = (PULONG)((PBYTE)pulTrgTmp + ppbf->lDeltaTrg);

        }

        prcl++;

    } while (--crcl);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPatCpyRow8_8x8
*
* Routine Description:
*
*   Tiles an 8x8 pattern to 8 bpp bitmaps, for SRCCOPY rasterop only.
*   Fills however many rectangles are specified by crcl
*   Assumes pattern bytes are contiguous.
*   Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
*   Assumes there is at least one rectangle to fill.
*
* Arguments
*
*   ppbf    -   pointer to PATBLTFRAME pattern information
*   yStart  -   starting row, all following rows are consecutive
*   crow    -   number of rows
*
* Returns
*
*   VOID, this functions may not fail
*
* History:
*  08-Dec-1993 -by- Mark Enstrom [marke]
*
\**************************************************************************/
VOID vPatCpyRow8_8x8(PATBLTFRAME *ppbf, LONG yStart, INT crow)
{
    PULONG  pulTrg;
    PULONG  pulTrgTmp;
    PUCHAR  pjTrgScan;
    LONG    lDeltaTrg8;
    ULONG   PatRotate;
    ULONG   PatRotateRight;
    ULONG   PatRotateLeft;
    PROW    prow;
    LONG    lDeltaPat;
    ULONG   ulPatternEven;
    ULONG   ulPatternOdd;
    ULONG   ulffPattern[2];
    ULONG   ulTmp;
    ULONG  *pulPat;
    ULONG  *pulPatMax;
    ULONG  *pulPatBase;
    ULONG   PatOffsetY;
    FETCHFRAME  ff;

    #if DBG_PAT_CPY

        if (DbgPatCpy >= 1) {
            DbgPrint("vPatCpyRect8_8x8   @ppbf = 0x%p   crow = %li\n",ppbf,crow);
            DbgPrint("pvTrg = 0x%p, pvPat = 0x%p\n",ppbf->pvTrg,ppbf->pvPat);
            DbgPrint("xPat = %li, yPat = %li\n",ppbf->xPat,ppbf->yPat);
        }

    #endif

    //
    // Point to list of rows to fill
    //

    prow = (PROW) ppbf->pvObj;

    //
    // start row dst address
    //

    pjTrgScan = (PUCHAR)ppbf->pvTrg + ppbf->lDeltaTrg * yStart;

    //
    // start pattern offset
    //

    PatOffsetY = (ULONG)((yStart - ppbf->yPat) & 0x07);

    //
    // set up pattern access vars and rotation
    //

    pulPatBase = (ULONG *)ppbf->pvPat;

    PatRotate      = (ppbf->xPat & 7);
    PatRotateLeft  = (ppbf->xPat & 3);
    PatRotateRight = 4 - PatRotateLeft;

    //
    // mupliply by 8 to get byte shift values
    //

    PatRotateRight <<= 3;
    PatRotateLeft  <<= 3;

    //
    // lDelta for 8bpp 8x8 patterns is hard coded to 12
    //

    lDeltaPat = 12;

    //
    // Remember where the pattern starts and where the pattern ends for wrapping
    //

    pulPat     = (PULONG)((PBYTE)pulPatBase + lDeltaPat * PatOffsetY);
    pulPatMax  = (PULONG)(((PBYTE)pulPatBase) + (lDeltaPat << 3));

    #if DBG_PAT_CPY
        if (DbgPatCpy >= 2) {
            DbgPrint("  Pattern Base   = 0x%p\n",pulPatBase);
            DbgPrint("  Pattern Max    = 0x%p\n",pulPatMax);
            DbgPrint("  Pattern Delta  = 0x%lx\n",lDeltaPat);
            DbgPrint("  Pattern Rotate = 0x%lx\n",PatRotate);
        }
    #endif

    //
    // Loop through all rows to fill
    //

    do {

        //
        // set up begin and end cases as well as middle case for
        // each row as well as wether to start on even or odd
        //

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 1)
            {
                DbgPrint("  Fill Row %li to %li\n",
                                prow->left,
                                prow->right
                                );
            }

        #endif

        LONG    cx = prow->right  - prow->left;

        //
        // determine start and end cases for the row
        //
        //
        // Simple start cases:          End cases:
        //
        //                          
        //          123   1            0        1
        //                          
        //                            
        //            23   2            01      2
        //                            
        //                              
        //              3   3            012    3
        //                              
        //
        // Start/end  combination
        //
        //          
        //          1       1 + 3
        //          
        //          
        //          12     1 + 4
        //          
        //            
        //            2     2 + 4
        //            
        //
        //

        LONG StartCase = prow->left  & 0x03;
        LONG EndCase   = prow->right & 0x03;
        LONG cxDword   = cx - EndCase - ((4-StartCase) & 0x03);

        if (cxDword < 0) {
            cxDword = 0;
        } else {
            cxDword >>= 2;
        }

        if (StartCase == 1)
        {
            if (cx == 1)
            {
                StartCase = 4;
                EndCase   = 0;
            } else if (cx == 2) {
                StartCase = 5;
                EndCase   = 0;
            }

        } else if (StartCase == 2)
        {
            if (cx == 1) {
            StartCase = 6;
            EndCase   = 0;
            }
        }

        //
        // calc the index for loading even and odd pattern DWORDS
        //

        LONG StartOffset    = (prow->left  & 0x04) >> 2;
        LONG StartOffsetNot = (~StartOffset) & 0x01;

        //
        // calculate the DWORD address of pat scan line and
        // of the destination
        //

        pulTrgTmp = (PULONG)(pjTrgScan + (prow->left & ~0x03));

        //
        // lDeltaTrg8 is the offset for 8 Trg scan lines
        //

        lDeltaTrg8 = ppbf->lDeltaTrg << 3;


        #if DBG_PAT_CPY
            if (DbgPatCpy >= 2)
            {
                DbgPrint("  Start Case  = %li, EndCase = %li cxDword = %li\n",StartCase,EndCase,cxDword);
                DbgPrint("  StartOffset = %li\n",StartOffset);
                DbgPrint("  pulPat      = 0x%p\n",pulPat);
                DbgPrint("  Pat Y       = %li\n",PatOffsetY);
                DbgPrint("  pulTrg      = 0x%p\n",pulTrgTmp);
            }
        #endif

        //
        // for each scan line
        //

        ff.pvPat = (PVOID)&ulffPattern;
        ff.xPat  = 0;
        ff.cxPat = 8;
        ff.culWidth = 2;

        PULONG  pulScanTrg;
        ULONG   ulTmpPatEven;
        ULONG   ulTmpPatOdd;

        //
        // load up even and odd pat, rotate into dst alignment
        //

        if (ppbf->xPat == 0) {

            //
            // pattern is aligned
            //

            ulPatternEven = *(pulPat + StartOffset);
            ulPatternOdd  = *(pulPat + StartOffsetNot);

        } else {


            //
            // pattern must be rotated
            //

            ulTmpPatEven = *(pulPat);
            ulTmpPatOdd  = *(pulPat + 1);

            #if DBG_PAT_CPY
                if (DbgPatCpy >= 2)
                {
                    DbgPrint("  TmpPatEven    = 0x%lx\n",ulTmpPatEven);
                    DbgPrint("  TmpPatOdd     = 0x%lx\n",ulTmpPatOdd);
                }
            #endif

            if (PatRotate < 4) {

                ulPatternEven   = (ulTmpPatEven << PatRotateLeft)  |
                                  (ulTmpPatOdd  >> PatRotateRight);

                ulPatternOdd    = (ulTmpPatOdd  << PatRotateLeft) |
                                  (ulTmpPatEven >> PatRotateRight);

            } else if (PatRotate == 4) {

                ulPatternEven   = ulTmpPatOdd;
                ulPatternOdd    = ulTmpPatEven;

            } else {

                ulPatternEven   = (ulTmpPatEven >> PatRotateRight) |
                                  (ulTmpPatOdd  << PatRotateLeft);

                ulPatternOdd    = (ulTmpPatOdd  >> PatRotateRight)  |
                                  (ulTmpPatEven << PatRotateLeft);

            }

            if (StartOffset != 0) {

                //
                // swap even and odd
                //

                ulTmpPatEven    = ulPatternEven;
                ulPatternEven   = ulPatternOdd;
                ulPatternOdd    = ulTmpPatEven;
            }
        }

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 2)
            {
                DbgPrint("  PatEven    = 0x%lx\n",ulPatternEven);
                DbgPrint("  PatOdd     = 0x%lx\n",ulPatternOdd);
            }

        #endif

        pulScanTrg = pulTrgTmp;

        ULONG   cxTmp = cxDword;

        //
        // pulTrg = beginning of next scan line
        //

        //
        // assign temp patterns
        //

        ulTmpPatEven = ulPatternEven;
        ulTmpPatOdd  = ulPatternOdd;

        pulTrg = pulScanTrg;

        if (StartCase != 0)
        {
            switch (StartCase)
            {
            case 1:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                break;
            case 2:
                *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                break;
            case 3:
                *((PBYTE)pulTrg+3)   = (BYTE)(ulTmpPatEven  >> 24);
                break;
            case 4:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                break;
            case 5:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                break;
            case 6:
                *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                break;
            }

            pulTrg++;

            //
            // swap patterns
            //

            ulTmp = ulTmpPatEven;
            ulTmpPatEven = ulTmpPatOdd;
            ulTmpPatOdd  = ulTmp;
        }

        if (cxDword > 7) {

            ulffPattern[0] = ulTmpPatEven;
            ulffPattern[1] = ulTmpPatOdd;
            ff.culFill = cxDword;
            ff.pvTrg = (PVOID)pulTrg;
            vFetchAndCopy(&ff);
            pulTrg += cxDword;

        } else {

            //
            // dword pairs
            //

            while (cxTmp >= 2) {

                *pulTrg     = ulTmpPatEven;
                *(pulTrg+1) = ulTmpPatOdd;

                pulTrg  += 2;
                cxTmp -= 2;
            }

            //
            // possible last dword
            //

            if (cxTmp) {
                *pulTrg = ulTmpPatEven;
                pulTrg++;
            }

        }

        //
        // end case if needed
        //

        if (EndCase != 0) {

            //
            // if cxDword is odd then the patterns must be swapped
            //

            if (cxDword & 0x01) {
                ulTmpPatEven = ulTmpPatOdd;
            }


            switch (EndCase) {
            case 1:
                *(PBYTE)pulTrg = (BYTE)ulTmpPatEven;
                break;
            case 2:
                *(PUSHORT)pulTrg = (USHORT)ulTmpPatEven;
                break;
            case 3:
                *(PUSHORT)pulTrg   = (USHORT)ulTmpPatEven;
                *((PBYTE)pulTrg+2) = (BYTE)(ulTmpPatEven >> 16);
                break;
            }
        }

        //
        // inc dst and pat pointers
        //

        pulPat    = (PULONG)((PBYTE)pulPat + lDeltaPat);

        if (pulPat >= pulPatMax) {
            pulPat = pulPatBase;
        }

        pjTrgScan = pjTrgScan + ppbf->lDeltaTrg;

        prow++;

    } while (--crow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pfeobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pfeobj.cxx
*
* Non-inline methods for physical font entry objects.
*
* Created: 30-Oct-1990 09:32:48
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/
// #pragma warning (disable: 4509)


#include "precomp.hxx"
#include "flhack.hxx"

BOOL  bExtendGlyphSet(FD_GLYPHSET **ppfdgIn, FD_GLYPHSET **ppfdgOut);

INT
__cdecl CompareRoutine(WCHAR *pwc1, WCHAR *pwc2)
{

    return(*pwc1-*pwc2);

}

/******************************Public*Routine******************************\
*
* ULONG cComputeGISET
*
* similar to cComputeGlyphSet in mapfile.c, computes the number of
*(_wcsicmp(pwszFaceName, pFaceName) == 0)* distinct glyph handles in a font and the number of runs, ie. number of
* contiguous ranges of glyph handles
*
*
* History:
*  03-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


ULONG cComputeGISET (
    USHORT * pgi,
    ULONG    cgi,
    GISET  * pgiset,
    ULONG    cGiRuns
    )
{
    ULONG    iRun, iFirst, iFirstNext;
    ULONG    cgiTotal = 0, cgiRun;

// now compute cRuns if pgiset == 0 and fill the glyphset if pgiset != 0

    for (iFirst = 0, iRun = 0; iFirst < cgi; iRun++, iFirst = iFirstNext)
    {
    // find iFirst corresponding to the next range.

        for (iFirstNext = iFirst + 1; iFirstNext < cgi; iFirstNext++)
        {
            if ((pgi[iFirstNext] - pgi[iFirstNext - 1]) > 1)
                break;
        }

    // note that this line here covers the case when there are repetitions
    // in the pgi array.

        cgiRun    = pgi[iFirstNext-1] - pgi[iFirst] + 1;
        cgiTotal += cgiRun;

        if (pgiset != NULL)
        {
            pgiset->agirun[iRun].giLow  = pgi[iFirst];
            pgiset->agirun[iRun].cgi = (USHORT) cgiRun;
        }
    }

// store results if need be

    if (pgiset != NULL)
    {
        ASSERTGDI(iRun == cGiRuns, "gdisrv! iRun != cRun\n");

        pgiset->cGiRuns  = cGiRuns;

    // init the sum before entering the loop

        pgiset->cgiTotal = cgiTotal;
    }

    return iRun;
}

/******************************Public*Routine******************************\
*
* bComputeGISET, similar to ComputeGlyphSet, only for gi's
*
* History:
*  03-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#include "stdlib.h"


VOID vSortPlacebo
(
USHORT        *pwc,
ULONG          cChar
)
{
    ULONG i;

    for (i = 1; i < cChar; i++)
    {
    // upon every entry to this loop the array 0,1,..., (i-1) will be sorted

        INT j;
        WCHAR wcTmp = pwc[i];

        for (j = i - 1; (j >= 0) && (pwc[j] > wcTmp); j--)
        {
            pwc[j+1] = pwc[j];
        }
        pwc[j+1] = wcTmp;
    }
}




BOOL bComputeGISET(IFIMETRICS * pifi, PFE * ppfe, GISET **ppgiset)
{
    BOOL bRet = TRUE;
    *ppgiset = NULL;
    GISET *pgiset;

    PFEOBJ          pfeObj(ppfe);
    PFFOBJ          pffo(pfeObj.pPFF());
    PFD_GLYPHSET    pfdg = NULL;
    BOOL bTT = (BOOL)(pffo.hdev() == (HDEV) gppdevTrueType);

    if (!bTT)
    {
        if (!(pfdg = pfeObj.pfdg()))
        {
            return FALSE;
        }
    }

    if (bTT || (pfdg->flAccel & (GS_16BIT_HANDLES | GS_8BIT_HANDLES)))
    {
    // first check if this is an accelerated case where handles are the same
    // as glyph indicies

        ULONG cig = 0;
        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, cig))
        {
            cig = ((IFIEXTRA *)(pifi + 1))->cig;
        }

        if (bTT && (cig == 0)) // most likely a corrupt font
        {
            return FALSE;
        }

        if (cig)
        {
        // one run only from zero to (cig-1);

            if (pgiset = (GISET*)PALLOCMEM(offsetof(GISET,agirun) + 1 * sizeof(GIRUN),'slgG'))
            {
            // now fill in the array of runs

                pgiset->cgiTotal = cig;
                pgiset->cGiRuns = 1;
                pgiset->agirun[0].giLow = 0;
                pgiset->agirun[0].cgi = (USHORT)cig;

            // we are done now

                *ppgiset = pgiset;
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
        // one of the goofy fonts, we will do as before

            USHORT *pgi, *pgiBegin;

        // aloc tmp buffer to contain glyph handles of all glyphs in the font

            if (pgiBegin = (USHORT*)PALLOCMEM(pfdg->cGlyphsSupported * sizeof(USHORT),'slgG'))
            {
                pgi = pgiBegin;
                for (ULONG iRun = 0; iRun < pfdg->cRuns; iRun++)
                {
                    HGLYPH *phg, *phgEnd;
                    phg = pfdg->awcrun[iRun].phg;

                    if (phg) // non unicode handles
                    {
                        phgEnd = phg + pfdg->awcrun[iRun].cGlyphs;
                        for ( ; phg < phgEnd; pgi++, phg++)
                            *pgi = (USHORT)(*phg);
                    }
                    else // unicode handles
                    {
                        USHORT wcLo = pfdg->awcrun[iRun].wcLow;
                        USHORT wcHi = wcLo + pfdg->awcrun[iRun].cGlyphs - 1;
                        for ( ; wcLo <= wcHi; wcLo++, phg++)
                            *pgi = wcLo;
                    }
                }

            // now sort the array of glyph indicies. This array will be mostly
            // sorted so that our algorithm is efficient


                qsort((void*)pgiBegin, pfdg->cGlyphsSupported, sizeof(WORD),
                  (int (__cdecl *)(const void *, const void *))CompareRoutine);


            // once the array is sorted we can easily compute the number of giRuns

                ULONG cGiRun = cComputeGISET(pgiBegin, pfdg->cGlyphsSupported, NULL, 0);

                if (pgiset = (GISET*)PALLOCMEM(offsetof(GISET,agirun) + cGiRun * sizeof(GIRUN),'slgG'))
                {
                // now fill in the array of runs

                    cComputeGISET(pgiBegin, pfdg->cGlyphsSupported, pgiset, cGiRun);
                    *ppgiset = pgiset;
                }
                else
                {
                    bRet = FALSE;
                }

                VFREEMEM(pgiBegin);
            }
            else
            {
                bRet = FALSE;
            }
        }
    }

    if (!bTT)
        pfeObj.vFreepfdg();

    return bRet;
}



//
// This is used to give ppfe->pkp something to point to if a driver
// error occurs.  That way, we won't waste time calling the driver
// again.
//

FD_KERNINGPAIR gkpNothing = { 0, 0, 0 };

static ULONG ulTimerPFE = 0;

/******************************Public*Routine******************************\
* VOID PFEOBJ::vDelete()                                                   *
*                                                                          *
* Destroy the PFE physical font entry object.                              *
*                                                                          *
* History:                                                                 *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

VOID PFEOBJ::vDelete()
{
    PDEVOBJ pdo(ppfe->pPFF->hdev);

// Save driver allocated resources in PFECLEANUP so that we can later
// call the driver to free them.

    if ((ppfe->pifi->jWinCharSet == SYMBOL_CHARSET) &&
        (ppfe->pfdg != NULL) &&
        (ppfe->pfdg->flAccel & GS_EXTENDED))
    {
        VFREEMEM(ppfe->pfdg);
    }
    else
    {
        if ((ppfe->pfdg != NULL) && PPFNVALID(pdo,Free))
        {
            pdo.Free(ppfe->pfdg, ppfe->idfdg);
        }
    }

    if (PPFNVALID(pdo,Free))
    {
        pdo.Free(ppfe->pifi, ppfe->idifi);
        if (ppfe->pkp != &gkpNothing)
        {
            pdo.Free(ppfe->pkp , ppfe->idkp );
        }
    }

    ppfe->pfdg = NULL;
    ppfe->pifi = NULL;

    ppfe->pkp = NULL;

    if (ppfe->pgiset)
    {
        VFREEMEM(ppfe->pgiset);
        ppfe->pgiset = NULL;
    }

// Free object memory and invalidate pointer.

    ppfe = PPFENULL;
}




/******************************Public*Routine******************************\
* dpNtmi()
*
* offset to NTMW_INTERNAL within ENUMFONTDATAW, needed in enumeration
*
* History:
*  19-Nov-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



ULONG PFEOBJ::dpNtmi()
{
    ULONG dpRet = DP_NTMI0;

    if (ppfe->pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (ppfe->pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(ppfe->pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)ppfe->pifi + dpDesVec);
            dpRet += (pdvSrc->dvNumAxes * sizeof(LONG));
        }
        else
        {
            DbgPrint("Test it %d %d \n", ppfe->pifi->cjIfiExtra, offsetof(IFIEXTRA, dpDesignVector));
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
        }

    }

    return dpRet;
}


/******************************Public*Routine******************************\
*
* IsAnyCharsetDbcs
*
* Does this font support any DBCS charset?
*
* History:
*  22-Jun-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" BOOL IsAnyCharsetDbcs(IFIMETRICS *pifi)
{
    BOOL bRet = FALSE;

    if (IS_ANY_DBCS_CHARSET(pifi->jWinCharSet))
        return TRUE;

    if (pifi->dpCharSets)
    {
        BYTE *aCharSets = (BYTE *)pifi + pifi->dpCharSets;

        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_ANY_DBCS_CHARSET(*aCharSets))
            {
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

/******************************Public*Routine******************************\
* PFEOBG::pfdg()
*
* If pfdg is NULL then we need to get it from font driver
* If pfdg is valid then we only need to return it.
*
* Return
*   FD_GLYPHSET *
*
* History
*  08-March-1999 -by- Yung-Jen Tony Tsai [yungt]
* Wrote it.
\**************************************************************************/
FD_GLYPHSET * PFEOBJ::pfdg()
{
    PFFOBJ  pffo(pPFF());
    PDEVOBJ pdo(pffo.hdev());
    BOOL    bFreeTmp = FALSE;
    FD_GLYPHSET *pfdgTmp = NULL;
    ULONG_PTR   idGlyphSet;
    
    GreAcquireSemaphore(ghsemGlyphSet);
    
    if (ppfe->pfdg == NULL)
    {
        ASSERTGDI(ppfe->cPfdgRef == 0, "PFEOBJ::pfdg is not matched with cRef\n");
        
        GreReleaseSemaphore(ghsemGlyphSet);
        
        BOOL    bUMPD = pdo.bUMPD();
        
        pfdgTmp = (FD_GLYPHSET *) pdo.QueryFontTree(pffo.dhpdev(),
                                                        pffo.hff(),
                                                        iFont(),
                                                        QFT_GLYPHSET,
                                                        &idGlyphSet);        
        GreAcquireSemaphore(ghsemGlyphSet);
        
        if (pfdgTmp)
        {
            if (ppfe->pfdg == NULL)
            {
                ppfe->pfdg = pfdgTmp;
                ppfe->idfdg = idGlyphSet;

                // For UMPD
                
                if (bUMPD)
                {
                    if (ppfe->pifi->jWinCharSet == SYMBOL_CHARSET)
                    {
                        FD_GLYPHSET *pfdgNew = NULL;

                        if (bExtendGlyphSet(&pfdgTmp, &pfdgNew))
                        {
                            bFreeTmp = TRUE;
                            ppfe->pfdg = pfdgNew;
                        }
                    }
                }
            }
            else
                bFreeTmp = TRUE;
        }
    }
    
    if (ppfe->pfdg)
        ppfe->cPfdgRef++;

    GreReleaseSemaphore(ghsemGlyphSet);
    
    if (bFreeTmp)
    {
        if (PPFNVALID(pdo,Free))
        {
            pdo.Free(pfdgTmp, idGlyphSet);
        }
    }
    
    return ppfe->pfdg;
}

extern "C" VOID ttfdFreeGlyphset(ULONG_PTR  iFile, ULONG iFace);


/******************************Public*Routine******************************\
* PFEOBG::vFreepfdg()
*
* If pfdg is valid then we free it.
* If pfdg is NULL then return.
*
* Return
*   VOID
*
* History
*  08-March-1999 -by- Yung-Jen Tony Tsai [yungt]
* Wrote it.
\**************************************************************************/
VOID PFEOBJ::vFreepfdg()
{
    PFFOBJ  pffo(pPFF());
    FD_GLYPHSET *pfdgTmp = NULL;
    ULONG_PTR   idGlyphSet;

    GreAcquireSemaphore(ghsemGlyphSet);
    
    ASSERTGDI(ppfe->cPfdgRef, "cRef of pfdg is wrong\n");

    ppfe->cPfdgRef--;

    if (ppfe->cPfdgRef == 0)
    {
        if (pffo.hdev() == (HDEV) gppdevTrueType)
        {
            ttfdFreeGlyphset(pffo.hff(), iFont()) ;
            ppfe->pfdg = NULL;
        }
        else
        {
            PDEVOBJ pdo(pffo.hdev());
            if (pdo.bUMPD() && PPFNVALID(pdo,Free))
            {
                if ((ppfe->pifi->jWinCharSet == SYMBOL_CHARSET) &&
                    (ppfe->pfdg != NULL) &&
                    (ppfe->pfdg->flAccel & GS_EXTENDED))
                {
                    VFREEMEM(ppfe->pfdg);
                }
                else
                {
                    pfdgTmp = ppfe->pfdg;
                    idGlyphSet = ppfe->idfdg;
                }
                ppfe->pfdg = NULL;
            }
        }
    }

    GreReleaseSemaphore(ghsemGlyphSet);

    if (pfdgTmp)
    {
        PDEVOBJ pdo(pffo.hdev());
        pdo.Free(pfdgTmp, idGlyphSet);
    }

    return;
}

/******************************Public*Routine******************************\
*
* PFEOBJ::flFontType()
*
* Computes the flags defining the type of this font.  Allowed flags are
* identical to the flType flags returned in font enumeration.
*
* Return:
*   The flags.
*
* History:
*  04-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


FLONG PFEOBJ::flFontType()
{
    FLONG flRet;
    IFIOBJ ifio(pifi());

// Compute the FontType flags, simulations are irrelevant

    flRet =
      ifio.bTrueType() ?
        TRUETYPE_FONTTYPE : (ifio.bBitmap() ? RASTER_FONTTYPE : 0);

// Add the device flag if this is also a device specific font.

    flRet |= (bDeviceFont()) ? DEVICE_FONTTYPE : 0;

// check if this is a postscript font

    if (pifi()->flInfo & FM_INFO_TECH_TYPE1)
    {
        flRet |= FO_POSTSCRIPT;

        if (pifi()->flInfo & FM_INFO_TECH_MM)
            flRet |= FO_MULTIPLEMASTER;

        if (pifi()->flInfo & FM_INFO_TECH_CFF)
            flRet |= FO_CFF;
    }

    if (ppfe->flPFE & PFE_DBCS_FONT)
    {
        flRet |= FO_DBCS_FONT;

        if (ppfe->flPFE & PFE_VERT_FACE)
            flRet |= FO_VERT_FACE;
    }

    return (flRet);
}


/******************************Public*Routine******************************\
* PFEOBJ::efstyCompute()
*
* Compute the ENUMFONTSTYLE from the IFIMETRICS.
*
* Returns:
*   The ENUMFONTSTYLE of font.  Note that EFSTYLE_SKIP and EFSTYLE_OTHER are
*   not legal return values for this function.  These values are used only
*   to mark fonts for which another font already exists that fills our
*   category for a given enumeration of a family.
*
* History:
*  04-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ENUMFONTSTYLE PFEOBJ::efstyCompute()
{
    IFIOBJ ifio(pifi());

    switch (ifio.fsSelection() & (FM_SEL_ITALIC | FM_SEL_BOLD) )
    {
        case FM_SEL_ITALIC:
            return EFSTYLE_ITALIC;

        case FM_SEL_BOLD:
            return EFSTYLE_BOLD;

        case FM_SEL_ITALIC | FM_SEL_BOLD:
            return EFSTYLE_BOLDITALIC;

        default:
            return EFSTYLE_REGULAR;
    }
}


/******************************Public*Routine******************************\
* COUNT PFEOBJ::cKernPairs                                                 *
*                                                                          *
* Retrieve the pointer to the array of kerning pairs for this font face.   *
* The kerning pair array is loaded on demand, so it may or may not already *
* be cached in the PFE.                                                    *
*                                                                          *
* Returns:                                                                 *
*   Count of kerning pairs.                                                *
*                                                                          *
* History:                                                                 *
*  Mon 22-Mar-1993 21:31:15 -by- Charles Whitmer [chuckwh]                 *
* WARNING: Never access a pkp (pointer to a kerning pair) without an       *
* exception handler!  The kerning pairs could be living in a file across   *
* the net or even on removable media.  I've added the try-except here.     *
*                                                                          *
*  29-Oct-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

COUNT PFEOBJ::cKernPairs(FD_KERNINGPAIR **ppkp)
{
//
// If the pointer cached in the PFE isn't NULL, we already have the answer.
//
    if ( (*ppkp = ppfe->pkp) != (FD_KERNINGPAIR *) NULL )
        return ppfe->ckp;

//
// Create a PFFOBJ.  Needed to create driver user object as well as
// provide info needed to call driver function.
//
    PFFOBJ pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "gdisrv!cKernPairsPFEOBJ(): invalid PPFF\n");

    PDEVOBJ pdo(pffo.hdev());

    if ( (ppfe->pkp = (FD_KERNINGPAIR*)
                          pdo.QueryFontTree(
                            pffo.dhpdev(),
                            pffo.hff(),
                            ppfe->iFont,
                            QFT_KERNPAIRS,
                            &ppfe->idkp)) == (FD_KERNINGPAIR *) NULL )
    {
    //
    // Font has no kerning pairs and didn't even bother to send back
    // an empty list. By setting pointer to a zeroed FD_KERNINGPAIR and
    // setting count to zero, we will bail out early and avoid calling
    // the driver.
    //
        ppfe->pkp = &gkpNothing;
        ppfe->ckp = 0;

        return 0;
    }

// Find the end of the kerning pair array (indicated by a zeroed out
// FD_KERNINGPAIR structure).

    FD_KERNINGPAIR *pkpEnd = ppfe->pkp;

// Be careful, the table isn't guaranteed to stay around!

    __try
    {
        while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
            pkpEnd += 1;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pkpEnd = ppfe->pkp = &gkpNothing;
    }

// Return the kerning pair pointer.

    *ppkp = ppfe->pkp;

//
// Return count (difference between the beginning and end pointers).
//

//Sundown truncation

    ASSERT4GB((LONGLONG)(pkpEnd - ppfe->pkp));

    return (ppfe->ckp = (ULONG)(pkpEnd - ppfe->pkp));
}


/******************************Public*Routine******************************\
* bValidFont
*
* Last minute sanity checks to prevent a font that may crash the system
* from getting in.  We're primarily looking for things like potential
* divide-by-zero errors, etc.
*
* History:
*  30-Apr-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bValidFont(IFIMETRICS *pifi)
{
    BOOL bRet = TRUE;

// Em height is used to compute scaling factors.  Must not be zero or
// divide-by-zero may result.

    if (pifi->fwdUnitsPerEm == 0)
    {
        WARNING("bValidFont(): fwdUnitsPerEm is zero\n");
        bRet = FALSE;
    }

// Font height is used to compute scaling factors.  Must not be zero or
// divide-by-zero may result.

    if ((pifi->fwdWinAscender + pifi->fwdWinDescender) == 0)
    {
        WARNING("bValidFont(): font height is zero\n");
        bRet = FALSE;
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFEMEMOBJ::bInit
*
* This function copies data into the PFE from the supplied buffer.  The
* calling routine should use the PFEMEMOBJ to create a PFE large enough
*
* History:
*  14-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFEMEMOBJ::bInit
(
    PPFF         pPFF,          // handle to root PFF
    ULONG        iFont,         // index of font
    FD_GLYPHSET *pfdg,          // ptr to wc-->hg map
    ULONG_PTR        idfdg,         // driver ID for wc-->hg map
    PIFIMETRICS  pifi,          // ptr to IFIMETRICS
    ULONG_PTR        idifi,         // driver ID for IFIMETRICS
    BOOL        bDeviceFont,    // mark as device font
    PUNIVERSAL_FONT_ID pufi,    // PFE_UFIMATCH flag for remote printing
    BOOL         bEUDC          // mark as EUDC font

)
{
// Check font's validity.  This is not a comprehensive check, but rather
// a last minute check for things that may make the engine crash.  Each
// font/device driver still needs to make an effort to weed out its own
// bad fonts.

    if (!bValidFont(pifi))
    {
        WARNING("PFEMEMOBJ::bInit(): rejecting REALLY bad font\n");
        return FALSE;
    }

// init non-table stuff

    ppfe->pPFF        = pPFF;
    ppfe->iFont       = iFont;
    ppfe->pfdg        = pfdg;
    ppfe->idfdg       = idfdg;
    ppfe->pifi        = pifi;
    ppfe->idifi       = idifi;
    ppfe->pkp         = (FD_KERNINGPAIR *) NULL;
    ppfe->idkp        = (ULONG_PTR) NULL;
    ppfe->ckp         = 0;
    ppfe->flPFE       = 0;
    ppfe->pid         = 0;
    ppfe->tid         = 0;
    ppfe->cPfdgRef    = 0;

    IFIOBJ ifio(ppfe->pifi);

    if (IsAnyCharsetDbcs(ppfe->pifi))
        ppfe->flPFE |= PFE_DBCS_FONT;

    if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
        ppfe->flPFE |= PFE_VERT_FACE;

// for base font attach full axes info, else, do not.

    ppfe->cjEfdwPFE = ALIGN4(dpNtmi() + CJ_NTMI0);

    if (pifi->flInfo & FM_INFO_TECH_MM) // if base mm font
    {
        PTRDIFF    dpAXIW = 0;
        AXESLISTW *paxlSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpAxesInfoW))
        {
            dpAXIW = ((IFIEXTRA *)(pifi + 1))->dpAxesInfoW;
            paxlSrc = (AXESLISTW *)((BYTE*)pifi + dpAXIW);
            ppfe->cjEfdwPFE += (paxlSrc->axlNumAxes * sizeof(AXISINFOW));
        }
        else
        {
            ASSERTGDI(dpAXIW, "AxesInfoW needed for base MM font\n");
        }
    }

    ASSERTGDI(ppfe->cjEfdwPFE >= CJ_EFDW0, "cjEfdwPFE problem\n");

    if (bDeviceFont)
    {
        ppfe->flPFE |= PFE_DEVICEFONT;
    }
    else if(pPFF->ppfv && (pPFF->ppfv[0]->pwszPath == NULL))
    {
    // CAUTION: It is enough to check one font only to determine if remote
    // or memory

        if (pPFF->flState & PFF_STATE_MEMORY_FONT)
        {
            ppfe->flPFE |= PFE_MEMORYFONT;
        }
        else
        {
            ppfe->flPFE |= PFE_REMOTEFONT;
        }
        ppfe->pid = W32GetCurrentPID();
        ppfe->tid = (PW32THREAD)PsGetCurrentThread();
    }

    // For remote printing, fonts are added to the public font table with FR_NOT_ENUM and PFE_UFIMATCH
    // flags set so that other process won't be able to enum or map the fonts.

    if (pufi)
    {
        ppfe->flPFE |= PFE_UFIMATCH;
    }

#ifdef FE_SB
    if( bEUDC )
    {
        ppfe->flPFE |= PFE_EUDC;
    }

// mark it as a SBCS system font if the facename is right

    PWSZ pwszFace = ifio.pwszFaceName();

    if(pwszFace[0] == '@')
    {
        pwszFace += 1;
    }

    if(!_wcsicmp(pwszFace,L"SYSTEM") ||
       !_wcsicmp(pwszFace,L"FIXEDSYS") ||
       !_wcsicmp(pwszFace,L"TERMINAL") ||
       ((!_wcsicmp(pwszFace,L"SMALL FONTS") &&
         ifio.lfCharSet() == SHIFTJIS_CHARSET)))
    {
        ppfe->flPFE |= PFE_SBCS_SYSTEM;
    }

// Initialize EUDC QUICKLOOKUP Table
//
// These field was used, if this font is loaded as FaceName/Default linked EUDC.
//

    ppfe->ql.puiBits = NULL;
    ppfe->ql.wcLow   = 1;
    ppfe->ql.wcHigh  = 0;

#endif

// Record and increment the time stamp.

    ppfe->ulTimeStamp = ulTimerPFE;
    InterlockedIncrement((LONG *) &ulTimerPFE);

// Precalculate stuff from the IFIMETRICS.


    ppfe->iOrientation = ifio.lfOrientation();

// Compute UFI stuff

    if( ifio.TypeOneID() )
    {
        ppfe->ufi.Index = ifio.TypeOneID();
        ppfe->ufi.CheckSum = TYPE1_FONT_TYPE;
    }
    else
    {
        ppfe->ufi.CheckSum = pPFF->ulCheckSum;
        ppfe->ufi.Index = iFont;
        if (pufi)
        {
        // need to ensure that ufi of this pfe on the server machine is
        // the same as it used to be on the client. Client side ufi
        // one of the pfe's corresponding to this font is pointed to by pufi.

            ppfe->ufi.Index += ((pufi->Index - 1) & ~1);
        }

    }

// init the GISET

    if(!bComputeGISET(pifi, ppfe, &ppfe->pgiset))
        return FALSE;

// initialize cAlt for this family name, the number of entries in font sub
// table that point to this fam name.

    ppfe->cAlt = 0;

// only tt fonts with multiple charsets can be multiply enumerated
// as being both themselves and whatever font sub table claims they are

    if (ppfe->pifi->dpCharSets)
    {
        PFONTSUB pfs = gpfsTable;
        PFONTSUB pfsEnd = gpfsTable + gcfsTable;
        WCHAR    awchCapName[LF_FACESIZE];

    // Want case insensitive search, so capitalize the name.

        cCapString(awchCapName, ifio.pwszFamilyName() , LF_FACESIZE);

    // Scan through the font substitution table for the key string.

        PWCHAR pwcA;
        PWCHAR pwcB;

        for (; pfs < pfsEnd; pfs++)
        {
        // Do the following inline for speed:
        //
        //  if (!wcsncmpi(pwchFacename, pfs->fcsFace.awch, LF_FACESIZE))
        //      return (pfs->fcsAltFace.awch);

        // only those entries in the Font Substitution which have the form
        // face1,charset1=face2,charset2
        // where both charset1 and charset2 are valid charsets
        // count for enumeration purposes.

            if (!(pfs->fcsAltFace.fjFlags | pfs->fcsFace.fjFlags))
            {
                for (pwcA=awchCapName,pwcB=pfs->fcsAltFace.awch; *pwcA==*pwcB; pwcA++,pwcB++)
                {
                    if (*pwcA == 0)
                    {
                        ppfe->aiFamilyName[ppfe->cAlt++] = (BYTE)(pfs-gpfsTable);
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}



BOOL PFEOBJ::bCheckFamilyName(const WCHAR * pwszFaceName, BOOL bIgonreVertical, BOOL *pbAliasMatch)
{
    PWSZ pFaceName;
    BOOL bRet;

    if (pbAliasMatch)
    {
        *pbAliasMatch = FALSE;
    }

    pFaceName = (PWSZ) (((BYTE*) ppfe->pifi) + ppfe->pifi->dpwszFamilyName);

    if (bIgonreVertical && (*pFaceName == L'@'))
        pFaceName++;

    bRet = (_wcsicmp(pwszFaceName, pFaceName) == 0);

    if (!bRet && (ppfe->pifi->flInfo & FM_INFO_FAMILY_EQUIV))
    {
        pFaceName += (wcslen(pFaceName) + 1);
        while(!bRet && *pFaceName)
        {
            if (bIgonreVertical && (*pFaceName == L'@'))
                pFaceName++;
            bRet = (_wcsicmp(pwszFaceName, pFaceName) == 0);
            pFaceName += (wcslen(pFaceName) + 1);
        }

    // for the font mapper only: If match is found among family name aliases,
    // increase the font mapping penalty

        if (pbAliasMatch)
        {
            *pbAliasMatch = bRet;
        }
    }
    return bRet;
}




/******************************Public*Routine******************************\
* BOOL PFEOBJ::bFilterNotEnum()
*
* Used by bFilterOut() in GreEnumOpen(). It checks whether the pfe should
* be filtered out because it is either an embedded font or it is loaded to
* the system with FR_NOT_ENUM bit set.
*
* Returns:
*   TRUE if embedded or FR_NOT_ENUM set, FALSE otherwise.
*
* History:
*
*  12-Jun-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bFilterNotEnum()
{
    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bFilterEmbPvt(): invalid PPFF\n");
    PVTDATA *pPvtData;
    BOOL  bRet = TRUE;

    if (pffo.bInPrivatePFT())
    {
        // Look for a PvtData block for the current process

        if ((pPvtData = pffo.pPvtDataMatch()) && (pPvtData->cNotEnum == 0))
        {
            bRet = FALSE;
        }
    }

    // public fonts, filter out FR_NOT_ENUM only

    else if (pffo.cLoaded())
    {
        bRet = FALSE;
    }

    return bRet;
}

/***********************Public*Routine***********************\
* BOOL PFEOBJ::bPrivate()
*
* Determine whether the pfe is in private PFT table
*
* History:
*
*  16-April-1997   -by- Xudong Wu [TessieW]
* Wrote it.
*************************************************************/
BOOL PFEOBJ::bPrivate()
{
    return (ppfe->pPFF->pPFT == gpPFTPrivate);
}


/******************************Public*Routine******************************\
* BOOL PFEOBJ::bEmbedOk()
*
* Determine if the font is added as embedded by the current process
*
* Returns:
*   TRUE   if the font is added by the current process as embedded font
*   FALSE  otherwise.
*
* History:
*
*  24-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bEmbedOk()
{
    PVTDATA *pPvtData;

    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bEmbedOk(): invalid PPFF\n");
    ASSERTGDI(pffo.bInPrivatePFT(), "win32k!PFEOBJ::bEmbedOk(): pfe not in private PFT\n");

    // embedded font added by the current process

    if ((pPvtData = pffo.pPvtDataMatch()) && (pPvtData->fl & (FRW_EMB_TID | FRW_EMB_PID)))
    {
        return TRUE;
    }

    return FALSE;
}


/******************************Public*Routine******************************\
* BOOL PFEOBJ::bEmbPvtOk()
*
* Determine whether the current process has right to mapping this font
*
* Returns:
*   TRUE    pfe in public PFT or
*           font has been loaded into Private PFT by the current process
*
*   FALSE   otherwise
*
* History:
*
*  24-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bEmbPvtOk()
{
    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bEmbPvtOk(): invalid PPFF\n");

    // can't find the current process ID in the PvtData link list

    if (pffo.bInPrivatePFT() && (pffo.pPvtDataMatch() == NULL))
    {
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* HPFEC   PFEOBJ::hpfecGet()
*
* Get the handle of PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   Hanlde of PFEC object
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

HPFEC   PFEOBJ::hpfecGet()
{
    PFFOBJ pffo(ppfe->pPFF);

    ASSERTGDI(((HPFEC)pffo.pfec()->hGet()) != HPFEC_INVALID, " PFEOBJ::hpfecGet error\n");
    return((HPFEC)pffo.pfec()->hGet());
}

/******************************Public*Routine******************************\
* BOOL PFEOBJ::bFilteredOut(EFFILTER_INFO *peffi)
*
* Determine if this PFE should be rejected from the enumeration.  Various
* filtering parameters are passed in via the EFFILTER_INFO structure.
*
* Returns:
*   TRUE if font should be rejected, FALSE otherwise.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFEOBJ::bFilteredOut(EFFILTER_INFO *peffi)
{
    IFIOBJ ifio(pifi());

// Always filter out "dead" (fonts waiting to be deleted) fonts and "ghost"
// fonts.

    if ( bDead() || ifio.bGhostFont() )
        return TRUE;

#ifdef FE_SB
// Always filter out fonts that have been loaded as EUDC fonts.

    if( bEUDC() )
        return TRUE;
#endif

// Raster font filtering.

    if (peffi->bRasterFilter && ifio.bBitmap())
        return TRUE;

// TrueType font filtering.  The flag is somewhat of a misnomer as it
// is intended to exclude TrueType, even though the flag is named
// bNonTrueTypeFilter.

    if (peffi->bNonTrueTypeFilter && ifio.bTrueType())
        return(TRUE);

// Non-TrueType font filtering.  The flag is somewhat of a misnomer as it
// is intended to exclude non-TrueType, even though the flag is named
// bTrueTypeFilter.

    if (peffi->bTrueTypeFilter && !ifio.bTrueType())
        return TRUE;

// Aspect ratio filtering.  If an engine bitmap font, we will filter out
// unsuitable resolutions.

    if ( peffi->bAspectFilter
         && (!bDeviceFont())
         && ifio.bBitmap()
         && ( (peffi->ptlDeviceAspect.x != ifio.pptlAspect()->x)
               || (peffi->ptlDeviceAspect.y != ifio.pptlAspect()->y) ) )
        return TRUE;

// GACF_TTIGNORERASTERDUPE compatibility flag filtering.
// If any raster fonts exist in the same list as a TrueType font, then
// they should be excluded.

    if ( peffi->bTrueTypeDupeFilter
         && peffi->cTrueType
         && ifio.bBitmap())
        return TRUE;

// Filter out embedded fonts or the fonts with FR_NOT_ENUM bit set.

    if (bFilterNotEnum())
        return TRUE;

// In the case of a Generic text driver we must filter out all engine fonts

    if( ( peffi->bEngineFilter ) && !bDeviceFont() )
    {
        return(TRUE);
    }

// if this is a remote/memory font we don't want to enumerate it

    if( ppfe->flPFE & (PFE_REMOTEFONT | PFE_MEMORYFONT) )
    {
        return(TRUE);
    }

// finally check out if the font should be eliminated from the
// enumeration because it does not contain the charset requested:

    if (peffi->lfCharSetFilter != DEFAULT_CHARSET)
    {
    // the specific charset has been requested, let us see if the font
    // in question supports it:

        BYTE jCharSet = jMapCharset((BYTE)peffi->lfCharSetFilter, *this);

        if (jCharSet != (BYTE)peffi->lfCharSetFilter)
            return TRUE; // does not support it, filter this font out.
    }

// Passed all tests.

    return FALSE;
}


 #if DBG

/******************************Public*Routine******************************\
* VOID PFEOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFEOBJ::vPrint()
{
    IFIOBJ ifio(pifi());

    DbgPrint("\nContents of PFE, PPFE = 0x%p\n", ppfeGet());
    DbgPrint("pPFF   = 0x%p\n", ppfe->pPFF);
    DbgPrint("iFont  = 0x%lx\n", ppfe->iFont);

    DbgPrint("lfHeight          = 0x%x\n",  ifio.lfHeight());
    DbgPrint(
        "Family Name       = %ws\n",
        ifio.pwszFamilyName()
        );
    DbgPrint(
        "Face Name         = %ws\n",
        ifio.pwszFaceName()
        );
    DbgPrint(
        "Unique Name       = %s\n\n",
        ifio.pwszUniqueName()
        );
}


/******************************Public*Routine******************************\
* VOID PFEOBJ::vDumpIFI ()
*
* Debugging code.  Prints PFE header and IFI metrics.
*
\**************************************************************************/

VOID PFEOBJ::vPrintAll()
{
    DbgPrint("\nContents of PFE, PPFE = 0x%p\n", ppfeGet());
    DbgPrint("pPFF   = 0x%p\n", ppfe->pPFF);
    DbgPrint("iFont  = 0x%p\n", ppfe->iFont);
    DbgPrint("IFI Metrics\n");
     vPrintIFIMETRICS(ppfe->pifi);
    DbgPrint("\n");
}
#endif

/******************************Public*Routine******************************\
* EFSMEMOBJ::EFSMEMOBJ(COUNT cefe)
*
* Constructor for font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

EFSMEMOBJ::EFSMEMOBJ(COUNT cefe, ULONG iEnumType_)
{
    fs = 0;
    pefs = (PEFSTATE) HmgAlloc((offsetof(EFSTATE, aefe) + cefe * sizeof(EFENTRY)),
                               EFSTATE_TYPE,
                               HMGR_ALLOC_LOCK);

    if (pefs != PEFSTATENULL)
    {
        vInit(cefe, iEnumType_);
    }
}

/******************************Public*Routine******************************\
* EFSMEMOBJ::~EFSMEMOBJ()
*
* Destructor for font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

EFSMEMOBJ::~EFSMEMOBJ()
{
// If object pointer not null, try to free the object's memory.

    if (pefs != PEFSTATENULL)
    {
        if (fs & EFSMO_KEEPIT)
        {
            DEC_EXCLUSIVE_REF_CNT(pefs);
        }
        else
        {
#if DBG
            if (pefs->cExclusiveLock != 1)
            {
               RIP("Not 1 EFSMEMOBJ\n");
            }
#endif

            HmgFree((HOBJ) pefs->hGet());
        }

        pefs = NULL;
    }
}

#define EFS_QUANTUM     16

/******************************Public*Routine******************************\
* BOOL EFSOBJ::bGrow
*
* Expand the EFENTRY table by the quantum amount.
*
* Returns:
*   TRUE if successful, FALSE if failed.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL EFSOBJ::bGrow (COUNT cefeMinIncrement)
{
    COUNT cefe;
    BOOL bRet = FALSE;

// Allocate a new EFSTATE bigger by the quantum amount.

    cefe = (COUNT) (pefs->pefeBufferEnd - pefs->aefe);

    if (cefeMinIncrement < EFS_QUANTUM)
        cefeMinIncrement = EFS_QUANTUM;
    cefe += cefeMinIncrement;

    EFSMEMOBJ efsmo(cefe, this->pefs->iEnumType);

// Validate new EFSTATE.

    if (efsmo.bValid())
    {
    // Copy the enumeration table.

        efsmo.vXerox(pefs);

    // Swap the EFSTATEs.

        if (HmgSwapHandleContents((HOBJ) hefs(),0,(HOBJ) efsmo.hefs(),0,EFSTATE_TYPE))
        {
        // swap pointers

            PEFSTATE pefsTmp = pefs;
            pefs = efsmo.pefs;
            efsmo.pefs = pefsTmp;               // destructor will delete old PFT
            bRet = TRUE;
        }
        else
            WARNING("gdisrv!bGrowEFSOBJ(): handle swap failed\n");
    }
    else
        WARNING("bGrowEFSOBJ failed alloc\n");

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL EFSOBJ::bAdd                                                        *
*                                                                          *
* Add a new EFENTRY to the table with the HPFE and ENUMFONTSTYLE.          *
*                                                                          *
* Returns:                                                                 *
*   FALSE if an error occurs, TRUE otherwise.                              *
*                                                                          *
* History:                                                                 *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EFSOBJ::bAdd(PFE *ppfe, ENUMFONTSTYLE efsty, FLONG fl, ULONG lfCharSetFilter)
{
// Check if the buffer needs to be expanded.

    COUNT cefeMinIncrement = 1; // will always enumerate at least one pfe

// if EnumFontFamilies is called, will enumerate the font under cAlt more names

    if (!(fl & FL_ENUMFAMILIESEX))
        cefeMinIncrement += ppfe->cAlt;

// if EnumFontFamiliesEx is called, and this font supports multiple charsets,
// this font will be enumerated no more than MAXCHARSETS times.

    if
    (
        (fl & FL_ENUMFAMILIESEX)             &&
        (lfCharSetFilter == DEFAULT_CHARSET) &&
        ppfe->pifi->dpCharSets
    )
    {
        cefeMinIncrement = MAXCHARSETS;
    }

    if ((pefs->pefeDataEnd + cefeMinIncrement) >= pefs->pefeBufferEnd)
    {
        if (!bGrow(cefeMinIncrement))
        {
        // Error code will be saved for us.

            WARNING("gdisrv!EFSOBJ__bAdd: cannot grow enumeration table\n");
            return FALSE;
        }
    }

// Add the new data and increment the data pointer.

    PFEOBJ pfeo(ppfe);

    HPFEC hpfec = pfeo.hpfecGet();
    ULONG iFont = ppfe->iFont;
    pefs->pefeDataEnd->hpfec  = hpfec;
    pefs->pefeDataEnd->iFont = iFont;

    pefs->pefeDataEnd->efsty = efsty;
    pefs->pefeDataEnd->fjOverride = 0; // do not override

    if (fl & FL_ENUMFAMILIESEX)
        pefs->pefeDataEnd->fjOverride |= FJ_CHARSETOVERRIDE;

    pefs->pefeDataEnd->jCharSetOverride = (BYTE)lfCharSetFilter;
    pefs->pefeDataEnd       += 1;
    pefs->cjEfdwTotal += ppfe->cjEfdwPFE;

// now check if called from EnumFonts or EnumFontFamilies so that the
// names from the
// [FontSubstitutes] section in the registry also need to be enumerated

    if (!(fl & FL_ENUMFAMILIESEX) && ppfe->cAlt) // alt names have to be enumerated too
    {
        for (ULONG i = 0; i < ppfe->cAlt; i++)
        {
        // the same hpfe, style etc. all the time, only lie about the name and charset

            pefs->pefeDataEnd->hpfec  = hpfec;
            pefs->pefeDataEnd->iFont = iFont;
            pefs->pefeDataEnd->efsty = efsty;
            pefs->pefeDataEnd->fjOverride = (FJ_FAMILYOVERRIDE | FJ_CHARSETOVERRIDE);  // do override
            pefs->pefeDataEnd->iOverride = ppfe->aiFamilyName[i];
            pefs->pefeDataEnd->jCharSetOverride =
                gpfsTable[pefs->pefeDataEnd->iOverride].fcsFace.jCharSet;
            pefs->pefeDataEnd       += 1;
            pefs->cjEfdwTotal += ppfe->cjEfdwPFE;
        }
    }

// now see if this is called from EnumFontFamiliesEx

    if ((fl & FL_ENUMFAMILIESEX) && (lfCharSetFilter == DEFAULT_CHARSET))
    {
    // The font needs to be enumerated once for every charset it supports

        if (ppfe->pifi->dpCharSets)
        {
            BYTE *ajCharSets = (BYTE*)ppfe->pifi + ppfe->pifi->dpCharSets;
            BYTE *ajCharSetsEnd = ajCharSets + MAXCHARSETS;

        // first fix up the one entry we just filled above

            (pefs->pefeDataEnd-1)->jCharSetOverride = ajCharSets[0];

        // this is from win95-J sources:

#define FEOEM_CHARSET 254

            for
            (
                BYTE *pjCharSets = ajCharSets + 1; // skip the first one, used already
                (*pjCharSets != DEFAULT_CHARSET) &&
                (*pjCharSets != OEM_CHARSET)     &&
                (*pjCharSets != FEOEM_CHARSET)   &&
                (pjCharSets < ajCharSetsEnd)     ;
                pjCharSets++
            )
            {
            // the same hpfe, style etc. all the time, only lie about the name and charset

                pefs->pefeDataEnd->hpfec  = hpfec;
                pefs->pefeDataEnd->iFont = iFont;
                pefs->pefeDataEnd->efsty = efsty;
                pefs->pefeDataEnd->fjOverride = FJ_CHARSETOVERRIDE;
                pefs->pefeDataEnd->iOverride = 0;
                pefs->pefeDataEnd->jCharSetOverride = *pjCharSets;
                pefs->pefeDataEnd       += 1;
                pefs->cjEfdwTotal += ppfe->cjEfdwPFE;
            }
        }
        else //  fix up the one entry we just filled above
        {
            (pefs->pefeDataEnd-1)->jCharSetOverride = ppfe->pifi->jWinCharSet;
        }
    }

// Success.

    return TRUE;
}



/******************************Public*Routine******************************\
* VOID EFSOBJ::vDelete ()
*
* Destroy the font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSOBJ::vDeleteEFSOBJ()
{
    HmgFree((HOBJ) pefs->hGet());
    pefs = PEFSTATENULL;
}


/******************************Member*Function*****************************\
* VOID EFSMEMOBJ::vInit
*
* Initialize the EFSTATE object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSMEMOBJ::vInit(COUNT cefe, ULONG iEnumType_)
{
// HPFE array empty, so initialize all pointer to the beginning of the array.

    pefs->pefeDataEnd  = pefs->aefe;
    pefs->pefeEnumNext = pefs->aefe;

// Except for this one.  Set this one to the end of the buffer.

    pefs->pefeBufferEnd = &pefs->aefe[cefe];

// Initialize the alternate name to NULL.

    pefs->pfsubOverride = NULL;

// init the enum type:

    pefs->iEnumType = iEnumType_;

// empty for now, total enumeration data size is zero

    pefs->cjEfdwTotal = 0;

// We don't need to bother with initializing the array.
}

/******************************Public*Routine******************************\
* VOID EFSMEMOBJ::vXerox(EFSTATE *pefeSrc)
*
* Copy the EFENTRYs from the source EFSTATE's table into this EFSTATE's table.
* The internal pointers will be updated to be consistent with the data.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSMEMOBJ::vXerox(EFSTATE *pefsSrc)
{
//
// Compute size of the table.
//

// Sundown truncation
    ASSERT4GB ((ULONGLONG)(pefs->pefeDataEnd - pefs->aefe));
    COUNT cefe = (COUNT)(pefsSrc->pefeDataEnd - pefsSrc->aefe);

    ASSERTGDI (
        cefe >= (COUNT)(pefs->pefeDataEnd - pefs->aefe),
        "gdisrv!vXeroxEFSMEMOBJ(): table to small\n"
        );

//
// Copy entries.
//
    RtlCopyMemory((PVOID) pefs->aefe, (PVOID) pefsSrc->aefe, (SIZE_T) cefe * sizeof(EFENTRY));

// Fixup the data pointer and size of enumeration data

    pefs->pefeDataEnd = pefs->aefe + cefe;
    pefs->cjEfdwTotal = pefsSrc->cjEfdwTotal;

// iEnumType has been set at the vInit time, it does not have to be reset now.
// Therefore we are done.


}


/******************************Public*Routine******************************\
* bSetEFSTATEOwner
*
* Set the owner of the EFSTATE
*
* if the owner is set to OBJECTOWNER_NONE, this EFSTATE will not be useable
* until bSetEFSTATEOwner is called to explicitly give the lfnt to someone else.
*
* History:
*  07-Aug-1992 by Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
bSetEFSTATEOwner(
    HEFS hefs,
    W32PID lPid)
{
    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return HmgSetOwner((HOBJ) hefs, lPid, EFSTATE_TYPE);
}



/******************************Public*Routine******************************\
* BOOL bSetFontXform
*
* Sets the FD_XFORM such that it can be used to realize the physical font
* with the dimensions specified in the wish list coordinates).  The
* World to Device xform (with translations removed) is also returned.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Tue 27-Oct-1992 23:18:39 by Kirk Olynyk [kirko]
* Moved it from PFEOBJ.CXX
*  19-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
PFEOBJ::bSetFontXform (
    XDCOBJ       &dco,               // realize for this device
    LOGFONTW   *pelfw,             // wish list (in logical coords)
    PFD_XFORM   pfd_xf,             // font transform
    FLONG       fl,
    FLONG       flSim,
    POINTL* const pptlSim,
    IFIOBJ&     ifio,
    BOOL        bIsLinkedFont  // TRUE if the font is linked, FALSE otherwise
    )
{
       BOOL bRet;

       EXFORMOBJ xo(dco, WORLD_TO_DEVICE); // synchronize the transformation

        if(dco.pdc->iGraphicsMode() == GM_COMPATIBLE)
        {
            bRet = bGetNtoD_Win31(
                    pfd_xf,
                    pelfw,
                    ifio,
                    (DCOBJ *)&dco,
                    fl,
                    pptlSim,
                    bIsLinkedFont
                    );
        }
        else // GM_ADVANCED
        {
            bRet = bGetNtoD(
                    pfd_xf,
                    pelfw,
                    ifio,
                    (DCOBJ *)&dco,
                    pptlSim
                    );
        }

        if (!bRet)
        {
            WARNING(
                "gdisrv!bSetFontXformPFEOBJ(): failed to get Notional to World xform\n"
                );
            return FALSE;
        }

    //
    // The next line two lines of code flips the sign of the Notional y-coordinates
    // The effect is that the XFORMOBJ passed over the DDI makes the assumption that
    // Notional space is such that the y-coordinate increases towards the bottom.
    // This is opposite to the usual conventions of notional space and the font
    // driver writers must be made aware of this historical anomaly.
    //
        NEGATE_IEEE_FLOAT(pfd_xf->eYX);
        NEGATE_IEEE_FLOAT(pfd_xf->eYY);

    //
    // If the font can be scaled isotropicslly only then we make sure that we send
    // to the font driver isotropic transformations.
    //
    // If a device has set the TA_CR_90 bit, then it is possible
    // that we will send to the driver a transformation that is equivalent to an isotropic
    // transformation rotated by a multiple of 90 degress. This is the reason for the
    // second line of this transformation.
    //
        if (ifio.bIsotropicScalingOnly())
        {
            *(LONG*)&(pfd_xf->eXX) = *(LONG*)&(pfd_xf->eYY);
            *(LONG*)&(pfd_xf->eXY) = *(LONG*)&(pfd_xf->eYX);
            NEGATE_IEEE_FLOAT(pfd_xf->eXY);
        }

    return (TRUE);
}

/******************************Public*Routine******************************\
* PFE * PFECOBJ::GetPFE(ULONG iFont)
*
* Get PFE from PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   memory pointer of PFE
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

PFE * PFECOBJ::GetPFE(ULONG iFont)
{
    PFE * ppfe = NULL;

    if (ppfec)
    {
        ASSERTGDI(ppfec->pvPFE, "PFECOBJ::GetPFE ppfset->pvPFE is null \n");
        ppfe = (PFE *) ((PBYTE) ppfec->pvPFE + ((iFont - 1) * ppfec->cjPFE));
    }

    return ppfe;
}

/******************************Public*Routine******************************\
* HPFEC  PFECOBJ::GetHPFEC()
*
* Get handle of PFEC from PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   Handle of PFEC
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

HPFEC  PFECOBJ::GetHPFEC()
{
    ASSERTGDI(ppfec, "PFECOBJ::GetHPFEC ppfec is NULL \n");

    return((HPFEC) ppfec->hGet());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pdevobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pdevobj.cxx
*
* Non-inline methods of PDEVOBJ objects.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern DRVFN gadrvfnPanning[];
extern ULONG gcdrvfnPanning;

//
// This flag is TRUE if the default GUI stock font is partially intialized.
// During stock font initialization there is no display driver and therefore
// we do not have one of the parameters (vertical DPI) needed to compute
// the font height.  Therefore, we do it when the first display driver is
// initialized.
//

extern BOOL gbFinishDefGUIFontInit;

//
// This is size of DirectDraw context which we keep in PDEV.
//

extern DWORD gdwDirectDrawContext;

// Use this as the default height if LOGFONTs provided by DEVINFO do not
// specify.

#define DEFAULT_POINT_SIZE          12L
#define DEFAULT_DPI                 72L

#if ((HT_PATSIZE_2x2         != HTPAT_SIZE_2x2)             || \
     (HT_PATSIZE_2x2_M       != HTPAT_SIZE_2x2_M)           || \
     (HT_PATSIZE_4x4         != HTPAT_SIZE_4x4)             || \
     (HT_PATSIZE_4x4_M       != HTPAT_SIZE_4x4_M)           || \
     (HT_PATSIZE_6x6         != HTPAT_SIZE_6x6)             || \
     (HT_PATSIZE_6x6_M       != HTPAT_SIZE_6x6_M)           || \
     (HT_PATSIZE_8x8         != HTPAT_SIZE_8x8)             || \
     (HT_PATSIZE_8x8_M       != HTPAT_SIZE_8x8_M)           || \
     (HT_PATSIZE_10x10       != HTPAT_SIZE_10x10)           || \
     (HT_PATSIZE_10x10_M     != HTPAT_SIZE_10x10_M)         || \
     (HT_PATSIZE_12x12       != HTPAT_SIZE_12x12)           || \
     (HT_PATSIZE_12x12_M     != HTPAT_SIZE_12x12_M)         || \
     (HT_PATSIZE_14x14       != HTPAT_SIZE_14x14)           || \
     (HT_PATSIZE_14x14_M     != HTPAT_SIZE_14x14_M)         || \
     (HT_PATSIZE_16x16       != HTPAT_SIZE_16x16)           || \
     (HT_PATSIZE_16x16_M     != HTPAT_SIZE_16x16_M)         || \
     (HT_PATSIZE_SUPERCELL   != HTPAT_SIZE_SUPERCELL)       || \
     (HT_PATSIZE_SUPERCELL_M != HTPAT_SIZE_SUPERCELL_M)     || \
     (HT_PATSIZE_USER        != HTPAT_SIZE_USER))
#error * HT_PATSIZE different in winddi.h and ht.h *
#endif

#if ((HT_FLAG_SQUARE_DEVICE_PEL != HIF_SQUARE_DEVICE_PEL) || \
     (HT_FLAG_HAS_BLACK_DYE     != HIF_HAS_BLACK_DYE)     || \
     (HT_FLAG_ADDITIVE_PRIMS    != HIF_ADDITIVE_PRIMS))
#error * HT_FLAG different in winddi.h and ht.h *
#endif

//
// Global linked list of all PDEVs in the system.
//

extern "C"
{
    extern HFASTMUTEX ghfmMemory;
}


PPDEV gppdevList = NULL;
PPDEV gppdevTrueType = NULL;
PPDEV gppdevATMFD = NULL;

VOID
vDeleteBitmapClone(
    SURFOBJ *pso
    );

/******************************Member*Function*****************************\
* PDEVOBJ::bMakeSurface ()
*
* Asks the device driver to create a surface for the PDEV.  This function
* can be called even if the PDEV already has a surface.
*
\**************************************************************************/

BOOL PDEVOBJ::bMakeSurface()
{
    TRACE_INIT(("PDEVOBJ::bMakeSurface: ENTERING\n"));

    BOOL bRet;

    if (ppdev->pSurface != NULL)
        return(TRUE);

    HSURF hTemp = (HSURF) 0;

    // Ask the driver for a surface.

    PDEVOBJ po((HDEV)ppdev);

    GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
    hTemp = (*PPFNDRV(po,EnableSurface))(ppdev->dhpdev);
    GreExitMonitoredSection(ppdev, WD_DEVLOCK);

    if (hTemp == (HSURF) 0)
    {
        WARNING("EnableSurface on device return hsurf 0\n");
        return(FALSE);
    }

    SURFREF sr(hTemp);
    ASSERTGDI(sr.bValid(),"Bad surface for device");

// Mark this as a device surface.

    sr.ps->vPDEVSurface();
    sr.vKeepIt();
    ppdev->pSurface = sr.ps;

// For 1.0 compatibility, set the pSurface iFormat to iDitherFormat.  This can
// be changed to an ASSERT if we no longer wants to support NT 1.0 drivers,
// which has BMF_DEVICE in the iFormat for device surfaces.

    if (sr.ps->iFormat() == BMF_DEVICE)
    {
        sr.ps->iFormat(ppdev->devinfo.iDitherFormat);
        ASSERTGDI(ppdev->devinfo.iDitherFormat != BMF_DEVICE,
            "ERROR iformat is hosed\n");
    }

// Put the PDEV's palette in the main device surface.
// Reference count the palette, it has a new user.

    ppdev->pSurface->ppal(ppdev->ppalSurf);

// If this is surface for layered driver, mark it as mirrored surface.

    if (flGraphicsCaps() & GCAPS_LAYERED)
    {
        sr.ps->vSetMirror();
    }

    HmgShareLock((HOBJ) ppdev->ppalSurf->hGet(), PAL_TYPE);

    TRACE_INIT(("PDEVOBJ::bMakeSurface: SUCCESS\n"));

// We move the mouse point off-screen in order to set an initial position and
// to fix a common driver bug, which is to show uninitialized garbage until 
// the first DrvSetPointerShape call occurs.

    if (bDisplayPDEV())
    {
        GreMovePointer(po.hdev(), -1, -1, MP_PROCEDURAL);
    }

// Enable PDEV components.

    bRet = DxDdEnableDirectDraw(po.hdev(),TRUE);

// Filter the driver hooks after DirectDraw has loaded but before we
// enable sprites, so that the filter can filter DirectX calls and
// the sprite code gets the filtered result.

    vFilterDriverHooks();

    bRet &= bSpEnableSprites(po.hdev());

    vEnableSynchronize(po.hdev());

    vNotify(DN_DRAWING_BEGIN, NULL);

    return(bRet);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bEnableHalftone(pca)
*
*  Creates and initializes a device halftone info.  The space is allocated
*  by the halftone.dll with heapCreate() and heapAlloc() calls.  All
*  the halftone resources are managed by the halftone.dll.
*
* History:
*  07-Nov-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

COLORADJUSTMENT gcaDefault =
{
    sizeof(COLORADJUSTMENT),    // WORD          caSize
    0,                          // WORD          caFlags
    ILLUMINANT_DEFAULT,         // WORD          caIlluminantIndex
    HT_DEF_RGB_GAMMA,           // WORD          caRedPowerGamma
    HT_DEF_RGB_GAMMA,           // WORD          caGreenPowerGamma
    HT_DEF_RGB_GAMMA,           // WORD          caBluePowerGamma
    REFERENCE_BLACK_DEFAULT,    // WORD          caReferenceBlack
    REFERENCE_WHITE_DEFAULT,    // WORD          caReferenceWhite
    CONTRAST_ADJ_DEFAULT,       // SHORT         caContrast
    BRIGHTNESS_ADJ_DEFAULT,     // SHORT         caBrightness
    COLORFULNESS_ADJ_DEFAULT,   // SHORT         caColorfulness
    REDGREENTINT_ADJ_DEFAULT,   // SHORT         caRedGreenTint
};

BOOL PDEVOBJ::bEnableHalftone(PCOLORADJUSTMENT pca)
{
    ASSERTGDI(pDevHTInfo() == NULL, "bEnableHalftone: pDevHTInfo not null\n");

    //
    // Create a halftone palette based on the format specified in GDIINFO.
    //

    PALMEMOBJ palHT;
    if (!palHT.bCreateHTPalette(GdiInfo()->ulHTOutputFormat, GdiInfo()))
        return(FALSE);

    //
    // Create the device halftone info.
    //

    HTINITINFO      htInitInfo;
    HALFTONEPATTERN HTPat;

    htInitInfo.Version        = HTINITINFO_VERSION;
    htInitInfo.Flags          = (WORD)(ppdev->GdiInfo.flHTFlags & 0xFFFF);
    htInitInfo.CMYBitMask8BPP = (BYTE)((ppdev->GdiInfo.flHTFlags &
                                        HT_FLAG_8BPP_CMY332_MASK) >> 24);
    htInitInfo.bReserved = 0;

    if (ppdev->GdiInfo.ulHTPatternSize <= HTPAT_SIZE_MAX_INDEX)
        htInitInfo.HTPatternIndex = (BYTE)ppdev->GdiInfo.ulHTPatternSize;
    else
        htInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;

    PCOLORINFO      pci = &GdiInfo()->ciDevice;
    htInitInfo.DevicePowerGamma = (UDECI4)((pci->RedGamma + pci->GreenGamma +
                                            pci->BlueGamma) / 3);
    htInitInfo.DeviceRGamma = (UDECI4)pci->RedGamma;
    htInitInfo.DeviceGGamma = (UDECI4)pci->GreenGamma;
    htInitInfo.DeviceBGamma = (UDECI4)pci->BlueGamma;

    htInitInfo.HTCallBackFunction = NULL;
    htInitInfo.pHalftonePattern = NULL;
    htInitInfo.pInputRGBInfo = NULL;

    if (htInitInfo.HTPatternIndex == HTPAT_SIZE_USER) {

        if ((ppdev->GdiInfo.cxHTPat >= HT_USERPAT_CX_MIN)   &&
            (ppdev->GdiInfo.cxHTPat <= HT_USERPAT_CX_MAX)   &&
            (ppdev->GdiInfo.cyHTPat >= HT_USERPAT_CY_MIN)   &&
            (ppdev->GdiInfo.cyHTPat <= HT_USERPAT_CY_MAX)   &&
            (ppdev->GdiInfo.pHTPatA)                        &&
            (ppdev->GdiInfo.pHTPatB)                        &&
            (ppdev->GdiInfo.pHTPatC)) {

            HTPat.cbSize  = sizeof(HALFTONEPATTERN);
            HTPat.Flags   = 0;
            HTPat.Width   = (WORD)ppdev->GdiInfo.cxHTPat;
            HTPat.Height  = (WORD)ppdev->GdiInfo.cyHTPat;
            HTPat.pHTPatA = (LPBYTE)ppdev->GdiInfo.pHTPatA;
            HTPat.pHTPatB = (LPBYTE)ppdev->GdiInfo.pHTPatB;
            HTPat.pHTPatC = (LPBYTE)ppdev->GdiInfo.pHTPatC;

            htInitInfo.pHalftonePattern = &HTPat;

        } else {

            htInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;
        }
    }

    CIEINFO cie;

    cie.Red.x = (DECI4)pci->Red.x;
    cie.Red.y = (DECI4)pci->Red.y;
    cie.Red.Y = (DECI4)pci->Red.Y;

    cie.Green.x = (DECI4)pci->Green.x;
    cie.Green.y = (DECI4)pci->Green.y;
    cie.Green.Y = (DECI4)pci->Green.Y;

    cie.Blue.x = (DECI4)pci->Blue.x;
    cie.Blue.y = (DECI4)pci->Blue.y;
    cie.Blue.Y = (DECI4)pci->Blue.Y;

    cie.Cyan.x = (DECI4)pci->Cyan.x;
    cie.Cyan.y = (DECI4)pci->Cyan.y;
    cie.Cyan.Y = (DECI4)pci->Cyan.Y;

    cie.Magenta.x = (DECI4)pci->Magenta.x;
    cie.Magenta.y = (DECI4)pci->Magenta.y;
    cie.Magenta.Y = (DECI4)pci->Magenta.Y;

    cie.Yellow.x = (DECI4)pci->Yellow.x;
    cie.Yellow.y = (DECI4)pci->Yellow.y;
    cie.Yellow.Y = (DECI4)pci->Yellow.Y;

    cie.AlignmentWhite.x = (DECI4)pci->AlignmentWhite.x;
    cie.AlignmentWhite.y = (DECI4)pci->AlignmentWhite.y;
    cie.AlignmentWhite.Y = (DECI4)pci->AlignmentWhite.Y;

    htInitInfo.pDeviceCIEInfo = &cie;

    SOLIDDYESINFO DeviceSolidDyesInfo;

    DeviceSolidDyesInfo.MagentaInCyanDye = (UDECI4)pci->MagentaInCyanDye;
    DeviceSolidDyesInfo.YellowInCyanDye  = (UDECI4)pci->YellowInCyanDye;
    DeviceSolidDyesInfo.CyanInMagentaDye = (UDECI4)pci->CyanInMagentaDye;
    DeviceSolidDyesInfo.YellowInMagentaDye = (UDECI4)pci->YellowInMagentaDye;
    DeviceSolidDyesInfo.CyanInYellowDye = (UDECI4)pci->CyanInYellowDye;
    DeviceSolidDyesInfo.MagentaInYellowDye = (UDECI4)pci->MagentaInYellowDye;

    htInitInfo.pDeviceSolidDyesInfo = &DeviceSolidDyesInfo;

    htInitInfo.DeviceResXDPI = (WORD)ppdev->GdiInfo.ulLogPixelsX;
    htInitInfo.DeviceResYDPI = (WORD)ppdev->GdiInfo.ulLogPixelsY;
    htInitInfo.DevicePelsDPI = (WORD)ppdev->GdiInfo.ulDevicePelsDPI;

    if (pca == NULL)
        htInitInfo.DefHTColorAdjustment = gcaDefault;
    else
        htInitInfo.DefHTColorAdjustment = *pca;

    if (HT_CreateDeviceHalftoneInfo(&htInitInfo,
                         (PPDEVICEHALFTONEINFO)&(ppdev->pDevHTInfo)) <= 0L)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        ppdev->pDevHTInfo = NULL;
        return(FALSE);
    }

// Check if halftone palette is the same as the device palette.
//
// For now, don't do display devices because dynamic mode changes may
// cause their palette to change at any time.

    vHTPalIsDevPal(FALSE);
    if (!bDisplayPDEV())
    {
        XEPALOBJ palSurf(ppalSurf());
        if (palHT.bEqualEntries(palSurf))
            vHTPalIsDevPal(TRUE);
    }

// Keep the halftone palette since this function won't fail.

    ((DEVICEHALFTONEINFO *)pDevHTInfo())->DeviceOwnData = (ULONG_PTR)palHT.hpal();
    palHT.vSetPID(OBJECT_OWNER_PUBLIC);
    palHT.vKeepIt();

    return(TRUE);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bDisableHalftone()
*
*  Delete the device halftone info structure.
*
* History:
*  07-Nov-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL PDEVOBJ::bDisableHalftone()
{
    ASSERTGDI((pDevHTInfo() != NULL), "bDisableHalftone: DevHTInfo null\n");

    DEVICEHALFTONEINFO *pDevHTInfo_ = (DEVICEHALFTONEINFO *)pDevHTInfo();

    if (fl(PDEV_ALLOCATEDBRUSHES))
    {
        for(int iPat = 0; iPat < HS_DDI_MAX; iPat++)
        {
            bDeleteSurface(ppdev->ahsurf[iPat]);
        }
    }

    ppdev->pDevHTInfo = NULL;

// Delete the halftone palette.

    BOOL bStatusPal = bDeletePalette((HPAL)pDevHTInfo_->DeviceOwnData);
    BOOL bStatusHT  = HT_DestroyDeviceHalftoneInfo(pDevHTInfo_);

    return(bStatusPal && bStatusHT);
}

ULONG gaaulPat[HS_DDI_MAX][8] = {

// Scans have to be DWORD aligned:

    { 0x00,                // ........     HS_HORIZONTAL 0
      0x00,                // ........
      0x00,                // ........
      0xff,                // ********
      0x00,                // ........
      0x00,                // ........
      0x00,                // ........
      0x00 },              // ........

    { 0x08,                // ....*...     HS_VERTICAL 1
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x80,                // *.......     HS_FDIAGONAL 2
      0x40,                // .*......
      0x20,                // ..*.....
      0x10,                // ...*....
      0x08,                // ....*...
      0x04,                // .....*..
      0x02,                // ......*.
      0x01 },              // .......*

    { 0x01,                // .......*     HS_BDIAGONAL 3
      0x02,                // ......*.
      0x04,                // .....*..
      0x08,                // ....*...
      0x10,                // ...*....
      0x20,                // ..*.....
      0x40,                // .*......
      0x80 },              // *.......

    { 0x08,                // ....*...     HS_CROSS 4
      0x08,                // ....*...
      0x08,                // ....*...
      0xff,                // ********
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x81,                // *......*     HS_DIAGCROSS 5
      0x42,                // .*....*.
      0x24,                // ..*..*..
      0x18,                // ...**...
      0x18,                // ...**...
      0x24,                // ..*..*..
      0x42,                // .*....*.
      0x81 }               // *......*
};


/**************************************************************************\
* PDEVOBJ::bCreateDefaultBrushes()
*
\**************************************************************************/

BOOL PDEVOBJ::bCreateDefaultBrushes()
{
    SIZEL   sizl;
    LONG    i;

    sizl.cx = 8;
    sizl.cy = 8;

    for (i = 0; i < HS_DDI_MAX; i++)
    {
        ppdev->ahsurf[i] = (HSURF) EngCreateBitmap(sizl,
                                                   (LONG) sizeof(ULONG),
                                                   BMF_1BPP,
                                                   BMF_TOPDOWN,
                                                   &gaaulPat[i][0]);

        if (ppdev->ahsurf[i] == NULL)
        {
            TRACE_INIT(("Failed bCreateDefaultBrushes - BAD !"));
            return(FALSE);
        }
    }

    return(TRUE);
}


/******************************Member*Function*****************************\
* PDEVOBJ::bCreateHalftoneBrushes()
*
* History:
*    The standard patterns for the NT/window has following order
*
*        Index 0     - Horizontal Line
*        Index 1     - Vertical Line
*        Index 2     - 45 degree line going up
*        Index 3     - 45 degree line going down
*        Index 4     - Horizontal/Vertical cross
*        Index 5     - 45 degree line up/down cross
*        Index 6     - 30 degree line going up
*        Index 7     - 30 degree line going down
*        Index 8     -   0% Lightness (BLACK)
*        Index 9     -  11% Lightness (very light Gray)
*        Index 10    -  22% Lightness
*        Index 11    -  33% Lightness
*        Index 12    -  44% Lightness
*        Index 13    -  56% Lightness
*        Index 14    -  67% Lightness
*        Index 15    -  78% Lightness
*        Index 16    -  89% Lightness
*        Index 17    - 100% Lightness (White)
*        Index 18    -  50% Lightness (GRAY)
*
*Return Value:
*
*    return value is total patterns created, if return value is <= 0 then an
*    error occurred.
*
*
*Author:
*
*    10-Mar-1992 Tue 20:30:44 created  -by-  Daniel Chou (danielc)
*
*    24-Nov-1992 -by-  Eric Kutter [erick] and DanielChou (danielc)
*     moved from printers\lib
\**************************************************************************/

BOOL PDEVOBJ::bCreateHalftoneBrushes()
{
    STDMONOPATTERN      SMP;
    LONG                cbPat;
    LONG                cb2;
    INT                 cPatRet;

    static BYTE         HTStdPatIndex[HS_DDI_MAX] = {

                                HT_SMP_HORZ_LINE,
                                HT_SMP_VERT_LINE,
                                HT_SMP_DIAG_45_LINE_DOWN,
                                HT_SMP_DIAG_45_LINE_UP,
                                HT_SMP_HORZ_VERT_CROSS,
                                HT_SMP_DIAG_45_CROSS
                        };

// better initialize the halftone stuff if it isn't already

    if ((pDevHTInfo() == NULL) && !bEnableHalftone(NULL))
        return(FALSE);

    cbPat = (LONG)sizeof(LPBYTE) * (LONG)(HS_DDI_MAX + 1);

// go through all the standard patterns

    for(cPatRet = 0; cPatRet < HS_DDI_MAX;)
    {

    // We will using default 0.01" line width and 10 lines per inch
    // halftone default

        SMP.Flags              = SMP_TOPDOWN;
        SMP.ScanLineAlignBytes = BMF_ALIGN_DWORD;
        SMP.PatternIndex       = HTStdPatIndex[cPatRet];
        SMP.LineWidth          = 8;
        SMP.LinesPerInch       = 15;

    // Get the cx/cy size of the pattern and total bytes required
    // to stored the pattern

        SMP.pPattern = NULL;                 /* To find the size */

        if ((cbPat = HT_CreateStandardMonoPattern((PDEVICEHALFTONEINFO)pDevHTInfo(), &SMP)) <= 0)
        {
            break;
        }

        //
        // create the bitmap
        //

        DEVBITMAPINFO dbmi;


        dbmi.iFormat  = BMF_1BPP;
        dbmi.cxBitmap = SMP.cxPels;
        dbmi.cyBitmap = SMP.cyPels;
        dbmi.hpal     = (HPALETTE) 0;
        dbmi.fl       = BMF_TOPDOWN;

        SURFMEM SurfDimo;

        SurfDimo.bCreateDIB(&dbmi, NULL);

        if (!SurfDimo.bValid())
        {
            break;
        }

        SurfDimo.vKeepIt();
        SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);

        ppdev->ahsurf[cPatRet] = SurfDimo.ps->hsurf();
        SMP.pPattern           = (PBYTE)SurfDimo.ps->pvBits();

        //
        // advance the count now so we clean up as appropriate
        //

        ++cPatRet;

    // now set the bits

        if ((cb2 = HT_CreateStandardMonoPattern((PDEVICEHALFTONEINFO)pDevHTInfo(), &SMP)) != cbPat)
        {
            break;
        }
    }

// if we failed, we had better delete what we created.

    if (cPatRet < HS_DDI_MAX)
    {
        while (cPatRet-- > 0)
        {
            bDeleteSurface(ppdev->ahsurf[cPatRet]);
        }

        return(FALSE);
    }

    setfl(TRUE, PDEV_ALLOCATEDBRUSHES);

    return(TRUE);
}

/******************************Public*Routine******************************\
* FLONG flRaster(ulTechnology, flGraphicsCaps)
*
* Computes the appropriate Win3.1 style 'flRaster' flags for the device
* given GDIINFO data.
*
* History:
*  1-Feb-1993 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*
\**************************************************************************/

FLONG flRaster(ULONG ulTechnology, FLONG flGraphicsCaps)
{
// Flags Win32 never sets:
// -----------------------
//
//   RC_BANDING       -- Banding is always transparent to programmer
//   RC_SCALING       -- Special scaling support is never required
//   RC_GDI20_OUTPUT  -- Win2.0 state blocks in device contexts not supported
//   RC_SAVEBITMAP    -- Bitmap saving is transparent and SaveScreenBitmap not
//                       exported
//   RC_DEVBITS       -- Drivers don't export BitmapBits or SelectBitmap

// Flags Win32 always sets:
// ------------------------

    FLONG fl = (RC_BIGFONT      | // All devices support fonts > 64k
                RC_GDI20_OUTPUT | // We handle most Win 2.0 features

// Set that not-terribly-well documented text flag:

                RC_OP_DX_OUTPUT); // Can do opaque ExtTextOuts with dx array

// Line printers and pen plotters can't support any bitmap BitBlt's:

    if ((ulTechnology != DT_PLOTTER) && (ulTechnology != DT_CHARSTREAM))
    {
        fl |= (RC_BITBLT       | // Can transfer bitmaps
               RC_BITMAP64     | // Can support bitmaps > 64k
               RC_DI_BITMAP    | // Support SetDIBIts and GetDIBits
               RC_DIBTODEV     | // Support SetDIBitsToDevice
               RC_STRETCHBLT   | // Support StretchBlts
               RC_STRETCHDIB);   // Support SetchDIBits
    }

// Printers can't journal FloodFill cals, so only allow raster displays:

    if (ulTechnology == DT_RASDISPLAY)
        fl |= RC_FLOODFILL;

// Set palette flag from capabilities bit:

    if (flGraphicsCaps & GCAPS_PALMANAGED)
        fl |= RC_PALETTE;

    return(fl);
}



/*
*
*   HACK 
*
*/

LPWSTR
EngGetPrinterDataFileName(
    HDEV hdev)
{

    return ((PPDEV)hdev)->pwszDataFile;
}

/*
*
*   HACK 
*
*/

LPWSTR
EngGetDriverName(
    HDEV hdev)
{
    return ((PPDEV)hdev)->pldev->pGdiDriverInfo->DriverName.Buffer;
}

/******************************Public*Routine******************************\
* EngQueryAttribute
*
* This is the engine entry point for device drivers to query device 
* attributes.
*
* hDev must always be a valid device.
*
* This call will return TRUE for success and FALSE for failure.
*
* QDA_ACCELERATION_LEVEL:
*     pvIn - ignored
*     pvInSize - ignored
*     pvOut - pointer to DWORD
*     pvOutSize - sizeof(DWORD)
*
*     The current device acceleration level is returned in pvOut.  Please
*     see ??? for a discussion of acceleration levels.
*
*     NOTE: we should have an enumeration in winddi.h for acceleration
*           levels.
*
*
* History:
*  07-Nov-1998 -by- Bart House bhouse
* Wrote it.
\**************************************************************************/

BOOL
EngQueryDeviceAttribute(
    HDEV                    hdev,
    ENG_DEVICE_ATTRIBUTE    devAttr,
    VOID *                  pvIn,
    ULONG                   ulInSize,
    VOID *                  pvOut,
    ULONG                   ulOutSize)
{
    BOOL    bResult = FALSE;    // assume failure
    PPDEV   ppdev = (PPDEV) hdev;

    if(pvOut != NULL)
    {

        switch(devAttr)
        {
        
        case QDA_ACCELERATION_LEVEL:
            if(ulOutSize == sizeof(DWORD))
            {
                *((DWORD *) pvOut) = ppdev->dwDriverAccelerationLevel;
                bResult = TRUE;
            }
            else
            {
                WARNING("EngQueryDeviceAttribute -- bad ulOutSize");
            }
            break;
    
        default:
            WARNING("EngQueryDeviceAttribute -- unknown device attribte");
            break;
        }
    }
    else
    {
        WARNING("EngQueryDeviceAttribute -- pvOut is NULL");
    }

    return bResult;
}

/******************************Member*Function*****************************\
* PDEVOBJ::PDEVOBJ
*
* Create a PDEVOBJ based on given HDEV.
*
* History:
*  1-Apr-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

// Should be in header to share with icmapi.cxx and ddraw.cxx

#define MAX_COLORTABLE     256

PDEVOBJ::PDEVOBJ
(
    HDEV hdevOrg,
    FLONG fl
)
{
    GDIFunctionID(PDEVOBJ::PDEVOBJ<clone>);

    INT i;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: ENTERING\n"));

    ppdev = (PDEV *) NULL;

    PDEVOBJ pdoOrg(hdevOrg);

    //
    // Validate input.
    // 
    // 1) Only GCH_CLONE_DISPLAY supported.
    // 2) hdevOrg should be valid.
    // 3) hdevOrg should be display device.
    //
    if ((fl != GCH_CLONE_DISPLAY) || (!pdoOrg.bValid()) || (!pdoOrg.bDisplayPDEV()))
    {
        WARNING("Failed to validate input parameter\n");
        return;
    }

    DEVLOCKOBJ dlo(pdoOrg);

    ppdev = (PDEV *) PALLOCMEM(sizeof(PDEV) - sizeof(DWORD) + gdwDirectDrawContext, 'veDG');

    if (ppdev == NULL)
    {
        WARNING("Failed allocation of PDEV\n");
        return;
    }

    PDEV *ppdevOrg = (PDEV *) pdoOrg.hdev();

    ppdev->pldev       = ppdevOrg->pldev;
    ppdev->ppdevParent = ppdev;
    ppdev->ulTag       = 'Pdev';

    PDEVOBJ pdo((HDEV) ppdev);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Mirroring original hdev info to clone\n"));

    //
    // Copy fields which can be copied from original.
    //

    ppdev->pfnDrvSetPointerShape = ppdevOrg->pfnDrvSetPointerShape; // Accelerator
    ppdev->pfnDrvMovePointer     = ppdevOrg->pfnDrvMovePointer;     // Accelerator
    ppdev->pfnMovePointer        = ppdevOrg->pfnMovePointer;        // Accelerator
    ppdev->pfnSync               = ppdevOrg->pfnSync;               // Accelerator
    ppdev->pfnSyncSurface        = ppdevOrg->pfnSyncSurface;        // Accelerator
    ppdev->pfnSetPalette         = ppdevOrg->pfnSetPalette;
    ppdev->pfnNotify             = ppdevOrg->pfnNotify;

    ppdev->dhpdev                = ppdevOrg->dhpdev;

    ppdev->ppalSurf              = ppdevOrg->ppalSurf;
    ppdev->devinfo               = ppdevOrg->devinfo;  
    ppdev->GdiInfo               = ppdevOrg->GdiInfo;
    ppdev->hSpooler              = ppdevOrg->hSpooler;
    ppdev->pDesktopId            = ppdevOrg->pDesktopId;
    ppdev->pGraphicsDevice       = ppdevOrg->pGraphicsDevice;
    ppdev->ptlOrigin             = ppdevOrg->ptlOrigin;

    if (ppdevOrg->ppdevDevmode)
    {
         DWORD dwSize = ppdevOrg->ppdevDevmode->dmSize +
                        ppdevOrg->ppdevDevmode->dmDriverExtra;

         ppdev->ppdevDevmode     = (PDEVMODEW) PALLOCNOZ(dwSize,GDITAG_DEVMODE);

         if (ppdev->ppdevDevmode)
         {
             RtlMoveMemory(ppdev->ppdevDevmode,
                           ppdevOrg->ppdevDevmode,
                           dwSize);
         }
         else
         {
             goto ERROR_RETURN;
         }
    }

    ppdev->flAccelerated         = ppdevOrg->flAccelerated;

    ppdev->ptlPointer            = ppdevOrg->ptlPointer;

    ppdev->hlfntDefault          = ppdevOrg->hlfntDefault;
    ppdev->hlfntAnsiVariable     = ppdevOrg->hlfntAnsiVariable;
    ppdev->hlfntAnsiFixed        = ppdevOrg->hlfntAnsiFixed;

    ppdev->pSurface              = ppdevOrg->pSurface;

    for (i = 0; i < HS_DDI_MAX; i++)
    {
        ppdev->ahsurf[i]         = ppdevOrg->ahsurf[i];
    }

    ppdev->pwszDataFile          = ppdevOrg->pwszDataFile;

    if (ppdevOrg->pvGammaRampTable)
    {
        ppdev->pvGammaRampTable  = (LPVOID) PALLOCNOZ(
                         MAX_COLORTABLE * sizeof(WORD) * 3,
                         'mciG');

        if (ppdev->pvGammaRampTable)
        {
            RtlCopyMemory(ppdev->pvGammaRampTable,
                          ppdevOrg->pvGammaRampTable,
                          MAX_COLORTABLE * sizeof(WORD) * 3);
        }
        else
        {
            goto ERROR_RETURN;
        }
    }

    ppdev->sizlMeta              = ppdevOrg->sizlMeta;
    ppdev->pfnUnfilteredBitBlt   = ppdevOrg->pfnUnfilteredBitBlt;
    ppdev->dwDriverCapableOverride
                                 = ppdevOrg->dwDriverCapableOverride;
    ppdev->dwDriverAccelerationLevel
                                 = ppdevOrg->dwDriverAccelerationLevel;

    RtlCopyMemory(ppdev->apfn,ppdevOrg->apfn,sizeof(ppdev->apfn));

    //
    // If the DDI is hooked, we want to make sure that we don't copy
    // the Sp function pointers from ppdevOrg, but get the driver function
    // pointers from the SPRITESTATE instead.  See vSpHook for details.
    //

    if (pdoOrg.pSpriteState()->bHooked)
    {
        SPRITESTATE *pState = pdoOrg.pSpriteState();

        ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) pState->pfnStrokePath;
        ppdev->apfn[INDEX_DrvFillPath]          = (PFN) pState->pfnFillPath;
        ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) pState->pfnBitBlt;
        ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) pState->pfnCopyBits;
        ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) pState->pfnStretchBlt;
        ppdev->apfn[INDEX_DrvTextOut]           = (PFN) pState->pfnTextOut;
        ppdev->apfn[INDEX_DrvLineTo]            = (PFN) pState->pfnLineTo;
        ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) pState->pfnTransparentBlt;
        ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) pState->pfnAlphaBlend;
        ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) pState->pfnPlgBlt;
        ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) pState->pfnGradientFill;
        ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) pState->pfnStretchBltROP;
        ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) pState->pfnSaveScreenBits;
        ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) pState->pfnDrawStream;
    }

    //
    // Set up the fields can not just copied from original.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Setup new hdev info for clone\n"));

    //
    // PDEVOBJ.cPdevRefs and PDEVOBJ.cPdevOpenRefs.
    //

    ppdev->cPdevRefs     = 1; // Number of clients.
    ppdev->cPdevOpenRefs = 1; // OpenCount

    //
    // Setup flags.
    //
    // We only inherit the flag which still has valid in clone, too.
    //

    ppdev->fl = ppdevOrg->fl & (PDEV_DISPLAY |
                                PDEV_GAMMARAMP_TABLE |
                                PDEV_META_DEVICE |
                                PDEV_DRIVER_PUNTED_CALL);

    //
    // PDEVOBJ.hsemDevLock
    //
    
    if ((ppdev->hsemDevLock = GreCreateSemaphore()) == NULL)
        goto ERROR_RETURN;

    //
    // we now load font info only when needed.  The driver still must have
    // setup the default font information.
    //

    bGotFonts(FALSE);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Create pointer semaphore\n"));

    //
    // PDEVOBJ.hsemPoiner
    //

    ppdev->hsemPointer = GreCreateSemaphore();
    if (!ppdev->hsemPointer)
        goto ERROR_RETURN;

    //
    // Enable DirectDraw (for clone).
    //

    if (!DxDdEnableDirectDraw(pdo.hdev(),FALSE))
        goto ERROR_RETURN;

    //
    // Adjust original pdev as cloned.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Processing onto new hdev as clone\n"));

    //
    // Mark new pdev as clone.
    //

    pdo.bCloneDriver(TRUE);

    //
    // NOTE: AFTER HERE, ERROR_RETURN COULD NOT BE ALLOWED
    //

#ifdef DDI_WATCHDOG

    //
    // !!! Hack - since watchdog creation requires access to DEVICE_OBJECT now
    // we have to delay watchdog creation till hCreateHDEV where PDEV gets associated
    // with DEVICE_OBJECT. It would be nice to have it here though.
    //

    ppdev->pWatchdogData = NULL;

#endif  // DDI_WATCHDOG

    // PDEVOBJ.ppdevNext.
    //
    // Finally, everything done, so put this on global list.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Insert new hdev to global list\n"));

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    ppdev->ppdevNext = gppdevList;
    gppdevList = ppdev;

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: LEAVING with success\n"));

    return;

ERROR_RETURN:

    if (ppdev->hsemDevLock)
    {
        GreDeleteSemaphore(ppdev->hsemDevLock);
    }

    if (ppdev->ppdevDevmode)
    {
        VFREEMEM(ppdev->ppdevDevmode);
    }

    if (ppdev->pvGammaRampTable)
    {
        VFREEMEM(ppdev->pvGammaRampTable);
    }

    DxDdDisableDirectDraw(pdo.hdev(),FALSE);

    VFREEMEM(ppdev);

    ppdev = (PDEV *) NULL;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: LEAVING with error\n"));

    return;
}

/******************************Member*Function*****************************\
* PDEVOBJ::PDEVOBJ
*
* Allocates and initializes a PDEV, i.e. takes the reference count from
* zero to one.
*
* The object must be completely constructed, otherwise completely destroyed.
*
\**************************************************************************/

PDEVOBJ::PDEVOBJ
(
    PLDEV pldev,
    PDEVMODEW pdriv,
    PWSZ pwszLogAddr,
    PWSZ pwszDataFile,
    PWSZ pwszDeviceName,
    HANDLE hSpool,
    PREMOTETYPEONENODE pRemoteTypeOne,
    PGDIINFO pMirroredGdiInfo,
    PDEVINFO pMirroredDevInfo,
    BOOL     bUMPD,
    DWORD    dwCapableOverride,
    ULONG    dwAccelerationLevel
)
{
    GDIFunctionID(PDEVOBJ::PDEVOBJ);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ: ENTERING\n"));

    if (bUMPD)
    {
        ppdev = (PDEV *) EngAllocMem(FL_ZERO_MEMORY,sizeof(PDEV) - sizeof(DWORD) + gdwDirectDrawContext, 'veDG');
    }
    else
    {
        ppdev = (PDEV *) PALLOCMEM(sizeof(PDEV) - sizeof(DWORD) + gdwDirectDrawContext, 'veDG');
    }

    if (ppdev == NULL)
    {
        WARNING("Failed allocation of PDEV\n");
        return;
    }

    ppdev->ppdevParent = ppdev;
    ppdev->pldev = pldev;
    ppdev->ulTag = 'Pdev';
    ppdev->dwDriverCapableOverride = dwCapableOverride;
    ppdev->dwDriverAccelerationLevel = dwAccelerationLevel;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ: Calling driver to initialize PDEV\n"));

    PDEVOBJ pdo((HDEV) ppdev);

    //
    // Create semaphores so the device can be locked.
    //

    if (ppdev->pldev->ldevType != LDEV_FONT)
    {
        ppdev->hsemDevLock = GreCreateSemaphore();
        if (!ppdev->hsemDevLock)
            goto ERROR_RETURN;
    }

    if ( dwCapableOverride & DRIVER_NOT_CAPABLE_GDI )
    {
        //
        // If the driver is not capable of GDI, then it is similar to
        // DRIVER_ACCELERATIONS_NONE. Reset the level we stored in PDEV
        //     
        ppdev->dwDriverAccelerationLevel = DRIVER_ACCELERATIONS_NONE;
    }

    //
    // fill in the dispatch table.  If we've been told to allow no
    // driver accelerations, redirect everything to the panning driver,
    // which handles this case.
    //
    if ((ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) &&
        (dwDriverAccelerationsLevel() == DRIVER_ACCELERATIONS_NONE))
    {
        //
        // Fill in function table with Panning driver versions.
        //
        bFillFunctionTable(gadrvfnPanning, 
                           gcdrvfnPanning, 
                           &ppdev->apfn[0]);
    }
    else
    {
        RtlMoveMemory(&(ppdev->apfn[0]),
                      &(ppdev->pldev->apfn[0]),
                      sizeof(PFN) * INDEX_LAST);
    }

    //
    // if we are doing a ResetDC then we need to transfer over remote type 1
    // fonts from previous PDEV
    //

    ppdev->RemoteTypeOne = pRemoteTypeOne;

    //
    // HACK - temporary
    //

    ppdev->pwszDataFile = pwszDataFile;

    //
    // If this is a Mirroring driver, we want to pass in the global GDIINFO
    // and DEVINFO as returned by the primary driver.
    //

    if (pMirroredGdiInfo)
    {
        ppdev->GdiInfo = *pMirroredGdiInfo;
        ppdev->devinfo = *pMirroredDevInfo;
    }

    //
    // Ask the device driver to create a PDEV.
    //

    UMDHPDEV *pUMdhpdev;

    pdo.bUMPD(bUMPD);

    if (bUMPD)
    {
        //
        // NOTE: we store the umpdCookie in dhpdev so that we can pass the
        //       cookie to the UM UMPD layer during DrvEnablePDEV
        //
        ppdev->dhpdev = (DHPDEV) pldev->umpdCookie;
    }

    ppdev->dhpdev = pdo.EnablePDEV (
                      pdriv,            // Driver Data.
                      pwszLogAddr,      // Logical Address.
                      HS_DDI_MAX,       // Count of standard patterns.
                      ppdev->ahsurf,    // Buffer for standard patterns
                      sizeof(GDIINFO),  // Size of GdiInfo
                      &ppdev->GdiInfo,  // Buffer for GdiInfo
                      sizeof(DEVINFO),  // Number of bytes in devinfo.
                      &ppdev->devinfo,  // Device info.
                      (HDEV)ppdev,      // Data File
                      pwszDeviceName,   // Device Name
                      hSpool);          // Base driver handle

    if (ppdev->dhpdev)
    {
        TRACE_INIT(("PDEVOBJ::PDEVOBJ: PDEV initialized by the driver\n"));

        if (ppdev->pldev->ldevType != LDEV_FONT)
        {
            //
            // Make sure that units are in MicroMeters for HorzSize, VertSize
            //

            if ( (LONG)ppdev->GdiInfo.ulHorzSize <= 0 )
            {
                if ( (LONG)ppdev->GdiInfo.ulHorzSize == 0)
                {
                    // Calculate the ulHorzSize using Default DPI.
                    // Width in mm =  (ulHorzRes / DEFAULT_DPI) * 25.4

                    ppdev->GdiInfo.ulHorzSize = (254 *
                        (LONG)ppdev->GdiInfo.ulHorzRes) / (10*DEFAULT_DPI);
                }
                else
                    ppdev->GdiInfo.ulHorzSize = (ULONG)(-(LONG)ppdev->GdiInfo.ulHorzSize);
            }
            else
            {
                ppdev->GdiInfo.ulHorzSize *= 1000;
            }

            if ( (LONG)ppdev->GdiInfo.ulVertSize <= 0 )
            {
                if ( (LONG)ppdev->GdiInfo.ulVertSize == 0)
                {
                    // Calculate the ulVertSize using Default DPI.
                    // Height in mm =  (ulVertRes / DEFAULT_DPI) * 25.4

                    ppdev->GdiInfo.ulVertSize = (254 *
                        (LONG)ppdev->GdiInfo.ulVertRes) / (10*DEFAULT_DPI);
                }
                else
                {
                    ppdev->GdiInfo.ulVertSize = (ULONG)(-(LONG)ppdev->GdiInfo.ulVertSize);
                }
            }
            else
            {
                ppdev->GdiInfo.ulVertSize *= 1000;
            }

            //
            // For compatibility, all displays will have constant style
            // values (plus this helps us because we know the values won't
            // change asynchronously because of dynamic mode changes):
            //

            if (ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY)
            {
                ppdev->GdiInfo.xStyleStep   = 1;
                ppdev->GdiInfo.yStyleStep   = 1;
                ppdev->GdiInfo.denStyleStep = 3;
            }
            else
            {
            #if DBG
                if (ppdev->GdiInfo.xStyleStep == 0)
                    WARNING("Device gave xStyleStep of 0");
                if (ppdev->GdiInfo.yStyleStep == 0)
                    WARNING("Device gave yStyleStep of 0");
                if (ppdev->GdiInfo.denStyleStep == 0)
                    WARNING("Device gave denStyleStep of 0");
            #endif
            }

            //
            // Compute the appropriate raster flags:
            //

            ppdev->GdiInfo.flRaster = flRaster(ppdev->GdiInfo.ulTechnology,
                                               ppdev->devinfo.flGraphicsCaps);

            TRACE_INIT(("PDEVOBJ::PDEVOBJ: Creating the default palette\n"));

            //
            // The default palette is stored in devinfo in the pdev.
            // This will be the palette we use for the main surface enabled.
            //

            ASSERTGDI(ppdev->devinfo.hpalDefault != 0,
                      "ERROR_RETURN devinfo.hpalDefault invalid");

            {
                EPALOBJ palDefault(ppdev->devinfo.hpalDefault);

                ASSERTGDI(palDefault.bValid(), "ERROR_RETURN hpalDefault invalid");

                //
                // Bug #68071:  display drivers often set the ulPrimaryOrder
                // field wrong (because of wrong sample code we gave them),
                // which causes red to be switched with blue in halftone
                // colors.  We fix this by ignoring the ulPrimaryOrder that they
                // pass us and instead compute it from the Palette.
                //
                // 19-Mar-1999 Fri 12:10:22 updated  -by-  Daniel Chou (danielc)
                //  Many ohter drivers also set ulPrimaryOrder wrong when the
                //  surface format >= 16BPP, here we should check for all
                //  devices, not just display, so we removed following line
                //  that only check for the display. This make it check on
                //  every pdev.
                //
                // if (ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY)
                //

                {
                    if (!(palDefault.bIsIndexed()))
                    {
                        //
                        // 6 possibilities here:  to be safe we should account for all of them.
                        // This code can probably be made simpler if we assume that the
                        // values of the PRIMARY_ORDER_xxx constants won't change, but it's
                        // not that big a deal.
                        //
                        if ((palDefault.flRed() > palDefault.flGre()) &&
                            (palDefault.flRed() > palDefault.flBlu()))
                        {
                            if (palDefault.flGre() > palDefault.flBlu())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_ABC;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_ACB;
                            }
                        }
                        else if ((palDefault.flGre() > palDefault.flRed()) &&
                                 (palDefault.flGre() > palDefault.flBlu()))
                        {
                            if (palDefault.flRed() > palDefault.flBlu())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_BAC;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_BCA;
                            }
                        }
                        else
                        {
                            // Blue must be greatest (leftmost)
                            if (palDefault.flRed() > palDefault.flGre())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_CAB;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_CBA;
                            }
                        }
                    }
                }

                if (ppdev->GdiInfo.flRaster & RC_PALETTE)
                {
                    //
                    // Attempt to make it palette managed.
                    // 
                    if(!CreateSurfacePal(palDefault,
                                     PAL_MANAGED,
                                     ppdev->GdiInfo.ulNumColors,
                                     ppdev->GdiInfo.ulNumPalReg))
                    {
                        goto ERROR_RETURN;
                    }
                }

                ppalSurf(palDefault.ppalGet());

                //
                // Leave a reference count of 1 on this palette.
                //

                palDefault.ppalSet(NULL);
            }

            //
            // if the driver didn't fill in the brushes, we'll do it.
            //
            // if it's a display driver, we'll overwrite its brushes with our
            // own, regardless of whether it already filled in the brushes or
            // not.  Note that it's okay even if a display driver filled in
            // these values -- the driver already had to keep its own copy of
            // the handles and will clean them up at DrvDisablePDEV time.
            // Supplying our own defaults also simplifies GreDynamicModeChange.
            //

            if ( (ppdev->ahsurf[0] == NULL) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_MIRROR) )
            {
                TRACE_INIT(("PDEVOBJ::PDEVOBJ: Creating brushes dor the driver\n"));

                if (ppdev->pldev->ldevType == LDEV_DEVICE_PRINTER)
                {
                    if (!bCreateHalftoneBrushes())
                        goto ERROR_RETURN;
                }
                else
                {
                    // WINBUG #55204 2-1-2000 bhouse Look into whether we leak default brushes
                    //
                    // Andre Vachon
                    // 6-6-95  Kernel mode cleanup
                    //
                    // The old behaviour is the call the halftoneBrushes function
                    // It ends up in a bunch of very complex halftoning code that I have
                    // no idea what it does.
                    // For now, to clean up drivers in kernel mode, replace this call
                    // with a simple function that will create the 6 bitmaps just
                    // like display drivers did.

                    // Where do these ever get cleaned up?!?  I see where the
                    //     halftone brushes get cleaned up, but not these.

                    if (!bCreateDefaultBrushes())
                        goto ERROR_RETURN;
                }
            }

            //
            // Set the hSpooler first
            //

            hSpooler(hSpool);

            //
            // Create a semaphore of the mouse pointer
            // (only for the driver will handle cursor)
            //

            if ( (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_META)    ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_MIRROR) )
            {
                //
                // Mouse pointer accelerators.
                //

                ppdev->pfnDrvMovePointer     =
                     (PFN_DrvMovePointer) PPFNDRV(pdo,MovePointer);
                ppdev->pfnDrvSetPointerShape =
                     (PFN_DrvSetPointerShape) PPFNDRV(pdo,SetPointerShape);

                //
                // Init fmPointer
                //

                SEMOBJ so(ghsemDriverMgmt);

                TRACE_INIT(("PDEVOBJ::PDEVOBJ: Create pointer semaphore\n"));

                ppdev->hsemPointer = GreCreateSemaphore();
                if (!ppdev->hsemPointer)
                    goto ERROR_RETURN;

                //
                // Mark the PDEV as a display.
                //

                ppdev->fl |= PDEV_DISPLAY;
            }

            ppdev->pfnSetPalette = PPFNDRV(pdo, SetPalette);
            ppdev->pfnSync = PPFNDRV(pdo, Synchronize);
            ppdev->pfnSyncSurface = PPFNDRV(pdo, SynchronizeSurface);
            ppdev->pfnNotify = PPFNDRV(pdo, Notify);

            //
            // we now load font info only when needed.  The driver still must have
            // setup the default font information.
            //

            bGotFonts(FALSE);

            //
            // If any of the LOGFONTs in DEVINFO do not specify a height,
            // substitute the default.
            //

            LONG lHeightDefault = (DEFAULT_POINT_SIZE * ppdev->GdiInfo.ulLogPixelsY) / POINTS_PER_INCH ;
            ENUMLOGFONTEXDVW elfw;

            if ( ppdev->devinfo.lfDefaultFont.lfHeight == 0 )
                ppdev->devinfo.lfDefaultFont.lfHeight = lHeightDefault;

            if ( ppdev->devinfo.lfAnsiVarFont.lfHeight == 0 )
                ppdev->devinfo.lfAnsiVarFont.lfHeight = lHeightDefault;

            if ( ppdev->devinfo.lfAnsiFixFont.lfHeight == 0 )
                ppdev->devinfo.lfAnsiFixFont.lfHeight = lHeightDefault;

            //
            // Create LFONTs from the LOGFONTs in the DEVINFO.
            // the LOGFONTs should become EXTLOGFONTWs
            //

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfDefaultFont));

#ifdef FE_SB
            // We are doing away with the concept of default device fonts for display
            // drivers since it doesnt make sense.  Assuming this change gets approved
            // I will remove these before SUR ships.

            if ( ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY )
            {
                ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
            }
            else
#endif
            {
                if ((ppdev->hlfntDefault
                      = (HLFONT) hfontCreate(&elfw,
                                             LF_TYPE_DEVICE_DEFAULT,
                                             LF_FLAG_STOCK,
                                             NULL)) == HLFONT_INVALID)
                {
                    ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
                }
                else
                {
                    //
                    // Set to public.
                    //

                    if (!GreSetLFONTOwner(ppdev->hlfntDefault, OBJECT_OWNER_PUBLIC))
                    {
                        //
                        // If it failed, get rid of the LFONT and resort to System font.
                        //

                        bDeleteFont(ppdev->hlfntDefault, TRUE);
                        ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
                    }
                }
            }

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfAnsiVarFont));

            if ((ppdev->hlfntAnsiVariable
                   = (HLFONT) hfontCreate(&elfw,
                                          LF_TYPE_ANSI_VARIABLE,
                                          LF_FLAG_STOCK,
                                          NULL)) == HLFONT_INVALID)
            {
                ppdev->hlfntAnsiVariable = STOCKOBJ_SYSFONT;
            }
            else
            {
                //
                // Set to public.
                //

                if (!GreSetLFONTOwner(ppdev->hlfntAnsiVariable, OBJECT_OWNER_PUBLIC))
                {
                    //
                    // If it failed, get rid of the LFONT and resort to System font.
                    //

                    bDeleteFont(ppdev->hlfntAnsiVariable, TRUE);
                    ppdev->hlfntAnsiVariable = STOCKOBJ_SYSFONT;
                }
            }

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfAnsiFixFont));

            if ((ppdev->hlfntAnsiFixed
                  = (HLFONT) hfontCreate(&elfw,
                                         LF_TYPE_ANSI_FIXED,
                                         LF_FLAG_STOCK,
                                         NULL)) == HLFONT_INVALID)
            {
                ppdev->hlfntAnsiFixed = STOCKOBJ_SYSFIXEDFONT;
            }
            else
            {
                //
                // Set to public.
                //

                if (!GreSetLFONTOwner(ppdev->hlfntAnsiFixed, OBJECT_OWNER_PUBLIC))
                {
                    //
                    // If it failed, get rid of the LFONT and resort to System Fixed font.
                    //

                    bDeleteFont(ppdev->hlfntAnsiFixed, TRUE);
                    ppdev->hlfntAnsiFixed = STOCKOBJ_SYSFIXEDFONT;
                }
            }

#ifdef DRIVER_DEBUG
            LFONTOBJ    lfo1(ppdev->hlfntDefault);
            DbgPrint("GRE!PDEVOBJ(): Device default font\n");
            if (lfo1.bValid())
            {
                lfo1.vDump();
            }
            DbgPrint("GRE!PDEVOBJ(): Ansi variable font\n");
            LFONTOBJ    lfo2(ppdev->hlfntAnsiVariable);
            if (lfo2.bValid())
            {
                lfo2.vDump();
            }
            DbgPrint("GRE!PDEVOBJ(): Ansi fixed font\n");
            LFONTOBJ    lfo3(ppdev->hlfntAnsiFixed);
            if (lfo3.bValid())
            {
                lfo3.vDump();
            }
#endif
            //
            // (see bInitDefaultGuiFont() in stockfnt.cxx)
            //
            // If we haven't yet computed the adjusted height of the
            // DEFAULT_GUI_FONT stock object, do so now.  We couldn't do
            // this during normal stock font initialization because the
            // display driver had not yet been loaded.
            //

            if ( gbFinishDefGUIFontInit &&
                 (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) )
            {
                LFONTOBJ lfo(STOCKOBJ_DEFAULTGUIFONT);

                if (lfo.bValid())
                {
                    lfo.plfw()->lfHeight = -(LONG)((lfo.plfw()->lfHeight * ppdev->GdiInfo.ulLogPixelsY + 36) / 72);
                }

                gbFinishDefGUIFontInit = FALSE;
            }
        }

        //
        // Initialize the PDEV fields.
        //

        ppdev->cPdevRefs     = 1;
        ppdev->cPdevOpenRefs = 1;

        //
        // Before adding a display PDEV to the PDEV list, make sure it's
        // disabled.  We do this to protect against GreFlush walking the
        // PDEV list and calling the driver before we've even finished calling
        // DrvEnableSurface.  We mark the PDEV as enabled when all initialization 
        // is complete.
        //

        if (pdo.bDisplayPDEV())
        {
            pdo.bDisabled(TRUE);

            // Once the pdev has been disabled we can safely update
            // magic colors in an indexed palette.  DrvEnableMDEV will
            // update the palette when the display is reenabled.
            vResetSurfacePalette(hdev());
        }

        //
        // Just stick it at the start of the list.
        // Make sure this list is protected by the driver semaphore
        //

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        ppdev->ppdevNext = gppdevList;
        gppdevList = ppdev;

        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        TRACE_INIT(("PDEVOBJ::PDEVOBJ: list of display pdevs %08lx\n", gppdevList));

        //
        // NOTE after this point, the object will be "permanent" and will
        // end up being destroyed by the destructor
        //

#ifdef DDI_WATCHDOG

        //
        // !!! Hack - since watchdog creation requires access to DEVICE_OBJECT now
        // we have to delay watchdog creation till hCreateHDEV where PDEV gets associated
        // with DEVICE_OBJECT. It would be nice to have it here though.
        //

        ppdev->pWatchdogData = NULL;

#endif  // DDI_WATCHDOG

        //
        // Inform the driver that the PDEV is complete.
        //

        pdo.CompletePDEV(ppdev->dhpdev,hdev());

        //
        // We will return with success indicated by a non-NULL ppdev.
        //

        return;
    }
    else
    {
        WARNING("Device failed DrvEnablePDEV\n");
        goto ERROR_RETURN;
    }

ERROR_RETURN:

    if (ppdev->hsemDevLock)
    {
        GreDeleteSemaphore(ppdev->hsemDevLock);
    }

    if (ppdev->pDevHTInfo != NULL)
    {
        bDisableHalftone();
    }

#if defined(_WIN64)
    vDeleteWOW64HTPATSIZEUSERAllocations();
#endif

    if (!bUMPD)
    {
        VFREEMEM(ppdev);
    }
    else
    {
        EngFreeMem(ppdev);
    }

    ppdev = (PDEV *) NULL;
}

/******************************Member*Function*****************************\
* PDEVOBJ::cFonts()
*
* History:
*  3-Feb-1994 -by-  Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

ULONG PDEVOBJ::cFonts()
{
    ULONG_PTR id;

    //
    // see if the device already told us how many fonts it has
    //

    if (ppdev->devinfo.cFonts == (ULONG)-1)
    {
        PDEVOBJ pdo(hdev());

        //
        // if not query the device to see how many there are
        //

        if (PPFNDRV(pdo,QueryFont) != NULL)
        {
            ppdev->devinfo.cFonts = (ULONG)(ULONG_PTR)(*PPFNDRV(pdo,QueryFont))(dhpdev(),0,0,&id);
        }
        else
        {
            ppdev->devinfo.cFonts = 0;
        }
    }

    return(ppdev->devinfo.cFonts);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bGetDeviceFonts()
*
* History:
*  27-Jul-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL PDEVOBJ::bGetDeviceFonts()
{

    ASSERTGDI(!bGotFonts(),"PDEVOBJ::bGetDeviceFonts - already gotten\n");

    //
    // mark that we have gotten the fonts.
    //

    bGotFonts(TRUE);

    //
    // need an ldevobj for calling the device
    //

    PDEVOBJ pdo(hdev());

    //
    // compute the number of device fonts
    //

    cFonts();

    //
    // If there are any device fonts, load the device fonts into the public PFT table.
    //

    if (ppdev->devinfo.cFonts)
    {
        DEVICE_PFTOBJ pfto;      // get the device font table
        if (!pfto.bLoadFonts(this))
        {
            WARNING("PDEVOBJ(): couldn't load device fonts\n");
            ppdev->devinfo.cFonts = 0;
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* FilteredBitBlt()
*
* This call allows only simple PATCOPY blts down to the driver; the rest
* are handled by GDI.
*
\**************************************************************************/

BOOL FilteredBitBlt
(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc,
    POINTL   *pptlMsk,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
)
{
    PFN_DrvBitBlt pfnBitBlt = EngBitBlt;

    // Allow only solid color blts and SRCCOPY blts to be accelerated:

    if ((rop4 == 0xcccc) ||
        ((rop4 == 0xf0f0) && (pbo->iSolidColor != 0xffffffff)))
    {
        PDEVOBJ po(psoDst->hdev);
        pfnBitBlt = po.ppdev->pfnUnfilteredBitBlt;
    }

    return(pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc, 
                     pptlMsk, pbo, pptlBrush, rop4));
}

/******************************Public*Routine******************************\
* PDEVOBJ::vFilterDriverHooks()
*
* Disables driver functionality as appropriate.  This routine is used to
* disable buggy functionality in third-party drivers.
*
\**************************************************************************/

VOID PDEVOBJ::vFilterDriverHooks()
{
    SYSTEM_GDI_DRIVER_INFORMATION*  pGdiDriverInfo;
    LPWSTR                          pDriverName;
    ULONG                           ulDriverVersion;
    SURFACE*                        pSurface;
    DWORD                           dwLevel;
    DWORD                           dwOverride;

    pGdiDriverInfo = ppdev->pldev->pGdiDriverInfo;
    pSurface       = ppdev->pSurface;

    // Only do this for real drivers.

    if (pGdiDriverInfo == NULL) 
    {
        return;
    }

    ulDriverVersion = ppdev->pldev->ulDriverVersion;

    // Make 'pDriverName' point after the last backslash in the fully
    // qualified driver name:

    pDriverName = wcsrchr(pGdiDriverInfo->DriverName.Buffer, L'\\');

    if (pDriverName != NULL)
        pDriverName++;
    else
        pDriverName = pGdiDriverInfo->DriverName.Buffer;

    if (!_wcsicmp(pDriverName, L"stbv128.dll"))
    {
        // The STB nVidia driver started falling around build 1796.
        // It falls over in the driver on calls from DrawCaptionButtons/
        // BitBltSysBmp/NtGdiBitBlt.  It appears to have a problem when
        // compatible bitmaps are used while DirectDraw is enabled.  As
        // of build 1796, we changed DirectDraw so that it initializes
        // the driver a boot time instead of when the first DirectX
        // application is started.  This appears to have exposed a bug
        // in the driver with compatible bitmaps while DirectDraw is
        // enabled.
        // Note: The driver we tested where this problem occured is
        // STBV128.dll, version(ulDriverVersion) 131072
        // Note: we also tried to disable DrvEnableDirectDraw. But it seems
        // this is not the right fix. The crash occured as well.

        ppdev->apfn[INDEX_DrvCreateDeviceBitmap] = NULL;
    }
    else if (!_wcsicmp(pDriverName, L"s3disp.dll"))
    {
        // Bug#178375, NT4 driver s3disp crashes on SetPointShape().  It
        // sometimes scans past the end of the pointer buffer.

        ppdev->apfn[INDEX_DrvSetPointerShape] = NULL;
    }
    else if ((!_wcsicmp(pDriverName, L"rrctrl1.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl2.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl3.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl4.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl5.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl6.dll")))
    {
        // Bug#333453, Quarterdeck/Symantec Rapid Remote driver tries
        // to hook all functionality exported by real display driver,
        // but doesn't support the new NT5 functions.  Limit the driver
        // to >= level 2 accelerations (which also disables DFBs, so
        // we don't need to worry about them hooking unsupported functions
        // there as well).

        if (dwDriverAccelerationsLevel() < 2)
            vSetDriverAccelerationsLevel(2);
    }

    if (bDisplayPDEV())
    {
        dwLevel = dwDriverAccelerationsLevel();
        
        dwOverride = dwDriverCapableOverride();

        if ( dwOverride & DRIVER_NOT_CAPABLE_GDI )
        {
            // If the driver is not capable of GDI, then it is similar to
            // DRIVER_ACCELERATIONS_NONE. Reset the level we stored in PDEV

            dwLevel = DRIVER_ACCELERATIONS_NONE;

            vSetDriverAccelerationsLevel(dwLevel);
        }

        if (dwLevel < DRIVER_ACCELERATIONS_NONE)
        {
            if (dwLevel >= 1)
            {
                // Disable hardware pointers and device bitmaps:
    
                ppdev->apfn[INDEX_DrvSetPointerShape]    = NULL;
                ppdev->apfn[INDEX_DrvCreateDeviceBitmap] = NULL;
            }
            if (dwLevel >= 2)
            {
                // Disable the more sophisticated GDI drawing routines:
    
                pSurface->flags(pSurface->flags() & ~(HOOK_STRETCHBLT        |
                                                      HOOK_PLGBLT            |
                                                      HOOK_FILLPATH          |
                                                      HOOK_STROKEANDFILLPATH |
                                                      HOOK_LINETO            |
                                                      HOOK_STRETCHBLTROP     |
                                                      HOOK_TRANSPARENTBLT    |
                                                      HOOK_ALPHABLEND        |
                                                      HOOK_GRADIENTFILL));
            }
            if (dwLevel >= 3)
            {
                // Disable all DirectDraw and Direct3D accelerations:
                // 
                // Handle by DxDdSetAccelLeve().
            }
            if (dwLevel >= 4)
            {
                // The only GDI accelerations we allow here are the base-line
                // GDI accelerations: DrvTextOut, DrvBitBlt, DrvCopyBits, and
                // DrvStrokePath.
                //
                // NOTE: We also specifically allow DrvMovePointer and
                //       GCAPS_PANNING in case the driver is panning the
                //       display.  (It would be bad if the display doesn't
                //       pan when the user enables safe mode!)
    
                pSurface->flags(pSurface->flags() & (SURF_FLAGS       |
                                                     HOOK_COPYBITS    |
                                                     HOOK_BITBLT      |
                                                     HOOK_TEXTOUT     |
                                                     HOOK_SYNCHRONIZE |
                                                     HOOK_STROKEPATH));

                ppdev->devinfo.flGraphicsCaps &= (GCAPS_PALMANAGED   |
                                                  GCAPS_MONO_DITHER  |
                                                  GCAPS_COLOR_DITHER |
                                                  GCAPS_PANNING      |
                                                  GCAPS_LAYERED);
        
                ppdev->devinfo.flGraphicsCaps2 &= (GCAPS2_SYNCFLUSH |
                                                   GCAPS2_SYNCTIMER);
    
                ppdev->apfn[INDEX_DrvSaveScreenBits]      = NULL;
                ppdev->apfn[INDEX_DrvEscape]              = NULL;
                ppdev->apfn[INDEX_DrvDrawEscape]          = NULL;
                ppdev->apfn[INDEX_DrvResetPDEV]           = NULL;
                ppdev->apfn[INDEX_DrvSetPixelFormat]      = NULL;
                ppdev->apfn[INDEX_DrvDescribePixelFormat] = NULL;
                ppdev->apfn[INDEX_DrvSwapBuffers]         = NULL;

                // Use filtered Blt function.

                ppdev->pfnUnfilteredBitBlt 
                    = (PFN_DrvBitBlt) ppdev->apfn[INDEX_DrvBitBlt];
                ppdev->apfn[INDEX_DrvBitBlt] = (PFN) FilteredBitBlt;
            }

            if ( dwOverride & DRIVER_NOT_CAPABLE_OPENGL )
            {
                // Disable OpenGL routines here

                ppdev->apfn[INDEX_DrvSetPixelFormat]      = NULL;
                ppdev->apfn[INDEX_DrvDescribePixelFormat] = NULL;
                ppdev->apfn[INDEX_DrvSwapBuffers]         = NULL;
            }

            //
            // Disable all escapes.
            //

            if ( dwOverride & DRIVER_NOT_CAPABLE_ESCAPE )
            {
                ppdev->apfn[INDEX_DrvEscape]     = NULL;
                ppdev->apfn[INDEX_DrvDrawEscape] = NULL;
            }

            // Call DirectDraw to set accel level.

            DxDdSetAccelLevel(hdev(),dwLevel,dwOverride);
        }
        else
        {
            ASSERTGDI(dwLevel == 5,
                "No-accelerations flag should be modified to reflect change");

            // This case was handled by loading the panning driver.
        }
    }
}

/******************************Public*Routine******************************\
* PDEVOBJ::vProfileDriver()
*
* Profiles the driver to determine what accelerations it supports.
*
* Note that for the multi-mon PDEV, this returns the acceleration 
* capabilities of the primary monitor.
*
\**************************************************************************/

#define PROFILE_DIMENSION 40

VOID PDEVOBJ::vProfileDriver()
{
    DEVBITMAPINFO   dbmi;
    EBLENDOBJ       eBlendObj;
    CLIPOBJ         coClip;
    SURFACE*        psurfScreen;
    BRUSHOBJ        boTransparent;
    BOOL            b;
    HSURF           hsurf;
    RECTL           rclBlt;

    // We only profile display devices.  We could actually do this for
    // printer devices as well, but we would have to re-clear the surface
    // after we did our drawing to it.

    if (!bDisplayPDEV())
        return;

    DEVLOCKOBJ dlo(*this);

    psurfScreen = pSurface();

    XEPALOBJ palScreen(ppalSurf());
    XEPALOBJ palRGB(gppalRGB);
    XEPALOBJ palDefault(ppalDefault);

    // We create the surface fairly big to try and get past drivers that
    // create device surfaces only for 'large' bitmaps.  To test the 
    // driver, we only have to blt a thin strip, though.

    rclBlt.left   = 0;
    rclBlt.top    = 0;
    rclBlt.right  = 16;
    rclBlt.bottom = 1;

    // Fake up a trivial clip object:

    RtlZeroMemory(&coClip, sizeof(coClip));
    coClip.iDComplexity = DC_TRIVIAL;
    coClip.rclBounds    = rclBlt;

    // Ignore any random stuff the driver might have set.  We're going
    // to verify for ourselves what they support!

    GdiInfo()->flShadeBlend = 0;

    // Check whatever we can using a 32bpp surface:

    {
        SURFMEM     SurfDimo;
        EXLATEOBJ   xlo32To32;
        EXLATEOBJ   xloScreenTo32;
        EXLATEOBJ   xlo32ToScreen;

        // Test for per-pixel alpha acceleration.
    
        dbmi.iFormat  = BMF_32BPP;
        dbmi.hpal     = palRGB.hpal();
        dbmi.cxBitmap = PROFILE_DIMENSION;
        dbmi.cyBitmap = PROFILE_DIMENSION;
        dbmi.fl       = BMF_TOPDOWN;
    
        if (SurfDimo.bCreateDIB(&dbmi, NULL))
        {
            if ((xlo32To32.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palRGB,
                                         palDefault, palDefault, 0, 0, 0)) &&
                (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                             palDefault, palDefault, 0, 0, 0)) &&
                (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                             palDefault, palDefault, 0, 0, 0)))
            {
                eBlendObj.BlendFunction.BlendOp             = AC_SRC_OVER;
                eBlendObj.BlendFunction.BlendFlags          = 0;
                eBlendObj.BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
                eBlendObj.BlendFunction.SourceConstantAlpha = 0xff;
                eBlendObj.pxloSrcTo32                       = xlo32To32.pxlo();
                eBlendObj.pxloDstTo32                       = xloScreenTo32.pxlo();
                eBlendObj.pxlo32ToDst                       = xlo32ToScreen.pxlo();

                vDriverPuntedCall(FALSE);

                b = PPFNGET(*this, AlphaBlend, psurfScreen->flags())
                              (psurfScreen->pSurfobj(),
                               SurfDimo.ps->pSurfobj(),
                               &coClip,
                               xlo32ToScreen.pxlo(),
                               &rclBlt,
                               &rclBlt,
                               &eBlendObj);

                if ((b) && (!bDriverPuntedCall()))
                {
                    // WARNING("----- Per-pixel accelerated\n");
                    GdiInfo()->flShadeBlend |= SB_PIXEL_ALPHA;
                    vAccelerated(ACCELERATED_PIXEL_ALPHA);
                }
            }
        }

        // Note that since we didn't apply 'vKeepIt()', the SURFMEM and 
        // EXLATEOBJ destructors will clean up.
    }

    // Check whatever we can using a compatible surface:

    hsurf = hsurfCreateCompatibleSurface(hdev(), 
                                         psurfScreen->iFormat(),
                                         0,
                                         PROFILE_DIMENSION,
                                         PROFILE_DIMENSION,
                                         TRUE);
    if (hsurf)
    {
        SURFREF sr(hsurf);
        ASSERTGDI(sr.bValid(), "Driver returned invalid surface");

        EXLATEOBJ   xloScreenToScreen;
        EXLATEOBJ   xloScreenTo32;
        EXLATEOBJ   xlo32ToScreen;

        if ((xloScreenToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palScreen,
                                             palDefault, palDefault, 0, 0, 0)) &&
            (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                         palDefault, palDefault, 0, 0, 0)) &&
            (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                         palDefault, palDefault, 0, 0, 0)))
        {
            // Test for constant-alpha acceleration.
    
            eBlendObj.BlendFunction.BlendOp             = AC_SRC_OVER;
            eBlendObj.BlendFunction.BlendFlags          = 0;
            eBlendObj.BlendFunction.AlphaFormat         = 0;
            eBlendObj.BlendFunction.SourceConstantAlpha = 0x85;
            eBlendObj.pxloSrcTo32                       = xloScreenTo32.pxlo();
            eBlendObj.pxloDstTo32                       = xloScreenTo32.pxlo();
            eBlendObj.pxlo32ToDst                       = xlo32ToScreen.pxlo();
    
            vDriverPuntedCall(FALSE);
    
            b = PPFNGET(*this, AlphaBlend, psurfScreen->flags())
                            (psurfScreen->pSurfobj(),
                             sr.ps->pSurfobj(),
                             &coClip,
                             xloScreenToScreen.pxlo(),
                             &rclBlt,
                             &rclBlt,
                             &eBlendObj);
    
            if ((b) && (!bDriverPuntedCall()))
            {
                // WARNING("----- Constant alpha accelerated\n");
                GdiInfo()->flShadeBlend |= SB_CONST_ALPHA;
                vAccelerated(ACCELERATED_CONSTANT_ALPHA);
            }
        }

        // Test for transparent blt acceleration.

        boTransparent.iSolidColor = 1;
        boTransparent.flColorType = 0;

        vDriverPuntedCall(FALSE);

        b = PPFNGET(*this, TransparentBlt, psurfScreen->flags())
                        (psurfScreen->pSurfobj(),
                         sr.ps->pSurfobj(),
                         NULL,
                         NULL,
                         &rclBlt,
                         &rclBlt,
                         1,
                         NULL);

        if ((b) && (!bDriverPuntedCall()))
        {
            // WARNING("----- Transparent blt accelerated\n");
            vAccelerated(ACCELERATED_TRANSPARENT_BLT);
        }
    }

    // Cleanup.

    bDeleteSurface(hsurf);
}

/******************************Public*Routine******************************\
* PDEVOBJ::vDisableSurface()
*
* Disables the surface for the pdev.
*
* Parameters:
*
*   cutype      The CLEANUPTYPE parameter (default value CLEANUP_NONE)
*               is used specify special processing during process cleanup
*               and session cleanup.
*
*               It may be one of the following values:
*
*       Value:              Description
*
*       CLEANUP_NONE        Default.  No special processing.
*
*       CLEANUP_PROCESS     The process cleanup code is used to do
*                           special handling of UMPD; during process
*                           cleanup it is not necessary or desirable
*                           to callback to user-mode to delete
*                           user-mode resources.
*
*       CLEANUP_SESSION     The session cleanup (i.e., hydra shutdown)
*                           code does special handling of HMGR
*                           objects deleted previously by session
*                           cleanup code, but for which stale pointer
*                           may exist in the PDEV.
*
\**************************************************************************/

VOID PDEVOBJ::vDisableSurface(CLEANUPTYPE cutype)
{
    TRACE_INIT(("PDEVOBJ::vDisableSurface: ENTERING\n"));

    //
    // Locate the LDEV.
    //

    PDEVOBJ pdo(hdev());

    //
    // Disable the surface.  Note we don't have to
    // fix up the palette because it doesn't get
    // reference counted when put in the palette.
    //

    //
    // On clone PDEV, those stuff never be enabled.
    // 

    if (!bCloneDriver())
    {
        vDisableSynchronize(hdev());
    }

    vSpDisableSprites(hdev(), cutype);

    //
    // Notify DirectDraw to be disabled.
    //

    DxDdDisableDirectDraw(hdev(),!bCloneDriver());

    if (ppdev->pSurface != NULL)
    {
        SURFREF su(ppdev->pSurface);

        ppdev->pSurface = NULL;

        //
        // Cannot call user-mode driver to delete surface if the user-mode
        // process is gone (i.e., during process or session cleanup).
        //

        if (!pdo.bUMPD() || (cutype == CLEANUP_NONE))
        {
            su.vUnreference();

            (*PPFNDRV(pdo,DisableSurface))(ppdev->dhpdev);
        }
        else
        {
            //
            // If we are here, then this is process or session cleanup
            // and the PDEV is a user-mode driver.  Even though the user-mode
            // portions of the surface are cleaned up as part of the user-mode
            // cleanup, we still need to delete the kernel-mode portion of the
            // surface.
            //

            su.bDeleteSurface(cutype);
        }
    }

    TRACE_INIT(("PDEVOBJ::vDisableSurface: LEAVING\n"));
}

/******************************Member*Function*****************************\
* PDEVOBJ::vReferencePdev()
*
* Adds a reference to the PDEV.
*
\**************************************************************************/

VOID PDEVOBJ::vReferencePdev()
{
    GDIFunctionID(PDEVOBJ::vReferencePdev);

    SEMOBJ so(ghsemDriverMgmt);

    ppdev->cPdevRefs++;
}

extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *);

/***************************************************************************\
*
* VOID vMarkSurfacesWithHDEV.
*
*     Sets hdev of all surfaces in Handle table which reference the PDEV passed
*     in to 0.
*
\***************************************************************************/

VOID vMarkSurfacesWithHDEV(PDEV *ppdev)
{
    SURFACE *pSurface = NULL;
    HOBJ hobj = 0;

    MLOCKFAST mlo;   // Take HandleManager lock so HmgSafeNextObjt can be called

    while (pSurface = (SURFACE*)HmgSafeNextObjt(hobj,SURF_TYPE))
    {
        hobj = (HOBJ) pSurface->hGet();

        if (pSurface->hdev() == (HDEV)ppdev)
        {
            KdPrint(("WARNING: Surface (%p) is owned by HDEV (%p). This HDEV is going to be freed\n", pSurface, ppdev));
            pSurface->hdev((HDEV)0);
        }
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vUnreferencePdev()
*
* Removes a reference to the PDEV.  Deletes the PDEV if all references are
* gone.
*
* Parameters:
*
*   cutype      The CLEANUPTYPE parameter (default value CLEANUP_NONE)
*               is used specify special processing during process cleanup
*               and session cleanup.
*
*               It may be one of the following values:
*
*       Value:              Description
*
*       CLEANUP_NONE        Default.  No special processing.
*
*       CLEANUP_PROCESS     The process cleanup code is used to do
*                           special handling of UMPD; during process
*                           cleanup it is not necessary or desirable
*                           to callback to user-mode to delete
*                           user-mode resources.
*
*       CLEANUP_SESSION     The session cleanup (i.e., hydra
*                           shutdown) code does special handling of
*                           HMGR objects deleted previously by session
*                           cleanup code, but for which stale pointer
*                           may exist in the PDEV (for example, palettes).
*
* Note: special session cleanup handling is usually only needed for HMGR
* objects for which the PDEV has cached a pointer.  Objects referenced
* via a handle are safe if they are locked via the HMGR table (if the
* object has already been deleted, then the handle is invalid and the
* lock attempt will fail).
*
\**************************************************************************/

VOID PDEVOBJ::vUnreferencePdev(CLEANUPTYPE cutype)
{
    GDIFunctionID(PDEVOBJ::vUnreferencePdev);

    HANDLE hSpooler = NULL;
    ULONG  cPdevRefs;
    BOOL   bUMPD = ppdev->fl  & PDEV_UMPD;

    //
    // Decrement reference count and remove from list if last reference.
    // This must be done under the protection of the driver mgmt semaphore.
    //

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    cPdevRefs = --(ppdev->cPdevRefs);

    if (cPdevRefs == 0)
    {
        TRACE_INIT(("PDEVOBJ::vCommonDelete: destroying a PDEV\n"));

        //
        // Delete it from the list.
        //

        if (gppdevList == ppdev)
        {
            gppdevList = ppdev->ppdevNext;
        }
        else
        {
            PDEV *pp;

            for (pp = gppdevList; pp != NULL; pp = pp->ppdevNext)
            {
                if (pp->ppdevNext == ppdev)
                {
                    pp->ppdevNext = ppdev->ppdevNext;
                    break;
                }
            }
        }

    #if DBG

        //
        // If this is DDML driver, make sure one other PDEV referecnes
        // this PDEV as parent.
        //

        if (bMetaDriver())
        {
            PDEV *pp;

            for (pp = gppdevList; pp != NULL; pp = pp->ppdevNext)
            {
                if (pp->ppdevParent == ppdev)
                {
                    WARNING("Deleting parent PDEV which still used\n");
                }
            }
        }

    #endif
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    //
    // If last reference, delete the PDEV and its resources.  We do this
    // outside of the driver mgmt semaphore because it could cause a
    // deadlock if we need to call back to user-mode (i.e., UMPD).
    //

    if (cPdevRefs == 0)
    {
        //
        // Since we are going to delete this PDEV, there shouldn't be any
        // active RFONTs lying around for this PDEV.
        //

        ASSERTGDI(ppdev->prfntActive == NULL,
            "active rfonts on pdev being deleted!\n");

        //
        // Ordinarily, we would grab the ghsemRFONTList semaphore because
        // we are going to access the RFONT list.  However, since we're in
        // the process of tearing down the PDEV, we don't really need to.
        //

        //
        // Delete all the rfonts on the PDEV.
        //

        PRFONT prfnt;
        while ( (prfnt = ppdev->prfntInactive) != (PRFONT) NULL )
        {
            RFONTTMPOBJ rflo(prfnt);
            PFFOBJ pffo(rflo.pPFF());

            ASSERTGDI (
                pffo.bValid(),
                "bad HPFF"
                );

            rflo.bDeleteRFONT(this, &pffo);  // bDelete keeps the list head ptrs updated
        }

        //
        // If device fonts exist, remove them
        //

        if ((ppdev->devinfo.cFonts != 0) && bGotFonts())
        {
            PFF *pPFF = 0;
            PFF **ppPFF;

            GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

            DEVICE_PFTOBJ pfto;
            pPFF = pfto.pPFFGet(hdev(), &ppPFF);

            if (!pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, 0))
            {
                WARNING("couldn't unload device fonts\n");
            }
        }

        //
        // If a type one font list exists dereference it
        //

        if(ppdev->TypeOneInfo)
        {
            PTYPEONEINFO FreeTypeOneInfo;

            FreeTypeOneInfo = NULL;

            GreAcquireFastMutex(ghfmMemory);
            ppdev->TypeOneInfo->cRef -= 1;

            if(!ppdev->TypeOneInfo->cRef)
            {
                //
                // Don't free pool while holding a mutex.
                //

                FreeTypeOneInfo = ppdev->TypeOneInfo;
            }

            GreReleaseFastMutex(ghfmMemory);

            if (FreeTypeOneInfo)
            {
                VFREEMEM(FreeTypeOneInfo);
            }
        }

        //
        // If any remote type one fonts exist free those
        //

        PREMOTETYPEONENODE RemoteTypeOne = ppdev->RemoteTypeOne;

        while(RemoteTypeOne)
        {
            PVOID Tmp = (PVOID) RemoteTypeOne;

            //
            // ulRegionSize and hSpoolerSecure will be stored in the PFM fileview
            //

            RemoteTypeOne->fvPFM.cRefCountFD = 1;
            vUnmapRemoteFonts(&RemoteTypeOne->fvPFM);
            RemoteTypeOne = RemoteTypeOne->pNext;
            VFREEMEM(Tmp);

            WARNING1("Freeing Type1\n");
        }

        //
        // Delete GammaRamp table, if allocated.
        //

        if (ppdev->fl & PDEV_GAMMARAMP_TABLE)
        {
            VFREEMEM(ppdev->pvGammaRampTable);
        }

        if (ppdev->ppdevDevmode)
        {
            VFREEMEM(ppdev->ppdevDevmode);
        }

        if (!bCloneDriver())
        {
            //
            // Destroy the LFONTs.
            //

            if (ppdev->hlfntDefault != STOCKOBJ_SYSFONT)
                bDeleteFont(ppdev->hlfntDefault, TRUE);

            if (ppdev->hlfntAnsiVariable != STOCKOBJ_SYSFONT)
                bDeleteFont(ppdev->hlfntAnsiVariable, TRUE);

            if (ppdev->hlfntAnsiFixed != STOCKOBJ_SYSFIXEDFONT)
                bDeleteFont(ppdev->hlfntAnsiFixed, TRUE);

            //
            // Delete the patterns if they are created by the graphics engine on the
            // behalf of the driver.
            // This is what happends for all display drivers.
            //

            if (ppdev->fl & PDEV_DISPLAY)
            {
                for (int iPat = 0; iPat < HS_DDI_MAX; iPat++)
                {
                    bDeleteSurface(ppdev->ahsurf[iPat]);
                }
            }
        }

        //
        // Disable the surface for the pdev.
        //

        vDisableSurface(cutype);

        //
        // Destroy the device halftone info.
        //

        if (ppdev->pDevHTInfo != NULL)
        {
            bDisableHalftone();
        }

#if defined(_WIN64)
        vDeleteWOW64HTPATSIZEUSERAllocations();
#endif
        //
        // Nuke the realized gray pattern brush (used to draw the
        // drag rectangles).  Normally, the EBRUSHOBJ destructor
        // will decrement the realized brush ref counts.  However,
        // the EBRUSHOBJ cached in the PDEV is allocated as part
        // of the PDEV so never invokes a destructor.  Therefore,
        // we need to force the realized brushes out explicitly.
        //

        pbo()->vNuke();

        if (!bCloneDriver())
        {
            //
            // Unreference the palette we used for this PDEV.
            //
            // If session cleanup (i.e., Hydra) the palettes are already
            // deleted; therefore, should skip.
            //

            if (cutype != CLEANUP_SESSION)
            {
                if (ppdev->ppalSurf)
                {
                    DEC_SHARE_REF_CNT(ppdev->ppalSurf);
                }
            }

            //
            // Disable the driver's PDEV.
            //
            // We do this odd check to ensure that the driver's DrvDisablePDEV
            // address isn't the same as its DrvEnablePDEV address because an
            // early beta NetMeeting driver had a bug where its table entries
            // for INDEX_DrvEnablePDEV and INDEX_DrvDisablePDEV were the same
            // (this was in SP3 before we enabled dynamic mode changes for
            // DDML drivers).  We made a change recently (this is still before
            // SP3 has shipped, which enabled the DDML) so that we refuse to
            // load DDML drivers that don't have GCAPS_LAYERRED set -- but we
            // have to load the driver first before we can check GCAPS_LAYERED.
            // So if it doesn't have GCAPS_LAYERED set, we have to unload the
            // driver -- but this old NetMeeting driver had a bad DisablePDEV
            // routine!
            //
            // At any rate, to work around the problem where someone has the
            // beta version of the NetMeeting driver installed (which shipped
            // with the IE4 beta and has the DisablePDEV bug) and then upgrades
            // to retail SP3, we simply don't call the driver's bad DisablePDEV
            // routine.  The driver will likely leak memory, but this happens
            // only once per boot and is better than a blue screen.
            //

            if (PPFNDRV((*this),DisablePDEV) != (PFN_DrvDisablePDEV)
                PPFNDRV((*this),EnablePDEV))
            {
                //
                // If the user mode process is gone (i.e, during session
                // or process cleanup), don't callout to user mode.
                //

                if (!bUMPD || (cutype == CLEANUP_NONE))
                    (*PPFNDRV((*this),DisablePDEV))(ppdev->dhpdev);
            }

            //
            // Remove the LDEV reference.
            //
            if (!bUMPD)
                 ldevUnloadImage(ppdev->pldev);
            else
                 UMPD_ldevUnloadImage(ppdev->pldev);

            // If this PDEV referenced an enabled physical device
            // then release its usage for this session.
            if (!bDisabled() && ppdev->pGraphicsDevice != NULL)
            {
                bSetDeviceSessionUsage(ppdev->pGraphicsDevice, FALSE);
            }
        }

        TRACE_INIT(("PDEVOBJ::vCommonDelete: Closing Device handle.\n"));

        if (ppdev->fl & PDEV_PRINTER)
        {
            //
            //  note the spool handle so we can close connection outside
            //  of the spooler management semaphore
            //

            hSpooler = ppdev->hSpooler;
        }

#ifdef DDI_WATCHDOG

        //
        // Stop and free all watchdogs.
        //

        GreDeleteWatchdogs(ppdev->pWatchdogData, WD_NUMBER);
        ppdev->pWatchdogData = NULL;

#endif  // DDI_WATCHDOG

        //
        // Free the locks as one of the last steps, in case any of the
        // above decides to try and acquire the locks.
        //

        //
        // If hsemDevLock points "shared devlock", don't delete it.
        //
        if (!(ppdev->fl & PDEV_SHARED_DEVLOCK))
        {
            if (ppdev->hsemDevLock)
            {
                GreDeleteSemaphore(ppdev->hsemDevLock);
            }
        }

        if (ppdev->fl & PDEV_DISPLAY)
        {
            GreDeleteSemaphore(ppdev->hsemPointer);
        }

        // See if there are any surfaces in the handle table still referencing
        // this PDEV. If so mark them such that the bDeleteSurface call will
        // not touch anything which refers the PDEV.

        vMarkSurfacesWithHDEV(ppdev);

        //
        // Free the PDEV.
        //

        if (!bUMPD)
        {
            VFREEMEM(ppdev);
        }
        else
        {
            EngFreeMem(ppdev);
        }

        ppdev = (PDEV *) NULL;
    }
    
    //
    // this needs to be done outside of the driver management semaphore
    //

    if (!bUMPD && hSpooler)
    {
        ClosePrinter(hSpooler);
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vSync()
*
* If the surface hooks synchronization then call the hook.  Note, if
* provided we will call DrvSynchronizeSurface otherwise we will call
* DrvSynchronize.
*
\**************************************************************************/

VOID PDEVOBJ::vSync(
    SURFOBJ*    pso,
    RECTL*      prcl,
    FLONG       fl)
{
    PSURFACE pSurf  = SURFOBJ_TO_SURFACE(pso);

    if(pSurf->flags() & HOOK_SYNCHRONIZE)
    {
        if (!bDisabled())
        {
            FREASSERTGDI(ppdev->pfnSyncSurface || ppdev->pfnSync,
                         "Surface has HOOK_SYNCHRONIZE flags, but both ppdev->pfnSyncSurface and ppdev->pfnSync are NULL\n");
            if(ppdev->pfnSyncSurface != NULL)
                (ppdev->pfnSyncSurface)(pso, prcl, fl);
            else
                (ppdev->pfnSync)(pso->dhpdev, prcl);
        }
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vNotify()
*
* If the driver supplies DrvNotify, then call it.
*
\**************************************************************************/

VOID PDEVOBJ::vNotify(
    ULONG   iType,
    PVOID   pvData)
{
    if(ppdev->pfnNotify != NULL)
    {
        (ppdev->pfnNotify)(ppdev->pSurface->pSurfobj(), iType, pvData);
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::bDisabled()
*
* Marks a PDEV as enabled or disabled, and modifies all updates the
* cached state in all affected DCs.
*
* NOTE: This assumes the DEVLOCK is held.
*
\**************************************************************************/

BOOL PDEVOBJ::bDisabled
(
    BOOL bDisable
)
{
    HDEV    hdev;
    HOBJ    hobj;
    DC     *pdc;

    ASSERTGDI(bDisplayPDEV(), "Expected only display devices");

    SETFLAG(bDisable, ppdev->fl, PDEV_DISABLED);

    hdev = (HDEV) ppdev;

    //
    // We have to hold the handle manager lock while we traverse all
    // the handle manager objects.
    //

    MLOCKFAST mo;

    hobj = 0;
    while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
    {
        hobj = (HOBJ) pdc->hGet();

        if ((pdc->dctp() == DCTYPE_DIRECT) &&
            (pdc->hdev() == hdev))
        {
            pdc->bInFullScreen(bDisable);
        }
    }

    return(ppdev->fl & PDEV_DISABLED);
}

#if DBG

/******************************Member*Function*****************************\
* PDEVOBJ::AssertDevLock()
*
*   This routine verifies that the DevLock is held.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertDevLock()
{

#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                       ||
              GreIsSemaphoreOwnedByCurrentThread(hsemDevLock()),
              "PDEVOBJ: Devlock not held");

#endif

}

/******************************Member*Function*****************************\
* PDEVOBJ::AssertNoDevLock()
*
*   This routine verifies that the DevLock is not held.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertNoDevLock()
{
#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                       ||
              !GreIsSemaphoreOwnedByCurrentThread(hsemDevLock()),
              "PDEVOBJ: Devlock held");

#endif
}

/******************************Member*Function*****************************\
* PDEVOBJ::AssertDynaLock()
*
*   This routine verifies that appropriate locks are held before accessing
*   DC fields that may otherwise be changed asynchronously by the dynamic
*   mode-change code.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertDynaLock()
{
    //
    // One of the following conditions is enough to allow the thread
    // to safely access fields that may be modified by the dyanmic
    // mode changing:
    //
    // 1.  It's a non-display device -- this will not change modes;
    // 2.  That the USER semaphore is held;
    // 3.  That the DEVLOCK is held for this object;
    // 4.  That the DEVLOCK is held for this object's parent;
    // 5.  That the Palette semaphore is held;
    // 6.  That the Handle Manager semaphore is held;
    // 7.  That the Pointer semaphore is held;
    // 8.  That the driver management semaphore is held;
    // 9.  That the parent's pointer Semaphore is held.
    // 10. The pdev is being torn down (i.e., cPdevRefs == 0).
    //

#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                         ||
              (ppdev->cPdevRefs == 0)                                 ||
              UserIsUserCritSecIn()                                   ||
               GreIsSemaphoreOwnedByCurrentThread(hsemDevLock())      ||
               GreIsSemaphoreOwnedByCurrentThread(
                                  ppdev->ppdevParent->hsemDevLock)    ||
               GreIsSemaphoreSharedByCurrentThread(ghsemShareDevLock) ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemPalette)       ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemHmgr)          ||
               GreIsSemaphoreOwnedByCurrentThread(hsemPointer())      ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemDriverMgmt)    ||
              ((ppdev->ppdevParent != NULL) &&
                GreIsSemaphoreOwnedByCurrentThread(ppdev->ppdevParent->hsemPointer)),
              "PDEVOBJ: A dynamic mode change lock must be held to access this field");

#endif

}

/******************************Member*Function*****************************\
* PDEVOBJ::ppfn()
*
*   This routine verifies that appropriate locks are held before accessing
*   the dispatch table for a PDEV for function pointers that could otherwise
*   be changed asynchronously by a dynamic mode change.
*
\**************************************************************************/

PFN PDEVOBJ::ppfn(ULONG i)
{
    //
    // Font producers and some types of font consumers are not allowed to
    // do dynamic mode changes.  As such, accessing the dispatch table
    // entries specific to those types of drivers does not have to occur
    // under a lock.
    //
    // Note that if this list is expanded, it should also be changed in
    // 'bMatchEnoughForDynamicModeChange':
    //

    if ((i != INDEX_DrvQueryFontCaps) &&
        (i != INDEX_DrvLoadFontFile) &&
        (i != INDEX_DrvQueryFontFile) &&
        (i != INDEX_DrvGetGlyphMode))
    {
        vAssertDynaLock();
    }

    return(ppdev->apfn[i]);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pffobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pffobj.cxx
*
* Non-inline methods for physical font file objects.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PW32PROCESS gpidSpool;

// Define the global PFT semaphore.  This must be held to access any of the
// physical font information.

#if DBG
extern FLONG gflFontDebug;
#endif

extern "C" void FreeFileView(PFONTFILEVIEW *ppfv, ULONG cFiles);
extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);

ULONG ComputeFileviewCheckSum(PVOID pvView, ULONG cjView)
{
    ULONG sum;
    PULONG pulCur,pulEnd;

    pulCur = (PULONG) pvView;

    __try
    {
        for (sum = 0, pulEnd = pulCur + cjView / sizeof(ULONG); pulCur < pulEnd; pulCur += 1)
        {
            sum += 256 * sum + *pulCur;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("win32k: exception while computing font check sum\n");
        sum = 0; // oh well, not very unique.
    }

    return ( sum < 2 ) ? 2 : sum;  // 0 is reserved for device fonts
                                      // 1 is reserved for TYPE1 fonts
}

PFFMEMOBJ::PFFMEMOBJ(
    PFF     *pPFFCloned,
    FLONG   fl,             // indicates if a permanent font
    FLONG   flEmbed,         // embedding flag
    PFT     *pPFTParent      // contains this pff
)
{
    if ( pPFF = (PFF *) PALLOCMEM((size_t)pPFFCloned->sizeofThis, 'ffpG'))
    {
        RtlCopyMemory((PBYTE) pPFF, (PBYTE) pPFFCloned, offsetof(PFF,aulData));

        pPFF->pPFFPrev      = 0;
        pPFF->pPFFNext      = 0;

    // Wet the implicit stuff.

        pPFF->cFonts        = 0;       // faces not loaded into table yet
        pPFF->cRFONT        = 0;       // nothing realized from this file yet
        pPFF->flState       = fl;
        pPFF->pfhFace       = 0;
        pPFF->pfhFamily     = 0;
        pPFF->pfhUFI        = 0;
        pPFF->prfntList     = 0;       // initialize to NULL list
        pPFF->pPFT          = pPFTParent;

        pPFF->pPvtDataHead  = NULL;    // initialize to NULL link list

    // loaded with FR_PRIVATE, FR_PRIVATE | FR_NOT_ENUM, FRW_EMB_PID, FRW_EMB_TID
    // the load count (cPirvate or cNotEnum) is initialized in PvtData structure per process

        if (flEmbed & (FR_PRIVATE | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 0;
            bAddPvtData(flEmbed);
        }

    // file is loaded as NOT_ENUM only

        else if ( flEmbed & FR_NOT_ENUM )
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 1;
        }

    // file is loaded as public

        else
        {
            pPFF->cLoaded   = 1;
            pPFF->cNotEnum  = 0;
        }

    // Mark this PFF as cloned
        pPFFCloned->pPFFClone = pPFF;
        pPFF->pPFFClone = pPFFCloned;

    }
    else
    {
        WARNING("invalid PFFMEMOBJ\n");
    }
}

/******************************Public*Routine******************************\
* PFFMEMOBJ::PFFMEMOBJ
*
* Constructor for default sized physical font file memory object.
*
* cFonts = # fonts in file or device
* pwsz   = pointer to upper case Unicode string containing the full
*          path to the font file. This pointer is set to zero, by
*          default for fonts loaded from a device.
*
* History:
*  Thu 01-Sep-1994 06:29:47 by Kirk Olynyk [kirko]
* Put the size calculation logic in the constructor thereby modularizing
* and shrinking the code.
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Remove from handle manager
*  02-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFFMEMOBJ::PFFMEMOBJ(
    unsigned cFonts          // number of fonts in file|device
  , PWSZ     pwsz            // if font file this is an upper case path
  , ULONG    cwc             // number of characters in the mul path above
  , ULONG    cFiles          // number of files
  , DESIGNVECTOR *pdv        // design vector, only present for mm instances
  , ULONG         cjDV       // size of design vector
  , HFF      hffFontFile     // IFI driver's handle to file
  , HDEV     hdevDevice      // physical device handle
  , DHPDEV   dhpdevDevice    // driver's pdev handle
  , PFT     *pPFTParent      // contains this pff
  , FLONG    fl              // indicates if a permanent font
  , FLONG    flEmbed         // embedding flag
  , PFNTCHECKSUM    pFntCheckSum
  , PFONTFILEVIEW   *ppfv      // ptr to FILEVIEW structure
  , PUNIVERSAL_FONT_ID  pufi // ptr to original UFI used in remote printing
  )
{
    ULONG size = offsetof(PFF,aulData) + cFonts * sizeof(PFE*);
    ULONG dpDV = 0;
    ULONG dpPathName = 0;

    ASSERTGDI(hdevDevice, "PFFMEMOBJ passed NULL hdevDevice\n");
    ASSERTGDI(pFntCheckSum, "pFntCheckSum is NULL\n");

    fs = 0;

    if (pwsz)
    {
        dpPathName = size;
        size += ALIGN4(cwc*sizeof(WCHAR));
    }

    if (cjDV)
    {
        dpDV = size;
        size += cjDV;
    }

    if (pPFF = (PFF *) PALLOCMEM(size, 'ffpG'))
    {
        pPFF->sizeofThis    = size;
        pPFF->pPFFPrev      = 0;
        pPFF->pPFFNext      = 0;
        pPFF->hff           = hffFontFile;
        pPFF->hdev          = hdevDevice;
        pPFF->dhpdev        = dhpdevDevice;
        pPFF->pPFT          = pPFTParent;
        pPFF->cFiles        = cFiles;

        pPFF->cwc           = cwc;
        if (cwc)
        {
            pPFF->pwszPathname_ = (PWSZ)((BYTE *)pPFF + dpPathName);
            RtlCopyMemory(pPFF->pwszPathname_, pwsz, cwc * sizeof(WCHAR));
        }
        else
        {
            pPFF->pwszPathname_ = 0;
        }

        pPFF->cjDV_ = cjDV;
        if (cjDV)
        {
            pPFF->pdv_ = (DESIGNVECTOR *)((BYTE *)pPFF + dpDV);
            RtlCopyMemory(pPFF->pdv_, pdv, cjDV);
        }
        else
        {
            pPFF->pdv_ = NULL;
        }

        pPFF->ppfv          = ppfv;

    // Wet the implicit stuff.

        pPFF->cFonts        = 0;       // faces not loaded into table yet
        pPFF->cRFONT        = 0;       // nothing realized from this file yet
        pPFF->flState       = fl;
        pPFF->pfhFace       = 0;
        pPFF->pfhFamily     = 0;
        pPFF->pfhUFI        = 0;
        pPFF->prfntList     = 0;       // initialize to NULL list

        pPFF->pPvtDataHead  = NULL;    // initialize to NULL link list

    // loaded with FR_PRIVATE, FR_PRIVATE | FR_NOT_ENUM, FRW_EMB_PID, FRW_EMB_TID
    // the load count (cPirvate or cNotEnum) is initialized in PvtData structure per process

        if (flEmbed & (FR_PRIVATE | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 0;
            bAddPvtData(flEmbed);
        }

    // file is loaded as NOT_ENUM only

        else if ( flEmbed & FR_NOT_ENUM )
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 1;
        }

    // file is loaded as public

        else
        {
            pPFF->cLoaded   = 1;
            pPFF->cNotEnum  = 0;
        }

    // Mark this PFF as not cloned

        pPFF->pPFFClone = NULL;

        pPFF->ulCheckSum = 0; // for device fonts it is zero

        if(pufi != NULL)
        {
            pPFF->ulCheckSum = pufi->CheckSum;
        }
        else
        {
            if (ppfv != NULL)
            {

                pPFF->ulCheckSum = pFntCheckSum->ulCheckSum;


                if (!pPFF->ulCheckSum)
                {
                // not in the boot, or could not find it in the ttfcache for some reason
                // Now compute the UFI

                    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
                    for (ULONG iFile = 0; iFile < cFiles; iFile ++)
                    {
                        pPFF->ulCheckSum += ComputeFileviewCheckSum(ppfv[iFile]->fv.pvViewFD, ppfv[iFile]->fv.cjView);
                    }
                    KeDetachProcess();

                    PutFNTCacheCheckSum(pFntCheckSum->ulFastCheckSum, pPFF->ulCheckSum);
                }

                ASSERTGDI(pPFF->ulCheckSum, "pPFF->ulCheckSum must not be zero\n");

                if (pPFF->cjDV_)
                {
                    pPFF->ulCheckSum += ComputeFileviewCheckSum(pdv, cjDV);
                }
            }

#if 0
        // do it old way, and compare values in DBG mode

            if (ppfv != NULL)
            {
                ULONG   ulCheckSumTest = 0;

            // Now compute the UFI

                KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
                for (ULONG iFile = 0; iFile < cFiles; iFile ++)
                {
                    ulCheckSumTest += ComputeFileviewCheckSum(ppfv[iFile]->fv.pvViewFD, ppfv[iFile]->fv.cjView);
                }
                KeDetachProcess();

                if (pPFF->cjDV_)
                {
                    ulCheckSumTest += ComputeFileviewCheckSum(pdv, cjDV);
                }

                if (ulCheckSumTest != pPFF->ulCheckSum)
                {
                    DbgPrint(" TrueType font cache failed, if you see these message \n");
                    DbgPrint(" Please contact YungT or NTFonts \n");
                    DbgPrint(" it is ok to hit 'g' \n");
                    DbgBreakPoint();
                }
            }
#endif
        }
    }
    else
    {
        WARNING("invalid PFFMEMOBJ\n");
    }
}

/******************************Public*Routine******************************\
* PFFMEMOBJ::~PFFMEMOBJ()
*
* Destructor for physical font file memory object.
*
* History:
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Remove from handle manager
*
*  02-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFFMEMOBJ::~PFFMEMOBJ()
{
    if ((fs & PFFMO_KEEPIT) == 0)
    {
        if (pPFF)
        {
            VFREEMEM(pPFF);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL PFFOBJ::bCreatePFEC(ULONG cFonts)
*
* Create the handle of PFE collect, a object to reduce the consumption of object handle
*
* Returns:
*   TRUE means we create successfully
*
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bCreatePFEC(ULONG cFonts)
{
    BOOL  bRet = FALSE;

    ASSERTGDI(cFonts, "PFFOBJ::bCreateHPFE cFonts is zero \n");
    
    pPFF->pPFEC = (PFEC *) HmgAlloc(sizeof(PFEC), PFE_TYPE, HMGR_ALLOC_ALT_LOCK | HMGR_MAKE_PUBLIC);

    if (pPFF->pPFEC)
    {
        pPFF->pPFEC->pvPFE = (PVOID) PALLOCMEM(SZ_PFE(gcfsCharSetTable) * cFonts, 'efpG');
        pPFF->pPFEC->cjPFE = SZ_PFE(gcfsCharSetTable);
        
        if (pPFF->pPFEC->pvPFE)
            bRet = TRUE;
        else
        {
            HmgFree((HOBJ)pPFF->pPFEC->hGet());
            pPFF->pPFEC = NULL;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* VOID PFFOBJ::vDeletePFEC(PVOID *ppvPFE)
*
* Delete the handle of PFE collect, a object to reduce the consumption of object handle
*
* Returns:
*   None
*
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vDeletePFEC(PVOID *ppvPFE)
{
    *ppvPFE = NULL;
    
    if (pPFF->pPFEC != NULL)
    {
        *ppvPFE = pPFF->pPFEC->pvPFE;
        HmgFree((HOBJ)pPFF->pPFEC->hGet());
        pPFF->pPFEC = NULL;
    }
}

/******************************Public*Routine******************************\
* PFFOBJ::bAddHash
*
* Adds the PFF and all its PFEs to the font hashing table.  The font
* hashing tabled modified is in the PFT if a font driver managed font;
* otherwise, the font hashing table is in the PFF itself.
*
* The caller should hold the ghsemPublicPFT while calling this function.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bAddHash(BOOL bEUDC)
{
// Caller must hold the ghsemPublicPFT semaphore to protect access to
// the hash tables.

//
// Add the entry to the appropriate font hash tables
//
    FONTHASH **ppfhFace, **ppfhFamily,**ppfhUFI;

    if (!bDeviceFonts())
    {
    //
    // Hash tables for the font driver loaded fonts exist off of
    // the font table.
    //
        PUBLIC_PFTOBJ pfto( bInPrivatePFT() ? gpPFTPrivate : gpPFTPublic );
        ASSERTGDI(pfto.bValid(),"PFFOBJ::vAddHash -- invalid Public PFTOBJ\n");

        ppfhFace   = &(pfto.pPFT->pfhFace);
        ppfhFamily = &(pfto.pPFT->pfhFamily);
        ppfhUFI = &(pfto.pPFT->pfhUFI);

    //
    // If this is a TrueType font, increment the count.
    //
        if ( pPFF->hdev == (HDEV) gppdevTrueType )
        {
            gcTrueTypeFonts++;              // protected by ghsemPublicPFT
        }
    }
    else
    {
    //
    // Hash tables for device fonts exist off of the PFF that
    // encapsulates them.
    //

#if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            RIP("\n\n[kirko] PFFMEMOBJ::vAddHash -- Adding to the Driver's font hash table\n\n");
        }
#endif

        ppfhFace   = &pPFF->pfhFace;
        ppfhFamily = &pPFF->pfhFamily;
        ppfhUFI = &pPFF->pfhUFI;
    }

//
// Now that we have figured out where the tables are, add the PFEs to them.
//
    FHOBJ fhoFamily(ppfhFamily);
    FHOBJ fhoFace(ppfhFace);
    FHOBJ fhoUFI(ppfhUFI);

    ASSERTGDI(fhoFamily.bValid(), "bAddHashPFFOBJ(): fhoFamily not valid\n");
    ASSERTGDI(fhoFace.bValid(), "bAddHashPFFOBJ(): fhoFace not valid\n");
    ASSERTGDI(fhoUFI.bValid(), "bAddHashPFFOBJ(): fhoUFI not valid\n");

    if (! (fhoUFI.bValid() && fhoFamily.bValid() && fhoFace.bValid()))
        return FALSE;
        
    for (COUNT c = 0; c < pPFF->cFonts; c++)
    {
        PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);
        ASSERTGDI(pfeo.bValid(), "bAddHashPFFOBJ(): bad HPFE\n");

        if(!fhoUFI.bInsert(pfeo) )
        {
            WARNING("PFFOBJ::bAddHash -- fhoUFI.bInsert failed\n");
            return FALSE;
        }

    // If we only need to add it to the UFI hash table (we need to add it there
    // so that the remote printing code can request the bits of it needs to).

        if(bEUDC)
        {
            continue;
        }

        if (!fhoFamily.bInsert(pfeo))
        {
            WARNING("PFFOBJ::bAddHash -- fhoFamily.bInsert failed\n");
            return FALSE;
        }

         #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            DbgPrint("PFFMEMOBJ::vAddHash(\"%ws\")\n",pfeo.pwszFamilyName());
        }
        // Need level 2 checking to see this.
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoFamily.vPrint((VPRINT) DbgPrint);
        }
        #endif


        #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            UNIVERSAL_FONT_ID ufi;
            pfeo.vUFI(&ufi);
            DbgPrint("PFFMEMOBJ::vAddHash(\"%x\")\n",ufi.CheckSum);
        }
        // Need level 2 checking to see this.
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoUFI.vPrint((VPRINT) DbgPrint);
        }
        #endif

        if(!fhoFace.bInsert(pfeo))
        {
            WARNING("PFFMEMOBJ::vAddHash -- fhoFace.bInsert failed\n");
            return FALSE;
        }

        #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            DbgPrint("gdisrv!PFFMEMOBJ::vAddHash(\"%ws\")\n",pfeo.pwszFaceName());
        }
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoFace.vPrint((VPRINT) DbgPrint);
        }
        #endif
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* PFFOBJ::vRemoveHash
*
* Removes the PFF and all its PFEs from the font hashing table, preventing
* the font from being enumerated or mapped.
*
* The caller should hold the ghsemPublicPFT while calling this function.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vRemoveHash ()
{
// Caller must hold the ghsemPublicPFT semaphore to protect access to
// the hash tables.

    if (bDeviceFonts())
    {
    //
    // Hash tables for device fonts exist off of the PFF that
    // encapsulates the device fonts.  Font driver loaded fonts
    // are handled later while deleting the PFEs.
    //

    //
    // Kill the entire table for the device. No more processing
    // of font hash table stuff is necssary for device fonts
    // after we leave this scope.
    //

        FHOBJ fhoFace(&(pPFF->pfhFace));
        if (fhoFace.bValid())
        {
            fhoFace.vFree();
        }

        FHOBJ fhoFamily(&(pPFF->pfhFamily));
        if (fhoFamily.bValid())
        {
            fhoFamily.vFree();
        }

        FHOBJ fhoUFI(&(pPFF->pfhUFI));
        if (fhoUFI.bValid())
        {
            fhoUFI.vFree();
        }
    }

    else
    {
        PUBLIC_PFTOBJ pfto( bInPrivatePFT() ? gpPFTPrivate : gpPFTPublic );
        ASSERTGDI(pfto.bValid(),"vRemoveHashPFFOBJ(): invalid PFTOBJ\n");

        //
        // Hash tables for the font driver managed fonts exist off of
        // the font table (PFT).
        //

        FHOBJ fhoFace(&(pfto.pPFT->pfhFace));
        FHOBJ fhoFamily(&(pfto.pPFT->pfhFamily));
        FHOBJ fhoUFI(&(pfto.pPFT->pfhUFI));

        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ pfeo(((PFE **) (pPFF->aulData))[c]);
            ASSERTGDI(pfeo.bValid(), "vRemoveHashPFFOBJ(): bad HPFE\n");

            //
            // Remove PFE from hash tables.
            //

            if( !pfeo.bEUDC() )
            {
            // EUDC fonts arent added to these two tables
                if (fhoFace.bValid())
                    fhoFace.vDelete(pfeo);

                if (fhoFamily.bValid())
                    fhoFamily.vDelete(pfeo);
            }

            if (fhoUFI.bValid())
                fhoUFI.vDelete(pfeo);



            #if DBG
            if (gflFontDebug & DEBUG_FONTTABLE)
            {
                DbgPrint("gdisrv!vRemoveHashPFFOBJ() hpfe 0x%lx (\"%ws\")\n",
                          pfeo.ppfeGet(), pfeo.pwszFamilyName());
            }
            // Need level 2 checking to see this extra detail.
            if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
            {
                fhoFamily.vPrint((VPRINT) DbgPrint);
            }
            #endif
        }

        //
        // If this is a TrueType font, decrement the count.
        //

        if ( pPFF->hdev == (HDEV) gppdevTrueType )
        {
            gcTrueTypeFonts--;              // protected by ghsemPublicPFT
        }
    }
}

/******************************Public*Routine******************************\
*
* BOOL PFFOBJ::bPermanent()
*
*
* Effects:
*
* Warnings:
*
* History:
*  06-Dec-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bPermanent()
{
// in the new version of the code every remote font is flagged at
// AddFontResourceTime. The difference in behavior from 3.51
// is that now fonts added by the applicaitons, if local, will not
// be removed at log on time.

    if (pPFF->flState & PFF_STATE_NETREMOTE_FONT)
        return FALSE;
    else
        return TRUE;

}

/******************************Public*Routine******************************\
* PFFOBJ::vPFFC_Delete
*
* Deletes the PFF and its PFEs.  Information needed to call the driver
* to unload the font file and release driver allocated data is stored
* in the PFFCLEANUP structure.  The PFFCLEANUP structure is allocated
* within this routine.  It is the caller's responsibility to release
* the PFFCLEANUP structure (calling vCleanupFontFile() calls the drivers
* AND releases the structure).
*
* Changed so that it does not return a pointer to a PFFCLEANUP
* structure.  Instead, it takes a pointer to a PFFCLEANUP
* structure as an argument.  Thus, the caller must allocate
* and free the memory to the PFFCLEANUP structure.  [dchinn  11/24/98]
*
* Returns:
*   void.  The contents of the PFFCLEANUP structure passed in will be altered
*   as appropriate.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vPFFC_Delete(PFFCLEANUP *pPFFC)
{

    PVOID pvPFE;
    
    TRACE_FONT(("Entering PFFOBJ::vPFFC_Delete()\n\tpPFF=%-#x\n", pPFF));

    // check to see if a NULL pointer to a PFFCLEANUP structure was passed in
    ASSERTGDI(pPFFC, "vPFFC_Delete(): passed in a NULL\n");

    vDeletePFEC(&pvPFE);
    
//
// Delete all the PFE entries.
//
    for (COUNT c = 0; c < pPFF->cFonts; c++)
    {
        PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);
        ASSERTGDI(pfeo.bValid(), "vPFFC_DeletePFFOBJ(): bad HPFE (device font)\n");

    //
    // Delete the PFE.  The vDelete function will copy the driver allocated
    // resource information from the PFE into the PFECLEANUP structure.
    // We will call DrvFree for these resources later (when we're not under
    // semaphore).
    //
        pfeo.vDelete();
    }


//
// Save stuff about the PFF also.
//
    pPFFC->hff  = pPFF->hff;
    pPFFC->hdev = pPFF->hdev;
    pPFFC->pPFFClone = pPFF->pPFFClone;

//
// Free object memory and invalidate pointer.
//

    TRACE_FONT(("Freeing pPFF=%-#x\n",pPFF));

// If this was a remote font then we must delete the memory for the file.
// If this is a normal font then we must still delete the view.

    if (!pPFF->pPFFClone)
    {
        if (pPFF->ppfv && pPFF->cFiles)
        {
            FreeFileView(pPFF->ppfv, pPFF->cFiles);
        }
    }
    else
    {

    // We release the pPFFClone.

        pPFF->pPFFClone->pPFFClone = NULL;
    }

    if (pvPFE)
        VFREEMEM(pvPFE);
        
    VFREEMEM(pPFF);

    pPFF = 0;
    TRACE_FONT(("Exiting PFFOBJ::vPFFC_Delete\n\treturn value = %x\n", pPFFC));
    return;
}


/******************************Public*Routine******************************\
* PFFOBJ::vPFFC_DeleteAndCleanup
*
* This function creates a pointer to a PFFCLEANUP structure, calls vPFFC_Delete(),
* and then calls vCleanupFontFile().  This is the recommended way to handle
* unloading a font file, because it avoids the possibility (when a font file
* contains fewer than CFONTS_PFFCLEANUP fonts) that under a Hydra scenario
* it will fail to free up all the memory.
*
* (The old way of doing the cleanup was to call vPFFC_Delete() and then
* vCleanupFontFile().  However, the old vPFFC_Delete() allocated a PFFCLEANUP
* structure.  If that allocation failed, then the rest of the cleanup would
* not occur, and so memory would leak from a Hydra session.  This new way of
* doing the cleanup does not allocate memory from the heap.  Instead, it allocates
* it on the stack.)
*
* If for some reason the two calls (vPFFC_Delete() and vCleanupFontFile() ) need
* to be done separately (for example, if one of the calls is protected by a
* semaphore), then one must wrap code similar to that below around the two calls.
*
* Returns:
*   void.
*
* History:
*  24-Nov-1998 -by- Donald Chinn [dchinn]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vPFFC_DeleteAndCleanup()
{
    PFFCLEANUP pffc;

    // now call vPFFC_Delete() and vCleanupFontFile()

    vPFFC_Delete (&pffc);
    vCleanupFontFile (&pffc);
}


/******************************Public*Routine******************************\
* BOOL PFFOBJ::bDeleteLoadRef ()
*
* Remove a load reference.  Caller must hold the ghsemPublicPFT semaphore.
*
* Returns:
*   TRUE if caller should delete, FALSE if caller shouldn't delete.
*
* History:
*  23-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bDeleteLoadRef(ULONG fl, PVTDATA *pPvtData, BOOL *pbWrongFlags)
{
// ghsemPublicPFT protects the ref counts (cLoaded and cRFONT).  Caller
// must grab the semaphore before calling this function.

// Decrement the load count.  Must prevent underflow.  Who knows if some
// app might not randomly go around doing extra RemoveFont calls.  Isn't
// it too bad that we have to run APPS on our nice clean OS?  :-)

    BOOL bRet = FALSE;
    *pbWrongFlags = FALSE;

    TRACE_FONT(("Enterning PFFOBJ::bDeleteLoadRef\n"
                "\tpPFF=%-#x\n"
                "\tcLoaded=%d\n",
                "\tcNotEnum=%d\n",pPFF ,pPFF->cLoaded ,pPFF->cNotEnum));

// Embedded/Private fonts

    if (bInPrivatePFT())
    {
        ASSERTGDI(pPvtData, "bDeleteLoadRef: pPvtData is NULL\n");

        if (pPvtData == NULL)
        {
            return bRet;
        }
        // called by cleanup routine when the process terminates

        if (fl == FRW_PVT_CLEANUP)
        {
            pPvtData->cPrivate = 0;
            pPvtData->cNotEnum = 0;
        }

        // decreament cNotEnum for Embedded or FR_NOT_ENUM set font

        else if (fl & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID | FR_PRINT_EMB_FONT))
        {
            if (pPvtData->fl & fl)
            {
                if ( pPvtData->cNotEnum )
                {
                    pPvtData->cNotEnum--;
                    if (fl == FR_PRINT_EMB_FONT)
                    {
                        pPvtData->fl &= ~FR_PRINT_EMB_FONT;
                    }
                }
            }
            else
            {
                *pbWrongFlags = TRUE;
            }
        }

        // decreament cPrivate for FR_PRIVATE set only font

        else
        {
            if (pPvtData->fl & fl)
            {
                if ( pPvtData->cPrivate )
                {
                    pPvtData->cPrivate--;
                }
                else
                {
                    *pbWrongFlags = TRUE;
                }
            }
        }

     // Remove the PvtData block if both cPrivate and cNotEnum counts are zero.

        if ((pPvtData->cPrivate | pPvtData->cNotEnum) == 0)
        {
            bRemovePvtData(pPvtData);
        }

     // Mark it to Ready2Die if the PvtData list is NULL.

        if (pPvtDataHeadGet() == NULL)
        {
            ASSERTGDI( (pPFF->cLoaded | pPFF->cNotEnum) == 0, "win32k!bDeleteLoadRef(): global (cLoaded | cNotEnum) in private PFF is not 0\n");

            vKill();
            bRet = TRUE;
        }
    }
    else
    {
        // remove a public font

        if (fl == 0)
        {
            if (pPFF->cLoaded)
            {
                pPFF->cLoaded--;
            }
        }

        // remove a FR_NOT_ENUM font in the public PFT

        else
        {
            ASSERTGDI(fl == FR_NOT_ENUM, "win32k!bDeletLoadRef(): attempt to delete a font in public PFT with fl!=FR_NOT_ENUM \n");

            if (pPFF->cNotEnum)
            {
                pPFF->cNotEnum--;
            }
        }

        if ((pPFF->cLoaded | pPFF->cNotEnum) == 0)
        {
            ASSERTGDI(pPFF->pPvtDataHead == NULL, "win32k!bDeleteLoadRef(): pPvtDataHead in public PFF is not NULL\n");

            vKill();            // mark as "dead"
            bRet = TRUE;
        }
    }

    TRACE_FONT(("Exiting PFFOBJ::bDeleteLoadRef\n\treturn value = %d\n",bRet));
    return( bRet );
}


/******************************Public*Routine******************************\
* BOOL PFFOBJ::bDeleteRFONTRef ()
*
* Destroy the PFF physical font file object (message from a RFONT).
*
* Conditions that need to be met before deletion:
*
*   must delete all RFONTs before PFF can be deleted (cRFONT must be zero)
*   must delete all PFEs before deleting PFF
*
* After decrementing the cRFONT:
*
*   If cRFONT != 0 OR flState != PFF_STATE_READY2DIE, just exit.
*
*   If cRFONT == 0 and flState == PFF_STATE_READY2DIE, delete the PFF.
*
* Note:
*   This function has the side effect of decrementing the RFONT count.
*
* Returns:
*   TRUE if successful, FALSE if error occurs (which means PFF still lives!)
*
* Warning:
*   This should only be called from RFONTOBJ::bDelete()
*
* History:
*  23-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bDeleteRFONTRef()
{
    PFFCLEANUP pffc;
    BOOL bCleanUp = FALSE;

    {
    // Need to stabilize table to access cRFONT and to modify font table.

        SEMOBJ so(ghsemPublicPFT);

    // Decrement the RFONT count.

        ASSERTGDI(pPFF->cRFONT > 0,"bDeleteRFONTRefPFFOBJ(): bad ref count in PFF\n");
        pPFF->cRFONT--;

    // If load count is zero and no more RFONTs for this PFF, OK to delete.

        if ( (pPFF->cLoaded == 0) && (pPFF->cNotEnum == 0) && (pPFF->pPvtDataHead == NULL) && (pPFF->cRFONT == 0) )
        {
        // If the load count is zero, the PFF is already out of the PFT.
        // It is now safe to delete the PFF.

            vPFFC_Delete(&pffc);
            bCleanUp = TRUE;
        }
    }

// Call the driver outside of the semaphore.

    if (bCleanUp)
        vCleanupFontFile(&pffc);     // function can handle NULL case

    return TRUE;
}


/******************************Public*Routine******************************\
* vKill
*
* Puts the PFF and its PFEs to death.  In other words, the PFF and PFEs are
* put in a dead state that prevents them from being mapped to or enumerated.
* It also means that the font file is in a state in which the system wants
* to delete it (load count is zero), but the deletion is delayed because
* RFONTs still exist which reference this PFF.
*
* History:
*  29-May-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vKill()
{
    // Put into a dead state if not already there.
    TRACE_FONT(("Entering PFFOBJ::vKill\n\tpPFF=%-#x\n", pPFF));
    if ( !bDead() )
    {
        // Set state.
        pPFF->flState |= PFF_STATE_READY2DIE;

        // Run the list of PFEs and set each to death.
        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ pfeo(((PFE **) (pPFF->aulData))[c]);

            if (pfeo.bValid())
            {
                // Mark PFE as dead state.

                pfeo.vKill();
            }
            else
            {
                WARNING("vDiePFFOBJ(): cannot make PFEOBJ\n");
            }
        }
    }
    TRACE_FONT(("Exiting PFFOBJ::vKill\n"));
}


/******************************Public*Routine******************************\
* vRevive
*
* Restores the PFF and its PFEs to life.  In other words, the states are
* cleared so that the PFF and PFEs are available for mapping and enumeration.
*
* History:
*  29-May-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vRevive ()
{
// If dead, then revive.

    if ( bDead() )
    {
    // Reset state.

        pPFF->flState &= ~PFF_STATE_READY2DIE;

    // Run the list of PFEs and revive each one.

        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);

            if (pfeo.bValid())
            {
            // Mark PFE as dead state.

                pfeo.vRevive();
            }
            else
            {
                WARNING("vRevivePFFOBJ(): cannot make PFEOBJ\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bLoadFontFileTable
*
* Creates a PFE for each of the faces in a font file and loads the IFI
* metrics and mapping tables into each of the PFEs.  The font file is
* uniquely identified by the driver, hoDriver, and IFI font file handle,
* hff, stored in the PFF object.  However, rather than hitting the handle
* manager an extra time, a PFDEVOBJ is passed into this function.
*
* After all the PFE entries are added, the font files pathname is added
* to the end of the data buffer.
*
* It is assumed that the PFF ahpfe table has enough room for cFontsToLoad
* new HPFE handles as well as the font files pathname.
*
* Returns:
*   TRUE if successful, FALSE if error.
*
* History:
*  16-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFMEMOBJ::bLoadFontFileTable (
    PWSZ     pwszPathname,  // upper case
    COUNT    cFontsToLoad,
    HANDLE   hdc,
    PUNIVERSAL_FONT_ID pufi
#ifdef FE_SB
    ,PEUDCLOAD pEudcLoadData
#endif
    )
{
    ULONG       iFont; // font face index

// Create PFE's for each of the fonts in the font file.
// (Note: iFont indices for IFI fonts are 1-based, not 0-based)

    PDEVOBJ ppdo(hdev());

    if (!bCreatePFEC(cFontsToLoad))
        return FALSE;

    for (iFont = 1; iFont <= cFontsToLoad; iFont++)
    {
        FD_GLYPHSET *pfdg;
        PIFIMETRICS pifi;  // storage for the pointer to ifi
        ULONG_PTR idMetrics;

    // Grab the IFIMETRICS pointer.

        if ( (pifi = ppdo.QueryFont(
                        pPFF->dhpdev,
                        pPFF->hff,
                        iFont,
                        &idMetrics)) == (PIFIMETRICS) NULL )
        {
            WARNING("bLoadFontFileTablePFFMEMOBJ(): error getting metrics\n");
            return (FALSE);
        }

    // Put into a new PFE.

#ifdef FE_SB
        BOOL bRet = TRUE;
        if( bReadyToInitializeFontAssocDefault )
        {
        // This should be Base font, not be EUDC.
        //
            if ( pEudcLoadData == NULL )
            {
            // check this base font should be RE-load as default linked font ?
            // if so, the pathname for this font will be registerd as default linked font.
                bRet = FindDefaultLinkedFontEntry(
                    (const WCHAR *)(((BYTE*) pifi) + pifi->dpwszFamilyName),pwszPathname);
            }
        }

        if (!bRet || !bAddEntry(iFont, NULL, 0, pifi, idMetrics, (HANDLE)0, pufi, pEudcLoadData))
        {
        // Failed to get the FD_GLYPHSET information.  The entry is
        // partially valid (IFIMETRICS), so lets invalidate the good part.

            if (PPFNVALID(ppdo,Free))
            {
                ppdo.Free(pifi, idMetrics);
            }

            WARNING("bLoadFontFileTablePFFMEMOBJ(): error getting glyphset\n");

            return (FALSE);
        }

#endif
    }

    return (TRUE);
}


/*************************Public*Routine**************************\
* BOOL  bExtendGlyphset
*  Check the glyph set returned by the printer driver. Tack on the
* f0xx unicode range if missing for symbol font.
*
* History:
*  Oct-10-97  Xudong Wu [TessieW]
* Wrote it.
*
\*****************************************************************/
BOOL  bExtendGlyphSet(FD_GLYPHSET **ppfdgIn, FD_GLYPHSET **ppfdgOut)
{
    WCHAR   awch[256], *pwsz = awch, wcLow, wcHigh;
    UCHAR   ach[256];
    USHORT AnsiCodePage, OemCodePage;
    INT     cjWChar, cjChar;

    ULONG   cjSize, iRun, jRun, i, j;
    FD_GLYPHSET  *pfdgNew, *pfdg;
    ULONG   cRuns;
    BOOL    bRet = FALSE, bNeedExt = FALSE;

    pfdg = *ppfdgIn;
    cRuns = pfdg->cRuns;
    if (cRuns == 0)
    {
        WARNING("bExtendGlyphSet - empty glyphset\n");
        return FALSE;
    }

    wcLow  = pfdg->awcrun[0].wcLow;
    wcHigh = pfdg->awcrun[cRuns-1].wcLow + (WCHAR)pfdg->awcrun[cRuns-1].cGlyphs - 1 ;

    // mixing CP_SYMBOL mapping
    // e0 is the number of glyphs in f020-f0ff range in symbol CP

    // We shall extend the glypset if [f020,f0ff] does not intersect any
    // of the runs specified in the old pfdg. We check that by making sure that
    // [f020,f0ff] is entirely contained in the complement of the old glyphset.

    if (pfdg->cGlyphsSupported <= 256)
    {
        if ((wcHigh < 0xf020) || (wcLow > 0xf0ff))
        {
            bNeedExt = TRUE;
        }
        else
        {
            // bNeedExt = FALSE; // already initialized

            for (iRun = 0; iRun < (cRuns - 1); iRun++)
            {
                wcLow = pfdg->awcrun[iRun].wcLow + pfdg->awcrun[iRun].cGlyphs - 1;
                wcHigh = pfdg->awcrun[iRun+1].wcLow;

                if ((wcLow < 0xf020) && (wcHigh > 0xf0ff))
                {
                    bNeedExt = TRUE;
                    break;
                }
            }
        }
    }

    if (bNeedExt)
    {
        cjSize = SZ_GLYPHSET(cRuns + 1, pfdg->cGlyphsSupported + 0x00e0);
        pfdgNew = (FD_GLYPHSET*) PALLOCMEM(cjSize,'slgG');

        if (pfdgNew)
        {
            HGLYPH  *phgS, *phgD;

            cjWChar = sizeof(WCHAR) * pfdg->cGlyphsSupported;
            cjChar = 256;

            for (iRun = 0; iRun < cRuns; iRun++)
            {
                for (i = 0; i < pfdg->awcrun[iRun].cGlyphs; i++)
                {
                    *pwsz++ = pfdg->awcrun[iRun].wcLow + (WCHAR)i;
                }
            }

            RtlGetDefaultCodePage(&AnsiCodePage, &OemCodePage);
            if(IS_ANY_DBCS_CODEPAGE(AnsiCodePage))
            {
                AnsiCodePage = 1252;
            }
            if(EngWideCharToMultiByte(AnsiCodePage, awch, cjWChar, (CHAR*)ach, cjChar) == -1)
            {
                VFREEMEM(pfdgNew);
                return bRet;
            }

            pfdgNew->cjThis = cjSize;
            pfdgNew->flAccel = pfdg->flAccel | GS_EXTENDED;

            pfdgNew->cGlyphsSupported = pfdg->cGlyphsSupported + 0x00e0;
            pfdgNew->cRuns = cRuns + 1;

            phgS = phgD = (HGLYPH*) &pfdgNew->awcrun[cRuns+1];

            for ( iRun = 0;
                (iRun < cRuns) && (pfdg->awcrun[iRun].wcLow < 0xf020);
                iRun++)
            {
                pfdgNew->awcrun[iRun].wcLow = pfdg->awcrun[iRun].wcLow;
                pfdgNew->awcrun[iRun].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                pfdgNew->awcrun[iRun].phg = phgD;

                RtlCopyMemory(phgD, pfdg->awcrun[iRun].phg,
                                sizeof(HGLYPH) * pfdg->awcrun[iRun].cGlyphs);

                phgD += pfdg->awcrun[iRun].cGlyphs;
            }

            // fill in the f0xx range

            pfdgNew->awcrun[iRun].wcLow = 0xf020;
            pfdgNew->awcrun[iRun].cGlyphs = 0x00e0;
            pfdgNew->awcrun[iRun].phg = phgD;

            RtlZeroMemory((PVOID)phgD, 0x00e0 * sizeof(HGLYPH));

            j = 0;
            for (jRun = 0; jRun < cRuns; jRun++)
            {
                for (i = 0; i < pfdg->awcrun[jRun].cGlyphs; i++)
                {
                    if (ach[j] >= 0x20)
                    {
                        phgD[ach[j] - 0x20] = pfdg->awcrun[jRun].phg[i];
                    }
                    j++;
                }
            }

            phgD += 0x00e0;
            for (; iRun < cRuns; iRun++)
            {
                pfdgNew->awcrun[iRun+1].wcLow = pfdg->awcrun[iRun].wcLow;
                pfdgNew->awcrun[iRun+1].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                pfdgNew->awcrun[iRun+1].phg = phgD;

                RtlCopyMemory(phgD,
                              pfdg->awcrun[iRun].phg,
                              sizeof(HGLYPH) * pfdg->awcrun[iRun].cGlyphs);

                phgD += pfdg->awcrun[iRun].cGlyphs;
            }

            *ppfdgOut = pfdgNew;
            bRet = TRUE;
        }
        else
        {
            WARNING("bExtentGlyphSet(): failed to allocate pGlyphset\n");
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bLoadDeviceFontTable (
*
* Creates a PFE object for each device font and stores the IFIMETRICS and
* FD_MAPPINGS (UNICODE->HGLYPH) structures of that font.  The device is
* identified by the pair (ppdo, dhpdev).  There are cFonts number of device
* fonts to load.
*
* Note:
*   It is assumed that there is enough storage in the PFF for the number
*   of device fonts requested.
*
* History:
*  18-Mar-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
PFFMEMOBJ::bLoadDeviceFontTable (
    PDEVOBJ  *ppdo              // physical device
    )
{
    ULONG iFont;                // font face index
    ULONG cFonts = ppdo->cFonts();
    BOOL  bUMPD = ppdo->bUMPD();
    BOOL  bRet = FALSE;

    PIFIMETRICS     pifi;           // pointer to font's IFIMETRICS
    FD_GLYPHSET     *pfdg;          // pointer to font's GLYPHSETs

    ULONG_PTR           idifi;          // driver id's
    ULONG_PTR           idfdg;

    if (cFonts)
    {

        if (!bCreatePFEC(cFonts))
            return bRet;

    //
    // If the device has some fonts, allocate two FONTHASH strcutures
    // and save the addresses of the tables on the PFF
    //

        FHMEMOBJ fhmoFace(  &pPFF->pfhFace,   FHT_FACE  , cFonts);
        FHMEMOBJ fhmoFamily(&pPFF->pfhFamily, FHT_FAMILY, cFonts);
        FHMEMOBJ fhmoUFI(&pPFF->pfhUFI, FHT_UFI, cFonts);
    }

// Create PFE's for each of the fonts in the font file
// (Note: iFont indices for device fonts are 1-based, not 0-based)

    for (iFont = 1; iFont<=cFonts; iFont++)
    {

    // Set as NULL before we start to allocate ifi and fd_glyphset
        pfdg = NULL;
        pifi = NULL;
            
    // Get pointer to metrics

        if (( pifi = ppdo->QueryFont(pPFF->dhpdev, 0, iFont, &idifi )) == NULL )
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
            #if DBG
            DbgPrint("gdisrv!PFFMEMOBJ::bLoadDeviceFontTable(): error getting metrics \
                     for iFace = %ld\n", iFont);
            #endif
            goto CleanUp;
        }

    // Get pointer to the UNICODE->HGLYPH mappings

        if (bUMPD)
        {
            pfdg = NULL;
        }
        else
        {
            if ( (pfdg = (FD_GLYPHSET *) ppdo->QueryFontTree(
                                            pPFF->dhpdev,
                                            0,
                                            iFont,
                                            QFT_GLYPHSET,
                                            &idfdg)) == NULL )
            {
            // Failed to get the FD_GLYPHSET information.  The entry is
            // partially valid (IFIMETRICS), so lets invalidate the good part.

                SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
                goto CleanUp;
            }

        // extend the glyph set,
        // it may not contain [f020,f0ff] range for the older drivers

            if (pifi->jWinCharSet == SYMBOL_CHARSET)
            {
                FD_GLYPHSET     *pfdgNew = NULL;

                if (bExtendGlyphSet(&pfdg, &pfdgNew))
                {
                    if (PPFNVALID(*ppdo,Free))
                    {
                        ppdo->Free(pfdg, idfdg);
                    }
                    pfdg = pfdgNew;
                }
            }
        }
        
    // Put into a new PFE

    // add entry logs error

        if (bAddEntry(iFont, pfdg, idfdg, pifi, idifi,(HANDLE)0,NULL) == FALSE)
        {
            WARNING("bLoadDeviceFontTable():adding PFE\n");
            goto CleanUp;
        }
    }

    bRet = TRUE;
    
CleanUp:

    if (!bRet)
    {
    
    // Free font hash

        FHOBJ fhoFace(&(pPFF->pfhFace));
        if (fhoFace.bValid())
        {
            fhoFace.vFree();
        }

        FHOBJ fhoFamily(&(pPFF->pfhFamily));
        if (fhoFamily.bValid())
        {
            fhoFamily.vFree();
        }

        FHOBJ fhoUFI(&(pPFF->pfhUFI));
        if (fhoUFI.bValid())
        {
            fhoUFI.vFree();
        }

    // Free pfdg
    
       if ( (pifi != NULL) &&
            (pifi->jWinCharSet == SYMBOL_CHARSET) &&
            (pfdg != NULL) &&
            (pfdg->flAccel & GS_EXTENDED))
        {
            VFREEMEM(pfdg);
        }
        else
        {
            if ((pfdg != NULL) && PPFNVALID(*ppdo,Free))
            {
                ppdo->Free(pfdg, idfdg);
            }
        }   

    // Free pifi

        if (pifi)
        {
            if (PPFNVALID(*ppdo,Free))
            {
                ppdo->Free(pifi, idifi);
            }
        }
        
    }
    
    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bAddEntry                                               *
*                                                                          *
* This function creates a new physical font entry object and adds it to the*
* end of the table.  The iFont parameter identifies the font within this   *
* file.  The cjSize and pjMetrics identify a buffer containing face        *
* information including the IFI metrics and the mapping structures         *
* (defining the UNICODE->HGLYPH mapping).                                  *
*                                                                          *
* Returns FALSE if the function fails.                                     *
*                                                                          *
* History:                                                                 *
*  02-Jan-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFFMEMOBJ::bAddEntry
(
    ULONG       iFont,              // index of the font (IFI or device)
    FD_GLYPHSET *pfdg,              // pointer to UNICODE->HGLYPH map
    ULONG_PTR       idfdg,              // driver id for FD_GLYPHSET
    PIFIMETRICS pifi,               // pointer to IFIMETRICS
    ULONG_PTR       idifi,              // driver id for IFIMETRICS
    HANDLE      hdc,                // handle of DC if this is a remote font
    PUNIVERSAL_FONT_ID pufi,         // used when adding remote fonts
    PEUDCLOAD   pEudcLoadData       // pointer to EUDCLOAD
)
{

// Allocate memory for a new PFE
    PFECOBJ pfeco(pPFF->pPFEC);
    
    PFEMEMOBJ   pfemo(pfeco.GetPFE(iFont));

// Validate new object, hmgr logs error if needed

    if (!pfemo.bValid())
        return (FALSE);

// Initialize the new PFE

#ifdef FE_SB

    BOOL bEUDC = ( pEudcLoadData != NULL );
    PPFE *pppfeEUDC = ((bEUDC) ? pEudcLoadData->pppfeData : NULL);

    if( !pfemo.bInit(pPFFGet(), iFont, pfdg, idfdg, pifi, idifi, bDeviceFonts(), pufi, bEUDC ))
    {
        return(FALSE);
    }

    if( bEUDC )
    {
    //
    // This font file is loaded as EUDC font.
    //
        if( pEudcLoadData->LinkedFace == NULL )
        {
        //
        // No face name is specified.
        //
            switch( iFont )
            {
            case 1:
                pppfeEUDC[PFE_NORMAL] = pfemo.ppfeGet();
                pppfeEUDC[PFE_VERTICAL] = pppfeEUDC[PFE_NORMAL];
                break;

            case 2:
            //
            // if more than one face name the second face must be an @face
            //
                if( pfemo.pwszFaceName()[0] == (WCHAR) '@' )
                {
                    pppfeEUDC[PFE_VERTICAL] = pfemo.ppfeGet();

                    #if DBG
                    if( gflEUDCDebug & (DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_INIT) )
                    {
                        DbgPrint("EUDC font has vertical face %ws %x\n",
                                  pfemo.pwszFaceName(), pppfeEUDC[PFE_VERTICAL] );
                    }
                    #endif
                }
                 else
                {
                    WARNING("bAddEntryPFFMEMOBJ -- second face not a @face.\n");
                }
                break;

            default:
                WARNING("bAddEntryPFFMEMOBJ -- too many faces in EUDC font.\n");
            }
        }
         else
        {
            if( iFont == 1 )
            {
                //
                // link first face as default, because this font file might not
                // contains user's specified face name, but the user want to link
                // this font file. I don't know which is better link it as default
                // or fail link.
                //
                pppfeEUDC[PFE_NORMAL] = pfemo.ppfeGet();
                pppfeEUDC[PFE_VERTICAL] = pppfeEUDC[PFE_NORMAL];
            }
            else
            {
                ULONG iPfeOffset   = PFE_NORMAL;
                PWSTR pwszEudcFace = pfemo.pwszFaceName();

                //
                // Is this a vertical face ?
                //
                if( pwszEudcFace[0] == (WCHAR) '@' )
                {
                    iPfeOffset = PFE_VERTICAL;
                }

                //
                // Is this a face that we want ?
                //
                if( pfemo.bCheckFamilyName(pEudcLoadData->LinkedFace,1) )
                {
                    //
                    // Yes....., keep it.
                    //
                    pppfeEUDC[iPfeOffset] = pfemo.ppfeGet();

                    //
                    // if this is a PFE for Normal face, also keep it for Vertical face.
                    // after this, this value might be over-written by CORRRCT vertical
                    // face's PFE.
                    //
                    // NOTE :
                    //  This code assume Normal face come faster than Vertical face...
                    //
                    if( iPfeOffset == PFE_NORMAL )
                        pppfeEUDC[PFE_VERTICAL] = pfemo.ppfeGet();
                }
            }
        }

    // mark the FaceNameEUDC pfe list as NULL

        pfemo.vSetLinkedFontEntry( NULL );
    }
    else
    {

        PWSZ pwszAlias = NULL;
        BOOL bIsFamilyNameAlias = FALSE;
        PFLENTRY pFlEntry = NULL;

    // Here we see if there is an EUDC font for this family name.

        pwszAlias = pfemo.pwszFamilyNameAlias(&bIsFamilyNameAlias);

        pFlEntry = FindBaseFontEntry(pwszAlias);

        if (!pFlEntry && bIsFamilyNameAlias)
        {

            pwszAlias += (wcslen(pwszAlias) + 1);

            if (bIsFamilyNameAlias)
            {
                pFlEntry = FindBaseFontEntry(pwszAlias);
            }
        }

        if( pFlEntry != NULL )
        {
            //
            // set eudc list..
            //

            pfemo.vSetLinkedFontEntry( pFlEntry );

            #if DBG
            if( gflEUDCDebug & DEBUG_FACENAME_EUDC )
            {
                PLIST_ENTRY p = pfemo.pGetLinkedFontList()->Flink;

                DbgPrint("Found FaceName EUDC for %ws is ",pfemo.pwszFamilyName());

                while( p != &(pFlEntry->linkedFontListHead) )
                {
                    PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
                    PFEOBJ pfeo( ppfeData->appfe[PFE_NORMAL] );
                    PFFOBJ pffo( pfeo.pPFF() );

                    DbgPrint(" %ws ",pffo.pwszPathname());

                    p = p->Flink;
                }

                DbgPrint("\n");
            }
            #endif
        }
        else
        {
        // mark the FaceNameEUDC pfe as NULL

            pfemo.vSetLinkedFontEntry( NULL );
        }

    }
#endif
// Put PFE pointer into the PFF's table

    ((PFE **) (pPFF->aulData))[pPFF->cFonts++] = pfemo.ppfeGet();

    return (TRUE);
}


 #if DBG
/******************************Public*Routine******************************\
* VOID PFFOBJ::vDump ()
*
* Debugging code.
*
* History:
*  Thu 02-Apr-1992 12:10:28 by Kirk Olynyk [kirko]
* DbgPrint supports %ws
*
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vDump ()
{
    DbgPrint("\nContents of PFF, pPFF = 0x%lx\n", pPFFGet());
    if (*(WCHAR *)pwszPathname())
    {
        DbgPrint("Filename = %ws\n", pwszPathname());
    }
    DbgPrint("flState  = 0x%lx\n", pPFF->flState);
    DbgPrint("cLoaded  = %ld\n", pPFF->cLoaded);
    DbgPrint("cNotEnum = %ld\n", pPFF->cNotEnum);
    DbgPrint("pPvtDataHead = 0x%lx\n", pPFF->pPvtDataHead);
    DbgPrint("cRFONT   = %ld\n", pPFF->cRFONT);
    DbgPrint("hff      = 0x%lx\n", pPFF->hff);
    DbgPrint("cFonts   = %ld\n", pPFF->cFonts);
    DbgPrint("HPFE table\n");
    for (ULONG i=0; i<pPFF->cFonts; i++)
        DbgPrint("    0x%lx\n", ((PFE **) (pPFF->aulData))[i]);
    DbgPrint("\n");
}
#endif


/******************************Public*Routine******************************\
* vCleanupFontFile
*
* Parses the PFFCLEANUP structure and calls the driver to release
* its resources and to unload the font file.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vCleanupFontFile(PFFCLEANUP *pPFFC)
{
    // Create PDEV user object so we can call driver functions.

    PDEVOBJ pdo(pPFFC->hdev);

    //
    // If font driver loaded font, call to unload font file.
    //
    if (pPFFC->hff != HFF_INVALID && pPFFC->pPFFClone == NULL)
    {
        BOOL bOK = pdo.UnloadFontFile( pPFFC->hff );
        ASSERTGDI(bOK, "PFFOBJ::vCleanupFontFile(): DrvUnloadFontFile failed\n");

#if DBG
        if(bOK == -1){
        	RIP("PFFOBJ::vCleanupFontFile(): DrvUnloadFontFile failed2\n");
        }
#endif        
    }
}


/******************************Public*Routine******************************\
* pPvtDataMatch()                                                          *
*                                                                          *
* Search for existing PvtData for the current process                      *
*                                                                          *
* Return                                                                   *
*        if found, return the address of the pPvtData block                *
*                                                                          *
*        otherwise, return NULL
*                                                                          *
* History:                                                                 *
*  11-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

PVTDATA *PFFOBJ::pPvtDataMatch()
{
    PVTDATA *pPvtDataCur;

    for (pPvtDataCur = pPvtDataHeadGet();
         pPvtDataCur;
         pPvtDataCur = pPvtDataCur->pPvtDataNext)
    {
        if ((pPvtDataCur->fl & FRW_EMB_TID) && (pPvtDataCur->dwID == (DWORD) W32GetCurrentTID()))
        {
            break;
        }

        if (pPvtDataCur->dwID == (DWORD) W32GetCurrentPID())
        {
            break;
        }

        // spooler has the right of using any fonts

        if ((gpidSpool == (PW32PROCESS)W32GetCurrentProcess()) &&
            (pPvtDataCur->fl & FR_PRINT_EMB_FONT))
            break;
    }

    return (pPvtDataCur);
}


/******************************Public*Routine******************************\
* bAddPvtData(ULONG flEmbed)                                               *
*                                                                          *
* Add PvtData data block to the tail of pPvtDataHead link list             *
*                                                                          *
* Return FALSE if function fails                                           *
*                                                                          *
* History:                                                                 *
*  11-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFFOBJ::bAddPvtData(ULONG flEmbed)
{
    PVTDATA  *pPvtData;

 // Search for the existing PvtData block for the current process

    pPvtData = pPvtDataMatch();

 // PvtData exists for the calling process

    if (pPvtData)
    {
        if (flEmbed & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPvtData->cNotEnum++;
        }
        else
        {
            pPvtData->cPrivate++;
        }

        pPvtData->fl |= flEmbed & (FR_PRIVATE | FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID);

        return TRUE;
    }

// no PvtData exists for the current process

    else
    {
        if (pPvtData = (PVTDATA *) PALLOCMEM(sizeof(PVTDATA), 'pvtG'))
        {
            pPvtData->fl = flEmbed & (FR_PRIVATE | FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID);

        // Embedded fonts can't be enumed, so we set cNotEnum to 1

            if (flEmbed & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID))
            {
                pPvtData->cPrivate = 0;
                pPvtData->cNotEnum = 1;
            }
            else
            {
                pPvtData->cPrivate = 1;
                pPvtData->cNotEnum = 0;
            }
            pPvtData->dwID  = (flEmbed & FRW_EMB_TID) ? (DWORD)W32GetCurrentTID() : (DWORD)W32GetCurrentPID() ;

            pPvtData->pPvtDataNext = pPFF->pPvtDataHead;
            pPFF->pPvtDataHead = pPvtData;

            return TRUE;
        }
        else
        {
            WARNING("PFFOBJ::bAddPvtData(): memory allocation failed\n");
            return FALSE;
        }
    }
}


/******************************Public*Routine******************************\
* bRemovePvtData(PVTDATA *pPvtData)                                        *
*                                                                          *
* Rmove the PvtData data block from the pPvtDataHead link list             *
*                                                                          *
* Return FALSE if function fails                                           *
*                                                                          *
* History:                                                                 *
*  27-Set-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL  PFFOBJ::bRemovePvtData(PVTDATA *pPvtData)
{
    PVTDATA *pPrev, *pCur;

    pPrev = pPvtDataHeadGet();

    if (!pPrev)
    {
        WARNING("PFFOBJ::bRemovePvtData: try to remove PvtData block from NULL list\n");
        return FALSE;
    }

    // remove the PvtData block from the head of the list

    if ( pPrev == pPvtData)
    {
        pPFF->pPvtDataHead = pPvtData->pPvtDataNext;

        VFREEMEM(pPvtData);
        return TRUE;
    }

    while (pCur = pPrev->pPvtDataNext)
    {
        if (pCur == pPvtData)
        {
            pPrev->pPvtDataNext = pPvtData->pPvtDataNext;

            VFREEMEM(pPvtData);
            return TRUE;
        }

        pPrev = pCur;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pixelapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: pixelapi.cxx
*
* This contains the functions that get/set individual pixels.
*
* Created: 25-Apr-1991 11:32:15
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* GreSetPixel
*
* API entry point for putting a single pixel on the screen.
*
* Returns: -1 if point not in clip rgn or for blt failure,
*           or the color put on the device surface for success.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* update for size/perf and bug fix.
*
*  Thu  4-Mar-1992 -by- Kent Diamond [kentd]
* Pass in Attribute cache.
*
*  Thu 27-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Fix RGB return.
*
*  Thu 05-Dec-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, optimize for size, add error code logging.
*
*  Fri 16-Aug-1991 -by- Patrick Haluptzok [patrickh]
* Bug fix, make it return -1 for blt failure, cleanup
*
*  20-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

DWORD APIENTRY NtGdiSetPixel(HDC hdcDst, int x, int y, COLORREF crColor)
{
    PAL_ULONG palul;

    palul.ul = 0xFFFFFFFF;

    XDCOBJ dcoDst(hdcDst);

    if (dcoDst.bValid()) 
    { 
        //
        // Transform the coordinates to device space.
        //

        EPOINTL eptlDst(x,y);
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        xoDst.bXform(eptlDst);
        ERECTL erclDst(eptlDst.x,eptlDst.y,eptlDst.x+1,eptlDst.y+1);

        //
        // Accumulate bounds.  We can do this before knowing if the operation is
        // successful because bounds can be loose.
        //

        if (dcoDst.fjAccum())
            dcoDst.vAccumulate(erclDst);

        //
        // Check surface is included in DC.
        //

        if (dcoDst.bHasSurface())
        {
            //
            // Lock the device.
            //

            DEVLOCKOBJ dloTrg;

            if (dloTrg.bLock(dcoDst))
            {
                SURFACE *pSurfDst = dcoDst.pSurface();

                //
                // With a fixed DC origin we can change the destination to SCREEN coordinates.
                //

                erclDst += dcoDst.eptlOrigin();

                //
                // Parameter validation to avoid sticky overflow errors.
                // Note the validation is performed after the transform.
                // Any point that starts out in the invalid FIX zone may
                // potentially be transformed into the valid range and 
                // therefore should be plotted.
                // Any point that's had it's bottom right wrap will be also invalidated
                // by this check.
                // Use of BLTOFXOK is probably an overkill, but lower level code
                // could potentially do a FIX conversion.
                //

                if (!BLTOFXOK(erclDst.left)  ||
                    !BLTOFXOK(erclDst.right) ||
                    !BLTOFXOK(erclDst.top)   ||
                    !BLTOFXOK(erclDst.bottom))
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);   

                    //                  
                    // XDCOBJ does not automagically clean up it's locks in 
                    // its destructor so we have do it explicitly here.
                    //

                    dcoDst.vUnlockFast();
                    return (DWORD)(GDI_ERROR);         //fail
                }
                ECLIPOBJ *pco = NULL;

                //
                // This is a pretty knarly expression to save a return in here.
                // Basically pco can be NULL if the rect is completely in the
                // cached rect in the DC or if we set up a clip object that isn't empty.
                //

                if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                     (erclDst.right  <= dcoDst.prclClip()->right) &&
                     (erclDst.top    >= dcoDst.prclClip()->top) &&
                     (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                    (pco = dcoDst.pco(),
                     pco->vSetup(dcoDst.prgnEffRao(), erclDst,CLIP_NOFORCETRIV),
                     !pco->erclExclude().bEmpty()))
                {
                    //
                    // Make a fake solid color brush for this guy.
                    //

                    XEPALOBJ  palDst(pSurfDst->ppal());
                    XEPALOBJ  palDstDC(dcoDst.ppal());
                    BBRUSHOBJ bo;
                    BOOL      bCMYKColor = dcoDst.pdc->bIsCMYKColor();

                    //
                    // Initialize BRUSHOBJ on stack.
                    //
                    bo.pvRbrush = (PVOID) NULL;
                    bo.flColorType = 0;

                    //
                    // if the in CMYK color mode, iSolidColor is CMYK color.
                    //
                    if (bCMYKColor)
                    {
                        bo.iSolidColor = crColor;
                        bo.flColorType = (BR_CMYKCOLOR | BR_HOST_ICM);

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(crColor);
                        }
                    }
                    else
                    {
                        bo.iSolidColor = ulGetNearestIndexFromColorref(palDst, palDstDC, crColor);

                        if (dcoDst.pdc->bIsSoftwareICM())
                        {
                            bo.flColorType = BR_HOST_ICM;
                        }
                        else if (dcoDst.pdc->bIsDeviceICM())
                        {
                            bo.flColorType = BR_DEVICE_ICM;
                        }

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(rgbFromColorref(palDst, palDstDC, crColor));
                        }
                    }

                    //
                    // Set up the correct return value.
                    //

                    DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,pco);

                    INC_SURF_UNIQ(pSurfDst);

                    ULONG rop4 = gaMix[dcoDst.pdc->jROP2() & 0x0F];
                    rop4 |= (rop4 << 8);

                    if ((*(pSurfDst->pfnBitBlt()))
                              (
                                  pSurfDst->pSurfobj(),
                                  (SURFOBJ *) NULL,
                                  (SURFOBJ *) NULL,
                                  NULL,
                                  NULL,
                                  &erclDst,
                                  (POINTL *)  NULL,
                                  (POINTL *)  NULL,
                                  &bo,
                                  &dcoDst.pdc->ptlFillOrigin(),
                                  rop4
                              ))
                    {
                        if (bCMYKColor)
                        {
                            palul.ul = bo.iSolidColor;
                        }
                        else
                        {
                            palul.ul = ulIndexToRGB(palDst, palDstDC, bo.iSolidColor);
                        }
                    }
                }
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING1("ERROR GreSetPixel called on invalid DC\n");
    }

    return(palul.ul);
}

#if 0
/******************************Public*Routine******************************\
* EngGetPixel
*
* This facilitates GetPixel on DIBs.
*
* History:
*  27-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG EngGetPixel(
SURFACE *pSurfSrc,
PPOINTL  pptlSrc)
{
    ULONG ulReturn;
    PBYTE pjBits;
    LONG lDelta;

    ASSERTGDI(pSurfSrc != (PDIBOBJ) NULL, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc != (PPOINTL) NULL, "ERROR GDI EngCopyBits");
    ASSERTGDI(pSurfSrc->iType() == STYPE_BITMAP, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc->x < pSurfSrc->sizl().cx, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc->y < pSurfSrc->sizl().cy, "ERROR GDI EngCopyBits");

    lDelta = pSurfSrc->lDelta();
    pjBits = (PBYTE) pSurfSrc->pvScan0();
    pjBits = pjBits + (lDelta * pptlSrc->y);

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(pSurfSrc->hdev());
        po.vSync(pSurfSrc,NULL,0);
    }

    switch(pSurfSrc->iFormat())
    {
    case BMF_1BPP:

    // Get the correct byte.
        ulReturn = (ULONG) *(pjBits + (pptlSrc->x >> 3));
    // Get the correct bit in the lowest bit.
        ulReturn = ulReturn >> (7 - (pptlSrc->x & 7));
    // Mask off the top bits.
        ulReturn = ulReturn & 1;
        break;

    case BMF_4BPP:

    // Get the correct byte.
        ulReturn = (ULONG) *(pjBits + (pptlSrc->x >> 1));

        if (pptlSrc->x & 1)
            ulReturn = ulReturn & 15;
        else
            ulReturn = ulReturn >> 4;

        ASSERTGDI(ulReturn < 16, "ERROR GDI EngCopyBits");
        break;

    case BMF_8BPP:

        ulReturn = (ULONG) *(pjBits + pptlSrc->x);
        break;

    case BMF_16BPP:

        ulReturn = (ULONG) *((PUSHORT) (pjBits + (pptlSrc->x << 1)));
        break;

    case BMF_24BPP:

        pjBits += (pptlSrc->x * 3);
        ulReturn = (ULONG) *(pjBits + 2);
        ulReturn <<= 8;
        ulReturn |= ((ULONG) *(pjBits + 1));
        ulReturn <<= 8;
        ulReturn |= ((ULONG) *pjBits);
        break;

    case BMF_32BPP:

        ulReturn = *((PULONG) (pjBits + (pptlSrc->x << 2)));
        break;

    default:
        RIP("ERROR GDI EngCopyBits1");
    }

    return(ulReturn);
}
#endif

/******************************Public*Routine******************************\
* GreGetPixel
*
* API entry point for getting a single pixel on the screen.
*
* Returns: -1 if point not in clip rgn or for blt failure,
*           the RGB color put on the device surface for success.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* update for size/perf and bug fix.
*
*  Thu 27-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Fix RGB return, remove unnecesary work.
*
*  22-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

DWORD NtGdiGetPixel(HDC hdc, int x, int y)
{
    //
    // Lock the destination and its transform.
    //

    DWORD iSolidColor = 0xFFFFFFFF;
    XDCOBJ dcoSrc(hdc);

    if (dcoSrc.bValid())
    {
        //
        // Lock the Rao region if we are drawing on a display surface.  The Rao
        // region might otherwise change asynchronously.  The DEVLOCKOBJ also makes
        // sure that the VisRgn is up to date, calling the window manager if
        // necessary to recompute it.  It also protects us from pSurfSrc
        // being changed asynchronously by a dynamic mode change.
        //

        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoSrc))
        {
            //
            // Check we can really do a GetPixel on this device.
            //

            SURFACE *pSurfSrc = dcoSrc.pSurface();

            if ((pSurfSrc != NULL) &&
                (pSurfSrc->bReadable() || UserScreenAccessCheck()))
            {
                EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

                //
                // Transform the coordinates to device space.
                //

                EPOINTL eptlSrc(x,y);

                xoSrc.bXform(eptlSrc);

                ERECTL erclSrc(eptlSrc.x,eptlSrc.y,eptlSrc.x+1,eptlSrc.y+1);

                //
                // Shift to Sreen Coordinates
                //

                erclSrc += dcoSrc.eptlOrigin();

                //
                // Parameter validation not necessary here. It seems
                // that if the +1 above wraps, the initialization of the
                // clip obj will catch it in this case.                
                //

                //
                // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                //

                ECLIPOBJ co(dcoSrc.prgnEffRao(), erclSrc);

                //
                // Check the destination which is reduced by clipping.
                //

                if (!co.erclExclude().bEmpty())
                {
                    //
                    // Exclude the pointer.
                    //

                    DEVEXCLUDEOBJ dxo(dcoSrc,&erclSrc);

                    //
                    // Check target device color.
                    //

                    BOOL     bCMYKColor = dcoSrc.pdc->bIsCMYKColor();

                    #if 0
                    if (pSurfSrc->iType() == STYPE_BITMAP)
                    {
                    // We have a special function to quick get it.

                        iSolidColor = EngGetPixel(
                                            pSurfSrc,              // Source surface.
                                            (POINTL *) &erclSrc    // Source origin.
                                           );

                        if (!bCMYKColor)
                        {
                            iSolidColor = ulIndexToRGB(palSurf, palDC, iSolidColor);
                        }
                    }
                    else
                    #endif
                    {
                        iSolidColor = 0;

                        //
                        // Allocate up a temporary DIB.
                        //

                        DEVBITMAPINFO dbmi;
                        dbmi.cxBitmap = 1;
                        dbmi.cyBitmap = 1;
                        dbmi.hpal = (HPALETTE) 0;
                        dbmi.fl = BMF_TOPDOWN;

                        RECTL rclDst;

                        //
                        // To make sure the color falls into the lower
                        // bit/nibble/word, the destination rect is adjusted.
                        //

                        dbmi.iFormat = pSurfSrc->iFormat();

                        switch (dbmi.iFormat)
                        {
                        case BMF_1BPP:
                            rclDst.left   = 7;
                            rclDst.right  = 8;
                            break;
                        case BMF_4BPP:
                            rclDst.left   = 1;
                            rclDst.right  = 2;
                            break;
                        default:
                            rclDst.left   = 0;
                            rclDst.right  = 1;
                        }

                        SURFMEM SurfTempDIB;

                        if (SurfTempDIB.bCreateDIB(&dbmi, &iSolidColor))
                        {
                            rclDst.top    = 0;
                            rclDst.bottom = 1;

                            PDEVOBJ pdo(pSurfSrc->hdev());

                            if ((*PPFNGET(pdo, CopyBits, pSurfSrc->flags()))
                                                   (SurfTempDIB.pSurfobj(),
                                                    pSurfSrc->pSurfobj(),
                                                    (CLIPOBJ *) NULL,
                                                    &xloIdent,
                                                    &rclDst,
                                                    (POINTL *) &erclSrc))
                            {
                                if (!bCMYKColor)
                                {
                                    XEPALOBJ palDC(dcoSrc.ppal());
                                    XEPALOBJ palSurf(pSurfSrc->ppal());

                                    iSolidColor = ulIndexToRGB(palSurf, palDC, iSolidColor);
                                }
                            }
                        }
                    }
                }
            }
        }

        dcoSrc.vUnlockFast();

    }

    return(iSolidColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pixelfmt.cxx ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.cxx
*
* This contains the pixel format functions.
*
* Created: 21-Sep-1993
* Author: Hock San Lee [hockl]
*
* 02-Nov-1995 -by- Drew Bliss [drewb]
* Restored in kernel mode in minimal form
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Number of generic pixel formats.  There are 5 pixel depths (4,8,16,24,32).
// See GreDescribePixelFormat for details.

#define MIN_GENERIC_PFD  1
#define MAX_GENERIC_PFD  24

/******************************Public*Routine******************************\
* LONG XDCOBJ::ipfdDevMaxGet()
*
* Initialize and return the maximum device supported pixel format index.
*
* The ipfdDevMax is set to -1 initially but is set to 0 or the maximum
* device pixel format index here.  This function should be called at most
* once for the given DC.
*
* History:
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

LONG XDCOBJ::ipfdDevMaxGet()
{
    PDEVOBJ pdo(hdev());
    int ipfd = 0;

    DEVLOCKOBJ dlo(pdo);

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              hdev(), (RECTL) pdc->erclWindow(), NULL);

        if (hdevDevice)
        {
            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if (PPFNVALID(pdo, DescribePixelFormat))
    {
        ipfd = (*PPFNDRV(pdo, DescribePixelFormat))(pdo.dhpdev(), 1, 0, NULL);

        if (ipfd < 0)
        {
            ipfd = 0;
        }
    }

    ipfdDevMax((SHORT)ipfd);

    return ipfd;
}

/******************************Public*Routine******************************\
* GreDescribePixelFormat
*
* Request pixel format information from a driver
* If cjpfd is 0, just return the maximum driver pixel format index.
*
* Returns: 0 if error; maximum driver pixel format index otherwise
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Stripped down to driver-only support for kernel-mode
*  Mon Apr 25 15:34:32 1994     -by-    Hock San Lee    [hockl]
* Added 16-bit Z buffer formats and removed double buffered formats for bitmaps.
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int GreDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                           PPIXELFORMATDESCRIPTOR ppfd)
{
// Validate DC.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    int ipfdDevMax = dco.ipfdDevMax();

// If cjpfd is 0, just return the maximum pixel format index.

    if (cjpfd == 0)
        return ipfdDevMax;

// Validate the size of the pixel format descriptor.

    if (cjpfd < sizeof(PIXELFORMATDESCRIPTOR))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    if ((ipfd < 1) || (ipfd > ipfdDevMax))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    PDEVOBJ po(dco.hdev());

    DEVLOCKOBJ dlo(po);

#ifdef OPENGL_MM

    if (po.bMetaDriver())
    {
        //  We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // replace meta pdevobj with device specific hdev.

            po.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    int iRet = 0;

    if (PPFNVALID(po, DescribePixelFormat))
    {
        iRet = (int) (*PPFNDRV(po, DescribePixelFormat))
                               (po.dhpdev(), ipfd, cjpfd, ppfd);
    }

    if (iRet == 0)
        return(0);

    ASSERTGDI(iRet == ipfdDevMax, "Bad ipfdDevMax");
    return ipfdDevMax;
}

/******************************Public*Routine******************************\
* NtGdiSetPixelFormat
*
* Set the pixel format.
*
* This is a special function.  It is one of the three (the other two are
* ExtEscape for WNDOBJ_SETUP escape and ExtEscape for 3D-DDI
* RX_CREATECONTEXT escape) functions that allow WNDOBJ to be created in
* the DDI.  We need to be in the user critical section and grab the devlock
* in the function before calling the DrvSetPixelFormat function to ensure
* that the new WNDOBJ created is current.
*
* Returns: FALSE if error; TRUE otherwise
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Changed to driver-only kernel-mode form
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL NtGdiSetPixelFormat(HDC hdc,int ipfd)
{
// Validate DC and surface.  Info DC is not allowed.

    DCOBJ dco(hdc);
    if (!dco.bValid() || !dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    int ipfdDevMax = dco.ipfdDevMax();
    if ((ipfd < 1) || (ipfd > ipfdDevMax))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// Make sure that we don't have devlock before entering user critical section.
// Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

// Enter user critical section.

    USERCRIT usercrit;

// We are modifying the pixel format of the window for the first time.
// Grab the devlock.
// We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

// If it is a display DC, get the hwnd that the hdc is associated with.
// If it is a printer or memory DC, hwnd is NULL.

    HWND     hwnd;
    if (dco.bDisplay())
    {
        PEWNDOBJ pwo;

        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,
                  "ERROR it has to be direct really");

        if (!UserGetHwnd(hdc, &hwnd, (PVOID *) &pwo, FALSE))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_WINDOW_STYLE);
            return(FALSE);
        }

        // If another thread has changed the pixel format of the window
        // after we queried it earlier in this function, make sure that
        // the pixel format is compatible.
        // If a previous 3D-DDI wndobj with pixel format 0 has been created
        // for this window, fail the call here.

        if (pwo)
        {
            WARNING("GreSetPixelFormat: pixel format set asynchrously!\n");

            if (pwo->ipfd != ipfd)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
                return(FALSE);
            }
            return(TRUE);
        }
    }
    else
    {
        hwnd = (HWND)NULL;
    }

    // Dispatch driver formats.  Call DrvSetPixelFormat.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if (!PPFNVALID(pdo,SwapBuffers) ||
        !((SURFOBJ_TO_SURFACE_NOT_NULL(pso)->bDriverCreated()) && 
          (*PPFNDRV(pdo, SetPixelFormat))(pso, ipfd, hwnd)))
            return(FALSE);

// If a new WNDOBJ is created, we need to update the window client regions
// in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* NtGdiSwapBuffers
*
* Since SwapBuffers is a GDI function, it has to work even if OpenGL is
* not called.  That is, we will eventually support 2D double buffering in
* GDI.  As a result, we need to define a DDI function DrvSwapBuffers() that
* works with both OpenGL and GDI.  The complication is that we have to
* deal with the generic opengl server, the install opengl driver and GDI.
* I will outline how this function works here:
*
* 1. On the client side, SwapBuffers() call glFinish() to flush all the
*    OpenGL functions in the current thread.  It then calls the server side
*    GreSwapBuffers().  Note that this flushes all GDI functions in the
*    current thread.
* 2. Once on the server side, we know that all GDI/OpenGL calls have been
*    flushed.  We first find the hwnd id that corresponding to the hdc.
*    Note that SwapBuffers really applies to the window but not to the dc.
*    There is only one back buffer for a window but possibly multiple
*    dc's referring to the same back buffer.  We find out the hwnd id
*    for the dc and do one of the following:
*    A. hdc has the device pixel formats.
*       This is simple.  We call the device driver to swap the buffer with
*       the hwnd id.
*    B. hdc has the generic pixel formats.
*       Call the opengl server to swap the buffer.  The OpenGL server uses
*       the hwnd id to bitblt the buffer that is associated with the window.
*
* Note that in this implementation, we do not flush calls in other threads.
* Applications are responsible for coordinating SwapBuffers in multiple
* threads.
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Stripped down to driver-only kernel-mode form
*  Thu Jan 06 12:32:11 1994     -by-    Hock San Lee    [hockl]
* Added some code and wrote the above comment.
*  21-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL NtGdiSwapBuffers(HDC hdc)
{
// Validate DC and surface.  Info DC is not allowed.

    DCOBJ dco(hdc);
    if (!dco.bValid() || !dco.bHasSurface())
    {
        WARNING("GreSwapBuffers(): invalid hdc\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Early out -- nothing to do if memory DC.

    if (dco.dctp() == DCTYPE_MEMORY)
        return(TRUE);

// Lock display.

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("GreSwapBuffers: could not lock device\n");
            return(FALSE);
        }
        else
            return(TRUE);
    }

    if (!dlo.bValidWndobj())
    {
        WARNING("GreSwapBuffers: invalid wndobj\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (dlo.pwo()->erclExclude().bEmpty())
        return(TRUE);

// Pointer exclusion.
// Increment the surface uniqueness.  This only needs to be done once
// per DEVLOCK.

    DEVEXCLUDEOBJ dxo;

    dxo.vExclude(dco.hdev(), &dlo.pwo()->rclClient, (ECLIPOBJ *) dlo.pwo());
    INC_SURF_UNIQ(dco.pSurface());

// Dispatch driver formats.

    PEWNDOBJ pwo;
    pwo = dlo.pwo();

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), pwo);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNVALID(pdo,SwapBuffers) ||
         !((*PPFNDRV(pdo,SwapBuffers))(pso, (WNDOBJ *)pwo)))
        return(FALSE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\plgblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: plgblt.cxx
*
* This contains the API and DDI entry points to the graphics engine
* for PlgBlt and EngPlgBlt.
*
* Created: 21-Oct-1990 14:15:53
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "rotate.hxx"

/******************************Public*Routine******************************\
* GrePlgBlt
*
* API for blting to a parallelogram from a rectangle.
*
* History:
*  Tue 02-Jun-1992 -by- Patrick Haluptzok [patrickh]
* fix clipping bugs
*
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  Wed 15-Jan-1992 -by- Patrick Haluptzok [patrickh]
* Add mask support
*
*  26-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GrePlgBlt(
    HDC     hdcTrg,
    LPPOINT pptlTrg,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   crBackColor
    )
{
    GDITraceHandle3(GrePlgBlt, "(%X, %p, %X, %d, %d, %d, %d, %X, %d, %d, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    BLTRECORD   blt;
    ULONG       ulAvec;

    // Lock the DC's, no optimization is made for same surface

    DCOBJ   dcoTrg(hdcTrg);
    DCOBJ   dcoSrc(hdcSrc);

    if (!dcoTrg.bValid() || !dcoSrc.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (dcoTrg.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // Lock the surface and the Rao region

    DEVLOCKBLTOBJ dlo(dcoTrg, dcoSrc);

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen() || dcoSrc.bFullScreen());
    }

    if (!dcoTrg.bValidSurf() || !dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        ulDirty = dcoSrc.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoSrc.pdc,dcoSrc.pdc->hbrush());
        }

        // I wanted to cheat, but InfoDCs need the right answer here...

        if ((dcoTrg.dctp() == DCTYPE_INFO) || !dcoSrc.bValidSurf())
        {
            if (dcoTrg.fjAccum())
            {
                blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);

                if (!blt.TrgPlg(pptlTrg))
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }

                // Complete the parallelogram and find the extrema.

                blt.vExtrema();

                // Get the bounding rectangle

                ERECTL  erclBnd;

                blt.vBound(&erclBnd);

                dcoTrg.vAccumulate(erclBnd);
            }
        }

        // Do the security test on SCREEN to MEMORY blits.

        if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
        {
            if (!UserScreenAccessCheck())
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                return(FALSE);
            }
        }

        // If the source isn't a DISPLAY we should exit unless there is no
        // destination surface.

        if( !dcoSrc.bDisplay() )
        {
            return( dcoTrg.pSurface() == NULL );
        }
    }

    if (dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }
    // Fill the BLTRECORD

    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.pSurfTrg(dcoTrg.pSurfaceEff());
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);
    blt.pSurfSrc(dcoSrc.pSurfaceEff());
    blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
    blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());

    // Initialize the color translation object.
    //
    // No ICM with PlgBlt(), so pass NULL color transform to XLATEOBJ.

    if (!blt.pexlo()->bInitXlateObj(NULL,                   // hColorTransform
                                    dcoTrg.pdc->lIcmMode(), // ICM mode
                                   *blt.ppoSrc(),
                                   *blt.ppoTrg(),
                                   *blt.ppoSrcDC(),
                                   *blt.ppoTrgDC(),
                                    dcoTrg.pdc->crTextClr(),
                                    dcoTrg.pdc->crBackClr(),
                                    crBackColor
                                    ))
    {
        WARNING("bInitXlateObj failed in PlgBlt\n");
        return(FALSE);
    }

    blt.flSet(BLTREC_PXLO);
    blt.pbo(NULL);

    // Set the source rectangle.

    if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cxSrc, cySrc))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // Deal with the mask if provided

    if (hbmMask == (HBITMAP) 0)
    {
        blt.pSurfMsk((SURFACE *) NULL);
        blt.rop(0x0000CCCC);
        ulAvec = AVEC_S;
    }
    else
    {
        SURFREF soMsk((HSURF) hbmMask);

        if (!soMsk.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        soMsk.vKeepIt();

        blt.pSurfMsk((SURFACE *) soMsk.ps);

        blt.rop(0x0000AACC);

        ulAvec = AVEC_NEED_MASK | AVEC_S;

        blt.flSet(BLTREC_MASK_NEEDED | BLTREC_MASK_LOCKED);

        if (
            (blt.pSurfMsk()->iType() != STYPE_BITMAP) ||
            (blt.pSurfMsk()->iFormat() != BMF_1BPP)
           )
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        blt.Msk(xMask, yMask);
    }

    // We must first transform the target.  We might be rotating because of
    // the transform or the specified parallelogram.

    if (!blt.TrgPlg(pptlTrg))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // If the parallelogram is rotated, skewed or has fractional endpoints
    // send the call to bRotate.

    if (blt.bRotated())
    {
        return(blt.bRotate(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

    // If we are halftoning or the extents aren't equal, call bStretch.

    if ((dcoTrg.pdc->jStretchBltMode() == HALFTONE) || !blt.bEqualExtents())
    {
        return(blt.bStretch(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

    return(blt.bBitBlt(dcoTrg, dcoSrc, ulAvec));
}

BOOL
APIENTRY
NtGdiPlgBlt(
    HDC     hdcTrg,
    LPPOINT pptlTrg,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   crBackColor
    )
{
    GDITraceHandle3(NtGdiPlgBlt, "(%X, %p, %X, %d, %d, %d, %d, %X, %d, %d, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    BOOL  bRet;
    POINT aptDst[3];

    __try
    {
        ProbeForRead(pptlTrg, sizeof(aptDst), sizeof(DWORD));
        RtlMoveMemory(aptDst, pptlTrg, sizeof(aptDst));

        pptlTrg = aptDst;
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GrePlgBlt(hdcTrg, pptlTrg, hdcSrc, xSrc, ySrc, cxSrc, cySrc,
                         hbmMask, xMask, yMask, crBackColor);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dcoTrg, dcoSrc, ulAvec)
*
* Do a rotate blt from the blt record
*
* History:
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
\**************************************************************************/

BOOL
BLTRECORD::bRotate(
    DCOBJ&  dcoTrg,
    DCOBJ&  dcoSrc,
    ULONG   ulAvec,
    BYTE    jMode
    )
{
    //
    // Complete the parallelogram and find the extrema
    //

    vExtrema();

    //
    // We might be here on behalf of MaskBlt and need to rotate the mask
    // before we do a pattern only blt.
    //

    BOOL    bReturn;

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        vOrder(perclMask());

        if (MIRRORED_DC(dcoTrg.pdc)) {
            LONG x = aptlMask[0].x;
            aptlMask[0].x = aptlMask[1].x;
            aptlMask[1].x = x;
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.
        //

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if (
                (aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
                (aptlMask[1].y > pSurfMsk()->sizl().cy)
               )
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }

        SURFMEM  dimoMask;

        //
        // If there is a mask, rotate it.
        //

        if ((ulAvec & AVEC_NEED_MASK) && !bRotate(dimoMask, (ULONG) jMode))
        {
            return(FALSE);
        }

        //
        // Since this is going to bBitBlt, we need to create a target rectangle.
        //

        vBound(perclTrg());

        //
        // Create a region from the parallelogram and select it into the
        // clipping pipeline.  This is to make sure no bits are altered
        // outside when BitBlt is called.
        //

        if (!bCreateRegion(dcoTrg, aptfxTrg))
        {
            return(FALSE);
        }

        bReturn = bBitBlt(dcoTrg, dcoSrc, ulAvec);

        //
        // Remember to clean up after ourselves!
        //

        dcoTrg.pdc->prgnAPI(NULL);

        return(bReturn);
    }

    //
    // Make the source rectangle well ordered remembering all the flips.
    //

    vOrder(perclSrc());
    perclMask()->vOrder();

    if (MIRRORED_DC(dcoTrg.pdc)) {
        int x = aptlMask[0].x;
        aptlMask[0].x = aptlMask[1].x;
        aptlMask[1].x = x;
    }

    //
    // Before we get too involved, validate that the mask will actually
    // cover the entire source.
    //

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if (
            (aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
            (aptlMask[1].y > pSurfMsk()->sizl().cy)
           )
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    //
    // If the devices are on different PDEV's we can only succeed if the Engine
    // manages one or both of the surfaces.  Check for this.
    //

    if (
        (dcoTrg.hdev() != dcoSrc.hdev()) &&
        (dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP) &&
        (dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
       )
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // We might be here with a ROP, again on behalf of MaskBlt.  If it
    // isn't one of the basic PlgBlt rops, create a rotated shadow and mask
    // and call BitBlt to finish the job for us.
    //

    if ((rop4 != 0x0000CCCC) && (rop4 != 0x0000AACC))
    {
        SURFMEM   dimoMask;
        SURFMEM   dimoShadow;

        // WINBUG #263939 3-5-2000 bhouse Watchdog timeout problems
        // We suspend the watchdog here ... GDI is brain dead and will
        // create a temporary shadow surface the size of the destination
        // mapping.  This is crazy when the destination mapping far excceeds
        // the actual size of the destination.  Maybe one day we will
        // re-write this brain dead code.... I'm not holding my breadth.
        PDEVOBJ pdoTrg(pSurfTrg()->hdev());
        
        if(pdoTrg.bDisplayPDEV())
            GreSuspendWatch(pdoTrg.ppdev, WD_DEVLOCK);

        bReturn = bRotate(dcoSrc, dimoShadow, dimoMask, ulAvec, (ULONG) jMode);

        if(pdoTrg.bDisplayPDEV())
            GreResumeWatch(pdoTrg.ppdev, WD_DEVLOCK);

        if(!bReturn)
            return(FALSE);

        //
        // Since this is going to bBitBlt, we need to create a target rectangle.
        //

        vBound(perclTrg());

        //
        // Create a region from the parallelogram and select it into the
        // clipping pipeline.  This is to make sure no bits are altered
        // outside when BitBlt is called.
        //

        if (!bCreateRegion(dcoTrg, aptfxTrg))
        {
            return(FALSE);
        }

        bReturn = bBitBlt(dcoTrg, dcoSrc, ulAvec);

        //
        // Remember to clean up after ourselves!
        //

        dcoTrg.pdc->prgnAPI(NULL);

        return(bReturn);
    }

    //
    // Get the bounding rectangle
    //

    ERECTL  erclBound;

    vBound(&erclBound);

    //
    // Adjust bounds for inclusive/inclusive
    //

    erclBound.right  += 1;
    erclBound.bottom += 1;

    //
    // Accumulate bounds.  We can do this before knowing if the operation is
    // successful because bounds can be loose.
    //

    if (dcoTrg.fjAccum())
    {
        dcoTrg.vAccumulate(erclBound);
    }

    //
    // With a fixed DC origin we can change parallelogram and rectangle to
    // SCREEN coordinates
    //

    vOffset(dcoTrg.eptlOrigin());
   *perclSrc()  += dcoSrc.eptlOrigin();
    erclBound   += dcoTrg.eptlOrigin();

    //
    // Compute the clipping complexity and maybe reduce the exclusion rectangle.
    //

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclBound);

    //
    // Check the destination which is reduced by clipping.
    //

    if (eco.erclExclude().bEmpty())
    {
        return(TRUE);
    }

    //
    // Compute the exclusion rectangle.
    //

    ERECTL erclExclude = eco.erclExclude();

    //
    // If we are going to the same source, prevent bad overlap situations
    //

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        if (perclSrc()->left   < erclExclude.left)
        {
            erclExclude.left   = perclSrc()->left;
        }

        if (perclSrc()->top    < erclExclude.top)
        {
            erclExclude.top    = perclSrc()->top;
        }

        if (perclSrc()->right  > erclExclude.right)
        {
            erclExclude.right  = perclSrc()->right;
        }

        if (perclSrc()->bottom > erclExclude.bottom)
        {
            erclExclude.bottom = perclSrc()->bottom;
        }
    }

    //
    // We might have to exclude the source or the target, get ready to do either.
    //

    DEVEXCLUDEOBJ dxo;

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());

    //
    // They can't both be display
    //

    if (dcoSrc.bDisplay())
    {
        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);

        if (dcoSrc.pSurface() == dcoTrg.pSurface())
        {
            ercl *= erclExclude;
        }
        else
        {
            ercl *= *perclSrc();
        }

        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
    }
    else if (dcoTrg.bDisplay())
    {
        dxo.vExclude(dcoTrg.hdev(),&erclExclude,&eco);
    }

    //
    // Handle target mirroring
    //

    vMirror(aptfxTrg);

    //
    // Inc the target surface uniqueness
    //

    INC_SURF_UNIQ(pSurfTrg());

    return((*PPFNGET(pdoTrg, PlgBlt, pSurfTrg()->flags()))(
        pSurfTrg()->pSurfobj(),
        pSurfSrc()->pSurfobj(),
        (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : pSurfMskOut()->pSurfobj(),
        &eco,
        pexlo()->pxlo(),
        (dcoTrg.pColorAdjustment()->caFlags & CA_DEFAULT) ?
            (PCOLORADJUSTMENT)NULL : dcoTrg.pColorAdjustment(),
        &dcoTrg.pdc->ptlFillOrigin(),
        aptfxTrg,
        perclSrc(),
        aptlMask,
        jMode));
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dimo, iMode)
*
* Rotate just the mask.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bRotate(
SURFMEM&   dimo,
ULONG      iMode)
{
    ERECTL  erclTrg;

    vBound(&erclTrg);

// Fill in the bitmap info.

    DEVBITMAPINFO   dbmi;

    dbmi.iFormat  = BMF_1BPP;
    dbmi.cxBitmap = erclTrg.right - erclTrg.left;
    dbmi.cyBitmap = erclTrg.bottom - erclTrg.top;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.fl       = pSurfMskOut()->bUMPD() ? UMPD_SURFACE : 0;

    dimo.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimo.bValid())
    {
        return(FALSE);
    }

    // Build a shadow parallelogram.

    POINTFIX    aptfxShadow[4];

    aptfxShadow[0].x = aptfxTrg[0].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[0].y = aptfxTrg[0].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[1].x = aptfxTrg[1].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[1].y = aptfxTrg[1].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[2].x = aptfxTrg[2].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[2].y = aptfxTrg[2].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[3].x = aptfxTrg[3].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[3].y = aptfxTrg[3].y - FIX_FROM_LONG(erclTrg.top);

    // Take care of mirroring.

    vMirror(aptfxShadow);

    // Call EngPlgBlt to rotate the mask.

    EPOINTL ptl(0,0);

    if (!EngPlgBlt(
                   dimo.pSurfobj(),
                   pSurfMskOut()->pSurfobj(),
                   (SURFOBJ *) NULL,
                   (CLIPOBJ *) NULL,
                   NULL,
                   NULL,
                   (POINTL *)&ptl,
                   aptfxShadow,
                   perclMask(),
                   (POINTL *) NULL,
                   iMode)
                  )
    return(FALSE);

    // Release the previous pSurfMask, tell ~BLTRECORD its gone and put the
    // new DIB in its place.  Remember to adjust the mask origin.

    flState &= ~BLTREC_MASK_LOCKED;
    pSurfMsk()->vAltUnlockFast();
    pSurfMsk((SURFACE *) dimo.ps);

    aptlMask[0].x = 0;
    aptlMask[0].y = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dcoSrc, dimoShadow, dimoMask, ulAvec, iMode)
*
* Rotate the shadow and mask.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL
BLTRECORD::bRotate(
    DCOBJ&     dcoSrc,
    SURFMEM&   dimoShadow,
    SURFMEM&   dimoMask,
    ULONG          ulAvec,
    ULONG          iMode
    )
{
    // If there is a mask, rotate it.

    if ((ulAvec & AVEC_NEED_MASK) && !bRotate(dimoMask, iMode))
    {
        return(FALSE);
    }

    ERECTL  erclTrg;

    vBound(&erclTrg);

    // Fill in the bitmap info.

    DEVBITMAPINFO   dbmi;

    dbmi.cxBitmap = erclTrg.right - erclTrg.left;
    dbmi.cyBitmap = erclTrg.bottom - erclTrg.top;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.iFormat  = pSurfSrc()->iFormat();
    dbmi.fl       = pSurfSrc()->bUMPD() ? UMPD_SURFACE : 0;

    dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimoShadow.bValid())
    {
        return(FALSE);
    }

    // Build a shadow parallelogram.

    POINTFIX    aptfxShadow[4];

    aptfxShadow[0].x = aptfxTrg[0].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[0].y = aptfxTrg[0].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[1].x = aptfxTrg[1].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[1].y = aptfxTrg[1].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[2].x = aptfxTrg[2].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[2].y = aptfxTrg[2].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[3].x = aptfxTrg[3].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[3].y = aptfxTrg[3].y - FIX_FROM_LONG(erclTrg.top);

    // Take care of mirroring.

    vMirror(aptfxShadow);

    // Now comes the tricky part.  The source may be a display.  While it may
    // be somewhat faster to assume it isn't, code would be much more complex.

    {
        // Adjust the source rectangle.

        *perclSrc() += dcoSrc.eptlOrigin();

        // Exclude the pointer.

        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);
        ercl *= *perclSrc();

        DEVEXCLUDEOBJ dxo(dcoSrc, &ercl);

        // Rotate the bits to the DIB.

        EPOINTL ptl(0,0);

        if (!EngPlgBlt(
                       dimoShadow.pSurfobj(),
                       pSurfSrc()->pSurfobj(),
                       (SURFOBJ *) NULL,
                       (CLIPOBJ *) NULL,
                       NULL,
                       NULL,
                       (POINTL *)&ptl,
                       aptfxShadow,
                       perclSrc(),
                       (POINTL *) NULL,
                       iMode)
                      )
        {
            return(FALSE);
        }

        // Update the source surface and set the source rectangle for
        // BitBlt or MaskBlt.

        pSurfSrc((SURFACE *) dimoShadow.ps);

        perclSrc()->left   = -dcoSrc.eptlOrigin().x;
        perclSrc()->top    = -dcoSrc.eptlOrigin().y;
        perclSrc()->right  = dbmi.cxBitmap - dcoSrc.eptlOrigin().x;
        perclSrc()->bottom = dbmi.cyBitmap - dcoSrc.eptlOrigin().y;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotated()
*
* Checks if the target parallelogram is skewed or rotated.
*
* History:
*  25-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bRotated()
{
    // Test for rotation or skew.

    if (
        ((aptfxTrg[1].y - aptfxTrg[0].y) != 0) ||
        ((aptfxTrg[2].x - aptfxTrg[0].x) != 0)
       )
    {
        return(TRUE);
    }

    // We might have fractional endpoints.      If so, we still need to call
    // bRotate since StretchBlt at the DDI takes integer coordinates.

    if (
        (aptfxTrg[0].x & 0x0f) || (aptfxTrg[0].y & 0x0f) ||
        (aptfxTrg[1].x & 0x0f) || (aptfxTrg[1].y & 0x0f) ||
        (aptfxTrg[2].x & 0x0f) || (aptfxTrg[2].y & 0x0f)
       )
    {
        return(TRUE);
    }

    // OK, we don't have to call bRotate.  Set up the target rectangle and
    // return FALSE.

    aptlTrg[0].x = LONG_FLOOR_OF_FIX(aptfxTrg[0].x);
    aptlTrg[0].y = LONG_FLOOR_OF_FIX(aptfxTrg[0].y);
    aptlTrg[1].x = LONG_FLOOR_OF_FIX(aptfxTrg[1].x);
    aptlTrg[1].y = LONG_FLOOR_OF_FIX(aptfxTrg[2].y);

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vExtrema()
*
* Complete the parallelogram and find the extrema.  Uses ChuckWh's trick.
*
* History:
*  28-Jan-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vExtrema()
{
    aptfxTrg[3].x = aptfxTrg[1].x + aptfxTrg[2].x - aptfxTrg[0].x;
    aptfxTrg[3].y = aptfxTrg[1].y + aptfxTrg[2].y - aptfxTrg[0].y;

    iLeft = (aptfxTrg[1].x > aptfxTrg[0].x) == (aptfxTrg[1].x > aptfxTrg[3].x);
    iTop  = (aptfxTrg[1].y > aptfxTrg[0].y) == (aptfxTrg[1].y > aptfxTrg[3].y);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vBound(percl)
*
* Make a well ordered bounding rectangle from the parallelogram
*
* History:
*  28-Jan-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vBound(ERECTL *percl)
{
    percl->left   = LONG_CEIL_OF_FIX(aptfxTrg[iLeft].x);
    percl->top    = LONG_CEIL_OF_FIX(aptfxTrg[iTop].y);
    percl->right  = LONG_CEIL_OF_FIX(aptfxTrg[iLeft ^ 3].x);
    percl->bottom = LONG_CEIL_OF_FIX(aptfxTrg[iTop ^ 3].y);

    // Make it well ordered!

    percl->vOrder();
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vMirror(pptfx)
*
* Flip the parallelogram according to the mirroring flags
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vMirror(POINTFIX *pptfx)
{
    FIX fx;

    if (flState & BLTREC_MIRROR_X)
    {
        fx = pptfx[1].x, pptfx[1].x = pptfx[0].x, pptfx[0].x = fx;
        fx = pptfx[1].y, pptfx[1].y = pptfx[0].y, pptfx[0].y = fx;
        fx = pptfx[3].x, pptfx[3].x = pptfx[2].x, pptfx[2].x = fx;
        fx = pptfx[3].y, pptfx[3].y = pptfx[2].y, pptfx[2].y = fx;
    }

    if (flState & BLTREC_MIRROR_Y)
    {
        fx = pptfx[2].x, pptfx[2].x = pptfx[0].x, pptfx[0].x = fx;
        fx = pptfx[2].y, pptfx[2].y = pptfx[0].y, pptfx[0].y = fx;
        fx = pptfx[3].x, pptfx[3].x = pptfx[1].x, pptfx[1].x = fx;
        fx = pptfx[3].y, pptfx[3].y = pptfx[1].y, pptfx[1].y = fx;
    }
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bCreateRegion(dco, pptfx)
*
* Create a region from the parallelogram and add it to the clipping
* pipeline.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bCreateRegion(
    DCOBJ&   dco,
    POINTFIX *pptfx
    )
{
    // First, take care of any mirroring that might have occured.

    vMirror(pptfx);

    // Create a path

    PATHMEMOBJ  pmo;

    if (!pmo.bValid())
    {
        return(FALSE);
    }

    // Create a parallelogram in drawing order.

    POINTL  aptl[4];

    aptl[0].x = pptfx[0].x;
    aptl[0].y = pptfx[0].y;
    aptl[1].x = pptfx[1].x;
    aptl[1].y = pptfx[1].y;
    aptl[2].x = pptfx[3].x;
    aptl[2].y = pptfx[3].y;
    aptl[3].x = pptfx[2].x;
    aptl[3].y = pptfx[2].y;

    // Construct a path around the parallelogram

    if (!pmo.bMoveTo((EXFORMOBJ *) NULL, &aptl[0]))
    {
        return(FALSE);
    }

    if (!pmo.bPolyLineTo((EXFORMOBJ *) NULL, &aptl[1], 3))
    {
        return(FALSE);
    }

    // Create a region from it.

    prmo()->vCreate(pmo, ALTERNATE);

    if (!prmo()->bValid())
    {
        return(FALSE);
    }

    // Tell ~BLTRECORD it has something to clean up.

    flState |= BLTREC_PRO;

    // Select the region into the DC's clipping pipeline.  This will dirty
    // the Rao so it gets merged in when bCompute is called.

    dco.pdc->prgnAPI(prmo()->prgnGet());

    return(TRUE);
}

#ifdef  DBG_PLGBLT
LONG gflPlgBlt = PLGBLT_ENABLE;

VOID vShowRect(
CHAR  *psz,
RECTL *prcl)
{
    if (gflPlgBlt & PLGBLT_RECTS)
    {
        DbgPrint("%s [(%ld,%ld) (%ld,%ld)]\n",
                 psz, prcl->left, prcl->top, prcl->right, prcl->bottom);
}
#endif

/******************************Public*Routine******************************\
* EngPlgBlt
*
*  This does parallelogram bltting.  This gets called to PlgBlt between
*  two engine managed surfaces or if the driver has chosen not to handle
*  EngPlgBlt.
*
*  The API passes in prclSrc which is the rectangle on the left, and
*  also passes in 3 points which define A,B,C of the paralellogram on the
*  right.  The points are assumed to be in that order A,B,C.
*  The lower-left of the src rect goes to the third point, the upper-left of
*  the src rect goes to the first point, and the upper-right of the source
*  rect goes to the second point.
*
*  NOTE! The source rectangle MUST BE WELL ORDERED IN DEVICE SPACE.
*
*   A-----B                  B                   A----------------B
*   |     |                 / \                  |                |
*   |     |     --->       /   \                 |                |
*   |     |               /     \        or      |                |
*   C-----D              A       \               |                |
*                         \       D              |                |
*                          \     /               |                |
*                           \   /                |                |
*                            \ /                 |                |
*                             C                  C----------------D
*
*
*  This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  27-Jul-1992 -by- Donald Sidoroff [donalds]
* Wrote.
\**************************************************************************/

BOOL
EngPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode)
{

    PSURFACE pSurfTrg = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMsk = SURFOBJ_TO_SURFACE(psoMsk);

    BOOL bRet = FALSE;

    //
    // Added HALFTONE support if iMode passed in is HALFTONE.
    // This is to ensure n-up printing on PCL printers
    // will look decent.
    // Note that we are currently not supporting HALFTONE
    // if there is mask.   [lingyunw]
    //
    BOOL bHalftone = ((iMode == HALFTONE) && !pSurfMsk);

    //
    // Prevent bad driver call backs
    //

    if ((iMode == 0) || (iMode > MAXSTRETCHBLTMODE))
    {
        WARNING1("EngPlgBlt: Unsupported iMode\n");
        return(FALSE);
    }

    //
    // Can't PlgBlt to an RLE
    // Can't PlgBlt to/from a JPEG or PNG
    //

    if ((pSurfTrg->iFormat() == BMF_4RLE) ||
        (pSurfTrg->iFormat() == BMF_8RLE) ||
        (pSurfTrg->iFormat() == BMF_JPEG) ||
        (pSurfSrc->iFormat() == BMF_JPEG) ||
        (pSurfTrg->iFormat() == BMF_PNG ) ||
        (pSurfSrc->iFormat() == BMF_PNG ))
    {
        WARNING("EngPlgBlt: Unsupported source/target\n");
        return(FALSE);
    }

    //
    // We may need to do a WHITEONBLACK or BLACKONWHITE from a monochrome source.
    // Find out and set the bogusity flag.
    //

    BOOL bBogus = (
                   (iMode < COLORONCOLOR) &&
                   (pSurfMsk == (SURFACE *) NULL) &&
                   ((pSurfSrc->iFormat() == BMF_1BPP) ||
                    (pSurfTrg->iFormat() == BMF_1BPP))
                  );

    if ((!bBogus) && (iMode < COLORONCOLOR))
    {
        iMode = COLORONCOLOR;
    }

    //
    // Get the LDEV's for the target and source surfaces
    //

    PDEVOBJ    pdoTrg(pSurfTrg->hdev());
    PDEVOBJ    pdoSrc(pSurfSrc->hdev());

    //
    // Set up frame variables for possible switch to temporary output surface
    //

    SURFMEM      dimoOut;
    SURFACE     *pSurfOut;
    POINTFIX     aptfxOut[4];
    POINTFIX    *pptfxOut;
    ECLIPOBJ     ecoOut;
    CLIPOBJ     *pcoOut;
    ERECTL       erclDev;
    EPOINTL      eptlDev;
    XLATEOBJ    *pxloOut;
    RGNMEMOBJTMP rmoOut;

    ERECTL       erclTrim(0, 0, pSurfSrc->sizl().cx, pSurfSrc->sizl().cy);
        
    //
    // Multimon negative offset case
    //

    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc) && (pdoSrc.bMetaDriver())))
    {
        erclTrim += *pdoSrc.pptlOrigin();
    }

    //
    // If the target is not a DIB, or the target and source are on the same
    // surface and the extents overlap, create a target DIB of the needed
    // size and format.  We will also create a target DIB if we need to do
    // the evil BLACKONWHITE or WHITEONBLACK modes.
    //

    if ( !bBogus &&
         (pSurfTrg->iType() == STYPE_BITMAP) &&
         (pSurfTrg->hsurf() != pSurfSrc->hsurf()) &&
         !bHalftone )
    {
        pSurfOut   = pSurfTrg;
        pptfxOut = pptfx;
        pcoOut   = pco;
    }
    else
    {
        aptfxOut[0] = pptfx[0];
        aptfxOut[1] = pptfx[1];
        aptfxOut[2] = pptfx[2];
        aptfxOut[3].x = pptfx[1].x + pptfx[2].x - pptfx[0].x;
        aptfxOut[3].y = pptfx[1].y + pptfx[2].y - pptfx[0].y;

        //
        // Compute the extrema
        //

        int iLeft = (aptfxOut[1].x > aptfxOut[0].x) == (aptfxOut[1].x > aptfxOut[3].x);
        int iTop  = (aptfxOut[1].y > aptfxOut[0].y) == (aptfxOut[1].y > aptfxOut[3].y);

        if (aptfxOut[iLeft].x > aptfxOut[iLeft ^ 3].x)
        {
            iLeft ^= 3;
        }

        if (aptfxOut[iTop].y > aptfxOut[iTop ^ 3].y)
        {
            iTop ^= 3;
        }

        //
        // This will be the area we copy dimoOut to in the target surface.
        //

        erclDev.left   = LONG_FLOOR_OF_FIX(aptfxOut[iLeft].x) - 1;
        erclDev.top    = LONG_FLOOR_OF_FIX(aptfxOut[iTop].y) - 1;
        erclDev.right  = LONG_CEIL_OF_FIX(aptfxOut[iLeft ^ 3].x) + 1;
        erclDev.bottom = LONG_CEIL_OF_FIX(aptfxOut[iTop ^ 3].y) + 1;

        //
        // Trim to the target surface.
        //

        ERECTL  erclTrg(0, 0, pSurfTrg->sizl().cx, pSurfTrg->sizl().cy);

        //
        // Multimon negative offset case
        //
    
        if ((pdoTrg.bValid()) && (pdoTrg.bPrimary(pSurfTrg) && (pdoTrg.bMetaDriver())))
        {
            erclTrg += *pdoTrg.pptlOrigin();
        }
        
        erclDev *= erclTrg;

        //
        // If we have nothing left, we're done.
        //

        if (erclDev.bEmpty())
        {
            return(TRUE);
        }

        //
        // If we are only here on possible overlap, test for misses
        //

        if ( !bBogus &&
             (pSurfTrg->iType() == STYPE_BITMAP) &&
             (!bHalftone) &&
             (  (erclDev.left > prcl->right) ||
                (erclDev.right < prcl->left) ||
                (erclDev.top > prcl->bottom) ||
                (erclDev.bottom < prcl->top) ) )
        {
            pSurfOut   = pSurfTrg;
            pptfxOut = pptfx;
            pcoOut   = pco;
        }
        else
        {
            // Compute the adjusted parallelogram in the temporary surface.

            aptfxOut[0].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[0].y -= FIX_FROM_LONG(erclDev.top);
            aptfxOut[1].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[1].y -= FIX_FROM_LONG(erclDev.top);
            aptfxOut[2].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[2].y -= FIX_FROM_LONG(erclDev.top);

            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclDev.right - erclDev.left + 1;
            dbmi.cyBitmap = erclDev.bottom - erclDev.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.iFormat  = pSurfTrg->iFormat();
            dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

            //
            // If this is a bogus call, build a monochrome target.
            //

            if (bBogus)
            {
                dbmi.iFormat = BMF_1BPP;
            }
            else if (bHalftone)
            {
               //
               // if HALFTONE, make the target same format as source
               // so latter on we can stretch with HALFTONE
               //
               dbmi.iFormat = pSurfSrc->iFormat();
            }

            dimoOut.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoOut.bValid())
            {
                return(FALSE);
            }

            //
            // What point in the target surface is 0,0 in temporary surface.
            //

            eptlDev = *((EPOINTL *) &erclDev);

            //
            // Build a CLIPOBJ for the new surface.
            //

            if (!rmoOut.bValid())
            {
                return(FALSE);
            }

            erclDev.left    = 0;
            erclDev.top     = 0;
            erclDev.right  -= eptlDev.x;
            erclDev.bottom -= eptlDev.y;

            rmoOut.vSet((RECTL *) &erclDev);

            ecoOut.vSetup(rmoOut.prgnGet(), erclDev, CLIP_FORCE);

            //
            // Synchronize with the device driver before touching the device surface.
            //

            pdoTrg.vSync(psoTrg,NULL,0);

            //
            // If there is a mask, copy the actual target to the temporary.
            //

            if (pSurfMsk != (SURFACE *) NULL)
            {
                (*PPFNGET(pdoTrg,CopyBits,pSurfTrg->flags()))(
                          dimoOut.pSurfobj(),
                          pSurfTrg->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &erclDev,
                          &eptlDev);

            }

            //
            // If we are doing BLACKONWHITE or WHITEONBLACK we need to
            // initialize the DIB appropriately.
            //

            if (bBogus)
            {
                if (!EngEraseSurface(dimoOut.pSurfobj(),
                                     &erclDev,
                                     iMode == BLACKONWHITE ? ~0L : 0L))
                    return(FALSE);
            }

            //
            // Point to the new target.
            //

            pSurfOut   = dimoOut.ps;
            pptfxOut   = &aptfxOut[0];
            pcoOut     = &ecoOut;

            if ((bBogus && (pSurfSrc->iFormat() == BMF_1BPP)) || bHalftone)
            {
                pxloOut = pxlo;
                pxlo    = NULL;
            }
            else
            {
                pxloOut = &xloIdent;
            }
        }
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    pdoSrc.vSync(psoSrc,NULL,0);

    //
    // Compute what area of the source surface will actually be used.  We do
    // this so we never read off the end of the surface and fault or worse,
    // write bad pixels onto the target. Trim the source rectangle to the
    // source surface.
    //

    erclTrim *= *prcl;

    // WINBUG #263939 3-5-2000 bhouse Watchdog timeout problems
    // We suspend the watchdog here ... This code is just brain
    // dead and for various scenarios can cause us to hang within GDI
    // giving false positive WatchDog timeouts.  Maybe one day we will
    // re-write this brain dead code.... I'm not holding my breadth.

    if(pdoTrg.bValid() && pdoTrg.bDisplayPDEV())
        GreSuspendWatch(pdoTrg.ppdev, WD_DEVLOCK);
    
    if(pdoSrc.bValid() && pdoSrc.bDisplayPDEV())
        GreSuspendWatch(pdoSrc.ppdev, WD_DEVLOCK);

    //
    // If we have nothing left, we're done.
    //

    if (erclTrim.bEmpty())
    {
         bRet = TRUE;
    }
    else
    {
        //
        // Now we must worry about the source surface.  Its possible we are blitting
        // from an RLE to the VGA for instance.  We convert the surface to the same
        // bitmap format as the target for convience.
        //

        SURFMEM     dimoIn;
        SURFACE    *pSurfIn;
        RECTL       rclIn;
        RECTL      *prclIn;
        XLATEOBJ   *pxloIn;

        if (! ((pSurfSrc->iType() != STYPE_BITMAP) ||
               (pSurfSrc->iFormat() == BMF_4RLE)   ||
               (pSurfSrc->iFormat() == BMF_8RLE) )
           )
        {
            pSurfIn  = pSurfSrc;

            pxloIn = pxlo;

            prclIn = prcl;
        }
        else
        {
            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclTrim.right - erclTrim.left + 1;
            dbmi.cyBitmap = erclTrim.bottom - erclTrim.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.iFormat  = pSurfOut->iFormat();
            dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

            dimoIn.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoIn.bValid())
            {
                bRet = FALSE;
                goto exit;
            }

            // The cursor should already be excluded at this point, so just copy
            // to the DIB.

            rclIn.left   = 0;
            rclIn.top    = 0;
            rclIn.right  = erclTrim.right - erclTrim.left;
            rclIn.bottom = erclTrim.bottom - erclTrim.top;

            (*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                     dimoIn.pSurfobj(),
                     pSurfSrc->pSurfobj(),
                     (CLIPOBJ *) NULL,
                     pxlo,
                     &rclIn,
                     (POINTL *) &erclTrim);

            // Point at the new source

            rclIn.left   = prcl->left   - erclTrim.left;
            rclIn.top    = prcl->top    - erclTrim.top;
            rclIn.right  = prcl->right  - erclTrim.left;
            rclIn.bottom = prcl->bottom - erclTrim.top;

            pSurfIn  = dimoIn.ps;
            pxloIn = NULL;
            prclIn = &rclIn;

            // Adjust the trimmed source origin and extent

            erclTrim.right  -= erclTrim.left;
            erclTrim.bottom -= erclTrim.top;
            erclTrim.left = 0;
            erclTrim.top  = 0;
        }

        // Synchronize with the device driver before touching the device surface.

        {
            PDEVOBJ po(pSurfOut->hdev());
            po.vSync(pSurfOut->pSurfobj(),NULL,0);
        }

        //
        // Initialize the DDA
        //

        PLGDDA   *pdda = (PLGDDA *)PALLOCMEM(sizeof(PLGDDA),'addG');
        if (pdda)
        {
            if (!bInitPlgDDA(pdda, (RECTL *) &erclTrim, prclIn, pptfxOut))
            {
                bRet = TRUE;
            }
            else
            {
                PFN_PLGREAD     pfnRead  = apfnRead[pSurfIn->iFormat()];
                PFN_PLGWRITE    pfnWrite;
                PLGRUN         *prun;
                LONG            cjSpace = lSizeDDA(pdda) * (erclTrim.right - erclTrim.left + 2);

                if (bBogus)
                {
                    pdda->bOverwrite = TRUE;
                    pfnWrite = apfnBogus[iMode];
                }
                else
                {
                    pdda->bOverwrite = FALSE;
                    pfnWrite = apfnWrite[pSurfOut->iFormat()];
                }

                if (prun = (PLGRUN *) PALLOCMEM(cjSpace,'addG'))
                {
                    BYTE    *pjSrc = (BYTE *) pSurfIn->pvScan0() + pSurfIn->lDelta() * erclTrim.top;
                    BYTE    *pjMask;
                    POINTL   ptlMask;

                    if (pSurfMsk == (SURFACE *) NULL)
                    {
                        pjMask = (BYTE *) NULL;
                    }
                    else
                    {
                        ptlMask.x = erclTrim.left - prclIn->left + pptl->x;
                        ptlMask.y = erclTrim.top  - prclIn->top  + pptl->y;

                        pjMask = (BYTE *) pSurfMsk->pvScan0() + pSurfMsk->lDelta() * ptlMask.y;
                    }

                    // See if we can accelerate anything.

                    if ((pxloIn != NULL) && (pxloIn->flXlate & XO_TRIVIAL))
                    {
                        pxloIn = NULL;
                    }

                    //
                    // force DDA into clipping to destination surface!, this can be
                    // removed once dda doesn't go negatice!
                    //

                    if ((pcoOut == NULL) || (pcoOut->iDComplexity == DC_TRIVIAL))
                    {
                        ERECTL erclDest(0,0,pSurfOut->sizl().cx,pSurfOut->sizl().cy);

                        rmoOut.vSet((RECTL *) &erclDest);
                        ecoOut.vSetup(rmoOut.prgnGet(), erclDest, CLIP_FORCE);
                        pcoOut = &ecoOut;
                    }

                    //
                    // make sure it doesn't have a empty rectangle
                    //
                    if ((pcoOut->rclBounds.left < pcoOut->rclBounds.right) &&
                        (pcoOut->rclBounds.top < pcoOut->rclBounds.bottom))
                    {
                       for (LONG yRow = erclTrim.top; yRow < erclTrim.bottom; yRow++)
                       {
                           pdda->dsX = pdda->ds;

                           (*pfnWrite)(prun,
                                       (*pfnRead)(pdda,
                                                  prun,
                                                  pjSrc,
                                                  pjMask,
                                                  pxloIn,
                                                  erclTrim.left,
                                                  erclTrim.right,
                                                  ptlMask.x),
                                       pSurfOut,
                                       pcoOut);

                           vAdvYDDA(pdda);
                           pjSrc += pSurfIn->lDelta();

                           if (pjMask != (BYTE *) NULL)
                           {
                               pjMask += pSurfMsk->lDelta();
                           }
                       }

                       VFREEMEM(prun);

                       //
                       // See if we have drawn on the actual output surface.
                       //

                       if (pSurfOut == pSurfTrg)
                       {
                           bRet = TRUE;
                       }
                       else
                       {
                           BOOL bTmpRet = FALSE;

                           //
                           // If the source rectangle was reduced, then we have to
                           // create a mask for the target, so only the actual pels
                           // effected by the PlgBlt will be altered on the target.

                           SURFMEM     dimoMask;
                           SURFACE    *pSurfMask;

                           if (((prcl->right - prcl->left) == erclTrim.right) &&
                               ((prcl->bottom - prcl->top) == erclTrim.bottom) )
                           {
                               pSurfMask = (SURFACE *) NULL;
                               bTmpRet = TRUE;
                           }
                           else
                           {
                               DEVBITMAPINFO   dbmi;

                               dbmi.cxBitmap = erclDev.right + 1;
                               dbmi.cyBitmap = erclDev.bottom + 1;
                               dbmi.hpal     = (HPALETTE) 0;
                               dbmi.iFormat  = BMF_1BPP;
                               dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

                               dimoMask.bCreateDIB(&dbmi, (VOID *) NULL);

                               if (dimoMask.bValid())
                               {
                                   SURFMEM   dimoTrim;

                                   dbmi.cxBitmap = erclTrim.right;
                                   dbmi.cyBitmap = erclTrim.bottom;
                                   dbmi.hpal     = (HPALETTE) 0;
                                   dbmi.iFormat  = BMF_1BPP;
                                   dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

                                   dimoTrim.bCreateDIB(&dbmi, (VOID *) NULL);

                                   RGNMEMOBJTMP rmoMask;

                                   if (dimoTrim.bValid() &&
                                       rmoMask.bValid() )
                                   {
                                       rmoMask.vSet((RECTL *) &erclDev);

                                       ECLIPOBJ    ecoMask(rmoMask.prgnGet(), erclDev, CLIP_FORCE);

                                       //
                                       // Initialize the two bitmaps and call EngPlgBlt to create a pel
                                       // perfect mask for the reduced call.
                                       //

                                       if (EngEraseSurface(dimoMask.pSurfobj(),
                                                           &erclDev,
                                                           0L)                  &&
                                           EngEraseSurface(dimoTrim.pSurfobj(),
                                                           &erclTrim,
                                                           (ULONG)~0L)          &&
                                           EngPlgBlt(dimoMask.pSurfobj(),
                                                     dimoTrim.pSurfobj(),
                                                     (SURFOBJ *) NULL,
                                                     &ecoMask,
                                                     NULL,
                                                     (COLORADJUSTMENT *) NULL,
                                                     (POINTL *) NULL,
                                                     pptfxOut,
                                                     prclIn,
                                                     (POINTL *) NULL,
                                                     COLORONCOLOR) )
                                       {

                                           pSurfMask = dimoMask.ps;
                                           bTmpRet = TRUE;
                                       }
                                   }
                               }
                           }

                           // If we had to draw the target on a shadow, we need to copy it to the
                           // actual surface.  Since we don't clip to the shadow buffer, we need
                           // to merge the parallelogram into the clipobj and clip against this
                           // and call BitBlt.

                           PATHMEMOBJ  pmo;

                           if (bTmpRet &&
                               pmo.bValid())
                           {
                               //
                               // Create a parallelogram in drawing order.
                               //

                               POINTL  aptl[4];

                               aptl[0].x = pptfx[0].x;
                               aptl[0].y = pptfx[0].y;
                               aptl[1].x = pptfx[1].x;
                               aptl[1].y = pptfx[1].y;
                               aptl[2].x = pptfx[1].x + pptfx[2].x - pptfx[0].x;
                               aptl[2].y = pptfx[1].y + pptfx[2].y - pptfx[0].y;;
                               aptl[3].x = pptfx[2].x;
                               aptl[3].y = pptfx[2].y;

                               //
                               // Construct a path around the parallelogram
                               //

                               if ( (pmo.bMoveTo((EXFORMOBJ *) NULL, &aptl[0])) &&
                                    (pmo.bPolyLineTo((EXFORMOBJ *) NULL, &aptl[1], 3)) )
                               {
                                   //
                                   // Create a regions from it.
                                   //

                                   RGNMEMOBJTMP rmo(pmo, ALTERNATE);
                                   RGNMEMOBJTMP rmoTrg;

                                   if ( (rmo.bValid()) &&
                                        (rmoTrg.bValid()) )
                                   {
                                       //
                                       // Merge the region we just constructed with the clip region.
                                       //

                                       if ( ((pco == (CLIPOBJ *) NULL) &&
                                             (rmoTrg.bCopy(rmo)))             ||
                                            ((pco != (CLIPOBJ *) NULL) &&
                                             (rmoTrg.bMerge(rmo,
                                                            *((ECLIPOBJ *)pco),
                                                            gafjRgnOp[RGN_AND])))  )
                                       {

                                           ERECTL  ercl;

                                           rmoTrg.vGet_rcl(&ercl);

                                           // If we have a clipobj,
                                           // make sure that the bounds are 
                                           // tight to the destination rectangle
                                           // and there is intersection.
                                           if ((pco == NULL) ||
                                               bIntersect(&ercl, &pco->rclBounds, &ercl))
                                           {
                                               ECLIPOBJ eco(rmoTrg.prgnGet(), ercl, CLIP_FORCE);

                                               if (!eco.erclExclude().bEmpty())
                                               {
                                                   //
                                                   // Copy from the temporary to the target surface.
                                                   //

                                                   erclDev.left   += eptlDev.x;
                                                   erclDev.top    += eptlDev.y;
                                                   erclDev.right  += eptlDev.x;
                                                   erclDev.bottom += eptlDev.y;
                                                   eptlDev.x       = 0;
                                                   eptlDev.y       = 0;

                                                   //
                                                   // Inc the target surface uniqueness
                                                   //

                                                   INC_SURF_UNIQ(pSurfTrg);

                                                   if (!bHalftone)
                                                   {
                                                      (*(pSurfTrg->pfnBitBlt()))(
                                                          pSurfTrg->pSurfobj(),
                                                          dimoOut.pSurfobj(),
                                                          pSurfMask->pSurfobj(),
                                                          &eco,
                                                          pxloOut,
                                                          &erclDev,
                                                          &eptlDev,
                                                          &eptlDev,
                                                          (BRUSHOBJ *) NULL,
                                                          (POINTL *) NULL,
                                                          pSurfMask == (SURFACE *) NULL ? 0x0000CCCC : 0x0000AACC);
                                                   }
                                                   else
                                                   {
                                                      POINTL ptlBrushOrg;
                                                      ERECTL erclSrc(0, 0,
                                                                     erclDev.right-erclDev.left,
                                                                     erclDev.bottom-erclDev.top);

                                                      ptlBrushOrg.x=0; ptlBrushOrg.y=0;

                                                      (*PPFNGET(pdoTrg, StretchBlt, pSurfTrg->flags()))(
                                                          pSurfTrg->pSurfobj(),
                                                          dimoOut.pSurfobj(),
                                                          pSurfMask->pSurfobj(),
                                                          &eco,
                                                          pxloOut,
                                                          NULL,
                                                          &ptlBrushOrg,
                                                          &erclDev,
                                                          &erclSrc,
                                                          &eptlDev,
                                                          HALFTONE);
                                                   }
                                               }
                                           }

                                           bRet = TRUE;
                                       }
                                   }
                               }
                           }
                       }
                    }
                    else
                    {
                        VFREEMEM(prun);
                    }
                }
            }

            VFREEMEM(pdda);
        }

    }

exit:

    if(pdoTrg.bValid() && pdoTrg.bDisplayPDEV())
        GreResumeWatch(pdoTrg.ppdev, WD_DEVLOCK);

    if(pdoSrc.bValid() && pdoSrc.bDisplayPDEV())
        GreResumeWatch(pdoSrc.ppdev, WD_DEVLOCK);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pftobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pftobj.cxx                                                  *
*                                                                          *
* Non-inline methods for physical font table objects.                      *
*                                                                          *
* Created: 30-Oct-1990 09:32:48                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
*  Tue 09-Aug-1994 10:04:09 by Kirk Olynyk [kirko]                         *
* Prior to build ### there was only a single font table on which all       *
* fonts, be they public (engine) or device, where attached. I have         *
* changed the font architecture so that there will be two font tables.     *
* One for public fonts and the other font device fonts. The public font    *
* table will be string based. That is, the fonts were added to this        *
* using GreAddFontResourceW() with the name of the associated font file.   *
* The name of the font file and path will be hashed and the font files     *
* will hang off of the collision list. The number of hash buckets is       *
* set at boot time.                                                        *
*                                                                          *
* The device font table will be for device fonts (suprise).                *
* In this case the fonts will be placed in hash collisions                 *
* lists depending upon the value of their hdev.                            *
*                                                                          *
* Copyright (c) 1994-1999 Microsoft Corporation                            *
*                                                                          *
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitFontTables();
extern "C" void vQueryRegistryForNumberOfBuckets(unsigned *, unsigned *);

#pragma alloc_text(INIT, bInitFontTables)
#pragma alloc_text(INIT, vQueryRegistryForNumberOfBuckets)

#define  CPRIVATEBUCKETS     20

PFT *gpPFTPublic;       // global public font table (for font drivers)
PFT *gpPFTDevice;       // global device font table (for printers)
PFT *gpPFTPrivate = PPFTNULL;   // global public talbe for private fonts, init as NULL

#ifdef LANGPACK
UINT PFFOBJ::uGlobalUniqueness = 0;
#endif

LARGE_INTEGER PFTOBJ::FontChangeTime;    // time of most recent addition or
                                         // removal of a font file
// Definitions for local functions used to remove font files from system.

static RFONT*      prfntKillList(PFFOBJ &);
static BOOL        bKillRFONTList(PFFOBJ &, RFONT *);
static UINT        iHash(const WCHAR *, UINT);


/******************************Public*Routine******************************\
* pAllocateAndInitializePFT                                                *
*                                                                          *
*   Allocates and initializes a font table with cBuckets                   *
*   This allows the public (engine) font table and the device              *
*   font table to share the same code.                                     *
*                                                                          *
*   input:  cBuckets = number of members in allocated PFF* table           *
*   output: address of new PFT                                             *
*                                                                          *
*   Notes:                                                                 *
*                                                                          *
*   it is not necessary to check for error in the creation                 *
*   of the hash tables because the system will still work                  *
*                                                                          *
*   error:  return 0                                                       *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 07:41:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

PFT *pAllocateAndInitializePFT(unsigned cBuckets)
{
    PFT *pPFT;

    register ULONGSIZE_T size = offsetof(PFT, apPFF) + cBuckets * sizeof(PFF*);
    if (pPFT = (PFT*) PALLOCMEM(size, 'tfpG'))
    {
        pPFT->cBuckets       = cBuckets;
        pPFT->cFiles         = 0;
    }
    return(pPFT);
}

// strings used to identify values stored in the registry

static CONST PWSZ pwszP0 =  L"NumberOfPublicFontFilesAtLastLogOff";
static CONST PWSZ pwszP1 =  L"NumberOfPublicFontFilesSetByUser";
static CONST PWSZ pwszD0 =  L"NumberOfDeviceFontFilesAtLastLogOff";
static CONST PWSZ pwszD1 =  L"NumberOfDeviceFontFilesSetByUser";
static CONST PWSZ pwszFC =
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontCache";

// Define some default values in case the registry numbers are bogus

#define MIN_PUBLIC_BUCKETS 100
#define MAX_PUBLIC_BUCKETS 10000
#define MIN_DRIVER_BUCKETS 5
#define MAX_DRIVER_BUCKETS 100

// PIR :== Put In Range

#define PIR(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))



/******************************Public*Routine******************************\
* vQueryRegistryForNumberOfBuckets
*
* Gets from the registry the number of buckets needed for the public
* and driver font tables.
*
* History:
*  Mon 26-Sep-1994 09:59:52 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" void vQueryRegistryForNumberOfBuckets(
    unsigned *puPublic      // recieves # buckets for Public fonts
  , unsigned *puDevice      // recieves # buckets for Device fonts
  )
{

    RTL_QUERY_REGISTRY_TABLE QueryTable[5];
    HANDLE hDevMode;
    DWORD Status;

    ULONG cPublicBucketsSys  = 0;
    ULONG cPublicBucketsUser = 0;
    ULONG cDeviceBucketsSys  = 0;
    ULONG cDeviceBucketsUser = 0;

    //
    // Initialize registry query table.
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[0].Name = L"NumberOfPublicFontFilesAtLastLogOff";
    QueryTable[0].EntryContext = &cPublicBucketsSys;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[1].Name = L"NumberOfPublicFontFilesSetByUser";
    QueryTable[1].EntryContext = &cPublicBucketsUser;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[2].Name = L"NumberOfDeviceFontFilesAtLastLogOff";
    QueryTable[2].EntryContext = &cDeviceBucketsSys;
    QueryTable[2].DefaultType = REG_NONE;
    QueryTable[2].DefaultData = NULL;
    QueryTable[2].DefaultLength = 0;

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[3].Name = L"NumberOfDeviceFontFilesSetByUser";
    QueryTable[3].EntryContext = &cDeviceBucketsUser;
    QueryTable[3].DefaultType = REG_NONE;
    QueryTable[3].DefaultData = NULL;
    QueryTable[3].DefaultLength = 0;

    QueryTable[4].QueryRoutine = NULL;
    QueryTable[4].Flags = 0;
    QueryTable[4].Name = NULL;

    //
    // If the open was succesdsful, then query the registry for the
    // specified printer.
    //

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontCache",
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status))
    {
        WARNING1("vQueryRegistryForNumberOfBuckets failure\n");
    }
    else
    {
        if (!cPublicBucketsUser)
        {
            cPublicBucketsUser = cPublicBucketsSys;
        }
        if (!cDeviceBucketsUser)
        {
            cDeviceBucketsUser = cDeviceBucketsSys;
        }
    }
    *puPublic = PIR(cPublicBucketsUser, MIN_PUBLIC_BUCKETS, MAX_PUBLIC_BUCKETS);
    *puDevice = PIR(cDeviceBucketsUser, MIN_DRIVER_BUCKETS, MAX_DRIVER_BUCKETS);
}


/******************************Public*Routine******************************\
* BOOL bInitFontTables                                                    *
*                                                                          *
* Create the global public PFT and driver PFT                              *
*                                                                          *
* Create the public PFT semaphore to serialize access to both the          *
* public and driver font tables and their releated PFF's and PFE's         *
* Access to the RFONT's (realized font instances) are regulated            *
* by a separate semaphore.                                                 *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 07:07:27 by Kirk Olynyk [kirko]                         *
* Made it allocate both the public and driver font tables. Both            *
* allocations and initializations are done by a common routine.            *
*  21-Jan-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" BOOL bInitFontTables()
{
    unsigned cPublicBuckets;
    unsigned cDeviceBuckets;
    register BOOL bRet = FALSE;

    vQueryRegistryForNumberOfBuckets(&cPublicBuckets, &cDeviceBuckets);
    if (
    bRet = (
        (gpPFTPublic    = pAllocateAndInitializePFT(cPublicBuckets))
     && (gpPFTDevice    = pAllocateAndInitializePFT(cDeviceBuckets))
     && (ghsemPublicPFT = GreCreateSemaphore())
     && (ghsemGlyphSet = GreCreateSemaphore())
     && (ghsemPrintKView = GreCreateSemaphore()))
    )
    {
       FHMEMOBJ fhmo1(&gpPFTPublic->pfhFace  , FHT_FACE  , cPublicBuckets);
       FHMEMOBJ fhmo2(&gpPFTPublic->pfhFamily, FHT_FAMILY, cPublicBuckets);
       FHMEMOBJ fhmo3(&gpPFTPublic->pfhUFI, FHT_UFI, cPublicBuckets);
    }

    #if DBG
        if (!bRet)
        {
            if (!gpPFTPublic)       WARNING("gpPFTPublic == 0\n");
            if (!gpPFTDevice)       WARNING("gpPFTDevice == 0\n");
            if (!ghsemPublicPFT)    WARNING("ghsemPublicPFT == 0\n");
        }
    #endif

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL bInitPrivatePFT                                                     *
*                                                                          *
* Create the global private PFT                                            *
*                                                                          *
* Create the semaphore for the private PFT to serialize access             *
* to the private PFT and its releated PFF's and PFE's                      *
* Access to the RFONT's (realized font instances) are regulated            *
* by a separate semaphore.                                                 *
*                                                                          *
* History:                                                                 *
*  10-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bInitPrivatePFT()
{
    register BOOL bRet = FALSE;

    SEMOBJ sem(ghsemPublicPFT);

    if (gpPFTPrivate)
        return TRUE;


    if ( bRet = ((gpPFTPrivate = pAllocateAndInitializePFT(CPRIVATEBUCKETS)) != PPFTNULL )  )
    {
       FHMEMOBJ fhmo1(&gpPFTPrivate->pfhFace  , FHT_FACE  , CPRIVATEBUCKETS);
       FHMEMOBJ fhmo2(&gpPFTPrivate->pfhFamily, FHT_FAMILY, CPRIVATEBUCKETS);
       FHMEMOBJ fhmo3(&gpPFTPrivate->pfhUFI, FHT_UFI, CPRIVATEBUCKETS);
    }

#if DBG
    if (!bRet)
    {
        if (!gpPFTPrivate)      WARNING("gpPFTPrivate== 0\n");
    }
#endif

    return(bRet);
}


/******************************Public*Routine******************************\
* VOID  vCleanupPrivateFonts()                                             *
*                                                                          *
* Clean up the PFF for the dying process pid                               *
*                                                                          *
* History:                                                                 *
*  01-Oct-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

VOID vCleanupPrivateFonts()
{
    ULONG i;
    PFF  *pPFF, **ppPFF, **ppPFFHead;

    // We have seen some stress failures on the Hydra system
    // that ghsemPublicPFT was not even initialized

    if (ghsemPublicPFT)
    {
        GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

        PUBLIC_PFTOBJ  pftop(gpPFTPrivate);

        if (pftop.bValid())
        {
            //fonts loaded as private

            ppPFFHead = gpPFTPrivate->apPFF;

            for (i=0; i < CPRIVATEBUCKETS; i++)
            {
                ppPFF = ppPFFHead;
                pPFF = *ppPFFHead;

                while ( pPFF )
                {
                    PFF *pPFFNextVictim = pPFF->pPFFNext;

                    // bUnloadWorkhorse should release ghsemPublicPFT

                    if ( pftop.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, FRW_PVT_CLEANUP) )
                    {
                        GreQuerySystemTime( &PFTOBJ::FontChangeTime );
                    }

                    pPFF = pPFFNextVictim;

                    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);
                }

                ppPFFHead++;
            }
        }

        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }
}

/******************************Public*Routine******************************\
* BOOL PFTOBJ::bDelete()                                                  *
*                                                                          *
* Destroy the PFT physical font table object.                              *
*                                                                          *
*   If this method succeeds the pointer to the public font table is        *
* set to 0 and then this method returns TRUE. If the table contains        *
* any files, then this method will fail and return FALSE.                  *
*                                                                          *
* History:                                                                 *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFTOBJ::bDelete()
{
    if (pPFT->cFiles == 0)
    {
        VFREEMEM(pPFT);
        pPFT = 0;
    }
    else
    {
        WARNING("gdisrv!bDeletePFTOBJ(): cFiles != 0");
    }
    return(!pPFT);
}

/******************************Public*Routine******************************\
* PFTOBJ::chpfeIncrPFF                                                     *
*                                                                          *
* If this was an attempt to load a font that was embeded and the           *
* client ID didn't match that in the *.fot file FALSE will be              *
* return via pbEmbedStatus ortherwise TRUE is returned.                    *
*                                                                          *
* If found, the load count of the PFF is incremented.                      *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT                            *
*   semaphore when calling this routine in order                           *
*   to access the table and load count.                                    *
*                                                                          *
* Returns:                                                                 *
*   Number of PFEs in the PFF, 0 if PFF not found.                         *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 13:37:11 by Kirk Olynyk [kirko]                         *
* The PFF has been found up front and is guaranteed to exist.              *
* I have removed the check to see if it is a device font. This check       *
* is now redundant because you can tell if it is a device font by the      *
* table that you are on. If device fonts cannot be loaded via              *
* AddFontResouce, then this function should not be called for a            *
* device font.                                                             *
*  28-Jun-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

COUNT PFTOBJ::chpfeIncrPFF(
   PFF    *pPFF,               // address of PFF to be, incremented
   BOOL   *pbEmbedStatus,      // tried to load an embeded font illegally
   ULONG  flEmbed,
   PEUDCLOAD pEudcLoadData   // PFE's in file if EUDC
    )
{
    // Caller should be holding ghsemPublicPFT semaphore!

    BOOL bEUDC = ( pEudcLoadData != NULL );

    COUNT cRet = 0;
    PFFOBJ pffo(pPFF);
    if (!pffo.bValid())
    {
        RIP("Invalid PFFOBJ\n");
    }
    else
    {
        if ((bEUDC && pffo.bEUDC()) || (!bEUDC && !pffo.bEUDC()) )
        {
            *pbEmbedStatus = !bIsPrivatePFT() || pffo.bAddPvtData(flEmbed);

            if(*pbEmbedStatus)
            {
                    if(bEUDC)
                    {
                        if((pEudcLoadData->LinkedFace == NULL) &&
                           (pffo.cFonts() > 2))
                        {
                            // EUDC font file can have at most two fonts (one regular
                            // and one @) unless the user specifies a face name.
                            // we return failure by setting embed status to false

                            *pbEmbedStatus = FALSE;

                            // return non-zero so calling function returns right away

                            return(1);
                        }
                        pffo.vGetEUDC(pEudcLoadData);
                    }

                    if (!bIsPrivatePFT())
                    {
                        pffo.vLoadIncr(flEmbed);
                    }

                    cRet = pffo.cFonts();
            }
            else
            {
                cRet = ~cRet;
                ASSERTGDI(cRet,
                    "cRet should be non zero so calling function"
                    " will return right away\n");
            }
        }
    }
    return(cRet);
}

/******************************Public*Routine******************************\
* PFTOBJ::pPFFGet                                                          *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT semaphore when             *
*   this method calling this in order to guarantee a stable font           *
*   table.                                                                 *
*   Note that since all the strings in the table are in upper case         *
*   and the input string must be upper case, we are allowed to             *
*   compare strings with the faster case sensitive compare                 *
*   wcscmp().                                                              *
*                                                                          *
* Returns:                                                                 *
*   PPFF of the PFF if found, (PPFF) NULL if the PFF not found.            *
*                                                                          *
* History:                                                                 *
*  Thu 04-Aug-1994 08:18:27 by Kirk Olynyk [kirko]                         *
* Modified to make the public font table hash based                        *
*  06-May-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

PPFF PUBLIC_PFTOBJ::pPFFGet (
    PWSZ pwszPathname   // address of upper case string
  , ULONG cwc
  , ULONG cFiles
  , DESIGNVECTOR *pdv
  , ULONG         cjDV
  , PFF ***pppPFF       // write address of bucket here
  , BOOL bEUDC          // be true if EUDC
  )
{
    PFF *pPFF, **ppPFF;

// it is enough to hash on the first file only, no need to include the
// second and or third file to the hashing routine [bodind]

    ppPFF = pPFT->apPFF + iHash(pwszPathname,pPFT->cBuckets);
    if (pppPFF)
    {
        *pppPFF = ppPFF;
    }

    pPFF = *ppPFF;

    while(pPFF)
    {
        if
        ((bEUDC == ((pPFF->flState & PFF_STATE_EUDC_FONT) != 0)) &&
        (cwc == pPFF->cwc) && (cFiles == pPFF->cFiles) &&
        !memcmp(pPFF->pwszPathname_, pwszPathname, cwc * sizeof(WCHAR)) &&
        (cjDV == pPFF->cjDV_) &&
        (!cjDV || !memcmp(pdv, pPFF->pdv_, pPFF->cjDV_))
        )
        {
            break;
        }
        pPFF = pPFF->pPFFNext;
    }

    return(pPFF);
}


/**********************Public*Routine***************************\
* PFTOBJ::pPFFGetMM                                             *
*                                                               *
* Note:                                                         *
*   Caller should be holding the ghsemPublicPFT semaphore       *
*   when this method calling this in order to guarantee         *
*   a stable font table. Also this should only be called        *
*   when we remove the memory fonts.                            *
*                                                               *
*   We check the PFF_STATE_MEMORY_FONT flag, the ulCheckSum     *
*   and the process ID                                          *
*                                                               *
* Returns:                                                      *
*   PPFF of the PFF if found, (PPFF) NULL if not found.         *
*                                                               *
* History:                                                      *
*  12-Jun-1997  -by-    Xudong Wu [TessieW]                     *
* Wrote it.                                                     *
\***************************************************************/
PPFF PUBLIC_PFTOBJ::pPFFGetMM
(
    ULONG   ulCheckSum,
    PFF     ***pppPFF
)
{
    BOOL    bFind = FALSE;
    PFF     *pPFF, **ppPFFHead;
    int     i;

    ASSERTGDI(pPFT == gpPFTPrivate, "pPFFGetMM(): it is not private PFT table\n");

    ppPFFHead = gpPFTPrivate->apPFF;

    for (i=0; i < CPRIVATEBUCKETS; i++)
    {
        pPFF = *ppPFFHead;

        while (pPFF)
        {
            if ((pPFF->flState & PFF_STATE_MEMORY_FONT) && (pPFF->ulCheckSum == ulCheckSum))
            {
                PFFOBJ  pffo(pPFF);

                if (pffo.pPvtDataMatch())
                {
                    bFind = TRUE;
                    break;
                }
            }

            pPFF = pPFF->pPFFNext;
        }

        if (bFind)
        {
            break;
        }

        ppPFFHead++;
    }

    if (bFind && pppPFF)
    {
        *pppPFF = ppPFFHead;
    }

    return(pPFF);
}



/******************************Public*Routine******************************\
* PFTOBJ::pPFFGet                                                          *
*                                                                          *
* This function searches for the PFF that contains the device fonts for    *
* the PDEV specified by the HPDEV passed in.                               *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT semaphore                  *
*   when calling this in order to have access to the font tables.          *
*                                                                          *
* Returns:                                                                 *
*   pointer to the PFF if found. 0 returned on error.                      *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 13:39:04 by Kirk Olynyk [kirko]                         *
* Changed this to a hash based search.                                     *
*  06-May-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

#define iHashHPDEV(hdev, c)    (((ULONG_PTR) hdev >> 4) % c)

PPFF DEVICE_PFTOBJ::pPFFGet(
    HDEV hdev
  , PFF ***pppPFF     // write address of bucket here
)
{
    PFF *pPFF, **ppPFF;

    ppPFF = pPFT->apPFF + iHashHPDEV(hdev, pPFT->cBuckets);
    pPFF = *ppPFF;
    if (pppPFF)
    {
        *pppPFF = ppPFF;
    }
    while (pPFF)
    {
        PFFOBJ pffo(pPFF);
        if (!pffo.bValid())
        {
            RIP("PFTOBJ::PPFFGet(HPDEV) encountered invalid PFFOBJ\n");
        }
        else if (hdev == pffo.hdev())
        {
            break;
        }
        pPFF = pPFF->pPFFNext;
    }
    return(pPFF);
}

/******************************Public*Routine******************************\
*
* bLoadAFont, wrapper for one file only
*
*
* History:
*  28-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL PUBLIC_PFTOBJ::bLoadAFont(
    PWSZ   pwszPathname,             // font file pathname
    PULONG pcFonts,                  // number of fonts faces loaded
    FLONG  fl,                       // permanent
    PPFF    *pPPFF,
    PEUDCLOAD pEudcLoadData
  )
{

    WCHAR awcUcPathName[MAX_PATH + 1];
    ULONG cwc = wcslen(pwszPathname) + 1;
    cCapString(awcUcPathName, pwszPathname, cwc);

    return bLoadFonts(awcUcPathName, cwc, 1, // pwsz, cwc, cFiles
                      NULL, 0,               // pdv, cjDV
                      pcFonts,fl, pPPFF
                      , 0
                      , FALSE
                      , pEudcLoadData
                      );
}

/************************Public*Routine*******************************\
*
* VOID    vLoadFontFileView()
*
* Note: we need to grab semaphore ghsemDriverMgmt before the function
*       call and release the semaphore afterwards.
*
* History:
*   03-June-1997 -by- Xudong Wu [Tessiew]
*  Wrote it.
\*********************************************************************/
VOID  vLoadFontFileView
(
    PWSZ            pwszPathname,             // font file pathname
    ULONG           cwc,                      // cwc in PathName
    FONTFILEVIEW    **apfv,
    ULONG           cFiles,
    PVOID           *apvView,
    ULONG           *acjView,
    DESIGNVECTOR    *pdv,
    ULONG           cjDV,
    HFF             *phffNew,
    PPDEV           *pppDevList,
    PFNTCHECKSUM    pFntCheckSum
)
{
    GDIFunctionID(vLoadFontFileView);

    HFF     hffNew = HFF_INVALID;
    PPDEV   ppDevList = gppdevList, ppDevTmp;
    ULONG   lflag;
    PPDEV   ppDevCache = NULL;
    BOOL    bCached = FALSE;

    pFntCheckSum->ulCheckSum = 0;
    pFntCheckSum->ulFastCheckSum = 0;

    pFntCheckSum->ulCheckSum = LookUpFNTCacheTable( cwc, pwszPathname, &pFntCheckSum->ulFastCheckSum,
                                                    apfv, cFiles, &ppDevList, pdv, cjDV);

    if (pFntCheckSum->ulCheckSum && ppDevList)
    {
        PDEVOBJ pdo((HDEV)ppDevList);

        ASSERTGDI (pdo.bFontDriver(), " Something wrong in font ppDev cache \n" );

        // In case something wrong in font driver.

        if (pdo.bFontDriver())
        {
            // make a reference to the font driver under the protection
            // of the semaphore. This will guarantee that the font
            // driver will not be unloaded unexpectedly. After that

            pdo.vReferencePdev();

            GreReleaseSemaphoreEx(ghsemDriverMgmt);


            // Attempt to load the font file.
            // It is acceptable to release the lock at this point because
            // we know this font driver has at least one reference to it.
            // We also do not care if other font drivers are added or removed
            // from the list while we are scanning it ...

            // We are assuming that DrvLoadFontFile will call EngMapFontFile
            // and EngUnmapFontFile in balanced pairs upon the view.

            // we are trying to add the font using the cached info. If this failed
            // we will try to add it later without using the cached info, in case there
            // is a problem with boot cache. (Defensive programming).

            hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       pFntCheckSum->ulFastCheckSum
                                      );


            if (hffNew == HFF_INVALID)
            {
                hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       0
                                      );

            }

            if (hffNew != HFF_INVALID)
            {
               bCached = TRUE;
            }
            else
            {
                // We did not load the font file properly
                // Release the reference and go on.
                pdo.vUnreferencePdev();
            }

            // Grab the lock again here (so we exit the loop properly)
            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
        }
    }

    if (!bCached)
    {
        ppDevList = gppdevList;

        do
        {
            PDEVOBJ pdo((HDEV)ppDevList);

            ppDevTmp = NULL;
            if ( pdo.bFontDriver() )
            {
            // make a reference to the font driver under the protection
            // of the semaphore. This will guarantee that the font
            // driver will not be unloaded unexpectedly. After that

                pdo.vReferencePdev();

                GreReleaseSemaphoreEx(ghsemDriverMgmt);

            // Attempt to load the font file.
            // It is acceptable to release the lock at this point because
            // we know this font driver has at least one reference to it.
            // We also do not care if other font drivers are added or removed
            // from the list while we are scanning it ...

            // We are assuming that DrvLoadFontFile will call EngMapFontFile
            // and EngUnmapFontFile in balanced pairs upon the view.

                hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       pFntCheckSum->ulFastCheckSum
                                      );


            // Grab the lock again here (so we exit the loop properly)

                GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

                if (hffNew != HFF_INVALID)
                {
                    PutFntCacheDrv(pFntCheckSum->ulFastCheckSum, ppDevList);
                    break;
                }
                else
                {
                // We did not load the font file properly
                // Release the reference and go on.

                    ppDevTmp = ppDevList->ppdevNext;
                    pdo.vUnreferencePdev();
                }
            }
            ppDevList = ppDevTmp ? ppDevTmp : ppDevList->ppdevNext;

        } while (ppDevList);
    }

    *pppDevList = ppDevList;
    *phffNew = hffNew;
}



/******************************Public*Routine******************************\
* BOOL PUBLIC_PFTOBJ::bLoadFonts                                          *
*                                                                          *
* The bLoadFont function searches for an IFI font driver which can load    *
* the requested font file.  If a driver is found, a new Pysical Font       *
* File object is created and is used to load the font file.                *
*                                                                          *
* Note that if the font file has already been loaded (i.e., a PFF object   *
* already exists for it), the ref count in the PFF is incremented without  *
* reloading the file.                                                      *
*                                                                          *
* If pppfeEUDC != NULL then we are loading an EUDC font file.  This has    *
* the restriction the font file has only one face or two if the other is   *
* an @face. If either of these aren't true the call fails.  Also, an EUDC  *
* font wont be enumerated.  Finally the PFE will be returned for the one   *
* font in the EUDC font file via pppfeEUDC.                                *
*                                                                          *
* Returns FALSE on failure.                                                *
*                                                                          *
* History:                                                                 *
*  Thu 28-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: added multiple file support
*  Thu 04-Aug-1994 08:04:03 by Kirk Olynyk [kirko]                         *
* Made the font table hash based.                                          *
*  06-Nov-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PUBLIC_PFTOBJ::bLoadFonts(
    PWSZ   pwszPathname,             // font file pathname
    ULONG  cwc,                      // cwc in PathName
    ULONG  cFiles,                   // number of distinct files in path
    DESIGNVECTOR *pdv,
    ULONG         cjDV,
    PULONG pcFonts,                  // number of fonts faces loaded
    FLONG  fl,                       // permanent
    PPFF    *pPPFF,
    FLONG  flEmbed,
    BOOL   bSkip,               // skip the check if the font is already loaded
    PEUDCLOAD pEudcLoadData     // returns PFE for EUDC font file
    )
{
    GDIFunctionID(PUBLIC_PFTOBJ::bLoadFonts);

    COUNT   cFonts;                   // count of fonts in font file
    BOOL    bRet = FALSE;             // assume failuer
    PFF     *pPFF;                    // convenient pointer2
    PFF     **ppPFF;                    // address of bucket
    BOOL    bEUDC = ( pEudcLoadData != NULL );
    PPFE    *pppfeEUDC = ((bEUDC) ? pEudcLoadData->pppfeData : NULL);
    FNTCHECKSUM fntCheckSum;
    PFF     *pPFFTemp = NULL;
    BOOL    bClone = FALSE;

    if (!pwszPathname)
    {
        RIP("pwszPathname != 0\n");
        return(bRet);
    }

    // we have seen AV caused by uninitialized gpsemPublicPFT
    // on Hydra systems
    // hydra -- we might remove this in Beta3

    //if (!ghsemPublicPFT)
    //{
    //    return bRet;
    //}

    // if (already_loaded) increment_ref_count_then_exit_immediately

    if (!bSkip)
    {
        SEMOBJ so(ghsemPublicPFT);

        *pcFonts = 0;

        if ((*pPPFF = pPFFGet((PWSZ) pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
            (*pcFonts = chpfeIncrPFF(*pPPFF, &bRet, flEmbed, pEudcLoadData)))
        {
            return(bRet);
        }
        else if (pPFFTemp = pPFFGet((PWSZ) pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, !bEUDC))
        {
            if (pPFFTemp->pPFFClone == (PFF *) NULL)
                bClone = TRUE;
        }
    }

    // Grab the head of the font driver list under semaphore and find
    // the first font driver in the list that loads the font
    //
    // Release the semaphore so we can go and see if the
    // driver supports the font.  If it does, then keep
    // the reference count and exit.  Otherwise, grab the
    // semaphore again, release the reference count and
    // find the next driver in the list.


// alloc temp memory, this could be done on the stack if it were not
// for the fact that we do not know ahead the upper bound on cFiles

    if (!bClone)
    {
        HFF hffNew = HFF_INVALID;             // IFI handle to font file

        MALLOCOBJ moViews(cFiles * (sizeof(PVOID) + sizeof(ULONG)));
        if (!moViews.bValid())
            return FALSE;

        PVOID *apvView      = (PVOID *)moViews.pv();
        ULONG *acjView      = (ULONG *)&apvView[cFiles];


        FONTFILEVIEW **apfv;

    // apfv - pointer to a block of memory that begins with an array
    //    of cFiles pointers to FONTFILEVIEW structures followed
    //    by a corretly aligned FONTFILEVIEW structure

        unsigned offset;

    // offset - offset of FONTFILEVIEW structure from the beginning
    //     of the block of memory pointed to by apfv. This is equal to the
    //     offset of the nearest double following the array of pointers.
    //     In C, a double is maximally aligned.

        offset = ALIGN8(cFiles * sizeof(void*));

        apfv = (FONTFILEVIEW**) PALLOCMEM(offset + cFiles*sizeof(FONTFILEVIEW),'vffG');

        if (apfv == NULL)
        {
            WARNING("Out of memory\n");
            return(FALSE);
        }

    // pfv - pointer to FONTFILEVIEW structure following the array of
    //     cFiles pointers.

        FONTFILEVIEW *pfv = (FONTFILEVIEW*)(((char*) apfv) + offset);

    // init the data for all files;

        PWSZ   pwszTmp = pwszPathname;
        ULONG  iFile;

        for (iFile = 0; iFile < cFiles; iFile++)
        {
            apfv[iFile] = &pfv[iFile];

            apfv[iFile]->pwszPath = pwszTmp;

            if (!EngMapFontFileFDInternal((ULONG_PTR)apfv[iFile], (PULONG*)&apvView[iFile], &acjView[iFile], FALSE))
            {
                WARNING("EngMapFontFile failed\n");

            // clean up, unmap all of those mapped so far

                for (ULONG jFile = 0; jFile < iFile; jFile++)
                    EngUnmapFontFileFD((ULONG_PTR)apfv[jFile]);

                VFREEMEM(apfv);
                return(FALSE);
            }

            // get to the next file in the multiple path

            while (*pwszTmp++)
                ;
        }

        PPDEV   ppDevList;

        // order of grabbing semaphores important

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
        vLoadFontFileView(pwszPathname, cwc, apfv, cFiles, apvView, acjView, pdv, cjDV, &hffNew, &ppDevList, &fntCheckSum);
        PDEVOBJ pdo((HDEV)ppDevList);
        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        ASSERTGDI(bRet==FALSE,"bRet != FALSE\n");

        if (hffNew != HFF_INVALID)
        {
        // cFonts = number of faces in the file

            cFonts = pdo.QueryFontFile( hffNew,
                                        QFF_NUMFACES,
                                        0,
                                        NULL);

            if (cFonts && cFonts != FD_ERROR)
            {
            // EUDC font file can have at most two fonts. If it
            // has two fonts then one of the face names must begin
            // with the '@' character. We check the number of fonts
            // here but we do not check the characters of the
            // face names.

                if (bEUDC && (pEudcLoadData->LinkedFace == NULL) && (cFonts > 2))
                {
                    WARNING("EUDC font file has more than two faces.");
                    return(bRet);
                }

                *pcFonts = cFonts;

            // Create new PFF with table big enough to accomodate
            // the new fonts and pathname.

                PFFCLEANUP *pPFFC = 0;

                PFFMEMOBJ pffmo(cFonts,
                                pwszPathname,cwc, cFiles, pdv, cjDV,
                                hffNew,pdo.hdev(),0,pPFT,fl,flEmbed,&fntCheckSum, apfv, NULL
                               );

                if (pffmo.bValid())
                {
                // Tell the PFF user object to load its table of
                // HPFE's for each font in file.

                    if (!pffmo.bLoadFontFileTable(pwszPathname,
                                                  cFonts,
                                                  (HANDLE) 0,
                                                  NULL,  //PFE_UFIMATCH bit for remote printing
                                                  pEudcLoadData
                                                  ))
                    {
                        *pcFonts = 0;
                    }
                    else
                    {
                    // Font load has succeeded.  If some other process hasn't
                    // already snuck in and added it while the ghsemPublicPFT
                    // semaphore was released, add the new PFF to the PFT.
                    // Stabilize font table before searching or modifying it.

                        SEMOBJ so2(ghsemPublicPFT);

                    // Is PFF already in table?  We check this by
                    // assuming that it already is and attempt to
                    // increment the load count.  If it succeeds, its
                    // there.  If it fails, it not there and we can add
                    // our new PFF to the PFT.

                    #ifdef LANGPACK

                        // do this under the public font table semaphore to
                        // serialize access to the

                        pffmo.vSetUniqueness();
                    #endif

                        if((*pPPFF = pPFFGet(pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
                            (cFonts = chpfeIncrPFF(*pPPFF,&bRet,flEmbed,pEudcLoadData)))
                        {
                        // Some other process got in and put it in before we
                        // could.  chpfeIncrPFF has already incremented the
                        // count for us.  We only need to delete the PFF that
                        // we made which will occur automatically if
                        // bRet = FALSE

                            *pcFonts = cFonts;
                        }
                        else
                        {
                        // Not already in the table, so we really are going
                        // to add it to the PFT.

                            *pPPFF = pffmo.pPFFGet();
                            if(pffmo.bAddHash(bEUDC))
                            {
                            // add entry to head of a doubly linked collision
                            // list

                                pPFT->cFiles++;
                                if (*ppPFF)
                                {
                                    (*ppPFF)->pPFFPrev = *pPPFF;
                                }
                                (*pPPFF)->pPFFNext = *ppPFF;
                                (*pPPFF)->pPFFPrev = 0;
                                *ppPFF = *pPPFF;

                                pffmo.vKeepIt();

                            // need to reset the file paths pointers

                                pwszTmp = pffmo.pwszPathname();

                                for (iFile = 0; iFile < cFiles; iFile++)
                                {
                                    apfv[iFile]->pwszPath = pwszTmp;

                                // get to the next file in the multiple path

                                    while (*pwszTmp++)
                                        ;
                                }
                                bRet           = TRUE;
                            }
                            else
                            {
                                WARNING("pffmo.bAddHash() failed\n");
                                *pcFonts = 0;
                                pffmo.vRemoveHash();
                            }
                        }
                    }

                    if (!bRet)
                    {
                    // must unmap the files before calling pPFFC_Delete()
                    // because this function will delete apfv memory so that unmap
                    // will fail

                        for (iFile = 0; iFile < cFiles; iFile++)
                        {
                            EngUnmapFontFileFD((ULONG_PTR)apfv[iFile]);
                        }

                        pffmo.vPFFC_DeleteAndCleanup();  // new code
                        return bRet;
                    }
                }
            }
        }

    // If you get to here then the font driver recognized the font. Since
    // we cannot be sure that the font will be used immediately, we will
    // unmap font font file and free the memory containing the image of the
    // font file.

        for ( iFile = 0; iFile < cFiles; iFile++ )
        {
            EngUnmapFontFileFD( (ULONG_PTR) apfv[iFile] );
        }

        if (!bRet)
        {
            VFREEMEM(apfv);
        }

        return(bRet);
    }
    else
    {
        PFFCLEANUP *pPFFC = 0;

    // Clone the hffNew and make a new PFF object
        PFFMEMOBJ pffmo(pPFFTemp, fl, flEmbed, pPFT);

        bRet = FALSE;

        cFonts = pPFFTemp->cFonts;

        if (pffmo.bValid())
        {
        // Tell the PFF user object to load its table of
        // HPFE's for each font in file.

            if (!pffmo.bLoadFontFileTable(pwszPathname, cFonts, (HANDLE) 0, NULL, pEudcLoadData))
            {
                *pcFonts = 0;
            }
            else
            {

            // Font load has succeeded.  If some other process hasn't
            // already snuck in and added it while the ghsemPublicPFT
            // semaphore was released, add the new PFF to the PFT.
            // Stabilize font table before searching or modifying it.

                SEMOBJ so2(ghsemPublicPFT);

            // Is PFF already in table?  We check this by
            // assuming that it already is and attempt to
            // increment the load count.  If it succeeds, its
            // there.  If it fails, it not there and we can add
            // our new PFF to the PFT.

            #ifdef LANGPACK

            // do this under the public font table semaphore to
            // serialize access to the

                pffmo.vSetUniqueness();
            #endif

                if((*pPPFF = pPFFGet(pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
                     (cFonts = chpfeIncrPFF(*pPPFF,&bRet,flEmbed,pEudcLoadData)))
                {
                // Some other process got in and put it in before we
                // could.  chpfeIncrPFF has already incremented the
                // count for us.  We only need to delete the PFF that
                // we made which will occur automatically if
                // bRet = FALSE

                    *pcFonts = cFonts;
                }
                else
                {
                // Not already in the table, so we really are going
                // to add it to the PFT.

                    *pPPFF = pffmo.pPFFGet();


                    if(pffmo.bAddHash(bEUDC))
                    {
                    // add entry to head of a doubly linked collision
                    // list

                        pPFT->cFiles++;
                        if (*ppPFF)
                        {
                            (*ppPFF)->pPFFPrev = *pPPFF;
                        }

                        (*pPPFF)->pPFFNext = *ppPFF;
                        (*pPPFF)->pPFFPrev = 0;
                        *ppPFF = *pPPFF;

                        pffmo.vKeepIt();

                        bRet           = TRUE;
                    }
                    else
                    {
                        WARNING("pffmo.bAddHash() failed\n");
                        *pcFonts = 0;
                        pffmo.vRemoveHash();
                    }
                }
            }

            if (!bRet)
            {

            // must unmap the files before calling pPFFC_Delete()
            // because this function will delete apfv memory so that unmap
            // will fail
                pffmo.vPFFC_DeleteAndCleanup();  // new code
            }
        }

        return(bRet);
    }
}


/******************************Public*Routine******************************\
* BOOL PUBLIC_PFTOBJ::bLoadRemoteFonts
*
* Warning:
*
*   This routine or any of the routines that it calls must
*   call EngMapFontFile and EngUnmapFontFile in pairs.
*
* History:
*  Thu 02-Feb-1995 2:04:06 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#define QUICK_VIEWS  4

ULONG PUBLIC_PFTOBJ::ulRemoteUnique = 0;


BOOL PUBLIC_PFTOBJ::bLoadRemoteFonts(
    XDCOBJ &dco,
    PFONTFILEVIEW *ppfv, // points to a pre mapped view of the font
                         // EngMapFontFile must NOT be called
                         // before sending it to the font driver
                         // EngUnmapFontFile must be called at
                         // the end of this routine for possible
                         // error cleanup
    UINT           cNumFonts, // number of files needed to represent this font
    DESIGNVECTOR  *pdv,        // dv for the mm instance
    PUNIVERSAL_FONT_ID  pufi
    )
{
    COUNT cFonts;                   // count of fonts in font file
    BOOL  bRet = FALSE;             // assume failure
    HFF hffNew = HFF_INVALID;       // IFI handle to font file
    ULONG        cjDV = (pdv ? SIZEOFDV(pdv->dvNumAxes) : 0);
    FNTCHECKSUM  fntCheckSum;

    PVOID pvQuickBuffer[QUICK_VIEWS], *ppvViews;
    ULONG pcjQuickBuffer[QUICK_VIEWS], *pcjViews;

    if(cNumFonts > QUICK_VIEWS)
    {
        if(!(ppvViews = (VOID**) PALLOCMEM((sizeof(void*)+sizeof(ULONG*))*cNumFonts,
                                           'vffG')))
        {
            WARNING("bLoadRemoteFonts unable to allocate memory\n");

            // need to free ppfv if this function (bLoadRemoteFonts) fails
            if (ppfv)
            {
                VFREEMEM (ppfv);
            }
            return(FALSE);
        }

        pcjViews = (ULONG*) &ppvViews[QUICK_VIEWS];
    }
    else
    {
        ppvViews = pvQuickBuffer;
        pcjViews = pcjQuickBuffer;
    }

    UINT i;

    for(i = 0; i < cNumFonts; i++)
    {
        ppvViews[i] = ppfv[i]->fv.pvViewFD;
        pcjViews[i] = ppfv[i]->fv.cjView;
    }

    PPDEV   ppDevList;

// order of grabbing semaphores important

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    vLoadFontFileView(NULL, 0, ppfv, cNumFonts, ppvViews, pcjViews, pdv, cjDV, &hffNew, &ppDevList, &fntCheckSum);
    PDEVOBJ pdo((HDEV)ppDevList);
    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    if(ppvViews != pvQuickBuffer)
    {
        VFREEMEM(ppvViews);
    }

    ASSERTGDI(bRet==FALSE,"bRet != FALSE\n");

    if (hffNew != HFF_INVALID)
    {
        //
        // cFonts = number of faces in the file
        //

        cFonts = pdo.QueryFontFile( hffNew, QFF_NUMFACES, 0, NULL);

        if (cFonts && cFonts != FD_ERROR)
        {
            WCHAR awc[30];

            // Create a (hopefully) unique file name for
            // the remote font of the form "REMOTE nnnnnnnn"

            swprintf(
                awc,
                L"REMOTE-%u",
                ulGetNewUniqueness(PUBLIC_PFTOBJ::ulRemoteUnique));
                ULONG cwc = wcslen(awc) + 1;

            // Create new PFF with table big enough to accomodate
            // the new fonts and pathname.

            PFFCLEANUP *pPFFC = 0;
            PFFMEMOBJ
            pffmo (cFonts,
                   awc, cwc, cNumFonts,  // pwsz, cwc, cFiles
                   pdv, cjDV,            // pdv, cjDV,
                   hffNew,
                   pdo.hdev(),
                   0,
                   pPFT,
                   PFF_STATE_DCREMOTE_FONT,
                   FR_NOT_ENUM, // never enum fonts that are temporarily
                   &fntCheckSum,
                   ppfv,        // loaded on printer server until print job is done
                   pufi);       // use this ufi instead of calculate from the ppfv for remote printing
            if (pffmo.bValid())
            {
                // Tell the PFF user object to load its table of
                // HPFE's for each font in file.


                if (  pffmo.bLoadFontFileTable(awc,
                                               cFonts,
                                               dco.hdc(),
                                               pufi,   // fonts can be mapped only by bFoundForcedMatch() calls
                                               NULL    // for remote printing.
                                              ))
                {
                    // Stabilize font table before searching or modifying it.

                    SEMOBJ so2(ghsemPublicPFT);

                    if(bRet = pffmo.bAddHash(FALSE))
                    {
                        PFF **ppPFF, *pPFF;

                        pPFF = pPFFGet(awc, cwc, cNumFonts, pdv, cjDV, &ppPFF);

                        if (pPFF)
                        {
                        #if DBG
                            KdPrint(("\"%ws\" has been found on the font table\n"));
                            KdBreakPoint();
                        #endif

                            bRet = FALSE;
                        }
                        else
                        {
                            pPFF = pffmo.pPFFGet();
                            if( bRet = dco.bAddRemoteFont( pPFF ) )
                            {
                                pPFT->cFiles++;

                                // place the pointer to this new remote
                                // PFF at the head of the public PFT.

                                if (*ppPFF)     // head of list exist?
                                {               // yes make it follow new PFF
                                    (*ppPFF)->pPFFPrev = pPFF;
                                }
                                pPFF->pPFFNext = *ppPFF;
                                pPFF->pPFFPrev = 0; // new PFF is first in list
                                *ppPFF = pPFF;

                                pffmo.vKeepIt();
                            }
                        }
                    }
                    else
                    {
                        pffmo.vRemoveHash();
                    }

                    // Here we should add it to our HDC's font table.
                }

                // call this if the above addition to the HDC's font table
                // fails

                if (!bRet)
                {
            pffmo.vPFFC_DeleteAndCleanup();  // new code
        }
            }
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* PFTOBJ::bLoadDeviceFonts
*
* This function loads the device fonts of the device identified by the pair
* (pldo, hdev) into the public table.  There are cFonts number of device
* fonts.
*
* The function will enlarge the PFT and create a PFF to contain the new fonts.
* The actual work of loading each device font into the tables is carrided
* out by PFF::bLoadDeviceFontTable().
*
* Note:
*   All the device fonts of a particular physical device are grouped together
*   as if they were in a single file and are placed all within a single PFF,
*   with each font represented by a single PFE.
*
* Note:
*   The function does not bother to check if the device fonts already are
*   in the tree.*
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Mon 15-Aug-1994 11:57:14 by Kirk Olynyk [kirko]
* Modified it for the new hashing scheme (not the same thing as font name
* hashing, which remains unchanged).
*  18-Mar-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
DEVICE_PFTOBJ::bLoadFonts(
    PPDEVOBJ    ppdo
    )
{
    PFF *pPFF, **ppPFF;
    BOOL bRet = FALSE;
    FNTCHECKSUM fntCheckSum;

    {
        SEMOBJ so(ghsemPublicPFT);
        if (pPFFGet(ppdo->hdev(), &ppPFF))
        {
            bRet = TRUE;
        }
    }

    if (!bRet)
    {
        //
        // create new PFF with table big enough to accomodate the
        // new device fonts
        //
        // the 'dhpdev' is used only for drivers that are font producers,
        // and consequently are not affected by dynamic mode changing.
        // We have to call 'dhpdevNotDynamic' to avoid an assert
        //

        fntCheckSum.ulFastCheckSum = 0;
        fntCheckSum.ulCheckSum = 0;

        PFFMEMOBJ pffmo(ppdo->cFonts(),
                        NULL,0,0,         // no path, no files,
                        NULL, 0,          // no pdv, cjDV,
                        HFF_INVALID,
                        ppdo->hdev(),
                        ppdo->dhpdevNotDynamic(),
                        pPFT,
                        0,
                        0,       // flEmbed
                        &fntCheckSum,    // pointer to PFNTCHECKSUM, on return fill in slow check sum
                        NULL,    // no views of the mapped font files
                        NULL     // pufi
                        );

        if (pffmo.bValid())
        {
            if (!pffmo.bLoadDeviceFontTable(ppdo))
            {
                WARNING("pffmo.bLoadDeviceFontTable() failed\n");
            }
            else
            {
                SEMOBJ so(ghsemPublicPFT);

                // if (!font_is_loaded_already) add_font_to_table;

                if (!(pPFF = pPFFGet(ppdo->hdev(), &ppPFF)))
                {
                    if (!pffmo.bAddHash(FALSE))
                    {
                        WARNING("gdisrv!bLoadDeviceFontsPFTOBJ()"
                                ": failed to add to font hash\n");
                        pffmo.vRemoveHash();
                    }
                    else
                    {
                        // Add file to font table

                        // Insert PFF at the head of the linked list
                        // pointed to by ppPFF

                        pPFF = pffmo.pPFF;  // convenient pointer.
                        pPFT->cFiles += 1;  // Increment total number
                                            //               of files in table.
                        if (*ppPFF)         // Is there a PFF at the head
                                            //         of the linked list?
                            (*ppPFF)->pPFFPrev = pPFF; // Yes, put this new
                        pPFF->pPFFNext = *ppPFF;       //  PFF in front of old.
                        pPFF->pPFFPrev = 0; // Nothing before new font.
                        *ppPFF = pPFF;      // Reset pointer to head of list.
                        pffmo.vKeepIt();    // Prevent ~PFFMEMOBJ from
                                            //                  freeing memory.
                        bRet = TRUE;
                    }
                }
            }
            if (!bRet)
            {
                pffmo.vPFFC_DeleteAndCleanup();  // new code
            }
        }
    }
    return(bRet);
}

#if 0

typedef struct _FONT_STRUCT_DATA {
    ULONG fontDataSize;
    ULONG fontMaxDataSize;
    ULONG cRegistryFonts;
    ULONG cMaxRegistryFonts;
    ULONG cHashBuckets;
    PBYTE pFont;
} FONT_STRUCT_DATA, *PFONT_STRUCT_DATA;

extern "C"
NTSTATUS
QueryRegistryFontListRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{

    PFONT_STRUCT_DATA pFontStructData = (PFONT_STRUCT_DATA) Context;
    ULONG Length;

    if ( (pFontStructData->fontDataSize + ValueLength >
          pFontStructData->fontMaxDataSize) ||
         (pFontStructData->cRegistryFonts >= pFontStructData->cMaxRegistryFonts) ||
         (pFontStructData->cRegistryFonts >= pFontStructData->cHashBuckets) )
    {
        //
        // The buffer is too small - reallocate it (leave lots of place to
        // build the hash table at the end
        //

        PBYTE pjBuffer;
        ULONG i;
        ULONG oldMaxSize = pFontStructData->fontMaxDataSize;

        pFontStructData->fontMaxDataSize += 0x100;
        pFontStructData->cMaxRegistryFonts += 10;
        pFontStructData->cHashBuckets = pFontStructData->cMaxRegistryFonts * 2;

        pjBuffer = (PBYTE) PALLOCMEM(pFontStructData->fontMaxDataSize +
                                     pFontStructData->cMaxRegistryFonts *
                                         sizeof(PBYTE) +
                                     pFontStructData->cHashBuckets *
                                          sizeof(REGHASHBKT) * 2, 'gerG');

        //
        // The buffer has three sections
        // 1) the first part of the buffer contains all the NULL terminated
        //    strings of the font files.
        // 2) an array of pointers to these strings.
        // 3) space for the hash table
        //
        // When copying the buffer, 1) can just be moved, 2) has to be adjusted
        // and 3) is not touched - has to be zero initialized
        //

        if (pjBuffer)
        {
            //
            // If we have an old one, move it to the new one, and then
            // always reset the pointer.
            //

            if (pFontStructData->fontDataSize)
            {
                //
                // Adjust the pointers - requires doing arithmetic on the
                // pointers themselves !
                //

                for (i=0; i < pFontStructData->cRegistryFonts; i++)
                {
                    *( ((PULONG)(pjBuffer +
                    pFontStructData->fontMaxDataSize)) + i ) =
                        *( ((PULONG)(pFontStructData->pFont + oldMaxSize)) + i )
                        + pjBuffer - pFontStructData->pFont;
                }

                //
                // Copy all the data to the new Buffer
                //

                RtlMoveMemory(pjBuffer,
                              pFontStructData->pFont,
                              pFontStructData->fontDataSize);

                VFREEMEM(pFontStructData->pFont);
            }

            pFontStructData->pFont = pjBuffer;
        }
        else
        {
            //
            // we do not have enough memory - return failiure
            //

            return STATUS_NO_MEMORY;
        }
    }

    Length = cCapString((PWSTR) (pFontStructData->pFont +
                                     pFontStructData->fontDataSize),
                        (const WCHAR*) ValueData,
                        ValueLength / 2);

    ASSERTGDI(Length * 2 + 2 == ValueLength,
              "QueryRegistryFontListRoutine CapString problem\n");

    * ( ((PBYTE *)(pFontStructData->pFont + pFontStructData->fontMaxDataSize)) +
        pFontStructData->cRegistryFonts) =
            pFontStructData->pFont + pFontStructData->fontDataSize;

    pFontStructData->fontDataSize += ValueLength;
    pFontStructData->cRegistryFonts += 1;

    return STATUS_SUCCESS;

}

#endif

/******************************Public*Routine******************************\
*
* BOOL PFTOBJ::bUnloadAllButPermanentFonts
*
* If bUnloadPermanent == FALSE (default):
*
* Called at log-off time to force unloading off all but permanent
* fonts Permanent fonts are defined as either console fonts or
* fonts from Gre_Initialize section of win.ini (i.e.  registry).
* Fonts from the "Fonts" section in win.ini (registry) are also
* permanent if they are on the local hard drive.  If they are
* remote they will get reloaded at the log on time.  This should
* be done after the net connections from the user profile are
* restored so that the font can get reloaded.
*
* If bUnloadPermanent == TRUE:
*
* All fonts in table are unloaded.  Only used for MultiUserGreCleanupAllFonts
* (i.e, MultiUserGreCleanup or Hydra processing).
*
* History:
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

typedef struct _FONTVICTIM
{
    PFF   *pPFFVictim;
    RFONT *prfntVictims;
} FONTVICTIM;

FONTVICTIM gFntVict[64];

BOOL PFTOBJ::bUnloadAllButPermanentFonts (BOOL bUnloadPermanent)
{
    // pointer to the array of cFonts victim structures.  Only as
    // many entries of this array will be initialized as there are
    // non-permanent fonts in the pft.  These fonts will be deleted
    // outside of the pft semaphore.

    FONTVICTIM *pvict, *pvictCur;
    COUNT      cFile, cFonts;
    PFF        *pPFF;
    BOOL        bAlloc = FALSE;

    // Look for the PFF to unload.

    {
        // Stablize table while we scan it for victims.

        SEMOBJ so(ghsemPublicPFT);

        // alloc mem for the array of font victims
        // It is essential that this memory is zero initialized
        // This must be done under semaphore, otherwise cFonts might change;

        cFonts = pPFT->cFiles;

        if (cFonts == 0)
        {
            // gpPFTDevice initialized but no device font loaded.
            // Seen this on Hydra.

            return TRUE;
        }

        if ( cFonts > 64)
        {
            if (!(pvict = (FONTVICTIM *)PALLOCNOZ(cFonts * sizeof(FONTVICTIM),'ivfG')))
            {
                WARNING(
                    "PFTOBJ::bUnloadAllButPermanentFonts failure\n"
                    "Failed to allocate memeory for font victim list\n");

                return FALSE;
            }

            bAlloc = TRUE;
        }
        else
        {
            pvict = &gFntVict[0];
        }

        pvictCur = pvict;

        // Caution with this code: pPFT->cFiles changes in the loop
        // This loop does two things:
        // a) stores the pPFFVictim information in the pvict array
        //    for the fonts that are going to be unloaded outside
        //    the semaphore.
        // b) contracts the pft table to contain only the permanent
        //    fonts upon the exit of the loop

        for (
            PFF **ppPFF = pPFT->apPFF
          ; ppPFF < pPFT->apPFF + pPFT->cBuckets
          ; ppPFF++
        )
        {
          for (pPFF = *ppPFF; pPFF; pPFF = pPFF->pPFFNext)
          {
            // Create a PFF user object.  There shouldn't be any invalid
            // handles in the PFT.

            PFFOBJ  pffo(pPFF);
            ASSERTGDI(pffo.bValid(),
                "gdisrv!bUnloadFontPFTOBJ(file): bad PPFF in public PFT\n");

            // Is it a font driver loaded file?  And if so, is this not a
            // permanent file (listed in Gre_Initialize or loaded by
            // console or local font from "fonts" section of the registry)
            // We also leave alone fonts loaded temporarily for printing

            if (bUnloadPermanent || !(pffo.bPermanent() || pffo.bDCRemote()))
            {
                ASSERTGDI(!pffo.bDCRemote(), "bUnloadAllButPermanentFonts: "
                          "EMF spooler playback fonts still present!\n");

                // Tell PFF to decrement its load count and ask it if is
                // ready to die.  If it returns TRUE, we will need to delete
                // (outside of semaphore since PFF deletion may cause driver
                // to be called).

                // we force the load count to zero. We are forcing the unload
                // of this font

                pffo.vSet_cLoaded((COUNT)0); // not loaded any more,
                                             // avoid asserts
                pffo.vSet_cNotEnum((COUNT)0);

                pffo.vKill();

                {
                    // unlink the PFF from the collision list

                    if (*ppPFF == pPFF)
                    {
                        // The hash bucket contains a pointer to the first
                        // PFF in the collision list. If it turns out that
                        // the victim is this first in the list, then the
                        // address storred in the hash bucket must be changed

                        *ppPFF = pPFF->pPFFNext;
                    }
                    if (pPFF->pPFFNext)
                    {
                        pPFF->pPFFNext->pPFFPrev = pPFF->pPFFPrev;
                    }
                    if (pPFF->pPFFPrev)
                    {
                        pPFF->pPFFPrev->pPFFNext = pPFF->pPFFNext;
                    }
                }
                // Save handle of victim.

                pvictCur->pPFFVictim = pffo.pPFFGet();

                // Remove PFF and PFEs from hash tables.  Fonts in this
                // font file will no longer be enumerated or mapped to.

                pffo.vRemoveHash();
                pPFT->cFiles--;

                // Construct a "kill" list of RFONTs.

                pvictCur->prfntVictims = prfntKillList(pffo);

                // point to the next entry in pvictCur array

                pvictCur++;
            }
            else
            {
                // this is a permanent or a device font, leave them in
                // set init to 1 for the next logon session

                if (pffo.bPermanent() && !(pPFF->flState & PFF_STATE_EUDC_FONT))
                {
                    if ( pffo.cLoaded() )
                    {
                        pffo.vSet_cLoaded((COUNT)1);
                        pffo.vSet_cNotEnum((COUNT)0);
                    }
                    else
                    {
                        pffo.vSet_cLoaded((COUNT)0);
                        pffo.vSet_cNotEnum((COUNT)1);
                    }
                }
            }
          }
        } // end of the for loop

    // at this time if any font were in the private font table, the process
    // cleanup should have removed them (this is logoff time!), therefore there
    // is nothing we need to do about private font table

        #if DBG

        PUBLIC_PFTOBJ pftop(gpPFTPrivate);

        ASSERTGDI((gpPFTPrivate == NULL) || (pftop.cFiles() == 0),
            "some private fonts still around at logoff time\n");

        #endif
    }

// Delete the victims that were found:
// Overload cFonts to mean cFontsToBeDeleted:

// Sundown truncation

    ASSERT4GB((ULONGLONG)(pvictCur - pvict));
    cFonts = (ULONG)(pvictCur - pvict);

    for (cFile = 0; cFile < cFonts; cFile++)
    {
        ASSERTGDI(
            pvict[cFile].pPFFVictim != (PPFF) NULL,
            "GreRemoveAllButPermanentFonts, pPFFVictim IS null\n"
            );
        PFFOBJ pffoVictim(pvict[cFile].pPFFVictim);
        ASSERTGDI(pffoVictim.bValid(),
            "gdisrv!bUnloadFontPFTOBJ(device): PFF victim bad\n");

    // If we need to kill any RFONT victims, now is the time to do it.
    // bKillRFONTList() can handle NULL prfntVictims case.
    // Note that we do not check the return, we go on to the
    // next font [bodind]

        bKillRFONTList(pffoVictim, pvict[cFile].prfntVictims);
    }

// release memory

    if (bAlloc)
        VFREEMEM(pvict);

// We didn't delete anything, but we're ok as long as we found the right
// PFF.  PFF still referenced (either load count or RFONT count) and will
// be deleted later.

    return(TRUE);
}

/******************************Public*Routine******************************\
* bUnloadWorkhorse
*
* History:
*  Mon 15-Aug-1994 14:10:53 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL PFTOBJ::bUnloadWorkhorse(
    PFF *pPFF,
    PFF **ppPFFHead,             // bucket address
    HSEMAPHORE hsem,             // if the pointer is not zero,
                                 //  then this must be a pointer
                                 //  to the public font table
                                 //  semaphore and must be released
                                 //  before this procedure returns
    ULONG   flEmbed              //  Embedding/private flag
)
{
    GDIFunctionID(PFTOBJ::bUnloadWorkhorse);

    PFF *pPFFVictim     = 0;    // Pointer to PFF to be deleted, only
                                // non zero when found and deleted

    BOOL bFoundPFF = FALSE;     // signals PFF was found (does not
                                // indicate deletion status);

    static const PSZ pszReleaseSem = "PFTOBJ::bUnloadWorkhorse()"
                                     " releasing gpPFTPublic";

    TRACE_FONT((
        "Entering PFTOBJ::bUnloadWorkhorse\n"
        "\tpPFF=%-#x\n"
        "\tppPFFHead=%-#x\n",
        "\thsem=%-#x\n",
        pPFF, ppPFFHead, hsem
    ));
    ASSERTGDI(!hsem || hsem==ghsemPublicPFT, "hsem!=ghsemPublicPFT\n");

    if ( pPFF )
    {
        PFFOBJ pffo(pPFF);
        ASSERTGDI(pffo.bValid(), "bad PPFF in public PFT\n");
        PVTDATA *pPvtData = NULL;

        if ((!bIsPrivatePFT()) || (pPvtData = pffo.pPvtDataMatch()))
        {
            // Tell PFF to decrement its load count and ask it if is
            // ready to die.  If it returns TRUE, we will need to
            // delete (outside of semaphore since PFF deletion may
            // cause driver to be called).

            bFoundPFF = TRUE;
            BOOL        bWrongFlags = FALSE;

            if ( pffo.bDeleteLoadRef(flEmbed, pPvtData, &bWrongFlags) )
            {
                // Remove PFF and PFEs from hash tables.  Fonts in this
                // font file will no longer be enumerated or mapped to.

                pffo.vRemoveHash();

                // now remove it from the font table hash

                pPFFVictim = pPFF;

                // If ppPFFHead is NULL then it means that we are
                // unloading  a font that has been added to the DC
                // as a remote font and the this must be the public
                // font table

                PFF **ppPFF = ppPFFHead;
                if( ppPFF == 0 )
                {
                    PUBLIC_PFTOBJ *pTemp;
                    PFF *pPFF_Found;

                    ASSERTGDI(pPFF->pPFT==gpPFTPublic || pPFF->pPFT==gpPFTPrivate,"PFF not in public font table\n");

                    pTemp = (PUBLIC_PFTOBJ*) this;

                    pPFF_Found = pTemp->pPFFGet(pPFF->pwszPathname_,
                                                pPFF->cwc,
                                                pPFF->cFiles,
                                                pPFF->pdv_,
                                                pPFF->cjDV_,
                                                &ppPFF
                                                );

                    ASSERTGDI(pPFF==pPFF_Found,"Could not find remote PFF in the font table\n");
                }
                if (*ppPFF == pPFF)
                {
                    *ppPFF = pPFF->pPFFNext;
                }
                if (pPFF->pPFFNext)
                {
                    (pPFF->pPFFNext)->pPFFPrev = pPFF->pPFFPrev;
                }
                if (pPFF->pPFFPrev)
                {
                    (pPFF->pPFFPrev)->pPFFNext = pPFF->pPFFNext;
                }
                pPFT->cFiles--;
            }
            else
            {
            // Set the return value as FALSE for private/embedded fonts

                if (bIsPrivatePFT() && bWrongFlags)
                {
                    bFoundPFF = FALSE;
                }
            }
        }
        if ( pPFFVictim )
        {
            PFFOBJ pffoVictim(pPFFVictim);
            if ( !pffoVictim.bValid() )
            {
                RIP("pffoVictim is not valid\n");
                bFoundPFF = 0;
            }
            else
            {
                if ( hsem )
                {
                    // The victim has been removed from the table
                    // so the semaphore for the table may be safely
                    // released. It is necessary to do this because
                    // bKillRFONTList() calls RFONTOBJ::bDeleteRFONT()
                    // which in turn locks the display. If we do
                    // not release the font table semaphore before
                    // the device lock, we will have deadlock.

                    TRACE_FONT(("%ws\n", pszReleaseSem));
                    GreReleaseSemaphoreEx(hsem);
                    hsem = 0;
                }

                bFoundPFF = bKillRFONTList( pffoVictim, prfntKillList( pffoVictim ));
            }
        }

        // We didn't delete anything, but we're ok as long as we found
        // the right PFF.  PFF still referenced (either load count or
        // RFONT count) and will be deleted later.
    }

    // Make sure the semampore is released before the procedure ends
    if( hsem )
    {
        TRACE_FONT(("%ws\n", pszReleaseSem));
        GreReleaseSemaphoreEx(hsem);
    }

    TRACE_FONT(("Exiting PFTOBJ::bUnloadWorkhorse\n"
                "\treturn value = %d\n", bFoundPFF));
    return( bFoundPFF );
}

/****************************************************************************
*  INT PFTOBJ::QueryFonts( PUNIVERSAL_FONT_ID, ULONG, PLARGE_INTEGER )
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


INT PUBLIC_PFTOBJ::QueryFonts(
    PUNIVERSAL_FONT_ID pufi,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
)
{
    ULONG cFonts = 0;
    *pTimeStamp = PFTOBJ::FontChangeTime;

// if we aren't supplied with a buffer just return the time stamp and number
// of fonts

    if( ( pufi == NULL ) || ( nBufferSize == 0 ) )
    {
        return(pPFT->cFiles + (UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer) ? 1 : 0));
    }

    PFF *pPFF;
    SEMOBJ so(ghsemPublicPFT);

// Fill the first position with the identifier for the local rasterizer if one
// exists.  This must be the first UFI in the list if it exists.

    if(UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer))
    {
        pufi[cFonts++] = gufiLocalType1Rasterizer;
    }

    for (
        PFF **ppPFF = pPFT->apPFF
      ; (ppPFF < pPFT->apPFF + pPFT->cBuckets) && (cFonts < nBufferSize)
      ; ppPFF++
    )
    {
      for (pPFF = *ppPFF; (pPFF) && (cFonts<nBufferSize); pPFF = pPFF->pPFFNext)
      {
        // Create a PFF user object.  There shouldn't be any invalid
        // handles in the PFT.

        PFFOBJ  pffo(pPFF);
        ASSERTGDI(pffo.bValid(),
            "gdisrv!bUnloadFontPFTOBJ(file): bad PPFF in public PFT\n");

        // be sure not to include remote fonts in list

        if (!pffo.bDCRemote())
        {
        // Set the Index to 1.  This value can be anything since we will only
        // be using the UFI's passed back to determine if font file match.
        // We could just pass back checksums but we may need to expand the
        // UFI structure to include more than checksum's which is why I'm
        // using UFI's.

            pufi[cFonts].Index = 1;
            pufi[cFonts++].CheckSum = pffo.ulCheckSum();
        }
      }
    }

    return(cFonts);
}




/******************************Public*Routine******************************\
* prfntKillList
*
* Scans the display PDEV list looking for inactive RFONTs that realized
* from the given PFF.  These RFONTs are put into a linked list (using the
* PDEV RFONTLINKs) that is returned as the function return.
*
* The function is quite aggressinve in its definition of an inactive RFONT.
* In addition to looking for victims on the inactive list of each PDEV,
* the function also scans the DC list off each PDEV for RFONTs that are
* selected into currently unused DCs.
*
* We're not worried about being aggressive with non-display PDEVs.  The
* PDEV cleanup code will destroy extraneous RFONTs directly using the PDEV's
* RFONT list(s).
*
* The reason we are building a list of RFONT victims rather than killing
* them immediately is because we are holding the ghsemPublicPFT semaphore
* when this function is called.
*
* Returns:
*   Pointer to the kill list, NULL if the list is empty.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
static
RFONT *prfntKillList(PFFOBJ &pffoVictim)
{
    TRACE_FONT((
        "Entering prfntKillList\n\tpffoVictim.pPFF = %-#x\n",pffoVictim.pPFF));
    RFONT *prfntDeadMeat = PRFNTNULL;

    // Must hold this semaphore to be sure that the display
    // PDEV list is stable.

    SEMOBJ so1(ghsemDriverMgmt);

    // Must hold this semaphore so we can manipulate the RFONT links and
    // RFONT::cSelected.

    SEMOBJ so2(ghsemRFONTList);
    TRACE_FONT(("Acquiring ghsemRFONTList\n"));

    // Must hold this mutex so that no one else tries to come in and lock
    // a DC while we're scanning the DC lists off the PDEVs.
    //
    // Since we're holding this mutex, we must be extremely careful not
    // to create any user objects that will try to regrab the mutex.
    // That is bad bad bad bad.

    MLOCKFAST mlf;
    TRACE_FONT(("Acquiring handle management semaphore\n"));

    PDEV *pPDEV = gppdevList;

    // Scan through the list of display PDEVs.

    while (pPDEV != NULL)
    {
        if (pPDEV->fl & PDEV_DISPLAY)
        {
            // Scan the RFONT active list for candidates made inactive by our
            // scan of the DC list.

            RFONT *prfntCandidate;

            for ( prfntCandidate = pPDEV->prfntActive;
                  prfntCandidate != PRFNTNULL;
                )
            {
                RFONTTMPOBJ rfo(prfntCandidate);

                // We have to grab the next pointer before we (possibly)
                // remove the current RFONT from the list.

                prfntCandidate = prfntCandidate->rflPDEV.prfntNext;

                // If this is an interesting RFONT (i.e., uses our PFF),
                // then take it out of the list.

                if ( (rfo.pPFF() == pffoVictim.pPFFGet()) && !rfo.bActive() )
                {
                    RFONT *prfntHead = pffoVictim.prfntList();
                    rfo.vRemove(&prfntHead, PFF_LIST);
                    pffoVictim.prfntList(prfntHead);

                    rfo.vRemove(&pPDEV->prfntActive, PDEV_LIST);
                    rfo.vInsert(&prfntDeadMeat, PDEV_LIST);
                }
            }

            // Scan the RFONT inactive list for candidates.

            for (prfntCandidate = pPDEV->prfntInactive;
                 prfntCandidate != PRFNTNULL;
                 )
            {
                RFONTTMPOBJ rfo(prfntCandidate);

                // We have to grab the next pointer before we (possibly)
                // remove the current RFONT from the list.

                prfntCandidate = prfntCandidate->rflPDEV.prfntNext;

                // If this is an interesting RFONT (i.e., uses our PFF),
                // then take it out of the list.

                if ( rfo.pPFF() == pffoVictim.pPFFGet() )
                {
                    RFONT *prfntHead = pffoVictim.prfntList();
                    rfo.vRemove(&prfntHead, PFF_LIST);
                    pffoVictim.prfntList(prfntHead);

                    rfo.vRemove(&pPDEV->prfntInactive, PDEV_LIST);
                    rfo.vInsert(&prfntDeadMeat, PDEV_LIST);

                    // Since we've removed a font from the inactive list, we
                    // need to update the count in the PDEV.

                    pPDEV->cInactive -= 1;
                }
            }
        }
        pPDEV = pPDEV->ppdevNext;
    }
    TRACE_FONT(("Releasing handle management semaphore\n"));
    TRACE_FONT(("Releasing ghsemRFONTList\n"));
    TRACE_FONT(("Releasing ghsemDriverMgmt\n"));
    TRACE_FONT(("Exiting prfntKillList\n\treturn value=%-#x\n", prfntDeadMeat));
    return(prfntDeadMeat);
}

/******************************Public*Routine******************************\
* bKillRFONTList
*
* Runs down a linked list (that is linked via the PDEV RFONTLINK's) and
* deletes each RFONT on it.  Hold no global semaphores while calling this
* because we may call out to a driver.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
static
BOOL bKillRFONTList(PFFOBJ &pffoVictim, RFONT *prfntVictims)
{
    // If kill list is NULL, it is already OK to delete the PFF.
    // However, we will have to do the work in here rather than let
    // RFONTOBJ::bDeleteRFONTRef() do the work for us.

    BOOL bRet;
    TRACE_FONT((
        "Entering bKillRFONTList\n"
        "\t*pffoVictim.pPFF=%-#x\n"
        "\tprfntVictims=%-#x\n"
        , pffoVictim.pPFF, prfntVictims
    ));

    if (prfntVictims == (PRFONT) NULL)
    {
        BOOL    bCleanUp = FALSE;

        PFFCLEANUP pffc;

        {
            // Need semaphore to access cRFONT.

            SEMOBJ so(ghsemPublicPFT);

            // If no more RFONTs for this PFF, OK to delete.
            // Load count is implied to be zero
            // (only time we call this function).

            // For private/embedded fonts, pPvtDataHead needs to be NULL too.

            ASSERTGDI( (pffoVictim.cLoaded() == 0 && pffoVictim.cNotEnum() == 0 && pffoVictim.pPvtDataHeadGet() == NULL),
                "gdisrv!bKillRFONTList(): PFF load count not zero\n");

            if (pffoVictim.cRFONT() == 0)
            {
            // It is now safe to delete the PFF.

                pffoVictim.vPFFC_Delete(&pffc);

                bCleanUp = TRUE;
            }
        }

        // Call the driver outside of the semaphore.

        if (bCleanUp)
        {
            vCleanupFontFile(&pffc);     // function can handle NULL case
        }

        bRet = TRUE;

    }
    else
    {

        // Otherwise, we will delete the RFONTs in the kill list.  If and when
        // the last RFONT dies, RFONTOBJ::bDeleteRFONTRef() will delete the PFF.

        PRFONT prfnt;

        while ( (prfnt = prfntVictims) != (PRFONT) NULL )
        {
            prfntVictims = prfntVictims->rflPDEV.prfntNext;

            RFONTTMPOBJ rflo(prfnt);

            ASSERTGDI(!rflo.bActive(),
                "gdisrv!bKillRFONTList(): RFONT still active\n");

            PDEVOBJ pdo(rflo.hdevConsumer());
            ASSERTGDI(pdo.bValid(), "gdisrv!bKillRFONTList(): invalid HPDEV\n");

            rflo.bDeleteRFONT((PDEVOBJ *) NULL, (PFFOBJ *) NULL);
            bRet = pffoVictim.bDeleteRFONTRef();
        }
    }
    TRACE_FONT(("Exiting bKillRFONTList\n\treturn value = %d\n", bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* cCapString (pwcDst,pwcSrc,cMax)                                          *
*                                                                          *
* A useful routine to capitalize a string.  This is adapted to our name    *
* strings that show up in logical fonts.  They may or may not have NULL    *
* terminators, but they always fit in a given width.                       *
*                                                                          *
* We assume that we may overwrite the last character in the buffer if      *
* there is no terminator!  (That's what the code was doing when I got      *
* to it.)                                                                  *
*                                                                          *
* Returns: The length, in characters, of the resultant string.             *
*                                                                          *
* History:                                                                 *
*  Sun 13-Dec-1992 17:22:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG cCapString(WCHAR *pwcDst, const WCHAR *pwcSrc,INT cMax)
{
    UNICODE_STRING csSrc,csDst;
    const WCHAR *pwc,*pwcEnd;
    INT cLen;

    // Count the length of the given string, but note that we can be given a
    // string with cMax characters and no terminator!
    // In that case, we truncate the last character and replace it with NULL.

    pwc = pwcSrc;
    pwcEnd = pwc + cMax - 1;

    while (pwc<pwcEnd && *pwc)
        pwc++;

    // Sundown: cMax is int, pwcEnd = cMax -1, safe to truncate

    cLen = (int)(pwc - pwcSrc);            // cLen <= cMax-1, always.

    if (cLen)
    {
        // Initialize the counted string structures.

        csSrc.Length = (USHORT)(cLen * sizeof(WCHAR));    // Measured in bytes!
        csSrc.Buffer = const_cast<WCHAR *>(pwcSrc);
        csSrc.MaximumLength = (USHORT)(cMax * sizeof(WCHAR));

        csDst.Buffer = pwcDst;
        csDst.MaximumLength = (USHORT)(cMax * sizeof(WCHAR));

        // Convert the string.

        RtlUpcaseUnicodeString(&csDst,&csSrc,FALSE);
    }

    // NULL terminate the result.

    pwcDst[cLen] = 0;
    return(cLen);
}

/******************************Member*Function*****************************\
* UINT iHash                                                               *
*                                                                          *
* A case dependent hashing routine for Unicode strings.                    *
*                                                                          *
* Input:                                                                   *
*                                                                          *
*   pwsz                    pointer to the string to be hashed             *
*   c                       number to be mod'ed against at the end         *
*                                                                          *
* Reutrns:                                                                 *
*                                                                          *
*   a 'random' number in the range 0,1,...,c-1                             *
*                                                                          *
* Note: All strings must be capitalized!                                   *
*                                                                          *
* History:                                                                 *
*  Wed 07-Sep-1994 08:12:22 by Kirk Olynyk [kirko]                         *
* Since chuck is gone the mice are free to play. So I have replaced        *
* it with my own variety. Tests show that this one is better. Of           *
* course, once I have gone someone will replace mine. By the way,          *
* just adding the letters and adding produces bad distributions.           *
*  Tue 15-Dec-1992 03:13:15 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks crazy, but I claim there's a theory behind it.       *
\**************************************************************************/
static
UINT iHash(const WCHAR * pwsz, UINT c)
{
    unsigned i = 0;
    while (*pwsz)
    {
        // use the lower byte since that is where most of the
        // interesting stuff happens

        i += 256*i + (UCHAR) *pwsz++;
    }
    return(i % c);
}

/******************************Member*Function*****************************\
* FHOBJ::vInit                                                             *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 18:38:35 -by- Charles Whitmer [chuckwh]                 *
* Compressed the table to contain only pointers to buckets.                *
*                                                                          *
*  Tue 14-Apr-1992 13:48:53 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vInit(FONTHASHTYPE fht_,UINT c)
{
    pfh->id       = FONTHASH_ID;
    pfh->fht      = fht_;
    pfh->cBuckets = c;

    // Currently, none of the buckets are in use

    pfh->cUsed = 0;
    pfh->cCollisions = 0;
    RtlZeroMemory(pfh->apbkt,sizeof(*(pfh->apbkt)) * pfh->cBuckets);

    // Setup head and tail pointers to the doubly linked list of
    // buckets.  This list is maintained in load order.  The ordinal
    // of a bucket is the load time of the earliest loaded PFE in a
    // bucket's list.

    pfh->pbktFirst = (HASHBUCKET *) NULL;
    pfh->pbktLast  = (HASHBUCKET *) NULL;
}

/******************************Member*Function*****************************\
* FHOBJ::vFree                                                             *
*                                                                          *
* History:                                                                 *
*  Tue 15-Dec-1992 00:53:39 -by- Charles Whitmer [chuckwh]                 *
* Deletes remaining hash buckets.                                          *
*                                                                          *
*  Tue 14-Apr-1992 13:48:56 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vFree()
{
    HASHBUCKET *pbkt,*pbktNext;

    if (pfh)
    {
        // Unfortunately, we get called here while a string of PFE's may be
        // hanging on.  One of the PFTOBJ::bUnloadFont calls kills the PFE's
        // separately.
        // We still need to free the small pfel bloks that
        // define enumeration links

        // Clean up any hash buckets.

        for (UINT ii=0; ii<pfh->cBuckets; ii++)
        {
            for
            (
                pbkt = pfh->apbkt[ii];
                pbkt != (HASHBUCKET *) NULL;
                pbkt = pbktNext
            )
            {
                pbktNext = pbkt->pbktCollision;

                // now free the small linking blocks:

                {
                    PFELINK *ppfel = pbkt->ppfelEnumHead;
                    PFELINK *ppfelNext;
                    for ( ; ppfel ; ppfel = ppfelNext)
                    {
                        ppfelNext = ppfel->ppfelNext;
                        VFREEMEM(ppfel);
                    #if DBG
                        if (ppfelNext == NULL)
                        {
                            ASSERTGDI(ppfel == pbkt->ppfelEnumTail,
                               "FHOBJ::vFree(), problem with ppfelEnumTail\n");
                        }
                    #endif
                    }
                }

                VFREEMEM(pbkt);
            }
        }

        // Free the table itself.

        VFREEMEM(pfh);
    }
    pfh   = 0;
    *ppfh = 0;
}

/******************************Member*Function*****************************\
* FHOBJ::pbktSearch (pwsz,pi)                                              *
*                                                                          *
* Tries to locate a HASHBUCKET for the given string.  If found, a pointer  *
* is returned, else NULL.  If pi is non-NULL, the hash index is returned   *
* in either case.                                                          *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 21:11:14 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  Differs from KirkO's old iSearch in that it assumes that all  *
* strings are capitalized, and the hash table is full of pointers to       *
* HASHBUCKETs instead of HASHBUCKETs.                                      *
\**************************************************************************/

HASHBUCKET *FHOBJ::pbktSearch(const WCHAR * pwsz,UINT *pi,PUNIVERSAL_FONT_ID pufi, BOOL bEquiv)
{
    UINT i;
    HASHBUCKET *pbkt;

// If we are requested to look only for equivalency buckets, and we find it,
// we shall return it.

// If we are asked to look for any kind of bucket, and we found equivalency
// bucket first in the linked list, we shall continue to search the linked
// list until we possibly find a non-equivalency bucket. If found both
// equivalency and non-equivalency bucket, we return non-equivalency bucket.
// If we find a non-equivalency bucket, we shall just return.

    HASHBUCKET *pbktEquiv = NULL;

// Locate the hash entry.

    if( pwsz == NULL )
    {
        if( pufi == NULL )
        {
            return NULL;
        }
        i = UFI_HASH_VALUE(pufi) % pfh->cBuckets;
    }
    else
    {
        i = iHash(pwsz,pfh->cBuckets);
    }

// Return the index for those who care.

    if (pi != (UINT *) NULL)
        *pi = i;

// Try to find an existing bucket that matches exactly.

    for
    (
      pbkt =  pfh->apbkt[i];
      pbkt != (HASHBUCKET *) NULL;
      pbkt = pbkt->pbktCollision
    )
    {
        if( pufi != NULL )
        {
            if( UFI_SAME_FILE(&pbkt->u.ufi,pufi) )
            {
                return(pbkt);
            }
        }
        else
        {
            if (!bEquiv || (pbkt->fl & HB_EQUIV_FAMILY))
            {
                const WCHAR *pwcA,*pwcB;
                for (pwcA=pwsz,pwcB=pbkt->u.wcCapName; *pwcA==*pwcB; pwcA++,pwcB++)
                {
                    if (*pwcA == 0)
                    {
                        if (bEquiv)
                        {
                            return(pbkt);
                        }
                        else
                        {

                            if (pbkt->fl & HB_EQUIV_FAMILY)
                            {
                                pbktEquiv = pbkt;
                                break;
                            }
                            else
                            {
                                return(pbkt);
                            }
                        }
                    }
                }
            }
        }
    }
    return(pbktEquiv);
}


/******************************Public*Routine******************************\
*
* BOOL FHOBJ::bAddPFELink
*
* History:
*  02-Jul-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL FHOBJ::bAddPFELink(
    HASHBUCKET *pbkt,    // pointer to bucket with this family name/ufi (if found)
    UINT        iBucket, // index into hash table for this pfe
    WCHAR      *pwcCap,  // capitalized family name
    PFEOBJ&     pfeoNew, // pfe for which we are adding the link
    BOOL        bEquiv   // create equiv or non-equivalency bucket
)
{

    PFELINK *ppfel = NULL;

    if (ppfel = (PFELINK *)PALLOCMEM(sizeof(PFELINK), 'knlG'))
    {
        ppfel->ppfelNext = NULL; // we have just added it;
        ppfel->ppfe      = pfeoNew.ppfeGet();

    // we will create a new bucket if the bucket with this face name does not exist
    // or if we are attempting to create a non-equivalency bucket and we have only
    // found an equivalency name bucket with this family name.

        if ((pbkt == (HASHBUCKET *) NULL) || (!bEquiv && (pbkt->fl & HB_EQUIV_FAMILY)))
        {
            pbkt = (HASHBUCKET *) PALLOCMEM(sizeof(HASHBUCKET), 'bahG');
            if (pbkt == (HASHBUCKET *) NULL)
            {
                VFREEMEM(ppfel);
                return(FALSE);
            }

            // Link the PFE into the empty lists.

            pbkt->ppfelEnumHead = pbkt->ppfelEnumTail = ppfel;

            // Set up the linked list pointers.  We always add new buckets at the
            // tail of the load order linked list.

            if ( pfh->pbktFirst == (HASHBUCKET *) NULL )
            {
                // Special case: this is the first bucket to be put on the list.

                pfh->pbktFirst = pbkt;
                pfh->pbktLast = pbkt;

                pbkt->pbktPrev = (HASHBUCKET *) NULL;
                pbkt->pbktNext = (HASHBUCKET *) NULL;
            }
            else
            {
                pbkt->pbktPrev = pfh->pbktLast;
                pbkt->pbktNext = (HASHBUCKET *) NULL;

                pfh->pbktLast->pbktNext = pbkt;
                pfh->pbktLast = pbkt;
            }

            // Record the time stamp of the bucket.  Its time stamp is the
            // time stamp of its oldest (or first) PFE.  Since this is a new
            // bucket, the time stamp is automatically that of pfeoNew.

            pbkt->ulTime = pfeoNew.ulTimeStamp();

            // Finish up.

            pbkt->fl        = bEquiv ? HB_EQUIV_FAMILY : 0;
            pbkt->cTrueType = (pfeoNew.flFontType() & TRUETYPE_FONTTYPE) ? 1 : 0;
            pbkt->cRaster   = (pfeoNew.flFontType() & RASTER_FONTTYPE) ? 1 : 0;

            // Copy in the string.

            if( fht() == FHT_UFI )
            {
                pfeoNew.vUFI( &(pbkt->u.ufi) );
            }
            else
            {
                for (INT ii=0; ii<LF_FACESIZE; ii++)
                    pbkt->u.wcCapName[ii] = pwcCap[ii];
            }

            // link the bucket into the hash table.

            pbkt->pbktCollision = pfh->apbkt[iBucket];
            if (pbkt->pbktCollision != (HASHBUCKET *) NULL)
                pfh->cCollisions++;
            pfh->apbkt[iBucket] = pbkt;
            pfh->cUsed++;
        }
        else
        {
            // In the following we have found an existing HASHBUCKET.
            // We can assume that its lists are non-empty.

            // Insert into the font enumeration list.  The new PFE is inserted at
            // the tail because we want to preserve the order in which fonts are
            // added to the system (Windows 3.1 compatibility).

            // Append new PFELINK to old tail and fixup the tail pointer

            pbkt->ppfelEnumTail->ppfelNext = ppfel;
            pbkt->ppfelEnumTail = ppfel;

            // Track the number of TrueType fonts.

            if (pfeoNew.flFontType() & TRUETYPE_FONTTYPE)
                pbkt->cTrueType++;

            // Track the number of Raster fonts.

            if (pfeoNew.flFontType() & RASTER_FONTTYPE)
                pbkt->cRaster++;
        }
    }

    return (ppfel != NULL);
}


/******************************Member*Function*****************************\
* FHOBJ::bInsert                                                           *
*                                                                          *
* Insert a new PFE into the font hash table.                               *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 22:51:22 -by- Charles Whitmer [chuckwh]                 *
* Moved HASHBUCKETs out of the hash table.  We now create them as needed.  *
*                                                                          *
*  06-Aug-1992 00:43:37 by Gilman Wong [gilmanw]                           *
* Added support for font enumeration list.                                 *
*                                                                          *
*  Tue 14-Apr-1992 13:49:24 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bInsert(PFEOBJ& pfeoNew)
{
// Capitalize the given string.  We will always match on the capitalized
// string.

    WCHAR wcCap[LF_FACESIZE];

    HASHBUCKET *pbkt;
    UINT iBucket;

// Insert into facename hash only if the typographic face name
// is different from the typeographic family name.  Case insensitive
// since searching in the font hash table is case insensitive.

    if ((fht() == FHT_FACE) &&
        !_wcsicmp(pfeoNew.pwszFaceName(),pfeoNew.pwszFamilyName()))
    {
        return TRUE; // nothing to do.
    }

    if( fht() == FHT_UFI )
    {
        UNIVERSAL_FONT_ID ufi;

        pfeoNew.vUFI( &ufi );
        pbkt = pbktSearch(NULL,&iBucket,&ufi);

    }
    else
    {
        cCapString(wcCap,pwszName(pfeoNew),LF_FACESIZE);

    // Locate the hashbucket.

        pbkt = pbktSearch(wcCap,&iBucket);
    }

// link the pfe into appropriate lists:

    if (!bAddPFELink(pbkt, iBucket, wcCap, pfeoNew, FALSE))
        return FALSE;

// Do we need to add equivalence buckets for this pfe to the hash table?
// This way the same pfe may show up in linked lists hanging off several buckets.

    if ( pfeoNew.bEquivNames() && (fht() == FHT_FAMILY) )
    {
        HASHBUCKET *pbktEquiv;
        PWSZ pwszEquivName = pwszName(pfeoNew);

    // Skip to first equiv name.

        while (*pwszEquivName++);

        // Process each equiv. name until we hit the list terminator (NULL).

        while (*pwszEquivName)
        {
        // Capitalize the name.

            cCapString(wcCap,pwszEquivName,LF_FACESIZE);

        // Locate the hashbucket. We only search for equiv buckets

            pbktEquiv = pbktSearch(wcCap,&iBucket, NULL, TRUE);

            if (!bAddPFELink(pbktEquiv, iBucket, wcCap, pfeoNew, TRUE))
                return FALSE;

        // Skip to next name.

            while (*pwszEquivName++);
        }
    }

    return(TRUE);
}



/******************************Public*Routine******************************\
*
* VOID FHOBJ::vDeletePFELink(HASHBUCKET *phbkt, PFEOBJ& pfeoV)
*
* Delete pfe from the linked list hanging off the bucket and possibly
* also remove the bucket itself, after removing the last pfe from the llist
*
* History:
*  27-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID FHOBJ::vDeletePFELink(HASHBUCKET *phbkt, UINT iBucket,  PFEOBJ& pfeoV)
{
    // Capitalize the search string.

    PFELINK *ppfel, *ppfelV = NULL;

    #if DBG
        BOOL bFoundVictim;      // used only for debugging
    #endif

    // Does the list exist?  It is possible that on the facename list this PFE
    // may not exist.  The set of PFEs in the facename list is a subset of the
    // set of PFEs in the family name list.

    // Return if there is no list.

    if (phbkt == (HASHBUCKET *) NULL)
    {
        // ASSERTGDI(fht() == FHT_FACE, "trying to remove nonexisting pfe\n");
        return;
    }

    // ----------------------------------
    // Remove from font enumeration list.
    // ----------------------------------

    // Check for special case: victim is at the head of list.

    if (phbkt->ppfelEnumHead->ppfe == pfeoV.ppfeGet())
    {
        // remember the pointer, we shall have to free the mem;

        ppfelV = phbkt->ppfelEnumHead;

        // Victim found, new head of list.

        phbkt->ppfelEnumHead = phbkt->ppfelEnumHead->ppfelNext;

        // Tail check.  List may now be empty, so we may need to adjust tail.

        if (phbkt->ppfelEnumHead == NULL)
        {
            phbkt->ppfelEnumTail = NULL;
        }
    }
    else
    {
    // If we're here, victim is either in the middle or end of the list.

        ppfel = phbkt->ppfelEnumHead;

        #if DBG
            bFoundVictim = FALSE;
        #endif

    // Search loop; look for victim on the linked list.

        while (ppfel->ppfelNext)
        {
            if (ppfel->ppfelNext->ppfe == pfeoV.ppfeGet())
            {
                // Victim found.

                ppfelV = ppfel->ppfelNext;
                ppfel->ppfelNext = ppfelV->ppfelNext;

                #if DBG
                    bFoundVictim = TRUE;
                #endif

                // Tail check.  If victim is also the tail, we need a new tail.

                if (ppfelV->ppfelNext == NULL)
                {
                    ASSERTGDI(phbkt->ppfelEnumTail == ppfelV, "ppfelEnumTail problem");
                    phbkt->ppfelEnumTail = ppfel;
                }

                // Get out of search loop.

                break;
            }

            ppfel = ppfel->ppfelNext;
        }

        // PFE must exist somewhere on the list.
        // We saw the case where PFE doesn't exist in the list on Hydra
        // Somehow pffmo.bAddHash failed in bLoadFonts which caused the
        // pffmo.vRemoveHash was called right after.

    }

    if (ppfelV)
    {
    // free the link itself

    VFREEMEM(ppfelV);

    //
    // Track the number of TrueType fonts.
    //

    if (pfeoV.flFontType() & TRUETYPE_FONTTYPE)
    {
        phbkt->cTrueType--;
    }

    //
    // Track the number of Raster fonts.
    //

    if (pfeoV.flFontType() & RASTER_FONTTYPE)
    {
        phbkt->cRaster--;
    }

    //
    // If the bucket has no PFE's attached, delete it.
    //

    if (phbkt->ppfelEnumHead == NULL)
    {
        //
        // We have to remove the HASHBUCKET from the load order linked list.
        //

        if ( phbkt->pbktPrev )
        {
            phbkt->pbktPrev->pbktNext = phbkt->pbktNext;
        }
        else
        {
            pfh->pbktFirst = phbkt->pbktNext;   // new head of list
        }

        if ( phbkt->pbktNext )
        {
            phbkt->pbktNext->pbktPrev = phbkt->pbktPrev;
        }
        else
        {
            pfh->pbktLast = phbkt->pbktPrev;    // new tail of list
        }

        // We also have to remove the HASHBUCKET from the collision list.

        for
        (
          HASHBUCKET **ppbkt = &pfh->apbkt[iBucket];
          *ppbkt != phbkt;
          ppbkt = &((*ppbkt)->pbktCollision)
        )
        {}

        *ppbkt = phbkt->pbktCollision;

        // Reduce the counts in the hash table.

        pfh->cUsed--;
        if (pfh->apbkt[iBucket])
        {
            pfh->cCollisions--;
        }

        // Delete the HASHBUCKET.

        VFREEMEM(phbkt);
    }
    else
    {
        // If we haven't deleted the bucket,
        // check to see if its time stamp should be changed.

        // The time stamp of a bucket is the time stamp of its oldest
        // PFE.  Since the font enumeration PFE list is also maintained
        // in load order, the bucket time stamp is equivalent to the time
        // stamp of the first bucket in its font enumeration list.

        if ( phbkt->ulTime == phbkt->ppfelEnumHead->ppfe->ulTimeStamp )
        {
            // If the time stamps are equal, the head of the list was not
            // deleted.  Therefore, the position of this bucket in the
            // load order list has not changed and we are done.

            return;
        }

        // Update the time stamp.

        phbkt->ulTime = phbkt->ppfelEnumHead->ppfe->ulTimeStamp;

        // The bucket can only get younger if the head of the list is removed.
        // Therefore we need only probe forward for the new position of the
        // hash bucket.

        // We will stop the scan when we are pointing at the bucket that
        // precedes the new position.

        for ( HASHBUCKET *pbktProbe = phbkt;
              (pbktProbe->pbktNext != (HASHBUCKET *) NULL)
              && (pbktProbe->pbktNext->ulTime < phbkt->ulTime);
              pbktProbe = pbktProbe->pbktNext
            );

        // If we found a new position and it isn't the one we already occupy,
        // move the bucket.

        if (pbktProbe != phbkt)
        {
            // Remove the bucket from its current position.

            if (phbkt->pbktPrev )
            {
                phbkt->pbktPrev->pbktNext = phbkt->pbktNext;
            }
            else
            {
                pfh->pbktFirst = phbkt->pbktNext;   // new head of list
            }

            if (phbkt->pbktNext )
            {
                phbkt->pbktNext->pbktPrev = phbkt->pbktPrev;
            }

            // It is not necessary to handle the case of a new tail
            // because if this were the current tail, we would not be
            // attempting to move it.

            // Insert at its new position.  Remember: pbktProbe is pointing to
            // the bucket that should precede this one.

            phbkt->pbktPrev = pbktProbe;
            phbkt->pbktNext = pbktProbe->pbktNext;

            pbktProbe->pbktNext = phbkt;
            if (phbkt->pbktNext )
            {
                phbkt->pbktNext->pbktPrev = phbkt;
            }
            else
            {
                pfh->pbktLast = phbkt;  // new tail for the list
            }
        }
    }
    }
}



/******************************Member*Function*****************************\
* FHOBJ::vDelete                                                           *
*                                                                          *
* Removes a PFE from all the lists hanging off the hash table.             *
*                                                                          *
* History:                                                                 *
*
*  Fri 27-Jun-1997 -by- Bodin Dresevic [BodinD]
* update:
* Added removing pfe's from equivalency buckets, I think this was missing
*
*  Mon 14-Dec-1992 23:39:28 -by- Charles Whitmer [chuckwh]                 *
* Changed to search for buckets.  Made it delete the bucket at the end,    *
* instead of reconstructing the whole table.                               *
*                                                                          *
*  06-Aug-1992 00:43:37 by Gilman Wong [gilmanw]                           *
* New deletion algorithm.  Also, added support for font enumeration list.  *
*                                                                          *
*  Tue 14-Apr-1992 13:49:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vDelete(PFEOBJ& pfeoV)
{
    // Capitalize the search string.

    WCHAR wcCapName[LF_FACESIZE];
    UINT iBucket;
    HASHBUCKET *phbkt;

// Delete from facename hash only if the typographic face name
// is different from the typeographic family name. Case insensitive
// since searching in the font hash table is case insensitive.

    if ((fht() == FHT_FACE) &&
        !_wcsicmp(pfeoV.pwszFaceName(),pfeoV.pwszFamilyName()))
    {
        return; // nothing to do.
    }

    if( fht() == FHT_UFI )

    {
        UNIVERSAL_FONT_ID ufi;

        pfeoV.vUFI( &ufi );
        phbkt = pbktSearch(NULL,&iBucket,&ufi);

    }
    else
    {
        cCapString(wcCapName,pwszName(pfeoV),LF_FACESIZE);

        // Determine hash position in the table.

        phbkt = pbktSearch(wcCapName,&iBucket);
    }

    vDeletePFELink(phbkt,iBucket,pfeoV);

    // this pfe may need to be deleted from the lists hanging off of
    // equivalency buckets:

    if (pfeoV.bEquivNames() && (fht() == FHT_FAMILY))
    {
        HASHBUCKET *pbktEquiv;
        PWSZ pwszEquivName = pwszName(pfeoV);

    // Skip to first equiv name.

        while (*pwszEquivName++);

        // Process each equiv. name until we hit the list terminator (NULL).

        while (*pwszEquivName)
        {
        // Capitalize the name.

            cCapString(wcCapName,pwszEquivName,LF_FACESIZE);

        // Locate the hashbucket. Only search for equivalency buckets

            pbktEquiv = pbktSearch(wcCapName,&iBucket, NULL, TRUE);
            vDeletePFELink(pbktEquiv,iBucket,pfeoV);

        // Skip to next name.

            while (*pwszEquivName++);
        }
    }

}

/******************************Public*Routine******************************\
* ENUMFONTSTYLE efsCompute(BOOL *abFoundStyle, PFEOBJ &pfeo)
*
* Computes a font enumeration style category for the given pfeo.
*
* An array of flags, abFoundStyle, is passed in.  There is a flag
* for each style classification returned by PFEOBJ::efsCompute().
*
* These flags are set as PFEs for each category are found.
* Once a category is filled, then all subsequent fonts of the
* same category are marked as either EFSTYLE_OTHER (if facename
* is different than family name, thereby allowing us to use it
* to distinguish from other fonts of this family) or EFSTYLE_SKIP
* (if facename is the same as the family name).
*
* This is to support Win 3.1 EnumFonts() behavior which can only
* discriminate 4 different styles for each family of fonts.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ENUMFONTSTYLE efstyCompute(BOOL *abFoundStyle, PFEOBJ &pfeo)
{
    ENUMFONTSTYLE efsty = pfeo.efstyCompute();

    if ( !abFoundStyle[efsty] )
    {
        abFoundStyle[efsty] = TRUE;
    }
    else
    {
        if ( _wcsicmp(pfeo.pwszFamilyName(), pfeo.pwszFaceName()) )
        {
            efsty = EFSTYLE_OTHER;
        }
        else
        {
            efsty = EFSTYLE_SKIP;
        }
    }

    return efsty;
}

/******************************Member*Function*****************************\
* BOOL FHOBJ::bScanLists                                                   *
*                                                                          *
* This implements the behavior of EnumFonts() and EnumFontFamilies() when  *
* a NULL name is passed in.  If the bComputeStyles flag is TRUE, the       *
* EnumFonts() behavior of enumerating some fonts by their facename (rather *
* than family name) is used.                                               *
*                                                                          *
* This function puts HPFEs from the hash table and lists into the EFSOBJ.  *
* If bComputeStyles is FALSE, only the font enumeration list heads from    *
* each bucket are added to the EFSOBJ.                                     *
*                                                                          *
* If bComputeStyles is TRUE, then each list is scanned and a style         *
* classification (EFSTYLE) is computed.  Fonts classified as EFSTYLE_OTHER *
* are also added to the EFSOBJ.                                            *
*                                                                          *
* Return:                                                                  *
*   Returns FALSE if an error occurs; TRUE otherwise.                      *
*                                                                          *
* History:                                                                 *
*  15-Jan-1993 -by- Gilman Wong [gilmanw]                                  *
* Changed to use the linked list that preserves PFE load order for outer   *
* loop.                                                                    *
*                                                                          *
*  Mon 14-Dec-1992 23:50:10 -by- Charles Whitmer [chuckwh]                 *
* Changed outer loop logic for new hashing.                                *
*                                                                          *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bScanLists (
    EFSOBJ *pefso,          // fill this EFSOBJ
    ULONG   iEnumType,      // Enum Fonts, Families or FamiliesEx
    EFFILTER_INFO *peffi    // filtering information
)
{
    HASHBUCKET *phbkt;
    // better C++ code generation if you always return a variable
    BOOL bRet = FALSE;
    FLONG       flAdd = 0;
    PFELINK     *ppfel;


    if (iEnumType == TYPE_ENUMFONTFAMILIES)
        flAdd |= FL_ENUMFAMILIES;
    if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
        flAdd |= FL_ENUMFAMILIESEX;

// Scan through the hash table using the load ordered linked list.

    for (phbkt = pfh->pbktFirst;
         phbkt != (HASHBUCKET *) NULL;
         phbkt = phbkt->pbktNext
        )
    {
    // If the list exists, need to scan it.  We skip over equiv. name
    // HASHBUCKETs.  These are here only to allow the mapper to alias
    // printer font names to other "equivlaent" names.  We do not
    // enumerate them.

        if (
            phbkt->ppfelEnumHead
            && !(phbkt->fl & HB_EQUIV_FAMILY)
        )
        {
            ppfel = phbkt->ppfelEnumHead;
            PFEOBJ pfeo(ppfel->ppfe);

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!bScanListsFHOBJ(NULL): bad HPFE handle\n"
                );

        // This flag is used only if bComputeStyles is TRUE (i.e.,
        // processing an EnumFonts() request).  We use this to track
        // whether or not the first suitable font in the list is found
        // yet.  The first font PLUS fonts that are EFSTYLE_OTHER
        // are put in the enumeration.

            BOOL bFoundFirst = FALSE;

        // These flags are set as PFEs for each category are found.
        // Once a category is filled, then all subsequent fonts of the
        // same category are marked as either EFSTYLE_OTHER (if facename
        // is different than family name, thereby allowing us to use it
        // to distinguish from other fonts of this family) or EFSTYLE_SKIP
        // (if facename is the same as the family name).
        //
        // This is to support Win 3.1 EnumFonts() behavior which can only
        // discriminate 4 different styles for each family of fonts.

            BOOL abFoundStyle[EFSTYLE_MAX];
            RtlZeroMemory((PVOID) abFoundStyle, EFSTYLE_MAX * sizeof(BOOL));

        // Windows 3.1 compatibility
        //
        // When NULL is passed into EnumFonts or EnumFontFamilies,
        // raster fonts are not enumerated if a TrueType font of the same
        // name exists.  We can emulate this behavior by turning on
        // the "TrueType duplicate" filter (the same one used by the
        // (GACF_TTIGNORERASTERDUPE app compatibility flag) for the NULL case.

            peffi->bTrueTypeDupeFilter = TRUE;

        // Win3.1 App compatibility flag GACF_TTIGNORERASTERDUPE.  Need
        // to copy count of TrueType from bucket into EFFILTER_INFO, peffi.

            peffi->cTrueType = phbkt->cTrueType;

            // Scan the list for candidates.

            do
            {
                pfeo.ppfeSet(ppfel); // "relock" ppfe;

            // Skip this PFE if it needs to be filtered out.

                if ( pfeo.bFilteredOut(peffi) )
                    continue;

            // EnumFonts() or EnumFontFamilies() processing (bComputeStyles
            // is TRUE for EnumFonts()).

                if (iEnumType != TYPE_ENUMFONTS)
                {
                // EnumFontFamilies --
                // Need only the first one on the list.

                    if (!pefso->bAdd(pfeo.ppfeGet(),EFSTYLE_REGULAR,flAdd,peffi->lfCharSetFilter))
                    {
                    // Error return.  bAdd() will set error code.

                        WARNING(
                            "gdisrv!bScanListsFHOBJ(NULL): "
                            "abandon enum, cannot grow list\n"
                            );
                        return bRet;
                    }

                // Break out of the do..while loop.
                //
                    break;
                }
                else
                {
                    // Compute the style category for this PFE.

                    ENUMFONTSTYLE efsty = efstyCompute(abFoundStyle, pfeo);

                // EnumFonts --
                // If style is EFSTYLE_OTHER, this font falls into an already
                // occupied category but it has a facename that allow it to be
                // distinguished from other fonts of this family.  So it
                // should be added.
                //
                    if ( !bFoundFirst || (efsty == EFSTYLE_OTHER) )
                    {
                        if (!pefso->bAdd(pfeo.ppfeGet(),efsty))
                        {
                            // Error return.  bAdd() will set error code.

                            WARNING(
                                "gdisrv!bScanListsFHOBJ(NULL): "
                                "abandon enum, cannot grow list\n");
                            return bRet;
                        }

                    //
                    // First one has been found.  From now on, we will only
                    // take EFSTYLE_OTHER fonts.
                    //
                        bFoundFirst = TRUE;
                    }

                }

            } while (ppfel = ppfel->ppfelNext);
        }
    }

// Success.
    bRet = TRUE;
    return bRet;
}

/******************************Member*Function*****************************\
* BOOL FHOBJ::bScanLists                                                   *
*                                                                          *
* This implements the behavior of EnumFonts() and EnumFontFamilies() when  *
* a non-NULL name is passed in.  If the bComputeStyles flag is TRUE, the   *
* EnumFonts() behavior of enumerating some fonts by their facename (rather *
* than family name) is used.                                               *
*                                                                          *
* This function puts HPFEs from the hash table and lists into the EFSOBJ.  *
* If bComputeStyles is FALSE, the entire font enumeration list is added    *
* to the EFSOBJ.                                                           *
*                                                                          *
* If bComputeStyles is TRUE, then each list is scanned and a style         *
* classification (EFSTYLE) is computed.  Fonts classified as EFSTYLE_OTHER *
* are excluded from the EFSOBJ.  (These fonts are enumerated by their      *
* facename rather than their family name).                                 *
*                                                                          *
* Return:                                                                  *
*   Returns FALSE if an error occurs; TRUE otherwise.                      *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 23:54:37 -by- Charles Whitmer [chuckwh]                 *
* Modified hash lookup.                                                    *
*                                                                          *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bScanLists
(
    EFSOBJ *pefso,              // fill this EFSOBJ
    PWSZ    pwszName,           // search on this name
    ULONG   iEnumType,          // Enum Fonts, Families or FamiliesEx
    EFFILTER_INFO *peffi        // filtering information
)
{

    WCHAR wcCapName[LF_FACESIZE];

    BOOL bRet = FALSE;          // for better code generation
    FLONG       flAdd = 0;
    PFELINK    *ppfel;

    if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
        flAdd |= FL_ENUMFAMILIESEX;

    // Capitalize the search name.

    cCapString(wcCapName,pwszName,LF_FACESIZE);

    // Search for head of the list.

    HASHBUCKET *pbkt = pbktSearch(wcCapName,(UINT *) NULL);

    // If the list exists, need to scan it.  Unless this is an equiv. name
    // HASHBUCKET.  These are here only to allow the mapper to alias
    // printer font names to other "equivlaent" names.  We do not
    // enumerate them.

    if (pbkt)
    {
        ppfel = pbkt->ppfelEnumHead;
        PFEOBJ pfeo(ppfel->ppfe);

        ASSERTGDI (
            pfeo.bValid(),
            "gdisrv!bScanListsFHOBJ(): bad HPFE handle\n"
            );

        // These flags are set as PFEs for each category are found.
        // Once a category is filled, then all subsequent fonts of the
        // same category are marked as either EFSTYLE_OTHER (if facename
        // is different than family name, thereby allowing us to use it
        // to distinguish from other fonts of this family) or EFSTYLE_SKIP
        // (if facename is the same as the family name).
        //
        // This is to support Win 3.1 EnumFonts() behavior which can only
        // discriminate 4 different styles for each family of fonts.

        BOOL abFoundStyle[EFSTYLE_MAX];
        RtlZeroMemory((PVOID) abFoundStyle, EFSTYLE_MAX * sizeof(BOOL));
        ENUMFONTSTYLE efsty = EFSTYLE_REGULAR;

    //
    // Win3.1 App compatibility flag GACF_TTIGNORERASTERDUPE.  Need
    // to copy count of TrueType from bucket into EFFILTER_INFO, peffi.
    //
        peffi->cTrueType = pbkt->cTrueType;

    //
    // Scan the list for candidates.
    //
        do
        {
            pfeo.ppfeSet(ppfel); // "relock" ppfe;

        // Skip this PFE if it needs to be filtered out.

            if ( pfeo.bFilteredOut(peffi) )
                continue;

        // If servicing an EnumFonts() call (bComputeStyles is TRUE),
        // then some fonts may be excluded.  EnumFontFamilies, however,
        // wants the entire list.

            if (iEnumType == TYPE_ENUMFONTS)
            {
            //
            // Compute the style category for this PFE.
            //
                efsty = efstyCompute(abFoundStyle, pfeo);

            // EnumFonts --
            // If style is EFSTYLE_OTHER, this font falls into an
            // already occupied category but it has a facename that allows
            // it to be distinguished from other fonts of this family.
            // So it will be excluded from this enumeration.  (It will
            // be enumerated by its facename).

                if ( efsty == EFSTYLE_OTHER )
                    continue;

            }

            // Add the font to the enumeration.

            if (!pefso->bAdd(pfeo.ppfeGet(),efsty,flAdd, peffi->lfCharSetFilter))
            {
                // Error return.  bAdd() will set error code.

                WARNING(
                    "gdisrv!bScanListsFHOBJ(): "
                    "abandon enum, cannot grow list\n");
                return bRet;
            }

        } while (ppfel = ppfel->ppfelNext);
    }

    // Success.
    bRet = TRUE;
    return bRet;

}

/******************************Member*Function*****************************\
* FHMEMOBJ::FHMEMOBJ                                                       *
*                                                                          *
* Allocates memory for a font hash table.                                  *
*                                                                          *
* History:                                                                 *
*  Tue 14-Apr-1992 14:44:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

FHMEMOBJ::FHMEMOBJ(FONTHASH **ppfhNew, FONTHASHTYPE fht_, UINT c)
{
    ppfh = ppfhNew;
    *ppfh = (FONTHASH*)
        PALLOCMEM (offsetof(FONTHASH,apbkt) + sizeof(*(pfh->apbkt)) * c, 'sahG');

    pfh = *ppfh;

    if (pfh != (FONTHASH*) NULL)
    {
        vInit(fht_,c);
    }
}

#if DBG
/******************************Public*Routine******************************\
* VOID PFTOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFTOBJ::vPrint()
{
    PFF *pPFF, **ppPFF;
    int i;

    DbgPrint("\nContents of PFT, PPFT = 0x%p\n", pPFT);
    DbgPrint("pfhFamily = %-#p\n", pPFT->pfhFamily);
    DbgPrint("pfhFace   = %-#p\n", pPFT->pfhFace);
    DbgPrint("pfhUFI   = %-#p\n", pPFT->pfhUFI);
    DbgPrint("cBuckets  = %ld\n", pPFT->cBuckets);
    DbgPrint("cFiles    = %ld\n", pPFT->cFiles);
    DbgPrint("PPFF table\n");
    for (
        ppPFF = pPFT->apPFF,i=0
      ; ppPFF < pPFT->apPFF + pPFT->cBuckets
      ; ppPFF++,i++)
    {
        if (pPFF = *ppPFF)
        {
            DbgPrint("\tPFT->apPFF[%d]\n",i);
            while (pPFF)
            {
                if (!pPFF->hdev)
                {
                    DbgPrint("%p\t\"%ws\" %u\n"
                        , pPFF
                        , pPFF->pwszPathname_
                        , pPFF->sizeofThis
                        );
                }
                else
                {
                    DbgPrint("%p\t%p %u\n"
                      , pPFF
                      , pPFF->hdev
                      , pPFF->sizeofThis
                      );
                }
                pPFF = pPFF->pPFFNext;
            }
        }
    }
    DbgPrint("\n");
}
/******************************Member*Function*****************************\
* FHOBJ::vPrint
*
* History:
*  Tue 14-Apr-1992 13:49:51 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID FHOBJ::vPrint(VPRINT print)
{
    UINT i;
    HASHBUCKET *pbkt;
    PFELINK    *ppfel;

    print("    FHOBJ::vPrint()\n\n");
    print("    ppfh           = %-#8lx\n",ppfh);
    print("    pfh            = %-#8lx\n",pfh);
    print(
        "    pfh->id        = %c%c%c%c\n",
        ((char*) (&pfh->id))[0],
        ((char*) (&pfh->id))[1],
        ((char*) (&pfh->id))[2],
        ((char*) (&pfh->id))[3]
        );
    print(
        "         fht       = %s\n",
        pfh->fht == FHT_FAMILY ? "FHT_FAMILY" :
        (pfh->fht == FHT_FACE   ? "FHT_FACE" :
        (pfh->fht == FHT_UFI    ? "FHT_UFI" : "BOGUS VALUE" ))
        );
    print("         cBuckets    = %d\n",pfh->cBuckets);
    print("         cUsed       = %d\n",pfh->cUsed);
    print("         cCollisions = %d\n",pfh->cCollisions);

    for (i = 0; i < pfh->cBuckets; i++)
    {
      for
      (
        pbkt = pfh->apbkt[i];
        pbkt != (HASHBUCKET *) NULL;
        pbkt = pbkt->pbktCollision
      )
      {
        print("         ahbkt[%04d] \"%ws\"\n",i,pbkt->u.wcCapName);
      }
    }

    print(
        "\n\n        hpfe        %s\n\n",
        pfh->fht ? "FamilyName" : "FaceName"
        );

    for (i = 0; i < pfh->cBuckets; i++)
    {
      BOOL bFirst;

      for
      (
        pbkt = pfh->apbkt[i];
        pbkt != (HASHBUCKET *) NULL;
        pbkt = pbkt->pbktCollision
      )
      {
        ppfel   = pbkt->ppfelEnumHead;
        bFirst = TRUE;
        while (ppfel)
        {
            PFEOBJ pfeo(ppfel->ppfe);

            if (bFirst)
            {
                print("        %-#8x    \"%ws\"\n",ppfel->ppfe,pwszName(pfeo));
                bFirst = FALSE;
            }
            else
            {
                print("        %-#8x\n",ppfel->ppfe);
            }
            ppfel = ppfel->ppfelNext;
        }
      }
    }
    print("\n\n");
}
#endif


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetLanguageID
*
* Routine Description:
*
*   This routines returns the default language ID.  Normally, we would call
*   GetLocaleInfoW to get this information but that API is not available in
*   kernel mode.  Since GetLocaleInfoW gets it from the registry we'll do the
*   same.
*
* Arguments: none
*
* Called by:
*
* Return Value:
*
*   The default language ID.  If the call fails it will just return 409
*   for English.
*
\**************************************************************************/

USHORT GetLanguageID()
{
    NTSTATUS NtStatus;
    USHORT Result = 0x409;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    #define NLS_TABLE_KEY \
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language"

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH +
          sizeof(KEY_VALUE_FULL_INFORMATION);

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) PALLOCMEM(BufferSize,'dilG');

        if(KeyValueInformation)
        {
            ULONG ValueReturnedLength;

            RtlInitUnicodeString(&UnicodeString,L"Default");

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {
                ULONG Temp;
                RtlInitUnicodeString(&UnicodeString,
                                     (PCWSTR) &(KeyValueInformation->Data[0]));
                RtlUnicodeStringToInteger(&UnicodeString, 16, &Temp);
                Result = (USHORT) Temp;
            }
            else
            {
                WARNING("GetLanguageID failed to read registry\n");
            }
            VFREEMEM(KeyValueInformation);
        }
        else
        {
            WARNING("GetLanguageID out of memory\n");
        }

        ZwCloseKey(RegistryKeyHandle);
    }
    else
    {
        WARNING("GetLanguageID failed to open NLS key\n");
    }

    return(Result);
}

BOOL PFTOBJ::bUnloadEUDCFont(PWSZ pwszPathname)
{
    PFF *pPFF, **ppPFF;
    WCHAR szUcPathName[MAX_PATH + 1];
    BOOL bRet = FALSE;

    cCapString(szUcPathName,
               pwszPathname,
               wcslen(pwszPathname)+1);


    PUBLIC_PFTOBJ pfto;              // access the public font table
    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);     // This is a very high granularity
                                     // and will prevent text output

    pPFF = pfto.pPFFGet(szUcPathName, wcslen(szUcPathName) + 1, 1,
                        NULL, 0,        // pdv, cjDV
                        &ppPFF,TRUE);

    if (pPFF)
    {
        // bUnloadWorkhorse() guarantees that the public font table
        // semaphore will be released before it returns

        bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, 0);
    }
    else
    {
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return( bRet );
}


/******************************Public*Routine******************************\
* HANDLE PUBLIC_PFTOBJ::hLoadMemFonts                                      *
*                                                                          **                                                                          *                                                                          *
* Returns zero on failure.                                                 *
*                                                                          *
* History:                                                                 *
*  20-May-1997 -by- Xudong Wu [TessieW}                                    *
* Wrote it.                                                                *
\**************************************************************************/

ULONG PUBLIC_PFTOBJ::ulMemoryUnique = 0;

HANDLE PUBLIC_PFTOBJ::hLoadMemFonts
(
    PFONTFILEVIEW  *ppfv,             // font file image
    DESIGNVECTOR *pdv,
    ULONG       cjDV,
    ULONG       *pcFonts
    )
{
    BOOL    bOK = FALSE;
    HANDLE  hMMFont = 0;
    ULONG   cFonts;
    FNTCHECKSUM fntCheckSum;

    PVOID    ppvViews[1];
    ULONG    pcjViews[1];

    ppvViews[0] = ppfv[0]->fv.pvViewFD;
    pcjViews[0] = ppfv[0]->fv.cjView;

    HFF hffNew = HFF_INVALID;
    PPDEV   ppDevList;

// order of grabbing semaphores important

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    vLoadFontFileView(NULL, 0, ppfv, 1, ppvViews, pcjViews, pdv, cjDV, &hffNew ,&ppDevList, &fntCheckSum);
    PDEVOBJ pdo((HDEV)ppDevList);
    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    if (hffNew != HFF_INVALID)
    {
        cFonts = pdo.QueryFontFile( hffNew, QFF_NUMFACES, 0, NULL);

        if (cFonts && cFonts != FD_ERROR)
        {
            WCHAR awc[30];

            *pcFonts = cFonts;

            // create a unique file name for the memory font
            // in the form of "Memory NNN"

            swprintf(awc, L"MEMORY-%u", ulGetNewUniqueness(PUBLIC_PFTOBJ::ulMemoryUnique));

            ULONG cwc = wcslen(awc) + 1;

            PFFCLEANUP *pPFFC = 0;

            PFFMEMOBJ
            pffmo(cFonts,
                  awc, cwc, 1,
                  pdv, cjDV,
                  hffNew, pdo.hdev(),
                  0, pPFT,
                  PFF_STATE_MEMORY_FONT,
                  FR_PRIVATE | FR_NOT_ENUM,  //always use FR_PRIVATE | FR_NOT_ENUM for memory fonts
                  &fntCheckSum,
                  ppfv,
                  NULL);          // pufi

            if (pffmo.bValid())
            {
                if (pffmo.bLoadFontFileTable(awc, cFonts, (HANDLE)0, NULL, NULL))
                {
                    SEMOBJ so2(ghsemPublicPFT);

                    if(bOK = pffmo.bAddHash(FALSE))
                    {
                        PFF **ppPFF, *pPFF;

                        pPFF = pPFFGet(awc, cwc, 1, pdv, cjDV, &ppPFF);

                        if (pPFF)
                        {
                            KdPrint(("bLoadMemFonts(): \"%ws\" has been found on the font table\n"));
                            KdBreakPoint();
                            bOK = FALSE;
                        }
                        else
                        {
                            pPFF = pffmo.pPFFGet();
                            pPFT->cFiles++;

                            //place this new pff at the head of the hash bucket list
                            if (*ppPFF)
                            {
                                (*ppPFF)->pPFFPrev = pPFF;
                            }
                            pPFF->pPFFNext = *ppPFF;
                            pPFF->pPFFPrev = 0;
                            *ppPFF = pPFF;

                            pffmo.vKeepIt();

                            //Sundown: hMMFont is not a real handle but the checksum
                            hMMFont = (HANDLE)(ULONG_PTR)pPFF->ulCheckSum;
                        }
                    }
                    else
                    {
                        pffmo.vRemoveHash();
                    }
                }

                if (!bOK)
                {
                    pffmo.vPFFC_DeleteAndCleanup();  // new code (not so new anymore)
                    bOK = TRUE;
                }
            }
        }
    }

    if (!bOK)
    {
        VFREEMEM(ppfv);
    }
    return hMMFont;
}

ULONG PUBLIC_PFTOBJ::GetEmbedFonts()
{
    ULONG i, cEmbedFonts = 0;
    PFF *pPFF, **ppPFF;
    PVTDATA  *pPvtData;
    DWORD pid, tid;

    if (!bIsPrivatePFT())
        return 0;

    pid = (DWORD) W32GetCurrentPID();
    tid = (DWORD) W32GetCurrentTID();

    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; i < CPRIVATEBUCKETS; i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                pPvtData = pPFF->pPvtDataHead;
                while (pPvtData)
                {
                    if (pPvtData->fl & FRW_EMB_TID)
                    {
                        if (pPvtData->dwID == tid)
                            cEmbedFonts++;
                    }
                    else
                    {
                        if (pPvtData->dwID == pid)
                            cEmbedFonts++;
                    }
                    pPvtData = pPvtData->pPvtDataNext;
                }
                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return cEmbedFonts;
}

BOOL PUBLIC_PFTOBJ::VerifyFontID(VOID *fontID)
{
    ULONG i;
    PFF *pPFF, **ppPFF;
    BOOL bRet = FALSE;

    if (!bIsPrivatePFT())
        return FALSE;


    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; (i < CPRIVATEBUCKETS && !bRet); i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                if ((PFF *)fontID == pPFF)          // PFF match
                {
                    return TRUE;
                }

                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return bRet;
}

BOOL PUBLIC_PFTOBJ::ChangeGhostFont(VOID *fontID, BOOL bLoad)
{
    ULONG i;
    PFF *pPFF, **ppPFF;
    PVTDATA  *pPvtData;
    DWORD pid, tid;
    BOOL bRet = FALSE;

    if (!bIsPrivatePFT())
        return FALSE;

    pid = (DWORD) W32GetCurrentPID();
    tid = (DWORD) W32GetCurrentTID();

    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; (i < CPRIVATEBUCKETS && !bRet); i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                if ((PFF *)fontID == pPFF)          // PFF match
                {
                    pPvtData = pPFF->pPvtDataHead;
                    while(pPvtData)
                    {
                        if (((pPvtData->fl & FRW_EMB_TID) && (pPvtData->dwID == tid)) ||
                             ((!(pPvtData->fl & FRW_EMB_TID)) && (pPvtData->dwID == pid)))
                        {
                            if (bLoad)
                            {
                                pPvtData->cNotEnum++;
                                pPvtData->fl |= FR_PRINT_EMB_FONT;
                                bRet = TRUE;
                            }
                            else
                            {
                                if (pPvtData->cNotEnum)
                                {
                                    pPvtData->cNotEnum--;
                                    pPvtData->fl &= ~FR_PRINT_EMB_FONT;
                                }
                            }
                            break;
                        }
                        pPvtData = pPvtData->pPvtDataNext;
                    }
                }

                if (bRet)
                    break;

                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pw32kevt.h ===
/******************************Module*Header*******************************\
* Module Name: pw32kevt.h
*
* Copyright (c) 1996-1999 Microsoft Corporation
* 
\**************************************************************************/

//
//  NOTE: The following structure has to be in nonpaged memory. It also
//  has to be the same as in videoprt.h.
//

typedef struct  _ENG_EVENT  {
    PKEVENT pKEvent;
    ULONG   fFlags;
    } ENG_EVENT, *PENG_EVENT;

//
//  Manifest constants for fFlags field of ENG_EVENT
//

#define ENG_EVENT_FLAG_IS_MAPPED_USER  0x1

typedef enum {
    type_delete,
    type_unmap
    } MANAGE_TYPE;

#define ENG_KEVENTALLOC(size) (PENG_EVENT)GdiAllocPoolNonPagedNS((size), 'msfD')
#define ENG_KEVENTFREE(ptr)   GdiFreePool((ptr))
#define ENG_ALLOC(size)       (PENG_EVENT)GdiAllocPool( (size), 'msfD')
#define ENG_FREE(ptr)         GdiFreePool((ptr))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rfntxlat.cxx ===
/******************************Module*Header*******************************\
* Module Name: rfntxlat.cxx
*
* Methods for translating wchars to hglyphs or pgd's
*
* Created: March 5, 1992
* Author: Paul Butzi
*
* Copyright (c) 1992-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

void RFONTOBJ::pfdg(FD_GLYPHSET *pfdg)
{
    prfnt->pfdg = pfdg;
}

/******************************Public*Routine******************************\
* void chglyGetAllGlyphHandles
*
* Get all the glyph handles for an RFONTOBJ
* return the number of handles
*
*
* History:
*  06-Mar-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/
COUNT RFONTOBJ::chglyGetAllHandles
(
    HGLYPH *pgh
)
{
// first check if this is one of the tt fonts which supports
// possibly more glyphs than can be accessed via fd_glyphset directly.
// In this case handles are the same as glyph indicies

    IFIMETRICS * pifi = prfnt->ppfe->pifi;

    ULONG cig = 0;

    if (pifi->cjIfiExtra > offsetof(IFIEXTRA, cig))
    {
        cig = ((IFIEXTRA *)(pifi + 1))->cig;
    }

    if (cig)
    {
        if (pgh)
        {
            for (ULONG hg = 0; hg < cig; hg++, pgh++)
                *pgh = hg;
        }

        return cig;
    }

    FD_GLYPHSET *pfdg = prfnt->pfdg;

    if ( pgh == NULL )
        return pfdg->cGlyphsSupported;

    for ( COUNT i = 0; i < pfdg->cRuns; i += 1 )
    {
        WCRUN *pwcr = &pfdg->awcrun[i];

        if ( pwcr->phg != NULL )
        {
            for ( COUNT j = 0; j < pwcr->cGlyphs; j += 1 )
            {
                *pgh = pwcr->phg[j];
                pgh += 1;
        }
    }
    else
    {
        for ( COUNT j = 0; j < pwcr->cGlyphs; j += 1 )
        {
        *pgh = pwcr->wcLow + j;
        pgh += 1;
        }
    }
    }
    return pfdg->cGlyphsSupported;
}


extern const BYTE  acBits[16]  = {0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4};

extern const INT aiStart[17] = {0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};


VOID RFONTOBJ::vXlatGlyphArray(WCHAR *pwc,UINT cwc,HGLYPH *phg, DWORD iMode, BOOL bSubset)
{
    FD_GLYPHSET *pgs = prfnt->pfdg;
    
    BOOL  bHorizGS = FALSE;
    ULONG iFont;
    PFE   *ppfeHoriz;

    iFont = prfnt->ppfe->iFont;

    // if this is used on @face font by font subsetting
    // we return the "base" glyph indices

    if (bSubset && iFont && !(iFont & 1))
    {
        PFEOBJ  pfeObj(ppfeHoriz = ((PFE**)(prfnt->pPFF->aulData))[(iFont - 1) & 0xFFFFFFFE]);
        FD_GLYPHSET  *pgsTmp;

        if (pfeObj.bValid() && (pgsTmp = pfeObj.pfdg()))
        {
            bHorizGS = TRUE;
            pgs = pgsTmp;
        }
    }

    if (pgs->cRuns == 0)
    {
        WARNING("vXlatGlyphArray - empty glyphset\n");

    	for (; cwc != 0; --cwc, ++phg)
        {
    		*phg = prfnt->hgDefault;
    	}
    	return;
    }
    
    WCRUN *pwcRunBase = pgs->awcrun;
    int    iMax  = (int) pgs->cRuns - 1;
    WCRUN *pwcRun;
    int    nwc;
    int    iThis;
    int    iFirst;
    int    cBits;
    HGLYPH hgReplace = (iMode == GGI_MARK_NONEXISTING_GLYPHS) ?
                       0xffffffff : prfnt->hgDefault;

// We should precompute this stuff.

// Count the bits.


    if (iMax > 0xFFFF)
      iMax = 0xFFFF;        // 65000 runs

    if ( iMax & 0xF000 )
      cBits = acBits[(iMax >> 12) & 0x00FF] + 12;
    else if (iMax & 0x0F00 )
      cBits = acBits[(iMax >>  8) & 0x00FF] +  8;
    else if (iMax & 0x00F0)
      cBits = acBits[(iMax >>  4) & 0x00FF] +  4;
    else
      cBits = acBits[iMax];

// Set the starting point.

    iFirst = aiStart[cBits];

    while (cwc)
    {
    // Handle a common case which otherwise causes us to do a lot of
    // useless searching.  It also guarantees that we never have to look
    // below run 0.

        if (*pwc < pwcRunBase->wcLow)
        {

            do { *phg++ = hgReplace; pwc++; cwc--; }
            while (cwc && (*pwc < pwcRunBase->wcLow));
            continue;
        }

    // Binary search to find a run for the first character.

        iThis = iFirst;

        switch (cBits)
        {
        case 16:
          iThis += (*pwc >= pwcRunBase[iThis].wcLow) ? 32768 : 0;
          iThis -= 16384;
        case 15:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 16384 : 0;
          iThis -= 8192;
        case 14:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 8192 : 0;
          iThis -= 4096;
        case 13:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 4096 : 0;
          iThis -= 2048;
        case 12:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 2048 : 0;
          iThis -= 1024;
        case 11:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 1024 : 0;
          iThis -= 512;
        case 10:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 512 : 0;
          iThis -= 256;
        case 9:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 256 : 0;
          iThis -= 128;
        case 8:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 128 : 0;
          iThis -= 64;
        case 7:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 64 : 0;
          iThis -= 32;
        case 6:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 32 : 0;
          iThis -= 16;
        case 5:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 16 : 0;
          iThis -= 8;
        case 4:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 8 : 0;
          iThis -= 4;
        case 3:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 4 : 0;
          iThis -= 2;
        case 2:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 2 : 0;
          iThis -= 1;
        case 1:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 1 : 0;
          iThis -= 1;
        case 0:
            break;
        }
        pwcRun = &pwcRunBase[iThis];     // This is our candidate.
        nwc = *pwc - pwcRun->wcLow;

        if (nwc >= pwcRun->cGlyphs)
        {
        // Oops, there is no such character.  Store the default.

#ifdef FE_SB
            if(bIsLinkedGlyph(*pwc) || bIsSystemTTGlyph(*pwc))
            {
                prfnt->flEUDCState |= EUDC_WIDTH_REQUESTED;
            }
#endif
            *phg++ = hgReplace; pwc++; cwc--;

            continue;
        }

    // Here's the better case, we found a run.  Let's try to use it a lot.

        if (pwcRun->phg != NULL)
        {
            do { *phg++ = pwcRun->phg[nwc]; pwc++; cwc--; }
            while
            (
                cwc
                && ((nwc = *pwc - pwcRun->wcLow) >= 0)
                && (nwc < (int) pwcRun->cGlyphs)
            );
        }
        else
        {
            do { *phg++ = *pwc++; cwc--; }
            while
            (
                cwc
                && ((nwc = *pwc - pwcRun->wcLow) >= 0)
                && (nwc < (int) pwcRun->cGlyphs)
            );
        }
    }

    
    if (bHorizGS)
    {
        PFEOBJ  pfeObj(ppfeHoriz);

        pfeObj.vFreepfdg();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rfntobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: rfntobj.cxx                                                 *
*                                                                          *
* Non-inline methods for realized font objects.                            *
*                                                                          *
* Created: 30-Oct-1990 09:32:48                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.hxx"
#include "flhack.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

#include "winsta.h"

//
// Storage for static globals in rfntobj.hxx
//

extern BOOL G_fConsole;

extern "C" USHORT gProtocolType;
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)

FONTFILE_PRINTKVIEW  *gpPrintKViewList = NULL;
HSEMAPHORE ghsemPrintKView;

NTSTATUS  MapFontFileInKernel(void*, void**);
VOID vUnmapFontFileInKernel(void* pvKView);
void vCleanupPrintKViewList();

const GAMMA_TABLES RFONTOBJ::gTables =
{
  {
        0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00
    ,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00
    ,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x01
    ,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02
    ,   0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03
    ,   0x03,   0x03,   0x04,   0x04,   0x04,   0x04,   0x05,   0x05
    ,   0x05,   0x05,   0x06,   0x06,   0x06,   0x06,   0x07,   0x07
    ,   0x07,   0x08,   0x08,   0x08,   0x08,   0x09,   0x09,   0x09
    ,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D
    ,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10
    ,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x14
    ,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,   0x19
    ,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E
    ,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24
    ,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2A
    ,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31
    ,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39
    ,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41
    ,   0x42,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A
    ,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54
    ,   0x55,   0x56,   0x58,   0x59,   0x5A,   0x5C,   0x5D,   0x5E
    ,   0x60,   0x61,   0x62,   0x64,   0x65,   0x66,   0x68,   0x69
    ,   0x6B,   0x6C,   0x6D,   0x6F,   0x70,   0x72,   0x73,   0x75
    ,   0x76,   0x78,   0x79,   0x7B,   0x7C,   0x7E,   0x80,   0x81
    ,   0x83,   0x84,   0x86,   0x88,   0x89,   0x8B,   0x8D,   0x8E
    ,   0x90,   0x92,   0x93,   0x95,   0x97,   0x99,   0x9A,   0x9C
    ,   0x9E,   0xA0,   0xA1,   0xA3,   0xA5,   0xA7,   0xA9,   0xAB
    ,   0xAD,   0xAE,   0xB0,   0xB2,   0xB4,   0xB6,   0xB8,   0xBA
    ,   0xBC,   0xBE,   0xC0,   0xC2,   0xC4,   0xC6,   0xC8,   0xCA
    ,   0xCC,   0xCE,   0xD0,   0xD2,   0xD5,   0xD7,   0xD9,   0xDB
    ,   0xDD,   0xDF,   0xE1,   0xE4,   0xE6,   0xE8,   0xEA,   0xED
    ,   0xEF,   0xF1,   0xF3,   0xF6,   0xF8,   0xFA,   0xFD,   0xFF
  }
  ,
  {
        0x00,   0x18,   0x20,   0x27,   0x2C,   0x30,   0x34,   0x37
    ,   0x3B,   0x3E,   0x40,   0x43,   0x46,   0x48,   0x4A,   0x4D
    ,   0x4F,   0x51,   0x53,   0x55,   0x56,   0x58,   0x5A,   0x5C
    ,   0x5D,   0x5F,   0x61,   0x62,   0x64,   0x65,   0x67,   0x68
    ,   0x6A,   0x6B,   0x6C,   0x6E,   0x6F,   0x70,   0x72,   0x73
    ,   0x74,   0x75,   0x76,   0x78,   0x79,   0x7A,   0x7B,   0x7C
    ,   0x7D,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85
    ,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8C
    ,   0x8E,   0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94
    ,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,   0x9A
    ,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA1
    ,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,   0xA7
    ,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,   0xAC,   0xAD,   0xAD
    ,   0xAE,   0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB2,   0xB2
    ,   0xB4,   0xB4,   0xB5,   0xB6,   0xB6,   0xB7,   0xB8,   0xB8
    ,   0xB9,   0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBD
    ,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3
    ,   0xC3,   0xC4,   0xC4,   0xC5,   0xC6,   0xC6,   0xC7,   0xC7
    ,   0xC8,   0xC9,   0xC9,   0xCA,   0xCA,   0xCB,   0xCC,   0xCC
    ,   0xCD,   0xCD,   0xCE,   0xCE,   0xCF,   0xD0,   0xD0,   0xD0
    ,   0xD1,   0xD2,   0xD2,   0xD3,   0xD3,   0xD4,   0xD4,   0xD5
    ,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,   0xD8,   0xD9,   0xD9
    ,   0xDA,   0xDA,   0xDB,   0xDB,   0xDC,   0xDC,   0xDD,   0xDD
    ,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,   0xE1
    ,   0xE2,   0xE3,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE5
    ,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,   0xE8,   0xE9,   0xE9
    ,   0xEA,   0xEA,   0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED
    ,   0xEE,   0xEE,   0xEF,   0xEF,   0xEF,   0xF0,   0xF0,   0xF0
    ,   0xF1,   0xF2,   0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5
    ,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF8
    ,   0xF9,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,   0xFB,   0xFC
    ,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF,   0xFF
 }
};

LONG lNormAngle(LONG lAngle);

BOOL
bGetNtoWScales (
    EPOINTFL *peptflScale, // return address of scaling factors
    XDCOBJ& dco,            // defines device to world transformation
    PFD_XFORM pfdx,        // defines notional to device transformation
    PFEOBJ& pfeo,          // defines baseline direction
    BOOL *pbIdent          // return TRUE if NtoW is identity (with repsect
                           // to EVECTFL transormations, which ignore
                           // translations)
    );

//
// The iUniqueStamp is protected by the ghsemRFONTList semaphore.
//

ULONG iUniqueStamp;

// Maximum number of RFONTs allowed on the PDEV inactive list.

#define     cMaxInactiveRFONT       32

// Device height over which we will cache PATHOBJ's instead of bitmaps.

static const ULONG gulOutlineThreshold = 800;


/******************************Public*Routine******************************\
* ulSimpleDeviceOrientation                                                *
*                                                                          *
* Attempts to calculate a simple orientation angle in DEVICE coordinates.  *
* This only ever returns multiples of 90 degrees when it succeeds.  If the *
* calculation would be hard, it just returns 3601.                         *
*                                                                          *
* Note that the text layout code, for which the escapement and orientation *
* are recorded in the RFONT, always considers its angles to be measured    *
* from the x-axis towards the positive y-axis.  (So that a unit vector     *
* will have a y component equal to the cosine of the angle.)  This is NOT  *
* what an application specifies in world coordinates!                      *
*                                                                          *
*  Sat 05-Jun-1993 -by- Bodin Dresevic [BodinD]                            *
* Wrote it.  It looks more formidable than it is.  It actually doesn't     *
* execute much code.                                                       *
\**************************************************************************/

ULONG ulSimpleDeviceOrientation(RFONTOBJ &rfo)
{
// Calculate the orientation in device space.

    INT sx = (INT) rfo.prfnt->pteUnitBase.x.lSignum();
    INT sy = (INT) rfo.prfnt->pteUnitBase.y.lSignum();

// Exactly one of these must be zero (for the orientation to be simple).

    if ((sx^sy)&1)
    {
    // Calculate the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 : 2700
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF :  900

        ULONG ulOrientDev = (sx & 1800) | (sy & 900) | ((-sy) & 2700);

        return(ulOrientDev);

    }

// If it's not simple, return an answer out of range.

    return(3601);
}

/******************************Public*Routine******************************\
* VOID RFONTOBJ::RFONTOBJ (PRFONT prfnt)
*
* Deletion Constructor for RFONTOBJ.  Note that this is only used
* in DC deletion, where we create the RFONTOBJ only to let it expire.
*
* We set up the RFONTOBJ only to unlock the handle and blow away the
* rfont.
*
* Ok, so it's sleazy.  I couldn't think of a cleaner way.  Sue me.
*
* History:
*  06-Feb-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/
RFONTOBJ::RFONTOBJ (PRFONT _prfnt)
{
    prfnt = _prfnt;
    if (prfnt != NULL)
    {
        vMakeInactive();

        prfnt = (PRFONT)NULL;
    }
}

/******************************Public*Routine******************************\
* RFONTOBJ::vInit (dco, bNeedPaths)                                        *
*                                                                          *
* Constructor for a realized font user object.  More complicated than most *
* contructors, this one doesn't even take an handle as an input.  Instead, *
* it accepts a dc reference.  This constructor creates a user object for   *
* the font realization for the font which is currently selected into the   *
* DC.  The name of the game here is to be fast in the common case, which   *
* is that the LFONT selection has not changed since the last time we were  *
* here.                                                                    *
*                                                                          *
* Note that the destructor for this class DOES NOT unlock the object.      *
* That only happens when the object is deselected in the routine or in the *
* sleazy deselection constructor above.                                    *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  15-Nov-1995 -by- Kirk Olynyk [kirko]                                    *
* Renamed from vInit to  to bInit. bInit is called by a stub called vInit  *
* If the return value is true then vInit calls vGetCache(), if the         *
* return value is false then vInit does not call vGetCache. This assures   *
* that the last thing that a valid construtor does is lock the cache       *
* semaphore. Before this change, the PFFREFOBJ destructor could sneak      *
* in and acquire the font semaphore inside a cache critical section.       *
*                                                                          *
*  Tue 10-Mar-1992 18:59:54 -by- Charles Whitmer [chuckwh]                 *
* Made this, the body of the constructor, optional.                        *
*                                                                          *
*  31-Jan-1992 -by- Paul Butzi                                             *
* Serious rewrite.                                                         *
*                                                                          *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bGrayRequestTheSame(XDCOBJ &dco)
{
    BOOL bRet = TRUE;

// if gulFontInformation did change, this would only matter to tt and ps fonts
// and if this is a screen or memory dc

    if (dco.bDisplay() || (dco.dctp() == DCTYPE_MEMORY))
    {
        PRFONT prfnt = dco.pdc->prfnt();

        if (prfnt->fobj.flFontType & (TRUETYPE_FONTTYPE|FO_POSTSCRIPT))
        {
            FLONG  flRequest = 0;

            if (gulFontInformation & FE_AA_ON)
            {
                flRequest |= FO_GRAY16;
                if (gulFontInformation & FE_CT_ON)
                    flRequest |= FO_CLEARTYPE_X;
            }

            if (prfnt->fobj.flFontType & TRUETYPE_FONTTYPE)
            {
                if (flRequest != (prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X)))
                    return FALSE;
            }
            else // (prfnt->fobj.flFontType & FO_POSTSCRIPT)
            {
                if ((flRequest & FO_GRAY16) != (prfnt->fobj.flFontType & FO_GRAY16))
                    return FALSE;
            }

            if ((prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X)) && IsRemoteConnection())
            {
                // the session got changed from console to remote and we need to force ClearType and gray antialiazing off
                return FALSE;
            }

        }
    }
    return bRet;
}


BOOL RFONTOBJ::bInit(XDCOBJ &dco, BOOL bNeedPaths, FLONG flType)
{
//
// We start out with the currently selected RFONT.
// That way, if we deselect it, we will unlock it!
//
    prfnt = dco.pdc->prfnt();

// Early out--maybe the font has not changed.

    if
    (
        bValid()                                            &&
        (dco.pdc->hlfntNew() == dco.pdc->hlfntCur())
    )
    {
        if
        (
            (iGraphicsMode() == dco.pdc->iGraphicsMode())     &&
            (bNeedPaths == prfnt->bNeededPaths)               &&
            (flType == (prfnt->flType & RFONT_TYPE_MASK))     &&
            bGrayRequestTheSame(dco)                          &&
            !dco.pdc->bUseMetaPtoD()
        )
        {

        // xform must be initialiazed before checking
        // dco.pdc->bXFormChange()

            EXFORMOBJ xo(dco, WORLD_TO_DEVICE);
            ASSERTGDI(xo.bValid(),
                "gdisrv!RFONTOBJ(dco) - invalid xform in dcof\n"
                );


        // bNeedPath clause is added to the above check since last time
        // this font could have been realized with bitmaps or metrics only
        // rather than with paths [bodind]

            if (!dco.pdc->bXFormChange())

            {
            // Since the LFONT  and xform have not changed, we know that we
            // already have the right RFONT selected into the DC
            // so we are just going to use it.  Remember that if it is
            // already selected it is also locked down.

                return(TRUE);
            }
            else
            {
            // Get World to Device transform (but with translations removed),
            // check if it happens to be to essentially the same as the old one


                if (xo.bEqualExceptTranslations(&(prfnt->mxWorldToDevice)))
                {
                    dco.pdc->vXformChange(FALSE);
                    return(TRUE);
                }
            }
        }
    }
    else
    {
    // LogFont has definitely changed, so update the current handle.

        dco.pdc->hlfntCur(dco.pdc->hlfntNew());
    }

// Get PDEV user object (need for bFindRFONT).  We also need to make
// sure that we have loaded device fonts before we go off to the font mapper.
// this must be done before the ghsemPublicPFT is locked down.

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!RFONTOBJ(dco): bad pdev in dc\n");

    if (!pdo.bGotFonts())
        pdo.bGetDeviceFonts();

// If we get to here, either the LFONT has changed since the last
// text operation, or the XFORM has changed.  In either case, we'll look
// on the list of RFONTs on the pdev to see if we can find the right
// realization.  If not, we'll just have to realize it now.

    vMakeInactive();    // deselects the rfont

//
// Now we have no selected RFONT.  We're going to track one down
// that corresponds to the current XFORM and LFONT,
// and 'select' it.

// Lock and Validate the LFONTOBJ user object.

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        dco.pdc->prfnt(prfnt);
        return(FALSE);
    }

// This is an opportune time to update the fields in the DC that
// are cached from the LFONTOBJ...

    dco.pdc->flSimulationFlags(lfo.flSimulationFlags());

// Note that our internal angles are always towards the positive y-axis,
// but at the API they are towards the negative y-axis.


    dco.pdc->lEscapement(lNormAngle(-lfo.lEscapement()));

//
// Now we're ready to track down this RFONT we want...
//

    PFE     *ppfe;          // realize this font
    FD_XFORM fdx;           // realize with this notional to device xform
    FLONG    flSim;         // simulation flags for realization
    POINTL   ptlSim;        // for bitmap scaling simulations
    FLONG    flAboutMatch;  // info about how the font mapping was done

// We will hold a reference to whatever PFF we map to while trying to
// realize the font.

    PFFREFOBJ pffref;

// Temporarily grab the global font semaphore to do the mapping.

    {
    // Stabilize the public PFT for mapping.

        SEMOBJ  so(ghsemPublicPFT);

    // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
    // a simulation type (ist)

        ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch, flType & RFONT_TYPE_HGLYPH);

    // Compute the Notional to Device transform for this realization.

        PFEOBJ  pfeo(ppfe);
        IFIOBJ  ifio(pfeo.pifi());

        ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

    // Map mode settings have no effect on stock logfont under Windows.
    // App PeachTree accounting relies on this behavior for postscript
    // printing works properly.

        BOOL   bIgnoreMapMode = (!(pdo.bDisplayPDEV()) && (lfo.fl() & LF_FLAG_STOCK) );

        if (
            !pfeo.bSetFontXform(
                dco, lfo.plfw(),
                &fdx,
                bIgnoreMapMode ? ND_IGNORE_MAP_MODE : 0,
                flSim,
                (POINTL* const) &ptlSim,
                ifio,
                FALSE
                )
        )
        {
            WARNING("gdisrv!RFONTOBJ(dco): failed to compute font transform\n");
            prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
            dco.pdc->prfnt(prfnt);
            return(FALSE);
        }

    // this is needed only by ttfd to support win31 hack: VDMX XFORM QUANTIZING
    // NOTE: in the case that the requested height is 0 we will pick a default
    // value which represent the character height and not the cell height for
    // Win 3.1 compatibility.  Thus I have he changed this check to be <= 0
    // from just < 0. [gerritv]


        if (ifio.bTrueType() && (lfo.plfw()->lfHeight <= 0))
            flSim |= FO_EM_HEIGHT;

    // Tell PFF about this new reference, and then release the global sem.
    // Note that vInitRef() must be called while holding the semaphore.

        pffref.vInitRef(pfeo.pPFF());
    }

// go find the font

    EXFORMOBJ xoWtoD(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!RFONTOBJ(dco) - \n");


// When looking for an RFONT it is important that we don't consider those
// who have small metrics in the GLYPHDATA cache if there is any possibility
// that we will hit the G1,G2,or G3 cases in the glyph layout code.  We will
// possibly hit this if the escapment in the LOGFONT is non-zero or the
// WorldToDevice XFORM is more than simple scaling or has negative values is
// M11 or M22.


    BOOL bSmallMetricsOk;

    if( ( dco.pdc->lEscapement() == 0 ) &&
         xoWtoD.bScale()  &&
         !xoWtoD.efM22().bIsNegative() &&
         !xoWtoD.efM11().bIsNegative() )
    {
        bSmallMetricsOk = TRUE;
    }
    else
    {
        bSmallMetricsOk = FALSE;
    }


// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if
    (
        bFindRFONT
        (
            &fdx,
            flSim,
            0, // lfo.pelfw()->elfStyleSize,
            pdo,
            &xoWtoD,
            ppfe,
            bNeedPaths,
            dco.pdc->iGraphicsMode(),
            bSmallMetricsOk,
            flType
        )
    )
    {
        dco.pdc->prfnt(prfnt);

        dco.pdc->vXformChange(FALSE);

        return(TRUE);
    }

//
// if we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.
//


    if ( !bRealizeFont(&dco,
                       &pdo,
                       lfo.pelfw(),
                       ppfe,
                       &fdx,
                       (POINTL* const) &ptlSim,
                       flSim,
                       0, // lfo.pelfw()->elfStyleSize,
                       bNeedPaths,
                       bSmallMetricsOk, flType) )
    {
        WARNING1("gdisrv!RFONTOBJ(dco): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        dco.pdc->prfnt(prfnt);

        return(FALSE);
    }
    ASSERTGDI(bValid(), "gdisrv!RFONTOBJ(dco): invalid hrfnt from realization\n");


// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Select this into the DC if successful.

    dco.pdc->prfnt(prfnt);

// Finally, grab the cache semaphore.

    dco.pdc->vXformChange(FALSE);

    return(TRUE);
}

/******************************Private*Routine******************************\
* RFONTOBJ::bMatchRealization()                                            *
*                                                                          *
* Return if prfnt matches a font realization caller wants.                 *
*                                                                          *
* History:                                                                 *
*  Wed 13-Sep-00 -by- Michael Leonov [mleonov]                             *
* Moved diplicating code from bFindRFONT into this function.               *
*                                                                          *
\**************************************************************************/
BOOL RFONTOBJ::bMatchRealization(
    PFD_XFORM   pfdx,
    FLONG       flSim,
    ULONG       ulStyleHt,
    EXFORMOBJ * pxoWtoD,
    PFE       * ppfe,
    BOOL        bNeedPaths,
    INT         iGraphicsMode,
    BOOL        bSmallMetricsOk,
    FLONG       flType
)
{
    if (prfnt->ppfe != ppfe)
        return FALSE;

    if (flType != (prfnt->flType & RFONT_TYPE_MASK))
        return FALSE;

    FLONG flXOR = prfnt->fobj.flFontType ^ flSim; // set the bits that are different
    if ((flXOR & (FO_EM_HEIGHT | FO_SIM_BOLD | FO_SIM_ITALIC)) == 0 )
    {
        flXOR &= (FO_GRAY16 | FO_CLEARTYPE_X | FO_CLEARTYPENATURAL_X); // focus just on ct and aa
        

        if (flXOR)
        {
            // The gray bits disagree but we still have a chance.
            // If the request is for gray but the font cannot
            // provide gray fonts at this particular font size
            // then this realization is OK

            if (flSim & FO_GRAY16)
            {
                if (prfnt->fobj.flFontType & FO_NOGRAY16)
                {
                    flXOR &= (FO_CLEARTYPE_X | FO_CLEARTYPENATURAL_X); // still need to look if we ask for the same AA type
                }
            }

            // If asking font sets CT bit but Rfont in cache doesn't set CT bit 
            // and FO_GRAY16 bit sets, then we assume this font cannot provide
            // CT at this size. So this realization is OK

            if ( (flSim & FO_CLEARTYPE_X) && !(prfnt->fobj.flFontType & FO_CLEARTYPE_X) )
            {
                if (prfnt->fobj.flFontType & FO_NOCLEARTYPE)
                {
                    flXOR = 0;
                }
            }
        }
        if (flXOR == 0)
          if (prfnt->fobj.ulStyleSize == ulStyleHt)
            if (bMatchFDXForm(pfdx))
              if ( bNeedPaths == prfnt->bNeededPaths )
                if ( !pxoWtoD || pxoWtoD->bEqualExceptTranslations(&(prfnt->mxWorldToDevice)))
                  if (prfnt->iGraphicsMode == iGraphicsMode)
                    if ( (!bSmallMetricsOk ) ? !(prfnt->cache.bSmallMetrics) : TRUE )
                    {
                        return TRUE;
                    }
    }
    return FALSE;
}


/******************************Public*Routine******************************\
* RFONTOBJ::bFindRFONT()                                                   *
*                                                                          *
* Find the rfont on the chain on the pdev, if it exists.                   *
*                                                                          *
* History:                                                                 *
*  Mon 08-Feb-1993 11:26:31 -by- Charles Whitmer [chuckwh]                 *
* Added dependency on graphics mode.                                       *
*                                                                          *
*  10-Feb-92 -by- Paul Butzi                                               *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bFindRFONT(
    PFD_XFORM  pfdx,
    FLONG      flSim,
    ULONG      ulStyleHt,
    PDEVOBJ&   pdo,
    EXFORMOBJ *pxoWtoD,
    PFE       *ppfe,
    BOOL       bNeedPaths,
    INT        iGraphicsMode,
    BOOL       bSmallMetricsOk,
    FLONG      flType
)
{
    ASSERTGDI(prfnt == NULL,
        "gdisrv!RFONTOBJ:bFindRFONT - prfnt != NULL");

    SEMOBJ so(ghsemRFONTList);

//
// Search active list.  If we find it, just increment selection
// count and leave.
//

    for (  prfnt = pdo.prfntActive();
                prfnt != (PRFONT)NULL;
                prfnt = prfnt->rflPDEV.prfntNext)
    {
        ASSERTGDI(prfnt->cSelected >= 1,
                "gdisrv!RFONTOBJ::bFindRFONT - cSelected < 1 on active list\n");
        if (bMatchRealization(
            pfdx,
            flSim,
            ulStyleHt,
            pxoWtoD,
            ppfe,
            bNeedPaths,
            iGraphicsMode,
            bSmallMetricsOk,
            flType
            ))
        {
            prfnt->cSelected += 1;
            PRFONT head = pdo.prfntActive();
            if( head != prfnt )
            {
                vRemove(&head, PDEV_LIST);
                vInsert(&head, PDEV_LIST); // we always insert at head
                pdo.prfntActive(head);
            }
            return TRUE;
        }
    }

//
// Search inactive list.  If we find it, we must take it off the
// inactive list and put it on the active list.
//
    PRFONT prfntLast = (RFONT*) NULL;
    for (  prfnt = pdo.prfntInactive();
                prfnt != NULL;
                prfntLast = prfnt, prfnt = prfnt->rflPDEV.prfntNext)
    {
        ASSERTGDI(prfnt->cSelected == 0,
                "gdisrv!RFONTOBJ::bFindRFONT - cSelected != 0 on inactive list\n");

        if (bMatchRealization(
            pfdx,
            flSim,
            ulStyleHt,
            pxoWtoD,
            ppfe,
            bNeedPaths,
            iGraphicsMode,
            bSmallMetricsOk,
            flType
            ))
        {
            // first, take it off inactive list

            PRFONT prfntHead = pdo.prfntInactive();
            vRemove(&prfntHead, PDEV_LIST);
            pdo.prfntInactive(prfntHead);   // vRemove MAY change head of list

            pdo.cInactive(pdo.cInactive()-1);

            // finally, put it on the active list and increment Selected count

            prfntHead = pdo.prfntActive();
            vInsert(&prfntHead, PDEV_LIST);
            pdo.prfntActive(prfntHead);     // vInsert changes head of list

            prfnt->cSelected = 1;

            return TRUE;
        }
    }

    prfnt = (RFONT*) NULL;
    return FALSE;
}

/******************************Public*Routine******************************\
* RFONTOBJ::VerifyCacheSemaphore
*
* Useful debugging code to verify the semaphore release
*
* History:
*
* 5-4-2000 Yung-Jen Tony Tsai 
* Write it.
\**************************************************************************/

#ifdef FE_SB

/******************************Public*Routine******************************\
* RFONTOBJ::bMakeInactiveHelper()
*
* Take the rfont off the active list, put on the inactive list, Return a
* list of linked fonts to deactivate.
*
* History:
*
*  13-Jan-95 -by- Hideyuki Nagase [hideyukn]
* Rewrite it.
*
*  29-Sep-93 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bMakeInactiveHelper(PRFONT *pprfnt)
{
    BOOL bLockEUDC = FALSE;

// Quick out if NULL or already inactive.

    if ((prfnt == NULL) || (prfnt->cSelected == 0))
        return(bLockEUDC);

// If prfVictim is changed to a valid pointer, then a victim was selected
// off the inactive list for deletion.

    PRFONT prfVictim = PRFNTNULL;

    {
        // in order to avoid a deadlock (ghsemRFONTList, ghsemEUDC1)
        // we increament the gcEUDCCount first

        if (pprfnt != NULL)
        {
            INCREMENTEUDCCOUNT;
        }
        
        SEMOBJ so(ghsemRFONTList);

    // Since RFONT is being deselected from a DC, remove a reference count.

        prfnt->cSelected -= 1;
        
    // If no more references, take the RFONT off the active list.

        if ( prfnt->cSelected == 0 )
        {

         // if pprfnt is not null, enumrate EUDC RFONT, and store pprfnt array.
                                                 
            if(pprfnt != NULL)
            {
                if(prfnt->prfntSystemTT)
                {
                    *pprfnt++ = prfnt->prfntSystemTT;
                    prfnt->prfntSystemTT = NULL;
                }
    
             // We need to accumulate a list of Linked/EUDC RFONTS and deactive
             // if pprfnt is not null, enumrate EUDC RFONT, and store pprfnt array.
                
                bLockEUDC = TRUE;

                if( prfnt->prfntSysEUDC != NULL )
                {
                    *pprfnt++ = prfnt->prfntSysEUDC;
                    prfnt->prfntSysEUDC = (RFONT *)NULL;
                }
    
                if( prfnt->prfntDefEUDC != NULL )
                {
                    *pprfnt++ = prfnt->prfntDefEUDC;
                    prfnt->prfntDefEUDC = (RFONT *)NULL;
                }
                
                for( UINT ii = 0; ii < prfnt->uiNumLinks ; ii++ )
                {
                    if (prfnt->paprfntFaceName[ii] != NULL)
                    {
                        *pprfnt++ = prfnt->paprfntFaceName[ii];
                        prfnt->paprfntFaceName[ii] = (RFONT *)NULL;
                    }
                }
                prfnt->uiNumLinks = 0;
                prfnt->bFilledEudcArray = FALSE;
            }
            else
            {
                ASSERTGDI( (prfnt->prfntSysEUDC == NULL),
                    "vMakeInactiveHelper:deactivated an RFONT with a System EUDC.\n" );
                ASSERTGDI( (prfnt->prfntDefEUDC == NULL),
                           "vMakeInactiveHelper:deactivated an RFONT with a Default \
                            EUDC.\n" );
                ASSERTGDI( (prfnt->uiNumLinks == 0),
                     "vMakeInactiveHelper:deactivated an RFONT with uiNumLinks\n");
            }

            PDEVOBJ pdo(prfnt->hdevConsumer);

        // Take it off the active list.

            PRFONT prf = pdo.prfntActive();
            vRemove(&prf, PDEV_LIST);
            pdo.prfntActive(prf);       // vRemove might change head of list

        // If font file no longer loaded, then make this RFONT the victim
        // for deletion.

            PFFOBJ pffo(prfnt->pPFF);
            ASSERTGDI(pffo.bValid(), "gdisrv!vMakeInactiveRFONTOBJ(): invalid PFF\n");

            // Possible race condition.  We're checking the count
            //     without the ghsemPublicPFT semaphore.  It could be that
            //     this is ABOUT to become zero, but we miss it.  I claim
            //     that this rarely happens and if it does, so what?  We'll
            //     eventually get rid of this font when it gets flushed out
            //     of the inactive list.  This code is just an attempt to
            //     get it out faster.   [GilmanW]

            if ( (pffo.cLoaded() == 0) && (pffo.cNotEnum() == 0) && (pffo.pPvtDataHeadGet() == NULL) )
            {
                prfVictim = prfnt;
            }

        // Otherwise, put it on the inactive list.

            else
            {
                if ( pdo.cInactive() >= cMaxInactiveRFONT )
                {
                // Too many inactive rfonts, blow one away!  Pick the last one on
                // the list.

                    for ( prf = pdo.prfntInactive();
                          prf != NULL;
                          prfVictim = prf, prf = prf->rflPDEV.prfntNext)
                    {
                    }

                // Remove victim from inactive list.

                    RFONTTMPOBJ rfo(prfVictim);

                    prf = pdo.prfntInactive();
                    rfo.vRemove(&prf, PDEV_LIST);
                    pdo.prfntInactive(prf); // vRemove might change head of list

                // We don't need to modify the count because, even though we
                // just removed one, we're going to add one back right away.

                }
                else
                {
                // We definitely made the list get longer.

                    pdo.cInactive(pdo.cInactive()+1);
                }

                prf = pdo.prfntInactive();
                vInsert(&prf, PDEV_LIST);
                pdo.prfntInactive(prf);     // vInsert changes head of list
            }
        }
    }

    // decreament the gcEUDCCount if there is no EUDC RFONTs

    if (pprfnt != NULL && !bLockEUDC)
    {
        DECREMENTEUDCCOUNT;
    }

// If we removed a victim from the inactive list, we can now delete it.

    if ( prfVictim != PRFNTNULL )
    {
        RFONTTMPOBJ rfloVictim(prfVictim);

    // Need this so we can remove this from the PFF's RFONT list.

        PFFOBJ pffo(prfVictim->pPFF);
        ASSERTGDI(pffo.bValid(), "gdisrv!vMakeInactiveRFONTOBJ(): bad HPFF");

    // We pass in NULL for ppdo because we've already removed it from the
    // PDEV list.

    // bDelete keeps the list head ptrs updated

        rfloVictim.bDeleteRFONT((PDEVOBJ *) NULL, &pffo);
    }

// No longer valid RFONTOBJ.  RFONT is now on the inactive list or deleted.

    prfnt = (PRFONT) NULL;
    return(bLockEUDC);
}


/******************************Public*Routine******************************\
* RFONTOBJ::vMakeInactive()
*
* Take the rfont off the active list, put on the inactive list
*
* History:
*  13-Jan-95 -by- Hideyuki Nagase [hideyukn]
* Rewrite it.
*
*  29-Sep-93 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vMakeInactive()
{
// We will treat this as a NULL terminated array of pointers to RFONTS so
// we need an extra ptr at the end for the NULL termination and
// SystemWide and Default EUDC Rfonts.


    PRFONT aprfnt[QUICK_FACE_NAME_LINKS + 4];
    PRFONT *pprfnt;
    BOOL   bLockEUDC, bScratch, bAllocated;

    if ((prfnt == NULL) || (prfnt->cSelected == 0))
        return;

// if the quick buffer is not enough, just allocate it here.

    if( prfnt->uiNumLinks > QUICK_FACE_NAME_LINKS )
    {
    // we need an extra ptr at the end for the NULL termination and
    // SystemWide and Default EUDC Rfonts.

        pprfnt = (PRFONT *) PALLOCMEM((prfnt->uiNumLinks+4)*sizeof(PRFONT),'flnk');
        if (pprfnt)
        {
            bAllocated = TRUE;
        }
        else
        {
        // this a small allocation which is really unlikely to fail.
        // If it does, we are probably in such a deep trouble that
        // it does not matter that we will leek even further by not
        // freeing mem allocated by this rfont. Also, in the real world,
        // we should never have uiNumLinks > QUICK_FACE_NAME_LINKS

#if DBG
            WARNING("We are in trouble to release the cache\n");
            DbgBreakPoint();
#endif

            return;
        }
    }
    else
    {
        RtlZeroMemory((VOID *)aprfnt, sizeof(aprfnt));
        pprfnt = aprfnt;
        bAllocated = FALSE;
    }

// First deactivate the RFONT itself. vMakeInactiveHelper returns a list of
// linked/EUDC RFONTS which we will then deactivate.  If bLockEUDC is TRUE
// on return from this function it means we've blocked EUDC API's from functioning
// because we are deactivating an EUDC RFONT.  On return from this function
// we should unblock EUDC API's.

    bLockEUDC = bMakeInactiveHelper(pprfnt);

    while( *pprfnt != NULL )
    {

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "vMakeInactive() deactivating linked font %x\n");

        RFONTTMPOBJ rfo( *pprfnt );

        rfo.bMakeInactiveHelper((PRFONT *)NULL);

    // next one..

        pprfnt++;
    }

// free temorary buffer, if it was allocated.

    if( bAllocated ) VFREEMEM( pprfnt );

// possibly unblock EUDC API's

    if( bLockEUDC )
    {
        ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0");
        DECREMENTEUDCCOUNT;
    }
}

#endif


/**************************Public*Routine************************\
* vRemoveAllInactiveRFONTs()
*
* Take all of the rfont off the inactive list.
* This is only called by bAllocateCache() after it fails to
* allocate the memory the fisrt time.
*
* History:
*
*  Mar-06-98 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

VOID vRemoveAllInactiveRFONTs(PPDEV ppdev)
{
    PRFONT  aprfnt[cMaxInactiveRFONT], prf, prfHead, prfVictim;
    ULONG   i = 0, cNumVictim;

    {
        SEMOBJ so(ghsemRFONTList);

        PDEVOBJ pdo((HDEV)ppdev);

        // remove every RFONT from the inactive list

        for (prf = pdo.prfntInactive(); prf != NULL; )
        {
            aprfnt[i++] = prfVictim = prf;
            prf = prf->rflPDEV.prfntNext;

            RFONTTMPOBJ rfo(prfVictim);
            prfHead = pdo.prfntInactive();
            rfo.vRemove(&prfHead, PDEV_LIST);
            pdo.prfntInactive(prfHead);
        }
        pdo.cInactive(0);
    }

    cNumVictim = i;
    ASSERTGDI(cNumVictim <= cMaxInactiveRFONT, "bRemoveAllInactiveRFONT: cNumVictim > cMaxInactiveRFONT");

    for (i = 0; i < cNumVictim; i++)
    {
        RFONTTMPOBJ rfo(aprfnt[i]);

        PFFOBJ pffo(aprfnt[i]->pPFF);
        ASSERTGDI(pffo.bValid(), "bReamoveAllInactiveRFONT: Invalid pff");

        // pass in ppdo as NULL because it has been
        // removed from the PDEV list

        rfo.bDeleteRFONT((PDEVOBJ *) NULL, &pffo);
    }
}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bRealizeFont
*
* Realizes the IFI or device font represented by the PFE handle for the
* DC associated with the passed DC user object.  Initializes the other
* fields of the RFONT.
*
* Warning:
*   Whoever calls this should be holding the semaphore of the PFT in which
*   the PFE lives.
*
* Returns:
*   TRUE if realization successful, FALSE if error occurs.
*
* History:
*  Wed 09-Mar-1994 13:52:26 by Kirk Olynyk [kirko]
* Made the FONTOBJ::flFontType consistent with the contents of the font
* in the case where the type of the original font is overridden.
*  Sat 09-Jan-1993 22:11:23 by Kirk Olynyk [kirko]
* Added pptlSim to the input parameter list. This is for bitmap scaling
* simulations.
*  12-Dec-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bRealizeFont(
    XDCOBJ     *pdco,            // realize font for this DC (optional)
    PPDEVOBJ    ppdo,            // realize font for this PDEV
    ENUMLOGFONTEXDVW *pelfw,     // font wish list (in logical coords)
    PFE        *ppfe,            // realize this font face
    PFD_XFORM   pfdx,            // font xform (Notional to Device)
    POINTL* const pptlSim,       // for bitmap scaling
    FLONG       _fl,             // xform flags
    ULONG       ulStyleHtPt,     // style ht
    BOOL        bNeedPaths,      // Font realization must cache paths
    BOOL        bSmallMetricsOk,
    FLONG       flType
)
{
    BOOL bRet = FALSE;
    PFEOBJ pfeo(ppfe);
    PFD_GLYPHSET pfdgTmp;

    ASSERTGDI(pfeo.bValid(),
        "gdisrv!bRealizeFontRFONTOBJ(): PFEOBJ constructor failed\n");

// If we can not allocate pfdg, then we would failed to do RFNT initialized.

    pfdgTmp = pfeo.pfdg();

    if (!pfdgTmp)
    {
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

    ASSERTGDI(prfnt == NULL,
        "gdisrv!bRealizeFontRFONTOBJ(): prfnt != NULL\n");

// Create a default sized RFONT.

    prfnt = (RFONT *) PALLOCMEM(sizeof(RFONT), 'tnfG');

    if (prfnt == PRFNTNULL)
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): failed alloc\n");
        pfeo.vFreepfdg();
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }


    PFFOBJ pffo(pfeo.pPFF());
    ASSERTGDI(pffo.bValid(),
        "gdisrv!bRealizeFontRFONTOBJ(): PFFOBJ constructor failed\n");

    ASSERTGDI(pfdx != NULL,
        "gdisrv!bRealizeFontRFONTOBJ(): pfdx == NULL\n");

// Set up the RFONT's copy of the FONTOBJ.
//
// This needs to be done before the IFI/device driver dependent stuff
// because it is needed by FdOpenFontContext.

    // Note: iUniq should be set here, but we won't set it until we grab
    //       the ghsemRFONTList because the iUniqueStap needs semaphore
    //       protection for increment and access.  (InterlockedIncrement
    //       doesn't cut it).

    pfo()->sizLogResPpi.cx = ppdo->ulLogPixelsX();
    pfo()->sizLogResPpi.cy = ppdo->ulLogPixelsY();
    pfo()->ulStyleSize = ulStyleHtPt;
    pfo()->flFontType = _fl | pfeo.flFontType();  // combine the simulation and type flage
    pfo()->pvConsumer = (PVOID) NULL;
    pfo()->pvProducer = (PVOID) NULL;
    pfo()->iFace = pfeo.iFont();
    pfo()->iFile = pffo.hff();

    // nonzero only for tt fonts

    //
    // Old comment from gilmanw:
    //  - what about device TT fonts?!? Should iTTUniq be zero?
    //

    // iTTUniq should be different between Normal face font and @face Verical font.
    // And also, this value should be uniq for TrueType collection format fonts.
    //
    pfo()->iTTUniq = (pfo()->flFontType & TRUETYPE_FONTTYPE) ? (ULONG_PTR) ppfe : 0;

    // Assert consistency of TrueType.  The driver is the TrueType font driver
    // if and only if the font is TrueType.

    #ifdef FINISHED_FONT_DRIVER_WORK
    ASSERTGDI(((pfo()->flFontType & TRUETYPE_FONTTYPE) != 0) ==
              (pffo.hdev() == (HDEV) gppdevTrueType),
              "gdisrv!bRealizeFontRFONTOBJ():  inconsistentflFontType\n");
    #endif

// Copy the font transform passed in.

    prfnt->fdx = *pfdx;
    prfnt->fdxQuantized = *pfdx;
    prfnt->ptlSim = *pptlSim;

// Initialize the DDI callback EXFORMOBJ.

    prfnt->xoForDDI.vInit(&prfnt->mxForDDI);
    vSetNotionalToDevice(prfnt->xoForDDI);

// Save identifiers to the source of the font (physical font).

    prfnt->ppfe = ppfe;
    prfnt->pPFF = pfeo.pPFF();

#ifdef FE_SB
// Set Null to indicate this RFONT not yet linked to EUDC

    prfnt->prfntSystemTT    = (PRFONT )NULL;
    prfnt->prfntSysEUDC     = (PRFONT  )NULL;
    prfnt->prfntDefEUDC     = (PRFONT  )NULL;
    prfnt->paprfntFaceName  = (PRFONT *)NULL;
    prfnt->bFilledEudcArray = FALSE;

// Initialize EUDC status.

    prfnt->flEUDCState = 0;
    prfnt->uiNumLinks  = 0;
    prfnt->ulTimeStamp = 0;
    prfnt->bVertical   = pfeo.bVerticalFace();
#endif


// Save identifiers to the consumer of this font realization.

    if (ppdo != NULL)
    {
    // The dhpdev is really for font producers, which won't support dynamic
    // mode changing:

        prfnt->hdevConsumer  = ppdo->hdev();
        prfnt->dhpdev        = ppdo->dhpdevNotDynamic();
    }
    else
    {
        prfnt->hdevConsumer  = NULL;
        prfnt->dhpdev        = 0;
    }

// Bits per pel?

    // 
    // Old comment:
    //   - setting cBitsPerPel = 1 is wrong - kriko

    prfnt->cBitsPerPel = 1;

// Outline (transformable)?

    IFIOBJ ifio(pfeo.pifi());
    prfnt->flInfo = pfeo.pifi()->flInfo;

    pfdg(pfdgTmp);

// Cache the default character.  The bInitCache method below needs it.

    prfnt->hgDefault = hgXlat(ifio.wcDefaultChar());

// Should this become an error exit, or can this be taken out?

    ASSERTGDI (
        pfdg()->cGlyphsSupported != 0,
        "gdisrv!bRealizeFontRFONTOBJ(): no glyphs in this font\n"
        );

// Get the device metrics info

    FD_DEVICEMETRICS devm = {0};          // buffer to which the driver returns info

// Initialize font driver (the font producer) information.

    prfnt->hdevProducer = pffo.hdev();

// Up to this point nothing has been done that could cause the font driver
// (the font provider) to realize the font.  However, this may now happen
// when querying for information dependent on the realization.  So we are
// going to HAVE TO KILL font driver realization on every  error return
// from this function

     // FONTASSASIN faKillDriverRealization(&ldo, pfo());

// get and convert device metrics.

    if ( !bGetDEVICEMETRICS(&devm) )
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): error with DEVICEMETRICS\n");

        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// Pre-compute some useful values for text placement and extents.
// (But only if it's not some journalling guys calling.)

    if (pdco != (XDCOBJ *) NULL)
    {
    // pelfw is null only when pdco is null

        ASSERTGDI(pelfw,"gdisrv! pelfw == NULL\n");

    // Get the unit baseline and ascent vectors from the DEVICEMETRICS.

        prfnt->pteUnitBase.x   = devm.pteBase.x; // Converts from FLOAT.
        prfnt->pteUnitBase.y   = devm.pteBase.y; // Converts from FLOAT.
        prfnt->pteUnitAscent.x = devm.pteSide.x; // Converts from FLOAT.
        prfnt->pteUnitAscent.y = devm.pteSide.y; // Converts from FLOAT.

    // Save a copy of the DC's World to Device matrix.  We'll need this later
    // to identify compatible XFORM's (i.e., DC marked as having a changed
    // transform when, in fact, the transform has not changed in a way that
    // would effect the font realization.  Example: translation only changes.

        prfnt->mxWorldToDevice = pdco->pdc->mxWorldToDevice();

    // Compute the scaling factors for fast transforms from world to
    // device space and back.

    // Compute some matrix stuff related to the font realization's transform.
    // Compute Notional to World scaling factors in the baseline and ascender
    // directions.

    // These two routines should be made into a single routine [bodind]
        if
        (
            !bCalcLayoutUnits(pdco)     // Uses pteUnitBase, pteUnitAscent.
            ||
            !bGetNtoWScales(
                &prfnt->eptflNtoWScale,
                *pdco,
                &prfnt->fdxQuantized,  // the one really used by the rasterizer
                pfeo,
                &prfnt->bNtoWIdent
                )
        )
        {
            WARNING("gdisrv!bRealizeFont(): error computing scaling factors\n");
            vDestroyFont(); // kill the driver realization
            VFREEMEM(prfnt);
            prfnt = PRFNTNULL;
            return bRet;        // return FALSE
        }

    // Precompute the offsets for max ascent and descent.

        prfnt->ptfxMaxAscent.x  = lCvt(prfnt->pteUnitAscent.x,prfnt->fxMaxAscent);
        prfnt->ptfxMaxAscent.y  = lCvt(prfnt->pteUnitAscent.y,prfnt->fxMaxAscent);
        prfnt->ptfxMaxDescent.x = lCvt(prfnt->pteUnitAscent.x,prfnt->fxMaxDescent);
        prfnt->ptfxMaxDescent.y = lCvt(prfnt->pteUnitAscent.y,prfnt->fxMaxDescent);

    // Mark escapement info as invalid.

        prfnt->lEscapement = -1;

        if (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE)
        {
            if (ifio.bStroke())
            {
            // esc and orientation treated as WORLD space concepts

                prfnt->ulOrientation =
                    (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);
            }
            else
            {
            // force orientation to be equal to escapement, which means
            // that h3 or g2 text out code will be executed
            // in this case ulOrientation and lEsc are device space concepts
            // but it does not really matter, so long as we wind up in h2 or
            // g3 layout routines which are not even going to look at this number.

                if (ifio.bArbXforms())
                {
                // you will always get the orientation you ask for

                    prfnt->ulOrientation =
                        (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement);
                }
                else // get one of the discrete choices of the font driver
                {
                    prfnt->ulOrientation
                        = ulSimpleDeviceOrientation(*this);

                    ASSERTGDI(
                        prfnt->ulOrientation != 3601,
                        "GDISRVL! ulSimpleDeviceOrientation err\n"
                        );
                }
            }

        }
        else // advanced mode
        {
        // Try to calculate an orientation angle in world coordinates.  Note that
        // we want an exact answer, because it's important to know if the
        // escapement and orientation are exactly equal.  In the Win 3.1
        // compatible case, we will force them equal (in ESTROBJ::vInit), but
        // we still need to know if the orientation is 0 for fast horizontal
        // layout.  (So we don't really care what the orientation is if it's
        // non-obvious in this case.)

            prfnt->ulOrientation = ulSimpleOrientation(pdco); // Uses pteUnitBase.

        // If we are in advanced mode and the font is scalable, we will assume
        // that the desired orientation is obtained.

            if
            (
                (prfnt->ulOrientation >= 3600)
                && bArbXforms()
            )
            {
            // For text layout, orientation angles are measured from the x-axis
            // towards the positive y-axis.  The app measures them towards the
            // negative y-axis.  We adjust for this.

                prfnt->ulOrientation =
                    (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);
            }

        }

    } // end of if (pdco != NULL) clause

// Make sure essential information is in place for further realization.

    ASSERTGDI(prfnt->hgDefault != HGLYPH_INVALID,"Default glyph invalid!\n");

    prfnt->bNeededPaths = bNeedPaths;

    // Is this font driver, or just a device driver?

    ULONG ulFontCaps = 0;

    PDEVOBJ pdo(prfnt->hdevProducer);

    if (PPFNVALID(pdo, QueryFontCaps))
    {
        ULONG ulBuf[2];

        if ( pdo.QueryFontCaps(2, ulBuf) != FD_ERROR )
        {
            ulFontCaps = ulBuf[1];
        }
    }

    if ( !pdo.bFontDriver() )
    {
    // If not a font driver, then the driver does not provide either bitmaps
    // or outlines.  Therefore, it must be that we are using a device-specific
    // font (i.e., metrics only).

        prfnt->bDeviceFont = TRUE;

    // Handle cache typing.

        prfnt->ulContent = FO_HGLYPHS;

        prfnt->cache.cjGlyphMax = 0;

    }
    else
    {
    // If its a font driver, then this font is not device specific.  We
    // can get more than just glyph metrics from this realization.

    // we will make sure that glyphs that are up to ~2 inches tall
    // are stored as glyphbits, above that as paths. That should speed up
    // printing on high resolution printers.

        ULONG ulPathThreshold;

        if ( prfnt->fobj.flFontType & (FO_CLEARTYPE_X | FO_GRAY16)) 
            ulPathThreshold = gulOutlineThreshold / 2;
        else
            ulPathThreshold = gulOutlineThreshold;


        prfnt->bDeviceFont = FALSE;

    // Figure out the type of font data we want to cache
    // First, figure out what the driver would like

        prfnt->ulContent = FO_GLYPHBITS;        // assume bitmaps

        if ( bNeedPaths )
        {
            prfnt->ulContent = FO_PATHOBJ;
        }
        else if (prfnt->hdevConsumer != NULL)
        {
        // get device driver user object

            PDEVOBJ pdoConsumer(prfnt->hdevConsumer);

            if (PPFNVALID(pdoConsumer, GetGlyphMode))
            {
                prfnt->ulContent =
                    (*PPFNDRV(pdoConsumer, GetGlyphMode)) (prfnt->dhpdev, pfo());
            }

        // multiply resolution by 3 inches to get pixel height limit

            if (pdoConsumer.flGraphicsCapsNotDynamic() & GCAPS_FONT_RASTERIZER)
            {
                ULONG ulTmp = pdoConsumer.ulLogPixelsY() * 3;

                if (ulTmp > gulOutlineThreshold)
                    ulPathThreshold = ulTmp;

            // also, if in the future we get 2400 dpi or 4800 dpi devices
            // we do not want this number to get too big, this
            // would cost us too much in terms of font cache memory
            // and rasterization times.

                if (ulPathThreshold > 2400)
                    ulPathThreshold = 2400;
            }
        }

        ASSERTGDI(prfnt->ulContent <= FO_PATHOBJ,
                  "RFONTOBJ::bRealize - bad ulContent\n");

        // A driver preference requires agreement between the font driver and
        // device driver.

        switch(prfnt->ulContent)
        {
        case FO_GLYPHBITS:
            {
            // If the driver is incapable of supplying bitmaps OR if the height
            // is very large (greater global outline threshold) and the font is
            // capable of doing outlines, then force path mode.

            // we use different threshold for cxMax
            // which is usually about 2 * cyMax

                if
                (
                  (!(ulFontCaps & QC_1BIT)) ||
                  (bReturnsOutlines() &&
                  ((prfnt->cxMax > (2*ulPathThreshold)) ||
                   (prfnt->cyMax > ulPathThreshold)))
                )
                    prfnt->ulContent = FO_PATHOBJ;
            }
            break;

        case FO_PATHOBJ:
            if ( !(ulFontCaps & QC_OUTLINES))
                prfnt->ulContent = FO_GLYPHBITS;
            break;

        default:
            break;
        }
    }
    // If you force the path mode then turn off antialiasing
    if (prfnt->ulContent == FO_PATHOBJ)
    {
        #if DBG
        if (gflFontDebug & DEBUG_AA)
            KdPrint(("Forcing path mode ==> turning off antialiasing\n"));
        #endif
        prfnt->fobj.flFontType &= ~FO_GRAY16;
    }
    if ( bNeedPaths && (prfnt->ulContent != FO_PATHOBJ))
    {
        WARNING1("Can't get paths for font!\n");
        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// we only use small metrics if the bit

    prfnt->cache.bSmallMetrics =
        ( bSmallMetricsOk && ( prfnt->ulOrientation == 0 ) ) ? TRUE : FALSE;

    if (!bInitCache(flType))
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): cache initialization failed\n");

        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// set TEXTMETRICS cache to NULL

    prfnt->ptmw = NULL;

// Made it this far, so everything is OK

    bRet = TRUE;

    //
    // Old comments:
    //  - really ought to check list to make sure that no one else
    //    realized the font while we were working
    //

    PRFONT prfntHead;

    {
        SEMOBJ so(ghsemRFONTList);

    // Assign the uniqueness ID under semaphore.

        // WARNING:
        // This exact same code is in iGetNextUniqueness() in JNLFONT.CXX.
        // Why not just call it?  Because iGetNextUniqueness() would grab
        // the semaphore a second time.  I'd rather live with duplicate
        // code!

        iUniqueStamp += 1;
        if (iUniqueStamp == 0)  // an iUniq of 0 means "don't cache" in driver
            iUniqueStamp = 1;

        pfo()->iUniq = iUniqueStamp;

    // If a PDEVOBJ * was passed in, we need to update its list.

        if (ppdo != NULL)
        {
            prfnt->cSelected = 1;

        // Add to PDEV list.

            prfntHead = ppdo->prfntActive();
            vInsert(&prfntHead, PDEV_LIST);
            ppdo->prfntActive(prfntHead);
        }

    // Add to PFF list.

        prfntHead = pffo.prfntList();
        vInsert(&prfntHead, PFF_LIST);
        pffo.prfntList(prfntHead);
    }

    if (prfnt->ulContent == FO_GLYPHBITS)
        prfnt->fobj.flFontType |= FO_TYPE_RASTER;
    else
        prfnt->fobj.flFontType &= ~FO_TYPE_RASTER;

// remember the graphics mode used in computing this realization's
// notional to world xform:

    if (pdco != (XDCOBJ *) NULL)
        iGraphicsMode(pdco->pdc->iGraphicsMode());
    else
        iGraphicsMode(0);

#ifdef FE_SB
    prfnt->bIsSystemFont = gbSystemDBCSFontEnabled && pfeo.bSBCSSystemFont();
#endif

    return bRet;
}



/******************************Public*Routine******************************\
* bCalcLayoutUnits (pdco)                                                  *
*                                                                          *
* Initializes the following fields in the RFONT.  The unit baseline and    *
* unit ascent vectors pteUnitBase and pteUnitAscent must already be        *
* initialized.  The vectors are given to us by the font realization code,  *
* so we can really make no assumptions about them other than that they are *
* unit vectors in device space and orthogonal in world space.              *
*                                                                          *
*   efWtoDBase                                                             *
*   efDtoWBase                                                             *
*   efWtoDAscent                                                           *
*   efDtoWAscent                                                           *
*                                                                          *
*  Fri 05-Feb-1993 16:03:14 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bCalcLayoutUnits(XDCOBJ *pdco)
{
    EFLOAT efOne;
    efOne.vSetToOne();

// Get the world to device transform from the DC.

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

// Pick up the diagonal components.

    EFLOAT efM11 = xo.efM11();
    EFLOAT efM22 = xo.efM22();
    efM11.vAbs(); efM22.vAbs();

// Handle the simple (but common) case.

    if (xo.bScale() && (efM11 == efM22))
    {
        EFLOAT efM11Inv;
        efM11Inv.eqDiv(efOne,efM11);

        prfnt->efWtoDBase   = efM11;
        prfnt->efWtoDAscent = efM11;
        prfnt->efDtoWBase   = efM11Inv;
        prfnt->efDtoWAscent = efM11Inv;

    // in isotropic case even win 31 dudes get it right;

        prfnt->efDtoWBase_31   = prfnt->efDtoWBase  ;
        prfnt->efDtoWAscent_31 = prfnt->efDtoWAscent;
    }

// Handle the slow general case.

    else
    {
        POINTFL ptfl;

    // Get the inverse transform from the DC.

        EXFORMOBJ xoDtoW(*pdco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
            return(FALSE);

    // Back transform the baseline, measure its length.


        xoDtoW.bXform((VECTORFL *) &prfnt->pteUnitBase,(VECTORFL *) &ptfl,1);
        prfnt->efDtoWBase.eqLength(ptfl);
        prfnt->efDtoWBase.vDivBy16();   // Adjust for subpel transform.
        prfnt->efWtoDBase.eqDiv(efOne,prfnt->efDtoWBase);

    // Back transform the ascent, measure its length.

        xoDtoW.bXform((VECTORFL *) &prfnt->pteUnitAscent,(VECTORFL *) &ptfl,1);
        prfnt->efDtoWAscent.eqLength(ptfl);
        prfnt->efDtoWAscent.vDivBy16(); // Adjust for subpel transform.
        prfnt->efWtoDAscent.eqDiv(efOne,prfnt->efDtoWAscent);

        if
        (
            (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE) &&
            !pdco->pdc->bUseMetaPtoD()                   &&
            !(prfnt->flInfo & FM_INFO_TECH_STROKE)
        )
        {
        // win 31 way of doing it: they scale extent measured
        // along baseline by the (DtoW) xx component even if baseline is
        // along some other direction. Likewise they scale ascender extent by
        // DtoW yy component even if ascender is not collinear with y axis.
        // so fix up backward scaling factors, but leave forward scaling factors
        // correct for the text layout code [bodind]
        // Note that win31 is here at least consistent with respect tt and
        // vector fonts: it returns text extent values that are screwed
        // in the same bogus way for tt and for vector fonts

            prfnt->efDtoWBase_31   = xoDtoW.efM11();
            prfnt->efDtoWAscent_31 = xoDtoW.efM22();

            prfnt->efDtoWBase_31.vAbs();
            prfnt->efDtoWAscent_31.vAbs();
        }
        else
        {
            prfnt->efDtoWBase_31   = prfnt->efDtoWBase  ;
            prfnt->efDtoWAscent_31 = prfnt->efDtoWAscent;
        }

    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* ulSimpleOrientation (pdco)                                               *
*                                                                          *
* Attempts to calculate a simple orientation angle in world coordinates.   *
* This only ever returns multiples of 90 degrees when it succeeds.  If the *
* calculation would be hard, it just returns 3601.                         *
*                                                                          *
* Note that the text layout code, for which the escapement and orientation *
* are recorded in the RFONT, always considers its angles to be measured    *
* from the x-axis towards the positive y-axis.  (So that a unit vector     *
* will have a y component equal to the cosine of the angle.)  This is NOT  *
* what an application specifies in world coordinates!                      *
*                                                                          *
*  Fri 05-Feb-1993 18:57:33 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks more formidable than it is.  It actually doesn't     *
* execute much code.                                                       *
\**************************************************************************/

ULONG RFONTOBJ::ulSimpleOrientation(XDCOBJ *pdco)
{
// Calculate the orientation in device space.

    INT sx = (INT) prfnt->pteUnitBase.x.lSignum();
    INT sy = (INT) prfnt->pteUnitBase.y.lSignum();

// Exactly one of these must be zero (for the orientation to be simple).

    if ((sx^sy)&1)
    {
    // Calculate the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 :  900
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF : 2700

        ULONG ulOrientDev = (sx & 1800) | ((-sy) & 900) | (sy & 2700);

    // Handle the trivial case.

        if (pdco->pdc->bWorldToDeviceIdentity())
            return(ulOrientDev);

    // Locate our transform and examine the matrix.

        EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

        INT s11 = (INT) xo.efM11().lSignum();
        INT s12 = (INT) xo.efM12().lSignum();
        INT s21 = (INT) xo.efM21().lSignum();
        INT s22 = (INT) xo.efM22().lSignum();

    // Handle non-inverting transforms.

    // Examine the transform to see if it's a simple multiple of 90
    // degrees rotation and perhaps some scaling.

    // If any of the terms we OR together are non-zero, it's a bad transform.

        if (
             (
               (s11 - s22)         // Signs on diagonal must match.
               | (s12 + s21)       // Signs off diagonal must be opposite.
               | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
             ) == 0
           )
        {
        // Since we've normalized to a space where (0 1) represents
        // a vector with a 90 degree orientation note that the matrix
        // that rotates us by positive 90 degrees, going from world to
        // device, is:
        //
        //           [ 0  1 ]
        //     (1 0) [      ] = (0 1)
        //           [-1  0 ]
        //
        // I.e. the one with M  < 0.  From device to world, that's -90 degrees.
        //                    21

            ULONG ulOrientWorld = ulOrientDev
                                  + (s12 &  900)
                                  + (s11 & 1800)
                                  + (s21 & 2700);

        // Note that only the single 0xFFFFFFFF term contributes above.

            if (ulOrientWorld >= 3600)
                ulOrientWorld -= 3600;

            return(ulOrientWorld);
        }

    // Now we do the parity inverting transforms.

        else if (
                  (
                    (s11 + s22)         // Signs on diagonal must be opposite.
                    | (s12 - s21)       // Signs off diagonal must match.
                    | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
                  ) == 0
                )
        {
        // These are just the simple reflections which take multiples of
        // 90 degrees to multiples of 90 degrees.  They are idempotent so
        // device-to-world or world-to-device is irrelevant.
        //
        //  [ 1  0 ]                [-1  0 ]
        //  [      ] => 3600-x      [      ] => 5400-x
        //  [ 0 -1 ]                [ 0  1 ]
        //
        //  [ 0 -1 ]                [ 0  1 ]
        //  [      ] => 6300-x      [      ] => 4500-x
        //  [-1  0 ]                [ 1  0 ]

            ULONG ulOrientWorld = (s22 & 3600) + (s12 & 6300)
                                + (s11 & 5400) + ((-s12) & 4500)
                                - ulOrientDev;

        // Note that only the single 0xFFFFFFFF term contributes.

            if (ulOrientWorld >= 3600)
                ulOrientWorld -= 3600;

            return(ulOrientWorld);
        }
    }

// If it's not simple, return an answer out of range.

    return(3601);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bDeleteFONT
*
* Delete an RFONT.  The ppdo and ppffo point to objects that have RFONT
* lists that require updating because of the deletion.  If NULL, that
* means the corresponding object does not need deletion (most likely
* because the list management has already been performed for that object).
*
* Warning:
*   Only PFFOBJ::bDelete should pass in a NULL for ppffo.  The PFF
*   list needs to be treated specially because PFFs are the only object
*   which might get deleted in response to a RFONT deletion.
*
* History:
*  30-Oct-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bDeleteRFONT (
    PDEVOBJ *ppdo,
    PFFOBJ *ppffo
    )
{
    PRFONT prfntHead;
    PFEOBJ pfeo(ppfe());

// free pfdg
    pfeo.vFreepfdg();

// Tell font producer that font is going away.

    PDEVOBJ pdoPro(prfnt->hdevProducer);

    if ( PPFNVALID(pdoPro, DestroyFont) )
    {
        pdoPro.DestroyFont(pfo());
    }

// Tell font consumer that font is going away.
// Note: the PLDEV for the consumer may be NULL (jounalling).

    if (prfnt->hdevConsumer != NULL )
    {
        PDEVOBJ pdoCon(prfnt->hdevConsumer);

    // If this is a display device and we are not in the middle of tearing
    // the pdev down we need to lock the display in order to synchronize
    // this call with other calls to the driver.

        BOOL bLock = ( pdoCon.bDisplayPDEV() && pdoCon.cPdevRefs() != 0 );

        if( bLock )
        {
            GreAcquireSemaphoreEx(pdoCon.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(pdoCon.ppdev, WD_DEVLOCK);
        }

        if ( PPFNVALID(pdoCon, DestroyFont) )
        {
            pdoCon.DestroyFont(pfo());
        }

        if( bLock )
        {
            GreExitMonitoredSection(pdoCon.ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(pdoCon.hsemDevLock());
        }
    }

// Update the RFONT lists.  Do this under the ghsemRFONTList semaphore (which
// may or may not already be held).

    {
    // Stablize the RFONT lists.

        SEMOBJ so(ghsemRFONTList);

    // If a ppdo is passed in, then we need to remove this RFONT from the
    // PDEV list.

        if ( ppdo != (PDEVOBJ *) NULL )
        {
            ASSERTGDI(!bActive(), "gdisrv!bDeleteRFONTOBJ(): RFONT still active\n");

        // Remove from PDEV list.

            prfntHead = ppdo->prfntInactive();
            vRemove(&prfntHead, PDEV_LIST);
            ppdo->prfntInactive(prfntHead);

        // Update the inactive RFONT ref. count.

            ppdo->cInactive(ppdo->cInactive()-1);
        }

    // If a ppffo is passed in, then remove from PFF list.  If ppffo is NULL, then
    // bDelete must have been called from PFFOBJ::bDelete(), so we are
    // in the process of deleting RFONTs already and do not need to maintain the
    // list.

    // Note: it is possible to write PFFOBJ::bDelete() so that a bDelete
    //       will recursively destroy the entire RFONT list, but I want to
    //       avoid the recursion.

        if ( ppffo != (PFFOBJ *) NULL )
        {
        // Remove from PFF list.

            prfntHead = ppffo->prfntList();
            vRemove(&prfntHead, PFF_LIST);
            ppffo->prfntList(prfntHead);

        }
    }

// Need to tell PFF that this RFONT is going away.  Can't do this under the
// semaphore because bDeleteRFONTRef may cause the driver to be called.

    if ( ppffo != (PFFOBJ *) NULL )
    {
    // Inform PFF that RFONT is going away

        if ( !ppffo->bDeleteRFONTRef() )
        {
            WARNING("gdisrv!bDeleteRFONTOBJ(): PFF deletion failed\n");
            return (FALSE);
        }
    }

// Destroy the cache

    vDeleteCache();

// Delete TEXTMETRICS cache

    if( prfnt->ptmw != NULL )
    {
        VFREEMEM( prfnt->ptmw );
    }

    if (prfnt->hsemEUDC)
        GreDeleteSemaphore(prfnt->hsemEUDC);
    
// Delete the cache semaphore
    GreDeleteSemaphore(prfnt->hsemCache);
// Free object memory and invalidate pointer

    VFREEMEM(prfnt);
    prfnt = PRFNTNULL;
    return (TRUE);
}

/******************************Member*Function*****************************\
* BOOL  RFONTOBJ::bGetDEVICEMETRICS
*
* calls the device or font driver to provide the engine with the
* FD_DEVICEMETRICS structure
*
* History:
*  08-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL RFONTOBJ::bGetDEVICEMETRICS(PFD_DEVICEMETRICS pdevm)
{
    ULONG ulRet;

// Supply fields to be overwritten by the font provider.
// The fdxQuantized field is overwritten if the provider wants a different
// transform.  The lExtLeading field is changed from MINLONG if the provider
// wants to scale this value non-linearly.

    pdevm->fdxQuantized  = prfnt->fdx;

    pdevm->lNonLinearExtLeading   = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearIntLeading   = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearMaxCharWidth = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearAvgCharWidth = MINLONG; // if stays MINLONG, means linear

    PDEVOBJ pdo(prfnt->hdevProducer);

    if ( ((ulRet = pdo.QueryFontData(
                    prfnt->dhpdev,
                    pfo(),
                    QFD_MAXEXTENTS,
                    HGLYPH_INVALID,
                    (GLYPHDATA *) NULL,
                    (PVOID) pdevm,
                    (ULONG) sizeof(FD_DEVICEMETRICS))) == FD_ERROR) )
    {
    // The QFD_MAXEXTENTS mode is required of all drivers.
    // However must allow for the possibility of this call to fail.
    // This could happen if the
    // font file is on the net and the net connection dies, and the font
    // driver needs the font file to produce device metrics [bodind]

        return FALSE;
    }

    #if DBG
    {
        EFLOAT efX;
        EFLOAT efY;

        efX = pdevm->pteBase.x;
        efY = pdevm->pteBase.y;
        efX *= efX;
        efY *= efY;
        efY += efX;
        ASSERTGDI(efY < FP_2_0, "pteBase is too large\n");

        efX  = pdevm->pteSide.x;
        efY  = pdevm->pteSide.y;
        efX *= efX;
        efY *= efY;
        efY += efX;
        ASSERTGDI(efY < FP_2_0, "pteSide is too large\n");
    }
    #endif

    prfnt->flRealizedType = SO_FLAG_DEFAULT_PLACEMENT;
    if (pdevm->flRealizedType & FDM_TYPE_MAXEXT_EQUAL_BM_SIDE)
        prfnt->flRealizedType |= SO_MAXEXT_EQUAL_BM_SIDE;
    if (pdevm->flRealizedType & FDM_TYPE_CHAR_INC_EQUAL_BM_BASE)
        prfnt->flRealizedType |= SO_CHAR_INC_EQUAL_BM_BASE;
    if (pdevm->flRealizedType & FDM_TYPE_ZERO_BEARINGS)
        prfnt->flRealizedType |= SO_ZERO_BEARINGS;

    prfnt->cxMax          = pdevm->cxMax;

    prfnt->ptlUnderline1  = pdevm->ptlUnderline1;
    prfnt->ptlStrikeOut   = pdevm->ptlStrikeOut;

    prfnt->ptlULThickness = pdevm->ptlULThickness;
    prfnt->ptlSOThickness = pdevm->ptlSOThickness;

    if (pdevm->fxMaxAscender < 0)
        prfnt->fxMaxExtent = pdevm->fxMaxDescender;
    else if (pdevm->fxMaxDescender < 0)
        prfnt->fxMaxExtent = pdevm->fxMaxAscender;
    else
        prfnt->fxMaxExtent = pdevm->fxMaxAscender + pdevm->fxMaxDescender;

    prfnt->fxMaxAscent  = pdevm->fxMaxAscender;
    prfnt->fxMaxDescent = -pdevm->fxMaxDescender;

    prfnt->lMaxAscent   = FXTOL(8 + prfnt->fxMaxAscent);
    prfnt->lMaxHeight   = FXTOL(8 + prfnt->fxMaxAscent - prfnt->fxMaxDescent);

    prfnt->lCharInc     = pdevm->lD;

// new fields

    prfnt->cyMax      = pdevm->cyMax;
    prfnt->cjGlyphMax = pdevm->cjGlyphMax; // used to get via QFD_MAXGLYPHBITMAP

// need to compute the filtering correction for CLEAR_TYPE:
// x filtering adds a pixel on each side of the glyph

    if (prfnt->fobj.flFontType & FO_CLEARTYPE_X)
    {
        prfnt->cjGlyphMax = CJ_CTGD((prfnt->cxMax + 2), prfnt->cyMax);
    }

// formerly in reExtra

    prfnt->fdxQuantized           = pdevm->fdxQuantized;
    prfnt->lNonLinearExtLeading   = pdevm->lNonLinearExtLeading;
    prfnt->lNonLinearIntLeading   = pdevm->lNonLinearIntLeading;
    prfnt->lNonLinearMaxCharWidth = pdevm->lNonLinearMaxCharWidth;
    prfnt->lNonLinearAvgCharWidth = pdevm->lNonLinearAvgCharWidth;

// Get the lMaxNegA lMaxNegC and lMinWidthD for USER

    prfnt->lMaxNegA   = pdevm->lMinA;
    prfnt->lMaxNegC   = pdevm->lMinC;
    prfnt->lMinWidthD = pdevm->lMinD;

// cxMax is now computed, copy it to FONTOBJ portion of the RFONTOBJ.

    pfo()->cxMax = prfnt->cxMax;

// Everythings OK.

    return TRUE;
}


/******************************Public*Routine******************************\
* VOID RFONTOBJ::vGetInfo (
*     PFONTINFO pfi
*     )
*
* Fills the FONTINFO buffer pointed to by pfi.
*
* Returns:
*   Nothing.
*
* History:
*  03-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vGetInfo(PFONTINFO pfi)
{
    RtlZeroMemory(pfi, sizeof(FONTINFO));

    pfi->cjThis = sizeof(FONTINFO);
    pfi->cGlyphsSupported = prfnt->pfdg->cGlyphsSupported;

    switch(prfnt->cBitsPerPel)
    {
    case 1:
        pfi->cjMaxGlyph1 = prfnt->cache.cjGlyphMax;
        break;

    case 4:
        pfi->cjMaxGlyph4 = prfnt->cache.cjGlyphMax;
        break;

    case 8:
        pfi->cjMaxGlyph8 = prfnt->cache.cjGlyphMax;
        break;

    case 32:
        pfi->cjMaxGlyph32 = prfnt->cache.cjGlyphMax;
        break;
    }

    if (bDeviceFont())
        pfi->flCaps |= FO_DEVICE_FONT;

    if (bReturnsOutlines())
        pfi->flCaps |= FO_OUTLINE_CAPABLE;
}


/******************************Public*Routine******************************\
* VOID RFONTOBJ::vSetNotionalToDevice (
*     EXFORMOBJ   &xfo
*     )
*
* Set the XFORMOBJ passed in to be the Notional to Device transform.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  03-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vSetNotionalToDevice(EXFORMOBJ &xo)  // set this transform
{
// Make sure to remove translations.

    xo.vRemoveTranslation();

// Set the rest of the transform matrix.

    xo.vSetElementsLToFx (
        prfnt->fdxQuantized.eXX,
        prfnt->fdxQuantized.eXY,
        prfnt->fdxQuantized.eYX,
        prfnt->fdxQuantized.eYY
        );

    xo.vComputeAccelFlags(XFORM_FORMAT_LTOFX);
}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bSetNotionalToWorld (
*     EXFORMOBJ   &xoDToW,
*     EXFORMOBJ   &xo
*     )
*
* Set the incoming XFORMOBJ to be the Notional to World transform for this
* font.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  27-Jan-1992 -by- Wendy Wu [wendywu]
* Changed calling interfaces.  Left translations alone as we can transform
* vectors now.
*  10-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bSetNotionalToWorld (
    EXFORMOBJ   &xoDeviceToWorld,   // Device to World transform
    EXFORMOBJ   &xo                 // set this transform
    )
{
// Get empty xform to receive Notional to Device transform.

    MATRIX  mxNotionalToDevice;

// This constructor never fails.

    EXFORMOBJ    xoNotionalToDevice(&mxNotionalToDevice,DONT_COMPUTE_FLAGS);

// Set the transform matrix from Notional to Device space.

    xoNotionalToDevice.vSetElementsLToFx (
        prfnt->fdx.eXX,
        prfnt->fdx.eXY,
        prfnt->fdx.eYX,
        prfnt->fdx.eYY
        );

// Make sure to remove translations.

    xoNotionalToDevice.vRemoveTranslation();

// Calculate a Notional to World transform.
// Don't mind about translations.  We'll use this to transform vectors only.

    return(xo.bMultiply(xoNotionalToDevice, xoDeviceToWorld,
                COMPUTE_FLAGS | XFORM_FORMAT_LTOL));
}

/******************************Public*Routine******************************\
* RFONTOBJ::bCalcEscapementP (xo,lEsc)                                     *
*                                                                          *
* This is the internal routine that calculates the projection of the       *
* escapement onto the base and ascent vectors, as well as other useful     *
* escapement quantities.                                                   *
*                                                                          *
* This is expensive, call only when needed!                                *
*                                                                          *
*  Sat 21-Mar-1992 13:35:49 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bCalcEscapementP(EXFORMOBJ& xo,LONG lEsc)
{
    ASSERTGDI((lEsc >= 0) && (lEsc < 3600),"Unnormalized angle!\n");

// Check for simple alignment with the orientation.

    if
    (
      (prfnt->ulOrientation < 3600) &&
      (
        ((ULONG) lEsc == prfnt->ulOrientation)
        || ((ULONG) lEsc == prfnt->ulOrientation + 1800)
        || ((ULONG) lEsc == prfnt->ulOrientation - 1800)
      )
    )
    {
        prfnt->lEscapement   = lEsc;
        prfnt->pteUnitEsc    = prfnt->pteUnitBase;
        prfnt->efWtoDEsc     = prfnt->efWtoDBase;
        prfnt->efDtoWEsc     = prfnt->efDtoWBase;
        prfnt->efEscToBase.vSetToOne();
        prfnt->efEscToAscent.vSetToZero();

        if ((ULONG) lEsc != prfnt->ulOrientation)
        {
            prfnt->pteUnitEsc.x.vNegate();
            prfnt->pteUnitEsc.y.vNegate();
            prfnt->efEscToBase.vNegate();
        }
        return(TRUE);
    }

// Do the general calculation.

    prfnt->lEscapement = -1;            // Assume failure.
    if (!xo.bComputeUnits
         (
          lEsc,
          &prfnt->pteUnitEsc,
          &prfnt->efWtoDEsc,
          &prfnt->efDtoWEsc
         )
       )
        return(FALSE);

/**************************************************************************\
* Compute the projections along the Base and Ascent axes.                  *
*                                                                          *
* We compute two quantities r  and r  as follows:                          *
*                            a      b                                      *
*                                                                          *
*    E = unit escapement vector                                            *
*    A = unit ascent vector                                                *
*    B = unit baseline vector                                              *
*                                                                          *
*         E x B           A x E                                            *
*    r  = -----      r  = -----                                            *
*     a   A x B       b   A x B                                            *
*                                                                          *
*                                                                          *
* These have the property that:                                            *
*                                                                          *
*    E = r A + r B                                                         *
*         a     b                                                          *
*                                                                          *
* This allows us to decompose the escapement vector.                       *
\**************************************************************************/

    EFLOAT ef;          // Ascent x Esc  or Esc x Base
    EFLOAT efNorm;      // Ascent x Base

    efNorm.eqCross(prfnt->pteUnitAscent,prfnt->pteUnitBase);
    if (efNorm.bIsZero())   // Too singular.
        return(FALSE);

    ef.eqCross(prfnt->pteUnitAscent,prfnt->pteUnitEsc);
    prfnt->efEscToBase.eqDiv(ef,efNorm);

    ef.eqCross(prfnt->pteUnitEsc,prfnt->pteUnitBase);
    prfnt->efEscToAscent.eqDiv(ef,efNorm);
    prfnt->lEscapement = lEsc;
    return(TRUE);
}


/******************************Public*Routine******************************\
* bGetNtoWScales
*
* Calculates the Notional to World scaling factor for vectors that are
* parallel to the baseline direction.
*
* History:
*  14-Apr-1992 14:23:49 Gilman Wong [gilmanw]
* Modified to support ascender scaling factor as well.
*  Sat 21-Mar-1992 08:03:14 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL bGetNtoWScales (
    EPOINTFL *peptflScale, // return address of scaling factors
    XDCOBJ& dco,            // defines device to world transformation
    PFD_XFORM pfdx,        // defines notional to device transformation
    PFEOBJ& pfeo,          // defines baseline direction
    BOOL *pbIdent          // return TRUE if NtoW is identity (with repsect
                           // to EVECTFL transormations, which ignore
                           // translations)
    )
{
    MATRIX    mxNtoD;
    EXFORMOBJ xoNtoD(&mxNtoD, DONT_COMPUTE_FLAGS);

    xoNtoD.vSetElementsLToFx(
        pfdx->eXX,
        pfdx->eXY,
        pfdx->eYX,
        pfdx->eYY
        );
    xoNtoD.vRemoveTranslation();
    xoNtoD.vComputeAccelFlags();  // XFORM_FORMAT_LTOFX is default

    IFIOBJ  ifio(pfeo.pifi());
    POINTL  ptlBase = *ifio.pptlBaseline();;

    EVECTORFL evflScaleBase(ptlBase.x, ptlBase.y);
    EVECTORFL evflScaleAsc;

    if ( ifio.bRightHandAscender() )
    {
        evflScaleAsc.x = -ptlBase.y;    // ascender is 90 deg CCW from baseline
        evflScaleAsc.y =  ptlBase.x;
    }
    else
    {
        evflScaleAsc.x =  ptlBase.y;    // ascender is 90 deg CW from baseline
        evflScaleAsc.y = -ptlBase.x;
    }

// assert ptlBase is normalized, this code would not work otherwise
// If base is normalized, ascender will also be normalized

    ASSERTGDI(
        (ptlBase.x * ptlBase.x + ptlBase.y * ptlBase.y) == 1,
        "gdisrv, unnormalized base vector\n"
        );

    if (!xoNtoD.bXform(evflScaleBase) || !xoNtoD.bXform(evflScaleAsc))
    {
        WARNING("gdisrv!bGetNtoWScale(): bXform(evflScaleBase or Asc) failed\n");
        return(FALSE);
    }

    if (!dco.pdc->bWorldToDeviceIdentity())
    {
    // The notional to world transformation is the product of the notional
    // to device transformation and the device to world transformation

        EXFORMOBJ xoDtoW(dco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
        {
            WARNING("gdisrv!bGetNtoWScale(): xoDtoW is not valid\n");
            return(FALSE);
        }

    #ifdef WASTE_TIME_MULTIPLYING_MATRICES

    // it is bit strange to do this multiply just to get this
    // accelerator [bodind]

        MATRIX    mxNtoW;
        EXFORMOBJ xoNtoW(&mxNtoW, DONT_COMPUTE_FLAGS);

        if (!xoNtoW.bMultiply(xoNtoD,xoDtoW))
        {
            WARNING("gdisrv!bGetNtoWScale(): xoNtoW.bMultiply failed\n");
            return(FALSE);
        }
        xoNtoW.vComputeAccelFlags(XFORM_FORMAT_LTOL);

        *pbIdent = xoNtoW.bTranslationsOnly();

    #endif //  WASTE_TIME_MULTIPLYING_MATRICES

    // forget about the acceleration in this infrequent case [bodind]

        *pbIdent = FALSE;

        if
        (
            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
            !dco.pdc->bUseMetaPtoD()                   &&
            !ifio.bStroke()
        )
        {
        // win 31 way of doing it: they scale extent measured
        // along baseline by the (DtoW) xx component even if baseline in device
        // is along some other direction. Likewise they scale ascender extent by
        // DtoW yy component even if ascender is not collinear with y axis.
        // Note that win31 is here at least consistent with respect tt and
        // vector fonts: it returns text extent values that are screwed
        // in the same bogus way for tt and for vector fonts [bodind]

            evflScaleBase *= xoDtoW.efM11();
            evflScaleAsc  *= xoDtoW.efM22();

        // we have to do this becase in else part of the clause
        // this multiplication occurs within bXform

            evflScaleBase.x.vTimes16();
            evflScaleBase.y.vTimes16();

            evflScaleAsc.x.vTimes16();
            evflScaleAsc.y.vTimes16();
        }
        else // do the right thing
        {
            if (!xoDtoW.bXform(evflScaleBase) || !xoDtoW.bXform(evflScaleAsc))
            {
                WARNING("gdisrv! bXform(evflScaleBase or Asc) failed\n");
                return(FALSE);
            }
        }
    }
    else
    {
    // accelerate when user is asking for font at em ht

        *pbIdent = xoNtoD.bTranslationsOnly();
    }

// The baseline and ascender scaling factors are equal to the length of the
// transformed Notional baseline unit and ascender unit vectors, respectively.

    peptflScale->x.eqLength(*(POINTFL *) &evflScaleBase);
    peptflScale->y.eqLength(*(POINTFL *) &evflScaleAsc);

    return(TRUE);
}



/******************************Public*Routine******************************\
* RFONTOBJ::vInsert
*
* This function is used to help maintain a doubly linked list of RFONTs.
* Its purpose is to insert this RFONT into a list.  New RFONTs are always
* inserted at the head of the list.
*
* WARNING!
*
* Caller should always grab the ghsemRFONTList semaphore before calling any
* of the RFONT list funcitons.
*
* History:
*  23-Jun-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInsert (
    PPRFONT pprfntHead,
    RFL_TYPE rflt
    )
{
    RFONTLINK *prflNew = NULL;
    RFONTLINK *prflOld = NULL;

// assert pprfntHead is different from prfnt, if they are same it will cause infinite loop

    ASSERTGDI(
        *pprfntHead != prfnt,
        "*pprfntHead is same as prfnt at RFONTOBJ::vInsert\n"
        );
        
// Which set of RFONT links should we use?

    switch (rflt)
    {
    case PFF_LIST:
        prflNew = &(prfnt->rflPFF);
        prflOld = (*pprfntHead != (PRFONT) NULL) ? &((*pprfntHead)->rflPFF) : (PRFONTLINK) NULL;
        break;

    case PDEV_LIST:
        prflNew = &(prfnt->rflPDEV);
        prflOld = (*pprfntHead != (PRFONT) NULL) ? &((*pprfntHead)->rflPDEV) : (PRFONTLINK) NULL;
        break;

    default:
        RIP("gdisrv!vInsertRFONTOBJ(): unknown list type\n");
        break;
    }

    if (prflNew != (RFONTLINK *) NULL)
    {
// Connect this RFONT to current head.

        prflNew->prfntPrev = (PRFONT) NULL;    // head of list has NULL prev
        prflNew->prfntNext = *pprfntHead;

// Connect current head to this RFONT.

        if (prflOld != (PRFONTLINK) NULL)
            prflOld->prfntPrev = prfnt;

// Make this RFONT the new head.

        *pprfntHead = prfnt;
    }
}


/******************************Public*Routine******************************\
* RFONTOBJ::vRemove
*
* This function is used to help maintain a doubly linked list of RFONTs.
* Its purpose is to remove this RFONT from the list.
*
* WARNING!
*
* Caller should always grab the ghsemRFONTList semaphore before calling any
* of the RFONT list funcitons.
*
* History:
*  23-Jun-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vRemove (
    PPRFONT pprfntHead,         // a pointer to the head of list
    RFL_TYPE rflt               // identifies which list to delete from list
    )
{
    RFONTLINK *prflVictim = NULL;
    RFONTLINK *prflPrev;
    RFONTLINK *prflNext;

// Which set of RFONT links should we use?

    switch (rflt)
    {
    case PFF_LIST:
        prflVictim = &(prfnt->rflPFF);
        prflPrev = (prflVictim->prfntPrev != (PRFONT) NULL) ? &(prflVictim->prfntPrev->rflPFF) : (PRFONTLINK) NULL;
        prflNext = (prflVictim->prfntNext != (PRFONT) NULL) ? &(prflVictim->prfntNext->rflPFF) : (PRFONTLINK) NULL;
        break;

    case PDEV_LIST:
        prflVictim = &(prfnt->rflPDEV);
        prflPrev = (prflVictim->prfntPrev != (PRFONT) NULL) ? &(prflVictim->prfntPrev->rflPDEV) : (PRFONTLINK) NULL;
        prflNext = (prflVictim->prfntNext != (PRFONT) NULL) ? &(prflVictim->prfntNext->rflPDEV) : (PRFONTLINK) NULL;
        break;

    default:
        RIP("gdisrv!vInsertRFONTOBJ(): unknown list type\n");
        break;
    }

// Case 1: this RFONT is at the head of the list.

    if ( prflVictim != (RFONTLINK *) NULL )
    {
        if ( prflVictim->prfntPrev == (PRFONT) NULL )
        {
        // Make the next RFONT the head of the list.

            (*pprfntHead) = prflVictim->prfntNext;
            if (prflNext != (RFONTLINK *) NULL)
                prflNext->prfntPrev = (PRFONT) NULL;    // head of list has NULL prev
        }

    // Case 2: this RFONT is not at the head of the list.

        else
        {
        // Connect previous RFONT to next RFONT.
        // Note: since we are guaranteed that this is NOT the head of the
        //       list, prflPrev is guaranteed !NULL.

            prflPrev->prfntNext = prflVictim->prfntNext;

        // Connect next RFONT to previous RFONT.

            if (prflNext != (RFONTLINK *) NULL)
                prflNext->prfntPrev = prflVictim->prfntPrev;
        }
    }
}

/******************************Public*Routine******************************\
* RFONTOBJ::lOverhang                                                      *
*                                                                          *
* The definitive routine to calculate the Win 3.1 compatible overhang for  *
* simulated bitmap fonts.                                                  *
*                                                                          *
*  Mon 01-Feb-1993 11:05:10 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG RFONTOBJ::lOverhang()
{
    LONG  ll = 0;
    FLONG fl = prfnt->fobj.flFontType;

    if
    (
        (prfnt->ppfe->pifi->flInfo & (FM_INFO_TECH_BITMAP|FM_INFO_TECH_STROKE)) &&
        !bDeviceFont()
    )
    {
        if (fl & FO_SIM_ITALIC)
            ll = (prfnt->lMaxHeight - 1) / 2;

        if (fl & FO_SIM_BOLD)
        {
            IFIOBJ  ifio(prfnt->ppfe->pifi);

            if (!ifio.bStroke())   // if not vector font
            {
                ll += 1;
            }
            else // vector font
            {
            // overhang has to be computed by scaling (1,0) in notional
            // space to device space and taking the length of this vector.
            // However if length is < 1 we round it up to 1. This is windows
            // 3.1 compatible vector font "hinting" [bodind]

            // Set up transform.

                MATRIX      mx;
                EXFORMOBJ   xo(&mx, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX);
                if (!xo.bValid())
                {
                    WARNING("gdisrv!lOverhang: XFORMOBJ\n");
                    return (FALSE);
                }

                vSetNotionalToDevice(xo);

                POINTL  ptlBase = *ifio.pptlBaseline();
                EVECTORFL evtflBase(ptlBase.x,ptlBase.y);

                if (!xo.bXform(evtflBase))
                {
                    WARNING("gdisrv!lOverhang(): transform failed\n");
                    return 1;
                }
                EFLOAT  ef;
                ef.eqLength(*(POINTFL *) &evtflBase);

                LONG lEmbolden = lCvt(ef,1);
                if (lEmbolden == 0)
                    lEmbolden = 1;
                ll += lEmbolden;
            }
        }
    }
    return(ll);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bSetNewFDX (dco, bNeedPaths)                                        *
*
* This function props up the functionality of the RESETFCOBJ.  It either
* finds a new RFONT or creates one that matches the same ppfe as the current
* RFONT, but with a different Notional to World transform.
*
* Unlike the initialization routines, this function does not modify the DC
* in anyway.  In particular, it does not change the font realization selected
* into the DC.  So this is a peculiar sort of RFONTOBJ in that it can be
* used to get glyphs and metrics and such (and it is "compatible" with the
* DC passed in) but it is not selected into any DC.  It is, however, classified
* as an active RFONT.  It is the caller's responsibility to make the RFONT
* inactive (by calling vMakeInactive()).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
\**************************************************************************/

BOOL RFONTOBJ::bSetNewFDX(XDCOBJ &dco, FD_XFORM &fdx, FLONG flType)
{
// Get PDEV user object (need for bFindRFONT)

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!bSetNewFDXRFONTOBJ(): bad pdev in dc\n");

// go find the font

    EXFORMOBJ xoWtoD(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!bSetNewFDXRFONTOBJ - bad WD xform in DC\n");

// Grab these out of the current RFONT so we can pass them into the find
// and realization routines.

    FLONG  flSim       = pfo()->flFontType & FO_SIM_MASK;
    ULONG  ulStyleSize = pfo()->ulStyleSize;
    POINTL ptlSim      = prfnt->ptlSim;
    PFE   *ppfe        = prfnt->ppfe;

// Release the cache semaphore.

    if (prfnt != PRFNTNULL )
    {
        vReleaseCache();
    }

// We will hold a reference to whatever PFF we are using while trying to
// realize the font.

    PFFREFOBJ pffref;
    pffref.vInitRef(prfnt->pPFF);

// Don't want to make the font inactive, but we must make the RFONTOBJ
// invalid.  So just set it to NULL.

    prfnt = PRFNTNULL;

// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if
    (
        bFindRFONT
        (
            &fdx,
            flSim,
            ulStyleSize,
            pdo,
            &xoWtoD,
            ppfe,
            FALSE,
            dco.pdc->iGraphicsMode(),
            FALSE,
            flType
        )
    )
    {
        vGetCache();
        
        return TRUE;
    }

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid

        return FALSE;
    }

//
// if we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.
//

    if ( !bRealizeFont(&dco,
                       &pdo,
                       lfo.pelfw(),
                       ppfe,
                       &fdx,
                       (POINTL* const) &ptlSim,
                       flSim,
                       ulStyleSize,
                       FALSE,
                       FALSE, flType) )
    {
        WARNING("gdisrv!bSetNewFDXRFONTOBJ(): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid

        return FALSE;
    }
    ASSERTGDI(bValid(), "gdisrv!bSetNewFDXRFONTOBJ(): invalid hrfnt from realization\n");

// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Finally, grab the cache semaphore.

    vGetCache();

    return TRUE;
}


/******************************Public*Routine******************************\
* bGetWidthTable (iMode,pwc,cwc,plWidth)
*
* Gets the advance widths for a bunch of glyphs at the same time.  Tries
* to do it the fast way with DrvQueryAdvanceWidths.  A value of NO_WIDTH
* is returned for widths that take too long to compute.
*
* Returns:
*   TRUE        If all widths are valid.
*   FALSE       If any widths are invalid.
*   GDI_ERROR   If an error occurred.
*
* History:
*  Wed 13-Jan-1993 03:21:59 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define HCOUNT  70

BOOL RFONTOBJ::bGetWidthTable(
    XDCOBJ&     dco,
    ULONG      cSpecial,    // Count of special chars.
    WCHAR     *pwcChars,    // Pointer to UNICODE text codepoints.
    ULONG      cwc,         // Count of chars.
    USHORT    *psWidth      // Width table (returned).
)
{
    ULONG    cBatch,ii,cc;
    WCHAR   *pwc;
    USHORT  *ps;
    BOOL     bRet = TRUE;
    GLYPHPOS gp;

// Locate the font driver.

    PDEVOBJ pdo(prfnt->hdevProducer);

// If it supports the easy function, just call it.

    if ( PPFNDRV( pdo, QueryAdvanceWidths ))
    {
        HGLYPH ahg[HCOUNT];

    // We need space to hold up the translated glyph handles, so we
    // batch the calls.

        cc  = cwc;
        ps  = psWidth;
        pwc = pwcChars;

        while (cc)
        {
            BOOL b;     // Tri-state BOOL.

            cBatch = (cc > HCOUNT) ? HCOUNT : cc;

        // Translate UNICODE to glyph handles.

        // It is important to note that vXlateGlyph array will set the
        // EUDC_WIDTH_REQUESTED flag if a linked character is encountered.
        // It will just return the glyph handle for the default glyph and
        // expects us to patch up this width later.

            vXlatGlyphArray(pwc,(UINT) cBatch,ahg);

        // Get easy widths from the driver.

            b = pdo.QueryAdvanceWidths
                (
                    prfnt->dhpdev,
                    pfo(),
                    QAW_GETEASYWIDTHS,
                    ahg,
                    (LONG *) ps,
                    cBatch
                );

#ifdef FE_SB
            if (b == GDI_ERROR)
            {
                prfnt->flEUDCState &= ~EUDC_WIDTH_REQUESTED;
                return(GDI_ERROR);
            }

            if( prfnt->flEUDCState & EUDC_WIDTH_REQUESTED )
            {
                prfnt->flEUDCState &= ~EUDC_WIDTH_REQUESTED;

            // If some of the widths requested were in a linked font, then patch
            // them up here.

                WCHAR wcDefault = prfnt->ppfe->pifi->wcDefaultChar;

                for( ii=0; ii < cBatch; ii++ )
                {
                    if( ( ahg[ii] == prfnt->hgDefault ) &&
                        ( pwc[ii] != wcDefault ) &&
                        ( bIsLinkedGlyph(pwc[ii]) || bIsSystemTTGlyph(pwc[ii])) )
                    {
                        if (cwc - cc + ii < cSpecial )  /* perf: we want to hit the linked font only for required characters */
                        {
                            if (!bGetGlyphMetrics(1,&gp,&pwc[ii],&dco))
                                return(GDI_ERROR);

                            ps[ii] = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);
                        }
                        else
                        {
                            ps[ii] = NO_WIDTH;
                            bRet = FALSE;
                        }
                    }
                }
            }
#endif
            bRet &= b;

        // Do the next batch.

            ps  += cBatch;
            pwc += cBatch;
            cc  -= cBatch;
        }
    }

// Otherwise just mark all widths invalid.

    else
    {
        for (ii=0; ii<cwc; ii++)
            psWidth[ii] = NO_WIDTH;
        bRet = FALSE;
    }

// Now make sure that all important widths are set, even if it's hard.

    if (!bRet)
    {
        for (ii=0; ii<cSpecial; ii++)
        {
            if (psWidth[ii] == NO_WIDTH)
            {
                if (!bGetGlyphMetrics(1,&gp,&pwcChars[ii],&dco))
                    return(GDI_ERROR);
                psWidth[ii] = (USHORT) ((GLYPHDATA*)gp.pgdf)->fxD;
            }
        }
    }

#ifdef FE_SB
    if (cwc == cSpecial)
      return((bRet == GDI_ERROR) ? (BOOL)GDI_ERROR : TRUE);

    else
#endif

    return(bRet);
}

/******************************Public*Routine******************************\
* bGetWidthData (pwd)                                                      *
*                                                                          *
* Gets font data which is useful on the client side.                       *
*                                                                          *
*  Thu 14-Jan-1993 00:52:43 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/


static const WCHAR RequestedDBCSChars[] = { 0x3000,   // Ideograhic Space
                               0x4e00,   // Kanji (digit one)
                               0xff21,   // FullWidth A
                               0x0000 };

static const WCHAR OptionalDBCSChars[]  = { 0x30a2,   // Katakana A
                               0x3041,   // Hiragana A
                               0x3131,   // Hangul Kiyeok
                               0x3400,   // Hangul Kiyeok A
                               0x4e08,   // Kanji (Take)
                               0x0000 };

BOOL RFONTOBJ::bGetWidthData(WIDTHDATA *pwd, XDCOBJ& dco)
{
    LONG fxHeight  = prfnt->lMaxHeight << 4;
    LONG fxCharInc = prfnt->lCharInc << 4;
    LONG fxBreak   = prfnt->fxBreak;

    LONG fxDBCSInc = 0;
    LONG fxDefaultInc = 0;

    IFIOBJ  ifio(prfnt->ppfe->pifi);

// If this font has a SHIFTJIS charset and FM_DBCS_FIXED_PITCH is set (and it
// will be 99% of the time ) then the width of all DBCS characters will be
// equal to MaxCharInc.  Using the is information we can still compute client
// side extents and char widths for DBCS fonts.

    if( IS_ANY_DBCS_CHARSET(ifio.lfCharSet()) )
    {
        if( ifio.bDBCSFixedPitch() )
        {
            GLYPHPOS gp;
            WCHAR    wc;
            LONG     fxInc;
            ULONG    ulIndex = 0;

        // This logic is for .....
        //  In Japanese market, there is some font that has not all glyph
        // of SHIFT-JIS charset. This means some SHIFTJIS glyphs will be replace
        // default character, even it is a valid SHIFTJIS code.
        //  we cache widths in client side, its logic is that just retrun DBCS width
        // if the codepoint is valid SHIFTJIS codepoint. but above case real glyph is
        // default char, the width is incorrect. then we just define "Requested chars"
        // for DBCS font, if this font does not have all of these glyph, we don't
        // cache in client side.

            while( (wc = RequestedDBCSChars[ulIndex]) != 0x0000 )
            {
                if( !bGetGlyphMetrics(1,&gp,&wc, &dco) )
                {
                    return(FALSE);
                }

            // Does the glyph fall into the category of default glyph ?

                if( gp.hg == prfnt->hgDefault )
                {
                    return(FALSE); // we don't cache in client side...
                }

                ulIndex++;
            }

        // treat last char in the array of width as DBCS width.

            fxDBCSInc = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);

            ulIndex = 0;

        // check Optional DBCS width.

            while( (wc = OptionalDBCSChars[ulIndex]) != 0x0000 )
            {
                if( !bGetGlyphMetrics(1,&gp,&wc) )
                {
                    return(FALSE);
                }

                fxInc = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);

                fxDBCSInc = max(fxInc,fxDBCSInc);

                ulIndex++;
            }
        }
         else
        {
            // WARNING("bGetWidthDataRFONTOBJ: DBCS chars not fixed pitch\n");
            return(FALSE); // we don't cache in client side.
        }

        fxDefaultInc = (USHORT)(pgdDefault()->fxD);
    }

    if( ((fxHeight | fxCharInc | fxBreak | fxDBCSInc) & 0xFFFF0000L) == 0 )
    {
        pwd->sHeight  = (USHORT) fxHeight;
        pwd->sCharInc = (USHORT) fxCharInc;
        pwd->sBreak   = (USHORT) fxBreak;

    // for DBCS client side widhts

        pwd->sDBCSInc = (USHORT) fxDBCSInc;
        pwd->sDefaultInc = (USHORT) fxDefaultInc;


    // Set a Windows 3.1 compatible overhang.

        pwd->sOverhang = (USHORT) (lOverhang() << 4);

    // Get some important ANSI codepoints.

        IFIMETRICS *pifi = prfnt->ppfe->pifi;

        pwd->iFirst   = pifi->chFirstChar;
        pwd->iLast    = pifi->chLastChar;
        pwd->iDefault = pifi->chDefaultChar;
        pwd->iBreak   = pifi->chBreakChar;
        return(TRUE);
    }
    return(FALSE);
}


/************************Public*Routine*****************\
*  RFONTOBJ::vChnageiTTUniq
*
* This is only called by PreTextOut()
\*******************************************************/
void RFONTOBJ::vChangeiTTUniq(FONTFILE_PRINTKVIEW *pPrintKview)
{
    ULONG       i;
    ULONG_PTR   uPFE, uPFEend;
    ULONG_PTR   iTTUniq;

    uPFE = (ULONG_PTR)ppfe();
    uPFEend = uPFE + sizeof(PFE);
    iTTUniq = pPrintKview->iTTUniq;

    if (pfo()->flFontType & TRUETYPE_FONTTYPE)
    {            
        if ((iTTUniq >= uPFE) && (iTTUniq < uPFEend))
        {
            if (iTTUniq < (--uPFEend))
            {
                pPrintKview->iTTUniq++;
            }
            else
            {
                pPrintKview->iTTUniq = uPFE;
            }
            pfo()->iTTUniq = pPrintKview->iTTUniq;
        }
    }
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ:PreTextOut
*
* Routine Description:
*
*   Called before calling to any DrvTextOut to prepare for callbacks
*   to FONTOBJ_pjOpenTypeTable and FONTOBJ_pvTrueTypeFontFile.
*
* Arguments:
*
*   none
*
* Called by:
*
*   bProxyTextOut, GreExtTextOutWLocked
*
* Return Value:
*
*   none
*
\**************************************************************************/

void RFONTOBJ::PreTextOut(XDCOBJ& dco)
{
    FONTFILE_PRINTKVIEW  *pPrintKView;
    
    if (dco.bPrinter() && !dco.bUMPD() && !bDeviceFont())
    {
        SEMOBJ so(ghsemPrintKView);

        pPrintKView = gpPrintKViewList;

        while (pPrintKView)
        {
            if (pPrintKView->hff == pPFF()->hff)
            {
                pPrintKView->cPrint++;

                if (pPrintKView->pKView == NULL)
                {
                    vChangeiTTUniq(pPrintKView);
                }
            }

            pPrintKView = pPrintKView->pNext;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pvFile
*
* Routine Description:
*
*   Generates a kernel mode pointer to the associated font file.
*
* Arguments:
*
*   pcjFile - address of 32-bit variable to receive the size
*             of the TrueType file in bytes.
*
* Called by:
*
*   FONTOBJ_pvTrueTypeFontFile
*
* Return Value:
*
*   A kernel mode pointer to the associated font file.
*
\**************************************************************************/

PVOID RFONTOBJ::pvFile(ULONG *pcjFile)
{
    char *pchFile;
    ULONG cjFile;

    pchFile = 0;
    cjFile = 0;

    PDEVOBJ pdo( prfnt->hdevProducer );
    if ( pdo.bValid() )
    {
        PFF *pPFF;
        if ( pPFF = prfnt->pPFF )
        {
            HFF hff;
            if ( hff = pPFF->hff )
            {
                if ( pchFile = (char*) pdo.GetTrueTypeFile( hff, &cjFile ))
                {
                    pchFile = pchTranslate( pchFile );
                }
            }
        }
    }

    if ( pchFile == 0 )
    {
        cjFile = 0;
    }
    if ( pcjFile )
    {
        *pcjFile = cjFile;
    }

    return( pchFile );
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pjTable
*
* Routine Description:
*
*   Generates a kernel mode view of a particular table in the associated
*   OpenType font file.
*
* Arguments:
*
*   ulTag     a 4-byte tag of the table according to the OpenType
*             conventions
*
*   pcjTable  the address of a 32-bit variable that will receive the size
*             of the table in bytes.
*
* Called by:
*
*   FONTOBJ_pjOpenTypeTable
*
* Return Value:
*
*   a kernel mode pointer to the desired OpenType table
*
\**************************************************************************/

BYTE *RFONTOBJ::pjTable( ULONG ulTag, ULONG *pcjTable )
{
    BYTE *pjTable = 0;
    ULONG cjTable = 0;

    PDEVOBJ pdo( prfnt->hdevProducer );
    if ( pdo.bValid() )
    {
        PFF *pPFF;
        LONG lRet;

        if ( pPFF = prfnt->pPFF )
        {
            HFF hff;
            if ( hff = pPFF->hff )
            {
                lRet = pdo.QueryTrueTypeTable( hff,
                                               1,
                                               ulTag,
                                               0,
                                               0,
                                               0,
                                               &pjTable,
                                               &cjTable
                                               );
                if ( lRet == FD_ERROR )
                {
                    pjTable = 0;
                }
                else
                {
                    pjTable = (BYTE*) pchTranslate( (char*) pjTable );
                }
            }
        }
    }

    if ( pjTable == 0 )
    {
        cjTable = 0;
    }
    if ( pcjTable )
    {
        *pcjTable = cjTable;
    }
    return( pjTable );
}

/*******************************Public*Routine********************************\
* Routine Name:
*
*   bFindPrintKView()
*
* Routine Description:
*
*   This routine goes through the gpPrintKViewList and try to find whether
* there is an existing node matches hff and iFile.
*
* Return:
*  TRUE if it finds a matching node (hff and iFile), and pNode contains
* the address of the matching node.
* Note that the pKView in the node might be NULL, which requires the caller
* to re-map the view.
*
*  FALSE if it doesn't find a match node.
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\*****************************************************************************/
BOOL bFindPrintKView(
    HFF     hff,
    ULONG   iFile,
    FONTFILE_PRINTKVIEW **ppNode
)
{
    ASSERTGDI(hff, "bFindPrintKView, hff == 0\n");
    FONTFILE_PRINTKVIEW *pPrintKView;
  
    *ppNode = NULL;
    
    SEMOBJ so(ghsemPrintKView);
    
    pPrintKView = gpPrintKViewList;

    while (pPrintKView)
    {
        if
        (
            (pPrintKView->hff == hff) && (pPrintKView->iFile == iFile)     // matching node
        )
        {
            *ppNode = pPrintKView;
            return TRUE;
        }

        pPrintKView = pPrintKView->pNext;
    }

    return FALSE;
}

/**********************Public*Routine************************\
* Routine Name:
*
*   bAddPrintKView()
*
* Routine Description:
*
* This routine either adds a new node or update the pKView
* in an existing node to the global gpPrintKViewList
* 
* If pNode is not NULL, it points to the existing node with
* the matching hff and iFile.
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\************************************************************/
BOOL bAddPrintKView(
    HFF hff,
    PVOID pvKView,
    ULONG iFile,
    ULONG_PTR iTTUniq,
    FONTFILE_PRINTKVIEW *pNode
)
{
    FONTFILE_PRINTKVIEW  *pNew = NULL;

    SEMOBJ so(ghsemPrintKView);
    
    // pNode != NULL, existing node with matching hff and iFile
    
    if (pNode) // just updating the pointer, cPrint is ++'ed at PreTextOut time
    {
        pNode->pKView = pvKView;
    }
    else    // new node
    {
        pNew = (FONTFILE_PRINTKVIEW *)PALLOCMEM(sizeof(FONTFILE_PRINTKVIEW), 'pmtG');

        if (pNew)
        {
            pNew->hff = hff;
            pNew->pKView = pvKView;
            pNew->iFile = iFile;
            pNew->cPrint = 1;
            pNew->iTTUniq = iTTUniq;

        // put it at the head of the linked list

            pNew->pNext = gpPrintKViewList;
            gpPrintKViewList = pNew;
        }
        else
            return FALSE;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pchTranslate
*
* Routine Description:
*
*   This routine returns a pointer into a kernel mode view of a font file.
*   If the argument is a kernel mode address then this routine simply
*   returns the same address. If the argument is a user mode address
*   then this routine will map a kernel mode view of the font, if
*   necessary, and translate the user mode pointer into an equivalent
*   kernel mode pointer. If it is necessary to map a kernel mode view
*   this routine records that fact in the global list. This view will be
*   unmapped when the fontcontext goes away or at the "clean up" time.
*
* Arguments:
*
*   pch  a pointer into the font file. This may be either a user mode
*        view or a kernel mode view.
*
* Called by:
*
*   RFONTOBJ::pjTable
*   RFONTOBJ::pvFile
*
* Return Value:
*
*   a kernel mode pointer to the desired offset into the font file
*
\**************************************************************************/

char* RFONTOBJ::pchTranslate(char *pch)
{
    NTSTATUS NtStatus;
    ULONG iKernelBase;
    char *pchBase;
    PFF *pPFF_;
    FONTFILEVIEW **ppFFV, *pFFV;
    PVOID pvKView;
    FONTFILE_PRINTKVIEW *pNode = NULL;
    HFF hff;

    //??? is it possible that pch is a kernel address? if so, what should we return?
    if (pch &&
        IS_USER_ADDRESS(pch) &&
        (pPFF_ = prfnt->pPFF) &&
        (hff = pPFF_->hff) &&
        (ppFFV = pPFF_->ppfv))
    {
        for (iKernelBase = 0; iKernelBase < pPFF_->cFiles; ppFFV++, iKernelBase++)
        {
            if (pFFV = *ppFFV)
            {
                pchBase = (char*) ((pFFV->SpoolerBase) ? pFFV->SpoolerBase : pFFV->fv.pvViewFD);

                if (pchBase && (pchBase <= pch) && (pch < pchBase + pFFV->fv.cjView))
                {
                    if (!bFindPrintKView(hff, iKernelBase, &pNode) || (pNode->pKView == NULL))
                    {
                        if (pFFV->fv.pSection)
                        {
                            if (NT_SUCCESS(MapFontFileInKernel(pFFV->fv.pSection, &pvKView)))
                            {
                                if (bAddPrintKView(hff, pvKView, iKernelBase, (ULONG_PTR)ppfe(), pNode))
                                {
                                    return (pch - pchBase + (char*)pvKView);
                                }
                                else
                                {
                                    vUnmapFontFileInKernel(pvKView);
                                    return NULL;
                                }
                            }
                        }
                        else
                        {
                            RIP("pSection = 0\n");
                        }
                    }
                    else
                    {
                        pvKView = pNode->pKView;
                        return (pch - pchBase + (char*)pvKView);
                    }
                }
            }
        }
    }

    return NULL;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ:PostTextOut
*
* Routine Description:
*
*   Called after calling to any DrvTextOut to keep track of cPrint count
*
* Arguments:
*
*   none
*
* Called by:
*
*   bProxyTextOut, GreExtTextOutWLocked
*
* Return Value:
*
*   none
*
\**************************************************************************/

void RFONTOBJ::PostTextOut(XDCOBJ& dco)
{
    FONTFILE_PRINTKVIEW  *pPrintKView;

    if (dco.bPrinter() && !dco.bUMPD() && !bDeviceFont())
    {
        SEMOBJ so(ghsemPrintKView);

        pPrintKView = gpPrintKViewList;

        while (pPrintKView)
        {
            if (pPrintKView->hff == pPFF()->hff)
            {
                if (pPrintKView->cPrint)
                {
                    pPrintKView->cPrint--;
                }
            }
            pPrintKView = pPrintKView->pNext;
        }
    }
}


/*******************Public*Routine***********************\
* Routine Name:
*
*   vClosePrintKView()
*
* Routine Description:
*
*   This routine goes through the global gpPrintKViewList
* and unmap all the kernel views, except for those "few" at
* that are at the moment used by DrvTextOut calls.
*   This is only called when the first attemp of mapping
* a kernel view on a font file failed.
\********************************************************/

void vClosePrintKView()
{
    FONTFILE_PRINTKVIEW *pPrintKView;

    SEMOBJ so(ghsemPrintKView);

    pPrintKView = gpPrintKViewList;

    while(pPrintKView)
    {
        if
        (
            (pPrintKView->cPrint == 0) && // no DrvTextOut calls in progress with this font
            pPrintKView->pKView           // and file is mapped
        )
        {
            vUnmapFontFileInKernel(pPrintKView->pKView);
            pPrintKView->pKView = NULL;
        }
        pPrintKView = pPrintKView->pNext;
    }
}

/***********************Public*Routine***************************\
* Routine Name:
*
*   MapFontFileInKernel(void* void**)
*
* Routine Description:
*
*   This routine maps a font file in kernel.
\****************************************************************/
NTSTATUS  MapFontFileInKernel(void *pSection, void** ppvKView)
{
    NTSTATUS NtStatus;
    SIZE_T Dummy;

    *ppvKView = NULL;
    Dummy = 0; // map entire section into kernel

#if defined(_GDIPLUS_)
    NtStatus = MapViewInProcessSpace(
                    pSection,
                    ppvKView,
                    &Dummy);
#elif defined(_HYDRA_)
    // MmMapViewInSessionSpace is internally promoted to
    // MmMapViewInSystemSpace on non-Hydra systems.

    NtStatus = Win32MapViewInSessionSpace(pSection,
                                          ppvKView,
                                          &Dummy);
#else
    NtStatus = MmMapViewInSystemSpace(pSection,
                                      ppvKView,
                                      &Dummy);
#endif
    
    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("MapFontViewInKernel -- failure at the first attemp\n");

        vClosePrintKView();

        // try again

        #if defined(_GDIPLUS_)
            NtStatus = MapViewInProcessSpace(
                            pSection,
                            ppvKView,
                            &Dummy);
        #elif defined(_HYDRA_)
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus = Win32MapViewInSessionSpace(pSection,
                                                  ppvKView,
                                                  &Dummy);
        #else
            NtStatus = MmMapViewInSystemSpace(pSection,
                                              ppvKView,
                                              &Dummy);
        #endif
    }

#ifdef _HYDRA_
#if DBG
    if (!G_fConsole)
    {
        DebugGreTrackAddMapView(*ppvKView);
    }
#endif
#endif

    return (NtStatus);
}


/**********************Public*Routine****************************\
* Routine Name:
*
*   vUnmapFontFileInKernel(void*)
*
* Routine Description:
*
*   This routine unmap the kernel font file view
\****************************************************************/

VOID vUnmapFontFileInKernel(void *pvKView)
{
#if defined(_GDIPLUS_)
    UnmapViewInProcessSpace(pvKView);
#elif defined(_HYDRA_)
    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.
    
    Win32UnmapViewInSessionSpace(pvKView);
#else
    MmUnmapViewInSystemSpace(pvKView);
#endif
    
#ifdef _HYDRA_
#if DBG
    if (!G_fConsole)
    {
        DebugGreTrackRemoveMapView (pvKView);
    }
#endif
#endif
}


/*******************Public*Routine********************\
* vCleanupPrintKViewList
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Worker functions for MultiUserGreCleanupAllFonts.
*
*
* History:
*  01-Jun-1999 -by- Xudong Wu [tessiew]
* Wrote it.
\*****************************************************/
void vCleanupPrintKViewList()
{
    FONTFILE_PRINTKVIEW *pPrintKView, *pNext;

    pNext = gpPrintKViewList;

    while(pNext)
    {
        ASSERTGDI(!pNext->pKView, "vCleanupPrintKViewList: unmapped pKView\n");

        pPrintKView = pNext;
        pNext = pPrintKView->pNext;

        VFREEMEM(pPrintKView);
    }
}


/*********************Public*Routine*******************\
* Routine Name:
*
*   UnmapPrintKView(char*)
*
* Routine Description:
*
* This routine is ONLY called at DestroyFont time
* when the cRFONT refer count in RFONT is ONE.
* 
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\******************************************************/
void UnmapPrintKView(HFF hff)
{
    FONTFILE_PRINTKVIEW *pPrintKView;

    SEMOBJ so(ghsemPrintKView);

    pPrintKView = gpPrintKViewList;

    while(pPrintKView)
    {        
        if (pPrintKView->hff == hff && pPrintKView->pKView)
        {
            ASSERTGDI(!pPrintKView->cPrint, "UnmapPrintKView: cPrint != 0\n");

            vUnmapFontFileInKernel(pPrintKView->pKView);

            pPrintKView->pKView = NULL;
        }
        pPrintKView = pPrintKView->pNext;        
    }
}



//
// Implementation of pvFile and pchTranslate for UMPD.
// Here we need to map the font file into the current process' user mode address
// instead of kernel's address space.
//

PVOID
RFONTOBJ::pvFileUMPD(
    ULONG *pcjFile,
    PVOID *ppBase
    )

{
    CHAR    *pchFile = NULL;
    ULONG   cjFile = 0;
    PFF     *pPFF;
    HFF     hff;

    PDEVOBJ pdo( prfnt->hdevProducer );

    //
    // pdo.GetTrueTypeFile returns a user mode address in
    // CSR process' address space.
    //

    if (pdo.bValid() &&
        (pPFF = prfnt->pPFF) != NULL &&
        (hff = pPFF->hff) != NULL &&
        (pchFile = (CHAR *) pdo.GetTrueTypeFile(hff, &cjFile)) != NULL)
    {
        //
        // We now need to translate that address into
        // the current process' address space.
        //

        pchFile = pchTranslateUMPD(pchFile, ppBase);
    }

    if (pchFile == NULL)
        cjFile = 0;

    if (pcjFile)
        *pcjFile = cjFile;

    return pchFile;
}


CHAR*
RFONTOBJ::pchTranslateUMPD(
    CHAR    *pch,
    PVOID   *ppBase
    )

{
    NTSTATUS        NtStatus;
    ULONG           iKernelBase;
    CHAR            *pchBase;
    PFF             *pPFF_;
    FONTFILEVIEW    **ppFFV, *pFFV;
    VOID            *pSaveFirstSpoolerBase, *pFinalSpoolerBase;
    VOID            *pSaveFirstSection, *pFinalSection;

    if ((pch != NULL) &&
        IS_USER_ADDRESS(pch) &&
        (pPFF_ = prfnt->pPFF) != NULL &&
        (ppFFV = pPFF_->ppfv) != NULL)
    {
        for (iKernelBase = 0; iKernelBase < pPFF_->cFiles; ppFFV++, iKernelBase++)
        {
            if ((pFFV = *ppFFV) == NULL)
                continue;

            // type 1 fonts have 2 or 3 files, we save the pSection and SpoolerBase and use for 2nd, 3rd file
            // in remote postscript printing they share the the same section and spooler base
            
            if (iKernelBase == 0)
            {
               //save the pSection and pSpoolerBase of the 1st font 

               pSaveFirstSection = pFFV->fv.pSection;     
               pSaveFirstSpoolerBase = pFFV->SpoolerBase; 

            }

            if (pFFV->SpoolerBase == NULL)
            {
                pFinalSpoolerBase = pSaveFirstSpoolerBase;
            }
            else
            {
                pFinalSpoolerBase = pFFV->SpoolerBase;
            }

            pchBase = (CHAR*) ((pFinalSpoolerBase) ? pFinalSpoolerBase : pFFV->fv.pvViewFD);

            if (pchBase && (pchBase <= pch) && (pch < pchBase + pFFV->fv.cjView))
            {

                if (pFFV->fv.pSection == NULL)
                {
                    pFinalSection = pSaveFirstSection;
                }
                else
                {
                    pFinalSection = pFFV->fv.pSection;
                }

                if (pFinalSection == NULL)
                {
                    RIP("pSection == NULL\n");  
                    return NULL;
                }

                LARGE_INTEGER   SectionOffset;
                SIZE_T          ViewSize;

                *ppBase = NULL;
                ViewSize = 0;
                RtlZeroMemory(&SectionOffset, sizeof(SectionOffset));

                NtStatus = MmMapViewOfSection(
                                pFinalSection,
                                PsGetCurrentProcess(),
                                ppBase,
                                0,
                                pFFV->fv.cjView,
                                &SectionOffset,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READONLY);

                if (!NT_SUCCESS(NtStatus))
                {
                    WARNING("RFONTOBJ::pchTranslateUMPD: MmMapViewOfSection failed\n");
                    *ppBase = NULL;

                    return NULL;
                }

                return (CHAR *) *ppBase + (pch - pchBase);
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\pooltrk.cxx ===
/******************************Module*Header*******************************\
* Module Name: pooltrk.cxx
*
* Pool allocation tracker.
*
* Created: 23-Feb-1998 20:09:03
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "pooltrk.hxx"

#if DBG

#ifdef _HYDRA_
#ifndef USER_POOL_TAGGING_ON

extern BOOL G_fConsole;

LIST_ENTRY gleDebugGrePoolTrackerHead;
HSEMAPHORE ghsemDebugGrePoolTracker = NULL;

/******************************Public*Routine******************************\
* DebugGrePoolTrackerInit
*
* Initialize the pool tracker.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
DebugGrePoolTrackerInit()
{
    //
    // Initialize doubly linked list used to track pool allocations.
    //

    InitializeListHead(&gleDebugGrePoolTrackerHead);

    //
    // Initialize the list semaphore.
    //
    // Note: allocate from non-tracked pool.  We will trust the pool
    // tracker to cleanup its own allocation.
    //

    ghsemDebugGrePoolTracker = GreCreateSemaphoreNonTracked();

    return (ghsemDebugGrePoolTracker != NULL);
}

/******************************Public*Routine******************************\
* DebugGrePoolTrackerAdd
*
* Add specified pool allocation to list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGrePoolTrackerAdd(POOLTRACKHDR *pTrack, SIZE_T cj, ULONG ulTag)
{
    PLIST_ENTRY pleNew = (PLIST_ENTRY) pTrack;

    //
    // Setup pool track header.
    //
    // Sundown note: pool allocations in GRE should be < 4GB
    //

    pTrack->ulSize = cj;
    pTrack->ulTag  = ulTag;

    //
    // Lock the pool tracking list.
    //
    // During GRE initialization, we may be called while allocating
    // the ghsemDebugGrePoolTracker.  So we actually need to check
    // if it exists.
    //

    if (ghsemDebugGrePoolTracker) GreAcquireSemaphore(ghsemDebugGrePoolTracker);

    //
    // Insert into the pool tracking list.
    //

    InsertTailList(&gleDebugGrePoolTrackerHead, pleNew);

    //
    // Unlock the pool tracking list.
    //

    if (ghsemDebugGrePoolTracker) GreReleaseSemaphore(ghsemDebugGrePoolTracker);
}

/******************************Public*Routine******************************\
* DebugGrePoolTrackerRemove
*
* Remove specified pool allocation from list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGrePoolTrackerRemove(POOLTRACKHDR *pTrack)
{
    PLIST_ENTRY pleVictim = (PLIST_ENTRY) pTrack;

    //
    // Lock the pool tracking list.
    //
    // During GRE initialization, we may be called while allocating
    // the ghsemDebugGrePoolTracker.  So we actually need to check
    // if it exists.
    //

    if (ghsemDebugGrePoolTracker) GreAcquireSemaphore(ghsemDebugGrePoolTracker);

    //
    // Remove entry from pool tracking list.
    //

    RemoveEntryList(pleVictim);

    //
    // Unlock the pool tracking list.
    //

    if (ghsemDebugGrePoolTracker) GreReleaseSemaphore(ghsemDebugGrePoolTracker);
}

/******************************Public*Routine******************************\
* DebugGreAllocPool
*
* Allocates paged pool and tracks it in the pool tracking list.
* Free with DebugGreFreePool.
*
*                 Buffer
*   pTrack --> +----------------+
*              | POOLTRACKHDR   |
*    pvRet --> +----------------+
*              | Returned       |
*              | Buffer         |
*              | Allocation     |
*              |                |
*                ...
*              |                |
*              +----------------+
*
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" PVOID
DebugGreAllocPool(SIZE_T ulBytes, ULONG ulTag)
{
    PVOID pv;

    //
    // If Hydra, adjust requested size to include tracking header.
    //
    // Sundown note: sizeof(POOLTRACKHDR) will fit into 32-bits.
    //

    if (!G_fConsole)
    {
        if (ulBytes <= (MAXULONG - sizeof(POOLTRACKHDR)))
            ulBytes += ((ULONG) sizeof(POOLTRACKHDR));
        else
            return NULL;
    }

    //
    // Allocate paged pool.
    //

    pv = ExAllocatePoolWithTag(
            (POOL_TYPE) (SESSION_POOL_MASK | PagedPool),
            ulBytes, ulTag);

    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Add allocation to tracking list.
            //

            POOLTRACKHDR *pTrack = (POOLTRACKHDR *) pv;

            DebugGrePoolTrackerAdd(pTrack, ulBytes, ulTag);

        #ifdef POOLTRACK_STACKTRACE_ENABLE
            //
            // Save the stack back trace.
            //

            ULONG ulHash;

            RtlZeroMemory(pTrack->apvStackTrace,
                          POOLTRACK_TRACESIZE * sizeof(PVOID));

            RtlCaptureStackBackTrace(1,
                                     POOLTRACK_TRACESIZE,
                                     pTrack->apvStackTrace,
                                     &ulHash);
        #endif

            //
            // Adjust return pointer to exclude tracking header.
            //

            pv = (PVOID) (pTrack + 1);
        }
    }

    return pv;
}

/******************************Public*Routine******************************\
* DebugGreAllocPoolNonPaged
*
* Allocates nonpaged pool and tracks it in the pool tracking list.
* Free with DebugGreFreePool.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" PVOID
DebugGreAllocPoolNonPaged(SIZE_T ulBytes, ULONG ulTag)
{
    PVOID pv;

    //
    // If Hydra, adjust requested size to include tracking header.
    //
    // Sundown note: sizeof(POOLTRACKHDR) will fit into 32-bits.
    //

    if (!G_fConsole)
    {
        ulBytes += ((ULONG) sizeof(POOLTRACKHDR));
    }

    //
    // Allocate nonpaged pool.
    //

    pv = ExAllocatePoolWithTag(
            (POOL_TYPE)NonPagedPool,
            ulBytes, ulTag);

    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Add allocation to tracking list.
            //

            POOLTRACKHDR *pTrack = (POOLTRACKHDR *) pv;

            DebugGrePoolTrackerAdd(pTrack, ulBytes, ulTag);

            //
            // Adjust return pointer to exclude tracking header.
            //

            pv = (PVOID) (pTrack + 1);
        }
    }

    return pv;
}

/******************************Public*Routine******************************\
* DebugGreFreePool
*
* Free pool memory allocated by DebugGreAllocPool and
* DebugGreAllocPoolNonPaged.  Removes the allocation from tracking list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID
DebugGreFreePool(PVOID pv)
{
    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Find header and remove from tracking list.
            //

            POOLTRACKHDR *pTrack = ((POOLTRACKHDR *) pv) - 1;

            DebugGrePoolTrackerRemove(pTrack);

            //
            // Adjust pointer to base of allocation.
            //

            pv = (PVOID) pTrack;
        }

        //
        // Free the pool allocation.
        //

        ExFreePool(pv);
    }
}

/******************************Public*Routine******************************\
* DebugGreCleanupPoolTracker
*
* Frees any allocations remaining in the tracking list (but asserts so
* that debugger is informed that a leak exists).  Free resources used
* to maintain the tracking list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGreCleanupPoolTracker()
{
    BOOL bTitle = FALSE;
    ULONG cLeaks = 0;
    volatile PLIST_ENTRY pleNext;

    //
    // Assert if list not empty (i.e., there are leaks!).
    //
    // What to do if there is a leak?
    //
    // Well, it might be enough just to look at the tags that leak.
    // If that doesn't provide enough detail to track the leak,
    // recompile with USER_POOL_TAGGING_ON defined in engine.h and
    // define POOL_ALLOC_TRACE in w32\w32inc\usergdi.h to use the
    // USER pool tracking code.  You'll have build a checked version
    // of win32k (clean build both USER and GDI), but this pool tracker
    // will record a stack trace for every allocation.  If we leak,
    // USER will assert during Hydra session shutdown and the userkdx
    // dpa extension will dump the allocations (use !dpa -ts 24 to
    // dump the leaked TAG_GDI allocations with a stack trace).
    //

    if (!IsListEmpty(&gleDebugGrePoolTrackerHead))
    {
        DbgPrint("DebugGreCleanupPoolTracker: "
                 "gleDebugGrePoolTrackerHead 0x%08lx not empty\n",
                 &gleDebugGrePoolTrackerHead);
        RIP("DebugGreCleanupPoolTracker: leak detected\n");
    }

    //
    // Free all allocations in the list.
    //

    pleNext = gleDebugGrePoolTrackerHead.Flink;

    while (pleNext != &gleDebugGrePoolTrackerHead)
    {
        //
        // Pool allocation starts after the POOLTRACKHDR.
        //

        PVOID pvVictim = (PVOID) (((POOLTRACKHDR *) pleNext) + 1);

        //
        // Count the number of leaked allocations.
        //

        cLeaks++;

        //
        // Print out the allocation information.
        //

        if (!bTitle)
        {
            DbgPrint("\nDebugGreCleanupPoolTracker: cleaning up pool allocations\n");
            DbgPrint("----------\t----------\t-----------------\n");
            DbgPrint("Address   \tSize      \tTag\n");
            DbgPrint("----------\t----------\t-----------------\n");
            bTitle = TRUE;
        }

        DbgPrint("0x%08lx\t0x%08lx\t0x%08lx (%c%c%c%c)\n",
                 pleNext,
                 ((POOLTRACKHDR *) pleNext)->ulSize,
                 ((POOLTRACKHDR *) pleNext)->ulTag,
                 ((((POOLTRACKHDR *) pleNext)->ulTag)      ) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >>  8) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >> 16) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >> 24) & 0xff);

        //
        // Delete the allocation.
        //

        DebugGreFreePool(pvVictim);

        //
        // Restart at the begining of the list since our
        // entry got deleted.
        //

        pleNext = gleDebugGrePoolTrackerHead.Flink;
    }

    if (bTitle)
    {
        DbgPrint("----------\t----------\t-----------------\n");
    }

    if (cLeaks)
    {
        DbgPrint("%ld allocations leaked\n\n", cLeaks);
    }

    //
    // Delete the list lock.
    //
    // Note that the list lock was allocated from non-tracked pool.
    // It is also a non-tracked semaphore - that is, it must be deleted
    // explicitly.
    //

    GreDeleteSemaphoreNonTracked(ghsemDebugGrePoolTracker);
    ghsemDebugGrePoolTracker = NULL;
}

#endif  //USER_POOL_TAGGING_ON

#endif  //_HYDRA_

#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rgn2path.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgn2path.cxx                                                *
*                                                                          *
* Created: 14-Sep-1993 11:00:07                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                                 *
*                                                                          *
* Discussion                                                               *
*                                                                          *
* Input                                                                    *
*                                                                          *
*     The input to the diagonalization routing is a rectangular            *
*     path whose vertices have integer endpoints.  Moreover it             *
*     is required that the path always has the region on its               *
*     left and that successive lines are mutually orthogonal.              *
*                                                                          *
*     All paths are in device 28.4 coordinates.  (Since all of             *
*     the input coordinates are integers, the fractional part of all       *
*     coordinates is zero.)                                                *
*                                                                          *
* Output                                                                   *
*                                                                          *
*     A path that contains the same pixels as the originl path.            *
*                                                                          *
* Filling Convention                                                       *
*                                                                          *
*     Any region bounded by two non-horizontal lines is closed             *
*     on the left and open on the right. If the region is bounded          *
*     by two horizontal lines, it is closed on the top and open on         *
*     bottom.                                                              *
*                                                                          *
* Definition                                                               *
*                                                                          *
*     A CORNER is subsequence of two lines from the orignal axial path.    *
*     It is convenient to partition the set of corners into two classes;   *
*     HORIZONTAL-VERTIAL and VERTICAL-HORIZONTAL.                          *
*                                                                          *
*     A corner is "diagonalizable" the original two lines can be replaced  *
*     by a single diagonal line such that same pixels would be rendered    *
*     (using the filling convention defined above).                        *
*                                                                          *
*                                                                          *
* Nomenclature                                                             *
*                                                                          *
*       S ::= "SOUTH" ::= one pixel move in +y-direction                   *
*       N ::= "NORTH" ::= one pixel move in -y-direction                   *
*       E ::= "EAST"  ::= one pixel move in +x direction                   *
*       W ::= "WEST"  ::= one pixel move in -x direction                   *
*                                                                          *
*     The set of diagonalizable corners are described by                   *
*     the following regular expressions:                                   *
*                                                                          *
*      DIAGONALIZABLE CORNERS                                              *
*                                                                          *
*         S(E+|W+)  a one pixel move in the +y-direction                   *
*                   followed by at least one pixel in any horizontal       *
*                   direction                                              *
*                                                                          *
*         S+W       an arbitary number of pixels in the +y-direction       *
*                   followed by a single pixel move in the                 *
*                   negative x-direction.                                  *
*                                                                          *
*         EN+       a one pixel move in the positive x-direction           *
*                   followed by at least one pixel move in the negative    *
*                   x-direction                                            *
*                                                                          *
*         (E+|W+)N  at least one-pixel move in the horizontal followed     *
*                   by a single pixel move in the negative                 *
*                   y-direction.                                           *
*                                                                          *
* Algorithm                                                                *
*                                                                          *
* BEGIN                                                                    *
*    <For each corner in the orginal path>                                 *
*    BEGIN                                                                 *
*        <if the corner is diagonalizable> THEN                            *
*                                                                          *
*            <just draw a single diagonal line>                            *
*        ELSE                                                              *
*            <draw both legs of the original corner>                       *
*    END                                                                   *
*                                                                          *
*    <Go around the path once again, merging successive                    *
*     identical moves into single lines>                                   *
* END                                                                      *
*                                                                          *
*     In the code, both of these steps are done in parallel                *
*                                                                          *
* Further Improvements                                                     *
*                                                                          *
*  The output path the I generate with this algorithm will contain only    *
*  points that were vertices of the original axial path. A larger of       *
*  regular expressions could be searched for if I were willing to          *
*  consider using new vertices for the output path. For example            *
*  the regular exprssios N+WN and S+ES describe two "chicane turns" that   *
*  can be diagonalized. The price to be paid is the a more complex         *
*  code path.                                                              *
*                                                                          *
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bDiagonalize                                             *
*                                                                          *
*   Produces a diagonalized path that is pixel equivalent.                 *
*                                                                          *
* Assumptions                                                              *
*                                                                          *
*   0. *this is the original path which will not be changed.               *
*   1. All points on the path lie on integers                              *
*   2. All subpaths have the inside on the left                            *
*   3. All subpaths are closed                                             *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bDiagonalizePath(EPATHOBJ* pepoOut_)
{
    pepoOut     = pepoOut_;
    bMoreToEnum = TRUE;
    vEnumStart();
    while (bFetchSubPath())
    {
        if (!bDiagonalizeSubPath())
        {
            return(FALSE);
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bFetchSubPath                                            *
*                                                                          *
* History:                                                                 *
*  Wed 15-Sep-1993 14:19:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bFetchSubPath()
{
    BOOL bRet = FALSE;

    if (bMoreToEnum) {

        // first we whiz on by any empty subpaths

        do {
            bMoreToEnum = bEnum(&pd);
        } while ((pd.count == 0) && (bMoreToEnum));

        if (pd.count && (pd.flags & PD_BEGINSUBPATH) && pd.pptfx) {
            // record the first point in the sub-path, we will need it later
            // when dealing with the last corner in the path

            ptfxFirst = *(pd.pptfx);
            bRet = TRUE;
        }
        else
            WARNING("RTP_PATHMEMOBJ::bFetchSubPath -- bad SubPath\n");
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bWritePoint                                              *
*                                                                          *
* This routine takes as input a candidate point for writing. However       *
* this routine is smart in that it analyzes the stream of candidate        *
* points looking for consecutive sub-sets of points that all lie on the    *
* same line. When such a case is recognized, then only the endpoints of    *
* the interpolating line are actually added to the output path.            *
*                                                                          *
* I do not go to a great deal of trouble to determine if a candidate       *
* point is on a line. All that I do is to see if the vector increment      *
* to the new point  is the same as the increment between prior points      *
* in the input path.                                                       *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bWritePoint()
{
    POINTFIX ptfxNewAB;
    BOOL bRet = TRUE;
    int  jA   = j;

    if (cPoints == 2)
    {
        ptfxNewAB.x = aptfx[jA].x - aptfxWrite[1].x;
        ptfxNewAB.y = aptfx[jA].y - aptfxWrite[1].y;
        if (ptfxNewAB.x != ptfxAB.x || ptfxNewAB.y != ptfxAB.y)
        {
            if (!(bRet = pepoOut->bPolyLineTo(aptfxWrite,1)))
            {
                WARNING((
                    "pepoOut->bPolyLineTo(aptfxWrite,1) failed when"
                    " called from RTP_PATHMEMOBJ::bWritePoint()\n"
                    ));
            }
            else
            {
                aptfxWrite[0] = aptfxWrite[1];
                ptfxAB   = ptfxNewAB;
            }
        }
        aptfxWrite[1] = aptfx[jA];
    }
    else if (cPoints == 0)
    {
        aptfxWrite[0] = aptfx[jA];
        cPoints += 1;
    }
    else if (cPoints == 1)
    {
        aptfxWrite[1] = aptfx[jA];
        ptfxAB.x = aptfxWrite[1].x - aptfxWrite[0].x;
        ptfxAB.y = aptfxWrite[1].y - aptfxWrite[0].y;
        cPoints += 1;
    }
    else
    {
        RIP("RTP_PATHMEMOBJ::bWritePoint -- bad cPoints\n");
        bRet = FALSE;
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* bFetchNextPoint  ... in sub-path                                         *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 14:13:01 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bFetchNextPoint()
{
#define TRUE_BIT 1
#define DONE_BIT 2

    int jold;
    int flag = TRUE_BIT;

    // advance the corner buffer along the path
    // jold points to the stale member of the corner buffer. This is
    // where we will store the new point in the path

    jold = j;
    j++;
    if (j > 2)
    {
        j -= 3;
    }
    if (pd.count == 0)
    {
        // there are no points left in the current batch.

        if (pd.flags & PD_ENDSUBPATH)
        {
            // If the PD_ENDSUBPATH flag was set, then we must add
            // into this path the first point in the subpath. This
            // is done so that later on, we can examine the last
            // corner which, of course, contains the first point.

            afl[jold]   = 0;
            aptfx[jold] = ptfxFirst;   // close the path
            pd.count -= 1;
            flag = DONE_BIT | TRUE_BIT;
        }
        else
        {
            ASSERTGDI(
                bMoreToEnum,
                "RTP_PATHMEMOBJ::bFetchNextPoint() -- bMoreToEnum == FALSE\n"
                );

            // If you get to here, you have exhauseted the current batch of
            // points, but there are more points left to be fetched for the
            // current subpath. This means that we will have to make another
            // call to bEnum()

            bMoreToEnum = bEnum(&pd);

            // At this point I check to make sure that the returned batch makes
            // sense

            if (!(pd.count > 0 && ((pd.flags & PD_BEGINSUBPATH) == 0) && pd.pptfx))
            {
                WARNING("RTP_PATHMEMOBJ::bFetchNextPoint -- bad pd\n");
                flag = DONE_BIT;
            }
        }
    }

    if (!(flag & DONE_BIT))
    {
        if ((LONG) pd.count > 0)
        {
            aptfx[jold] = *(pd.pptfx);
            if (pd.count == 1 && (pd.flags & PD_ENDSUBPATH))
            {
                afl[jold] = RTP_LAST_POINT;
            }
            else
            {
                afl[jold] = 0;
            }
            pd.pptfx += 1;
            pd.count -= 1;
        }
        else
        {
            ASSERTGDI(
                (LONG) pd.count > -3,
                "RTP_PATHMEMOBJ::bFetchNextPoint -- pd.count < -2\n"
                );
        }
    }
    return((BOOL) flag & TRUE_BIT);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bDiagonalizeSubPath                                      *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 12:47:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

#define ROTATE_BACKWARD(x,y,z) {int ttt = x; x = z; z = y; y = ttt;}
#define ROTATE_FORWARD(x,y,z)  {int ttt = x; x = y; y = z; z = ttt;}

BOOL RTP_PATHMEMOBJ::bDiagonalizeSubPath()
{
    FIX fxAB;    // length of the first leg
    FIX fxBC;    // length of the second leg
    int bH;      // set to 1 if second leg is horizontal
    int jA,jB,jC;
    register BOOL bRet = TRUE; // if FALSE then return immediately
                               // otherwise keep processing.

    cPoints = 0; // no points so far in the write buffer
    j       = 0; // set the start of the circular buffer

    // Fill the circular buffer with the first three points of the
    // path. The three member buffer, defines two successive lines, or
    // one corner (the path is guaranteed to be composed of alternating
    // lines along the x-axis and y-axis). I shall label the three vertices
    // of the corner A,B, and C. The point A always resides at ax[j],
    // point B resides at ax[iMod3[j+1]], and point C resides at
    // ax[iMod3[j+2]] where j can have one of the values 0, 1, 2.

    if (bRet = bFetchNextPoint() && bFetchNextPoint() && bFetchNextPoint())
    {
        ASSERTGDI(j == 0,"RTP_PATHMEMOBJ::bDiagonalizeSubPath() -- j != 0\n");

        // bH ::= <is the second leg of the corner horizontal?>
        //
        // if the second leg of the corner is horizontal set bH=1 otherwise
        // set bH=0. Calculate the length of the first leg of the corner
        // and save it in fxAB. Note that I do not need to use the iMod3
        // modulus operation since j==0.

        if (aptfx[2].y == aptfx[1].y)
        {
            bH = 1;
            fxAB = aptfx[1].y - aptfx[0].y;
        }
        else
        {
            bH = 0;
            fxAB = aptfx[1].x - aptfx[0].x;
        }

        // Start a new subpath at the first point of the subpath.

        bRet = pepoOut->bMoveTo(aptfx);

        jA = 0;
        jB = 1;
        jC = 2;
    }

    while (bRet)
    {
#if DBG
        if (!(afl[jA] & RTP_LAST_POINT))
        {
            // Assert that the the legs of the corner are along
            // the axes, and that the two legs are mutually
            // orthogonal

            ASSERTGDI(
                aptfx[jC].x == aptfx[jB].x ||
                aptfx[jC].y == aptfx[jB].y,
                "Bad Path :: C-B is not axial\n"
                );
            ASSERTGDI(
                aptfx[jA].x == aptfx[jB].x ||
                aptfx[jA].y == aptfx[jB].y,
                "Bad Path :: B-A is not axial\n"
                );
            ASSERTGDI(
                (aptfx[jC].x - aptfx[jB].x) *
                (aptfx[jB].x - aptfx[jA].x)
                +
                (aptfx[jC].y - aptfx[jB].y) *
                (aptfx[jB].y - aptfx[jA].y)
                == 0,
                "Bad Path :: B-A is not orthogonal to C-B"
                );
        }
#endif
        // If the first vertex of the corner is the last point in the
        // original subpath then we terminate the processing.  This point
        // has either been recorded with PATHMEMOBJ::bMoveTo or
        // PATHMEMOBJ::bPolyLineTo.  All that remains is to close the
        // subpath which is done outside the while loop

        if (afl[jA] & RTP_LAST_POINT)
            break;

        // There are two paths through the following if-else clause
        // They are for VERTICAL-HORIZONTAL and HORIZONTAL-VERTICAL
        // corners respectively. These two clauses are identical
        // except for the interchange of ".x" with ".y". It might be
        // a good idea to have macros or subrouines for these sections
        // in order that they be guranteed to be identical.

        // Is the second leg of the corner horizontal?

        if (bH)
        {
            // Yes, the second leg of the corner is horizontal

            fxBC = aptfx[jC].x - aptfx[jB].x;

            // Is the corner diagonalizable?

            if ((fxAB > 0) && ((fxAB == FIX_ONE) || (fxBC == -FIX_ONE)))
            {
                // Yes, the corner is diagonalizable
                //
                // If the middle of the corner was the last point in the
                // original path then the last point in the output path
                // is the first point in the corner. This is because the
                // last line in the output path is this diagonalized
                // corner which will be produced automatically by the
                // CloseFigure() call after this while-loop. Thus, in
                // this case we would just break out of the loop.

                if (afl[jB] & RTP_LAST_POINT)
                    break;

                // The corner is diagonalizable. This means that we are no
                // longer interested in the first two points of this corner.
                // We therefore fetch the next two points of the path
                // an place them in our circular corner-buffer.

                if (!(bRet = bFetchNextPoint() && bFetchNextPoint()))
                    break;

                // under modulo 3 arithmetic, incrementing by 2 is
                // equivalent to decrementing by 1

                ROTATE_BACKWARD(jA,jB,jC);

                // fxAB is set to the length of the first leg of the new
                // corner.

                fxAB = aptfx[jB].y - aptfx[jA].y;
            }
            else
            {
                // No, the corner is not diagonalizable
                //
                // The corner cannot be diagonalized. Advance the corner
                // to the next point in the original path. The orientation
                // of the second leg of the corner will change. The length
                // of the first leg of the new corner is set equal to the
                // length of the second leg of the previous corner.

                if (!(bRet = bFetchNextPoint()))
                    break;
                ROTATE_FORWARD(jA,jB,jC);
                bH  ^= 1;
                fxAB = fxBC;
            }
        }
        else
        {
            // Diagonalize the HORIZONTAL->VERTICAL corner

            fxBC = aptfx[jC].y - aptfx[jB].y;
            if ((fxBC < 0) && ((fxAB == FIX_ONE) || (fxBC == -FIX_ONE)))
            {
                if (afl[jB] & RTP_LAST_POINT)
                    break;
                if (!(bRet = bFetchNextPoint() && bFetchNextPoint()))
                    break;
                ROTATE_BACKWARD(jA,jB,jC);
                fxAB = aptfx[jB].x - aptfx[jA].x;
            }
            else
            {
                if (!(bRet = bFetchNextPoint()))
                    break;
                ROTATE_FORWARD(jA,jB,jC);
                bH  ^= 1;
                fxAB  = fxBC;
            }
        }
        if (!(bRet = bWritePoint()))
            break;
    }

    if (bRet)
    {
        ASSERTGDI(cPoints == 2,"GDI Region To Path -- cPoints is not 2\n");

        bRet = pepoOut->bPolyLineTo(aptfxWrite, 2) && pepoOut->bCloseFigure();
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\print.cxx ===
/******************************Module*Header*******************************\
* Module Name: print.cxx
*
* Printer support routines.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C"
{
#include <gl\gl.h>
#include <gldrv.h>
#include <dciddi.h>
};

extern "C"
{
    extern HFASTMUTEX ghfmMemory;
}

#define TYPE1_KEY L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts"

PTYPEONEINFO gpTypeOneInfo = NULL;
PTYPEONEINFO GetTypeOneFontList();
BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName );

extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);
extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *pFontFileView);

extern PW32PROCESS gpidSpool;

/******************************Public*Routine******************************\
* DoFontManagement                                                         *
*                                                                          *
* Gives us access to the driver entry point DrvFontManagement.  This is    *
* very much an Escape function, except that it needs a font realization.   *
*                                                                          *
*  Fri 07-May-1993 14:56:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

ULONG DoFontManagement(
    DCOBJ &dco,
    ULONG iMode,
    ULONG cjIn,
    PVOID pvIn,
    ULONG cjOut,
    PVOID pvOut
)
{
    ULONG ulRet   = 0;
    PVOID pvExtra = NULL;

    PDEVOBJ pdo(dco.hdev());

    PFN_DrvFontManagement pfnF = PPFNDRV(pdo,FontManagement);

    if (pfnF == (PFN_DrvFontManagement) NULL)
        return(ulRet);


    if (iMode == QUERYESCSUPPORT)
    {
    // Pass it to the device.

        return ((*pfnF)
            (
                pdo.bUMPD() ? (SURFOBJ *)pdo.dhpdev() : NULL, //overload pso with dhpdev for UMPD
                NULL,
                iMode,
                cjIn,
                pvIn,
                0,
                NULL
            ));

    }

    RFONTOBJ rfo(dco,FALSE);

    if (!rfo.bValid())
    {
        WARNING("gdisrv!DoFontManagement(): could not lock HRFONT\n");
        return(ulRet);
    }

    // See if we need some extra RAM and translation work.

    if (iMode == DOWNLOADFACE)
    {
        // How many 16 bit values are there now?

        int cWords = (int)cjIn / sizeof(WCHAR);

        // Try to get a buffer of 32 bit entries, since HGLYPHs are bigger.

        pvExtra = (BALLOC_OVERFLOW1(cWords,HGLYPH)) ? NULL
            : PALLOCMEM(cWords * sizeof(HGLYPH),'mfdG');

        if (pvExtra == NULL)
            return(ulRet);

        // Translate the UNICODE to HGYLPHs.

        if (cWords > 1)
        {
            rfo.vXlatGlyphArray
            (
                ((WCHAR *) pvIn) + 1,
                (UINT) (cWords-1),
                ((HGLYPH *) pvExtra) + 1
            );
        }

        // Copy the control word from the app over.

        *(HGLYPH *) pvExtra = *(WORD *) pvIn;

        // Adjust the pvIn and cjIn.

        pvIn = pvExtra;
        cjIn = cWords * sizeof(HGLYPH);
    }


    // It is unfortunate that apps call some printing escapes before
    // doing a StartDoc, so there is no real surface in the DC.
    // We fake up a rather poor one here if we need it.  The device
    // driver may only dereference the dhpdev from this!

    SURFOBJ soFake;
    SURFOBJ *pso = dco.pSurface()->pSurfobj();

    if (pso == (SURFOBJ *) NULL)
    {
        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
        soFake.dhpdev = dco.dhpdev();
        soFake.hdev   = dco.hdev();
        soFake.iType  = (USHORT)STYPE_DEVICE;
        pso = &soFake;
    }

    // Pass it to the device.

    ulRet = (*pfnF)
            (
                pso,
                rfo.pfo(),
                iMode,
                cjIn,
                pvIn,
                cjOut,
                pvOut
            );

    // Free any extra RAM.

    if (pvExtra != NULL)
    {
        VFREEMEM(pvExtra);
    }
    return(ulRet);
}

/******************************Public*Routine******************************\
*
* LockMcdHdrSurfaces
*
* Locks kernel-mode handles for DirectDraw surfaces described in the
* given header.
*
* History:
*  Fri Sep 20 14:18:31 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL LockMcdHdrSurfaces(MCDESC_HEADER *pmeh,
                        PDD_SURFACE_LOCAL *ppslColor,
                        PDD_SURFACE_LOCAL *ppslDepth)
{
    PDD_SURFACE_LOCAL psl;
    PDD_SURFACE_GLOBAL psg;

    *ppslColor = *ppslDepth = NULL;

    if (pmeh->msrfColor.hSurf != NULL)
    {
        *ppslColor = psl = EngLockDirectDrawSurface(pmeh->msrfColor.hSurf);
        if (psl == NULL)
        {
            return FALSE;
        }
        psg = psl->lpGbl;

        // Update information with trusted values
        pmeh->msrfColor.hSurf = (HANDLE)psl;
        pmeh->msrfColor.lOffset = (ULONG)psg->fpVidMem;
        pmeh->msrfColor.lStride = psg->lPitch;
        pmeh->msrfColor.rclPos.left = psg->xHint;
        pmeh->msrfColor.rclPos.top = psg->yHint;
        pmeh->msrfColor.rclPos.right = psg->xHint+psg->wWidth;
        pmeh->msrfColor.rclPos.bottom = psg->yHint+psg->wHeight;
    }

    if (pmeh->msrfDepth.hSurf != NULL)
    {
        *ppslDepth = psl = EngLockDirectDrawSurface(pmeh->msrfDepth.hSurf);
        if (psl == NULL)
        {
            if (*ppslColor)
            {
                EngUnlockDirectDrawSurface(*ppslColor);
                *ppslColor = NULL;
            }
            return FALSE;
        }
        psg = psl->lpGbl;

        // Update information with trusted values
        pmeh->msrfDepth.hSurf = (HANDLE)psl;
        pmeh->msrfDepth.lOffset = (ULONG)psg->fpVidMem;
        pmeh->msrfDepth.lStride = psg->lPitch;
        pmeh->msrfDepth.rclPos.left = psg->xHint;
        pmeh->msrfDepth.rclPos.top = psg->yHint;
        pmeh->msrfDepth.rclPos.right = psg->xHint+psg->wWidth;
        pmeh->msrfDepth.rclPos.bottom = psg->yHint+psg->wHeight;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* iMcdSetupExtEscape
*
* MCD CreateContext ExtEscape.  This special escape allows WNDOBJ to be
* created in DrvEscape.  This is one of the three places where WNDOBJ can
* be created (the other two are iWndObjSetupExtEscape and DrvSetPixelFormat).
*
* See also iWndObjSetupExtEscape().
*
* History:
*  Tue Jun 21 17:24:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iMcdSetupExtEscape(
    DCOBJ &dco,             //  DC user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    KFLOATING_SAVE fsFpState;
    MCDESC_HEADER *pmeh = (MCDESC_HEADER *)pvIn;
    MCDESC_HEADER_NTPRIVATE *pmehPriv =
        (MCDESC_HEADER_NTPRIVATE *)((PBYTE)pvIn + sizeof(MCDESC_HEADER));

    // This command may not be in shared memory.  Also, make sure
    // we have entire command structure.

    if ((!pmehPriv->pBuffer) ||
        (pmehPriv->bufferSize < sizeof(MCDESC_CREATE_CONTEXT)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return 0;
    }

    MCDESC_CREATE_CONTEXT *pmccCreate =
        (MCDESC_CREATE_CONTEXT *)(pmehPriv->pBuffer);

    ASSERTGDI(nEscape == MCDFUNCS,
              "iMcdSetupExtEscape(): not a CreateContext escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Make sure that we don't have devlock before entering user critical section.
    // Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

    // Enter user critical section.

    USERCRIT usercrit;

    // Grab the devlock.
    // We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }

    // Assume no WNDOBJ on this call

    pmehPriv->pwo = (WNDOBJ *)NULL;

    HWND hwnd = NULL;

    PEWNDOBJ pwo = NULL;

    if (pmccCreate->flags & MCDESC_SURFACE_HWND)
    {
        // If it is a display DC, get the hwnd that the hdc is associated with.
        // If it is a printer or memory DC, hwnd is NULL.

        if (dco.bDisplay() && dco.dctp() == DCTYPE_DIRECT)
        {
            ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct really");

            if (!UserGetHwnd(dco.hdc(), &hwnd, (PVOID *) &pwo, FALSE))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_WINDOW_STYLE);
                return(FALSE);
            }

            if (pwo)
            {
                // If the WNDOBJ is owned by a different surface (as can happen with
                // dynamic mode changes, where the old driver instance lives as long
                // as the WNDOBJ is alive), simply fail the call.

                if (pwo->pto->pSurface != dco.pSurface())
                {
#ifdef OPENGL_MM
                    // Under multi-mon the DCOBJ may have the meta-surface while
                    // the pto was created with the actual hardware surface.
                    // So if the parent hdev of hdev in WNDOBJ is same as hdev in
                    // DCOBJ, we will allow to continue since we have replaced
                    // meta-PDEV with hardware PDEV. so it's fine.

                    PDEVOBJ pdoOfPwo(pwo->pto->pSurface->hdev());

                    if (pdoOfPwo.hdevParent() != dco.hdev())
                    {
                        WARNING("iMcdSetupExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                        return(FALSE);
                    }
#else
                    return(FALSE);
#endif // OPENGL_MM
                }

                if (!(pwo->fl & WO_GENERIC_WNDOBJ))
                    pmehPriv->pwo = (WNDOBJ *)pwo;
            }
        }

    // Make sure that DC hwnd matches MCDESC_CREATE_CONTEXT hwnd.

        if (hwnd != pmccCreate->hwnd)
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(0);
        }
    }

// Dispatch the call.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), pwo);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNDRV( pdo, Escape ))
        return(0);

    // Handle any surfaces

    // This escape doesn't expect any extra locks
    ASSERTGDI((pmeh->flags & MCDESC_FL_LOCK_SURFACES) == 0,
              "iMcdSetupExtEscape: MCDESC_FL_LOCK_SURFACES set\n");

    PDD_SURFACE_LOCAL psl[2] = { NULL, NULL };

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (!LockMcdHdrSurfaces(pmeh, &psl[0], &psl[1]))
        {
            return 0;
        }
    }

// Save floating point state
// This allows client drivers to do floating point operations
// If the state were not preserved then we would be corrupting the
// thread's user-mode FP state

    int iRet;

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iMcdSetupExtEscape: Unable to save FP state\n");
        iRet = 0;
        goto iMcdSetupExtEscape_Unlock_And_Exit;
    }

    iRet = (int) pdo.Escape(pso,
                            (ULONG)nEscape,
                            (ULONG)cjIn,
                             pvIn,
                            (ULONG)cjOut,
                            pvOut);

    // Restore floating point state

    KeRestoreFloatingPointState(&fsFpState);

    // If a new WNDOBJ is created, we need to update the window client regions
    // in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

iMcdSetupExtEscape_Unlock_And_Exit:

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (psl[0])
        {
            EngUnlockDirectDrawSurface(psl[0]);
        }

        if (psl[1])
        {
            EngUnlockDirectDrawSurface(psl[1]);
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* iWndObjSetupExtEscape
*
* Live video ExtEscape.  This special escape allows WNDOBJ to be created
* in DrvEscape.  This is one of the three places where WNDOBJ can be created
* (the other two are iMcdSetupExtEscape and DrvSetPixelFormat).
*
* See also iMcdSetupExtEscape().
*
* History:
*  Fri Feb 18 13:25:13 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iWndObjSetupExtEscape
(
    DCOBJ &dco,             //  DC user object
       int nEscape,         //  Specifies the escape function to be performed.
       int cjIn,            //  Number of bytes of data pointed to by pvIn
     PVOID pvIn,            //  Points to the input structure required
       int cjOut,           //  Number of bytes of data pointed to by pvOut
     PVOID pvOut            //  Points to the output structure
)
{
    ASSERTGDI(nEscape == WNDOBJ_SETUP,
        "iWndObjSetupExtEscape(): not a WndObjSetup escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Make sure that we don't have devlock before entering user critical section.
    // Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

    // Enter user critical section.

    USERCRIT usercrit;

    // Grab the devlock.
    // We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }


    // Dispatch the call.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNDRV( pdo, Escape ))
        return(0);

    int iRet = (int) pdo.Escape(pso,
                                (ULONG)nEscape,
                                (ULONG)cjIn,
                                pvIn,
                                (ULONG)cjOut,
                                pvOut);

    // If a new WNDOBJ is created, we need to update the window client regions
    // in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* LookUpWndobjs
*
* Looks up WNDOBJs for a list of HDCs.  Only performs lookups for
* HDCs which are for the same device as that given.  Returns negative
* if error, otherwise it returns a bitmask of the HDCs
* that had a lookup.
*
* Fills in DCOBJ table with locked DCs for tested HDCs.
* Overwrites HDC table with WNDOBJ pointers.
*
* History:
*  Mon Oct 14 16:48:13 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int LookUpWndobjs(DCOBJ *pdcoMatch, DCOBJ *pdcoFill, HDC *phdc, int n)
{
    int iMask;
    HDEV hdevMatch;
    int i;

    CHECKUSERCRITIN;

    hdevMatch = pdcoMatch->hdev();
    iMask = 0;
    for (i = 0; i < n; i++)
    {
        pdcoFill->vLock(*phdc);
        if (!pdcoFill->bValid())
        {
            return -1;
        }

        if (pdcoFill->hdev() != hdevMatch)
        {
            pdcoFill->vUnlock();
            *phdc = NULL;
        }
        else
        {
            HWND hwnd;

            if (!UserGetHwnd(*phdc, &hwnd, (PVOID *)phdc, FALSE))
            {
                return -1;
            }
            else
            {
                iMask |= 1 << i;
            }
        }

        phdc++;
        pdcoFill++;
    }

    return iMask;
}

/******************************Public*Routine******************************\
* iMcdExtEscape
*
* Take the MCD special case ExtEscape out of line to minimize the
* impact on other ExtEscapes.  We need to stick special data into the
* input buffer.  No CLIPOBJ is given to the driver here.
*
* History:
*  Tue Jun 21 17:24:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iMcdExtEscape(
    DCOBJ &dco,             //  DC user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    BOOL bSaveSwapEnable;
    KFLOATING_SAVE fsFpState;
    ULONG i;
    int iRet = 0;
    int iMultiMask;
    DCOBJ dcoMulti[MCDESC_MAX_EXTRA_WNDOBJ];

    ASSERTGDI(nEscape == MCDFUNCS, "iMcdExtEscape(): not an MCD escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return iRet;
    }

    // Special processing for 3D-DDI escape.
    //
    // The escape requires that the server fill in the pwo engine object pointer
    // before it is passed to the display driver.  The client side simply
    // doesn't have a clue what this might be.
    // CAUTION: These object are defined here so that they will live long enough
    // to be valid when control is passed to the driver!

    // Grab the devlock and lock down wndobj.

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }
    
    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("iMcdExtEscape(): devlock failed\n");
            return iRet;
        }
    }

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(),
                              (RECTL)dco.erclWindow(),
                              (dlo.bValidWndobj() ? dlo.pwo() : NULL));

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    // Locate the driver entry point.

    if ( !PPFNDRV( pdo, Escape ))
        return( iRet );

    if (pdo.bUMPD())
        return (iRet);

    // If surfaces are passed through the MCDESC_HEADER then lock them
    MCDESC_HEADER *pmeh = (MCDESC_HEADER *)pvIn;
    MCDESC_HEADER_NTPRIVATE *pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh+1);

    PDD_SURFACE_LOCAL psl[2+MCDESC_MAX_LOCK_SURFACES];
    RtlZeroMemory(psl, (2+MCDESC_MAX_LOCK_SURFACES) * sizeof(PDD_SURFACE_LOCAL));

    // First lock standard surfaces
    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (!LockMcdHdrSurfaces(pmeh, &psl[0], &psl[1]))
        {
            return iRet;
        }
    }

    // Now check for extra surfaces
    if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
    {
        HANDLE *phSurf;

        phSurf = pmehPriv->pLockSurfaces;
        for (i = 0; i < pmeh->cLockSurfaces; i++)
        {
            if ((psl[i+2] = EngLockDirectDrawSurface(*phSurf++)) == NULL)
            {
                goto iMcdExtEscape_Unlock_And_Exit;
            }
        }
    }

    // Look up any extra WNDOBJs that need to be looked up
    if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
    {
        iMultiMask = LookUpWndobjs(&dco, dcoMulti, pmehPriv->pExtraWndobj,
                                   pmeh->cExtraWndobj);
        if (iMultiMask < 0)
        {
            goto iMcdExtEscape_Unlock_And_Exit;
        }
    }

// Grow the kernel stack so that OpenGL drivers can use more
// stack than is provided by default.  The call attempts to
// grow the stack to the maximum possible size
// The stack will shrink back automatically so there's no cleanup
// necessary

    if (!NT_SUCCESS(MmGrowKernelStack((BYTE *)PsGetCurrentThreadStackBase()-
                                      KERNEL_LARGE_STACK_SIZE+
                                      KERNEL_LARGE_STACK_COMMIT)))
    {
        WARNING("iMcdExtEscape: Unable to grow stack\n");

        goto iMcdExtEscape_Unlock_And_Exit;
    }

    // Ensure that the stack does not shrink back until we release it.

    bSaveSwapEnable = KeSetKernelStackSwapEnable(FALSE);

// We need to get the WNDOBJ for the driver.  Note that we pass calls
// through to the driver even if we don't yet have a WNDOBJ to allow
// query functions to succeed (before context-creation).  Cursor exclusion
// is not performed in this case, since no drawing is done.

    {
        DEVEXCLUDEWNDOBJ dxoWnd;

        if (dlo.bValidWndobj())
        {
        // Put the DDI pwo pointer in the input buffer.

            PEWNDOBJ pwo;

            pwo = dlo.pwo();

        // If the WNDOBJ is owned by a different surface (as can happen with
        // dynamic mode changes, where the old driver instance lives as long
        // as the WNDOBJ is alive), simply fail the call.

            if (pwo->pto->pSurface != dco.pSurface())
            {
#ifdef OPENGL_MM
            // Under multi-mon the DCOBJ may have the meta-surface while
            // the pto was created with the actual hardware surface.
            // So if the parent hdev of hdev in WNDOBJ is same as hdev in
            // DCOBJ, we will allow to continue since we have replaced
            // meta-PDEV with hardware PDEV. so it's fine.

                PDEVOBJ pdoOfPwo(pwo->pto->pSurface->hdev());

                if (pdoOfPwo.hdevParent() != dco.hdev())
                {
                    WARNING("iMcdExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                    goto iMcdExtEscape_RestoreSwap;
                }
#else
                goto iMcdExtEscape_RestoreSwap;
#endif // OPENGL_MM
            }

            if (pwo->fl & WO_GENERIC_WNDOBJ)
                pwo = (PEWNDOBJ) NULL;

            pmehPriv->pwo = (WNDOBJ *) pwo;

        // Cursor exclusion.
        // Note that we do not early out for empty clip rectangle.

            if (pwo)
            {
                dxoWnd.vExclude(pwo);
                INC_SURF_UNIQ(dco.pSurface());
            }
        }
        else
            pmehPriv->pwo = (WNDOBJ *) NULL;
    }

    // Save floating point state
    // This allows client drivers to do floating point operations
    // If the state were not preserved then we would be corrupting the
    // thread's user-mode FP state

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iMcdExtEscape: Unable to save FP state\n");
        goto iMcdExtEscape_RestoreSwap;
    }

    // Call the driver escape.

    iRet = (int) pdo.Escape(pso,
                            (ULONG)nEscape,
                            (ULONG)cjIn,
                            pvIn,
                            (ULONG)cjOut,
                            pvOut);

    if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
    {
        iRet = (iRet & (0xffffffff >> MCDESC_MAX_EXTRA_WNDOBJ)) |
            (iMultiMask << (32-MCDESC_MAX_EXTRA_WNDOBJ));
    }

    // Restore floating point state and stack swap enable state

    KeRestoreFloatingPointState(&fsFpState);

iMcdExtEscape_RestoreSwap:

    KeSetKernelStackSwapEnable((BOOLEAN)bSaveSwapEnable);

iMcdExtEscape_Unlock_And_Exit:

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (psl[0])
        {
            EngUnlockDirectDrawSurface(psl[0]);
        }

        if (psl[1])
        {
            EngUnlockDirectDrawSurface(psl[1]);
        }
    }

    if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
    {
        for (i = 0; i < pmeh->cLockSurfaces; i++)
        {
            if (psl[i+2])
            {
                EngUnlockDirectDrawSurface(psl[i+2]);
            }
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* iOpenGLExtEscape
*
* Take the OpenGL special case ExtEscape out of line to minimize the
* impact on non-OpenGL ExtEscapes.  We need to stick special data into the
* input buffer.  No CLIPOBJ is given to the driver here.
*
* History:
*  20-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iOpenGLExtEscape(
    DCOBJ &dco,             //  DC user object
      int nEscape,          //  Specifies the escape function to be performed.
      int cjIn,             //  Number of bytes of data pointed to by pvIn
    PVOID pvIn,             //  Points to the input structure required
      int cjOut,            //  Number of bytes of data pointed to by pvOut
    PVOID pvOut             //  Points to the output structure
)
{
    BOOL bSaveSwapEnable;
    KFLOATING_SAVE fsFpState;
    int iRet = 0;
    int iMultiMask;
    DCOBJ dcoMulti[OPENGLCMD_MAXMULTI];

    ASSERTGDI(
        (nEscape == OPENGL_CMD) || (nEscape == OPENGL_GETINFO),
        "iOpenGLExtEscape(): not an OpenGL escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Special processing for OPENGL_CMD escape.
    //
    // The OPENGL_CMD escape may require that the server fill in the pxo and
    // pwo engine object pointers before it is passed to the display driver.
    // The client side simply doesn't have a clue what these might be.
    // CAUTION: These object are defined here so that they will live long enough
    // to be valid when control is passed to the driver!

    EXLATEOBJ xlo;
    XLATEOBJ *pxlo = (XLATEOBJ *) NULL;

    PDEVOBJ po(dco.hdev());
    ASSERTGDI(po.bValid(), "iOpenGLExtEscape(): bad hdev in DC\n");

    // Grab the devlock and user crit section

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }
    
    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("iOpenGLExtEscape(): devlock failed\n");
            return 0;
        }
    }

    // Find a target surface, if DDML.

    PSURFACE pSurface = dco.pSurfaceEff();

#ifdef OPENGL_MM

    if (po.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(),
                              (RECTL)dco.erclWindow(),
                              (dlo.bValidWndobj() ? dlo.pwo() : NULL));

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (po.bPrimary(dco.pSurface()))
            {
                PDEVOBJ poDevice(hdevDevice);

                pSurface = poDevice.pSurface();
            }

            // replace meta pdevobj with device specific hdev.

            po.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    SURFOBJ *pso = pSurface->pSurfobj();

    // Locate the driver entry point.

    if (!PPFNDRV(po, Escape))
        return(0);

    if (po.bUMPD())
        return (0);

    // Create a sprite exclusion object.  Actual exclusion is performed elsewhere
    // as needed.

    DEVEXCLUDEWNDOBJ dxoWnd;
    DEVEXCLUDERECT dxoRect;

    // Grow the kernel stack so that OpenGL drivers can use more
    // stack than is provided by default.  The call attempts to
    // grow the stack to the maximum possible size
    // The stack will shrink back automatically so there's no cleanup
    // necessary

    if (!NT_SUCCESS(MmGrowKernelStack((BYTE *)PsGetCurrentThreadStackBase()-
                                      KERNEL_LARGE_STACK_SIZE+
                                      KERNEL_LARGE_STACK_COMMIT)))
    {
        WARNING("iOpenGLExtEscape: Unable to grow stack\n");
        return 0;
    }

    // Ensure that the stack does not shrink back until we release it.

    bSaveSwapEnable = KeSetKernelStackSwapEnable(FALSE);

    // Save floating point state
    // This allows client drivers to do floating point operations
    // If the state were not preserved then we would be corrupting the
    // thread's user-mode FP state

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iOpenGLExtEscape: Unable to save FP state\n");
        goto iOpenGLExtEscape_RestoreSwap;
    }

    // Handle OPENGL_CMD processing.

    if ( nEscape == OPENGL_CMD )
    {
        ASSERTGDI(sizeof(OPENGLCMD) == sizeof(OPENGLCMDMULTI),
                  "OPENGLCMD doesn't match OPENGLCMDMULTI\n");

    // Better check input size.  We don't want to access violate.

        if (cjIn < sizeof(OPENGLCMD))
        {
            WARNING("iOpenGLExtEscape(): buffer too small\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            goto iOpenGLExtEscape_RestoreState;
        }

        DWORD inBuffer[(sizeof(OPENGLCMD) + 128) / sizeof(DWORD)];
        POPENGLCMD poglcmd;
        POPENGLCMDMULTI pomcmd;

        // Copy pvIn to a private buffer to prevent client process from trashing
        // pwo and pxlo.

        if (cjIn <= sizeof(inBuffer))
        {
            poglcmd = (POPENGLCMD) inBuffer;
        }
        else
        {
            // may affect performance
            WARNING("iOpenGLExtEscape(): big input buffer\n");
            poglcmd = (POPENGLCMD) PALLOCNOZ(cjIn,'lgoG');
            if (!poglcmd)
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                goto iOpenGLExtEscape_RestoreState;
            }
        }

        RtlCopyMemory((PBYTE) poglcmd, (PBYTE) pvIn, cjIn);

        if (poglcmd->fl & OGLCMD_MULTIWNDOBJ)
        {
            pomcmd = (POPENGLCMDMULTI)poglcmd;

            if (pomcmd->cMulti > OPENGLCMD_MAXMULTI ||
                (DWORD)cjIn < sizeof(OPENGLCMDMULTI)+pomcmd->cMulti*
                sizeof(HDC))
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                goto oglcmd_cleanup;
            }

            iMultiMask = LookUpWndobjs(&dco, dcoMulti, (HDC *)(poglcmd+1),
                                       pomcmd->cMulti);
            if (iMultiMask < 0)
            {
                goto oglcmd_cleanup;
            }
        }

        if ( poglcmd->fl & OGLCMD_NEEDXLATEOBJ )
        {
            switch (po.iDitherFormat())
            {
            case BMF_4BPP:
            case BMF_8BPP:
                {
                    XEPALOBJ pal(dco.ppal());

                    if ( pal.bValid() )
                    {
                        COUNT cColors = (po.iDitherFormat() == BMF_4BPP) ? 16 : 256;
                        USHORT aus[256];

                        for (COUNT ii = 0; ii < cColors; ii++)
                            aus[ii] = (USHORT) ii;

#ifdef OPENGL_MM
                        if ( xlo.bMakeXlate(aus, pal, pSurface, cColors, cColors) )
#else
                        if ( xlo.bMakeXlate(aus, pal, dco.pSurfaceEff(), cColors, cColors) )
#endif // OPENGL_MM

                            pxlo = (XLATEOBJ *) xlo.pxlo();
                    }

                    if (!pxlo)
                        pxlo = &xloIdent;
                }
                break;

            default:
                pxlo = &xloIdent;
                break;
            }
        }

        // Write the XLATOBJ into the correct places in the input structure.

        poglcmd->pxo = pxlo;

        // May need to get the WNDOBJ for the driver.

        if ((poglcmd->fl & OGLCMD_MULTIWNDOBJ) == 0)
        {
            if (poglcmd->fl & OGLCMD_NEEDWNDOBJ)
            {
                if (!dlo.bValidWndobj() || dlo.pwo()->fl & WO_GENERIC_WNDOBJ)
                {
                    WARNING("iOpenGLExtEscape(): invalid WNDOBJ\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                    goto oglcmd_cleanup;
                }

            // If the WNDOBJ is owned by a different surface (as can happen with
            // dynamic mode changes, where the old driver instance lives as long
            // as the WNDOBJ is alive), simply fail the call.

                if (dlo.pwo()->pto->pSurface != dco.pSurface())
                {
#ifdef OPENGL_MM
                // Under multi-mon the DCOBJ may have the meta-surface while
                // the pto was created with the actual hardware surface.
                // So if the parent hdev of hdev in WNDOBJ is same as hdev in
                // DCOBJ, we will allow to continue since we have replaced
                // meta-PDEV with hardware PDEV. so it's fine.

                    PDEVOBJ pdoOfPwo(dlo.pwo()->pto->pSurface->hdev());

                    if (pdoOfPwo.hdevParent() != dco.hdev())
                    {
                        WARNING("iOpenGLExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                        goto oglcmd_cleanup;
                    }
#else
                    goto oglcmd_cleanup;
#endif // OPENGL_MM
                }

                poglcmd->pwo = (WNDOBJ *)dlo.pwo();
            }
            else
            {
                poglcmd->pwo = (WNDOBJ *)NULL;
            }
        }

        // Cursor exclusion.

        if (dlo.bValidWndobj())
        {
            // If the driver's WNDOBJ knows about sprites, we assume the driver
            // will take of exclusion.

            if (!(dlo.pwo()->fl & WO_SPRITE_NOTIFY))
            {
                dxoWnd.vExclude(dlo.pwo());
            }
            INC_SURF_UNIQ(dco.pSurface());
        }
        else
        {
            ERECTL ercl(dco.prgnEffRao()->rcl);
            ECLIPOBJ co(dco.prgnEffRao(), ercl, FALSE);

            dxoRect.vExclude(dco.hdev(), &co.erclExclude());
            INC_SURF_UNIQ(dco.pSurface());
        }

        iRet = (int) po.Escape(pso,
                                    (ULONG)nEscape,
                                    (ULONG)cjIn,
                                    (PVOID)poglcmd,
                                    (ULONG)cjOut,
                                    pvOut);
        if (poglcmd->fl & OGLCMD_MULTIWNDOBJ)
        {
            iRet = (iRet & (0xffffffff >> OPENGLCMD_MAXMULTI)) |
                (iMultiMask << (32-OPENGLCMD_MAXMULTI));
        }

    oglcmd_cleanup:
        if (cjIn > sizeof(inBuffer))
            VFREEMEM(poglcmd);
    } // if ( nEscape == OPENGL_CMD )
    else
    {
        // Handle OPENGL_GETINFO processing.

        iRet = ((int) po.Escape(pso,
                                (ULONG)nEscape,
                                (ULONG)cjIn,
                                pvIn,
                                (ULONG)cjOut,
                                pvOut));
    }

// Restore floating point state

iOpenGLExtEscape_RestoreState:
    KeRestoreFloatingPointState(&fsFpState);

iOpenGLExtEscape_RestoreSwap:
    KeSetKernelStackSwapEnable((BOOLEAN)bSaveSwapEnable);

    return iRet;
}

/******************************Public*Routine******************************\
* iCheckPassthroughImage
*
* Implements the CHECKJPEGFORMAT and CHECKPNGFORMAT escapes on behalf of
* the driver.  Converts the escape into a call to DrvQueryDriverSupport
* which can pass objects such as XLATEOBJ to the driver that DrvEscape
* does not have.
*
* These escapes are used to validate images with the device so that
* they can later be sent directly (passthrough) to the device.
*
* Returns:
*   QUERYESCSUPPORT returns 1 if escape supported, 0 otherwise.
*   CHECKJPEGFORMAT/CHECKPNGFORMAT returns 1 if image supported, 0 if not
*   supported, and -1 if error.
*
* History:
*  14-Oct-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iCheckPassthroughImage(
    DCOBJ &dco,             //  DC user object
  PDEVOBJ &pdo,             //  PDEV user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    int iRet = 0;           // not supported

    if (nEscape == QUERYESCSUPPORT)
    {
        ASSERTGDI((*(ULONG*)pvIn == CHECKJPEGFORMAT) ||
                  (*(ULONG*)pvIn == CHECKPNGFORMAT),
                  "iCheckPassthroughImage: unknown escape\n");

        if (*(ULONG*)pvIn == CHECKJPEGFORMAT)
        {
            // Escape is supported if driver has JPEG support.

            if (dco.bSupportsJPEG() &&
                (PPFNVALID(pdo, QueryDeviceSupport)))
            {
                iRet = 1;
            }
        }
        else
        {
            // Escape is supported if driver has PNG support.

            if (dco.bSupportsPNG() &&
                (PPFNVALID(pdo, QueryDeviceSupport)))
            {
                iRet = 1;
            }
        }
    }
    else if (PPFNVALID(pdo, QueryDeviceSupport))
    {
        ASSERTGDI((nEscape == CHECKJPEGFORMAT) || (nEscape == CHECKPNGFORMAT),
                  "iCheckPassthroughImage: unknown escape\n");

        if ((cjOut >= sizeof(ULONG)) && pvOut)
        {
            // There is no surface in metafile DCs.  In addition, some
            // apps call printing escape before the StartDoc, also
            // resulting in no real surface in DC.
            //
            // The XLATEOBJ generated in this way may not be valid except
            // for the ICM information (which is all this escape cares
            // about in the XLATEOBJ anyway).

            XEPALOBJ  palDest(dco.pSurface() ? dco.pSurface()->ppal() : NULL);
            XEPALOBJ  palDestDC(dco.ppal());
            PALMEMOBJ palTemp;
            XLATEOBJ *pxlo = NULL;
            EXLATEOBJ xlo;

            // Create the XLATEOBJ so driver can determine the ICM state.

            if (((nEscape == CHECKJPEGFORMAT) && dco.bSupportsJPEG()) ||
                ((nEscape == CHECKPNGFORMAT ) && dco.bSupportsPNG()))
            {
                if (palTemp.bCreatePalette(PAL_BGR, 0, (PULONG) NULL,
                                            0, 0, 0, PAL_FIXED))
                {
                    if (xlo.pInitXlateNoCache(dco.pdc->hcmXform(),
                                              dco.pdc->lIcmMode(),
                                              palTemp,
                                              palDest,
                                              palDestDC,
                                              0,
                                              0,
                                              0x00FFFFFF))
                    {
                        pxlo = xlo.pxlo();
                    }
                    else
                    {
                        WARNING("ExtEscape(CHECKJPEGFORMAT/CHECKPNGFORMAT): "
                                "failed pxlo creation\n");

                        iRet = -1;  // error
                    }
                }
            }

            // If XLATEOBJ created, call DrvQueryDriverSupport to validate
            // the image.

            if (pxlo)
            {
                // There is no surface in metafile DCs.  In addition, some
                // apps call printing escape before the StartDoc, also
                // resulting in no real surface in DC.
                //
                // We fake up a rather poor one here if we need it.  The
                // device driver may only dereference the dhpdev from this!

                SURFOBJ soFake;
                SURFOBJ *pso = dco.pSurface()->pSurfobj();

                if (pso == (SURFOBJ *) NULL)
                {
                    RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
                    soFake.dhpdev = dco.dhpdev();
                    soFake.hdev   = dco.hdev();
                    soFake.iType  = (USHORT)STYPE_DEVICE;
                    pso = &soFake;
                }

                // Call the Driver.

                *(ULONG *)pvOut = PPFNDRV(pdo,QueryDeviceSupport)
                                            (pso,
                                             pxlo,
                                             (XFORMOBJ *) NULL,
                                             (nEscape == CHECKJPEGFORMAT)
                                                ? QDS_CHECKJPEGFORMAT
                                                : QDS_CHECKPNGFORMAT,
                                             (ULONG) cjIn,
                                             pvIn,
                                             (ULONG) cjOut,
                                             pvOut) ? 1 : 0;

                iRet = 1;
            }
        }
        else
        {
            WARNING("ExtEscape(CHECKJPEGFORMAT/CHECKPNGFORMAT): "
                    "invalid output buffer\n");

            iRet = -1;  // error
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GreExtEscape                                                             *
*                                                                          *
* GreExtEscape() allows applications to access facilities of a particular  *
* device that are not directly available through GDI.  GreExtEscape calls  *
* made by an application are translated and sent to the device driver.     *
*                                                                          *
* Returns                                                                  *
*                                                                          *
*     The return value specifies the outcome of the function.  It is       *
*     positive if the function is successful except for the                *
*     QUERYESCSUPPORT escape, which only checks for implementation.        *
*     The return value is zero if the escape is not implemented.           *
*     A negative value indicates an error.                                 *
*     The following list shows common error values:                        *
*                                                                          *
*                                                                          *
*   Value           Meaning                                                *
*                                                                          *
*   SP_ERROR        General error.                                         *
*                                                                          *
*   SP_OUTOFDISK    Not enough disk space is currently                     *
*                   available for spooling, and no more                    *
*                   space will become available.                           *
*                                                                          *
*                                                                          *
*   SP_OUTOFMEMORY  Not enough memory is available for                     *
*                   spooling.                                              *
*                                                                          *
*                                                                          *
*   SP_USERABORT    User terminated the job through the                    *
*                   Print Manager.                                         *
*                                                                          *
*                                                                          *
*  COMMENTS                                                                *
*                                                                          *
*  [1] I assume that if we pass to the driver an Escape number that        *
*      it does not support, the driver will handle it gracefully.          *
*      No checks are done in the Engine.                                   *
*                                                         [koo 02/13/91].  *
*  [2] The cast on pso may seem redundant.  However if you                 *
*      try it without the (PSURFOBJ) cast, you will find                   *
*      that cFront objects.  The reason for this is beyond                 *
*      my understanding of C++.                                            *
*                                                                          *
* History:                                                                 *
*  Fri 07-May-1993 14:58:39 -by- Charles Whitmer [chuckwh]                 *
* Added the font management escapes.  Made it copy the ATTRCACHE.          *
*                                                                          *
*  Fri 03-Apr-1992  Wendy Wu [wendywu]                                     *
* Old escapes are now mapped to GDI functions on the client side.          *
*                                                                          *
*  Fri 14-Feb-1992  Dave Snipp                                             *
* Added output buffer size. This is calculated on the client and passed to *
* us in the message                                                        *
*                                                                          *
*  Wed 13-Feb-1991 09:17:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreExtEscape(
      HDC hDC,        //  Identifies the device context.
      int iEscape,    //  Specifies the escape function to be performed.
      int cjIn,       //  Number of bytes of data pointed to by pvIn.
    LPSTR pvIn,       //  Points to the input data.
      int cjOut,      //  Number of bytes of data pointed to by pvOut.
    LPSTR pvOut       //  Points to the structure to receive output.
)
{
    // Locate the surface.

    DCOBJ dco(hDC);

    if (!dco.bValid())
        return(0);

    // PDEVs that have been marked by USER for deletion cannot have escapes
    // going down to them.

    PDEVOBJ pdo(dco.hdev());
    if (pdo.bDeleted())
        return(0);

#if TEXTURE_DEMO
    if (iEscape == 0x031898)
    {
        return(TexTexture(pvIn, cjIn));
    }

    if ((cjIn >= 4) && (pvIn != NULL) && (iEscape == 0x031899))
    {
        return((int) hdcTexture(*(ULONG*) pvIn));
    }
#endif

    // We are responsible for not faulting on any call that we handle.
    // (As are all drivers below us!)  Since we handle QUERYESCSUPPORT, we'd
    // better verify the length.  [chuckwh]

    ////////////////////////////////////////////////////////////////////////
    // NOTE: If you add more private escape routines, you MUST acquire the
    //       DEVLOCK before calling the driver's DrvEscape routine, to allow
    //       for dynamic mode changing.

    // First, get the driver capable override info
    DWORD   dwOverride = pdo.dwDriverCapableOverride();

    if ((iEscape == QUERYESCSUPPORT) && (((ULONG)cjIn) < 4))
    {
        return(0);
    }
    else if ( (iEscape == QUERYESCSUPPORT)
            &&(  (*(ULONG*)pvIn == OPENGL_GETINFO)
               ||(*(ULONG*)pvIn == OPENGL_CMD)
               ||(*(ULONG*)pvIn == MCDFUNCS) )
            &&(dwOverride & DRIVER_NOT_CAPABLE_OPENGL) )
    {
        return (0);
    }
    else if ( (iEscape == OPENGL_CMD) || (iEscape == OPENGL_GETINFO) )
    {
        // If the driver is not capable of doing OpenGL, just return
        if ( (dwOverride & DRIVER_NOT_CAPABLE_OPENGL)
          || (dco.dctp() != DCTYPE_DIRECT) )
            return 0;

        return iOpenGLExtEscape(dco, iEscape, cjIn, pvIn, cjOut, pvOut);
    }
    else if (iEscape == MCDFUNCS)
    {
        // Don't allow the MCD to be started up on device bitmaps.
        // If the driver is not capable of doing OpenGL, just return
        if ( (dwOverride & DRIVER_NOT_CAPABLE_OPENGL)
          || (dco.dctp() != DCTYPE_DIRECT) )
            return 0;

        DWORD inBuffer[((sizeof(MCDESC_HEADER) +
                         sizeof(MCDESC_HEADER_NTPRIVATE)) /
                        sizeof(DWORD))];
        HANDLE hLockSurfaces[MCDESC_MAX_LOCK_SURFACES];
        HDC hdcExtraWndobj[MCDESC_MAX_EXTRA_WNDOBJ];
        MCDESC_HEADER *pmeh = (MCDESC_HEADER *)inBuffer;
        MCDESC_HEADER_NTPRIVATE *pmehPriv;
        BYTE *pbCmd;

        // MCD escape protocol involves an
        // MCDESC_HEADER + MCDESC_HEADER_NTPRIVATE structure sent via
        // the escape.
        //
        // If there is shared memory, then the entire command is described
        // in the MCDESC_HEADER.  Otherwise, the pBuffer field of the
        // MCDESC_HEADER_NTPRIVATE
        // structure is set to point to the command structure.

        if (cjIn >= sizeof(MCDESC_HEADER))
        {
            RtlCopyMemory(pmeh,pvIn,sizeof(*pmeh));
            pbCmd = (BYTE *)pvIn+sizeof(MCDESC_HEADER);
            cjIn -= sizeof(MCDESC_HEADER);
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return 0;
        }

        pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh+1);

        // If MCDESC_FL_LOCK_SURFACES is set, the cLockSurfaces field indicates
        // the number of trailing surface handles for locking
        if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
        {
            int cb;

            if ((pmeh->cLockSurfaces <= MCDESC_MAX_LOCK_SURFACES) &&
                ((cb = sizeof(HANDLE)*pmeh->cLockSurfaces) <= cjIn))
            {
                RtlCopyMemory(hLockSurfaces, pbCmd, cb);
                pmehPriv->pLockSurfaces = hLockSurfaces;
                pbCmd += cb;
                cjIn -= cb;
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return 0;
            }
        }
        else
        {
            pmehPriv->pLockSurfaces = NULL;
        }

        // If MCDESC_FL_EXTRA_WNDOBJ is set, the cExtraWndobj field indicates
        // the number of trailing HDCs to find WNDOBJs for.
        if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
        {
            int cb;

            if ((pmeh->cExtraWndobj <= MCDESC_MAX_EXTRA_WNDOBJ) &&
                ((cb = sizeof(HDC)*pmeh->cExtraWndobj) <= cjIn))
            {
                RtlCopyMemory(hdcExtraWndobj, pbCmd, cb);
                pmehPriv->pExtraWndobj = hdcExtraWndobj;
                pbCmd += cb;
                cjIn -= cb;
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return 0;
            }
        }
        else
        {
            pmehPriv->pExtraWndobj = NULL;
        }

        if (!pmeh->hSharedMem)
        {
            pmehPriv->pBuffer = (VOID *)pbCmd;
            pmehPriv->bufferSize = cjIn;
        }
        else
        {
            pmehPriv->pBuffer = (VOID *)NULL;
            pmehPriv->bufferSize = 0;
        }

        if (pmeh->flags & MCDESC_FL_CREATE_CONTEXT)
        {
            return iMcdSetupExtEscape(dco, iEscape, sizeof(inBuffer), inBuffer,
                                      cjOut, pvOut);
        }
        else
        {
            return iMcdExtEscape(dco, iEscape, sizeof(inBuffer), inBuffer,
                                 cjOut, pvOut);
        }
    }
    else if (iEscape == WNDOBJ_SETUP)
    {
        if (dco.dctp() != DCTYPE_DIRECT)
            return 0;

        return iWndObjSetupExtEscape(dco, iEscape, cjIn, pvIn, cjOut, pvOut);
    }
    else if (iEscape == DCICOMMAND)
    {
        return (0);
    }

    // Acquire the DEVLOCK to protect against dynamic mode changes.  We still
    // let escapes down if we're in full-screen mode, though.

    DEVLOCKOBJ dlo;

    dlo.vLockNoDrawing(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }

    // Make sure that a driver can't be called with an escape on a DIB bitmap
    // that it obviously won't own.

    if (dco.dctp() != DCTYPE_DIRECT)
    {
        if (!dco.bPrinter())
        {
            if ((dco.pSurface() == NULL) ||
                (dco.pSurface()->iType() != STYPE_DEVBITMAP))
            {
                return(0);
            }
        }
        else
        {
            // Have to be careful with the printer case since there is no
            // surface if metafile or escape called before StartDoc.  Only
            // reject if surface exists and does not match device.

            if ((dco.pSurface() != NULL) &&
                (dco.pSurface()->dhpdev() != pdo.dhpdev())
               )
            {
                return(0);
            }
        }
    }

    DRAWPATRECTP PatternRect;
    EXFORMOBJ   exo;

    // Adjust DRAWPATTERNRECT for banding

    if (iEscape == DRAWPATTERNRECT)
    {
        if (pdo.flGraphicsCaps() & GCAPS_NUP)
        {
            exo.vQuickInit(dco, WORLD_TO_DEVICE);

            //
            // If app passes us the wrong size return failure.
            // Note: wow always fix up 16bit DRAWPATRECT to 32bit
            // version.
            //
            if (cjIn != sizeof(DRAWPATRECT))
            {
                WARNING(" we are passed in a bad cjIn for DRAWPATTERNRECT\n");
                return (0);
            }
            else
            {
               PatternRect.DrawPatRect = *(DRAWPATRECT *) pvIn;
               PatternRect.pXformObj = (XFORMOBJ *) (PVOID) &exo;

               pvIn = (LPSTR)&PatternRect;

               cjIn = sizeof(DRAWPATRECTP);
            }
        }

        if (dco.pSurface() && (dco.pSurface())->bBanding())
        {
            if ((cjIn == sizeof(DRAWPATRECT)) || (pdo.flGraphicsCaps() & GCAPS_NUP))
            {
                DRAWPATRECT *pPatternRect = (DRAWPATRECT *) pvIn;

                // convert position to band coords from page coords.

                pPatternRect->ptPosition.x -= (dco.ptlPrintBandPos().x);
                pPatternRect->ptPosition.y -= (dco.ptlPrintBandPos().y);
            }
            else
            {
                WARNING("GreExtEscape():DRAWPATRECT - cjIn != sizeof(DRAWPATRECT)\n");

                // we don't fail, let driver effort for this.
            }
        }

    }

    // Pass the calls that require a FONTOBJ off to DoFontManagement.

    if ( ((iEscape >= 0x100) && (iEscape < 0x3FF)) ||
            ((iEscape == QUERYESCSUPPORT) &&
             ((*(ULONG*)pvIn >= 0x100) && (*(ULONG*)pvIn < 0x3FF))) )
    {
        return ( (int) DoFontManagement(dco,
                                        iEscape,
                                        (ULONG) cjIn,
                                        (PVOID) pvIn,
                                        (ULONG) cjOut,
                                        (PVOID) pvOut));
    }

    // Handle device compressed image passthrough support (JPEG or PNG images)

    if ( (iEscape == CHECKJPEGFORMAT) || (iEscape == CHECKPNGFORMAT) ||
         ((iEscape == QUERYESCSUPPORT) &&
          ((*(ULONG*)pvIn == CHECKJPEGFORMAT) ||
           (*(ULONG*)pvIn == CHECKPNGFORMAT ))
         )
       )
    {
        return ( iCheckPassthroughImage(dco,
                            pdo,
                            iEscape,
                            (ULONG) cjIn,
                            (PVOID) pvIn,
                            (ULONG) cjOut,
                            (PVOID) pvOut));
    }

    // Inc the target surface for output calls with a valid surface.

    if (dco.bValidSurf() && (pvOut == (LPSTR) NULL))
    {
        INC_SURF_UNIQ(dco.pSurface());
    }

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

    // Handle OpenGL - QUERYSUPPORT escape with multimon system

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        if ( (iEscape == QUERYESCSUPPORT) &&
             ((*(ULONG *) pvIn == OPENGL_GETINFO) ||
              (*(ULONG *) pvIn == OPENGL_CMD)     ||
              (*(ULONG *) pvIn == MCDFUNCS)
             )
           )
        {

        // We need to change the meta-PDEV into a hardware specific PDEV

            HDEV hdevDevice = hdevFindDeviceHdev(
                                  dco.hdev(),
                                  (RECTL)dco.erclWindow(),
                                  NULL);

            if (hdevDevice)
            {
                // If the surface is pdev's primary surface, we will replace it with
                // new device pdev's surface.

                if (pdo.bPrimary(dco.pSurface()))
                {
                    PDEVOBJ pdoDevice(hdevDevice);

                    pso = pdoDevice.pSurface()->pSurfobj();
                }

                // replace meta pdevobj with device specific hdev.

                pdo.vInit(hdevDevice);
            }
        }
    }

#endif // OPENGL_MM

    // Locate the driver entry point.

    if (!PPFNDRV(pdo, Escape))
        return(0);

    // There is no surface in metafile DCs.  In addition,
    // it is unfortunate that apps call some printing escapes before
    // doing a StartDoc, so there is no real surface in the DC.
    // We fake up a rather poor one here if we need it.  The device
    // driver may only dereference the dhpdev from this!

    SURFOBJ soFake;

    if (pso == (SURFOBJ *) NULL)
    {
        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
        soFake.dhpdev = dco.dhpdev();
        soFake.hdev   = dco.hdev();
        soFake.iType  = (USHORT)STYPE_DEVICE;
        pso = &soFake;

        // Special case SETCOPYCOUNT if we havn't done a startdoc yet

        if ((iEscape == SETCOPYCOUNT) && (cjIn >= sizeof(USHORT)))
        {
            // let's remember the call in the dc and wait for start doc
            // since if there is no hardware support, we can simulate it
            // when EMF spooling case.

            dco.ulCopyCount((ULONG)(*(PUSHORT)pvIn));

            // check if the driver supports it and let him fill in the actual
            // size in the return buffer.

            pdo.Escape(pso,iEscape,cjIn,pvIn,cjOut,pvOut);

            // always behaves as success, since EMF spooling can simulate it.

            return(1);
        }

        // Special case post scripts EPS_PRINTING if we havn't done a startdoc yet

        if ((iEscape == EPSPRINTING) && (cjIn >= sizeof(USHORT)))
        {
            // yes, lets remember the call in the dc and wait for start doc

            if ((BOOL)*(PUSHORT)pvIn)
                dco.vSetEpsPrintingEscape();
            else
                dco.vClearEpsPrintingEscape();

            return(1);
        }
    }

    // Call the Driver.

    int iRes;

    iRes = (int) pdo.Escape(pso,
                        (ULONG) iEscape,
                        (ULONG) cjIn,
                        pvIn,
                        (ULONG) cjOut,
                        pvOut);

    return(iRes);
}

/******************************Public*Routine******************************\
* GreDrawEscape
*
* History:
*  07-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int APIENTRY GreDrawEscape(
     HDC hdc,          //  Identifies the device context.
     int nEscape,      //  Specifies the escape function to be performed.
     int cjIn,         //  Number of bytes of data pointed to by lpIn
    PSTR pstrIn        //  Points to the input structure required
)
{
    LONG  lRet = 0;
    DCOBJ dco(hdc);

    //
    // The DC must be valid and also the surface must be valid in order
    // for the driver to be called
    //

    if ((dco.bValid()) && (dco.bHasSurface()) && (!dco.pdc->bDIBSection()))
    {
        //
        // We are responsible for not faulting on any call that we handle.
        // (As are all drivers below us!)  Since we handle QUERYESCSUPPORT, we'd
        // better verify the length.
        //

        if ((nEscape == QUERYESCSUPPORT) && (((ULONG) cjIn) < 4))
        {
            return(0);
        }

        //
        // see if the device supports it
        //

        PDEVOBJ pdo(dco.hdev());

        //
        // Lock the surface and the Rao region, ensure VisRgn up to date.
        //

        DEVLOCKOBJ dlo(dco);

        PFN_DrvDrawEscape pfnDrvDrawEscape = PPFNDRV(pdo, DrawEscape);

        if (pfnDrvDrawEscape != NULL)
        {
            //
            // if it is query escape support, get out early
            //

            if (nEscape == QUERYESCSUPPORT)
            {
                lRet = (int)(*pfnDrvDrawEscape)(dco.pSurface()->pSurfobj(),
                                       (ULONG)nEscape,
                                       (CLIPOBJ *)NULL,
                                       (RECTL *)NULL,
                                       (ULONG)cjIn,
                                       (PVOID)pstrIn);
            }
            else
            {
                if (!dlo.bValid())
                {
                    lRet = (int)dco.bFullScreen();
                }
                else
                {
                    ERECTL ercl = dco.erclWindow();

                    ECLIPOBJ co(dco.prgnEffRao(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        lRet = (int)TRUE;
                    }
                    else
                    {
                        //
                        // Exclude any sprites.
                        //

                        DEVEXCLUDERECT dxoRect(dco.hdev(), &ercl);

                        //
                        // Inc the target surface uniqueness
                        //

                        INC_SURF_UNIQ(dco.pSurface());

                        lRet = (int)(*pfnDrvDrawEscape)(dco.pSurface()->pSurfobj(),
                                               (ULONG)nEscape,
                                               (CLIPOBJ *)&co,
                                               (RECTL *)&ercl,
                                               (ULONG)cjIn,
                                               (PVOID)pstrIn);
                    }
                }
            }
        }
    }

    return(lRet);
}

/******************************Public*Routine******************************\
* int APIENTRY GreStartDoc(HDC hdc, DOCINFOW *pDocInfo,BOOL *pbBanding)
*
* Arguments:
*
*   hdc        - handle to device context
*   pdi        - DOCINFO of output names
*   pbBanding  - return banding flag
*
* Return Value:
*
*   if successful return job identifier, else SP_ERROR
*
* History:
*  Wed 08-Apr-1992 -by- Patrick Haluptzok [patrickh]
* lazy surface enable, journal support, remove unnecesary validation.
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

int APIENTRY GreStartDocInternal(
         HDC  hdc,
    DOCINFOW *pDocInfo,
        BOOL *pbBanding,
        INT  iDocJob
)
{
    int iRet = 0;
    int iJob;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Check that this is a printer surface.
        //

        if ((!po.bDisplayPDEV())          &&
            (po.hSpooler())               &&
            (dco.dctp() == DCTYPE_DIRECT) &&
            (!dco.bHasSurface()))
        {
            // We now try and open the printer up in journal mode.  If we fail
            // then we try and open it up in raw mode.  If that fails we fail call.

            if (!po.bUMPD())
            {

               #define MAX_DOCINFO_DATA_TYPE 80
               DOC_INFO_1W DocInfo;
               WCHAR awchDatatype[MAX_DOCINFO_DATA_TYPE];

               DocInfo.pDocName = (LPWSTR)pDocInfo->lpszDocName;
               DocInfo.pOutputFile = (LPWSTR)pDocInfo->lpszOutput;
               DocInfo.pDatatype = NULL;

               // see if the driver wants to define its own data type.  If it does,
               // first fill the buffer in with the type requested by the app

               if (PPFNVALID(po, QuerySpoolType))
               {
                   awchDatatype[0] = 0;

                   // did the app specify a data type and will it fit in our buffer

                   if (pDocInfo->lpszDatatype)
                   {
                       int cjStr = (wcslen(pDocInfo->lpszDatatype) + 1) * sizeof(WCHAR);

                       if (cjStr < (MAX_DOCINFO_DATA_TYPE * sizeof(WCHAR)))
                       {
                           RtlCopyMemory((PVOID)awchDatatype,(PVOID)pDocInfo->lpszDatatype,cjStr);
                       }
                   }

                   if ((*PPFNDRV(po, QuerySpoolType))(po.dhpdev(), awchDatatype))
                   {
                       DocInfo.pDatatype = awchDatatype;
                   }
               }

               // open up the document


               iJob = (BOOL)StartDocPrinterW(po.hSpooler(), 1, (LPBYTE)&DocInfo);

               if (iJob <= 0)
               {
                   WARNING("ERROR GreStartDoc failed StartDocPrinter Raw Mode\n");
                   return(iJob);
               }
            }
            else
            {
                // if it is UMPD, StartDocPrinter has been called in user mode already
                iJob = iDocJob;
            }

            // Lazy surface creation happens now.

            if (po.bMakeSurface())
            {
                *pbBanding = (po.pSurface())->bBanding();

                // Put the surface into the DC.

                dco.pdc->pSurface(po.pSurface());

                if ( *pbBanding )
                {
                // if banding set Clip rectangle to size of band

                    dco.pdc->sizl((po.pSurface())->sizl());
                    dco.pdc->bSetDefaultRegion();
                }

                BOOL bSucceed = FALSE;

                PFN_DrvStartDoc pfnDrvStartDoc = PPFNDRV(po, StartDoc);

                bSucceed = (*pfnDrvStartDoc)(po.pSurface()->pSurfobj(),
                                             (PWSTR)pDocInfo->lpszDocName,
                                             iJob);

                // now, if a SETCOPYCOUNT escape has come through, send it down

                if (dco.ulCopyCount() != (ULONG)-1)
                {
                    ULONG ulCopyCount = dco.ulCopyCount();

                    GreExtEscape(hdc,SETCOPYCOUNT,sizeof(DWORD),
                                 (LPSTR)&ulCopyCount,0,NULL);

                    dco.ulCopyCount((ULONG)-1);
                }

                // now, if a EPSPRINTING escape has come through, send it down

                if (dco.bEpsPrintingEscape())
                {
                    SHORT b = 1;

                    GreExtEscape(hdc,EPSPRINTING,sizeof(b),(LPSTR)&b,0,NULL);

                    dco.vClearEpsPrintingEscape();
                }

                if (bSucceed)
                {
                    iRet = iJob;
                    dco.vSetSaveDepthStartDoc();
                }
            }
        }
        if (!iRet)
        {
            AbortPrinter(po.hSpooler());
        }
    }

    return iRet;
}

/****************************************************************************
*  NtGdiSetLinkedUFIs
*
*  History:
*   12/16/1996 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

#define QUICK_LINKS   4

extern "C" BOOL NtGdiSetLinkedUFIs(
                   HDC hdc,
    PUNIVERSAL_FONT_ID pufiLinks,
                 ULONG uNumUFIs
)
{
    BOOL bRet = TRUE;
    UNIVERSAL_FONT_ID pufiQuickLinks[QUICK_LINKS];
    PUNIVERSAL_FONT_ID pufi = NULL;

    if (!pufiLinks && uNumUFIs)
        return FALSE;
        
    if (uNumUFIs > QUICK_LINKS)
    {
        if (!BALLOC_OVERFLOW1(uNumUFIs,UNIVERSAL_FONT_ID))
        {
            pufi = (PUNIVERSAL_FONT_ID)
              PALLOCNOZ(uNumUFIs * sizeof(UNIVERSAL_FONT_ID),'difG');
        }

        if (pufi == NULL)
        {
            WARNING("NtGdiSetLinkedUFIs: out of memory\n");
            return(FALSE);
        }
    }
    else
    {
        pufi = pufiQuickLinks;
    }

    __try
    {
        if (pufiLinks)
        {
            ProbeForRead(pufiLinks,
                          sizeof(UNIVERSAL_FONT_ID)*uNumUFIs,
                          sizeof(DWORD) );
            RtlCopyMemory(pufi,pufiLinks,
                          sizeof(UNIVERSAL_FONT_ID)*uNumUFIs);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(106);
        bRet = FALSE;
    }

    if (bRet)
    {
        XDCOBJ dco(hdc);

        if (dco.bValid())
        {
            bRet = dco.bSetLinkedUFIs(pufi, uNumUFIs);
            dco.vUnlockFast();
        }
    }

    if (pufi != pufiQuickLinks)
    {
        VFREEMEM(pufi);
    }
    return(bRet);
}

int APIENTRY NtGdiStartDoc(
         HDC  hdc,
    DOCINFOW *pdi,
        BOOL *pbBanding,
        INT  iJob
)
{
    int iRet = 0;
    BOOL bkmBanding;
    DOCINFOW  kmDocInfo;
    ULONG cjStr;
    BOOL bStatus = TRUE;

    kmDocInfo.cbSize = 0;
    kmDocInfo.lpszDocName  = NULL;
    kmDocInfo.lpszOutput   = NULL;
    kmDocInfo.lpszDatatype = NULL;

    //DbgPrint ("NtGdiStartDoc\n");

    if (pdi != (DOCINFOW *)NULL)
    {
        __try
        {
            LPCWSTR lpszDocName;
            LPCWSTR lpszOutput;
            LPCWSTR lpszDatatype;

            ProbeForRead(pdi,sizeof(DOCINFOW),sizeof(ULONG));

            kmDocInfo.cbSize = pdi->cbSize;
            lpszDocName      = pdi->lpszDocName;
            lpszOutput       = pdi->lpszOutput;
            lpszDatatype     = pdi->lpszDatatype;

            if (lpszDocName != NULL)
            {
                cjStr = (wcslensafe(lpszDocName) + 1) * sizeof(WCHAR);
                kmDocInfo.lpszDocName = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');
                if (kmDocInfo.lpszDocName == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    ProbeForRead(lpszDocName,cjStr,sizeof(WCHAR));
                    RtlCopyMemory((PVOID)kmDocInfo.lpszDocName,(PVOID)lpszDocName,cjStr);

                    // Guarantee NULL termination of string.
                    ((WCHAR *)kmDocInfo.lpszDocName)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                }
            }

            if (lpszOutput != NULL)
            {
                cjStr = (wcslensafe(lpszOutput) + 1) * sizeof(WCHAR);
                kmDocInfo.lpszOutput = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');
                if (kmDocInfo.lpszOutput == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    ProbeForRead(lpszOutput,cjStr,sizeof(WCHAR));
                    RtlCopyMemory((PVOID)kmDocInfo.lpszOutput,(PVOID)lpszOutput,cjStr);

                    // Guarantee NULL termination of string.
                    ((WCHAR *)kmDocInfo.lpszOutput)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                }
            }

            // does it contain the new Win95 fields

            if ((kmDocInfo.cbSize >= sizeof(DOCINFOW)) && (lpszDatatype != NULL))
            {
                __try
                {
                    cjStr = (wcslensafe(lpszDatatype) + 1) * sizeof(WCHAR);

                    ProbeForRead(lpszDatatype,cjStr,sizeof(WCHAR));
                    kmDocInfo.lpszDatatype = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');

                    if (kmDocInfo.lpszDatatype == NULL)
                    {
                        bStatus = FALSE;
                    }
                    else
                    {
                        RtlCopyMemory((PVOID)kmDocInfo.lpszDatatype,(PVOID)lpszDatatype,cjStr);

                        // Guarantee NULL termination of string.
                        ((WCHAR *)kmDocInfo.lpszDatatype)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // apps may have forgotten to initialize this.  Don't want to fail

                    if (kmDocInfo.lpszDatatype != NULL)
                    {
                        VFREEMEM(kmDocInfo.lpszDatatype);
                        kmDocInfo.lpszDatatype = NULL;
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            bStatus = FALSE;
        }
    }

    if (bStatus)
    {
        iRet = GreStartDocInternal(hdc,&kmDocInfo,&bkmBanding, iJob);

        if (iRet != 0)
        {
            __try
            {
                ProbeForWrite(pbBanding,sizeof(BOOL),sizeof(BOOL));
                *pbBanding = bkmBanding;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }
        }
    }

    if (kmDocInfo.lpszDocName != NULL)
    {
        VFREEMEM(kmDocInfo.lpszDocName);
    }

    if (kmDocInfo.lpszOutput != NULL)
    {
        VFREEMEM(kmDocInfo.lpszOutput);
    }

    if (kmDocInfo.lpszDatatype != NULL)
    {
        VFREEMEM(kmDocInfo.lpszDatatype);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* bEndDocInternal
*
* History:
*  Tue 22-Sep-1992 -by- Wendy Wu [wendywu]
* Made it a common routine for EndDoc and AbortDoc.
*
*  Sun 21-Jun-1992 -by- Patrick Haluptzok [patrickh]
* surface disable, check for display dc.
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL bEndDocInternal(HDC hdc, FLONG fl)
{
    BOOL bSucceed;
    BOOL bEndPage;

    ASSERTGDI(((fl & ~ED_ABORTDOC) == 0), "GreEndDoc: invalid fl\n");

    DCOBJ dco(hdc);

    if (!dco.bValidSurf())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        WARNING("GreEndDoc failed - invalid DC\n");
        return(FALSE);
    }

    // before going any futher, restore the DC to it's original level

    if (dco.lSaveDepth() > dco.lSaveDepthStartDoc())
        GreRestoreDC(hdc,dco.lSaveDepthStartDoc());

    PDEVOBJ po(dco.hdev());

    if (po.bDisplayPDEV() || po.hSpooler() == (HANDLE)0)
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        WARNING("GreEndDoc: Display PDEV or not spooling yet\n");
        return(FALSE);
    }

    SURFACE   *pSurf = dco.pSurface();

    bEndPage = (*PPFNDRV(po,EndDoc))(pSurf->pSurfobj(), fl);

    if (!po.bUMPD())
    {
       if (fl & ED_ABORTDOC)
           bSucceed = AbortPrinter(po.hSpooler());
       else
           bSucceed = EndDocPrinter(po.hSpooler());
    }
    else
        bSucceed = TRUE;

    // Reset pixel format accelerators.

    dco.ipfdDevMax(-1);

    // Remove the surface from the DC.

    dco.pdc->pSurface((SURFACE *) NULL);

    po.vDisableSurface();

    return(bSucceed && bEndPage);
}

/******************************Public*Routine******************************\
* NtGdiEndDoc()
*
\**************************************************************************/

BOOL APIENTRY NtGdiEndDoc( HDC hdc )
{
    return(bEndDocInternal(hdc, 0));
}

/******************************Public*Routine******************************\
* NtGdiAbortDoc()
*
\**************************************************************************/

BOOL APIENTRY NtGdiAbortDoc( HDC hdc )
{
    return(bEndDocInternal(hdc, ED_ABORTDOC));
}

/******************************Public*Routine******************************\
* NtGdiStartPage()
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStartPage( HDC hdc )
{
    DCOBJ dco(hdc);
    BOOL  bReturn = FALSE;

    if (dco.bValidSurf())
    {
        if (dco.bHasSurface())
        {
            PDEVOBJ po(dco.hdev());

            //
            // Must be spooling already
            //

            if (po.hSpooler())
            {
                SURFACE *pSurf = dco.pSurface();
                BOOL    bStarted;

                //
                // if it is not a User Mode Printer,
                // Call the spooler before calling the printer.
                //

                if (!po.bUMPD())
                {
                    bStarted = StartPagePrinter(po.hSpooler());
                }
                else
                {
                    bStarted = TRUE;
                }

                if (bStarted)
                {
                    if ((*PPFNDRV(po, StartPage))(pSurf->pSurfobj()))
                    {
                        //
                        // Can't ResetDC in an active page
                        //

                        dco.fsSet(DC_RESET);

                        //
                        // Reset band position in page (if we are banding)
                        //
                        dco.vResetPrintBandPos();

                        bReturn = TRUE;
                    }
                    else
                    {
                        bEndDocInternal(hdc, ED_ABORTDOC);
                    }
                }
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return (bReturn);
}

/******************************Public*Routine******************************\
* NtGdiEndPage()
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiEndPage( HDC hdc )
{
    BOOL bRet = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf())
    {
        if (dco.bHasSurface())
        {
            PDEVOBJ po(dco.hdev());

        // Must be spooling already.

            if (!po.bDisplayPDEV() && po.hSpooler())
            {
                SURFACE *pSurf = dco.pSurface();

                if ((*PPFNDRV(po, SendPage))(pSurf->pSurfobj()))
                {
                    BOOL bEndPage;

                    if (po.bUMPD())
                    {
                        //
                        // all the spooler calls have been made at the user mode
                        // for User Mode Printer Drivers
                        //
                        bEndPage = TRUE;
                    }
                    else
                    {
                        bEndPage = EndPagePrinter(po.hSpooler());
                    }

                    if (bEndPage)
                    {
                        //
                        // Allow ResetDC to function again.
                        //

                        dco.fsClr(DC_RESET);

                        //
                        // Delete the wndobj and reset the pixel format.
                        // Since we don't allow pixel format to change once it
                        // is set, we need to reset it internally here to allow a
                        // different pixel format in the next page.  This means
                        // that applications must make the OpenGL rendering
                        // context not current before ending a page or a document.
                        // They also need to set the pixel format explicitly in
                        // the next page if they need it.
                        //

                        EWNDOBJ *pwoDelete = pSurf->pwo();
                        if (pwoDelete)
                        {
                            GreDeleteWnd((PVOID) pwoDelete);
                            pSurf->pwo((EWNDOBJ *) NULL);
                        }

                        //
                        // Reset pixel format accelerators.
                        //

                        dco.ipfdDevMax(-1);

                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GreDoBanding(HDC hdc,BOOL bStart,RECTL *prcl)
*
*
*  Tue 20-Dec-1994 14:50:45 by Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreDoBanding( HDC hdc, BOOL bStart, POINTL *pptl, PSIZE pSize )
{
    BOOL bRet = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf() && (dco.bHasSurface()))
    {
        PDEVOBJ po(dco.hdev());

        // Must be spooling already.

        if (po.hSpooler())
        {
            SURFACE *pSurf = dco.pSurface();

            if (pSurf->SurfFlags & BANDING_SURFACE)
            {
                BOOL bSucceed;

                if ( bStart )
                {
                    // DrvStartBanding

                    PFN_DrvStartBanding pfnDrvStartBanding = PPFNDRV(po, StartBanding);

                    bSucceed = (*pfnDrvStartBanding)(pSurf->pSurfobj(),pptl);
                    #if DEBUG_BANDING
                        DbgPrint("just called DrvStartBanding which returned %s %d %d\n",
                             (bSucceed) ? "TRUE" : "FALSE", pptl->x, pptl->y );
                    #endif
                    pSize->cx = pSurf->so.sizlBitmap.cx;
                    pSize->cy = pSurf->so.sizlBitmap.cy;

                    //
                    // Set band position in page (if we are banding)
                    //
                    dco.vSetPrintBandPos(pptl);
                }
                else
                {
                    // DrvNextBand

                    PFN_DrvNextBand pfnDrvNextBand = PPFNDRV(po, NextBand);

                    bSucceed = (*pfnDrvNextBand)(pSurf->pSurfobj(), pptl );

                    #if DEBUG_BANDING
                        DbgPrint("just called DrvNextBand which returned %s %d %d\n",
                             (bSucceed) ? "TRUE" : "FALSE", pptl->x, pptl->y );
                    #endif

                    if ( (bSucceed) && ( pptl->x == -1 ) )
                    {
                        // No more bands.

                       if (!po.bUMPD())
                       {
                           //
                           // all the spooler calls have been made at the user mode
                           // for User Mode Printer Drivers
                           //
                           bSucceed = EndPagePrinter(po.hSpooler());
                       }

                        // Allow ResetDC to function again.

                        if (bSucceed)
                        {
                            dco.fsClr(DC_RESET);
                        }

                        // Delete the wndobj and reset the pixel format.
                        // Since we don't allow pixel format to change once it is set, we need
                        // to reset it internally here to allow a different pixel format in the
                        // next page. This means that applications must make the OpenGL
                        // rendering context not current before ending a page or a document.
                        // They also need to set the pixel format explicitly in the next page
                        // if they need it.

                        if (bSucceed)
                        {
                            EWNDOBJ *pwoDelete = pSurf->pwo();
                            if (pwoDelete)
                            {
                                GreDeleteWnd((PVOID) pwoDelete);
                                pSurf->pwo((EWNDOBJ *) NULL);
                            }

                            // Reset pixel format accelerators.

                            dco.ipfdDevMax(0);
                        }
                    }
                    else
                    {
                        if ( !bSucceed )
                        {
                            WARNING("GreDoBanding failed DrvNextBand\n");
                        }
                        else
                        {
                           //
                           // Set band position in page (if we are banding)
                           //
                           dco.vSetPrintBandPos(pptl);
                        }
                    }
                }

                return(bSucceed);
            }
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiDoBanding()
*
* History:
*  11-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
*  01-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL APIENTRY NtGdiDoBanding(
       HDC  hdc,
      BOOL  bStart,
    POINTL *pptl,
     PSIZE  pSize
)
{
    POINTL  ptTmp;
    SIZE szTmp;
    BOOL    bRet = TRUE;

    bRet = GreDoBanding(hdc,bStart,&ptTmp,&szTmp);

    if (bRet)
    {
        __try
        {
            ProbeForWrite(pptl,sizeof(POINTL), sizeof(DWORD));
            *pptl = ptTmp;
            ProbeForWrite(pSize,sizeof(SIZE), sizeof(DWORD));
            *pSize = szTmp;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GreGetPerBandInfo()
*
* History:
*  05-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
***************************************************************************/

ULONG APIENTRY GreGetPerBandInfo(
    HDC          hdc,
    PERBANDINFO *ppbi
)
{
    ULONG ulRet = GDI_ERROR;

    //
    // Set default. Assume no repeat, just play one time per one band.
    //
    ppbi->bRepeatThisBand = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf() && (dco.bHasSurface()))
    {
        PDEVOBJ po(dco.hdev());

        if (po.hSpooler())
        {
            SURFACE *pSurf = dco.pSurface();

            //
            // The surface should be banded.
            //
            if (pSurf->SurfFlags & BANDING_SURFACE)
            {
                PFN_DrvQueryPerBandInfo pfnDrvQueryPerBandInfo = PPFNDRV(po, QueryPerBandInfo);

                //
                // DrvQueryPerBandInfo is optional fucntion, check it is provided.
                //
                if (pfnDrvQueryPerBandInfo)
                {
                    //
                    // Call driver.
                    //
                    ulRet = (*pfnDrvQueryPerBandInfo)(pSurf->pSurfobj(), ppbi);

                    if (ulRet == DDI_ERROR)
                    {
                        ulRet = GDI_ERROR;
                    }
                }
                 else
                {
                    //
                    // The function is not provided, that means the driver don't
                    // want to repeat more than one time for each band. Just return
                    // true, and use default that setted above.
                    //
                    ulRet = 0;
                }
            }
        }
    }

    return (ulRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiGetPerBandInfo()
*
* History:
*  05-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
***************************************************************************/

ULONG APIENTRY NtGdiGetPerBandInfo(
    HDC          hdc,
    PERBANDINFO *ppbi
)
{
    PERBANDINFO PerBandInfo;
    ULONG       ulRet = GDI_ERROR;

    if (ppbi)
    {
        __try
        {
            ProbeForRead(ppbi,sizeof(PERBANDINFO),sizeof(ULONG));
            RtlCopyMemory(&PerBandInfo,ppbi,sizeof(PERBANDINFO));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return (ulRet);
        }
    }

    ulRet = GreGetPerBandInfo(hdc,&PerBandInfo);

    if (ulRet && (ulRet != GDI_ERROR))
    {
        __try
        {
            ProbeForWrite(ppbi,sizeof(PERBANDINFO), sizeof(ULONG));
            RtlCopyMemory(ppbi,&PerBandInfo,sizeof(PERBANDINFO));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ulRet = GDI_ERROR;
        }
    }

    return (ulRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY EngCheckAbort
*
* History:
*  01-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY EngCheckAbort(SURFOBJ *pso)
{
    // Return FALSE if it's a faked surfobj.

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    if (pSurf == NULL || pSurf->hsurf() == 0)
    {
        return(FALSE);
    }

    return(pSurf->bAbort());
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiAnyLinkedFonts()
*
* Returns TRUE if there are any linked fonts in the system.
*
*
* History:
*  12-Dec-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" BOOL NtGdiAnyLinkedFonts()
{
    return(gbAnyLinkedFonts || IS_SYSTEM_EUDC_PRESENT());
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiGetLinkedUFIs
*
* This API returns UFI's (in order of priority) of all the fonts linked to
* the font currently in the DC.
*
*
* History:
*  12-Dec-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" INT NtGdiGetLinkedUFIs(
                   HDC hdc,
    PUNIVERSAL_FONT_ID pufiLinkedUFIs,
                   INT BufferSize
    )
{
    INT iRet = 0;
    PUNIVERSAL_FONT_ID pufi = NULL;

    if (( BufferSize > 0 ) && ( pufiLinkedUFIs != NULL ))
    {
        if (!BALLOC_OVERFLOW1(BufferSize,UNIVERSAL_FONT_ID))
        {
            pufi = (PUNIVERSAL_FONT_ID)
              PALLOCNOZ(BufferSize * sizeof(UNIVERSAL_FONT_ID),'difG');
        }

        if ( pufi == NULL )
        {
            iRet = -1 ;
        }
    }
    else if (BufferSize && pufiLinkedUFIs == NULL)
    {
        iRet = -1;
    }

    if ( iRet != -1 )
    {
       {
           XDCOBJ dco(hdc);
           if (dco.bValid())
           {
               RFONTOBJ rfo(dco,FALSE);

               if (rfo.bValid())
               {
                   iRet = rfo.GetLinkedFontUFIs(dco, pufi,BufferSize);
               }
               else
               {
                   iRet = -1;
                   WARNING("NtGdiGetLinkedUFIS: Invalid RFNTOBJ");
               }

               dco.vUnlockFast();
           }
           else
           {
               WARNING("NtGdiGetLinkedUFIS: Invalid DC");
               iRet = -1;
           }

       }

        if ( iRet > 0 )
        {
            __try
            {
                if (pufiLinkedUFIs)
                {
                    ProbeForWrite(pufiLinkedUFIs,
                                  sizeof(UNIVERSAL_FONT_ID)*BufferSize,
                                  sizeof(DWORD));

                    RtlCopyMemory(pufiLinkedUFIs,
                                  pufi,sizeof(UNIVERSAL_FONT_ID)*BufferSize);
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(62);
                iRet = -1;
            }

        }
    }

    if ( pufi != NULL )
    {
        VFREEMEM( pufi );
    }

    if ( iRet == -1 )
    {
    // We need to set the last error here to something because the spooler
    // code that calls this relies on there being a non-zero error code
    // in the case of failure.  Since we really have no idea I will just
    // set this to ERROR_NOT_ENOUGH_MEMORY which would be the most likely
    // reason for a failure

        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(iRet);
}

ULONG GreGetEmbedFonts()
{
    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (!pfto.bValid() || pfto.cFiles() == 0)         // no embedded fonts
        return 0;

    return (pfto.GetEmbedFonts());
}


BOOL GreChangeGhostFont(VOID *fontID, BOOL bLoad)
{
    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (!pfto.bValid() || !pfto.cFiles())            // somehow the private font table is invalid
        return FALSE;

    return (pfto.ChangeGhostFont(fontID, bLoad));
}


extern "C" BOOL NtGdiAddEmbFontToDC(HDC hdc, VOID **pFontID)
{
    VOID *fontID;
    BOOL bRet = TRUE;

    __try
    {
        ProbeForRead(pFontID, sizeof(VOID *), sizeof(BYTE));
        RtlCopyMemory(&fontID, pFontID, sizeof(VOID *));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = FALSE;

        XDCOBJ dco(hdc);

        if (dco.bValid())
        {
            PUBLIC_PFTOBJ pfto(gpPFTPrivate);
        
        // FonID could be a fake value from hacker to crash the system        
            if(pfto.bValid() && pfto.VerifyFontID(fontID))
                bRet = dco.bAddRemoteFont((PFF *)fontID);            
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL GreGetUFI
*
* History:
*  18-Jan-1995 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreGetUFI( HDC hdc, PUNIVERSAL_FONT_ID pufi,
                DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
                FLONG *pfl,
                VOID **pfontID)
{
    *pfl = 0;
    if (pfontID)
        *pfontID = NULL;

    BOOL bRet = FALSE;
    XDCOBJ dco(hdc);

    if(dco.bValid())
    {
        RFONTOBJ rfo(dco,FALSE);

        if (rfo.bValid())
        {
            rfo.vUFI( pufi );

        // now on to determine if this is private or public font

            PFEOBJ pfeo(rfo.ppfe());
            if (pfeo.bValid())
            {
                PFFOBJ pffo(pfeo.pPFF());
                if (pffo.bValid())
                {
                    if (pffo.bInPrivatePFT())
                    {
                        *pfl |= FL_UFI_PRIVATEFONT;
                        if (pfontID)
                            *pfontID = (VOID*) pfeo.pPFF();                        
                    }

                    if (pffo.bMemFont())
                    {
                        *pfl |= FL_UFI_MEMORYFONT;
                    }

                    if (pffo.pdv())
                    {
                        *pfl |= FL_UFI_DESIGNVECTOR_PFF;
                        if (pdv)
                            RtlCopyMemory(pdv, pffo.pdv(), pffo.cjDV());
                        if (pcjDV)
                            *pcjDV = pffo.cjDV();
                        if (pulBaseCheckSum)
                        {
                        // factor out DV check sum. If we endup using algorithm
                        // that couples these two numbers, then BaseCheckSum will
                        // have to be remembered at the time of computation.

                            *pulBaseCheckSum = pffo.ulCheckSum();

                            *pulBaseCheckSum -= ComputeFileviewCheckSum(pffo.pdv(), pffo.cjDV());
                        }
                    }

                    bRet = TRUE;
                }
            }
        }
        else
        {
            WARNING("GreGetUFI: Invalid rfo");
        }

        dco.vUnlockFast();
    }
    else
    {
        WARNING("GreGetUFI: Invalid DC");
    }

    return bRet;
}



/******************************Public*Routine******************************\
*
* ppfeGetPFEFromUFI
*
* This is used all over the place
*
* History:
*  11-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



PFE *ppfeGetPFEFromUFIInternal (
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bPrivate,
    BOOL               bCheckProccess
)
{
    PFE *ppfeRet = NULL;

    PFELINK *ppfel;
    BOOL    bThreadMatch = FALSE;

    PUBLIC_PFTOBJ pfto(bPrivate ? gpPFTPrivate : gpPFTPublic);
    if (!pfto.bValid())
        return ppfeRet;

    FHOBJ fho(&pfto.pPFT->pfhUFI);
    HASHBUCKET  *pbkt;

    pbkt = fho.pbktSearch( NULL, (UINT*)NULL, pufi );

    if (!pbkt)
    {
        WARNING1("ppfeGetPFEFromUFI: pbkt is NULL\n");
        return ppfeRet;
    }

    for(ppfel = pbkt->ppfelEnumHead; ppfel; ppfel = ppfel->ppfelNext)
    {
        PFEOBJ pfeo(ppfel->ppfe);

        if (UFI_SAME_FACE(pfeo.pUFI(),pufi) && (!bCheckProccess || pfeo.SameProccess()))
        {
            if(pfeo.bDead())
            {
                WARNING("ppfeGetPFEFromUFI: get the pathname to a dead PFE\n");
            }
            else
            {
                if (ppfeRet == NULL)
                {
                    bThreadMatch = pfeo.SameThread();
                    ppfeRet = ppfel->ppfe;
                }
                else
                {
                    // if we get here, it means we have multiple face name and process match.
                    // Do more extensive matching using thread ID.
                    if (!bThreadMatch && pfeo.SameThread())
                    {
                       // This is a better candidate.
                       // Although spooler can be running multiple threads, the same thread for a given
                       // port is used by spooler.  However, if multiple printers were sharing the same
                       // port, we cannot distinguish.  

                       ppfeRet = ppfel->ppfe;
                       bThreadMatch = TRUE;
                       break;
                    }
                }
            }
        }
    }

    return ppfeRet;
}




PFE *ppfeGetPFEFromUFI (
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bPrivate,
    BOOL               bCheckProccess
)
{
    PFE * pfeRet = NULL;

    if (bPrivate)
    pfeRet = ppfeGetPFEFromUFIInternal(pufi, TRUE, bCheckProccess);
    if (!pfeRet)
    pfeRet = ppfeGetPFEFromUFIInternal(pufi, FALSE, bCheckProccess);
    return pfeRet;
}

#define SZDLHEADER ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[1]))


/*********************************Public*Routine*********************************\
* BOOL GreGetUFIPathname
*
* Get the path name and file counts to a given UFI.
*
* History:
*  Feb-04-1997  Xudong Wu   [tessiew]
* Wrote it.
\********************************************************************************/

BOOL GreGetUFIPathname(
    PUNIVERSAL_FONT_ID pufi,
    ULONG             *pcwc,
    LPWSTR             pwszPathname,
    ULONG             *pcNumFiles,
    FLONG              fl,
    BOOL              *pbMemFont,
    ULONG             *pcjView,
    PVOID              pvView,
    BOOL              *pbTTC,
    ULONG             *piTTC
)
{
    BOOL bRet = TRUE;
    PFE *ppfe = ppfeGetPFEFromUFI(pufi, (BOOL)(fl & (FL_UFI_PRIVATEFONT | FL_UFI_MEMORYFONT)), TRUE);

    if (ppfe == NULL)
    {
        WARNING("GreGetUFIPathname can't find the PFE\n");
        return FALSE;
    }

    PFFOBJ pffo(ppfe->pPFF);

    if (pcNumFiles)
    {
        *pcNumFiles = pffo.cNumFiles();
    }
    if (pcwc)
    {
        *pcwc = pffo.cSizeofPaths();
    }
    if (pwszPathname)
    {
        RtlCopyMemory(pwszPathname, pffo.pwszPathname(), pffo.cSizeofPaths() * sizeof(WCHAR));
    }

    if (pbMemFont)
    {
        *pbMemFont = (BOOL)(ppfe->flPFE & PFE_MEMORYFONT);
    }

    if (ppfe->flPFE & PFE_MEMORYFONT)
    {
        NTSTATUS NtStatus;
        SIZE_T    ViewSize = 0;
        ULONG    cjView;

        ASSERTGDI((pffo.ppfvGet()[0])->SpoolerPid == (W32PID)W32GetCurrentPID() ||          // either the current process
                  gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),                                  // or the spooler
                  "GreGetUFIPathname: wrong process to access memory font\n");

        #if 0

        PVOID  pvView1;
        LARGE_INTEGER SectionOffset; SectionOffset.QuadPart = 0;

        NtStatus = MmMapViewOfSection(
                       pffo.ppfvGet()[0]->fv.pSection , // SectionToMap,
                       PsGetCurrentProcess(), //
                       &pvView1          , // CapturedBase,
                       0                 , // ZeroBits,
                       ViewSize          , // CommitSize,
                       &SectionOffset    , // SectionOffset,
                       &ViewSize         , // CapturedViewSize,
                       ViewUnmap         , // InheritDisposition,
                       SEC_NO_CHANGE     , // AllocationType,
                       PAGE_READONLY       // Protect
                       );

        if (!NT_SUCCESS(NtStatus))
        {
            //WARNING("could not map mem font to the spooler process\n");
            KdPrint(("could not map mem font to the spooler process\n"));
            *pcjView = 0;
            *ppvView = NULL;
            return FALSE;
        }

    // if this is a memory font, preceeding the font image
    // there is going to be the header stuff in the section,
    // so will need to adjust the pointer. cjView will already contain
    // the correct data corresponding to the size without the header

        *pcjView = pffo.ppfvGet()[0]->fv.cjView;
        *ppvView = (PVOID)((BYTE *)pvView1 + SZDLHEADER);

        #endif

        cjView = pffo.ppfvGet()[0]->fv.cjView;

        if (pcjView)
        {
            *pcjView = cjView;
        }

        if (pvView)
        {
            PVOID pvKView;

#ifdef _HYDRA_
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus = Win32MapViewInSessionSpace(
                          pffo.ppfvGet()[0]->fv.pSection,
                          &pvKView,
                          &ViewSize);
#else
            NtStatus = MmMapViewInSystemSpace(
                           pffo.ppfvGet()[0]->fv.pSection,
                           &pvKView,
                           &ViewSize);
#endif

            if (!NT_SUCCESS(NtStatus))
            {
                //WARNING("could not map mem font to the system space\n");
                KdPrint(("could not map mem font to the system space\n"));
                return FALSE;
            }

            __try
            {
            // if this is a memory font, preceeding the font image
            // there is going to be the header stuff in the section,
            // so will need to adjust the pointer before copying.
            // cjView already corresponds to the correct data
            // without the header

                ProbeForWrite(pvView, cjView, sizeof(BYTE));
                RtlCopyMemory(pvView, ((BYTE *)pvKView + SZDLHEADER), cjView);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bRet = FALSE;
            }

#ifdef _HYDRA_
        // MmUnmapViewInSessionSpace is internally promoted to
        // MmUnmapViewInSystemSpace on non-Hydra systems.

            Win32UnmapViewInSessionSpace(pvKView);
#else
            MmUnmapViewInSystemSpace(pvKView);
#endif
        }
    }

    if (bRet && pbTTC && piTTC)
    {
        *pbTTC = FALSE;
        *piTTC = 0;

        PFF *pPFF = ppfe->pPFF;

        if (pPFF->hdev == (HDEV) gppdevTrueType)
        {
            COUNT cFonts = pPFF->cFonts;

        // if this is a ttc file we need at least 4 faces, eg.
        // foo1, @foo1, foo2, @foo2 ...

            if ((cFonts >= 4) && !(cFonts & 1))
            {
                ASSERTGDI(ppfe->ufi.Index, "ufi.Index must not be zero\n");
                *piTTC = (ppfe->ufi.Index - 1) / 2;
                *pbTTC = TRUE;
            }
        }
    }

    return bRet;
}



/******************************Public*Routine******************************\
* BOOL GreForceUFIMapping( HDC hdc, PUNIVERSAL_FONT_ID pufi )
*
* History:
*  3-Mar-1995 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreForceUFIMapping( HDC hdc, PUNIVERSAL_FONT_ID pufi)
{
    XDCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("GreForceUFIMapping: Invalid DC");
        return(FALSE);
    }

    dco.pdc->vForceMapping( pufi );

    dco.vUnlockFast();

    return(TRUE);
}


/**********************Public*Routine******************************\
* NtGdiRemoveMergeFont(HDC hdc, UNIVERSAL_FONT_ID *pufi)
*
* History:
*  Jan-27-1997 -by- Xudong Wu [tessiew]
* Wrote it.
\******************************************************************/
BOOL
APIENTRY
NtGdiRemoveMergeFont(HDC hdc, UNIVERSAL_FONT_ID *pufi)
{
    BOOL  bRet = TRUE;
    UNIVERSAL_FONT_ID ufiTmp;
    XDCOBJ dco(hdc);

    if(!dco.bValid())
    {
        WARNING("NtGdiRemoveMergefont bogus HDC\n" );
        return FALSE;
    }
    else if (dco.bDisplay())
    {
        WARNING("NtGdiRemoveMergefont: display DC\n" );
        bRet = FALSE;
    }
    else
    {
        ASSERTGDI(pufi != NULL, "Try to remove a font wiht pufi == NULL\n");

        __try
        {
            ProbeForRead(pufi, sizeof(UNIVERSAL_FONT_ID), sizeof(DWORD));
            ufiTmp = *pufi;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            bRet = FALSE;
        }

        if (bRet)
        {
            if (!(bRet = dco.bRemoveMergeFont(ufiTmp)))
            {
                WARNING("NtGdiRemoveMergeFont failed on dco.bRemoveMergeFont\n");
            }
        }
    }

    dco.vUnlockFast();

    return bRet;
}

/****************************************************************************
*  INT GreQueryFonts( PUNIVERSAL_FONT_ID, ULONG, PLARGE_INTEGER )
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

INT GreQueryFonts(
    PUNIVERSAL_FONT_ID pufi,
                 ULONG nBufferSize,
        PLARGE_INTEGER pTimeStamp
)
{

    PUBLIC_PFTOBJ  pfto;
    return(pfto.QueryFonts(pufi,nBufferSize,pTimeStamp));
}

/*****************************************************************************
 * PTYPEONEINFO GetTypeOneFontList()
 *
 * This function returns a pointer to a TYPEONEINFO structure that contains
 * a list of file mapping handles and checksums for the Type1 fontst that are
 * installed in the system.  This structure also has a reference count and a
 * time stamp coresponding to the last time fonts were added or removed from
 * the system.  The reference count is 1 biased meaning that even if no PDEV's
 * a referencing it, it is still 1.
 *
 * History
 *  8-10-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ****************************************************************************/

PTYPEONEINFO GetTypeOneFontList()
{
                    UNICODE_STRING UnicodeRoot;
                      PTYPEONEINFO InfoReturn = NULL;
                 OBJECT_ATTRIBUTES ObjectAttributes;
                              BOOL bCloseRegistry = FALSE;
                          NTSTATUS NtStatus;
             PKEY_FULL_INFORMATION InfoBuffer = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = NULL;
                             ULONG KeyInfoLength;
                            HANDLE KeyRegistry;

    RtlInitUnicodeString(&UnicodeRoot,TYPE1_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

        NtStatus = ZwOpenKey(&KeyRegistry,
                         GENERIC_READ,
                         &ObjectAttributes);

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unable to open TYPE1 key\n");
        goto done;
    }

    bCloseRegistry = TRUE;

    NtStatus = ZwQueryKey(KeyRegistry,
                          KeyFullInformation,
                          (PVOID) NULL,
                          0,
                          &KeyInfoLength );

    if ((NtStatus != STATUS_BUFFER_OVERFLOW) &&
       (NtStatus != STATUS_BUFFER_TOO_SMALL))
    {
        WARNING("Unable to query TYPE1 key\n");
        goto done;
    }

    InfoBuffer = (PKEY_FULL_INFORMATION) PALLOCNOZ(KeyInfoLength,'f1tG');

    if ( !InfoBuffer )
    {
        WARNING("Unable to alloc mem for TYPE1 info\n");
        goto done;
    }

    NtStatus = ZwQueryKey(KeyRegistry,
                          KeyFullInformation,
                          InfoBuffer,
                          KeyInfoLength,
                          &KeyInfoLength );

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unable to query TYPE1 key\n");
        goto done;
    }

    // if there aren't any soft TYPE1 fonts installed then just return now.

    if ( !InfoBuffer->Values )
    {
        goto done;
    }

    GreAcquireFastMutex(ghfmMemory);

    if (gpTypeOneInfo != NULL )
    {
        if ((gpTypeOneInfo->LastWriteTime.LowPart == InfoBuffer->LastWriteTime.LowPart)&&
           (gpTypeOneInfo->LastWriteTime.HighPart == InfoBuffer->LastWriteTime.HighPart))
        {
            // If the times match then increment the ref count and return

            InfoReturn = gpTypeOneInfo;
            gpTypeOneInfo->cRef += 1;
            GreReleaseFastMutex(ghfmMemory);
            goto done;
        }

        gpTypeOneInfo->cRef -= 1;

        // At this point if gTypeOneInfo->cRef > 0 then there is a PDEV using this
        // info still.  If gTypeOneInfo->cRef = 0 then it is okay to delete it.
        // Note that this behavior means we must initialize gTypeOneInfo->cRef to 1.

        if ( !gpTypeOneInfo->cRef  )
        {
            VFREEMEM(gpTypeOneInfo);
        }

        // Whether someone is using it or not, remove pointer to current type one
        // info so that noone else tries to use it.

        gpTypeOneInfo = NULL;
    }

    GreReleaseFastMutex(ghfmMemory);


    ULONG MaxValueName, MaxValueData, TotalData, Values;

    MaxValueData = ALIGN4(InfoBuffer->MaxValueDataLen);
    Values = InfoBuffer->Values;

    TotalData = MaxValueData + sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    if( TotalData < MaxValueData ) // overflow
    {
        TotalData = 0;
    } else {
        unsigned long n = sizeof(ULONG)  // checksum
            + (2 * sizeof(WCHAR) * (MAX_PATH+1)) // PFM & PFB paths
            + sizeof(FONTFILEVIEW);  // mapping structs
        if( Values > MAXIMUM_POOL_ALLOC/n // multiply would overflow
                || TotalData < (TotalData + Values * n) ) // addition would overflow
            TotalData = 0;
        else
            TotalData += Values * n;
    }

    // now TotalData contains either:
    //     MaxValueData + sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
    //     (Values * sizeof(ULONG)) +  <--- Room for checksums
    //     (Values * 2 * sizeof(WCHAR) * (MAX_PATH + 1)) + <--- PFM/PFB paths
    //     Values * sizeof(FONTFILEVIEW);   <--- room for mapping structs
    //  or it contains a zero because of arithmetic overflow in the size
    //  calculation

    PartialInfo = (TotalData == 0) ? NULL
        : (PKEY_VALUE_PARTIAL_INFORMATION) PALLOCNOZ(TotalData,'f1tG');

    if ( !PartialInfo )
    {
        WARNING("Unable to allocate memory for TYPE1 info\n");
        goto done;
    }

    BYTE *ValueData;
    PFONTFILEVIEW FontFileViews;
    WCHAR *FullPFM, *FullPFB;
    ULONG *Checksums;
    ULONG SoftFont,Result;

    ValueData =  &(PartialInfo->Data[0]);
    FullPFM = (WCHAR*) &ValueData[MaxValueData];
    FullPFB = &FullPFM[(MAX_PATH+1)*Values];
    Checksums = (ULONG*) &FullPFB[Values*(MAX_PATH+1)];

    FontFileViews = (PFONTFILEVIEW) &Checksums[Values];

    for ( SoftFont = 0; SoftFont < Values; SoftFont ++ )
    {
        WCHAR *TmpValueData;
        COUNT  SizeOfString;

        NtStatus = ZwEnumerateValueKey(KeyRegistry,
                                       SoftFont,
                                       KeyValuePartialInformation,
                                       PartialInfo,
                                       MaxValueData +
                                       sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                       &Result );

        if (!NT_SUCCESS(NtStatus))
        {
            WARNING("Unable to enumerate TYPE1 keys\n");
            goto done;
        }

        TmpValueData = (WCHAR*) ValueData;
        TmpValueData = TmpValueData + wcslen(TmpValueData)+1;

        SizeOfString = wcslen(TmpValueData);

        if ( SizeOfString > MAX_PATH )
        {
            WARNING("PFM path too long\n");
            goto done;
        }

        wcscpy(&FullPFM[SoftFont*(MAX_PATH+1)],TmpValueData);

        TmpValueData += SizeOfString+1;

        SizeOfString = wcslen(TmpValueData);

        if ( SizeOfString > MAX_PATH )
        {
            WARNING("PFB path too long\n");
            goto done;
        }

        wcscpy(&FullPFB[SoftFont*(MAX_PATH+1)],TmpValueData);
    }

    // Release key at this point.  We are about to call off to the spooler
    // which could take a while and shouldn't be holding the key while we do so.

    ZwCloseKey(KeyRegistry);
    bCloseRegistry = FALSE;

    ULONG i, ValidatedTotal,TotalSize;


    for ( i = 0, ValidatedTotal = TotalSize = 0; i < SoftFont; i++ )
    {
        BOOL bAbleToLoadFont;

        bAbleToLoadFont = FALSE;

    // go through all the PFM's and PFB's and expand them to full paths by
    // calling back to the spooler

        if (GetFontPathName(&FullPFM[i*(MAX_PATH+1)],&FullPFM[i*(MAX_PATH+1)]) &&
           GetFontPathName(&FullPFB[i*(MAX_PATH+1)],&FullPFB[i*(MAX_PATH+1)]))
        {
        // Compute the checksum that we are goine to give to the PSCRIPT
        // driver to stuff into the IFI metrics.  We will use the sum
        // of the checksum of both files.

            FILEVIEW fv;
            RtlZeroMemory( &fv, sizeof(fv) );

            // Temporarily map a kernel mode view

            if (bMapFile(&FullPFM[i*(MAX_PATH+1)], &fv, 0, NULL))
            {
                ULONG sum;

                sum = ComputeFileviewCheckSum(fv.pvKView, fv.cjView);
                vUnmapFile( &fv);

                // Temporarily map a kernel mode view

                if (bMapFile(&FullPFB[i*(MAX_PATH+1)], &fv, 0, NULL))
                {
                    sum += ComputeFileviewCheckSum(fv.pvKView, fv.cjView);

                    vUnmapFile( &fv);

                    ValidatedTotal += 2;
                    TotalSize += (wcslen(&FullPFM[i*(MAX_PATH+1)]) + 1) * sizeof(WCHAR);
                    TotalSize += (wcslen(&FullPFB[i*(MAX_PATH+1)]) + 1) * sizeof(WCHAR);
                    Checksums[i] = sum;
                    bAbleToLoadFont = TRUE;
                }
            }
        }

        if (!bAbleToLoadFont)
        {
            FullPFM[i*(MAX_PATH+1)] = (WCHAR) 0;
            FullPFB[i*(MAX_PATH+1)] = (WCHAR) 0;
        }
    }

    TotalSize += ValidatedTotal * sizeof(TYPEONEMAP) + sizeof(TYPEONEINFO);

    PTYPEONEINFO TypeOneInfo;
    WCHAR *StringBuffer;

    if (!ValidatedTotal)
    {
        goto done;
    }

    TypeOneInfo = (PTYPEONEINFO) PALLOCMEM(TotalSize,'f1tG');
    StringBuffer = (WCHAR*) &TypeOneInfo->aTypeOneMap[ValidatedTotal];

    if ( !TypeOneInfo )
    {
        goto done;
    }

    TypeOneInfo->cRef = 1; // must be one so PDEV stuff doesn't deallocate it unless
                           // we explicitly set it to 0

    TypeOneInfo->cNumFonts = ValidatedTotal/2;
    TypeOneInfo->LastWriteTime = InfoBuffer->LastWriteTime;

    // loop through everything again packing everything tightly together in memory
    // and setting up the FONTFILEVIEW pointers.

    UINT CurrentFont;

    for ( i = 0, CurrentFont = 0; i < SoftFont; i ++ )
    {
        if (FullPFM[i*(MAX_PATH+1)] != (WCHAR) 0)
        {
            wcscpy(StringBuffer,&FullPFM[i*(MAX_PATH+1)]);
            TypeOneInfo->aTypeOneMap[CurrentFont].fv.pwszPath = StringBuffer;
            StringBuffer += wcslen(&FullPFM[i*(MAX_PATH+1)]) + 1;

            wcscpy(StringBuffer,&FullPFB[i*(MAX_PATH+1)]);
            TypeOneInfo->aTypeOneMap[CurrentFont+1].fv.pwszPath = StringBuffer;
            StringBuffer += wcslen(&FullPFB[i*(MAX_PATH+1)]) + 1;

            // Both the PFM and PFB share the same checksum since they represent
            // the same font file.

            TypeOneInfo->aTypeOneMap[CurrentFont].Checksum = Checksums[i];
            TypeOneInfo->aTypeOneMap[CurrentFont+1].Checksum = Checksums[i];

            CurrentFont += 2;
        }
    }

    ASSERTGDI(CurrentFont == ValidatedTotal,
              "GetTypeOneFontList:CurrentFont != ValidatedTotal\n");

    // everything should be set up now just our list into

    GreAcquireFastMutex(ghfmMemory);

    if ( gpTypeOneInfo )
    {
        // looks like someone snuck in before us.  that's okay well use their font
        // list and destroy our own
        VFREEMEM(TypeOneInfo);
    }
    else
    {
        gpTypeOneInfo = TypeOneInfo;
    }

    gpTypeOneInfo->cRef += 1;
    InfoReturn = gpTypeOneInfo;

    GreReleaseFastMutex(ghfmMemory);

done:

    if ( bCloseRegistry )
    {
        ZwCloseKey(KeyRegistry);
    }

    if ( InfoBuffer )
    {
        VFREEMEM(InfoBuffer);
    }

    if ( PartialInfo )
    {
        VFREEMEM(PartialInfo);
    }

    return(InfoReturn);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetType1FontList
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

BOOL APIENTRY EngGetType1FontList(
             HDEV  hdev,
       TYPE1_FONT *pType1Buffer,
            ULONG  cjType1Buffer,
           PULONG  pulLocalFonts,
           PULONG  pulRemoteFonts,
    LARGE_INTEGER *pLastModified
)
{
    BOOL bRet = FALSE;

    PPDEV ppdev = (PPDEV) hdev;

    if (!ppdev->TypeOneInfo)
    {
        ppdev->TypeOneInfo = GetTypeOneFontList();
    }

    PREMOTETYPEONENODE RemoteTypeOne = ppdev->RemoteTypeOne;

    if (ppdev->TypeOneInfo || RemoteTypeOne )
    {
        *pulRemoteFonts = 0;

        while (RemoteTypeOne)
        {
            *pulRemoteFonts += 1;
            RemoteTypeOne = RemoteTypeOne->pNext;
        }

        if ( ppdev->TypeOneInfo )
        {
            *pulLocalFonts = ppdev->TypeOneInfo->cNumFonts;
            *pLastModified = *(&ppdev->TypeOneInfo->LastWriteTime);
        }
        else
        {
            *pulLocalFonts = 0;
            pLastModified->LowPart = 0;
            pLastModified->HighPart = 0;
        }

        // If buffer is NULL then caller is only querying for time stamp
        // and size of buffer.

        if (pType1Buffer)
        {
            COUNT Font;
            unsigned long buflen = 
               (BALLOC_OVERFLOW1((*pulLocalFonts+*pulRemoteFonts),TYPE1_FONT))
                ? 0 : (*pulLocalFonts+*pulRemoteFonts) * sizeof(TYPE1_FONT);

            
            if (cjType1Buffer >= buflen  &&  buflen != 0)
            {
                TYPEONEMAP *pTypeOneMap = ppdev->TypeOneInfo->aTypeOneMap;

                for (Font = 0;
                    ppdev->TypeOneInfo && (Font < ppdev->TypeOneInfo->cNumFonts);
                    Font++ )
                {
                    pType1Buffer[Font].hPFM = (HANDLE)&pTypeOneMap[Font*2].fv;
                    pType1Buffer[Font].hPFB = (HANDLE)&pTypeOneMap[Font*2+1].fv;
                    pType1Buffer[Font].ulIdentifier = pTypeOneMap[Font*2+1].Checksum;
                }

                RemoteTypeOne = ppdev->RemoteTypeOne;

                while ( RemoteTypeOne )
                {
                    pType1Buffer[Font].hPFM = (HANDLE) &(RemoteTypeOne->fvPFM);
                    pType1Buffer[Font].hPFB = (HANDLE) &(RemoteTypeOne->fvPFB);
                    pType1Buffer[Font].ulIdentifier =
                                        RemoteTypeOne->pDownloadHeader->Type1ID;

                    Font += 1;
                    RemoteTypeOne = RemoteTypeOne->pNext;
                }

                bRet = TRUE;
            }
            else
            {
                WARNING("GDI:EngGetType1FontList:pType1Buffer is too small.\n");
            }
        }
        else
        {
            bRet = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* EngQueryLocalTime()
*
*   Fill in the ENG_TIME_FIELDS structure with the current local time.
*   Originaly added for postscript
*
* History:
*  07-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID EngQueryLocalTime( PENG_TIME_FIELDS ptf )
{
    TIME_FIELDS   tf;
    LARGE_INTEGER li;

    GreQuerySystemTime(&li);
    GreSystemTimeToLocalTime(&li,&li);
    RtlTimeToTimeFields(&li,&tf);

    ptf->usYear         = tf.Year;
    ptf->usMonth        = tf.Month;
    ptf->usDay          = tf.Day;
    ptf->usHour         = tf.Hour;
    ptf->usMinute       = tf.Minute;
    ptf->usSecond       = tf.Second;
    ptf->usMilliseconds = tf.Milliseconds;
    ptf->usWeekday      = tf.Weekday;
}


/******************************Public*Routine******************************\
* BOOL GreGetBaseUFIBits(UNIVERSAL_FONT_ID *pufi, FONTFILEVIEW **ppfv)
*
* History:
*  17-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL GreGetBaseUFIBits(UNIVERSAL_FONT_ID *pufi, FONTFILEVIEW *pfv)
{
    BOOL bRet = FALSE;

// base font is not an old fashioned type1 font

    ASSERTGDI(!UFI_TYPE1_FONT(pufi), "Base MM Font is old fashioned device font\n");

// Stabilize the public PFT for mapping.

    PUBLIC_PFTOBJ  pfto(gpPFTPublic);

// base mm font will always be added to gpPFTPublic (not to gpPFTPrivate)
// on the print server machine (look at NtGdiAddRemoteFontsToDC).
// Therefore, we shall only look in the public table for it

    PFE  *ppfe = ppfeGetPFEFromUFI(pufi,
                                   FALSE,  // public
                                   FALSE); // do not check the proccess id

    if (!ppfe)
        return bRet;

    PFFOBJ pffo(ppfe->pPFF);

    #if DBG
    COUNT cNumFiles = pffo.cNumFiles();
    ASSERTGDI(cNumFiles == 1, "GreGetBaseUFIBits cNumFiles != 1\n");
    ASSERTGDI(!wcsncmp(pffo.pwszPathname(), L"REMOTE-", 7), "GreGetBaseUFIBits pathname != REMOTE\n");
    #endif

// We need to copy this to a buffer since the PFFOBJ could go away after
// we release the semaphore. TRUE? Not really. The point is that ppfv is
// only going to be used during a print job while base font is added to DC.
// That is, only when DC goes away the base font will be removed so that this
// ppfv will be around for as long as is necessary to service its mm instances
// that are used in the same job.

    *pfv = *(pffo.ppfvGet()[0]);

    ASSERTGDI(pfv->SpoolerPid == W32GetCurrentPID() || gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),
              "GreGetBaseUFIBits, Pid doesn't match\n");

    return TRUE;
}


/******************************Public*Routine******************************\
*
* NtGdiAddRemoteMMInstanceToDC(
*
* History:
*  17-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL NtGdiAddRemoteMMInstanceToDC(
    HDC                   hdc,
    DOWNLOADDESIGNVECTOR *pddv,
    ULONG                 cjDDV
    )
{

    DOWNLOADDESIGNVECTOR ddv;
    BOOL bRet = FALSE;
    FONTFILEVIEW fv;

    XDCOBJ dco(hdc);

    if (!dco.bValid())
        return bRet;

    if (!dco.bDisplay() && (cjDDV <= sizeof(DOWNLOADDESIGNVECTOR)) )
    {
        __try
        {
            ProbeForRead(pddv,cjDDV, sizeof(BYTE));
            RtlCopyMemory(&ddv, pddv, cjDDV);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("GreAddRemoteMMInstanceToDC, bogus ddv\n");
        }

    // Now get the pointer to the bits of the base mm font.
    // This will only work because the base font has already been installed
    // on the print server. We always first write the bits for the base font
    // to the spool file and then design vectors for all its instances.
    // Consenquently, as we spool, the base font has already been added
    // and its bits live in virtual memory window allocated by
    // NtGdiAddRemoteFontToDC. We now just get the file view for the bits

        if (GreGetBaseUFIBits(&ddv.ufiBase, &fv))
        {
            PUBLIC_PFTOBJ  pfto;

            UINT offset = ALIGN8(sizeof(FONTFILEVIEW*));
            FONTFILEVIEW** ppfv = (FONTFILEVIEW**)
              PALLOCMEM( sizeof(FONTFILEVIEW) + offset, 'vffG');

            if (ppfv == NULL)
            {
                WARNING1("NtGdiAddRemoteMMInstanceToDC out of memory\n");
                bRet = FALSE;
            }
            else
            {
            // CAUTION
            //
            // The PFF cleanup code has intimate knowledge of this
            // code so be sure you synchronize changes in here and there.
            //
            // We are about to create a FONTFILEVIEW that corresponds to
            // a pool image of a font downloaded for metafile printing.
            // This case is signified by setting FONTFILEVIEW::pszPath
            // to zero. This corresponds to a image loaded once.

                ppfv[0] = (FONTFILEVIEW*)((BYTE *)ppfv + offset);

            // the following line of code is crucial:
            // since we set ulRegionSize to zero, the code
            // which does unsecure mem will not be executed for instances
            // but only for the base font. However, ppfv will be freed properly.

                fv.ulRegionSize = 0;

            // cRefCountFD should be set to or 1, what should it be?
            // It turns out it does not matter because ulRegionSize
            // is set to zero, so that unmap remote fonts is not called on
            // pdv record, only on the base font.

                fv.cRefCountFD = 0;

                *(ppfv[0]) = fv;

                bRet = pfto.bLoadRemoteFonts(dco, ppfv, 1, &ddv.dv, NULL);
            }
        }
    }
    else
    {
        WARNING("GreAddRemoteMMInstanceToDC bogus HDC,display DC, or cjDDV\n");
    }

    dco.vUnlockFast();

    return (bRet);
}


/*************Public**Routine**************\
* BOOL GreUnmapMemFont
*
* History:
*  Jul-03-97  Xudong Wu [TessieW]
* Wrote it
\*******************************************/
#if 0

BOOL GreUnmapMemFont(PVOID pvView)
{
    NTSTATUS NtStatus;

    NtStatus = MmUnmapViewOfSection(PsGetCurrentProcess(), (PVOID)((PBYTE)pvView - SZDLHEADER));

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unmapping memory font's view in application's process space failed");
        return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rgngdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgngdi.cxx
*
* GDI Region calls
*
* Created: 30-Aug-1990 10:21:11
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PBRUSH gpbrNull;

#if DBG
extern ULONG dbgrgn;
#endif


// Tracing defines for traces that should ignore class
#define GDITE_GreCreatePolyPolygonRgnInternal_return                        \
       (GDITE_GreCreatePolyPolygonRgnInternal|GDITF_IGNORE_CLASS)
#define GDITE_GreCreateRectRgn_return                                       \
       (GDITE_GreCreateRectRgn|GDITF_IGNORE_CLASS)
#define GDITE_GreCreateRectRgnIndirect_return                               \
       (GDITE_GreCreateRectRgnIndirect|GDITF_IGNORE_CLASS)
#define GDITE_GreExtCreateRegion_return                                     \
       (GDITE_GreExtCreateRegion|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateEllipticRgn_return                                 \
       (GDITE_NtGdiCreateEllipticRgn|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateRectRgn_return                                     \
       (GDITE_NtGdiCreateRectRgn|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateRoundRectRgn_return                                \
       (GDITE_NtGdiCreateRoundRectRgn|GDITF_IGNORE_CLASS)


/******************************Public*Routine******************************\
* BOOL bDeleteRegion(HRGN)
*
* Delete the specified region
*
* History:
*  17-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL bDeleteRegion(HRGN hrgn)
{

    RGNLOG rl(hrgn,NULL,"bDeleteRegion",0,0,0);

    RGNOBJAPI   ro(hrgn,FALSE);

    return(ro.bValid() &&
           (ro.cGet_cRefs() == 0) &&
           ro.bDeleteRGNOBJAPI());
}

/***************************Exported*Routine****************************\
* BOOL GreSetRegionOwner(hrgn,lPid)
*
* Assigns a new owner to the given region.  This function should be as
* fast as possible so that the USER component can call it often without
* concern for performance!
*
\***********************************************************************/

BOOL
GreSetRegionOwner(
    HRGN hrgn,
    W32PID lPid)
{

    RGNLOG rl(hrgn,NULL,"GreSetRegionOwner",W32GetCurrentPID(),0,0);

    //
    // Setting a region to public, the region must not have
    // a user mode component
    //

    #if DBG

    RGNOBJAPI ro(hrgn,TRUE);
    if (ro.bValid())
    {
        if (PENTRY_FROM_POBJ(ro.prgn)->pUser != NULL)
        {
            RIP("Error: setting region public that has user component");
        }
    }

    #endif

    //
    // Get the current PID.
    //

    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return HmgSetOwner((HOBJ)hrgn, lPid, RGN_TYPE);
}






/******************************Public*Routine******************************\
* CLIPOBJ *EngCreateClip()
*
* Create a long live clipping object for a driver
*
* History:
*  22-Sep-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

CLIPOBJ *EngCreateClip()
{

    //
    // Note that we intentionally zero this memory on allocation. Even though
    // we're going to set some of these fields to non-zero values right away,
    // this is not a performance-critical function (a driver typically calls
    // this only once), and we save a lot of instruction bytes by not having to
    // zero a number of fields explicitly.
    //

    VOID *pv = EngAllocMem(FL_ZERO_MEMORY,
                           sizeof(ECLIPOBJ) + SINGLE_REGION_SIZE,
                           'vrdG');

    if (pv != NULL)
    {
        //
        // Make this a CLIPOBJ that doesn't clip anything.
        //

        ((ECLIPOBJ *) pv)->iDComplexity     = DC_TRIVIAL;
        ((ECLIPOBJ *) pv)->iFComplexity     = FC_RECT;
        ((ECLIPOBJ *) pv)->iMode            = TC_RECTANGLES;

        REGION *prgn = (REGION*)((PBYTE)pv + sizeof(ECLIPOBJ));
        ((ECLIPOBJ *) pv)->prgn             = prgn;

        RGNOBJ ro(prgn);
        RECTL  r;

        r.left  = r.top    = MIN_REGION_COORD;
        r.right = r.bottom = MAX_REGION_COORD;

        ro.vSet(&r);
    }

    return((CLIPOBJ *)pv);
}

/******************************Public*Routine******************************\
* VOID EngDeleteClip()
*
* Delete a long live clipping object for a driver
*
* History:
*  22-Sep-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID EngDeleteClip(CLIPOBJ *pco)
{
    if (pco == NULL)
    {
        WARNING("Driver calling to free NULL clipobj");
    }
    else
    {
        ASSERTGDI(pco->iUniq == 0, "Non-zero iUniq\n");
    }

    //
    // We call EngFreeMem since some drivers like to free non-existant
    // Clip Objects.
    //

    EngFreeMem((PVOID)pco);

}



/******************************Public*Routine******************************\
* ASSERTDEVLOCK()
*
*   This validates that the thread using the DC has the devlock as well.
*
* History:
*  24-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if DBG
VOID ASSERTDEVLOCK(PDC pdc)
{
    return;

    if (pdc->fs() & DC_SYNCHRONIZEACCESS)
    {
        ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(pdc->hsemDcDevLock_),
                  "ASSERTDEVLOCK: wrong id\n");
    }
}
#endif

/******************************Public*Routine******************************\
* LONG GreCombineRgn(hrgnTrg,hrgnSrc1,hrgnSrc2,iMode)
*
* Combine the two source regions by the given mode.  The result is placed
* in the target.  Note that either (or both sources) may be the same as
* the target.
*
\**************************************************************************/

int APIENTRY GreCombineRgn(
    HRGN  hrgnTrg,
    HRGN  hrgnSrc1,
    HRGN  hrgnSrc2,
    int   iMode)
{
    GDITraceHandle3(GreCombineRgn, "(%X, %X, %X, %d)\n", (va_list)&hrgnTrg,
                    hrgnTrg, hrgnSrc1, hrgnSrc2);

    RGNLOG rl(hrgnTrg,NULL,"GreCombineRgn",(ULONG_PTR)hrgnSrc1,(ULONG_PTR)hrgnSrc2,iMode);

    LONG Status;

    if ((iMode < RGN_MIN) || (iMode > RGN_MAX))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return ERROR;
    }

    //
    // Check if a simple copy is to be performed.
    //

    if (iMode == RGN_COPY)
    {

        RGNOBJAPI roTrg(hrgnTrg,FALSE);
        RGNOBJAPI roSrc1(hrgnSrc1,TRUE);

        //
        // if either of these regions have a client rectangle, then set the
        // km region
        //

        if (!roTrg.bValid() || !roSrc1.bValid() || !roTrg.bCopy(roSrc1))
        {
            if (!roSrc1.bValid() || !roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }

            Status = ERROR;
        }
        else
        {
            Status = roTrg.iComplexity();
        }

    }
    else if (SAMEHANDLE(hrgnTrg, hrgnSrc1) || SAMEHANDLE(hrgnTrg, hrgnSrc2))
    {

    // Two of the handles are the same. Check to determine if all three
    // handles are the same.

        if (SAMEHANDLE(hrgnSrc1, hrgnSrc2))
        {
            RGNOBJAPI roTrg(hrgnTrg,FALSE);

            if (!roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                Status = ERROR;
            }
            else
            {
                if ((iMode == RGN_DIFF) || (iMode == RGN_XOR))
                {
                    roTrg.vSet();
                }

                Status = roTrg.iComplexity();
            }

        }
        else
        {

            //
            // All three handles are not the same.
            //
            // Also, Src1 or Src2 could be the actual
            // destination so don't use TRUE on the
            // RGNOBJAPI contructor
            //

            RGNMEMOBJTMP rmo((BOOL)FALSE);
            RGNOBJAPI roSrc1(hrgnSrc1,FALSE);
            RGNOBJAPI roSrc2(hrgnSrc2,FALSE);

            if (!rmo.bValid()    ||
                !roSrc1.bValid() ||
                !roSrc2.bValid() ||
                (rmo.iCombine(roSrc1, roSrc2, iMode) == ERROR))
            {
                if (!roSrc1.bValid() || !roSrc2.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                }

                Status = ERROR;

            }
            else if (SAMEHANDLE(hrgnTrg, hrgnSrc1))
            {
                if (!roSrc1.bSwap(&rmo))
                {
                    Status = ERROR;

                }
                else
                {
                    Status = roSrc1.iComplexity();
                }

            }
            else
            {
                if (!roSrc2.bSwap(&rmo))
                {
                    Status = ERROR;

                }
                else
                {
                    Status = roSrc2.iComplexity();
                }
            }
        }

    }
    else
    {

    // Handle the general case.

        RGNOBJAPI roSrc1(hrgnSrc1,TRUE);
        RGNOBJAPI roSrc2(hrgnSrc2,TRUE);
        RGNOBJAPI roTrg(hrgnTrg,FALSE);

        if (!roSrc1.bValid() ||
            !roSrc2.bValid() ||
            !roTrg.bValid()  ||
            (roTrg.iCombine(roSrc1, roSrc2, iMode) == ERROR))
        {
            if (!roSrc1.bValid() || !roSrc2.bValid() || !roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }

            Status = ERROR;

        }
        else
        {
            Status = roTrg.iComplexity();
        }
    }

    return (int)Status;
}

/******************************Public*Routine******************************\
* HRGN NtGdiCreateEllipticRgn(xLeft,yTop,xRight,yBottom)
*
* Create an elliptical region.
*
\**************************************************************************/

HRGN
APIENTRY NtGdiCreateEllipticRgn(
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    GDITrace(NtGdiCreateEllipticRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    HRGN hrgn;

    PATHMEMOBJ pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    ERECTL ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  And set the flag that this will be an
// ellipse, to fill it nice:

    EBOX ebox(ercl, TRUE);

    if (ebox.bEmpty())
    {
        RGNMEMOBJ rmoEmpty;

        if (rmoEmpty.bValid())
        {
            hrgn = rmoEmpty.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmoEmpty.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN) 0;
        }
    }
    else if (!bEllipse(pmo, ebox) || !pmo.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN)0;
    }
    else
    {
        RGNMEMOBJ rmo(pmo);         // convert path to region (ALTERNATE)

        if (rmo.bValid())
        {
            rmo.vTighten();

            hrgn = rmo.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN) 0;
        }
    }

    GDITrace(NtGdiCreateEllipticRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreatePolyPolygonRgn(aptl,acptl,cPoly,iFill)
*
* Create a polygonal region with multiple, disjoint polygons.
*
\**************************************************************************/

HRGN
APIENTRY
GreCreatePolyPolygonRgnInternal(
    CONST POINT *aptl,
    CONST INT *acptl,
    int     cPoly,
    int     iFill,
    UINT    cMaxPoints)
{
    GDITrace(GreCreatePolyPolygonRgnInternal, "(%p, %p, %d, %d, %u)\n",
             (va_list)&aptl);

    HRGN hrgn = NULL;

    if ((iFill == ALTERNATE) || (iFill == WINDING))
    {
        PATHMEMOBJ pmo;

        if (pmo.bValid())
        {
            EXFORMOBJ   exfo(IDENTITY);

            ASSERTGDI(exfo.bValid(), "Can\'t make IDENTITY matrix!\n");

            if (bPolyPolygon(pmo,
                             exfo,
                             (PPOINTL) aptl,
                             (PLONG) acptl,
                             cPoly,
                             cMaxPoints))
            {
                RGNMEMOBJ rmo(pmo, iFill);  // convert path to region

                if (rmo.bValid())
                {
                    hrgn = rmo.hrgnAssociate();

                    if (hrgn == (HRGN)0)
                    {
                        rmo.bDeleteRGNOBJ();
                    }
                }
            }
        }
    }

    GDITrace(GreCreatePolyPolygonRgnInternal_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreateRectRgn(xLeft,yTop,xRight,yBottom)
*
* Create a rectangular region.
*
* Called only from user
*
\**************************************************************************/

HRGN APIENTRY GreCreateRectRgn(
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    GDITrace(GreCreateRectRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgn");



    ERECTL   ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmo((BOOL)FALSE);
    HRGN hrgn;

    if (!rmo.bValid())
    {
        hrgn = (HRGN) 0;
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {

        #if NOREORDER_RGN

            //
            // reduce region if coordinates are not well ordered
            //

            if ((xLeft > xRigth) || (yTop > yBottom))
            {
                WARNING("GreCreateRectRgn: region not well ordered");

                xLeft   = 0;
                yTop    = 0;
                xRight  = 0;
                yBottom = 0;
            }

        #else

            //
            // Make the rectangle well ordered.
            //

            ercl.vOrder();

        #endif

        rmo.vSet((RECTL *) &ercl);

        hrgn = (HRGN)HmgInsertObject(rmo.prgnGet(),HMGR_MAKE_PUBLIC,RGN_TYPE);

        if (hrgn == (HRGN)0)
        {
            rmo.bDeleteRGNOBJ();
        }
    }

    rl.vRet((ULONG_PTR)hrgn);

    GDITrace(GreCreateRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}


/******************************Public*Routine******************************\
*
*   NtGdiCreateRectRgn is the same as GreCreateRectRgn except an additional
*   argument is passed in, a shared RECTREGION pointer. This pointer must be
*   put into the shared pointer filed of the handle table for the RGN
*   created. This allows fast user-mode access to RECT regions.
*
* Arguments:
*
*    xLeft       - left edge of region
*    yTop        - top edge of region
*    xRight      - right edge of region
*    yBottom     - bottom edge of region
*    pRectRegion - pointer to user-mode data
*
* Return Value:
*
*   new HRGN or NULL
*
* History:
*
*    20-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HRGN APIENTRY
NtGdiCreateRectRgn(
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    GDITrace(NtGdiCreateRectRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgn");

    ERECTL   ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }


    PVOID pRgnattr = (PRGNATTR)HmgAllocateObjectAttr();
    HRGN  hrgn;

    if (pRgnattr == NULL)
    {
        //
        // memory alloc error
        //

        hrgn = (HRGN) 0;
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {
        RGNMEMOBJ rmo((BOOL)FALSE);

        if (!rmo.bValid())
        {
            hrgn = (HRGN) 0;
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            //
            // Make the rectangle well ordered.
            //

            ercl.vOrder();

            rmo.vSet((RECTL *) &ercl);

            //
            // allocate an object for this region, set
            // the shared pointer if needed
            //

        #if DBG

            RGNLOG rl(rmo.prgn,"RGNOBJ::hrgnAssociate");
            hrgn = (HRGN)HmgInsertObject(rmo.prgn,HMGR_ALLOC_LOCK,RGN_TYPE);
            rl.vRet((ULONG_PTR)hrgn);

        #else

            hrgn = (HRGN)HmgInsertObject(rmo.prgn,HMGR_ALLOC_LOCK,RGN_TYPE);

        #endif

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
                HmgFreeObjectAttr((POBJECTATTR)pRgnattr);
            }
            else
            {
                //
                // set shared rect region pointer and unlock
                //

                PENTRY_FROM_POBJ(rmo.prgn)->pUser = (PDC_ATTR)pRgnattr;
                DEC_EXCLUSIVE_REF_CNT(rmo.prgn);
            }
        }
    }

    rl.vRet((ULONG_PTR)hrgn);

    GDITrace(NtGdiCreateRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreateRectRgnIndirect(prcl)
*
* Create a rectangular region.
*
\**************************************************************************/

HRGN APIENTRY GreCreateRectRgnIndirect(LPRECT prcl)
{
    GDITrace(GreCreateRectRgnIndirect, "(%p)\n", (va_list)&prcl);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgnIndirect",prcl->left,prcl->top,prcl->right);



    if ((prcl == (LPRECT) NULL) || !VALID_SCRPRC(prcl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmo((BOOL)FALSE);
    HRGN hrgn;

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN) 0;
    }
    else
    {
        ((ERECTL *) prcl)->vOrder();    // Make the rectangle well ordered.

        rmo.vSet((RECTL *) prcl);

        hrgn = rmo.hrgnAssociate();

        if (hrgn == (HRGN)0)
        {
            rmo.bDeleteRGNOBJ();
        }
    }
    rl.vRet((ULONG_PTR)hrgn);

    GDITrace(GreCreateRectRgnIndirect_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}



HRGN
APIENTRY
NtGdiCreateRoundRectRgn(
    int xLeft,
    int yTop,
    int xRight,
    int yBottom,
    int xWidth,
    int yHeight
    )
{
    GDITrace(NtGdiCreateRoundRectRgn, "(%d, %d, %d, %d, %d, %d)\n",
             (va_list)&xLeft);

    PATHMEMOBJ pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    ERECTL ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  And set the flag that this will be an
// ellipse, to fill it nice:

    EBOX ebox(ercl, TRUE);
    HRGN hrgn;

    if (ebox.bEmpty())
    {
        RGNMEMOBJ   rmoEmpty;

        if (rmoEmpty.bValid())
        {
            hrgn = rmoEmpty.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmoEmpty.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN)0;
        }
    }
    else if (!bRoundRect(pmo, ebox, xWidth, yHeight) || !pmo.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN)0;
    }
    else
    {
        RGNMEMOBJ rmo(pmo);         // convert path to region (ALTERNATE)

        if (rmo.bValid())
        {
            rmo.vTighten();
            hrgn = rmo.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN)0;
        }
    }

    GDITrace(NtGdiCreateRoundRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}
/******************************Public*Routine******************************\
* NtGdiEqualRgn()
*
* Check if the two regions are equal.
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiEqualRgn(
    HRGN hrgn1,
    HRGN hrgn2
    )
{
    GDITraceHandle2(NtGdiEqualRgn, "(%X, %X)\n", (va_list)&hrgn1, hrgn1, hrgn2);

    BOOL bRet = ERROR;

    RGNOBJAPI   roSrc1(hrgn1,TRUE);
    RGNOBJAPI   roSrc2(hrgn2,TRUE);

    if (roSrc1.bValid() && roSrc2.bValid())
    {
        bRet = roSrc1.bEqual(roSrc2);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL GreFillRgn (hdc,hrgn,hbrush,pac)
*
* Paint the region with the specified brush.
*
\**************************************************************************/

BOOL NtGdiFillRgn(
 HDC    hdc,
 HRGN   hrgn,
 HBRUSH hbrush
 )
{
    GDITraceHandle3(NtGdiFillRgn, "(%X, %X, %X)\n", (va_list)&hdc,
                    hdc, hrgn, hbrush);

    BOOL bRet = FALSE;

    DCOBJ   dco(hdc);
    BOOL    bXform;
    PREGION prgnOrg;

    if (dco.bValid())
    {
        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

        // We may have to scale/rotate the incoming region.

        bXform = !dco.pdc->bWorldToDeviceIdentity();

        RGNOBJAPI ro(hrgn,FALSE);

        if (ro.bValid())
        {
            if (bXform)
            {
                PATHMEMOBJ  pmo;

                if (!pmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                if (!exo.bValid() || !ro.bCreate(pmo, &exo))
                    return(FALSE);

                ASSERTGDI(pmo.bValid(),"GreFillRgn - pmo not valid\n");

                RGNMEMOBJ rmo(pmo);

                if (!rmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

            // this replaces the prgn in ro with the new prgn.  The ro destructor will
            // unlock the handle for hrgn.  We must first delete the prgn though.

                prgnOrg = ro.prgnGet();
                ro.vSetRgn(rmo.prgnGet());
            }

            // If region is null, return TRUE

            if (ro.iComplexity() != NULLREGION)
            {
                // Accumulate bounds.  We can do this before knowing if the operation is
                // successful because bounds can be loose.

                ERECTL   ercl(0, 0, 0, 0);

                ro.vGet_rcl((RECTL *) &ercl);

                if (dco.fjAccum())
                    dco.vAccumulate(ercl);

                if (dco.bHasSurface())
                {
                    dco.pdc->prgnAPI(ro.prgnGet());          // Dirties rgnRao

                    DEVLOCKOBJ dlo(dco);

                    SURFACE  *pSurf = dco.pSurface();

                    if (!dlo.bValid())
                    {
                        bRet = dco.bFullScreen();
                    }
                    else
                    {
                        ercl += dco.eptlOrigin();               // So we know where to draw

                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                        if (eco.erclExclude().bEmpty())
                        {
                            bRet = TRUE;
                        }
                        else
                        {
                            XEPALOBJ  epal(pSurf->ppal());
                            XEPALOBJ  epalDC(dco.ppal());
                            PDEVOBJ   pdo(pSurf->hdev());
                            EBRUSHOBJ ebo;


                            PBRUSH pbrush = (BRUSH *)HmgShareCheckLock((HOBJ)hbrush,
                                                                     BRUSH_TYPE);

                            bRet = FALSE;   // assume we won't succeed

                            //
                            // Substitute the NULL brush if this brush handle
                            // couldn't be locked.
                            //
                            if (pbrush != NULL)
                            {
                                //
                                // in case the brush is cached and the color has changed
                                //
                                bSyncBrushObj(pbrush);

                                ebo.vInitBrush(dco.pdc,
                                               pbrush,
                                               epalDC,
                                               epal,
                                               pSurf);

                                ebo.pColorAdjustment(dco.pColorAdjustment());

                                if (!pbrush->bIsNull())
                                {
                                // Exclude the pointer.

                                    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                                // Get and compute the correct mix mode.

                                    MIX mix = ebo.mixBest(dco.pdc->jROP2(),
                                                          dco.pdc->jBkMode());

                                // Inc the target surface uniqueness

                                    INC_SURF_UNIQ(pSurf);

                                // Issue a call to Paint.

                                    EngPaint(
                                          pSurf->pSurfobj(),
                                          &eco,
                                          &ebo,
                                          &dco.pdc->ptlFillOrigin(),
                                          mix);

                                    bRet = TRUE;
                                }

                                DEC_SHARE_REF_CNT_LAZY0(pbrush);
                            }
                        }
                    }

                    dco.pdc->prgnAPI((PREGION) NULL);     // Dirties rgnRao
                }
                else
                {
                    bRet = TRUE;
                }
            }
            else
            {
                bRet = TRUE;
            }

            if (bXform)
            {
            // need to delete the temporary one and put the old one back in so
            // the handle gets unlocked

                ro.prgnGet()->vDeleteREGION();
                ro.vSetRgn(prgnOrg);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreFrameRgn (hdc,hrgn,hbrush,xWidth,yHeight,pac)
*
* Frame the region and fill with the specified brush.
*
\**************************************************************************/

BOOL APIENTRY NtGdiFrameRgn(
HDC        hdc,
HRGN       hrgn,
HBRUSH     hbrush,
int        xWidth,
int        yHeight
)
{
    GDITraceHandle3(NtGdiFrameRgn, "(%X, %X, %X, %d, %d)\n", (va_list)&hdc,
                    hdc, hrgn, hbrush);

    DCOBJ       dco(hdc);
    RGNOBJAPI   ro(hrgn,TRUE);
    BOOL        bRet = FALSE;


    //
    // Take the absolute value just like Win3 does:
    //

    xWidth  = ABS(xWidth);
    yHeight = ABS(yHeight);

    //
    // do some validation
    //

    if (dco.bValid()    &&
         ro.bValid()    &&
         (xWidth > 0)   &&
         (yHeight > 0))
    {

        if (ro.iComplexity() == NULLREGION)
        {
            bRet = TRUE;
        }
        else
        {
            //
            // Convert the region to a path, scaling/rotating it as we do so.
            //

            PATHMEMOBJ  pmoSpine;
            PATHMEMOBJ  pmoWide;
            EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

            ASSERTGDI(exo.bValid(), "Non valid xform");

            if (pmoSpine.bValid() && pmoWide.bValid())
            {
                if (ro.bCreate(pmoSpine, &exo))
                {
                    EXFORMOBJ exoWiden;
                    LINEATTRS la;
                    MATRIX mx;

                    exoWiden.vInit(&mx, DONT_COMPUTE_FLAGS);

                    //
                    // Initialize line attributes and xform from DC's xform:
                    //

                    pmoSpine.vWidenSetupForFrameRgn(dco, xWidth, yHeight, &exoWiden, &la);

                    //
                    // Make sure we won't expand out of device space before we
                    // widen:
                    //

                    if (pmoWide.bComputeWidenedBounds(pmoSpine, (XFORMOBJ*) &exoWiden, &la) &&
                        pmoWide.bWiden(pmoSpine, (XFORMOBJ*) &exoWiden, &la))
                    {
                        //
                        // Now convert the widened result back into a region:
                        //

                        RGNMEMOBJTMP rmoFill(pmoWide, WINDING);
                        RGNMEMOBJTMP rmoFrame;

                        if (rmoFill.bValid() &&
                            rmoFrame.bValid())
                        {
                            if (dco.pdc->bWorldToDeviceIdentity())
                            {
                                //
                                // We AND the original region and the widened region to get the
                                // frame region:
                                //

                                bRet = rmoFrame.bMerge(rmoFill, ro, gafjRgnOp[RGN_AND]);
                            }
                            else
                            {
                                //
                                // Ugh, we have to transform the original region according to the
                                // world transform before we merge it:
                                //

                                RGNMEMOBJTMP rmo(pmoSpine);

                                bRet = rmo.bValid() &&
                                    rmoFrame.bMerge(rmoFill, rmo, gafjRgnOp[RGN_AND]);
                            }

                            if (bRet)
                            {
                                //
                                // Accumulate bounds.  We can do this before knowing if the operation is
                                // successful because bounds can be loose.
                                //

                                // NOTE - the default return value is now TRUE

                                ERECTL   ercl(0, 0, 0, 0);

                                rmoFrame.vGet_rcl((RECTL *) &ercl);

                                if (dco.fjAccum())
                                {
                                    dco.vAccumulate(ercl);
                                }

                                // in FULLSCREEN mode, exit with success.

                                if (!dco.bFullScreen() && dco.bHasSurface())
                                {
                                    dco.pdc->prgnAPI(rmoFrame.prgnGet());   // Dirties rgnRao

                                    DEVLOCKOBJ dlo(dco);

                                    SURFACE *pSurf = dco.pSurface();

                                    if (!dlo.bValid())
                                    {
                                        dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                        bRet = dco.bFullScreen();
                                    }
                                    else
                                    {
                                        ercl += dco.eptlOrigin();

                                        //
                                        // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                                        //

                                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                                        if (eco.erclExclude().bEmpty())
                                        {
                                            dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                        }
                                        else
                                        {

                                            XEPALOBJ    epal(pSurf->ppal());
                                            XEPALOBJ    epalDC(dco.ppal());
                                            PDEVOBJ     pdo(pSurf->hdev());
                                            EBRUSHOBJ   ebo;

                                            //
                                            // NOTE - the default return value
                                            // is now FALSE;

                                            PBRUSH pbrush = (BRUSH *)HmgShareCheckLock((HOBJ)hbrush, BRUSH_TYPE);

                                            bRet = FALSE;

                                            if (pbrush == NULL)
                                            {
                                                dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                            }
                                            else
                                            {
                                                //
                                                // in case the brush is cached and the color has changed
                                                //
                                                bSyncBrushObj (pbrush);

                                                ebo.vInitBrush(dco.pdc,
                                                               pbrush,
                                                               epalDC,
                                                               epal,
                                                               pSurf);

                                                ebo.pColorAdjustment(dco.pColorAdjustment());

                                                if (pbrush->bIsNull())
                                                {
                                                    dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                                }
                                                else
                                                {
                                                    //
                                                    // Exclude the pointer.
                                                    //

                                                    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                                                    //
                                                    // Get and compute the correct mix mode.
                                                    //

                                                    MIX mix = ebo.mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());

                                                    //
                                                    // Inc the target surface uniqueness
                                                    //

                                                    INC_SURF_UNIQ(pSurf);

                                                    //
                                                    // Issue a call to Paint.
                                                    //

                                                    EngPaint(
                                                          pSurf->pSurfobj(),                // Destination surface.
                                                          &eco,                             // Clip object.
                                                          &ebo,                             // Realized brush.
                                                          &dco.pdc->ptlFillOrigin(),        // Brush origin.
                                                          mix);                             // Mix mode.

                                                    dco.pdc->prgnAPI(NULL);                 // Dirties rgnRao

                                                    bRet = TRUE;
                                                }

                                                DEC_SHARE_REF_CNT_LAZY0(pbrush);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG GreGetRgnBox(hrgn,prcl)
*
* Get the bounding box of the region.
*
\**************************************************************************/

int
APIENTRY
GreGetRgnBox(
    HRGN   hrgn,
    LPRECT prcl)
{
    GDITraceHandle(GreGetRgnBox, "(%X, %p)\n", (va_list)&hrgn, hrgn);

    int iret = ERROR;

    RGNOBJAPI ro(hrgn,TRUE);

    if ((prcl != NULL) &&
        (ro.bValid()))
    {
        ro.vGet_rcl((RECTL *) prcl);

        iret = (int)ro.iComplexity();

        if (iret == NULLREGION)
        {
            //
            // Be compatible with Win 3.1 [donalds] 02-Jun-1993
            //

            prcl->left   = 0;
            prcl->top    = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
        }
    }

    return(iret);
}

/******************************Public*Routine******************************\
* BOOL GreInvertRgn(hdc,hrgn)
*
* Invert the colors in the given region.
*
\**************************************************************************/

BOOL NtGdiInvertRgn(
 HDC  hdc,
 HRGN hrgn)
{
    GDITraceHandle2(NtGdiInvertRgn, "(%X, %X)\n", (va_list)&hdc, hdc, hrgn);

    DCOBJ   dco(hdc);
    BOOL    bXform;
    PREGION prgnOrg;
    BOOL    bRet = FALSE;


    if (dco.bValid())
    {
        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

        //
        // We may have to scale/rotate the incoming region.
        //

        bXform = !dco.pdc->bWorldToDeviceIdentity();

        RGNOBJAPI   ro(hrgn,TRUE);

        if (ro.bValid())
        {
            if (bXform)
            {
                PATHMEMOBJ  pmo;

                if (!pmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }
                if (!exo.bValid() || !ro.bCreate(pmo, &exo))
                    return(FALSE);

                RGNMEMOBJ   rmo(pmo);

                if (!rmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                prgnOrg = ro.prgnGet();
                ro.vSetRgn(rmo.prgnGet());
            }

            //
            // If region is null, return TRUE
            //

            if (ro.iComplexity() != NULLREGION)
            {
                // Accumulate bounds.  We can do this before knowing if the operation is
                // successful because bounds can be loose.

                ERECTL   ercl;

                ro.vGet_rcl((RECTL *) &ercl);

                if (dco.fjAccum())
                    dco.vAccumulate(ercl);

                if (dco.bHasSurface())
                {
                    dco.pdc->prgnAPI(ro.prgnGet());             // Dirties rgnRao

                    DEVLOCKOBJ dlo(dco);

                    SURFACE  *pSurf = dco.pSurface();

                    if (!dlo.bValid())
                    {
                        bRet = dco.bFullScreen();
                    }
                    else
                    {
                        ercl += dco.eptlOrigin();

                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                        if (!eco.erclExclude().bEmpty())
                        {
                            PDEVOBJ pdo(pSurf->hdev());

                        // Exclude the pointer.

                            DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                        // Inc the target surface uniqueness

                            INC_SURF_UNIQ(pSurf);

                        // Issue a call to Paint.

                            EngPaint(
                                  pSurf->pSurfobj(),                // Destination surface.
                                  &eco,                             // Clip object.
                                  (BRUSHOBJ *) NULL,                // Realized brush.
                                  (POINTL *) NULL,                  // Brush origin.
                                  0x00000606);                      // R2_NOT
                        }

                        bRet = TRUE;
                    }

                    dco.pdc->prgnAPI((PREGION)NULL);     // Dirties rgnRao
                }
                else
                {
                    bRet = TRUE;
                }
            }
            else
            {
                bRet = TRUE;
            }


            if (bXform)
            {
            // need to delete the temporary one and put the old one back in so
            // the handle gets unlocked

                ro.prgnGet()->vDeleteREGION();
                ro.vSetRgn(prgnOrg);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG GreOffsetRgn(hrgn,x,y)
*
* Offset the given region.
*
\**************************************************************************/

int
APIENTRY
GreOffsetRgn(
    HRGN hrgn,
    int  x,
    int  y)
{
    GDITraceHandle(GreOffsetRgn, "(%X, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI ro(hrgn,FALSE);
    POINTL    ptl;
    int       iRet = ERROR;

    ptl.x = x;
    ptl.y = y;

    if (ro.bValid())
    {
        if (ro.bOffset(&ptl))
        {
            iRet = ro.iComplexity();
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* BOOL GrePtInRegion(hrgn,x,y)
*
* Is the point in the region?
*
\**************************************************************************/

BOOL APIENTRY GrePtInRegion(
 HRGN hrgn,
 int x,
 int y)
{
    GDITraceHandle(GrePtInRegion, "(%X, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI ro(hrgn,TRUE);

    if (!ro.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return((BOOL) ERROR);
    }

    POINTL  ptl;

    ptl.x = x;
    ptl.y = y;

    return(ro.bInside(&ptl) == REGION_POINT_INSIDE);
}

/******************************Public*Routine******************************\
* BOOL GreRectInRegion(hrgn,prcl)
*
* Is any part of the rectangle in the region?
*
\**************************************************************************/

BOOL
APIENTRY
GreRectInRegion(
    HRGN   hrgn,
    LPRECT prcl)
{
    GDITraceHandle(GreRectInRegion, "(%X, %p)\n", (va_list)&hrgn, hrgn);

    BOOL bRet = ERROR;
    RGNOBJAPI   ro(hrgn,TRUE);

    if (prcl &&
        (ro.bValid()))
    {
        bRet = (ro.bInside((RECTL *) prcl) == REGION_RECT_INTERSECT);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* VOID GreSetRectRgn(hrgn,xLeft,yTop,xRight,yBottom)
*
* Set the region to be the specified rectangle
*
\**************************************************************************/

BOOL
APIENTRY
GreSetRectRgn(
    HRGN hrgn,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom)
{
    GDITraceHandle(GreSetRectRgn, "(%X, %d, %d, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI   ro(hrgn,FALSE);
    BOOL bRet = ERROR;

    if (ro.bValid())
    {
        ERECTL   ercl(xLeft, yTop, xRight, yBottom);

        if (VALID_SCRPRC((RECTL *) &ercl))
        {
            ercl.vOrder();       // Make the rectangle well ordered.

            ro.vSet((RECTL *) &ercl);

            bRet = TRUE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* LONG GreExcludeClipRect(hdc,xLeft,yTop,xRight,yBottom)
*
* Subtract the rectangle from the current clip region
*
\**************************************************************************/

int APIENTRY GreExcludeClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom)
{
    GDITraceHandle(GreExcludeClipRect, "(%X, %d, %d, %d, %d)\n", (va_list)&hdc,
                   hdc);

    int     iRet;
    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        // For speed, test for rotation upfront.

        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);
        ERECTL      ercl(xLeft, yTop, xRight, yBottom);

        if (!exo.bRotation())
        {
            exo.vOrder(*(RECTL *)&ercl);
            exo.bXform(ercl);

            iRet = (int)dco.pdc->iCombine((RECTL *) &ercl,RGN_DIFF);
        }
        else if (!VALID_SCRPRC((RECTL *) &ercl))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            iRet = ERROR;
        }
        else
        {
            iRet = (int) dco.pdc->iCombine(&exo, (RECTL *) &ercl,RGN_DIFF);
        }

        if (iRet > NULLREGION)
        {
            iRet = COMPLEXREGION;
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        iRet = ERROR;
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* LONG GreGetAppClipBox(hdc,prcl)
*
* Get the bounding box of the clip region
*
\**************************************************************************/

int APIENTRY GreGetAppClipBox(
     HDC    hdc,
     LPRECT prcl)
{
    GDITraceHandle(GreGetAppClipBox, "(%X, %p)\n", (va_list)&hdc, hdc);

    DCOBJ   dor(hdc);
    int     iRet;
    int iSaveLeft;

    if (dor.bValid())
    {
        DEVLOCKOBJ  dlo(dor);

        if (!dlo.bValid())
        {
            if (dor.bFullScreen())
            {
                prcl->left = 0;             // Make it a 'simple' empty rectangle
                prcl->right = 0;
                prcl->top = 0;
                prcl->bottom = 0;
                return(COMPLEXREGION);
            }
            else
            {
                return(ERROR);
            }
        }

        RGNOBJ  ro(dor.prgnEffRao());

        ro.vGet_rcl((RECTL *) prcl);

        //
        // return to logical coordinates
        //

        if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
        {
            prcl->left = 0;             // Make it a 'simple' empty rectangle
            prcl->right = 0;
            prcl->top = 0;
            prcl->bottom = 0;

            iRet = NULLREGION;
        }
        else
        {
            EXFORMOBJ xfoDtoW(dor, DEVICE_TO_WORLD);

            if (xfoDtoW.bValid())
            {
                *(ERECTL *)prcl -= dor.eptlOrigin();

                if (!xfoDtoW.bRotation())
                {
                    if (xfoDtoW.bXform(*(ERECTL *)prcl))
                    {
                        iRet = ro.iComplexity();

                        //
                        // Transforms with negative scale can give
                        // a prcl that is not in vOrder.
                        //

                        //
                        // This is the correct fix, but some apps require the
                        // previous bad behaviour.
                        //
                        //((ERECTL *)prcl)->vOrder();
                    }
                    else
                    {
                        iRet = ERROR;
                    }
                }
                else
                {
                    POINTL aptl[4];

                    aptl[0].x = prcl->left;
                    aptl[0].y = prcl->top;
                    aptl[1].x = prcl->right;
                    aptl[1].y = prcl->top;
                    aptl[2].x = prcl->left;
                    aptl[2].y = prcl->bottom;
                    aptl[3].x = prcl->right;
                    aptl[3].y = prcl->bottom;

                    xfoDtoW.bXform(aptl, 4);

                    prcl->left   = MIN4(aptl[0].x, aptl[1].x, aptl[2].x, aptl[3].x);
                    prcl->top    = MIN4(aptl[0].y, aptl[1].y, aptl[2].y, aptl[3].y);
                    prcl->right  = MAX4(aptl[0].x, aptl[1].x, aptl[2].x, aptl[3].x);
                    prcl->bottom = MAX4(aptl[0].y, aptl[1].y, aptl[2].y, aptl[3].y);

                    iRet = COMPLEXREGION;
                }
            }
            else
            {
                iRet = ERROR;
            }
        }
        if ((iRet != ERROR) && MIRRORED_DC(dor.pdc) && (prcl->left > prcl->right)) {
            iSaveLeft   = prcl->left;
            prcl->left  = prcl->right;
            prcl->right = iSaveLeft;
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        iRet = ERROR;
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* int GreGetRandomRgn(hdc,hrgn,iNum)
*
* Copy the specified region into the handle provided
*
\**************************************************************************/

int GreGetRandomRgn(
HDC  hdc,
HRGN hrgn,
int  iNum)
{
    GDITraceHandle2(GreGetRandomRgn, "(%X, %X, %d)\n", (va_list)&hdc, hdc, hrgn);

    DCOBJ   dor(hdc);
    PREGION prgnSrc1, prgnSrc2;
    int     iMode = RGN_COPY;

    int iRet = -1;

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }
    else
    {
        DEVLOCKOBJ  dlo(dor);

        switch(iNum)
        {
        case 1:
            prgnSrc1 = dor.pdc->prgnClip();
            break;

        case 2:
            prgnSrc1 = dor.pdc->prgnMeta();
            break;

        case 3:
            prgnSrc1 = dor.pdc->prgnClip();
            prgnSrc2 = dor.pdc->prgnMeta();

            if (prgnSrc1 == NULL)           // prgnSrc1 == 0, prgnSrc2 != 0
            {
                prgnSrc1 = prgnSrc2;
            }
            else if (prgnSrc2 != NULL)      // prgnSrc1 != 0, prgnSrc2 != 0
            {
                iMode = RGN_AND;
            }
            break;

        case 4:
            ASSERTDEVLOCK(dor.pdc);
            prgnSrc1 = dor.pdc->prgnVis();
            break;

        default:
            prgnSrc1 = NULL;
        }

        if (prgnSrc1 == NULL)
        {
            iRet = 0;
        }
        else
        {
            RGNOBJAPI ro(hrgn,FALSE);

            if (ro.bValid())
            {
                RGNOBJ ro1(prgnSrc1);

                if (iMode == RGN_COPY)
                {
                    if (ro.bCopy(ro1))
                    {
                         // For a redirection DC, the surface originates at the
                         // redirected window origin. For compatibility reasons,
                         // we must return the visrgn in screen coordinates.

                        if (iNum == 4 && dor.pdc->bRedirection())
                        {
                            POINTL ptl;

                            if (UserGetRedirectedWindowOrigin(hdc,
                                    (LPPOINT)&ptl) && ro.bOffset(&ptl))
                            {
                                iRet = 1;
                            }
                        }
                        else
                        {
                            iRet = 1;
                        }
                    }
                }
                else
                {
                    RGNOBJ ro2(prgnSrc2);

                    if (ro.iCombine(ro1,ro2,iMode) != RGN_ERROR)
                        iRet = 1;
                }
            }
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* LONG GreIntersectClipRect(hdc,xLeft,yTop,xRight,yBottom)
*
* AND the rectangle with the current clip region
*
\**************************************************************************/

int APIENTRY GreIntersectClipRect(
HDC hdc,
int xLeft,
int yTop,
int xRight,
int yBottom)
{
    GDITraceHandle(GreIntersectClipRect, "(%X, %d, %d, %d, %d)\n", (va_list)&hdc,
                   hdc);

    DCOBJ   dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR);
    }

    EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);
    ERECTL      ercl(xLeft, yTop, xRight, yBottom);

// For speed, test for rotation up front.

    int iRet;

    if (!exo.bRotation())
    {
        exo.vOrder(*(RECTL *)&ercl);
        exo.bXform(ercl);

        iRet = (int)dco.pdc->iCombine((RECTL *) &ercl,RGN_AND);
    }
    else if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        iRet = ERROR;
    }
    else
    {
        iRet = (int)dco.pdc->iCombine(&exo, (RECTL *) &ercl,RGN_AND);
    }

    if (iRet > NULLREGION)
        iRet = COMPLEXREGION;

    return(iRet);
}

 /******************************Public*Routine******************************\
* INT NtGdiOffsetClipRgn(hdc,x,y)
*
* Offset the current clip region
*
\**************************************************************************/

int APIENTRY
NtGdiOffsetClipRgn(
 HDC  hdc,
 int x,
 int y)
{
    GDITraceHandle(NtGdiOffsetClipRgn, "(%X, %d, %d)\n", (va_list)&hdc, hdc);

    DCOBJ   dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR);
    }

    PREGION prgn = dor.pdc->prgnClip();

    if (prgn == NULL)
        return(SIMPLEREGION);

// if this region has multiple references (saved levels) we need to duplicate
// it and modify the copy.

    if (prgn->cRefs > 1)
    {
        RGNOBJ ro(prgn);

        RGNMEMOBJ rmo(ro.sizeRgn());

        if (!rmo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR);
        }

        rmo.vCopy(ro);
        prgn = rmo.prgnGet();

        rmo.vSelect(hdc);
        ro.vUnselect();

        dor.pdc->prgnClip(prgn);

    }

    RGNOBJ ro(prgn);

    EPOINTL  eptl(x, y);

// Transform the point from Logical to Device

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);

    if (!xfo.bXform(*((EVECTORL *) &eptl)) || !ro.bOffset((PPOINTL)&eptl))
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(ERROR);
    }

    dor.pdc->vReleaseRao();

    dor.pdc->vUpdate_VisRect(dor.pdc->prgnVis());

    return(ro.iComplexity());
}


/******************************Public*Routine******************************\
* BOOL GrePtVisible(hdc,x,y)
*
* Is the point in the current clip region?
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPtVisible(
    HDC  hdc,
    int x,
    int y)
{
    DCOBJ dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR_BOOL);
    }

    DEVLOCKOBJ dlo(dor);

    if (!dlo.bValid())
        return(REGION_POINT_OUTSIDE);

    RGNOBJ  ro(dor.prgnEffRao());

    EPOINTL  eptl(x, y);

// Transform the point from Logical to Screen

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);
    xfo.bXform(eptl);

    eptl += dor.eptlOrigin();

    return(ro.bInside((PPOINTL)&eptl) == REGION_POINT_INSIDE);
}

/******************************Public*Routine******************************\
* BOOL GreRectVisible(hdc,prcl)
*
* Is the rectangle in the current clip region?
*
\**************************************************************************/

BOOL APIENTRY GreRectVisible(
HDC    hdc,
LPRECT prcl)
{
    DCOBJ   dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR_BOOL);
    }

    DEVLOCKOBJ dlo(dor);

    if (!dlo.bValid())
        return(REGION_RECT_OUTSIDE);

    RGNOBJ  ro(dor.prgnEffRao());

    ERECTL  ercl = *((ERECTL *) prcl);

// Transform the rectangle from Logical to Screen

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);

// If there is no rotation in the transform, just call bInside().

    if (!xfo.bRotation())
    {
        xfo.vOrder(*(RECTL *)&ercl);
        xfo.bXform(ercl);

        ercl += dor.eptlOrigin();

        BOOL   bIn = ro.bInside((RECTL *) &ercl);

        return(bIn == REGION_RECT_INTERSECT);
    }

// Convert the rectangle to a parallelogram and merge it with the Rao.
// If there is anything left, the call succeeded.

    POINTL  aptl[4];

    aptl[0].x = prcl->left;
    aptl[0].y = prcl->top;
    aptl[1].x = prcl->right;
    aptl[1].y = prcl->top;
    aptl[2].x = prcl->right;
    aptl[2].y = prcl->bottom;
    aptl[3].x = prcl->left;
    aptl[3].y = prcl->bottom;

// Create a path, and draw the parallelogram.

    PATHMEMOBJ  pmo;
    BOOL bRes;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        bRes = ERROR_BOOL;
    }
    else if (!pmo.bMoveTo(&xfo, &aptl[0]) ||
             !pmo.bPolyLineTo(&xfo, &aptl[1], 3) ||
             !pmo.bCloseFigure())
    {
        bRes = ERROR_BOOL;
    }
    else
    {
    // Now, convert it back into a region.

        RGNMEMOBJTMP rmoPlg(pmo, ALTERNATE);
        RGNMEMOBJTMP rmo;

        if (!rmoPlg.bValid() || !rmo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            bRes = ERROR_BOOL;
        }
        else
        {
            if (!rmo.bMerge(ro, rmoPlg, gafjRgnOp[RGN_AND]) ||
                (rmo.iComplexity() == NULLREGION))
            {
                bRes = (BOOL)REGION_RECT_OUTSIDE;
            }
            else
            {
                bRes = (BOOL)REGION_RECT_INTERSECT;
            }
        }
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* int GreExtSelectClipRgn(hdc,hrgn,iMode)
*
* Merge the region into current clip region
*
\**************************************************************************/

int
GreExtSelectClipRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iMode)
{
    GDITraceHandle2(GreExtSelectClipRgn, "(%X, %X, %d)\n", (va_list)&hdc,
                    hdc, hrgn);

    int iRet = RGN_ERROR;
    BOOL bSame = FALSE;

    if (((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        DCOBJ   dco(hdc);
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            if (hrgn != (HRGN)0)
            {
                RGNOBJAPI ro(hrgn,TRUE);

                if (ro.bValid())
                {
                    iRet = dco.pdc->iSelect(ro.prgnGet(),iMode);

                    if (iRet != RGN_ERROR)
                    {
                        DEVLOCKOBJ dlo(dco);
                        RGNOBJ ro(dco.prgnEffRao());
                        iRet = ro.iComplexity();
                    }
                }

            }
            else
            {
                if (iMode == RGN_COPY)
                {
                    iRet = dco.pdc->iSelect((PREGION)NULL,iMode);

                    if (iRet != RGN_ERROR)
                    {
                        DEVLOCKOBJ dlo(dco);
                        RGNOBJ roVis(dco.pdc->prgnVis());
                        iRet = roVis.iComplexity();
                    }
                }
            }
        }
    }


    return(iRet);
}


/******************************Public*Routine******************************\
*   SelectClip from bathcing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    26-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

GreExtSelectClipRgnLocked(
    XDCOBJ    &dco,
    PRECTL    prcl,
    int       iMode)
{
    int  iRet = RGN_ERROR;
    BOOL bNullHrgn = iMode & REGION_NULL_HRGN;

    iMode &= ~REGION_NULL_HRGN;

    if (((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            //
            // iFlag specifies a null hrgn
            //

            if (!bNullHrgn)
            {
                //
                // check if current region is the same as new
                // hrgn
                //

                BOOL bSame = FALSE;

                RGNOBJ roClipOld(dco.pdc->prgnClip());

                if (roClipOld.bValid())
                {
                    if (roClipOld.bRectl())
                    {
                        RECTL rclOld;
                        roClipOld.vGet_rcl(&rclOld);

                        if (
                             (prcl->left   == rclOld.left)  &&
                             (prcl->top    == rclOld.top)   &&
                             (prcl->right  == rclOld.right) &&
                             (prcl->bottom == rclOld.bottom)
                           )
                        {
                            RGNOBJ ro(dco.prgnEffRao());
                            iRet = ro.iComplexity();
                            bSame = TRUE;
                        }
                    }
                }

                //
                // regions don't match, must select new region into DC
                //

                if (!bSame)
                {
                    RGNMEMOBJTMP ro(FALSE);

                    if (ro.bValid())
                    {
                        ro.vSet(prcl);

                        iRet = dco.pdc->iSelect(ro.prgnGet(),iMode);

                        //
                        // need to update RAO
                        //

                        if (dco.pdc->bDirtyRao())
                        {
                            if (!dco.pdc->bCompute())
                            {
                                WARNING("bCompute fails in GreExtSelectClipRgnLocked");
                            }
                        }

                        if (iRet != RGN_ERROR)
                        {
                            RGNOBJ ro(dco.prgnEffRao());
                            iRet = ro.iComplexity();
                        }
                    }
                }
            }
            else
            {
                if (iMode == RGN_COPY)
                {
                    iRet = dco.pdc->iSelect((PREGION)NULL,iMode);

                    //
                    // need to update RAO
                    //

                    if (dco.pdc->bDirtyRao())
                    {
                        if (!dco.pdc->bCompute())
                        {
                            WARNING("bCompute fails in GreExtSelectClipRgnLocked");
                        }
                    }

                    if (iRet != RGN_ERROR)
                    {
                        RGNOBJ roVis(dco.pdc->prgnVis());
                        iRet = roVis.iComplexity();
                    }
                }
            }
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* int GreStMetaRgn(hdc,hrgn,iMode)
*
* Merge the region into current meta region
*
\**************************************************************************/

int GreSetMetaRgn(
    HDC hdc)
{
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(ERROR);
    }

    return(dco.pdc->iSetMetaRgn());
}

/******************************Public*Routine******************************\
* GreGetRegionData
*
* Retreives the region data
*
* History:
*  5-Dec-1997 -by- Samer Arafeh   [samera]
* Wrote it.
\**************************************************************************/
DWORD
GreGetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITraceHandle(GreGetRegionData, "(%X, %u, %p)\n", (va_list)&hrgn, hrgn);

    DWORD       nSize;
    DWORD       nRectangles;
    DWORD       nRgnSize;  // size of buffer of rectangles
    RGNOBJAPI   ro(hrgn,TRUE);

    if (ro.bValid())
    {
        //
        // just return size if buffer is NULL
        //

        nRgnSize = ro.sizeSave();
        nSize = nRgnSize + sizeof(RGNDATAHEADER);

        if (lpRgnData != (LPRGNDATA) NULL)
        {
            if (nSize > nCount)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                nSize = ERROR;
            }
            else
            {
                nRectangles = (nSize - sizeof(RGNDATAHEADER)) / sizeof(RECTL);

                lpRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
                lpRgnData->rdh.iType  = RDH_RECTANGLES;
                lpRgnData->rdh.nCount = nRectangles;
                lpRgnData->rdh.nRgnSize = nRgnSize;
                if (nRectangles != 0)
                {
                    ro.vGet_rcl((RECTL *) &lpRgnData->rdh.rcBound);
                }
                else
                {
                    lpRgnData->rdh.rcBound.left = 0;
                    lpRgnData->rdh.rcBound.top = 0;
                    lpRgnData->rdh.rcBound.right = 0;
                    lpRgnData->rdh.rcBound.bottom = 0;
                }
                ro.vDownload((PVOID) &lpRgnData->Buffer);
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        nSize = ERROR;
    }

    return(nSize);
}


/******************************Public*Routine******************************\
* DWORD NtGdiGetRegionData(hrgn, nCount, lpRgnData)
*
* Compute size of buffer/copy region data to buffer
*
\**************************************************************************/
DWORD
NtGdiGetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITraceHandle(NtGdiGetRegionData, "(%X, %u, %p)\n", (va_list)&hrgn, hrgn);

    DWORD     nSize=!ERROR;
    ULONG     ulTemp[QUANTUM_REGION_SIZE/2];
    LPRGNDATA prgnTemp=NULL;

    //
    // If it is valid user pointer, let's copy into
    // into kernel memory (we don't know what the user might do with this memory)
    //

    if (lpRgnData)
    {
        if (nCount <= sizeof(ulTemp))
            prgnTemp = (PRGNDATA) ulTemp;
        else
            prgnTemp = (PRGNDATA)AllocFreeTmpBuffer(nCount);

        if (!prgnTemp)
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            nSize = ERROR;
        }
    }

    //
    // Check if allocation (if happened) is ok ?
    //

    if (nSize != ERROR)
    {
        nSize = GreGetRegionData( hrgn , nCount , prgnTemp );


        //
        // Copy retreived data to user-buffer
        //

        if (lpRgnData && (nSize != ERROR))
        {
            __try
            {
                ProbeForWrite(lpRgnData,nSize, sizeof(DWORD));
                RtlCopyMemory( lpRgnData , prgnTemp , nSize );
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                nSize = ERROR;
            }
        }
    }


    //
    // And free the kernel memory, if allocated
    //

    if (prgnTemp && (prgnTemp != (PRGNDATA)&ulTemp[0]))
    {
        FreeTmpBuffer(prgnTemp);
    }


    return(nSize);
}

/******************************Public*Routine******************************\
* HRGN GreExtCreateRegion(lpXform, nCount, lpRgnData)
*
* Create a region from a region data buffer
*
\**************************************************************************/


HRGN
GreExtCreateRegion(
    XFORML   *lpXform,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITrace(GreExtCreateRegion, "(%p, %u, %p)\n", (va_list)&lpXform);

    ASSERTGDI(nCount >= sizeof(RGNDATAHEADER), "GreExtCreateRegion: passed invalid count");

    DWORD   nSize = lpRgnData->rdh.dwSize;
    ULONG   cRect = lpRgnData->rdh.nCount;

    if (nSize != sizeof(RGNDATAHEADER))
    {
        WARNING("GreExtCreateRegion: bad nSize");
        return((HRGN) 0);
    }

    if (cRect > ((MAXULONG - sizeof(RGNDATAHEADER)) / sizeof (RECTL)))
    {
        // cRect is too large, which will cause the computation for nSize below to overflow.
        return ((HRGN) 0);
    }

    nSize += (cRect * sizeof(RECTL));

    if (nSize > nCount)
        return((HRGN) 0);

    // At this point we have what looks like a valid header, and a buffer that
    // is at least big enough to contain all the data for a region.  Create a
    // region to contain it and then attempt to upload the data into the region.


    RGNMEMOBJ rmo;

    if(!rmo.bValid())
    {
        rmo.bDeleteRGNOBJ();
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    RECTL *prcl = (RECTL *)lpRgnData->Buffer;

    if(!rmo.bSet(cRect, prcl))
    {
        rmo.bDeleteRGNOBJ();
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    HRGN hrgn;

    if ((lpXform == NULL) || (rmo.iComplexity() == NULLREGION))
    {
        //
        // Create the proper bounding box and make it long lived
        //

        rmo.vTighten();

        hrgn = rmo.hrgnAssociate();

        if (hrgn == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }

        GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

        return(hrgn);
    }

    //
    // Convert the XFORM to a MATRIX
    //

    MATRIX  mx;

    vConvertXformToMatrix(lpXform, &mx);

    //
    // Scale it to FIXED notation.
    //

    mx.efM11.vTimes16();
    mx.efM12.vTimes16();
    mx.efM21.vTimes16();
    mx.efM22.vTimes16();
    mx.efDx.vTimes16();
    mx.efDy.vTimes16();
    mx.fxDx *= 16;
    mx.fxDy *= 16;

    EXFORMOBJ   exo(&mx, XFORM_FORMAT_LTOFX | COMPUTE_FLAGS);

    if (!exo.bValid())
    {
        rmo.bDeleteRGNOBJ();
        return((HRGN) 0);
    }

    //
    // If the xform is the identity, we don't have to do anything.
    //

    if (exo.bIdentity())
    {
        //
        // Create the proper bounding box and make it long lived
        //

        rmo.vTighten();
        hrgn = rmo.hrgnAssociate();

        if (hrgn == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }

        GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

        return(hrgn);
    }

    //
    // Create a path from the region
    //

    PATHMEMOBJ  pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        rmo.bDeleteRGNOBJ();
        return((HRGN) 0);
    }

    BOOL bSuccess = rmo.bCreate(pmo, &exo);

    //
    // done with the region, delete it now.
    //

    rmo.bDeleteRGNOBJ();

    if (!bSuccess)
    {
        return((HRGN) 0);
    }

    //
    // Create a region from the path
    //

    RGNMEMOBJTMP rmoPath(pmo);

    if (!rmoPath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmoFinal;

    if (!rmoFinal.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    //
    // coelece the region
    //

    rmoFinal.iReduce(rmoPath);

    //
    // Create the proper bounding box and make it long lived
    //

    rmoFinal.vTighten();

    hrgn = rmoFinal.hrgnAssociate();

    if (hrgn == NULL)
    {
        rmoFinal.bDeleteRGNOBJ();
    }

    GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* BOOL GreIntersectVisRect(hdc, xLeft, yTop, xRight, yBottom)
*
* Intersect (AND) the rectangle with the vis region
*
* Warnings:
*   This is a PRIVATE USER API.
*
\**************************************************************************/

BOOL GreIntersectVisRect(
 HDC hdc,
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    BOOL bRes = FALSE;

    //
    // fail bad ordered rectangles
    //
    if ((xLeft>=xRight) || (yTop>=yBottom))
    {
        return(FALSE);
    }

    //
    // fail bad coordinates
    //
    if ((xLeft<MIN_REGION_COORD)  ||
        (xRight>MAX_REGION_COORD) ||
        (yTop<MIN_REGION_COORD)   ||
        (yBottom>MAX_REGION_COORD))
    {
        return(FALSE);
    }

    DCOBJA  dov(hdc);               // Use ALTLOCK

    if (dov.bValid())    // don't trust them the DC to be valid
    {
        // We invoke the 'dlo(po)' devlock form instead of 'dlo(dco)'
        // to avoid the bCompute that the latter does:

        PDEVOBJ po(dov.hdev());
        DEVLOCKOBJ dlo(po);

        ASSERTDEVLOCK(dov.pdc);

        if (dlo.bValid())
        {
            RGNOBJ  ro(dov.pdc->prgnVis());

            ERECTL  ercl(xLeft, yTop, xRight, yBottom);

            RGNMEMOBJTMP rmo;
            RGNMEMOBJTMP rmo2(ro.sizeRgn());

            if (!rmo.bValid() || !rmo2.bValid())
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            }
            else
            {
                rmo.vSet((RECTL *) &ercl);
                rmo2.vCopy(ro);

                if (ro.iCombine(rmo, rmo2, RGN_AND) != ERROR)
                {
                    dov.pdc->prgnVis(ro.prgnGet());
                    ro.prgnGet()->vStamp();
                    dov.pdc->vReleaseRao();

                    bRes = TRUE;
                }
            }
        }

        RGNLOG rl((HRGN) dov.pdc->prgnVis(),0,"GreIntersectVisRect",(ULONG_PTR)hdc);
        rl.vRet((ULONG_PTR)bRes);
    }
    #if DBG
    else
    {
        //
        // USER may send a NULL hdc in low memory situations.
        // Just print a warning for those situations, but rip
        // for other bad handles (i.e., USER should figure out
        // why they passed us a bad handle).
        //

        if (hdc)
        {
            RIP("GDISRV!GreSelectVisRgn: Bad hdc\n");
        }
        else
        {
            WARNING("GDISRV!GreSelectVisRgn: hdc NULL\n");
        }
    }
    #endif

    return(bRes);
}

#if DBG || defined(PRERELEASE)
/******************************Public*Routine******************************\
* GreValidateVisrgn()
*
* History:
*  10-Dec-1998 -by-  Vadim Gorokhovsky [vadimg]
* Wrote it.
\**************************************************************************/

VOID
GreValidateVisrgn(
    HDC hdc,
    BOOL bValidateVisrgn
    )
{
    DCOBJA dco(hdc);

    if (dco.bValid())
    {
        dco.pdc->vValidateVisrgn(bValidateVisrgn);

        if (bValidateVisrgn)
        {
            PDEVOBJ pdo(dco.hdev());
            SURFACE *pSurf = dco.pSurface();
            REGION *prgn = dco.pdc->prgnVis();

            if (pdo.bValid() && !pdo.bMetaDriver() && pSurf && prgn)
            {
                BOOL bIsOK = ((pSurf->sizl().cx >= prgn->rcl.right) &&
                              (pSurf->sizl().cy >= prgn->rcl.bottom)&&
                              (prgn->rcl.left >= 0) &&
                              (prgn->rcl.top >= 0));

                FREASSERTGDI(bIsOK, "Rgn size is bigger than surface size");
            }
        }
    }
}

#endif

/******************************Public*Routine******************************\
* GreIsValidRegion()
*
* History:
*  08-Dec-2001 -by-  Mohamed Sadek [msadek]
* Wrote it.
\**************************************************************************/
BOOL
GreIsValidRegion(
    HRGN   hrgn)
{
    RGNOBJAPI ro(hrgn, TRUE);

    return ro.bValid();
}

/******************************Public*Routine******************************\
* HRGN GreSelectVisRgn(hdc,hrgn,fl)
*
* Select the region as the new vis region
*
* flags - only one of these may be passed in
*
*   SVR_COPYNEW   - make a copy of region passed in, deletes the old one
*   SVR_DELETEOLD - use the select rgn, delete the old one
*   SVR_SWAP      - swaps the contents of the hrgn and the visrgn
*
* Warnings:
*   This is a PRIVATE USER API.
*
\**************************************************************************/

BOOL
GreSelectVisRgn(
    HDC               hdc,
    HRGN              hrgn,
    VIS_REGION_SELECT fl)
{
    RGNLOG rl(hrgn,NULL,"GreSelectVisRgn",(ULONG_PTR)hdc,(ULONG_PTR)fl);

    ASSERTGDI((fl == SVR_COPYNEW  ) ||
              (fl == SVR_DELETEOLD) ||
              (fl == SVR_SWAP     ), "GreSelectVisRgn - invalid fl\n");

    BOOL bRet;

    //
    // Share Lock DC
    //

    DCOBJA   dco(hdc);
    PREGION  prgnOld;
    PREGION  prgn;

    ASSERTDEVLOCK(dco.pdc);

    //
    // Always validate input hdc
    //

    if (!dco.bValid())
    {
    #if DBG
        //
        // USER may send a NULL hdc in low memory situations.
        // Just print a warning for those situations, but rip
        // for other bad handles (i.e., USER should figure out
        // why they passed us a bad handle).
        //

        if (hdc)
        {
            RIP("GDISRV!GreSelectVisRgn: Bad hdc\n");
        }
        else
        {
            WARNING("GDISRV!GreSelectVisRgn: hdc NULL\n");
        }
    #endif
        bRet = FALSE;
    }
    else
    {
        bRet = TRUE;

        //
        // Always nuke the Rao
        //

        dco.pdc->vReleaseRao();

        BOOL bDeleteOld = TRUE;

        if (hrgn != (HRGN) NULL)
        {
            //
            // The incoming region may be some random thing, make it lockable
            //

            GreSetRegionOwner(hrgn, OBJECT_OWNER_PUBLIC);

            RGNOBJAPI ro(hrgn,FALSE);

            if (ro.bValid())
            {
                #if DBG || defined(PRERELEASE)
                     //
                     // Make Sure USER is not going to give us a RGN bigger than the surface
                     // Note: USER may select a bogus rgn in during ReleaseDC time, we don't want
                     // to assert there.
                     //
                     // To make things easy, we only check for single monitors
                     //
                     PDEVOBJ pdo(dco.hdev());

                     if (pdo.bValid() && !pdo.bMetaDriver())
                     {
                        UINT uiIndex = (UINT) HmgIfromH((HOBJ)hdc);

                        PENTRY pentTmp = &gpentHmgr[uiIndex];

                        SURFACE *pSurf = dco.pSurface();

                        if (pSurf &&
                           dco.pdc->bValidateVisrgn() &&
                           (OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_NONE))
                        {
                            BOOL bIsOK = ((pSurf->sizl().cx >= ro.prgn->rcl.right) &&
                                         (pSurf->sizl().cy >= ro.prgn->rcl.bottom)&&
                                         (ro.prgn->rcl.left >= 0) &&
                                         (ro.prgn->rcl.top >= 0));

                            FREASSERTGDI(bIsOK, "Rgn size is bigger than surface size");
                        }
                     }

                #endif

                switch (fl)
                {
                case SVR_COPYNEW:
                    {
                        //
                        // We need to make a copy of the new one and delete the old one
                        //

                        RGNMEMOBJ rmo(ro.sizeRgn());

                        if (!rmo.bValid())
                        {
                            prgn = prgnDefault;
                        }
                        else
                        {
                            rmo.vCopy(ro);
                            prgn = rmo.prgnGet();
                        }
                    }
                    break;

                case SVR_SWAP:
                    {
                        //
                        // we need to just swap handles.  No deletion.
                        //

                        prgn = dco.pdc->prgnVis();

                        if (prgn == NULL)
                        {
                            prgn = prgnDefault;
                        }

                        //
                        // don't swap out prgnDefault
                        //

                        if (prgn != prgnDefault)
                        {
                            RGNOBJ roVis(prgn);
                            ro.bSwap(&roVis);

                            //
                            // roVis now contains the new vis rgn and the old visrgn
                            // is associated with hrgn.
                            //

                            prgn = roVis.prgnGet();

                            bDeleteOld = FALSE;
                        }
                        else
                        {
                            bRet = FALSE;
                        }
                    }
                    break;

                case SVR_DELETEOLD:

                    //
                    // delete the old handle but keep the region
                    //

                    prgn = ro.prgnGet();

                    if (ro.bDeleteHandle())
                       ro.vSetRgn(NULL);

                    break;
                }
            }
            else
            {
                RIP("Bad hrgn");
                prgn = prgnDefault;
            }

            // see if we need to delete the old one

            if (bDeleteOld)
            {
                dco.pdc->vReleaseVis();
            }

            // set the new one in.

            dco.pdc->prgnVis(prgn);
            prgn->vStamp();

        }
        else
        {

            //
            // User called GreSelectVisRgn after CreateRectRgn without
            // checking return value, so may have NULL hrgn here.
            //

            #if DBG

            if (fl != SVR_DELETEOLD)
            {
                WARNING("GreSelectVisRgn - fl != SVR_DELETEOLD");
            }

            #endif

            dco.pdc->vReleaseVis();
            dco.pdc->bSetDefaultRegion();
        }
    }

    rl.vRet((ULONG_PTR)bRet);
    return(bRet);
}

/******************************Public*Routine******************************\
* GreCopyVisVisRgn()
*
* History:
*  11-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GreCopyVisRgn(
    HDC    hdc,
    HRGN   hrgn)
{
    RGNLOG rl(hrgn,NULL,"GreCopyVisRgn",(ULONG_PTR)hdc,0);

    int iRet = ERROR;

    DCOBJA    dco(hdc);                  // Use ALT_LOCK on DC
    RGNOBJAPI ro(hrgn,FALSE);

    ASSERTDEVLOCK(dco.pdc);

    if (dco.bValid() && ro.bValid())
    {
        RGNOBJ roVis(dco.pdc->prgnVis());
        if (roVis.bValid() && ro.bCopy(roVis))
            iRet = ro.iComplexity();
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* LONG GreGetClipBox(hdc,prcl,fXForm)
*
* Get the bounding box of the clip region
*
\**************************************************************************/

int
APIENTRY
GreGetClipBox(
   HDC    hdc,
   LPRECT prcl,
   BOOL fXForm)
{
    GDITraceHandle(GreGetClipBox, "(%X, %p, %X)\n", (va_list)&hdc, hdc);

    int iRet = ERROR;
    int iSaveLeft;

    DCOBJ   dor(hdc);

    if (dor.bValid())
    {
        DEVLOCKOBJ  dlo(dor);

        if (!dlo.bValid())
        {
            prcl->left   = 0;           // Make it a 'simple' empty rectangle
            prcl->right  = 0;
            prcl->top    = 0;
            prcl->bottom = 0;

            if (dor.bFullScreen())
                iRet = NULLREGION;
        }
        else
        {
            RGNOBJ  ro(dor.prgnEffRao());

            ro.vGet_rcl((RECTL *) prcl);

            // First convert from screen to device coordinates

            if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
            {
                prcl->left = 0;             // Make it a 'simple' empty rectangle
                prcl->right = 0;
                prcl->top = 0;
                prcl->bottom = 0;
            }
            else
            {
                *(ERECTL *)prcl -= dor.eptlOrigin();

                // If requested, convert from device to logical coordinates.

                if (fXForm)
                {
                    EXFORMOBJ xfoDtoW(dor, DEVICE_TO_WORLD);

                    if (xfoDtoW.bValid())
                    {
                        xfoDtoW.bXform(*(ERECTL *)prcl);
                    }
                }
                if (MIRRORED_DC(dor.pdc) && (prcl->left > prcl->right)) {
                    iSaveLeft   = prcl->left;
                    prcl->left  = prcl->right;
                    prcl->right = iSaveLeft;
                }
            }

            iRet = ro.iComplexity();
        }

        GDITrace(GreGetClipBox, " returns (%d, %d) - (%d %d)\n", (va_list)prcl);
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* int GreSubtractRgnRectList(hrgn, prcl, arcl, crcl)
*
* Quickly subtract the list of rectangles from the first rectangle to
* produce a region.
*
\**************************************************************************/

int
GreSubtractRgnRectList(
    HRGN   hrgn,
    LPRECT prcl,
    LPRECT arcl,
    int    crcl)
{
    GDITraceHandle(GreSubtractRgnRectList, "(%X, %p, %p, %d)\n", (va_list)&hrgn, hrgn);

    RGNLOG rl(hrgn,NULL,"GreSubtractRgnRectList",crcl);

    RGNOBJAPI   ro(hrgn,FALSE);
    int iRet;

    if (!ro.bValid() || !ro.bSubtract((RECTL *) prcl, (RECTL *) arcl, crcl))
    {
    // If bSubtract fails, clean up the target region for USER.

        if (ro.bValid())
            ro.vSet();

        iRet = ERROR;
    }
    else
    {
        iRet = ro.iComplexity();
    }

    rl.vRet(iRet);
    return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rgnobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgnobj.cxx
*
* Non inline RGNOBJ methods
*
* Created: 02-Jul-1990 12:36:30
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Region is expanded by this size when the size is too small.
// Used by bAddScans().

#define FILL_REGION_SIZE    10 * QUANTUM_REGION_SIZE

extern RECTL rclEmpty;

#if DBG
RGNOBJ *gprgn = NULL;
#define VALIDATE(ro)    {gprgn = &ro; (ro).bValidateFramedRegion(); }
#else
#define VALIDATE(ro)
#endif

//
// The following declarations are required by the native c8 compiler.
//

ULONG   REGION::ulUniqueREGION;
HRGN    hrgnDefault;
REGION  *prgnDefault;

/**************************************************************************\
 *
\**************************************************************************/

#if DBG

#define MAXRGNLOG  1000

extern "C"
{
    int gMaxRgnLog = MAXRGNLOG;
    RGNLOGENTRY argnlog[MAXRGNLOG];
    LONG iLog  = 0;
    LONG iPass = 0;
};

BOOL bDispRgn = 0;
BOOL bLogRgn  = 1;

VOID vPrintRgn(RGNLOGENTRY& rl)
{
    DbgPrint("%p,%p,(%8lx),%8lx,%8lx,%4lx, %s, %p, %p\n",
            rl.hrgn,rl.prgn,rl.lRes,rl.lParm1,rl.lParm2,rl.lParm3,
            rl.pszOperation,rl.pvCaller,rl.pvCallersCaller);
}

RGNLOG::RGNLOG(HRGN hrgn,PREGION prgn,PSZ psz,ULONG_PTR l1, ULONG_PTR l2, ULONG_PTR l3)
{
    if (!bLogRgn)
        return;

    plog = &argnlog[iLog++];
    if (iLog >= MAXRGNLOG)
    {
        iLog = 0;
        ++iPass;
    }

    if (plog >= argnlog+MAXRGNLOG)
        plog = &argnlog[0];

    plog->hrgn = (HOBJ) hrgn;
    plog->prgn = prgn;
    plog->pszOperation = psz;
    plog->lRes = 0xff;
    plog->lParm1 = l1;
    plog->lParm2 = l2;
    plog->lParm3 = l3;
    plog->teb    = (PVOID)W32GetCurrentThread();

    RtlGetCallersAddress(&plog->pvCaller,&plog->pvCallersCaller);

    if (bDispRgn)
        vPrintRgn(*plog);
}

RGNLOG::RGNLOG(PREGION prgn,PSZ psz,ULONG_PTR l1, ULONG_PTR l2, ULONG_PTR l3)
{
    if (!bLogRgn)
        return;

    plog = &argnlog[iLog++];
    if (iLog >= MAXRGNLOG)
    {
        iLog = 0;
        ++iPass;
    }

    if (plog >= argnlog+MAXRGNLOG)
        plog = &argnlog[0];

    plog->hrgn = (HOBJ) 1;
    plog->prgn = prgn;
    plog->pszOperation = psz;
    plog->lRes = 0xff;
    plog->lParm1 = l1;
    plog->lParm2 = l2;
    plog->lParm3 = l3;
    plog->teb    = (PVOID)W32GetCurrentThread();

    RtlGetCallersAddress(&plog->pvCaller,&plog->pvCallersCaller);

    if (bDispRgn)
        vPrintRgn(*plog);
}
#endif

/******************************Public*Routine******************************\
* RGNOBJ::vGetSubRect
*
* Return largest rectange completely within the region.
*
* History:
*  09-Sep-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vGetSubRect(PRECTL prcl)
{
// We should try and do better here but this will solve 80% of our
// performance goal.  We should try and return the biggest rectangle
// completely contained within the region that we can quickly compute.

    if (prgn->sizeRgn <= SINGLE_REGION_SIZE)
    {
    // Bounding rect == rect region

        *prcl = prgn->rcl;
        return;
    }

    *prcl = rclEmpty;
}

/******************************Public*Routine******************************\
*
*
* History:
*  05-Jul-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

RGNOBJAPI::RGNOBJAPI(HRGN hrgn,BOOL bSelect)
{
    prgn  = (REGION *)HmgLock((HOBJ)hrgn, RGN_TYPE);
    RGNLOG rl(hrgn,prgn,"RGNOBJAPI::RGNOBJAPI");
    hrgn_    = hrgn;
    bSelect_ = bSelect;

    if (prgn != (PREGION)NULL)
    {
        BOOL bStatus = TRUE;
        //
        // Does this region have valid user-mode data? If there is
        // any problem with the user-mode state, then the contructor
        // must unlock the region set prgn to NULL.
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            //
            // update a valid rgn, we can get an invalid
            // region here because gdi32!DeleteRegion must
            // clear the VALID flag before calling the
            // kernel.
            //

            if (
                 (prRegion->AttrFlags & ATTR_RGN_VALID) &&
                 !(prRegion->AttrFlags & ATTR_CACHED)
               )
            {
                if (prRegion->AttrFlags & ATTR_RGN_DIRTY)
                {
                    if (prRegion->Flags == NULLREGION)
                    {
                        vSet();
                        prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                    }
                    else if (prRegion->Flags == SIMPLEREGION)
                    {
                        vSet(&prRegion->Rect);
                        prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                    }
                }
            }
            else
            {
                bStatus = FALSE;
            }
        }

        if (!bStatus)
        {
            DEC_EXCLUSIVE_REF_CNT(prgn);
            prgn  = NULL;
            hrgn_ = NULL;
        }
    }
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bDeleteHandle()
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bDeleteHandle");

    ASSERTGDI(hrgn_ != (HRGN) NULL, "Delete NULL\n");

    if (hrgn_ == hrgnDefault)
    {
        rl.vRet(0);
        return(FALSE);
    }

    PREGION prgn1 = (PREGION)HmgRemoveObject((HOBJ) hrgn_, 1, 0, FALSE, RGN_TYPE);

    if (prgn1 != prgn)
    {
        rl.vRet(-1);

    #if DBG
        DbgPrint("couldn't delete api rgn - %p, prgn1 = %p\n",hrgn_,prgn1);
        DbgBreakPoint();
    #endif
        return(FALSE);
    }
    hrgn_ = NULL;

    rl.vRet(1);
    return(TRUE);
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bDeleteRGNOBJAPI()
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bDelete");
    BOOL bRes = FALSE;
    POBJECTATTR pRgnattr = NULL;

    //
    // if this region has user-mode memory, try to place in cache
    //

    if (prgn)
    {
        PENTRY pEntry = PENTRY_FROM_POBJ(prgn);
        pRgnattr = (POBJECTATTR)pEntry->pUser;

        if (pRgnattr)
        {
            bRes = bPEBCacheHandle(prgn->hGet(),RegionHandle,pRgnattr,pEntry);
        }
    }

    if (!bRes)
    {
        bRes = bDeleteHandle() && bDeleteRGNOBJ();

        if (bRes && (pRgnattr != NULL))
        {
            HmgFreeObjectAttr((POBJECTATTR)pRgnattr);
        }
    }
    rl.vRet(bRes);
    return(bRes);
}

VOID RGNOBJ::vDeleteRGNOBJ()
{
    //
    // Deletes the region and sets it to NULL.
    //

    RGNLOG rl(prgn,"RGNOBJ::vDeleteRGNOBJ");
    prgn->vDeleteREGION();
    prgn = NULL;
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//
struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};

BOOL RGNOBJ::bSwap(RGNOBJ *pro)
{
    RGNLOG rl(prgn,"RGNOBJ::bSwap",(ULONG_PTR)pro,(ULONG_PTR)pro->prgn);

    //
    // Swap the BASEOBJECT info at the start of the region.
    // Ensuring that when cExclusiveLock is swapped, the BaseFlags
    // is not swapped with it.
    // BaseFlags contains information about how the
    // object was allocated (and therefore, how it must be deallocated).  Thus,
    // it represents state associated with the actual memory, not the object,
    // and should not be swapped.
    //
    // See comments regarding BASEOBJECT in inc\hmgshare.h for more details.
    // Also, there is swapping code in HmgSwapLockedHandleContents (hmgrapi.cxx).
    //
    BASEOBJECT  *proB = (BASEOBJECT *)pro->prgnGet();
    BASEOBJECT obj = *proB;
    SplitOrCombinedLockAndFlags lfTmp;

    proB->hHmgr = prgn->hHmgr;
    
    lfTmp.S.c_cExclusiveLock = prgn->cExclusiveLock;
    lfTmp.S.c_BaseFlags = proB->BaseFlags;
    InterlockedExchange((LONG *) &(proB->cExclusiveLock), lfTmp.W);
    proB->Tid = prgn->Tid;

    prgn->hHmgr = obj.hHmgr;

    lfTmp.S.c_cExclusiveLock = obj.cExclusiveLock;
    lfTmp.S.c_BaseFlags = prgn->BaseFlags;
    InterlockedExchange((LONG *) &(prgn->cExclusiveLock), lfTmp.W);
    prgn->Tid = obj.Tid;

    // Swap the selection data.

    COUNT cRefsTemp = prgn->cRefs;
    prgn->cRefs = pro->prgn->cRefs;
    pro->prgn->cRefs = cRefsTemp;

    // swap the pointers in the objects

    PREGION prgnTmp = prgn;
    prgn = pro->prgnGet();
    pro->vSetRgn(prgnTmp);

    return(TRUE);
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSwap(RGNOBJ *pro)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bSwap",(ULONG_PTR)pro,(ULONG_PTR)pro->prgn);

    ASSERTGDI(hrgn_ != NULL,"RGNOBJAPI::bSwap - hrgn is null\n");

    //
    // dunno if this is safe without grabbing the handle lock first
    //

    //
    // This increments the lock count so that between the HmgReplace and
    // the bSwap we're guaranteed a cExclusiveLock > 0 for both objects.
    //

    INC_EXCLUSIVE_REF_CNT(pro->prgnGet());
    INC_EXCLUSIVE_REF_CNT(prgn);

    // swap the pointer in the handle
    
    PREGION prgnRet = (PREGION)HmgReplace((HOBJ) hrgn_,(POBJ) pro->prgnGet(),0,1,RGN_TYPE);

    if (prgnRet != prgn)
    {
        rl.vRet((ULONG_PTR)prgnRet);
        RIP("RGNOBJ::bSwap - swapping invalid rgn\n");

        return(FALSE);
    }

    // swap the objects

    rl.vRet(1);


    BOOL retVal = RGNOBJ::bSwap(pro);


    //
    // Decrementing the cExclusiveLock for both objects in this way ensures
    // that after the swap the Lock status is restored for _both_ objects.
    //

    DEC_EXCLUSIVE_REF_CNT(pro->prgnGet());
    DEC_EXCLUSIVE_REF_CNT(prgn);

    return retVal;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vCopy()
*
* Copy region.  There are some fields like the object size that don't need
* copying.  This deals with them appropriately
*
* History:
*  22-Jul-1993 -by-  Eric Kutter [erick]
*       reorged region structure so don't have to deal with individual
*       fields that may not need copying.
*
*  04-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNOBJ::vCopy",(ULONG_PTR)roSrc.prgn);

    ASSERTGDI(prgn->sizeObj >= roSrc.prgn->sizeRgn, "sizeObj Src > sizeRgn Trg\n");

    RtlCopyMemory ((PBYTE) prgn + RGN_COPYOFFSET,
                   (PBYTE) roSrc.prgn + RGN_COPYOFFSET,
                   roSrc.prgn->sizeRgn - RGN_COPYOFFSET);

// Get the difference and add it to the pscnTail pointer.  This is faster
// than running through the list to find it.

    prgn->pscnTail = (SCAN *) ((BYTE *) prgn->pscnHead() +
                              (LONG) ((BYTE *) roSrc.prgn->pscnTail -
                                      (BYTE *) roSrc.prgn->pscnHead()));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bCopy(roSrc)
*
* Copy region.
*
* NOTE: This is significantly different than vCopy.  This routine will
*       create a new region if the source and target are of different
*       complexities.
*
* WARNING: the prgn may change.  If this rgn is associated with a handle,
*       the handle's version will not have changed.
*
* History:
*  04-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNOBJ::bCopy",(ULONG_PTR)roSrc.prgn);

    if (prgn->sizeObj <= QUANTUM_REGION_SIZE)
    {
        if (roSrc.prgn->sizeObj <= QUANTUM_REGION_SIZE)
        {
            rl.vRet(1);
            vCopy(roSrc);
            return(TRUE);
        }
        else
        {
            rl.vRet(2);
            RGNMEMOBJTMP rmo(roSrc.prgn->sizeRgn);

            if (!rmo.bValid())
                return(FALSE);

            rmo.vCopy(roSrc);
            return(bSwap(&rmo));
        }
    }

    if (roSrc.prgn->sizeObj <= QUANTUM_REGION_SIZE)
    {
        rl.vRet(3);
        RGNMEMOBJTMP rmo2;

        if (!rmo2.bValid())
            return(FALSE);

        rmo2.vCopy(roSrc);
        return(bSwap(&rmo2));
    }

    if (prgn->sizeObj >= roSrc.prgn->sizeRgn)
    {
        rl.vRet(4);
        vCopy(roSrc);
        return(TRUE);
    }

    RGNMEMOBJTMP rmo3(roSrc.prgn->sizeRgn);

    rl.vRet(5);

    if (!rmo3.bValid())
        return(FALSE);

    rmo3.vCopy(roSrc);
    return(bSwap(&rmo3));
}

/******************************Member*Function*****************************\
*  bCopy
*
*  This should be used if you want any prgn change reflected in the handle.
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bCopy",(ULONG_PTR)roSrc.prgn);

    ASSERTGDI(hrgn_ != NULL,"RGNOBJAPI::bCopy\n");

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    BOOL bRes = RGNOBJ::bCopy(roSrc);

    rl.vRet(0);

    if (bRes)
    {
        rl.vRet(1);
        if (prgn != prgnOrg)
        {
            rl.vRet((ULONG_PTR)prgn);

            PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
            ASSERTGDI(pv != NULL,"RGNOBJAPI::bCopy - HmgReplace failed\n");
        }
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bExpand(size)
*
* Expand the object to the given size
*
* History:
*  10-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bExpand(ULONGSIZE_T size)
{
    RGNLOG rl(prgn,"RGNOBJ::bExpand",size);

    ASSERTGDI(size > prgn->sizeObj, "Expanded size <= original size\n");

    RGNMEMOBJTMP rmo(size);

    rl.vRet((ULONG_PTR)rmo.prgnGet());

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    rmo.vCopy(*this);

    return(bSwap(&rmo));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bInside(pptl)
*
* Is the point inside the region?
*
* Returns:
*   ERROR            0L
*   REGION_POINT_OUTSIDE    1L
*   REGION_POINT_INSIDE     2L
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bInside(PPOINTL pptl)
{
// First check if the point is in the bounding box

    if (!bBounded(pptl))
        return(REGION_POINT_OUTSIDE);

    BOOL    b = REGION_POINT_OUTSIDE;   // Assume point is outside
    PSCAN   pscn;
    COUNT   cScan;
    COUNT   cWall;
    COUNT   iWall;

    pscn = prgn->pscnHead();            // Get first scan
    cScan = prgn->cScans;               // Get scan count

    while (cScan--)
    {
        if (pscn->yTop > pptl->y)       // Have we passed the point?
            return(b);                  // Yes, exit.

        if (pscn->yBottom > pptl->y)    // Does this scan overlap the point?
        {                               // Yes, test walls/lines.

            ASSERTGDI(!(pscn->cWalls & 1), "Invalid cWalls\n");

            iWall = 0;
            cWall = pscn->cWalls;

            while (iWall != cWall)
                if (xGet(pscn, (PTRDIFF)iWall++) > pptl->x)
                    return(b);
                else
                    b ^= (REGION_POINT_INSIDE | REGION_POINT_OUTSIDE);
        }

        pscn = pscnGet(pscn);

        ASSERTGDI( pscn <=  prgn->pscnTail, "bInside:Went past end of region\n");
    }

    WARNING("********** RGNOBJ::bInside *****************\n");

    return(b);
}

/******************************Public*Routine******************************\
* RGNOBJ::bInside (prcl)                                                   *
*                                                                          *
* Does the rectangle intersect the region?                                 *
*                                                                          *
* Returns:                                                                 *
*   ERROR          0L                                               *
*   REGION_RECT_OUTSIDE   1L                                               *
*   REGION_RECT_INTERSECT 2L                                               *
*                                                                          *
* History:                                                                 *
*  Tue 12-May-1992 22:23:10 -by- Charles Whitmer [chuckwh]                 *
* Rewrote the scan search.  I want this zippy fast since I'm going to use  *
* it for pointer exclusion.                                                *
*                                                                          *
*  11-May-1991 -by- Kent Diamond [kentd]                                   *
* Rewrote.  No more support for partial intersection.                      *
*                                                                          *
*  02-Jul-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RGNOBJ::bInside(PRECTL prcl)
{
// First check if the rectangle is outside the bounding box

    if ((prcl->left   >= prgn->rcl.right) ||
        (prcl->right  <= prgn->rcl.left)  ||
        (prcl->top    >= prgn->rcl.bottom) ||
        (prcl->bottom <= prgn->rcl.top))
        return(REGION_RECT_OUTSIDE);

// Skip scans above the rectangle.

    PSCAN pscn  = prgn->pscnHead();
    COUNT cScan = prgn->cScans;

    while (cScan && (prcl->top >= pscn->yBottom))
    {
        pscn = pscnGet(pscn);
        cScan--;
    }

// Examine all interesting scans.

    INDEX_LONG *pix,*pixEnd;

    while (cScan && (prcl->bottom > pscn->yTop))
    {
        pix    = pscn->ai_x;
        pixEnd = pix + 2 * pscn->cWalls;

    // Skip segments to the left.

        while ((pix < pixEnd) && (prcl->left >= pix[1].x))
            pix += 2;

    // It's this segment or nothing!

        if ((pix < pixEnd) && (prcl->right > pix[0].x))
            return(REGION_RECT_INTERSECT);

    // Move to the next scan.

        pscn = pscnGet(pscn);
        cScan--;
    }
    return(REGION_RECT_OUTSIDE);        // Did not find an intersection
}

/******************************Public*Routine******************************\
* RGNOBJ::bEqual(roSrc)
*
* Are the two regions equal?
*
* NOTE: The handle and sizeObj maybe different even though the regions
* are the same, so these are skipped.
*
* Returns:
*   TRUE if they are equal.
*   FALSE if they are not.
*
* History:
*  13-May-1991 -by- Donald Sidoroff [donalds]
* Rewrote it.
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bEqual(RGNOBJ& roSrc)
{
// In the region header, only cScans need to be similar for
// a region to equal another region
// Now run thru the scans and determine if they are the same

    ASSERT4GB((LONGLONG)((BYTE *)prgn->pscnTail - (BYTE *)prgn->pscnHead()));

    return(
        (prgn->cScans == roSrc.prgn->cScans) &&
        (!memcmp(prgn->pscnHead(), roSrc.prgn->pscnHead(),
                   (ULONG)((BYTE *)prgn->pscnTail - (BYTE *)prgn->pscnHead()))));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bOffset(pptl)
*
* Offset the region by the point.
*
* Note:
*   Since the point is in DEVICE coords it will have to be converted to
*   FIX notation before it can be added to endpoints of trapezoid lines.
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bOffset(PPOINTL pptl)
{
    COUNT       cscn;
    COUNT       cwll;
    PSCAN       pscn;
    int         x = (int)pptl->x;
    int         y = (int)pptl->y;

// Can't fail to offset a NULL region

    if (prgn->cScans == 1)
        return(TRUE);

// First try to update the bounding box.  If we are successful here then
// all the other offsets will be successful.  This eliminates the need
// for checking for overflow/underflow on every offset operation.

    ERECTL ercl(prgn->rcl);          // Get the current bounding box
    if (ercl.bWrapped())
        return(TRUE);

    ercl.left   += x;
    ercl.bottom += y;
    ercl.right  += x;
    ercl.top    += y;

    if (!VALID_SCRRC(ercl))
    {
    // Foo, we over/under flowed.

        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
        return(FALSE);
    }
    prgn->rcl = *((RECTL *)&ercl);  // Set the current bounding box

    cscn = prgn->cScans;            // Number of scans;
    pscn = prgn->pscnHead();        // First scan

    while (cscn--)
    {
        pscn->yTop += y;
        pscn->yBottom += y;

        cwll = pscn->cWalls;
        while (cwll)
            pscn->ai_x[--cwll].x += x;

        pscn = pscnGet(pscn);       // Get next scan

        ASSERTGDI(pscn <= prgn->pscnTail, "bOffset:Went past end of region\n");
    }

    pscn = pscnGot(pscn);           // Fix top ...
    pscn->yBottom = POS_INFINITY;
    pscn = prgn->pscnHead();        // ... and bottom.
    pscn->yTop = NEG_INFINITY;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet()
*
* Set region to null region
*
* History:
*  05-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vSet()
{
    RGNLOG rl(prgn,"RGNOBJ::vSet");

    PREGION prgn1 = prgn;

    prgn1->sizeRgn    = NULL_REGION_SIZE;
    prgn1->cScans     = 1;
    prgn1->rcl.left   = 0;
    prgn1->rcl.top    = 0;
    prgn1->rcl.right  = 0;
    prgn1->rcl.bottom = 0;

    PSCAN pscn = prgn1->pscnHead();
    pscn->cWalls     = 0;
    pscn->yTop       = NEG_INFINITY;
    pscn->yBottom    = POS_INFINITY;
    pscn->ai_x[0].x  = 0;                    // This sets cWalls2

    prgn1->pscnTail   = pscnGet(pscn);
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet()
*
* Set region from list of rectangles
*
* History:
*   7-18-2000 bhouse Wrote it
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bSet(ULONG cRect, RECTL * prcl)
{
    RGNMEMOBJTMP rmoTmp1, rmoTmp2;

    if (!rmoTmp1.bValid() || !rmoTmp2.bValid())
    {
        return(FALSE);
    }

    // NOTE: the iCombine call below is O(n*n) so
    // we want to only call it with small n.  We use
    // merge sort which is O(n*log n) to handle larger n.
    //
    // The limit of 20 was picked as a reasonable number which
    // balances the cost of the RGNMEMOBJ creation
    // with the cost of the n squared algorithm.
    //

    if(cRect < 20)
    {
        BOOL bDoneFirst=FALSE;
        
        for (ULONG i=0; i < cRect; i++, prcl++)
        {      
            // ignore bad rectangles
            if (!((prcl->left>=prcl->right)     || 
                  (prcl->top>=prcl->bottom)     ||
                  (prcl->left<MIN_REGION_COORD) ||
                  (prcl->right>MAX_REGION_COORD)||
                  (prcl->top<MIN_REGION_COORD)  ||
                  (prcl->bottom>MAX_REGION_COORD)))
            {
                if(!bDoneFirst) 
                {
                    // Do the first rectangle
                    vSet(prcl);
                    bDoneFirst=TRUE;
                }
                else 
                {
                    // Now get the rest of the rectangles, one by one
                    rmoTmp1.vSet(prcl);
                    rmoTmp2.iCombine(*this, rmoTmp1, RGN_OR); // put result of merge into rmoTmp2
                    bSwap(&rmoTmp2); // now move into rmo
                }
            }
        }
    }
    else
    {
        RGNMEMOBJTMP rmoTmp3;
        
        ULONG   cTmp1 = cRect >> 1;
        ULONG   cTmp2 = cRect - cTmp1;

        if(!rmoTmp1.bSet(cTmp1, prcl) || !rmoTmp2.bSet(cTmp2, prcl+cTmp1))
        {
            return FALSE;
        }

        rmoTmp3.iCombine(rmoTmp2, rmoTmp1, RGN_OR);
        bSwap(&rmoTmp3);

    }
    return TRUE;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet(prcl)
*
* Set region to single rect
*
* History:
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vSet(PRECTL prcl)
{
    RGNLOG rl(prgn,"RGNOBJ::vSet prcl");

    PSCAN   pscn;

    if ((prcl->left == prcl->right) || (prcl->top == prcl->bottom))
    {
        vSet();
        return;
    }

// If the region is already a RECT region, this can be much faster

    PREGION prgn1 = prgn;

    prgn1->rcl = *prcl;

    if (prgn1->sizeRgn == SINGLE_REGION_SIZE)
    {
        rl.vRet(0);

        ASSERTGDI(prgn1->cScans == 3,"RGNOBJ::vSet - cScans != 3\n");

    // scan 0

        pscn = prgn1->pscnHead();
        ASSERTGDI(pscn->yTop == NEG_INFINITY,"RGNOBJ::vSet - yTop0\n");

        pscn->yBottom = prcl->top;

    // scan 1

        pscn = pscnGet(pscn);
        ASSERTGDI(pscn->cWalls == 2,"RGNOBJ::vSet - cWalls1 != 2\n");

        pscn->yTop = prcl->top;
        pscn->yBottom = prcl->bottom;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;

    // scan 2

        pscn = pscnGet(pscn);
        ASSERTGDI(pscn->cWalls == 0,"RGNOBJ::vSet - cWalls2 != 0\n");
        ASSERTGDI(pscn->yBottom == POS_INFINITY,"RGNOBJ::vSet - yBottom2\n");

        pscn->yTop = prcl->bottom;

    // tail

        prgn1->pscnTail = pscnGet(pscn);
    }
    else
    {
        rl.vRet(0);

        prgn1->sizeRgn = SINGLE_REGION_SIZE;
        prgn1->cScans = 3;

        pscn = prgn1->pscnHead();
        pscn->cWalls = 0;
        pscn->yTop = NEG_INFINITY;
        pscn->yBottom = prcl->top;
        pscn->ai_x[0].x = 0;                    // This sets cWalls2

        pscn = pscnGet(pscn);
        pscn->cWalls = 2;
        pscn->yTop = prcl->top;
        pscn->yBottom = prcl->bottom;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;
        pscn->ai_x[2].x = 2;                    // This sets cWalls2

        pscn = pscnGet(pscn);
        pscn->cWalls = 0;
        pscn->yTop = prcl->bottom;
        pscn->yBottom = POS_INFINITY;
        pscn->ai_x[0].x = 0;                    // This sets cWalls2

        prgn1->pscnTail = pscnGet(pscn);
    }
    VALIDATE(*(RGNOBJ *)this);
}

/******************************Public*Routine******************************\
* VOID SCAN::vMerge(pscnSrcA, pscnSrcB, fj)
*
* Merge the scans.
*
* The algorithm takes advantage of the pre-sorted nature of the source
* scans.  We define the 'events' to be the merged sorted list of X values
* from both A and B.  The 'op' is referenced to determine if the event
* is worth recording in the destination.
*
* There are a few tricks used in this routine.  The first is the way that
* the state is recorded.  There are four states possible, since
* we can either be IN or OUT of A or B.  These states are:
*
*  0001b    OUT A, OUT B
*  0010b    OUT A, IN  B
*  0100b    IN  A, OUT B
*  1000b    IN  A, IN  B
*
* From this we can see A is equal to 1100 (IN_A_OUT_B | IN_A_IN_B) and
* that B is equal to 1010 (OUT_A_IN_B | IN_A_IN_B).
*
* We use a state table to find the next state.  The index into the table
* is the current state and the value we get out the new state.
*
* We always begin with an initial state OUT A, OUT B.  We then take the
* lowest X value from either A or B.  We then map through the table of
* which ever scan we pulled an X value from and so the state always
* indicates whether we are in (entering) or out (leaving) of either scan.
*
* The second trick is in the similar way that the logical operation
* to be used for the merge is encoded in the 'op'.  This is done as a
* simple logical truth table that can be tested against the state to
* see if we are IN or OUT of the result.  The frequently used ops are:
*
*  1110     OR
*  1000     AND
*  0110     XOR
*  0100     DIFF
*
* These ops are seen to be the OR of the appropriate state definitions
* needed for the boolean operation.  For example the op for 'A OR B' is
* derived from (1100 | 1010).
*
* In fact, any op whose lower bit is 0 is allowed.  This gives eight
* possible operations.
*
* The final trick we use to determine when an event worthy of recording
* has occured.  When we are not in a destination rectangle, we just
* test the new state against the op to see if we've just changed to IN.
* If so, we invert the op.  Now we only need to test the state against
* this inverted op to determine when we pop OUT again!  So whenever we
* record a point we invert the op.
*
* History:
*  11-Nov-1992 -by- Donald Sidoroff [donalds]
* Merged into RGNOBJ::bMerge for speed.
*
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#define MERGE_OUT_OUT       0x01
#define MERGE_OUT_IN        0x02
#define MERGE_IN_OUT        0x04
#define MERGE_IN_IN         0x08
#define MERGE_INITIAL_STATE MERGE_OUT_OUT

static  FCHAR   afjA[16] =
{
    0x00,               //
    MERGE_IN_OUT,       //  OUT OUT ->  IN  OUT
    MERGE_IN_IN,        //  OUT IN  ->  IN  IN
    0x00,               //
    MERGE_OUT_OUT,      //  IN  OUT ->  OUT OUT
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_OUT_IN        //  IN  IN  ->  OUT IN
};

static  FCHAR   afjB[16] =
{
    0x00,               //
    MERGE_OUT_IN,       //  OUT OUT ->  OUT IN
    MERGE_OUT_OUT,      //  OUT IN  ->  OUT OUT
    0x00,               //
    MERGE_IN_IN,        //  IN  OUT ->  IN  IN
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_IN_OUT        //  IN  IN  ->  IN  OUT
};

static  FCHAR   afjAB[16] =
{
    0x00,               //
    MERGE_IN_IN,        //  OUT OUT ->  IN  IN
    MERGE_IN_OUT,       //  OUT IN  ->  IN  OUT
    0x00,               //
    MERGE_OUT_IN,       //  IN  OUT ->  OUT IN
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_OUT_OUT       //  IN  IN  ->  OUT OUT
};

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bMerge(proSrc1, proSrc2, fjOp)
*
* Merge two regions together.
*
* WARNING: If this function returns FALSE, the region may be inconsistent.
*          The caller must discard or reset the region. (See bug #343770)
*
* History:
*  11-Nov-1992 -by- Donald Sidoroff [donalds]
* Merged SCAN::vMerge into code for speed up.  More aggressive memory
* usage scheme and other optimizations.
*
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bMerge(RGNOBJ& roSrc1,
                     RGNOBJ& roSrc2,
                     FCHAR   fjOp)
{
    RGNLOG rl(prgn,"RGNOBJ::bMerge",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,(ULONG_PTR)fjOp);

    SCAN   *pscnSrc1 = roSrc1.prgn->pscnHead();
    SCAN   *pscnSrc2 = roSrc2.prgn->pscnHead();
    SCAN   *pscnOld = (SCAN *) NULL;
    SCAN   *pscnTrg;
    LONG    yTop;
    LONG    yBottom;
    ULONG   size;

// Set target region to be TOTALLY empty, yet valid.

    prgn->pscnTail = prgn->pscnHead();
    prgn->sizeRgn  = NULL_REGION_SIZE - NULL_SCAN_SIZE;
    prgn->cScans   = 0;

// Ensure the bounding box gets updated later on.

    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.top    = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;
    prgn->rcl.bottom = NEG_INFINITY;

// Merge the source scans into the target

    for(;;)
    {
        pscnTrg = prgn->pscnTail;

    // Check for nearly full region

        size = (pscnSrc1->cWalls + pscnSrc2->cWalls) * sizeof(INDEX_LONG) +
               NULL_SCAN_SIZE;

        if (size > prgn->sizeObj - prgn->sizeRgn)
        {
        // OK, we need to realloc this region.  Lets be fairly aggressive
        // on the allocate to cut down on realloc's

            if (!bExpand(prgn->sizeRgn * 2 + (ULONGSIZE_T)size))
                return(FALSE);

            pscnTrg = prgn->pscnTail;       // Get the updated object's tail.

            if (pscnOld)                    // If we had an old scan
                pscnOld = pscnGot(pscnTrg); // Get the updated old scan.
        }

        yTop = MAX(pscnSrc1->yTop, pscnSrc2->yTop);
        yBottom = MIN(pscnSrc1->yBottom, pscnSrc2->yBottom);

        ASSERTGDI(yBottom > yTop, "Bottom <= Top\n");

    // Merge the current scans

        pscnTrg->yBottom = yBottom;
        pscnTrg->yTop    = yTop;

        {
        register INDEX_LONG *plTrg   = &pscnTrg->ai_x[0];
        register INDEX_LONG *plSrc1  = &pscnSrc1->ai_x[0];
        register INDEX_LONG *plSrc2  = &pscnSrc2->ai_x[0];
                 COUNT cSrc1   = pscnSrc1->cWalls;
                 COUNT cSrc2   = pscnSrc2->cWalls;
                 LONG  xEvent;
                 FCHAR fjState = MERGE_INITIAL_STATE;
                 FCHAR fjOpTmp = fjOp;

            pscnTrg->cWalls = 0;                // Init the wall count to zero


            // Continue to loop as long as either cSrc1 or cSrc2 (or both) are non-zero.
            // We terminate the loop via a break statement because this causes the compiler
            // to generate more efficient code (fewer branches).  I believe this is a key loop
            // that is worth optimizing at a minor cost to readability.

            while (1)
            {
                if (cSrc1)
                {
                    if (cSrc2)
                    {
                        // Both cSrc1 and cSrc2 are non-zero, so the next xEvent
                        // will come from whichever is smaller: *plSrc1 or *plSrc2

                        if (plSrc1->x < plSrc2->x)
                        {
                            xEvent = plSrc1->x, plSrc1++, cSrc1--, fjState = afjA[fjState];
                        }
                        else if (plSrc1->x > plSrc2->x)
                        {
                            xEvent = plSrc2->x, plSrc2++, cSrc2--, fjState = afjB[fjState];
                        }
                        else
                        {
                            // *plSrc1 and *plSrc2 are equal so advance both pointers

                            xEvent = plSrc1->x, plSrc1++, cSrc1--, plSrc2++, cSrc2--, fjState = afjAB[fjState];
                        }
                    }
                    else
                    {
                        // cSrc1 is non-zero, but cSrc2 is zero:  the next xEvent is
                        // at *plSrc1

                        xEvent=plSrc1->x, plSrc1++, cSrc1--, fjState = afjA[fjState];
                    }
                }
                else
                {
                    if (cSrc2)
                    {

                        // cSrc1 is zero and cSrc2 is non-zero:  the next xEvent is
                        // at *plSrc2

                        xEvent = plSrc2->x, plSrc2++, cSrc2--, fjState = afjB[fjState];

                    }
                    else
                    {
                        // both cSrc1 and cSrc2 are zero.  We are done with the loop.

                        break;
                    }

                }
                // We now have the next event and a new state

                if (fjOpTmp & fjState)
                    pscnTrg->cWalls++, plTrg->x = xEvent, plTrg++, fjOpTmp ^= 0x0f;
            }

            pscnTrg->ai_x[pscnTrg->cWalls].x = pscnTrg->cWalls;
        }

        ASSERTGDI(!(pscnTrg->cWalls & 1), "Odd cWalls\n");

    // Try to coalesce the current scan with the previous scan

        if (pscnOld != (SCAN *) NULL)
        {
        // If the wall counts are the same, compare the walls

            if (pscnOld->cWalls == pscnTrg->cWalls)
                if (!memcmp(&pscnOld->ai_x[0], &pscnTrg->ai_x[0], (UINT)pscnOld->cWalls * sizeof(INDEX_LONG)))
                {
                    pscnOld->yBottom = pscnTrg->yBottom;
                    pscnTrg = pscnOld;
                }
        }

    // If the scans didn't coalesce, update size and count information

        if (pscnOld != pscnTrg)
        {
            prgn->pscnTail = pscnGet(pscnTrg);
            prgn->sizeRgn += pscnTrg->sizeGet();
            prgn->cScans++;
        }

    // We might be done

        if (pscnTrg->yBottom == POS_INFINITY)
        {
            ASSERTGDI((prgn->sizeRgn <= prgn->sizeObj),"bMerge: sizeRgn > sizeObj\n");
            ASSERTGDI(prgn->sizeRgn == (SIZE_T)((BYTE *)prgn->pscnTail - (BYTE *)prgn),
                      "bMerge:sizeRgn != size of region\n");

            return(TRUE);
        }

    // Maybe update the bounding rectangle

        if (pscnTrg->cWalls)
        {
            if (pscnTrg->ai_x[0].x < prgn->rcl.left)
                prgn->rcl.left = pscnTrg->ai_x[0].x;

            if (pscnTrg->yTop < prgn->rcl.top)
                prgn->rcl.top = pscnTrg->yTop;

            if (pscnTrg->ai_x[pscnTrg->cWalls - 1].x > prgn->rcl.right)
                prgn->rcl.right = pscnTrg->ai_x[pscnTrg->cWalls - 1].x;

            if (pscnTrg->yBottom > prgn->rcl.bottom)
                prgn->rcl.bottom = pscnTrg->yBottom;
        }

    // Decide which source pointers need to be advanced

        if (yBottom == pscnSrc1->yBottom)
            pscnSrc1 = pscnGet(pscnSrc1);

        if (yBottom == pscnSrc2->yBottom)
            pscnSrc2 = pscnGet(pscnSrc2);

    // Set the pscnOld to the current scan

        pscnOld = pscnTrg;
    }
}

/******************************Public*Routine******************************\
* LONG RGNOBJ::iCombine(proSrc1, proSrc2, iMode)
*
* Combine the two regions by the mode and update the objects region.
* Return the complexity of the resulting region.
*
* History:
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

FCHAR gafjRgnOp[] =
{
    0x00,                   //
    0x08,                   // RGN_AND
    0x0e,                   // RGN_OR
    0x06,                   // RGN_XOR
    0x04,                   // RGN_DIFF
};

LONG RGNOBJ::iCombine(RGNOBJ& roSrc1,
                      RGNOBJ& roSrc2,
                      LONG    iMode)
{
    RGNLOG rl(prgn,"RGNOBJ::iCombine",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,iMode);

// The target region MUST NOT be either of the source regions

    ASSERTGDI(prgn != roSrc1.prgn, "Trg == Src1\n");
    ASSERTGDI(prgn != roSrc2.prgn, "Trg == Src2\n");

// if this is the global empty one, we don't want to mess with it.

    if (prgn == prgnDefault)
        return(iComplexity());

// Check for the special case of merging one big single region with others.

    if ((iMode == RGN_AND)||(iMode == RGN_OR))
    {

        if (roSrc1.bRectl())
        {
            // if roSrc2.prgn's bounding box is smaller or equal

            if (roSrc1.bContain(roSrc2))
            {
                // The result will be identical to one region
                if (!bCopy((iMode == RGN_AND) ? roSrc2 : roSrc1))
                {
                    WARNING("Unable to copy region!!");
                    vSet();
                    return(ERROR);
                }
                rl.vRet((ULONG_PTR)prgn);
                return(iComplexity());
            }
        }

        if (roSrc2.bRectl())
        {

            // if roSrc1.prgn's bounding box is smaller or equal

            if (roSrc2.bContain(roSrc1))
            {
                // The result will be identical to one region
                if (!bCopy((iMode == RGN_AND) ? roSrc1 : roSrc2))
                {
                    WARNING("Unable to copy region!!");
                    vSet();
                    rl.vRet((ULONG_PTR)prgn);
                    return(ERROR);
                }
                    rl.vRet((ULONG_PTR)prgn);
                return(iComplexity());
            }
        }
    }

// Check for the special case of ANDing two single regions together.

    if ((iMode == RGN_AND)                     &&
        (roSrc1.prgn->sizeRgn == SINGLE_REGION_SIZE)  &&
        (roSrc2.prgn->sizeRgn == SINGLE_REGION_SIZE))
    {
    // Cool, all we have to do is AND the bounding boxes and we're done.

        RECTL   rclSrc1;
        RECTL   rclSrc2;
        RECTL   rclTrg;

        rclSrc1 = roSrc1.prgn->rcl;
        rclSrc2 = roSrc2.prgn->rcl;

        rclTrg.left    = MAX(rclSrc1.left,   rclSrc2.left);
        rclTrg.right   = MIN(rclSrc1.right,  rclSrc2.right);
        rclTrg.top     = MAX(rclSrc1.top,    rclSrc2.top);
        rclTrg.bottom  = MIN(rclSrc1.bottom, rclSrc2.bottom);

    // Was the resulting region NULL?

        if ((rclTrg.left >= rclTrg.right) ||
            (rclTrg.top  >= rclTrg.bottom))
            vSet();                     // Make target NULL;
        else
            vSet(&rclTrg);              // Make target a rect

        rl.vRet((ULONG_PTR)prgn);
        return(SIMPLEREGION);          // Since we know what we get
    }

// Do the general cases.

    if (!bMerge(roSrc1, roSrc2, gafjRgnOp[iMode]))
    {
        vSet();
        rl.vRet((ULONG_PTR)prgn);
        return(ERROR);
    }
    rl.vRet((ULONG_PTR)prgn);
    return(iComplexity());
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG RGNOBJAPI::iCombine(
    RGNOBJ& roSrc1,
    RGNOBJ& roSrc2,
    LONG    iMode)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::iCombine",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,iMode);

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    LONG iRet = RGNOBJ::iCombine(roSrc1,roSrc2,iMode);

    if (prgn != prgnOrg)
    {
        rl.vRet((ULONG_PTR)prgn);

        PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
        ASSERTGDI(pv != NULL,"RGNOBJAPI::iCombine - HmgReplace failed\n");
    }
    return(iRet);
}

/******************************Member*Function*****************************\
* RGNOBJ::iReduce()
*
*   copy the roSrc into this reducing the size of the region if possible.
*
* History:
*  13-Aug-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG RGNMEMOBJ::iReduce(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNMEMOBJ::iReduce",(ULONG_PTR)roSrc.prgn);

    RGNMEMOBJTMP rmoBigRect;
    RECTL rcl;

    rcl.left   = MIN_REGION_COORD;
    rcl.right  = MAX_REGION_COORD;
    rcl.top    = MIN_REGION_COORD;
    rcl.bottom = MAX_REGION_COORD;

    rmoBigRect.vSet(&rcl);

// Set the bounding box to be maximally crossed (left > right, top > bottom)

    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.top    = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;
    prgn->rcl.bottom = NEG_INFINITY;

    if (!bMerge(rmoBigRect, roSrc, gafjRgnOp[RGN_AND]))
    {
        vSet();
        rl.vRet((ULONG_PTR)prgn);
        return(ERROR);
    }

    rl.vRet((ULONG_PTR)prgn);
    return(iComplexity());
}

/******************************Public*Routine******************************\
* SIZE_T RGNOBJ::sizeSave()
*
* Compute the size of the save data for this region
*
* History:
*  26-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

ULONGSIZE_T RGNOBJ::sizeSave()
{
    COUNT   cscn = prgn->cScans;
    PSCAN   pscn = prgn->pscnHead();
    COUNT   crcl = 0;

// The number of rectangles per scan is:
//
// For RECT regions --  (# of walls / 2)
// For TRAP regions --  (# of walls / 2) * (height of scan)

    while (cscn--)
    {
        crcl += (pscn->cWalls / 2);
        pscn = pscnGet(pscn);

        ASSERTGDI(pscn <= prgn->pscnTail, "sizeSave:Went past end of region\n");
    }

    return(crcl * sizeof(RECTL));
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vDownload(pv)
*
* Download the region to the buffer
*
* History:
*  26-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vDownload(PVOID pv)
{
    PRECTL  prcl = (PRECTL) pv;
    PSCAN   pscn = prgn->pscnHead();
    COUNT   cscn = prgn->cScans;
    RECTL   rclTmp;
    LONG    lPrevBottom = NEG_INFINITY;
    LONG    lPrevRight;

    while (cscn--)
    {
#if DBG
        if (pscn->yTop < lPrevBottom)
            DbgPrint("top < prev bottom, scan %ld, pscn @ 0x%lx\n",
                     prgn->cScans - cscn, (BYTE *)pscn - (BYTE *)prgn->pscnHead());

        if (pscn->yTop > pscn->yBottom)
            DbgPrint("top > bottom, scan %ld, pscn @ 0x%lx\n",
                     prgn->cScans - cscn, (BYTE *)pscn - (BYTE *)prgn->pscnHead());
#endif

        lPrevBottom = pscn->yBottom;


        rclTmp.top    = pscn->yTop;
        rclTmp.bottom = pscn->yBottom;

        COUNT iWall = 0;

        lPrevRight = NEG_INFINITY;

        while (iWall < pscn->cWalls)
        {
            rclTmp.left  = xGet(pscn, (PTRDIFF) iWall);
            rclTmp.right = xGet(pscn, (PTRDIFF) iWall + 1);

#if DBG
            if ((rclTmp.left <= lPrevRight) || (rclTmp.right <= rclTmp.left))
                DbgPrint("left[i] < left[i+1], pscn @ 0x%lx, iWall = 0x%lx\n",
                         (BYTE *)pscn - (BYTE *)prgn->pscnHead(),iWall);
#endif

            lPrevRight = rclTmp.right;

            *prcl++ = rclTmp;
            iWall += 2;
        }

#if DBG
        if (pscn->cWalls != (COUNT)xGet(pscn,(PTRDIFF)iWall))
            DbgPrint("cWalls != cWalls2 @ 0x%lx\n",
                         (BYTE *)pscn - (BYTE *)prgn->pscnHead());
#endif

        pscn = pscnGet(pscn);

#if DBG
        if (pscn > prgn->pscnTail)
        {
            DbgPrint("vDownload1:Went past end of region\n");
            return;
        }
#endif
    }

    return;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vComputeUncoveredSpriteRegion(po)
*
* Upload the region describing the parts of the screen not covered by
* sprites.  Derived from 'bupload'.
*
* History:
*  28-Nov-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vComputeUncoveredSpriteRegion(PDEVOBJ& po)
{
    SPRITESTATE*    pState = po.pSpriteState();
    PSCAN           pscn   = prgn->pscnHead();
    LONG            yTop;
    LONG            yBottom;
    ULONG           cScans;
    ULONG           cWalls;
    RECTL           rcl;

    // First, reset to an empty region:

    vSet();

    // Find the first non-covered range:

    ENUMUNCOVERED Enum(pState);
    if (!Enum.bEnum(&rcl))
        return;                 // Empty region

    cScans = prgn->cScans;

    // Setup variables for first scan:

    yTop = NEG_INFINITY;
    yBottom = rcl.top;
    cWalls = 0;

    do {
        if (rcl.top != yTop)
        {
            cScans++;

            // Close off current scan:

            pscn->yTop = yTop;
            pscn->yBottom = yBottom;
            pscn->cWalls = cWalls;
            pscn->ai_x[cWalls].x = cWalls;

            // Add a null scan if the top of the new rectangle and
            //  the bottom of the old don't overlap:

            if (rcl.top != yBottom)
            {
                cScans++;
                pscn = pscnGet(pscn);
                pscn->yTop = yBottom;
                pscn->yBottom = rcl.top;
                pscn->cWalls = 0;
                pscn->ai_x[0].x = 0;
            }

            // Advance to the next scan:

            pscn = pscnGet(pscn);

            // Open up current scan:

            yTop = rcl.top;
            yBottom = rcl.bottom;
            cWalls = 0;
        }

        pscn->ai_x[cWalls].x = rcl.left;
        pscn->ai_x[cWalls + 1].x = rcl.right;
        cWalls += 2;

    } while (Enum.bEnum(&rcl));

    // Close off current scan:

    pscn->yTop = yTop;
    pscn->yBottom = yBottom;
    pscn->cWalls = cWalls;
    pscn->ai_x[cWalls].x = cWalls;

    // Build final scan:

    cScans++;
    pscn = pscnGet(pscn);
    pscn->cWalls = 0;
    pscn->yTop = yBottom;
    pscn->yBottom = POS_INFINITY;
    pscn->ai_x[0].x = 0;

    prgn->pscnTail = pscnGet(pscn);
    prgn->cScans = cScans;
    prgn->sizeRgn = NULL_REGION_SIZE - NULL_SCAN_SIZE;
    prgn->sizeRgn += (ULONGSIZE_T) (((BYTE *) prgn->pscnTail - (BYTE *) prgn->pscnHead()));
}

/******************************Public*Routine******************************\
*
* History:
*  24-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ()
{
    vInitialize(QUANTUM_REGION_SIZE);
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::RGNMEMOBJ(size)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ(ULONGSIZE_T size)
{
    vInitialize(size);
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::vInitialize(size)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID
RGNMEMOBJ::vInitialize(ULONGSIZE_T size)
{
    RGNLOG rl((PREGION)0,"RGNMEMOBJ::vInitialize(sz)",(ULONG_PTR)size);

// don't bother with anything smaller than a QUANTUM_REGION_SIZE

    if (size <  QUANTUM_REGION_SIZE)
        size = QUANTUM_REGION_SIZE;

// Got to allocate a new one.

    prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);

    rl.vRet((ULONG_PTR)prgn);

    if (prgn)
    {
        vInit(size);
    }
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::RGNMEMOBJ(bInit)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ(BOOL bInit)
{
    RGNLOG rl((PREGION)0,"RGNMEMOBJ::RGNMEMOBJ(b)",(ULONG_PTR)bInit);

    ASSERTGDI(bInit == FALSE,"RGNMEMOBJ::RGNMEMOBJ - bInit == TRUE\n");

    prgn = (PREGION)ALLOCOBJ(QUANTUM_REGION_SIZE,RGN_TYPE,FALSE);

    rl.vRet((ULONG_PTR)prgn);

    if (prgn)
    {
        prgn->sizeObj = QUANTUM_REGION_SIZE;
        prgn->sizeRgn = 0;
        prgn->cRefs   = 0;
    prgn->iUnique = 0;
    }
}

/******************************Public*Function*****************************\
* AddEdgeToGET
*
*  Adds the edge described by the two passed-in points to the Global Edge
*  Table, if the edge spans at least one pixel vertically.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/


PEDGE AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pBound)
{
    LONG lyStart, lyEnd, lxStart, lxEnd, lyHeight, lxWidth,lyStartSave;
    BOOL bTopClip;

// Set the winding-rule direction of the edge, and put the endpoints in
// top-to-bottom order

    lyHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (lyHeight >= 0)
    {
        lxStart = ppfxEdgeStart->x;
        lyStart = ppfxEdgeStart->y;
        lxEnd = ppfxEdgeEnd->x;
        lyEnd = ppfxEdgeEnd->y;
        pFreeEdge->lWindingDirection = 1;
    }
    else
    {
        lyHeight = -lyHeight;
        lxEnd = ppfxEdgeStart->x;
        lyEnd = ppfxEdgeStart->y;
        lxStart = ppfxEdgeEnd->x;
        lyStart = ppfxEdgeEnd->y;
        pFreeEdge->lWindingDirection = -1;
    }

    bTopClip = FALSE;

    if( pBound != NULL )
    {
        if( ( lyEnd < pBound->top ) || ( lyStart > pBound->bottom ) )
        {
        // completely above or below the bound rectangle so skip this segment

            return(pFreeEdge);
        }

        if( lyStart < pBound->top )
        {
        // starts above the rect so clip to the top of the rect

            bTopClip = TRUE;
            lyStartSave = lyStart;
            lyStart = pBound->top;
        }

        if( lyEnd > pBound->bottom )
        {
        // ends below the rect so clip to the bottom of the rect

            lyEnd = pBound->bottom;
        }

    }

// First pixel scan line (non-fractional GIQ Y coordinate) edge intersects.
// Dividing by 16 with a shift is okay because Y is always positive

    pFreeEdge->Y = (lyStart + 15) >> 4;

// Calculate the number of pixels spanned by this edge

    pFreeEdge->lScansLeft = ((lyEnd + 15) >> 4) - pFreeEdge->Y;

    if (pFreeEdge->lScansLeft <= 0)
        return(pFreeEdge);  // no pixels at all are spanned, so we can ignore
                            //  this edge

// Set the error term and adjustment factors, all in GIQ coordinates for new.

    lxWidth = lxEnd - lxStart;
    if (lxWidth >= 0)
    {
    // Left to right, so we change X as soon as we move at all.

        pFreeEdge->lXDirection = 1;
        pFreeEdge->lErrorTerm = -1;
    }
    else
    {
    // Right to left, so we don't change X until we've moved a full GIQ
    // coordinate.

        lxWidth = -lxWidth;
        pFreeEdge->lXDirection = -1;
        pFreeEdge->lErrorTerm = -lyHeight;
    }

    if (lxWidth >= lyHeight)
    {
    // Calculate base run length (minimum distance advanced in X for a 1-
    // scan advance in Y)

        pFreeEdge->lXWhole = lxWidth / lyHeight;

    // Add sign back into base run length if going right to left

        if (pFreeEdge->lXDirection == -1)
            pFreeEdge->lXWhole = -pFreeEdge->lXWhole;

        pFreeEdge->lErrorAdjustUp = lxWidth % lyHeight;
    }
    else
    {
    // Base run length is 0, because line is closer to vertical than
    // horizontal.

        pFreeEdge->lXWhole = 0;
        pFreeEdge->lErrorAdjustUp = lxWidth;
    }
    pFreeEdge->lErrorAdjustDown = lyHeight;

// If the edge doesn't start on a pixel scan (that is, it starts at a
// fractional GIQ coordinate), advance it to the first pixel scan it
// intersects or to the top of the clip rectangle if we are top clipped

    LONG lyAdjust;

    if( bTopClip )
    {
        lyAdjust = pBound->top;
        lyStart = lyStartSave;
    }
    else
    {
        lyAdjust = ( lyStart + 15 ) & ~15;
    }

    while( lyStart != lyAdjust )
    {
    // Starts at a fractional GIQ coordinate, not exactly on a pixel scan
    // Advance the edge's GIQ X coordinate for a 1-GIQ-pixel Y advance
    // Advance by the minimum amount

        lxStart += pFreeEdge->lXWhole;

    // Advance the error term and see if we got one extra pixel this time.

        pFreeEdge->lErrorTerm += pFreeEdge->lErrorAdjustUp;
        if (pFreeEdge->lErrorTerm >= 0)
        {
        // The error term turned over, so adjust the error term and
        // advance the extra pixel.

            pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown;
            lxStart += pFreeEdge->lXDirection;
        }
        lyStart++;  // advance to the next GIQ Y coordinate
    }

// Turn the calculations into pixel rather than GIQ calculations

// Move the X coordinate to the nearest pixel, and adjust the error term
// accordingly
// Dividing by 16 with a shift is okay because X is always positive

    pFreeEdge->X = (lxStart + 15) >> 4; // convert from GIQ to pixel coordinates

    if (pFreeEdge->lXDirection == 1)
    {
    // Left to right

        pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown *
                (((lxStart + 15) & ~0x0F) - lxStart);
    }
    else
    {
    // Right to left

        pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown *
                ((lxStart - 1) & 0x0F);
    }

// Scale the error adjusts up by 16 times, to move 16 GIQ pixels at a time.
// Shifts work to do the multiplying because these values are always
// non-negative

    pFreeEdge->lErrorAdjustUp <<= 4;
    pFreeEdge->lErrorAdjustDown <<= 4;

// Insert the edge into the GET in YX-sorted order. The search always ends
// because the GET has a sentinel with a greater-than-possible Y value

    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X)))
    {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

/******************************Public*Function*****************************\
* vConstructGET
*
*  Build the Global Edge Table from the path.  The GET is constructed in
*  Y-X order, and has a head/tail/sentinel node at pGETHead.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vConstructGET(EPATHOBJ& po, EDGE *pGETHead, EDGE *pFreeEdges,RECTL *pBound)
{
// Create an empty GET with the head node also a tail sentinel

    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

    PPATH ppath = po.ppath;

    PPOINTFIX pptfxStart, pptfxEnd, pptfx;
    PPOINTFIX pptfxPrev = NULL;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
    // If first point starts a subpath, remember it as such
    // and go on to the next point, so we can get an edge.

        pptfx = ppr->aptfx;

        if (ppr->flags & PD_BEGINSUBPATH)
        {
            pptfxStart = ppr->aptfx;        // the subpath starts here
            pptfxPrev = ppr->aptfx;         // this points starts next edge
            pptfx++;                        // advance to the next point
        }

   // Add edges in PATH to GET, in Y-X sorted order.

        pptfxEnd = ppr->aptfx + ppr->count;

        while (pptfx < pptfxEnd)
        {
            ASSERTGDI(pptfxPrev != NULL, "No path record with PD_BEGINSUBPATH");

            pFreeEdges =
                AddEdgeToGET(pGETHead, pFreeEdges,pptfxPrev,pptfx,pBound);
            pptfxPrev = pptfx;
            pptfx++;                        // advance to the next point
        }

     // If last point ends the subpath, insert the edge that
     // connects to first point.

        if (ppr->flags & PD_ENDSUBPATH)
        {
            pFreeEdges =
                AddEdgeToGET(pGETHead, pFreeEdges,pptfxPrev, pptfxStart,pBound);

            pptfxPrev = NULL;
        }
    }
}

/******************************Public*Function*****************************\
* vAdvanceAETEdges
*
*  Advance the edges in the AET to the next scan, dropping any for which we've
*  done all scans. Assumes there is at least one edge in the AET.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vAdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;
    COUNT c = pAETHead->Y;                  // Y is used as edge count in AET

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do
    {
    // Count down this edge's remaining scans

        if (--pCurrentEdge->lScansLeft == 0)
        {
        // We've done all scans for this edge; drop this edge from the AET

            pLastEdge->pNext = pCurrentEdge->pNext;
            c--;
        }
        else
        {
        // Advance the edge's X coordinate for a 1-scan Y advance
        // Advance by the minimum amount

            pCurrentEdge->X += pCurrentEdge->lXWhole;

        // Advance the error term and see if we got one extra pixel this time.

            pCurrentEdge->lErrorTerm += pCurrentEdge->lErrorAdjustUp;
            if (pCurrentEdge->lErrorTerm >= 0)
            {
            // The error term turned over, so adjust the error term and
            // advance the extra pixel.

                pCurrentEdge->lErrorTerm -= pCurrentEdge->lErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->lXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
    pAETHead->Y = c;                        // Y is used as edge count in AET
}

/******************************Public*Function*****************************\
* vXSortAETEdges
*
*  X-sort the AET, because the edges may have moved around relative to
*  one another when we advanced them. We'll use a multipass bubble
*  sort, which is actually okay for this application because edges
*  rarely move relative to one another, so we usually do just one pass.
*  Also, this makes it easy to keep just a singly-linked list. Assumes there
*  are at least two edges in the AET.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vXSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do
    {
        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X)
            {
            // Next edge is to the left of the current edge; swap them.

                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

/******************************Public*Function*****************************\
* vMoveNewEdges
*
*  Moves all edges that start on the current scan from the GET to the AET in
*  X-sorted order. Parameters are pointer to head of GET and pointer to dummy
*  edge at head of AET, plus current scan line. Assumes there's at least one
*  edge to be moved.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vMoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, LONG lyCurrent)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;
    COUNT c = pAETHead->Y;          // Y is used as edge count in AET

    do
    {
    // Scan through the AET until the X-sorted insertion point for this
    // edge is found. We can continue from where the last search left
    // off because the edges in the GET are in X sorted order, as is
    // the AET. The search always terminates because the AET sentinel
    // is greater than any valid X

        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X)
            pCurrentEdge = pCurrentEdge->pNext;

    // We've found the insertion point; add the GET edge to the AET, and
    // remove it from the GET.

        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;
        c++;

    } while (pGETNext->Y == lyCurrent);
    pAETHead->Y = c;                // Y is used as edge count in AET
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bAddScans
*
*  Add a new scan into the region.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bAddScans(LONG yTop, PEDGE pAETHead, FLONG flOptions)
{
    ULONGSIZE_T cWalls = (ULONGSIZE_T)pAETHead->Y;    // Y is used as edge count in AET
    ULONGSIZE_T size = cWalls * sizeof(INDEX_LONG) + NULL_SCAN_SIZE;

// Check for nearly full region

    if (size > prgn->sizeObj - prgn->sizeRgn)
    {
    // There isn't enough space for this scan, lets try to realloc this region.
    // We want to expand to a big enough size to avoid reallocation in the near
    // future.

        if (!bExpand(prgn->sizeObj + size + FILL_REGION_SIZE))
            return(FALSE);
    }

    PSCAN pscn = (SCAN *) prgn->pscnTail;      // points pass last scan

    ASSERTGDI(yTop == pscnGot(pscn)->yBottom, "bAddNullScan: bad yTop\n");

    PEDGE pCurrentEdge = pAETHead->pNext;   // point to the first edge

// yBottom is the dword before ai_x[0] in the SCAN structure.
// Stuff NEG_INFINITY there so the first wall is bigger than
// the "previous" wall.  yBottom will be initialized later on.

    PLONG pWallStart = (LONG *)&pscn->yBottom;
    PLONG pWall = pWallStart;
    *pWall = NEG_INFINITY;

    if (flOptions & WINDING)
    {
    // Do winding fill; scan across until we've found equal numbers
    // of up and down edges.

        while (pCurrentEdge != pAETHead)
        {
            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            LONG lWindingCount = pCurrentEdge->lWindingDirection;
            do
            {
                pCurrentEdge = pCurrentEdge->pNext;
                lWindingCount += pCurrentEdge->lWindingDirection;
            } while (lWindingCount != 0);

            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            pCurrentEdge = pCurrentEdge->pNext;
        }
    }
    else
    {
        while (pCurrentEdge != pAETHead)
        {
            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            pCurrentEdge = pCurrentEdge->pNext;
        }
    }

    ASSERT4GB ((LONGLONG)(((BYTE *)pWall - (BYTE *)pWallStart) / sizeof(LONG)));
    cWalls = (ULONGSIZE_T)(((BYTE *)pWall - (BYTE *)pWallStart) / sizeof(LONG));

    PSCAN pscnPrev = pscnGot(pscn);

    if ((pscnPrev->cWalls == cWalls) &&
        !memcmp(pscnPrev->ai_x, pscn->ai_x,cWalls * sizeof(LONG)))
    {
        pscnPrev->yBottom = yTop+1;
    }
    else
    {
        prgn->cScans += 1;
        prgn->sizeRgn += (ULONGSIZE_T)(NULL_SCAN_SIZE + sizeof(INDEX_LONG) * cWalls);
        ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "bAddScans: sizeRgn > sizeObj\n");
        ASSERTGDI((cWalls & 1) == 0,"bAddScan error: cWalls odd number\n");

        pscn->yTop = yTop;
        pscn->yBottom = yTop+1;

        pscn->cWalls = cWalls;
        pscn->ai_x[cWalls].x = cWalls;              // This sets cWalls2
        prgn->pscnTail = pscnGet(pscn);
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bAddNullScan
*
*  Add a null scan into the region.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bAddNullScan(LONG yTop, LONG yBottom)
{
// Check for nearly full region

    if (NULL_SCAN_SIZE > prgn->sizeObj - prgn->sizeRgn)
    {
    // There isn't enough space for this scan, lets try to realloc this region.
    // We want to expand to a big enough size to avoid reallocation in the near
    // future.

        if (!bExpand(prgn->sizeObj + NULL_SCAN_SIZE + FILL_REGION_SIZE))
            return(FALSE);
    }

    PSCAN pscn = (SCAN *) prgn->pscnTail;      // points pass last scan
    ASSERTGDI(prgn->cScans == 0 || yTop == pscnGot(pscn)->yBottom,
              "bAddNullScan: bad yTop\n");

    prgn->cScans += 1;

    pscn->yTop = yTop;
    pscn->yBottom = yBottom;

    prgn->sizeRgn += (ULONGSIZE_T)NULL_SCAN_SIZE;
    ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "bAddNullScan: sizeRgn > sizeObj\n");

    pscn->cWalls = pscn->ai_x[0].x = 0;
    prgn->pscnTail = pscnGet(pscn);

    return(TRUE);
}

/******************************Member*Function*****************************\
* VOID RGNMEMOBJ::vCreate(po, fl)
*
* Routine for constructing a region from a path.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Removed trapazoidal regions.
*  04-Apr-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID RGNMEMOBJ::vCreate(
EPATHOBJ&   po,
FLONG       flOptions, // ALTERNATE or WINDING
RECTL       *pBound
)
{
    GDIFunctionID(RGNMEMOBJ::vCreate);

    RGNLOG rl((PREGION)NULL,"RGNMEMOBJ::vCreate");
    rl.vRet(0);

    if (!po.bValid())
    {
        RIP("Invalid EPATHOBJ");
    }
    else
    {

        ULONG count;
        EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
        EDGE *pAETHead;     // pointer to AETHead
        EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
        EDGE *pGETHead;     // pointer to GETHead
        EDGE aEdge[MAX_POINTS];

        prgn = (REGION *) NULL;         // Assume failure.

        if (po.bBeziers() && !po.bFlatten())
            return;

    // The given path should be closed when create region from path
    // then make sure it here.

        po.vCloseAllFigures();

        if ((count = po.cCurves) < 2)
            return;

        // Is path contained in a bounding rectangle?
        //
        // If there is no bound (pBound = NULL) or 
        // the bound won't shrink the current BoundBox
        // then try bFastFillWrapper.
        //
        // Many calling sites only initialize the top and bottom of the
        // pBound rectange because the underlying clipping code only
        // uses the top and bottom.
        // Also, they always initialize them in FIX coordinate.

        if ( (pBound==NULL) ||
             ( ( pBound->top    < po.rcfxBoundBox().yTop   ) &&
               ( pBound->bottom > po.rcfxBoundBox().yBottom)
           ) )
        {
             if (bFastFillWrapper(po))
             {
                 vTighten();
                 rl.vRet((ULONG_PTR)prgn);
                 return;
             }
        }

    // Allocate memory for edge storage.

        BOOL bAlloc;
        EDGE *pFreeEdges;   // pointer to memory free for use to store edges

        if (count < MAX_POINTS)
        {
            pFreeEdges = &aEdge[0];
            bAlloc     = FALSE;
        }
        else
        {
            pFreeEdges = (PEDGE)PALLOCNOZ(sizeof(EDGE) * (count + 1), 'ngrG');
            if (pFreeEdges == (PEDGE)NULL)
                return;
            bAlloc     = TRUE;
        }

    // This is a size of random guess...
    // Given a path of n points, assume there are n scans with 4 walls on each
    // scan.  The region will be expanded later if this size is too small.

        ULONG size;
        LONGLONG llSize;
        FIX top    = po.rcfxBoundBox().yTop;
        FIX bottom = po.rcfxBoundBox().yBottom;

        if (bottom < top)
        {
            // WINBUG #178736 claudebe 9-7-2000 we should check for math overflow where the path is created/offset/scaled see stress #178262
            // when this is done, we can chage this test back into an assert
            WARNING("PATHOBJ BoundBox is invalid.\n");

            if (bAlloc)
                VFREEMEM(pFreeEdges);

            return;
        }

        // Make sure we account for the clipping in our estimate.
        // Without this code, we could overestimate by many orders
        // of magnitude.

        if (pBound)
        {
            top    = MAX(top,    pBound->top);
            bottom = MIN(bottom, pBound->bottom);
        }

        // The smallest region we should have from bounding is zero.
        // Note this also takes care of the conversion issue of using
        //  FXTOL and assigning the result to an unsigned long.
        // using LONGLONG because bottom-top may overflow a ULONG

        llSize = MAX((LONGLONG)bottom-(LONGLONG)top, 0);

        // we know that after >> 4, the result will fit in a ULONG
        size = (ULONG)(FXTOL(llSize)) + 10;

        if (size < 0x00ffffff)
        {
            size = QUANTUM_REGION_SIZE + (sizeof(INDEX_LONG) * 4 + NULL_SCAN_SIZE) * size;

            prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);
        }

        if (!prgn)
        {
            if (bAlloc)
                VFREEMEM(pFreeEdges);

            return;
        }

        prgn->sizeObj = size;
        prgn->sizeRgn = offsetof(REGION,scan);
        prgn->cRefs = 0;
        prgn->iUnique = 0;
        prgn->cScans = 0;           // start from scratch, assume no scans
        prgn->pscnTail = prgn->pscnHead();

    // Construct the global edge list.

        pGETHead = &GETHead;
        vConstructGET(po, pGETHead, pFreeEdges,pBound);    // bad line coordinates or

        BOOL bSucceed = TRUE;
        LONG yTop = NEG_INFINITY;   // scan line for which we're currently scanning

    // Create an empty AET with the head node also a tail sentinel

        pAETHead = &AETHead;
        AETHead.pNext = pAETHead;   // mark that the AET is empty
        AETHead.Y = 0;              // used as a count for number of edges in AET
        AETHead.X = 0x7FFFFFFF;     // this is greater than any valid X value, so
                                    //  searches will always terminate

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out.

        while (bSucceed)
        {
        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)

            if (AETHead.pNext != pAETHead)
                vAdvanceAETEdges(pAETHead);

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET

            if (AETHead.pNext == pAETHead)
            {
            // Done if there are no edges in either the AET or the GET

                if (GETHead.pNext == pGETHead)
                    break;

            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET.

                LONG    yTopOld = yTop;
                yTop = ((EDGE *)GETHead.pNext)->Y;
                if (yTop != yTopOld)
                {
                // Fill in NULL scan between rectangles.

                    if (!(bSucceed = bAddNullScan(yTopOld, yTop)))
                        break;
                }
            }
            else
            {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)

                if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
                    vXSortAETEdges(pAETHead);
            }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add

            if (((EDGE *)GETHead.pNext)->Y == yTop)
                vMoveNewEdges(pGETHead, pAETHead, yTop);

        // Scan the AET into region scans (there's always at least one
        // edge pair in the AET)

            bSucceed = bAddScans(yTop, pAETHead, flOptions);
            yTop++;    // next scan
        }

        if (!bSucceed ||
            !bAddNullScan(yTop, POS_INFINITY))
        {
            bDeleteRGNOBJ();
            bSucceed = FALSE;
        }
        else
        {
            vTighten();
        }

        if (bAlloc)
            VFREEMEM(pFreeEdges);

        rl.vRet((ULONG_PTR)prgn);

    }
}

/******************************Member*Function*****************************\
* RGNMEMOBJ::bFastFillWrapper
*
*   create a rgn from a convex polygon.
*
* History:
*  27-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define QUICKPOINTS 40

BOOL RGNMEMOBJ::bFastFillWrapper(
    EPATHOBJ& epo)
{
    PATHDATA pd;
    BOOL     bRes = FALSE;

    ASSERTGDI(!(epo.fl & PO_BEZIERS),"RGNMEMOBJ::bFastFill - bez\n");
    ASSERTGDI(epo.cCurves == epo.cTotalPts(),"RGNMEMOBJ::cCurves != cTotalPts\n");

    epo.vEnumStart();

    if (epo.bEnum(&pd))
    {
        // if this ends the sub path, that means there is more than one sub path.
        // also don't handle if we can't copy points onto stack

        if (!(pd.flags & PD_ENDSUBPATH) && (epo.cCurves <= QUICKPOINTS))
        {
            POINTFIX aptfx[QUICKPOINTS];
            LONG cPoints;
            BOOL bMore;

            RtlCopyMemory(aptfx,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
            cPoints = pd.count;

            do {
                bMore = epo.bEnum(&pd);

                if (pd.flags & PD_BEGINSUBPATH)
                    goto DoStart;

                RtlCopyMemory(aptfx+cPoints,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
                cPoints += pd.count;

            } while(bMore);

            // Should never hit this assert. if hit, the stack is already broken...

            ASSERTGDI(cPoints <= QUICKPOINTS,"RGNMEMOBJ::bFastFillWrapper - too many points\n");

            bRes = bFastFill(epo,cPoints,aptfx);
        }
    }
    else if (pd.count > 1)
    {
        bRes = bFastFill(epo,pd.count,pd.pptfx);
    }
    else
    {
        bRes = TRUE;
    }

DoStart:
    epo.vEnumStart();

    return(bRes);
}

/******************************Member*Function*****************************\
* RGNMEMOBJ::bFastFill
*
*   create a rgn from a convex polygon.
*   this routine is very similar to bFastFill in fastfill.cxx
*
* History:
*  14-Oct-1993 -by-  Eric Kutter [erick]
* initial code stolen from s3 driver.
\**************************************************************************/

BOOL RGNMEMOBJ::bFastFill(
    EPATHOBJ& po,
    LONG      cEdges,       // Includes close figure edge
    POINTFIX* pptfxFirst)
{
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    LONG yCurrent;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    yCurrent = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

#define RIGHT 0
#define LEFT  1

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

    // setup the region

    ULONGSIZE_T size = (ULONGSIZE_T)(NULL_REGION_SIZE + NULL_SCAN_SIZE +
                   (sizeof(INDEX_LONG) * 2 + NULL_SCAN_SIZE) *
                   FXTOL(po.rcfxBoundBox().yBottom - po.rcfxBoundBox().yTop + 15));

    prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);

    if (!prgn)
        return(FALSE);

    prgn->sizeObj  = size;
    prgn->sizeRgn  = offsetof(REGION,scan);
    prgn->cRefs    = 0;
    prgn->cScans   = 0;           // start from scratch, assume no scans
    prgn->pscnTail = (PSCAN)((PBYTE)prgn + size);

    // setup the scans

    PSCAN pscnPrev= prgn->pscnHead();
    ULONG cScans  = 1;

    pscnPrev->yTop    = NEG_INFINITY;
    pscnPrev->yBottom = yCurrent;
    pscnPrev->cWalls  = 0;
    pscnPrev->ai_x[0].x = 0;

    PSCAN pscn = pscnGet(pscnPrev);

NextEdge:

    ASSERTGDI(pscn < prgn->pscnTail,"bFastFill - pscn past end\n");

    // We loop through this routine on a per-trapezoid basis.

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                {
                // the only way out

                    if (pscnPrev->cWalls == 0)
                    {
                        pscnPrev->yBottom = POS_INFINITY;
                    }
                    else
                    {
                        pscn->cWalls  = 0;
                        pscn->ai_x[0].x = 0;
                        pscn->yTop    = yCurrent;
                        pscn->yBottom = POS_INFINITY;
                        ++cScans;
                        pscn = pscnGet(pscn);
                    }

                    ASSERTGDI(pscn <= prgn->pscnTail,"bFastFill - pscn past end2\n");

                    prgn->cScans = cScans;
                    prgn->pscnTail = pscn;

                    ASSERT4GB((ULONGLONG)((PBYTE)pscn - (PBYTE)prgn));
                    prgn->sizeRgn  = (ULONG)((PBYTE)pscn - (PBYTE)prgn);

                    return(TRUE);
                }
                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yCurrent:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yCurrent;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yCurrent'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTGDI(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i > 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0))
    {
        LONG xL = aed[LEFT].x;
        LONG xR = aed[RIGHT].x;

        if (xL != xR)
        {
            if (xL > xR)
            {
                LONG l = xL;
                xL = xR;
                xR = l;
            }

        // non NULL case

            if ((pscnPrev->cWalls  == 2) &&
                (pscnPrev->ai_x[0].x == xL) &&
                (pscnPrev->ai_x[1].x == xR))
            {
                pscnPrev->yBottom = yCurrent+cyTrapezoid;
            }
            else
            {
                pscn->cWalls  = 2;
                pscn->ai_x[0].x = xL;
                pscn->ai_x[1].x = xR;
                pscn->ai_x[2].x = 2;
                pscn->yTop    = yCurrent;
                pscn->yBottom = yCurrent+cyTrapezoid;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);
                ++cScans;
            }
        }
        else
        {
        // NULL scan case

            if (pscnPrev->cWalls == 0)
            {
                pscnPrev->yBottom = yCurrent+cyTrapezoid;
            }
            else
            {
                pscn->cWalls  = 0;
                pscn->ai_x[0].x = 0;
                pscn->yTop    = yCurrent;
                pscn->yBottom = yCurrent+cyTrapezoid;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);
                ++cScans;
            }
        }

        yCurrent += cyTrapezoid;

        goto NextEdge;
    }

    while (TRUE)
    {
        LONG lWidth = aed[RIGHT].x - aed[LEFT].x;

        if (lWidth > 0)
        {
            if ((pscnPrev->cWalls  == 2) &&
                (pscnPrev->ai_x[0].x == aed[LEFT].x) &&
                (pscnPrev->ai_x[1].x == aed[RIGHT].x))
            {
            // the scans coalesce, just need to change the bottom

    ContinueAfterZeroDup:

                pscnPrev->yBottom = ++yCurrent;
            }
            else
            {
            // need to setup the entire scan

                pscn->cWalls  = 2;
                pscn->ai_x[0].x = aed[LEFT].x;
                pscn->ai_x[1].x = aed[RIGHT].x;
                pscn->ai_x[2].x = 2;

    ContinueAfterZero:

                pscn->yTop    = yCurrent;
                pscn->yBottom = ++yCurrent;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);    // (PBYTE)pscn + NULL_SCAN_SIZE + 2 * sizeof(LONG);
                ++cScans;
            }

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;

            if (cyTrapezoid == 0)
                goto NextEdge;
        }
        else if (lWidth == 0)
        {
            // NULL scan, do null scan specific stuff

            if (pscnPrev->cWalls == 0)
            {
                goto ContinueAfterZeroDup;
            }
            else
            {
                pscn->cWalls  = 0;
                pscn->ai_x[0].x = 0;

                goto ContinueAfterZero;
            }
        }
        else
        {
            #define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            EDGEDATA edTmp;
            SWAP(aed[LEFT],aed[RIGHT],edTmp);

            continue;
        }
    }
}

#if DBG
/******************************Member*Function*****************************\
* VOID RGNOBJ::vPrintScans()
*
*  DbgPrint the walls of every scan of the given region.  This is
*  for debugging only.
*
* History:
*  08-Mar-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vPrintScans()
{
    COUNT cScans = prgn->cScans;
    PSCAN pscn = prgn->pscnHead();

    for (COUNT i = 0;
         i < cScans;
         i++)
    {
        COUNT cWalls = pscn->cWalls;
        DbgPrint("Scan %ld: yTop = %ld, yBottom = %ld, cWalls = %ld\n",
                  i, pscn->yTop, pscn->yBottom, cWalls);

        for (COUNT j = 0;
             j < cWalls;
             j+=2)
        {
            DbgPrint("  Left edge: index = %ld\n", pscn->ai_x[j].x);
            DbgPrint("  Right edge: index = %ld\n", pscn->ai_x[j+1].x);
        }
        pscn = pscnGet(pscn);
    }
}
#endif

/******************************Public*Routine******************************\
* VOID vTighten()
*
* Tighten the bounding rectangle
*
* History:
*  21-May-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vTighten()
{
// If this is a NULL region, zero the bounding box and get out of here.

    if (prgn->cScans == 1)
    {
        prgn->rcl.left = 0;
        prgn->rcl.bottom = 0;
        prgn->rcl.right = 0;
        prgn->rcl.top = 0;
        return;
    }

// Start with a maximally crossed rectangle

    ERECTL  ercl(POS_INFINITY, POS_INFINITY, NEG_INFINITY, NEG_INFINITY);
    COUNT   cScans = prgn->cScans;
    PSCAN   pscn = pscnGot(prgn->pscnTail);

    ercl.bottom = pscn->yTop;          // The top of the empty bottom scan
    pscn = prgn->pscnHead();
    ercl.top = pscn->yBottom;          // The bottom of the empty top scan

    COUNT   cWall;

    while (cScans--)
    {
    // Are there any walls?

        if ((cWall = pscn->cWalls) != 0)
        {
            if (ercl.left > pscn->ai_x[0].x)
                ercl.left = pscn->ai_x[0].x;
            if (ercl.right < pscn->ai_x[cWall - 1].x)
                ercl.right = pscn->ai_x[cWall - 1].x;
        }

        pscn = pscnGet(pscn);

        ASSERTGDI(pscn <= prgn->pscnTail, "vTighten2:Went past end of region\n");
    }

    if (ercl.left >= ercl.right)
    {
        ercl.left  = 0;
        ercl.right = 0;
    }

    prgn->rcl = *((RECTL *) &ercl);
}

/******************************Public*Routine******************************\
* BOOL vFramed(pscn, iWall)
*
* Marks the given wall as having been added to the frame path.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define REGION_FRAMED_OFFSET 0x10000000L
#define DIR_UP               0x00000001L
#define DIR_DOWN             0x00000000L

inline VOID vFramed(SCAN* pscn, LONG iWall, RGNOBJ* pro)
{
#if DBG
    if (!VALID_SCR(pscn->ai_x[iWall].x))
    {
        pro->bValidateFramedRegion();
        RIP("Wall revisited");
    }
#endif

    DONTUSE(pro);
    pscn->ai_x[iWall].x += REGION_FRAMED_OFFSET;
}

/******************************Public*Routine******************************\
* BOOL bFramed(pscn, iWall)
*
* Returns TRUE if the wall has already been added to the frame's path.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline BOOL bFramed(SCAN* pscn, LONG iWall)
{
    return(pscn->ai_x[iWall].x > MAX_REGION_COORD);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::xMyGet(pscn, iWall, iDir)
*
* Retrieves the x-value of the wall of the given scan, iDir indicating
* if it should be the top or bottom.
*
* History:
*  31-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline LONG RGNOBJ::xMyGet(SCAN* pscn, LONG iWall, LONG iDir)
{
    DONTUSE(iDir);

    INDEX_LONG il = pscn->ai_x[iWall];

    if (il.x > MAX_REGION_COORD)
        il.x -= REGION_FRAMED_OFFSET;

#if DBG
    if (!VALID_SCR(il.x))
    {
        bValidateFramedRegion();
        RIP("Wall Revisited");
    }
#endif

    return(il.x);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bOutline(epo, pexo)
*
* Create a path from the outline of a region.
*
* WARNING: This call destroys the data in the region!
*
* Note that this code makes the implicit assumption that the x-value of
* adjacent walls is not the same (i.e., no empty rectangles).
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bOutline(
EPATHOBJ& epo,
EXFORMOBJ *pexo)
{
    RGNLOG rl(prgn,"RGNOBJ::bOutline");

    POINTL  aptl[2];
    COUNT   cScans;
    SCAN*   pscnCurrent;
    COUNT   iWallCurrent;
    COUNT   cWallsCurrent;

// Now compute the outline:

    pscnCurrent = prgn->pscnHead();
    cScans      = prgn->cScans;

    while (cScans--)
    {
        cWallsCurrent = pscnCurrent->cWalls;
        for (iWallCurrent = 0; iWallCurrent != cWallsCurrent; iWallCurrent++)
        {
        // Only start at unvisited walls:

            if (!bFramed(pscnCurrent, iWallCurrent))
            {
                SCAN* pscn    = pscnCurrent;
                COUNT iWall   = iWallCurrent;
                LONG  iTurn;

                aptl[0].x = xMyGet(pscn, iWallCurrent, DIR_UP);
                aptl[0].y = pscn->yTop;

                if (!epo.bMoveTo(pexo, aptl))
                    return(FALSE);

                SCAN* pscnSearch = pscnGet(pscn);
                BOOL  bInside = (BOOL) (iWallCurrent & 1);

            // Mark that we've visited this wall:

                vFramed(pscn, iWall, this);

            // Loop until the path closes on itself:

            GoDown:
                iTurn = +1;
                while (pscnSearch->cWalls != 0)
                {
                    LONG xWall = xMyGet(pscn, iWall, DIR_DOWN);
                    LONG iNewWall;
                    LONG xNewWall;

                    COUNT iLeft  = bInside;
                    COUNT iRight = pscnSearch->cWalls - 1 - bInside;

                // It would be nice if the first wall in the region structure
                // was minus infinity, but it isn't, so we do this check:

                    if (xMyGet(pscnSearch, iLeft, DIR_UP) > xWall)
                        iNewWall = iLeft;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // minimum x-value > xWall:

                        if (xMyGet(pscnSearch, iRight, DIR_UP) <= xWall)
                            break;                  // =====>

                    // Do a binary search to find it:

                        while (TRUE)
                        {
                            COUNT iSearch = (iLeft + iRight) >> 1;
                            if (iSearch == iLeft)
                                break;              // =====>

                            LONG xSearch = xMyGet(pscnSearch, iSearch, DIR_UP);

                            if (xSearch > xWall)
                                iRight = iSearch;
                            else
                                iLeft = iSearch;
                        }
                        iNewWall = iRight;
                    }

                    if ((iNewWall & 1) != bInside)
                    {
                    // There is a region directly below xWall.  We can't
                    // move down if its left side is < the left
                    // side of our space:

                        if (iWall > 0 &&
                            xMyGet(pscnSearch, iNewWall - 1, DIR_UP) <
                            xMyGet(pscn, iWall - 1, DIR_DOWN))
                        {
                            iTurn = -1;
                            break;                      // =====>
                        }

                        iNewWall--;
                    }
                    else
                    {
                    // There is a space directly below xWall.  We can't
                    // move down if its right side is more than the
                    // right side of our region:

                        if (xMyGet(pscnSearch, iNewWall, DIR_UP) >=
                            xMyGet(pscn, iWall + 1, DIR_DOWN))
                            break;                      // =====>
                    }

                    xNewWall  = xMyGet(pscnSearch, iNewWall, DIR_UP);

                // Don't bother outputing multiple in-line straight lines:

                    if (xWall != xNewWall                               ||
                        xMyGet(pscn, iWall, DIR_UP) != xNewWall         ||
                        xMyGet(pscnSearch, iNewWall, DIR_DOWN) != xNewWall)
                    {
                        aptl[0].x = xWall;
                        aptl[0].y = pscn->yBottom;
                        aptl[1].y = pscn->yBottom;
                        aptl[1].x = xNewWall;

                        if (!epo.bPolyLineTo(pexo, aptl, 2))
                            return(FALSE);
                    }

                    pscn       = pscnSearch;
                    iWall      = iNewWall;
                    pscnSearch = pscnGet(pscn);

                    vFramed(pscn, iWall, this);
                }

            // Setup to go up other side:

                aptl[0].x = xMyGet(pscn, iWall, DIR_DOWN);
                aptl[0].y = pscn->yBottom;
                aptl[1].y = pscn->yBottom;
                aptl[1].x = xMyGet(pscn, iWall + iTurn, DIR_DOWN);

                if (!epo.bPolyLineTo(pexo, aptl, 2))
                    return(FALSE);

                pscnSearch = pscnGot(pscn);
                iWall += iTurn;
                vFramed(pscn, iWall, this);

            // Go up:

                iTurn = -1;
                while (pscnSearch->cWalls != 0)
                {
                    LONG  xWall = xMyGet(pscn, iWall, DIR_UP);
                    LONG  iNewWall;
                    LONG  xNewWall;

                    COUNT iLeft  = bInside;
                    COUNT iRight = pscnSearch->cWalls - 1 - bInside;

                // It would be nice if the last wall in the region structure
                // was plus infinity, but it isn't, so we do this check:

                    if (xMyGet(pscnSearch, iRight, DIR_DOWN) < xWall)
                        iNewWall = iRight;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // maximum x-value < xWall:

                        if (xMyGet(pscnSearch, iLeft, DIR_DOWN) >= xWall)
                            break;                  // =====>

                    // Binary search to find it:

                        while (TRUE)
                        {
                            COUNT iSearch = (iLeft + iRight) >> 1;
                            if (iSearch == iLeft)
                                break;              // =====>

                            LONG xSearch = xMyGet(pscnSearch, iSearch, DIR_DOWN);

                            if (xSearch >= xWall)
                                iRight = iSearch;
                            else
                                iLeft = iSearch;
                        }
                        iNewWall = iLeft;
                    }

                    if ((iNewWall & 1) == bInside)
                    {
                    // There is a region directly above xWall.  We can't
                    // move up if its right side is more than the right
                    // side of our space:

                        if (iWall < pscn->cWalls - 1 &&
                            xMyGet(pscnSearch, iNewWall + 1, DIR_DOWN) >
                            xMyGet(pscn, iWall + 1, DIR_UP))
                        {
                            iTurn = +1;
                            break;                          // =====>
                        }

                        iNewWall++;
                    }
                    else
                    {
                    // There is a space directly above xWall.  We can't
                    // move up if its left side is <= the left side
                    // of our region:

                        if (xMyGet(pscnSearch, iNewWall, DIR_DOWN) <=
                            xMyGet(pscn, iWall - 1, DIR_UP))
                            break;                          // =====>
                    }

                    xNewWall = xMyGet(pscnSearch, iNewWall, DIR_DOWN);

                // Don't bother outputing multiple in-line straight lines:

                    if (xWall != xNewWall                               ||
                        xMyGet(pscn, iWall, DIR_DOWN) != xNewWall       ||
                        xMyGet(pscnSearch, iNewWall, DIR_UP) != xNewWall)
                    {
                        aptl[0].x = xWall;
                        aptl[0].y = pscn->yTop;
                        aptl[1].y = pscn->yTop;
                        aptl[1].x = xNewWall;

                        if (!epo.bPolyLineTo(pexo, aptl, 2))
                            return(FALSE);
                    }

                    pscn       = pscnSearch;
                    iWall      = iNewWall;
                    pscnSearch = pscnGot(pscn);

                    vFramed(pscn, iWall, this);
                }

            // Check if we've returned to where we started from:

                if (pscnCurrent != pscn || iWallCurrent != iWall - 1)
                {
                // Setup to go down other side:

                    aptl[0].x = xMyGet(pscn, iWall, DIR_UP);
                    aptl[0].y = pscn->yTop;
                    aptl[1].y = pscn->yTop;
                    aptl[1].x = xMyGet(pscn, iWall + iTurn, DIR_UP);

                    if (!epo.bPolyLineTo(pexo, aptl, 2))
                        return(FALSE);

                    pscnSearch = pscnGet(pscn);
                    iWall += iTurn;
                    vFramed(pscn, iWall, this);

                    goto GoDown;                    // =====>
                }

            // We're all done with this outline!

                aptl[0].x = xMyGet(pscn, iWall, DIR_UP);
                aptl[0].y = pscn->yTop;

                if (!epo.bPolyLineTo(pexo, aptl, 1) ||
                    !epo.bCloseFigure())
                    return(FALSE);
            }
        }
        pscnCurrent  = pscnGet(pscnCurrent);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bCreate(epo, pexo)
*
* Create a path from the frame of a region without destroying the region.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bCreate(
EPATHOBJ& epo,
EXFORMOBJ *pexo)
{

// When converting the region to a path, bCreate() destroys the region's
// data, which would be sort of rude, so make a copy of the region first:

    BOOL bRes;
    RGNMEMOBJTMP rmoCopy(sizeRgn());
    if (!rmoCopy.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
    }
    else
    {
        rmoCopy.vCopy(*this);

        VALIDATE(rmoCopy);

        bRes = rmoCopy.bOutline(epo, pexo);

        VALIDATE(*(RGNOBJ *)this);
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bSubtract(prcl, arcl, crcl)
*
* Subtract a list of rectangles from a rectangle to produce a region.
* This is just a special case of bMerge and is written to speed up
* USER's computation of VisRgns for obscured windows.
*
* WARNING: If this function returns FALSE, the region may be inconsistent.
*          The caller must discard or reset the region. (See bug #343770)
*
* History:
*  10-Aug-1993 -by-  Eric Kutter [erick]
*       rewrote the complex case.  (accounts for 50% of operations)
*
*  18-Nov-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSubtract(RECTL *prcl, RECTL *arcl, int crcl)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bSubtract");
    rl.vRet(0);

    PREGION prgn1 = prgn;

    ASSERTGDI(crcl > 0, "Zero rectangles in RGNOBJ::bSubtract\n");

// Since we are really pressed for speed, we special case ONE rectangle being
// subtracted.  There are only a few cases to deal with and the result always
// fits into a quantum region.

#if DBG
    for (int i = 0; i < crcl; ++i)
    {
        if ((arcl[i].left >= arcl[i].right) || (arcl[i].top >= arcl[i].bottom))
        {
            RIP("RGNOBJAPI::bSubtract - invalid rectangle from USER\n");
            arcl[i].left   = -10001;
            arcl[i].right  = -10000;
            arcl[i].top    = -10001;
            arcl[i].bottom = -10000;
        }
    }
#endif


    // Handle empty rectangles here.  Otherwise if we pass them to 
    // bSubtractComplex they can cause an AV with the sentinel case
    // (see bug 299398 for details).

    if (((ERECTL *) prcl)->bEmpty()) 
    {
        vSet();
        return TRUE;    
    }    
    
    if (crcl == 1)
    {
    // First discard total misses

        if ((arcl[0].top    >= prcl->bottom) ||
            (arcl[0].left   >= prcl->right)  ||
            (arcl[0].bottom <= prcl->top)    ||
            (arcl[0].right  <= prcl->left))
        {
            vSet(prcl);
            return(TRUE);
        }

    /*
        OK, this gets a little tricky.  There are 16 distinct ways that
        two rectangles can overlap.  In the diagram below, 1 and 2 are
        rectangle boundaries and asterisks represent areas of overlap.

        22          22222        2            22
        2*11        2***2       1*1         11*2
         1 1         1 1        1 1         1 1     TOP_NOTCH
         111         111        111         111

        22          22222        2            22
        2*11        2***2       1*1         11*2
        2* 1        2***2       1*1         1 *2    VERT_CLIP
        2*11        2***2       1*1         11*2
        22          22222        2            22

         111         111        111         111
        2* 1        2***2       1*1         1 *2    VERT_NOTCH
         111         111        111         111


         111         111        111         111
         1 1         1 1        1 1         1 1     BOTTOM_NOTCH
        2*11        2***2       1*1         11*2

     LEFT_NOTCH  HORIZ_CLIP HORIZ_NOTCH  RIGHT_NOTCH

        I have given each of the rows and columns names.  By simply finding
        out which state I'm in, I can produce the correct output region.
    */

        RECTL   rcl;
        SCAN   *pscn;
        int     iState;

        if (arcl[0].left <= prcl->left)
            iState = arcl[0].right < prcl->right ? SR_LEFT_NOTCH  : SR_HORIZ_CLIP ;
        else
            iState = arcl[0].right < prcl->right ? SR_HORIZ_NOTCH : SR_RIGHT_NOTCH;

        if (arcl[0].top <= prcl->top)
            iState += arcl[0].bottom < prcl->bottom ? SR_TOP_NOTCH  : SR_VERT_CLIP ;
        else
            iState += arcl[0].bottom < prcl->bottom ? SR_VERT_NOTCH : SR_BOTTOM_NOTCH;

        switch(iState)
        {
        // NULL case

        case SR_VERT_CLIP | SR_HORIZ_CLIP:
            vSet();
            break;

        // SINGLE cases

        case SR_TOP_NOTCH | SR_HORIZ_CLIP:
            rcl = *prcl;
            rcl.top = arcl[0].bottom;
            vSet(&rcl);
            break;

        case SR_VERT_CLIP | SR_LEFT_NOTCH:
            rcl = *prcl;
            rcl.left = arcl[0].right;
            vSet(&rcl);
            break;

        case SR_VERT_CLIP | SR_RIGHT_NOTCH:
            rcl = *prcl;
            rcl.right = arcl[0].left;
            vSet(&rcl);
            break;

        case SR_BOTTOM_NOTCH | SR_HORIZ_CLIP:
            rcl = *prcl;
            rcl.bottom = arcl[0].top;
            vSet(&rcl);
            break;

        // 2 scans (Corner notch)

        case SR_TOP_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_TOP_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 3 scans

        case SR_VERT_CLIP | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 2 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 3;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = prcl->top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 4 scans (Edge notch)

        case SR_TOP_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 5 scans

        case SR_VERT_NOTCH | SR_HORIZ_CLIP:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_VERT_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_VERT_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // The classic toroidal region

        case SR_VERT_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 8 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;
        }

        return(TRUE);
    }

// its complex, do it the hard way

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    BOOL b = bSubtractComplex(prcl,arcl,crcl);

    if (prgn != prgnOrg)
    {
        PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
        ASSERTGDI(pv != NULL,"RGNOBJAPI::bSubtract - HmgReplace failed\n");
    }

    rl.vRet((ULONG_PTR)prgn);

    return(b);
}

/******************************Member*Function*****************************\
* RGNOBJ::bSubtractComplex()
*
*   Handle the complex cases of subtracting a list of rectangles from another
*   rectangle to generate a region.
*
*   The alogrithm used here requires that the list of rectangles is always
*   sorted by both ytop and ybottom within the range of rectangles overlaping
*   the current scan.  To have both of these true, ytop refers to the max of
*   ytop and the top of the current scan.  There is no ordering in the
*   horizontal direction.  Rectangles that fall below the current scan are still
*   sorted by top but not by bottom.  While computing a new scan, all rectangles
*   that are just being added are inserted to keep the bottoms sorted.
*
*                 ..................
*   scan 1 top -->.+-----+  +-----+.
*                 .|     |  |     |.
*                 .|     |  |     |.
*                 .|     |  |     |.  +-----+
*                 .................   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  +-----+  |     |   |     |
*                           |     |   |     |
*                           |     |   +-----+
*                           |     |
*                           +-----+
*
*
*
*                   +-----+           +-----+
*                   |     |           |     |.
*                  ...........................
*   scan 2 top --> .|     |  +-----+  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .+-----+  |     |  |     |.
*                  ...........................
*                            +-----+  |     |
*                                     |     |
*                                     +-----+
*
*
*   To keep this ordering, a list of pointers to rectangles is used.  This reduces
*   the overhead of reordering the rectangles for each scan and reduces the amount
*   of temporary memory required.  For each scan, iFirst and iLast bracket the
*   set of rectangles intersecting the current scan.
*
*   To calculate the walls of a scan, we start assuming the entire with of the
*   dst rectangle and subtract from there.  The left to right of each rectangle
*   from iFirst to iLast is subtracted from the scan.
*
*   iFirst is update to remove any rectangles that are finished after the current
*   scan.
*
*   iLast is updated to include any new rectangles that lie in the new scan.
*
*   WARNING: If this function returns FALSE, the region may be inconsistent.
*            The caller must discard or reset the region. (See bug #343770)
*
* History:
*  26-Jul-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSubtractComplex(
    RECTL *prcl,
    RECTL *arclRemove,
    int    crcl)
{
    ASSERTGDI(crcl > 0, "Zero rectangles in RGNOBJ::bSubtract\n");
    ASSERTGDI(prcl->bottom >= prcl->top," RGNOBJ::bSubtractComplex - bottom > top\n");

// allocate array for temporary storage

    PRECTL aprclStack[100];
    PRECTL *aprcl;

    if (crcl < 100)
    {
        aprcl = aprclStack;
    }
    else
    {
        aprcl = (PRECTL *)PALLOCNOZ((sizeof(PRECTL) + 1) * crcl, 'ngrG');

        if (aprcl == NULL)
            return(FALSE);
    }

// sort the array of subtraction rectangles by yTop

    int iInsert;
    int i;

    for (i = 0; i < crcl; ++i)
    {
    // insert rect[i], search from the end so we don't do much in the
    // case of a pre-sorted list and we do the pointer copies while we
    // search backwards if it isn't sorted.

        iInsert = i;

        while (iInsert && (arclRemove[i].top < aprcl[iInsert-1]->top))
        {
            aprcl[iInsert] = aprcl[iInsert-1];
            --iInsert;
        }

        aprcl[iInsert] = &arclRemove[i];
    }

// add an extra rectangle at the end to make the end case simple

    RECTL rclLast;
    rclLast.left   = 0;
    rclLast.right  = 0;
    rclLast.top    = prcl->bottom;
    rclLast.bottom = POS_INFINITY;

    aprcl[crcl] = &rclLast;

// partialy setup the first scan, allowing for coalescing of inital empty scans

    PSCAN pscnOld = prgn->pscnHead();

    pscnOld->cWalls  = 0;
    pscnOld->yTop    = NEG_INFINITY;
    pscnOld->yBottom = POS_INFINITY;
    pscnOld->ai_x[0].x = 0;

    PSCAN pscn       = pscnGet(pscnOld);

    prgn->sizeRgn    = NULL_REGION_SIZE;
    prgn->cScans     = 1;
    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;

// now do the real work, all rectangles in the range of iFirst to iLast
// are sorted by bottom.  To get in this range, the rectangle must intersect
// yTop.
//
// yTop    - top y value for current scan
// yBottom - bottom y value for current scan
// iFirst  - index first rectangle in current scan
// iLast   - one past index of last rectangle in current scan

    LONG yTop    = prcl->top;
    LONG yBottom = prcl->bottom;
    int  cWalls  = 0;

// throw out any easy ones

    int  iFirst  = 0;

    while (aprcl[iFirst]->bottom <= yTop)
        ++iFirst;

    int iLast = iFirst;

// while we still have scans

    do
    {
    // make sure this scan is going to have enough room, also insure enough space
    // for last scan.  The scan will never have more walls than 2 * (num rectangles + 1)

        LONG size = prgn->sizeRgn + 2 * NULL_SCAN_SIZE + 2 * sizeof(INDEX_LONG) * (crcl - iFirst + 1);

        if (size > (LONG)prgn->sizeObj)
        {
        // not big enough, grow it and be aggresive with size because growing is
        // very expensive.  Also set any fields need to grow and reset the scans
        // afterwards.

            prgn->pscnTail = pscn;

            if (!bExpand((UINT)(size + (crcl - iFirst) * (NULL_SCAN_SIZE + (crcl - iFirst) * sizeof(INDEX_LONG)))))
            {
                if (aprcl != aprclStack)
                {
                    VFREEMEM(aprcl);
                }
                return(FALSE);
            }

            pscn    = prgn->pscnTail;
            pscnOld = pscnGot(pscn);
        }

    // setup the new scan, assume the entire width of prcl

        cWalls          = 2;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;

    // check if we need to reduce the scan, do we have any overlapping rects?

        if (aprcl[iFirst]->top > yTop)
        {
        // the bottom of this scan is the top of the next rectangle

            yBottom = aprcl[iFirst]->top;
        }
        else
        {
        // assume the bottom is the bottom of the first rectangle

            yBottom = aprcl[iFirst]->bottom;

        // first find any new rectangles that fit in the new scan, and reduce
        // ybottom appropriately

            while (TRUE)
            {
            // does the next rectangle start below the current top

                if (aprcl[iLast]->top > yTop)
                {
                // stop this scan where the next rectangle starts

                    if (aprcl[iLast]->top < yBottom)
                       yBottom = aprcl[iLast]->top;

                    break;
                }

                if (aprcl[iLast]->bottom < yBottom)
                   yBottom = aprcl[iLast]->bottom;

            // perculate it backwards to keep the current rectangles sorted by yBottom

                iInsert = iLast;
                PRECTL prclTmp = aprcl[iLast];

                while ((iInsert > iFirst) && (prclTmp->bottom < aprcl[iInsert-1]->bottom))
                {
                    aprcl[iInsert] = aprcl[iInsert-1];
                    --iInsert;
                }

            // if we did some shuffling, put the rectangle in the right place.
            // It is possible to have a rectangle that completely lies above
            // the top of this scan if we are on the first scan and the top of
            // this rectangle is greater than one before it but the bottom is
            // less than the top of prcl.

                if (aprcl[iInsert]->bottom <= yTop)
                {
                // the rectangle is completely clipped away

                    ASSERTGDI(iInsert == iFirst,"bSubtractComplex - iInsert != iFirst\n");
                    ++iFirst;
                }
                else
                {
                    aprcl[iInsert] = prclTmp;
                }

                ++iLast;
            }

        // build up the scan, for each new rectangle...

            for (int irc = iFirst; irc < iLast; ++irc)
            {
                LONG xLeft  = aprcl[irc]->left;
                LONG xRight = aprcl[irc]->right;

            // merge it into the walls

                for (int iWall = 0; iWall < cWalls; iWall += 2)
                {
                // the walls are before the rectangle, nothing to do yet

                    if (xLeft >= pscn->ai_x[iWall+1].x)
                        continue;

                // the walls are passed the rectangle, done with this rectangle

                    if (xRight <= pscn->ai_x[iWall].x)
                        break;

                // compute the overlap, update the walls

                    int iHit = 0;

                    if (xLeft <= pscn->ai_x[iWall].x)
                        iHit = 1;

                    if (xRight >= pscn->ai_x[iWall+1].x)
                        iHit += 2;

                    switch (iHit)
                    {
                    case 0:
                        // completely inside the walls, insert new rectangle

                        RtlMoveMemory(&pscn->ai_x[iWall+3],&pscn->ai_x[iWall+1],
                                      (cWalls - iWall - 1) * sizeof(INDEX_LONG));
                        pscn->ai_x[iWall+1].x = xLeft;
                        pscn->ai_x[iWall+2].x = xRight;
                        cWalls += 2;
                        break;

                    case 1:
                        // overlapped the left wall, just update the left edge

                        pscn->ai_x[iWall].x = xRight;
                        break;

                    case 2:
                        // overlapped the right wall, just update the right edge

                        pscn->ai_x[iWall+1].x = xLeft;
                        break;

                    case 3:
                        // completely bounds the walls, remove rectangle

                        RtlMoveMemory(&pscn->ai_x[iWall],&pscn->ai_x[iWall+2],
                                      (cWalls - iWall - 2) * sizeof(INDEX_LONG));
                        cWalls -= 2;
                        iWall  -= 2;
                        break;
                    }
                }
            }
        }

    // make sure yBottom isn't below the original rectangle

        if (yBottom > prcl->bottom)
            yBottom = prcl->bottom;

    // Try to coalesce the current scan with the previous scan

        if (((int)pscnOld->cWalls == cWalls) &&
            !memcmp(pscnOld->ai_x, pscn->ai_x,(UINT)cWalls * sizeof(INDEX_LONG)))
        {
        // the walls are identical to the previous scan, merge them

            pscnOld->yBottom = yBottom;
        }
        else
        {
        // update the x bounds

            if (cWalls)
            {
                if (pscn->ai_x[0].x < prgn->rcl.left)
                    prgn->rcl.left = pscn->ai_x[0].x;

                if (pscn->ai_x[cWalls-1].x > prgn->rcl.right)
                     prgn->rcl.right = pscn->ai_x[cWalls-1].x;
            }

        // update the rest of the fields

            prgn->cScans++;
            pscn->cWalls = cWalls;
            prgn->sizeRgn += pscn->sizeGet();

            pscn->yTop           = yTop;
            pscn->yBottom        = yBottom;
            pscn->ai_x[cWalls].x = cWalls;

            pscnOld = pscn;
            pscn = pscnGet(pscn);
        }

    // trim off the finished rectangles

        yTop = yBottom;

        while ((iFirst < iLast) && (aprcl[iFirst]->bottom <= yTop))
            ++iFirst;

    } while (yBottom < prcl->bottom);

// set the top and bottom bounds and the last scan

    if (prgn->cScans == 1)
    {
        prgn->rcl.top    = 0;
        prgn->rcl.bottom = 0;
        prgn->rcl.left   = 0;
        prgn->rcl.right  = 0;
        pscnOld->yBottom = POS_INFINITY;
        prgn->pscnTail   = pscn;
    }
    else
    {
    // was the last scan empty?

        if (pscnOld->cWalls == 0)
        {
        // combine the final scan with the last computed scan

            pscn = pscnOld;
        }
        else
        {
        // set up any fields that wouldn't already be set by an empty scan

            pscn->yTop = pscnOld->yBottom;
            prgn->cScans++;
            pscn->cWalls    = 0;
            pscn->ai_x[0].x = 0;
            prgn->sizeRgn += pscn->sizeGet();
        }

    // set vertical bounds

        prgn->pscnHead()->yBottom = pscnGet(prgn->pscnHead())->yTop;
        prgn->rcl.top    = prgn->pscnHead()->yBottom;
        prgn->rcl.bottom = pscn->yTop;

    // setup the other region fields

        pscn->yBottom   = POS_INFINITY;
        prgn->pscnTail  = pscnGet(pscn);
    }

// if we allocated a buffer, free it

    if (aprcl != aprclStack)
        VFREEMEM(aprcl);

    return(TRUE);
}



/******************************Public*Routine******************************\
*
*   SyncRgn converts a client NULL or SIMPLE rectangle into a normal region
*   for kernel operations
*
* Arguments:
*
*   none
*
* Return Value:
*
*   BOOL
*
* History:
*
*    22-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
RGNOBJ::SyncUserRgn()
{
    BOOL bRet = FALSE;

    RGNLOG rl(prgn,"RGNOBJ::SyncUserRgn");

    if (prgn != (PREGION)NULL)
    {
        //
        // does this fine region have valid user-mode data?
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            __try
            {

              if (prRegion->AttrFlags & ATTR_RGN_VALID)
              {

                  if (prRegion->AttrFlags & ATTR_RGN_DIRTY)
                  {
                      if (prRegion->Flags == NULLREGION)
                      {
                          vSet();
                          prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                      }
                      else if (prRegion->Flags == SIMPLEREGION)
                      {
                          vSet(&prRegion->Rect);
                          prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                      }
                  }
              }
              else
              {
                  WARNING("RGNOBJ::SyncUserRgn invalid rectregion\n");
              }

              bRet = TRUE;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("except in RGNOBJ::SyncRgn\n");
            }
        }
    }
    return(bRet);
}

VOID
RGNOBJ::UpdateUserRgn()
{
    RGNLOG rl(prgn,"RGNOBJ::UpdateUserRgn");
    if (prgn != (PREGION)NULL)
    {
        //
        // does this fine region have valid user-mode data?
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            //
            // check for DCATTR
            //

            __try
            {
                //
                // set user region complexity and bounding box
                //

                if (prRegion->AttrFlags & ATTR_RGN_VALID)
                {
                    prRegion->Flags = iComplexity();
                    prRegion->Rect = prgn->rcl;
                }
                else
                {
                    WARNING("UpdateUserRgn: Invalid region");
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("except in RGNOBJ::UpdateUserRgn\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bValidateFramedRegion()
*
* Verify the region's integrity.  For debugging purposes only.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#if DBG

#define REASONABLE      0x10000L
#define FX_REASONABLE   (0x10000L << 4)

BOOL RGNOBJ::bValidateFramedRegion()
{
#ifdef DEBUGREGIONS

    if (prgn == NULL)
        return(TRUE);       // ???

//    ASSERTGDI(prgn->rcl.left <= prgn->rcl.right &&
//              prgn->rcl.top  <= prgn->rcl.bottom, "Funky rcl");
    ASSERTGDI(prgn->pscnHead() <= prgn->pscnTail, "Funky head/tail");
    ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "sizeRgn > sizeObj");
    ASSERTGDI((BYTE*) prgn->pscnTail <= (BYTE*) prgn + prgn->sizeObj,
              "Tail > prgn + sizeObj");
    ASSERTGDI((BYTE*) prgn->pscnTail <= (BYTE*) prgn + prgn->sizeRgn,
              "Tail > prgn + sizeRgn");
//    ASSERTGDI(prgn->cScans < REASONABLE, "cScans not reasonable");
    ASSERTGDI(prgn->cScans >= 1, "cScans < 1");

    if (prgn->cScans < 2)
        return(TRUE);

    COUNT   cScans = prgn->cScans;
    SCAN   *pscn   = prgn->pscnHead();
    LONG    yOldBottom = pscn->yBottom;

    ASSERTGDI(pscn->yTop == NEG_INFINITY, "Very yTop not NEG_INFINITY");
    ASSERTGDI(pscn->cWalls == 0, "Very top cWalls not 0");
    ASSERTGDI(pscn->ai_x[0].x == 0, "Very top cWalls2 not 0");
//    ASSERTGDI(pscn->yBottom == prgn->rcl.top, "Very top yBottom not rcl.top");

    pscn = pscnGet(pscn);
    cScans -= 2;

    while (cScans--)
    {
        LONG    iWall;
        LONG    cWalls  = pscn->cWalls;
        LONG    yTop    = pscn->yTop;
        LONG    yBottom = pscn->yBottom;
        LONG    xOld    = NEG_INFINITY;

        ASSERTGDI(pscn->ai_x[cWalls].x == cWalls, "cWalls1 != cWalls2");
        ASSERTGDI(yTop < yBottom, "Region corrupted: yTop >= yBottom");
        ASSERTGDI(yOldBottom == yTop, "Region corrupted: yOldBottom != yTop");
//        ASSERTGDI(cWalls < REASONABLE, "cWalls not reasonable");
        ASSERTGDI((cWalls & 1) == 0, "cWalls not even");
//        ASSERTGDI(yTop > -REASONABLE && yTop < REASONABLE,
//                  "yTop not reasonable");
//        ASSERTGDI(yBottom > -REASONABLE && yBottom < REASONABLE,
//                  "yBottom not reasonable");

        for (iWall = 0; iWall != cWalls; iWall++)
        {
            LONG x = xGet(pscn, (PTRDIFF) iWall);

        // Framed regions make things look weird:

            if (x > MAX_REGION_COORD)
                x -= REGION_FRAMED_OFFSET;

            ASSERTGDI(VALID_SCR(x), "Region corrupted: Invalid x");

            if (x <= xOld)
                DbgPrint("x <= xOld - pscn = %p, iWall = %lx\n",pscn,iWall);

//            ASSERTGDI(x > xOld, "Region corrupted: x <= xOld");
//            ASSERTGDI(x > -REASONABLE && x < REASONABLE, "x not reasonable");
            xOld = x;
        }

//        if (cWalls > 0)
//        {
//            ASSERTGDI(xGet(pscn, (PTRDIFF) 0) >= (prgn->rcl.left - 1),
//                      "x < rcl.left");
//            ASSERTGDI(xGet(pscn, (PTRDIFF) (cWalls - 1)) <= (prgn->rcl.right + 1),
//                      "x > rcl.right");
//        }

        yOldBottom = yBottom;
        pscn = pscnGet(pscn);

        ASSERTGDI(pscn > prgn->pscnHead() && pscn <= prgn->pscnTail,
                  "pscn out of bounds");
//        ASSERTGDI(prgn->rcl.top <= (yBottom + 1) && prgn->rcl.bottom >= (yBottom - 1),
//                 "yBottom not in rcl");
    }

    ASSERTGDI(pscn->yBottom == POS_INFINITY, "Very yBottom not POS_INFINITY");
    ASSERTGDI(pscn->cWalls == 0, "Very bottom cWalls not 0");
    ASSERTGDI(pscn->ai_x[0].x == 0, "Very bottom cWalls2 not 0");
    //ASSERTGDI(pscn->yTop == prgn->rcl.bottom, "Very bottom yTop not rcl.bottom");

#endif

    return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rleblt.h ===
/* rleblt.h
 *
 * Modified: 21 Oct 1992 by Gerrit van Wingerden [gerritv]
 *
 * Purpose:  Added an enumerated type and function prototypes for RLE
 *           compression routines.
 *
 * Created:  5 Mar 1992 by Andrew Milton (w-andym)
 *
 * Purpose:  Contains support macros for the RLE blt functions in
 *           <rle4blt.cxx> and <rle8blt.cxx>
 *
 * See the notes section of the above files for more info about these macros
 *
 * Contents: (The interesting macros only)
 *
 *  RLE_InitVars - Declares & initializes the variables for output position
 *                 management and source access in all RLE blt functions.
 *
 *  RLE_AssertValid - ASSERTs to verify the BLTINFO structure has good data
 *
 *  RLE_FetchVisibleRect - Declares the visible region variables & initializes
 *                         them from the BLTINFO structure
 *
 *  RLE_SetStartPos - Initializes the output position on the DIB for the RLE
 *
 *  RLE_SourceExhausted - Verifies that the source contains n more bytes.
 *
 *  RLE_GetNextCode - Fetches an RLE code.
 *
 *  RLE_NextLine - Advances to the next line of output on the destination DIB
 *
 *  RLE_PosDelta - Changes the output postion on the DIB.  The delta is
 *                 ALWAYS up the DIB, but may move left or right.
 *
 *  RLE_InVisibleRect - Checks if any portion of a run will fall inside the
 *                      visible region.
 *
 *  RLE_ForceBounds - Returns the left/(right) boundary if an output column is
 *                    before/(after) the left/(right) edge.  If the column is
 *                    inside the interval it does nothing.
 *
 *  RLE_SavePositon - Saves the current output position, source pointer,
 *                    destination pointer, and RLE bytes consumed into the
 *                    BLTINFO structure.  This information is used by
 *                    <EngCopyBits> for complex clipping optimization.
 *
 * Copyright (c) 1992-1999 Microsoft Corporation
 *
 \***************************************************************************/

/* Miscellaneous Macros *****************************************************/

#define GetLowNybble(b)  ((b) & 0x0F)

/* Byte Manipulators */

#define GetHighNybble(b) ( ( (b) & 0xF0) >> 4)
#define SetLowNybble(b, rn)  b = ( ((b) & 0xF0) | ((rn) & 0x0F) )
#define SetHighNybble(b, ln) b = ( ((b) & 0x0F) | (((ln) & 0x0F) << 4) )
#define BuildByte(ln, rn) (BYTE) ((((ln) & 0x0F) << 4) | ((rn) & 0x0F))

/* Word Manipulators */

#define GetLowByte(w)  ((w) & 0x00FF)
#define GetHighByte(w) ( ( (w) & 0xFF00) >> 8)

#define SetLowByte(w, b)  w = ( ((w) & 0xFF00) | ((b) & 0x00FF) )
#define SetHighByte(w, b) w = ( ((w) & 0x00FF) | (((b) & 0x00FF) << 4) )


#define RollLeft(x)  ( ((x) & 0x80) ? ((x) << 1) | 0x01 : (x) << 1 )

#define RollRight(x) ( ((x) & 0x01) ? ((x) >> 1) | 0x80 : (x) >> 1 )

#define SwapValues(x, y) (x) ^= (y); \
                         (y) ^= (x); \
                         (x) ^= (y);

/****************************************************************************
 *
 *  RLE4_MakeColourBlock - Unpacks & translates a packed byte of 2 colours
 *                         into an array
 *
 *  RLE4_MakePackedWord  - Unpacks & translates a packed byte of 2 colours
 *                         into 8 Bits/Pel and packs them into a word
 *
 *  RLE4_MakePackedDWord - Unpacks & translates a packed byte of 2 colours
 *                         into 16 Bits/Pel and packs them into a double word
 *
 *  RLE4_AlignToWord  - Verifies all bytes of an Absolute run exist in the
 *                      source & sets a flag if the run does not end on a
 *                      word boundary.
 *
 *  RLE4_FixAlignment - Forces the source pointer to a word boundary if the
 *                      flag was set by <RLE4_AlignToWord>
 *
 ****************************************************************************/

/* Source Byte Unpacking ****************************************************/

#define RLE4_MakeColourBlock(PackedColours, ColourBlock,  Type, Trans)       \
    ColourBlock[0] = (Type) Trans[GetHighNybble(PackedColours)];             \
    ColourBlock[1] = (Type) Trans[GetLowNybble(PackedColours)];              \

#define RLE4_MakePackedWord(PackedColours, PackedWord, Trans)                \
    PackedWord  = (( (WORD) Trans[GetHighNybble(PackedColours)] ) << 8);     \
    PackedWord |=  ( (WORD) Trans[GetLowNybble(PackedColours)]  );           \

#define RLE4_MakePackedDWord(PackedColours, PackedDWord, Trans)              \
    PackedDWord  = (( Trans[GetHighNybble(PackedColours)] ) << 16);          \
    PackedDWord |=  ( Trans[GetLowNybble(PackedColours)]  );                 \

/* Source Alignment Macros **************************************************/

#define RLE4_ByteLength(RunLength) ((RunLength + 1) >> 1)

#define RLE4_AlignToWord(SrcPtr, RunLength)                                  \
     ulNotAligned = ((1 + RunLength) >> 1) & 1;

#define RLE4_FixAlignment(SrcPtr)                                            \
    ulSrcIndex += ulNotAligned;                                              \
    SrcPtr += ulNotAligned;                                                  

/****************************************************************************
 *
 *  RLE8_AbsClipLeft - Forces an Absolute run to start at the left edge of
 *                     the visible region when the current output column is
 *                     before the left edge.
 *
 *  RLE8_EncClipLeft - Forces an Encoded run to start at the left edge of
 *                     the visible region when the current output column is
 *                     before the left edge.
 *
 *  RLE8_AbsClipLeft - Forces any run to end at the right edge of the visible
 *                     region when it extends beyond the right edge
 *
 *  RLE8_AlignToWord - Verifies all bytes of an Absolute run exist in the
 *                     source & sets a flag if the run does not end on a
 *                     word boundary.
 *
 *  RLE8_FixAlignment - Forces the source pointer to a word boundary if
 *                      the flag was set by <RLE8_AlignToWord>
 *
 ****************************************************************************/

/* Clipping Macros  *********************************************************/

#define RLE8_AbsClipLeft(SrcPtr, IndentAmount, RunLength, OutColumn)         \
    if (OutColumn < (LONG)ulDstLeft)                                         \
    {                                                                        \
        IndentAmount = ulDstLeft - OutColumn;                                \
        OutColumn    = ulDstLeft;                                            \
        SrcPtr      += IndentAmount;                                         \
        RunLength   -= IndentAmount;                                         \
    }

#define RLE8_EncClipLeft(IndentAmount, RunLength, OutColumn)                 \
    if (OutColumn < (LONG)ulDstLeft)                                         \
    {                                                                        \
        IndentAmount = ulDstLeft - OutColumn;                                \
        RunLength    -= IndentAmount;                                        \
        OutColumn    += IndentAmount;                                        \
    }                                                                        \

#define RLE8_ClipRight(OverRun, RunLength, OutColumn)                        \
    if ((OutColumn + (LONG) RunLength) > (LONG)ulDstRight)                          \
    {                                                                        \
        OverRun = (OutColumn + RunLength) - ulDstRight;                      \
        RunLength -= OverRun;                                                \
    } else                                                                   \
        OverRun = 0;                                                         \

/* Source Alignment Macros **************************************************/

#define RLE8_AlignToWord(SrcPtr, RunLength)                                  \
     ulNotAligned = RunLength & 1;                                           \

#define RLE8_FixAlignment(SrcPtr)                                            \
    ulSrcIndex += ulNotAligned;                                              \
    SrcPtr += ulNotAligned;                                                  





#define LOOP_FOREVER   while(1)
#define bIsOdd(x) ((x) & 1)
#define BoundsCheck(a, b, x) ( ((x) >= (a)) ? ( ((x) <= (b)) ? (x) : (b) )   \
                                            : (a) )
/* Startup and Initialization Macros ****************************************/

#define RLE_InitVars(BI, Source, Dest, DstType, Count, Colour, \
                    OutColumn, Xlate)                          \
    LONG   OutColumn;  /* Offest from <pjDst> to get to the output column */ \
    LONG   lOutRow;    /* Output scanline                                 */ \
                                                                             \
    ULONG  Count;      /* First byte of an RLE code                       */ \
    ULONG  Colour;     /* Second byte of an RLE code                      */ \
                                                                             \
    PBYTE Source = (BI)->pjSrc; /* Current location into the source RLE   */ \
    DstType Dest = (DstType)(BI)->pjDst; /* Beginning of crnt. out line   */ \
    LONG lDeltaDst = (BI)->lDeltaDst / (LONG)sizeof(Dest[0]);                \
                                                                             \
    ULONG  ulSrcIndex  = (BI)->ulConsumed;                                   \
    ULONG  ulSrcLength = (BI)->pdioSrc->cjBits();                            \
                                                                             \
    PULONG Xlate = (BI)->pxlo->pulXlate;                                     \
                                                                             \
    ULONG ulNotAligned;                                                      \

#define RLE_AssertValid(BI)                                                  \
    ASSERTGDI((BI)->xDir == 1,  "RLE4 - direction not left to right");       \
    ASSERTGDI((BI)->yDir == -1, "RLE4 - direction not up to down");          \
    ASSERTGDI((BI)->lDeltaSrc == 0, "RLE - lDeltaSrc not 0");                \
    ASSERTGDI(pulXlate != (PULONG) NULL, "ERROR pulXlate NULL in RLE");      \

#define RLE_FetchVisibleRect(BI)                                             \
    /* Fetch the visible region boundaries of the passed structure */        \
    ULONG ulDstLeft   = (BI)->rclDst.left;                                   \
    ULONG ulDstRight  = (BI)->rclDst.right;                                  \
    ULONG ulDstTop    = (BI)->rclDst.top;                                    \
    ULONG ulDstBottom = (BI)->rclDst.bottom;                                 \

#define RLE_SetStartPos(BI, InitialColumn)                                   \
    /* Initialize the starting positions */                                  \
    LONG lDstStart = (BI)->xDstStart;                                        \
    InitialColumn  = (BI)->ulOutCol;                                         \
    lOutRow        = (LONG) (BI)->yDstStart;                                 \

/* Source Access ************************************************************/

#define RLE_SourceExhausted(Count)                                           \
    ((ulSrcIndex += (Count)) > ulSrcLength)

#define RLE_GetNextCode(SrcPtr, Count, Colour)                               \
    Count = (ULONG) *(SrcPtr++);                                             \
    Colour = (ULONG) *(SrcPtr++);                                            \

/* Output Position Change Macros ********************************************/

#define RLE_NextLine(DstType, DstPtr, OutColumn)                             \
    /*  Goto the next row */                                                 \
    DstPtr += lDeltaDst;                                                     \
    OutColumn  = lDstStart;                                                  \
    lOutRow -= 1;                                                            \

#define RLE_PosDelta(DstPtr, OutColumn, ColDelta, RowDelta)                  \
    OutColumn += ColDelta;                                                   \
    DstPtr += (LONG) (RowDelta) * lDeltaDst;                                 \
    lOutRow -= RowDelta;                                                     \

/* Visability Check Macros **************************************************/

#define RLE_InVisibleRect(RunLength, OutColumn)                              \
    ((lOutRow < (LONG) ulDstBottom) &&                                       \
     ((OutColumn) < (LONG)ulDstRight)  &&                                    \
     (((OutColumn) + (LONG) (RunLength)) > (LONG) ulDstLeft))                        \

#define RLE_RowVisible ( (lOutRow < (LONG) ulDstBottom)                      \
                      && (lOutRow >= (LONG) ulDstTop) )

#define RLE_ColVisible(Col) ( ( (Col) >= (LONG) ulDstLeft  )                 \
                           && ( (Col) <  (LONG) ulDstRight ) )

#define RLE_ForceBounds(Col) BoundsCheck(ulDstLeft, ulDstRight, Col)

#define RLE_PastRightEdge(Col) ((Col) >= (LONG) ulDstRight)

#define RLE_PastTopEdge  (lOutRow < (LONG) ulDstTop)

/* Ending Macro *************************************************************/

#define RLE_SavePosition(BI, SrcPtr, DstPtr, OutColumn)                      \
    (BI)->ulEndConsumed = ulSrcIndex;                                        \
    (BI)->pjSrcEnd = (SrcPtr);                                               \
    (BI)->pjDstEnd = (PBYTE) (DstPtr);                                       \
    (BI)->ulEndCol = (OutColumn);                                            \
    (BI)->ulEndRow = (ULONG) lOutRow;



enum RLE_TYPE { RLE_START, RLE_ABSOLUTE, RLE_ENCODED };
int EncodeRLE8( BYTE*, BYTE *, UINT, UINT, UINT );
int EncodeRLE4( BYTE*, BYTE*, UINT, UINT, UINT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rotate.cxx ===
/******************************Module*Header*******************************\
* Module Name: rotate.cxx
*
* Internal DDAs for EngPlgBlt
*
* Created: 06-Aug-1992 15:35:02
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "rotate.hxx"

#ifdef DBG_PLGBLT
extern BOOL gflPlgBlt;
#endif

int aiPlgConst[][6] = {
    {  1,  0,  0,  0,  1,  0 },
    {  0,  1,  0,  1,  0,  0 },
    { -1,  0,  1,  0,  1,  0 },
    {  0,  1,  0, -1,  0,  1 },
    {  0, -1,  1,  1,  0,  0 },
    {  1,  0,  0,  0, -1,  1 },
    {  0, -1,  1, -1,  0,  1 },
    { -1,  0,  1,  0, -1,  1 }
};

int aiPlgSort[][4] = {
    {  0,  1,  2,  3 },
    {  0,  2,  1,  3 },
    {  1,  0,  3,  2 },
    {  1,  3,  0,  2 },
    {  2,  0,  3,  1 },
    {  2,  3,  0,  1 },
    {  3,  1,  2,  0 },
    {  3,  2,  1,  0 }
};

static VOID ROT_DIV(
DIV_T *pdt,
LONG   lNum,
LONG   lDen)
{
    pdt->lQuo = lNum / lDen;
    pdt->lRem = lNum % lDen;

    if (pdt->lRem < 0)
    {
	pdt->lQuo -= 1;
	pdt->lRem += lDen;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("%ld / %ld = %ld R %ld\n", lNum, lDen, pdt->lQuo, pdt->lRem);
#endif
}

static VOID QDIV(
DIV_T *pdt,
LONGLONG *peqNum,
LONG   lDen)
{
    ULONGLONG       liQuo;
    ULONG	    ul;
    BOOL	    bSigned;

    bSigned = *peqNum < 0;

    if (bSigned)
    {
        liQuo =  (ULONGLONG) (- (LONGLONG) *peqNum);
    }
    else
	liQuo = *peqNum;

    pdt->lQuo = DIVREM(liQuo, lDen, &ul);

    if (bSigned)
    {
	pdt->lQuo = - pdt->lQuo;
	if (ul == 0)
	    pdt->lRem = 0;
	else
	{
	    pdt->lQuo -= 1;
	    pdt->lRem  = lDen - ((LONG) ul);
	}
    }
    else
    {
	pdt->lRem = (LONG) ul;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("%ld,%ld / %ld = %ld R %ld\n", peqNum->HighPart, peqNum->LowPart, lDen, pdt->lQuo, pdt->lRem);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitPlgDDA(pdda, pptl)
*
* Initialize the DDA
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL bInitPlgDDA(
PLGDDA	 *pdda,
RECTL	 *prclScan,
RECTL	 *prcl,
POINTFIX *pptfx)
{
    POINTFIX	aptfx[4];
    RECTL	rclScan;
    RECTL	rcl;

    aptfx[0]   = pptfx[0];
    aptfx[1]   = pptfx[1];
    aptfx[2]   = pptfx[2];
    aptfx[3].x = aptfx[1].x + aptfx[2].x - aptfx[0].x;
    aptfx[3].y = aptfx[1].y + aptfx[2].y - aptfx[0].y;

// If the source surface does not have a 0,0 origin, deal with it here.

    if ((prcl->left != 0) || (prcl->top != 0))
    {
	rclScan.left   = prclScan->left	  - prcl->left;
	rclScan.top    = prclScan->top	  - prcl->top;
	rclScan.right  = prclScan->right  - prcl->left;
	rclScan.bottom = prclScan->bottom - prcl->top;
	prclScan = &rclScan;

	rcl.left   = 0;
	rcl.top    = 0;
	rcl.right  = prcl->right - prcl->left;
	rcl.bottom = prcl->bottom - prcl->top;
	prcl = &rcl;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("prclScan = [(%ld,%ld) (%ld,%ld)]\n",
		  prclScan->left, prclScan->top, prclScan->right, prclScan->bottom);

	DbgPrint("prcl = [(%ld,%ld) (%ld,%ld)]\n",
		  prcl->left, prcl->top, prcl->right, prcl->bottom);

	DbgPrint("aptfx[0] = (%ld,%ld)\n", aptfx[0].x, aptfx[0].y);
	DbgPrint("aptfx[1] = (%ld,%ld)\n", aptfx[1].x, aptfx[1].y);
	DbgPrint("aptfx[2] = (%ld,%ld)\n", aptfx[2].x, aptfx[2].y);
	DbgPrint("aptfx[3] = (%ld,%ld)\n", aptfx[3].x, aptfx[3].y);
    }
#endif

    int iTop  = (aptfx[1].y > aptfx[0].y) == (aptfx[1].y > aptfx[3].y);
    int iCase;

    if (aptfx[iTop].y > aptfx[iTop ^ 3].y)
	iTop ^= 3;

    switch (iTop) {
    case 0:
	if (aptfx[1].y < aptfx[2].y)
	    iCase = 0;
	else
	    if (aptfx[1].y > aptfx[2].y)
		iCase = 1;
	    else
		if (aptfx[1].x < aptfx[2].x)
		    iCase = 0;
		else
		    iCase = 1;
	break;

    case 1:
	if (aptfx[0].y < aptfx[3].y)
	    iCase = 2;
	else
	    if (aptfx[0].y > aptfx[3].y)
		iCase = 3;
	    else
		if (aptfx[0].x < aptfx[3].x)
		    iCase = 2;
		else
		    iCase = 3;
	break;

    case 2:
	if (aptfx[0].y < aptfx[3].y)
	    iCase = 4;
	else
	    if (aptfx[0].y > aptfx[3].y)
		iCase = 5;
	    else
		if (aptfx[0].x < aptfx[3].x)
		    iCase = 4;
		else
		    iCase = 5;
	break;

    case 3:
	if (aptfx[1].y < aptfx[2].y)
	    iCase = 6;
	else
	    if (aptfx[1].y > aptfx[2].y)
		iCase = 7;
	    else
		if (aptfx[1].x < aptfx[2].x)
		    iCase = 6;
		else
		    iCase = 7;
	break;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("iTop = %ld, iCase = %ld\n", iTop, iCase);
#endif

    LONG    DELTA_1;
    LONG    DELTA_2;

    switch (iCase) {
    case 0:
    case 2:
    case 5:
    case 7:
	DELTA_1 = prcl->right - prcl->left;
	DELTA_2 = prcl->bottom - prcl->top;
	break;

    case 1:
    case 3:
    case 4:
    case 6:
	DELTA_1 = prcl->bottom - prcl->top;
	DELTA_2 = prcl->right - prcl->left;
	break;
    }

    LONG    ci1 = aiPlgConst[iCase][0];
    LONG    cj1 = aiPlgConst[iCase][1];
    LONG    c1	= aiPlgConst[iCase][2];
    LONG    ci2 = aiPlgConst[iCase][3];
    LONG    cj2 = aiPlgConst[iCase][4];
    LONG    c2	= aiPlgConst[iCase][5];

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("Global constants: %ld %ld %ld %ld %ld %ld %ld %ld\n",
		 DELTA_1, DELTA_2, ci1, cj1, c1, ci2, cj2, c2);
#endif

    LONG    V1 = ci1 * prclScan->left + cj1 * prclScan->top + c1 * (DELTA_1 - 1);
    LONG    V2 = ci2 * prclScan->left + cj2 * prclScan->top + c2 * (DELTA_2 - 1);

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("V1 = %ld, V2 = %ld\n", V1, V2);
#endif

    LONG I0 = aptfx[aiPlgSort[iCase][0]].x;
    LONG J0 = aptfx[aiPlgSort[iCase][0]].y;
    LONG I1 = aptfx[aiPlgSort[iCase][1]].x;
    LONG J1 = aptfx[aiPlgSort[iCase][1]].y;
    LONG I2 = aptfx[aiPlgSort[iCase][2]].x;
    LONG J2 = aptfx[aiPlgSort[iCase][2]].y;
    LONG I3 = aptfx[aiPlgSort[iCase][3]].x;
    LONG J3 = aptfx[aiPlgSort[iCase][3]].y;

    I1 -= I0;
    I2 -= I0;
    I3 -= I0;

    J1 -= J0;
    J2 -= J0;
    J3 -= J0;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("I0, I1, I2, I3 = %8ld %8ld %8ld %8ld\n", I0, I1, I2, I3);
	DbgPrint("J0, J1, J2, J3 = %8ld %8ld %8ld %8ld\n", J0, J1, J2, J3);
    }
#endif

    LONG    X1 = DELTA_2 * I1;
    LONG    Y1 = DELTA_2 * J1;

    LONG    X2 = DELTA_1 * I2;
    LONG    Y2 = DELTA_1 * J2;

// avoid divide by 0's.  In some way shape or form, all divides are based on
// these two values.  Note that by checking Y2, DELTA_1 is also validated.  We
// can't just validate Y1 as well because it is special cased below to be 0.
// Also beware of overflows given large numbers where multipications can
// potentially shift off all set bits leaving you with a zero value. In the case
// where we just lose bits but don't end up with all zeros we will have
// undefined but non-exception (divide by zero) behavior

    if ((Y2 == 0) || (DELTA_2 == 0))
        return(FALSE);
    
    LONG    T = DELTA_1 * DELTA_2;

    LONGLONG N = Int32x32To64(T, (J0 + 16));
    LONGLONG eqTmp = Int32x32To64(V1, Y1);

    N += eqTmp;
    eqTmp = Int32x32To64(V2, Y2);
    N += eqTmp;
    N -= 1;

//  LONG    N = T * (J0 + 16) + V1 * Y1 + V2 * Y2 - 1;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("X1 = %ld, Y1 = %ld, X2 = %ld, Y2 = %ld\n", X1, Y1, X2, Y2);
	DbgPrint("T = %ld, N = %ld,%ld\n", T, N.HighPart, N.LowPart);
    }
#endif

    T *= 16;
// overflow check: avoid divide by 0's
    if ( T == 0 )
        return(FALSE);

    DDA_STEP	dp1;
    DDA_STEP	dp2;

    ROT_DIV(&dp1.dt, Y1, T);
    dp1.lDen = T;

    ROT_DIV(&dp2.dt, Y2, T);
    dp2.lDen = T;

    QDIV(&pdda->ds.dt0, &N, T);

    pdda->ds.dt1 = pdda->ds.dt0;
    DDA(&pdda->ds.dt1, &dp1)

    pdda->ds.dt2 = pdda->ds.dt0;
    DDA(&pdda->ds.dt2, &dp2)

    pdda->ds.dt3 = pdda->ds.dt2;
    DDA(&pdda->ds.dt3, &dp1)

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("N0, N1, N2, N3 = %8ld %8ld %8ld %8ld\n",
		  pdda->ds.dt0.lQuo, pdda->ds.dt1.lQuo, pdda->ds.dt2.lQuo, pdda->ds.dt3.lQuo);

	DbgPrint("R0, R1, R2, R3 = %8ld %8ld %8ld %8ld\n",
		  pdda->ds.dt0.lRem, pdda->ds.dt1.lRem, pdda->ds.dt2.lRem, pdda->ds.dt3.lRem);
    }
#endif

    ROT_DIV(&pdda->dp0_i.dt, ci1 * Y1 + ci2 * Y2, T);
    pdda->dp0_i.lDen = T;
    pdda->dp1_i = pdda->dp0_i;
    pdda->dp2_i = pdda->dp0_i;
    pdda->dp3_i = pdda->dp0_i;

    ROT_DIV(&pdda->dp0_j.dt, cj1 * Y1 + cj2 * Y2, T);
    pdda->dp0_j.lDen = T;
    pdda->dp1_j = pdda->dp0_j;
    pdda->dp2_j = pdda->dp0_j;
    pdda->dp3_j = pdda->dp0_j;

    LONGLONG Q = Int32x32To64(I1, J2);
    eqTmp = Int32x32To64(J1, I2);
    Q -= eqTmp;

//  LONG    Q = I1 * J2 - J1 * I2;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("Q = %ld,%ld\n", Q.HighPart, Q.LowPart);
#endif

    DIV_T   dt1;
    DIV_T   dt2;

//overflow check: avoid divide by 0's
    if ((16 * DELTA_1) == 0 || (16 * DELTA_2) == 0)
        return(FALSE);
    
    ROT_DIV(&dt1, ci1 * J1, 16 * DELTA_1);
    ROT_DIV(&dt2, ci2 * J2, 16 * DELTA_2);

    LONG    dn_i = dt1.lQuo + dt2.lQuo;

    ROT_DIV(&dt1, cj1 * J1, 16 * DELTA_1);
    ROT_DIV(&dt2, cj2 * J2, 16 * DELTA_2);

    LONG    dn_j = dt1.lQuo + dt2.lQuo;

    if (Y1 == 0)
    {
	pdda->dp01.dt.lQuo = 0;
	pdda->dp01.dt.lRem = 0;
	pdda->dp01.lDen    = 0;

	pdda->dp01_i.dt.lQuo = 0;
	pdda->dp01_i.dt.lRem = 0;
	pdda->dp01_i.lDen    = 0;

	pdda->dp01_j.dt.lQuo = 0;
	pdda->dp01_j.dt.lRem = 0;
	pdda->dp01_j.lDen    = 0;

	pdda->ds.dt01.lQuo = 0;
	pdda->ds.dt01.lRem = 0;
	pdda->ds.dt23.lQuo = 0;
	pdda->ds.dt23.lRem = 0;

	pdda->dpP01.dt.lQuo = 0;
	pdda->dpP01.dt.lRem = 0;
	pdda->dpP01.lDen    = 0;
    }
    else
    {
	N= Int32x32To64(X1, 16 * pdda->ds.dt0.lQuo - J0);
	eqTmp= Int32x32To64(Y1, (I0 + 16));
	N += eqTmp;
	eqTmp= Int32x32To64(V2, I1 * J2);
	N -= eqTmp;
	eqTmp= Int32x32To64(V2, I2 * J1);
	N += eqTmp;
	N -= 1;

//	N = X1 * (16 * pdda->ds.dt0.lQuo - J0) + Y1 * (I0 + 16) - V2 * Q - 1;

	pdda->dp01.lDen   = 16 * Y1;
	pdda->dp01_i.lDen = pdda->dp01.lDen;
	pdda->dp01_j.lDen = pdda->dp01.lDen;

// overflow check: avoid divide by 0's.
        if (pdda->dp01.lDen == 0)
            return(FALSE);

	QDIV(&pdda->ds.dt01, &N, pdda->dp01.lDen);

	eqTmp= Int32x32To64(16 * X1, pdda->ds.dt2.lQuo - pdda->ds.dt0.lQuo);
	eqTmp -= Q;
	N += eqTmp;

//	N += 16 * X1 * (pdda->ds.dt2.lQuo - pdda->ds.dt0.lQuo) - Q;

	QDIV(&pdda->ds.dt23, &N, pdda->dp01.lDen);

	ROT_DIV(&pdda->dp01.dt, 16 * X1, pdda->dp01.lDen);

	N= Int32x32To64(ci2 * I1,J2);
	eqTmp= Int32x32To64(ci2 * I2, J1);
	N -= eqTmp;	// Q * ci2
	eqTmp= Int32x32To64(16 * dn_i, X1);
	eqTmp -= N;
	QDIV(&pdda->dp01_i.dt, &eqTmp, pdda->dp01_i.lDen);

	N= Int32x32To64(cj2 * I1,J2);
	eqTmp= Int32x32To64(cj2 * I2, J1);
	N -= eqTmp;	// Q * cj2
	eqTmp= Int32x32To64(16 * dn_j, X1);
	eqTmp -= N;
	QDIV(&pdda->dp01_j.dt, &eqTmp, pdda->dp01_j.lDen);

//	ROT_DIV(&pdda->dp01_i.dt, 16 * X1 * dn_i - ci2 * Q, pdda->dp01_i.lDen);
//	ROT_DIV(&pdda->dp01_j.dt, 16 * X1 * dn_j - cj2 * Q, pdda->dp01_j.lDen);

// overflow check: avoid divide by 0's
// 16*Y1 was already checked above computing pdda->dp01.lDen       
	ROT_DIV(&pdda->dpP01.dt, 16 * X1, 16 * Y1);
	pdda->dpP01.lDen = 16 * Y1;
    }

    N= Int32x32To64(X2, 16 * pdda->ds.dt0.lQuo - J0);
    eqTmp= Int32x32To64(Y2, I0 + 16);
    N += eqTmp;
    eqTmp= Int32x32To64(V1, I1 * J2);
    N += eqTmp;
    eqTmp= Int32x32To64(V1, I2 * J1);
    N -= eqTmp;
    N -= 1;

//  N = Y1 * (16 * pdda->ds.dt0.lQuo - J0) + Y2 * (I0 + 16) + V1 * Q - 1;

    pdda->dp02.lDen   = 16 * Y2;
    pdda->dp02_i.lDen = pdda->dp02.lDen;
    pdda->dp02_j.lDen = pdda->dp02.lDen;

// overflow check: avoid divide by 0's.
    if (pdda->dp02.lDen == 0)
        return(FALSE);
        
    QDIV(&pdda->ds.dt02, &N, pdda->dp02.lDen);

    eqTmp= Int32x32To64(16 * X2, pdda->ds.dt1.lQuo - pdda->ds.dt0.lQuo);
    eqTmp += Q;
    N += eqTmp;

//  N += 16 * Y1 * (pdda->ds.dt1.lQuo - pdda->ds.dt0.lQuo) + Q;

    QDIV(&pdda->ds.dt13, &N, pdda->dp02.lDen);

    ROT_DIV(&pdda->dp02.dt, 16 * X2, pdda->dp02.lDen);

    N= Int32x32To64(ci1 * I1,J2);
    eqTmp= Int32x32To64(ci1 * I2, J1);
    N -= eqTmp; 	// Q * ci1
    eqTmp= Int32x32To64(16 * dn_i, X2);
    eqTmp += N;
    QDIV(&pdda->dp02_i.dt, &eqTmp, pdda->dp02_i.lDen);

    N= Int32x32To64(cj1 * I1,J2);
    eqTmp= Int32x32To64(cj1 * I2, J1);
    N -= eqTmp; 	// Q * cj1
    eqTmp= Int32x32To64(16 * dn_j, X2);
    eqTmp += N;
    QDIV(&pdda->dp02_j.dt, &eqTmp, pdda->dp02_j.lDen);

//  DIV(&pdda->dp02_i.dt, 16 * X2 * dn_i + ci1 * Q, pdda->dp02_i.lDen);
//  DIV(&pdda->dp02_j.dt, 16 * X2 * dn_j + cj1 * Q, pdda->dp02_j.lDen);

    pdda->dp13	 = pdda->dp02;
    pdda->dp13_i = pdda->dp02_i;
    pdda->dp13_j = pdda->dp02_j;

    pdda->dp23	 = pdda->dp01;
    pdda->dp23_i = pdda->dp01_i;
    pdda->dp23_j = pdda->dp01_j;

// overflow check: avoid divide by 0's
// 16*Y2 was already checked above computing pdda->dp02.lDen
    ROT_DIV(&pdda->dpP02.dt, 16 * X2, 16 * Y2);
    pdda->dpP02.lDen = 16 * Y2;

    return(TRUE);
}

/******************************Public*Routine******************************\
* LONG lSizeDDA(pdda)
*
* Return the space needed to run the DDA for a scan
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG lSizeDDA(PLGDDA *pdda)
{
    LONG dt[4];
    LONG max, min, i;
    
    // Bug #336058:
    // Prior to this fix, this function assumed that dt0 contains the
    // top-most vertex and dt3 contains the bottom-most vertex in the
    // parallelogram.  However, under some calls to EngPlgBlt this appears
    // to not be true (the bug includes a test program that can
    // demonstrate this).  That caused the allocated buffer to not be large
    // enough which resulted in an AV (i.e. when doing the run from dt1
    // to dt2).  The fix is to find the smallest and largest vertices (with
    // respect to y-values) and allocate enough space for a run from the
    // smallest to the largest.

    dt[0] = pdda->ds.dt0.lQuo;
    dt[1] = pdda->ds.dt1.lQuo;
    dt[2] = pdda->ds.dt2.lQuo;
    dt[3] = pdda->ds.dt3.lQuo;
        
    max = min = dt[0];
    for (i=1; i<4; i++) 
    {
        if (min > dt[i]) 
        {
            min = dt[i];
        }

        if (max < dt[i]) 
        {
            max = dt[i];
        }
    }
    
    //LONG    lTmp = pdda->ds.dt3.lQuo - pdda->ds.dt0.lQuo;
    LONG lTmp = max-min;

    if (lTmp == 0)
	lTmp = 1;

    return((lTmp + 4) * sizeof(CNTPOS) + sizeof(ULONG));
}

/******************************Public*Routine******************************\
* VOID vAdvXDDA(pdda)
*
* Advance the DDA in X.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vAdvXDDA(PLGDDA *pdda)
{
    pdda->dsX.dt0.lQuo += pdda->dp0_i.dt.lQuo;
    pdda->dsX.dt0.lRem += pdda->dp0_i.dt.lRem;
    if (pdda->dsX.dt0.lRem >= pdda->dp0_i.lDen)
    {
	pdda->dsX.dt0.lRem -= pdda->dp0_i.lDen;
	pdda->dsX.dt0.lQuo++;
	DDA(&pdda->dsX.dt01, &pdda->dpP01);
	DDA(&pdda->dsX.dt02, &pdda->dpP02);
    }

    pdda->dsX.dt1.lQuo += pdda->dp1_i.dt.lQuo;
    pdda->dsX.dt1.lRem += pdda->dp1_i.dt.lRem;
    if (pdda->dsX.dt1.lRem >= pdda->dp1_i.lDen)
    {
	pdda->dsX.dt1.lRem -= pdda->dp1_i.lDen;
	pdda->dsX.dt1.lQuo++;
	DDA(&pdda->dsX.dt13, &pdda->dpP02);
    }

    pdda->dsX.dt2.lQuo += pdda->dp2_i.dt.lQuo;
    pdda->dsX.dt2.lRem += pdda->dp2_i.dt.lRem;
    if (pdda->dsX.dt2.lRem >= pdda->dp2_i.lDen)
    {
	pdda->dsX.dt2.lRem -= pdda->dp2_i.lDen;
	pdda->dsX.dt2.lQuo++;
	DDA(&pdda->dsX.dt23, &pdda->dpP01);
    }

    DDA(&pdda->dsX.dt3, &pdda->dp3_i);

    DDA(&pdda->dsX.dt01, &pdda->dp01_i);
    DDA(&pdda->dsX.dt02, &pdda->dp02_i);
    DDA(&pdda->dsX.dt13, &pdda->dp13_i);
    DDA(&pdda->dsX.dt23, &pdda->dp23_i);
}

/******************************Public*Routine******************************\
* VOID vAdvYDDA(pdda)
*
* Advance the DDA in Y.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vAdvYDDA(PLGDDA *pdda)
{
    pdda->ds.dt0.lQuo += pdda->dp0_j.dt.lQuo;
    pdda->ds.dt0.lRem += pdda->dp0_j.dt.lRem;
    if (pdda->ds.dt0.lRem >= pdda->dp0_j.lDen)
    {
	pdda->ds.dt0.lRem -= pdda->dp0_j.lDen;
	pdda->ds.dt0.lQuo++;
	DDA(&pdda->ds.dt01, &pdda->dpP01);
	DDA(&pdda->ds.dt02, &pdda->dpP02);
    }

    pdda->ds.dt1.lQuo += pdda->dp1_j.dt.lQuo;
    pdda->ds.dt1.lRem += pdda->dp1_j.dt.lRem;
    if (pdda->ds.dt1.lRem >= pdda->dp1_j.lDen)
    {
	pdda->ds.dt1.lRem -= pdda->dp1_j.lDen;
	pdda->ds.dt1.lQuo++;
	DDA(&pdda->ds.dt13, &pdda->dpP02);
    }

    pdda->ds.dt2.lQuo += pdda->dp2_j.dt.lQuo;
    pdda->ds.dt2.lRem += pdda->dp2_j.dt.lRem;
    if (pdda->ds.dt2.lRem >= pdda->dp2_j.lDen)
    {
	pdda->ds.dt2.lRem -= pdda->dp2_j.lDen;
	pdda->ds.dt2.lQuo++;
	DDA(&pdda->ds.dt23, &pdda->dpP01);
    }

    DDA(&pdda->ds.dt3, &pdda->dp3_j);
    DDA(&pdda->ds.dt01, &pdda->dp01_j);
    DDA(&pdda->ds.dt02, &pdda->dp02_j);
    DDA(&pdda->ds.dt13, &pdda->dp13_j);
    DDA(&pdda->ds.dt23, &pdda->dp23_j);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPumpDDA(pdda, prun)
*
* 'Pump' out the target point run for the source point.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPumpDDA(
PLGDDA *pdda,
PLGRUN *prun)
{
    DIV_T     dt01 = pdda->dsX.dt01;
    DIV_T     dt02 = pdda->dsX.dt02;
    DIV_T     dt13 = pdda->dsX.dt13;
    DIV_T     dt23 = pdda->dsX.dt23;
    CNTPOS   *pcp;
    LONG      n    = pdda->dsX.dt0.lQuo;

    prun->cpY.iPos = n;
    pcp = &prun->cpX[0];

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
    {
	DbgPrint("Pumping pel\n");
	DbgPrint("N0 = %ld\n", n);
	DbgPrint("N1 = %ld\n", pdda->dsX.dt1.lQuo);
	DbgPrint("N2 = %ld\n", pdda->dsX.dt2.lQuo);
	DbgPrint("N3 = %ld\n", pdda->dsX.dt3.lQuo);

	DbgPrint("DDA 01 = %ld, %ld\n", dt01.lQuo, dt01.lRem);
	DbgPrint("DDA 02 = %ld, %ld\n", dt02.lQuo, dt02.lRem);
	DbgPrint("DDA 13 = %ld, %ld\n", dt13.lQuo, dt13.lRem);
	DbgPrint("DDA 23 = %ld, %ld\n", dt23.lQuo, dt23.lRem);

	DbgPrint("Step 01 = %ld, %ld, %ld\n",
		 pdda->dp01.dt.lQuo, pdda->dp01.dt.lRem, pdda->dp01.lDen);
	DbgPrint("Step 02 = %ld, %ld, %ld\n",
		 pdda->dp02.dt.lQuo, pdda->dp02.dt.lRem, pdda->dp02.lDen);
	DbgPrint("Step 13 = %ld, %ld, %ld\n",
		 pdda->dp13.dt.lQuo, pdda->dp13.dt.lRem, pdda->dp13.lDen);
	DbgPrint("Step 23 = %ld, %ld, %ld\n",
		 pdda->dp23.dt.lQuo, pdda->dp23.dt.lRem, pdda->dp23.lDen);
    }
#endif

    while(n < pdda->dsX.dt1.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt01.lQuo, dt02.lQuo);
#endif
	if (dt01.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt01.lQuo;
	    pcp->cCnt = dt02.lQuo - dt01.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt01.lQuo - dt02.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt01, &pdda->dp01);
	DDA(&dt02, &pdda->dp02);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Switching LHS to 13\n");
#endif

    while(n < pdda->dsX.dt2.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt13.lQuo, dt02.lQuo);
#endif
	if (dt13.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt02.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt13.lQuo - dt02.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt13, &pdda->dp13);
	DDA(&dt02, &pdda->dp02);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Switching RHS to 23\n");
#endif

    while(n < pdda->dsX.dt3.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt13.lQuo, dt23.lQuo);
#endif
	if (dt13.lQuo < dt23.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt23.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt23.lQuo;
	    pcp->cCnt = dt13.lQuo - dt23.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt13, &pdda->dp13);
	DDA(&dt23, &pdda->dp23);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Done.\n");
#endif

    prun->cpY.cCnt = n - prun->cpY.iPos;

// Always put at least one X pair in the list.	This handles the BLACKONWHITE
// and WHITEONBLACK compression.  Notice that the size of the X run is zero.

    if ((pdda->bOverwrite) && (prun->cpY.cCnt == 0))
    {
	if (dt13.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt02.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt13.lQuo - dt02.lQuo;
	}

	prun->cpY.cCnt = 1;
	pcp++;
    }

    return((PLGRUN *) pcp);
}

static ULONG gaulMaskMono[] =
{
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000
};

static ULONG gaulMaskQuad[] =
{
    0x000000F0, 0x0000000F, 0x0000F000, 0x00000F00,
    0x00F00000, 0x000F0000, 0xF0000000, 0x0F000000
};

static ULONG gaulShftQuad[] =
{
    0x00000004, 0x00000000, 0x0000000C, 0x00000008,
    0x00000014, 0x00000010, 0x0000001C, 0x00000018
};

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead1(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 1BPP surface.
*
* History:
*  12-Feb-1993 -by- Donald Sidoroff [donalds]
* Fixed a LOT of bugs in monochrome sources
*
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead1(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;

    cLeft  =  xLeft >> 5;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 31;                   // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
	iBlack = 0;
	iWhite = 1;
    }
    else
    {
	iBlack = pxlo->pulXlate[0];
	iWhite = pxlo->pulXlate[1];
    }

    if (pjMask == (BYTE *) NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    prun->iColor = iWhite;
                else
                    prun->iColor = iBlack;

                prun = prunPumpDDA(pdda, prun);
                vAdvXDDA(pdda);

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 32)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
	}

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    prun->iColor = iWhite;
                else
                    prun->iColor = iBlack;

                prun = prunPumpDDA(pdda, prun);
            }

            vAdvXDDA(pdda);
            xLeft++;
            iLeft++;
            iMask++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead4(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 4BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead4(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    if (pjMask == (BYTE *) NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                if (pxlo == NULL)
                    prun->iColor = iColor;
                else
                    prun->iColor = pxlo->pulXlate[iColor];

                prun = prunPumpDDA(pdda, prun);
                vAdvXDDA(pdda);

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
	}

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {

                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                if (pxlo == NULL)
                    prun->iColor = iColor;
                else
                    prun->iColor = pxlo->pulXlate[iColor];

                prun = prunPumpDDA(pdda, prun);
            }

            vAdvXDDA(pdda);
            xLeft++;
            iLeft++;
            iMask++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 8)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead8(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 8BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead8(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pjSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pjSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pjSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = pxlo->pulXlate[*pjSrc];
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pjSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pjSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = pxlo->pulXlate[iColor];

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pjSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead16(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 16BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead16(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pwSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pwSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pwSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pwSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead24(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 24BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead24(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG     *pulMsk;
    ULONG      ulMsk;
    ULONG      iColor = 0;
    LONG       iMask;

    prgbSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &iColor) = *prgbSrc;
                prun->iColor = iColor;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                prgbSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &iColor) = *prgbSrc;
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                prgbSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            *((RGBTRIPLE *) &iColor) = *prgbSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        prgbSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead32(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 32BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead32(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pdwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pdwSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pdwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(*pdwSrc);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pdwSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pdwSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pdwSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

static BYTE gajMask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/******************************Public*Routine******************************\
* VOID vPlgWrite1(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 1BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite1(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor ? (ULONG) -1L : 0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist != 0)
		{
		    jTemp = (BYTE) ((jTemp & ~jMask) | (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor ? (ULONG) -1L : 0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 3);
		jMask = gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp = (BYTE) ((jTemp & ~jMask) | (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			jMask = gajMask[xCurr & 7];
			pjOff++;

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

	       if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite4(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 4BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite4(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor | (prun->iColor << 4);

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 1);
		jMask = (xCurr & 1) ? 0x0F : 0xF0;

		while (xDist != 0)
		{
		   *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));
		    jMask ^= 0xFF;
		    if (jMask == 0xF0)
			pjOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There maybe a single rectangle to clip against.

    RECTL    rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
	rclClip = pco->rclBounds;

	while (prun != prunEnd)
	{
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    iColor = prun->iColor | (prun->iColor << 4);
	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp    = &prun->cpX[0];

	    while (yDist != 0)
	    {
		if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
		{
		    xCurr = pcp->iPos;
		    xDist = pcp->cCnt;

		    pjOff = pjBase + (xCurr >> 1);
		    jMask = (xCurr & 1) ? 0x0F : 0xF0;

		    while (xDist != 0)
		    {
			if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			   *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));

			xDist--;
			xCurr++;
			jMask ^= 0xFF;
			if (jMask == 0xF0)
			    pjOff++;
		    }
		}

		pjBase += pSurf->lDelta();
		yCurr++;
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor | (prun->iColor << 4);
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 1);
		jMask = (xCurr & 1) ? 0x0F : 0xF0;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask ^= 0xFF;
		    if (jMask == 0xF0)
			pjOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }

}

/******************************Public*Routine******************************\
* VOID vPlgWrite8(prun, prunEnd, pso, pco)
*
* Write the clipped run list of pels to the target 8BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite8(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pjOff = pjBase + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pjOff = (BYTE) iColor;
		    pjOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There maybe a single rectangle to clip against.

    RECTL    rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
	rclClip = pco->rclBounds;

	while (prun != prunEnd)
	{
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    iColor = prun->iColor;
	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp    = &prun->cpX[0];

	    while (yDist != 0)
	    {
		if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
		{
		    xCurr = pcp->iPos;
		    xDist = pcp->cCnt;

		    pjOff = pjBase + xCurr;

		    while (xDist != 0)
		    {
			if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			   *pjOff = (BYTE) iColor;

			xDist--;
			xCurr++;
			pjOff++;
		    }
		}

		pjBase += pSurf->lDelta();
		yCurr++;
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pjOff = (BYTE) iColor;

		    xDist--;
		    xCurr++;
		    pjOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite16(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 16BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite16(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    WORD   *pwOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pwOff = ((WORD *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pwOff = (WORD) iColor;
		    xDist--;
		    pwOff++;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pwOff = ((WORD *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pwOff = (WORD) iColor;

		    xDist--;
		    xCurr++;
		    pwOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite24(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 24BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite24(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE      *pjBase;
    RGBTRIPLE *prgbOff;
    CNTPOS    *pcp;
    ULONG      iColor;
    LONG       yCurr;
    LONG       yDist;
    LONG       xCurr;
    LONG       xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr  = prun->cpY.iPos;
	    yDist  = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		prgbOff = ((RGBTRIPLE *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *prgbOff = *((RGBTRIPLE *) &iColor);
		    prgbOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		prgbOff = ((RGBTRIPLE *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *prgbOff = *((RGBTRIPLE *) &iColor);

		    xDist--;
		    xCurr++;
		    prgbOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite32(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 32BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite32(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    DWORD  *pdwOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pdwOff = ((DWORD *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pdwOff = iColor;
		    xDist--;
		    pdwOff++;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pdwOff = ((DWORD *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pdwOff = iColor;

		    xDist--;
		    xCurr++;
		    pdwOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWriteAND(prun, prunEnd, pSurf, pco)
*
* AND the clipped run list of pels to the target 1BPP surface.	This can
* be made much faster by noting that ANDing with 1's is a NOP.
*
* History:
*  25-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWriteAND(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor == 0 ? ~0L : 0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist >= 0)
		{
		    jTemp &= ~((BYTE) (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor == 0 ? ~0L : 0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist >= 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp &= ~((BYTE) (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			pjOff++;
			jMask = gajMask[xCurr & 7];

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

	       if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
            yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWriteOR(prun, prunEnd, pso, pco)
*
* OR the clipped run list of pels to the target 1BPP surface.  This can
* be much faster by noting that ORing with 0's is a NOP.
*
* History:
*  25-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWriteOR(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor == 0 ? 0L : ~0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist >= 0)
		{
		    jTemp |= ((BYTE) (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor == 0 ? 0L : ~0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist >= 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp |= ((BYTE) (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			pjOff++;
			jMask = gajMask[xCurr & 7];

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

		if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
            yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rle4blt.cxx ===
/******************************Module*Header*******************************\
* Module Name: rleblt4.cxx
*
* This contains the bitmap simulation functions that blt from a 4 bit
* Run-Length Encoded (RLE) source to a DIB surface.  The DIB surface can be
* 1, 4, 8, 16, 24, or 32 bits/pel.
*
* The code is based on functions found in 'rleblt8.cxx', version 2.
*
* Added RLE Encoding functions: 10 Oct 92 @ 10:18
*  Gerrit van Wingerden [gerritv]
*
* Created: 03 Feb 92 @ 21:00
*
*  Author: Andrew Milton (w-andym)
*
* Notes:
*
*   1)  These functions return a BOOL value.  This value is TRUE if the
*       function ends before running out of data in the source RLE or before
*   hitting an End-of-Bitmap code.  Otherwise, we return FALSE.  This return
*   value is used by <EngCopyajBits> in the complex clipping case to decide
*   if the blt is complete.
*
*   2)  Before exiting a function with a TRUE value, position information is
*       saved by the macro <RLE_SavePosition>.  This is used by <EngCopyajBits>
*   to speed up the complex clipping case.
*
*   3)  The below functions use about twenty different macros.  This is
*       because they are all using the same basic algorithm to play an RLE
*   compression. The macros allow us to focus in on the nifty stuff of writing
*   the bytes out to the DIB.  Routine administrivia is handled by the macros.
*
*   The macros themselves are used to manage
*
*          - Source Access and data alignment
*          - Visability Checking
*          - Output position changes with Newline & Delta codes
*
*   The macro <RLE_InitVars> is used to define the varibles that relate to
*   the above information, and to define variables common to all RLE 4
*   blt functions.  Note that actual names of the common variables are passed
*   in as parameters to the macro.  Why?  Two reasons.  Firstly, they are
*   initialized by values taken of the BLTINFO structure passed into the blt
*   function.  Secondly, showing the variable names in the macro 'call' means
*   they don't just appear from nowhere into the function.  RLE_InitVars
*   is the one macro that you should think three times about before modifying.
*
*   One further note.  The variables 'ulDstLeft' and 'ulDstRight' appear to
*   come from nowhere.  This is not true.  They are in fact declared by the
*   macro <RLE_GetVisibleRect>.  However, showing these names in the macro
*   'call' tended to obscure the code.  Pretend you can see the declaration.
*
* Where can I find a macro definition?
*
*   Good question, glad you asked.  Look at the prefix:
*
*       RLE_<stuff> - lives in RLEBLT.H
*       RLE4_<blah> - lives in RLE4BLT.H
*
*   Anything else in here that looks like function call is not.  It's a macro.
*   Probably for bitwise manipulations.  Look for it in BITMANIP.H or in
*   the Miscellaneous section of RLEBLT.H
*
* 4)  The 8 and 16 ajBits/Pel cases can be optimized by packing the source
*     colours into a word / dword.  However, to actually see some net gain in
* run time, it will take some tricky-dicky-doo pointer alignment checking.
* This sort of thing may break on MIPS.
*
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************************Public*Routine*****************************\
* bSrcCopySRLE4D8
*
* Secure RLE blting that does clipping and won't die or write somewhere
* it shouldn't if given bad data.
*
* History:
*   3 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE4D8(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.
// Extra Variables

    BYTE jSource;       // Packed RLE 4 colour code
    BYTE ajColours[2];  // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;    // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin; // Number of bytes clipped in an Encoded run


// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode.

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left Side Clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount  = ulDstLeft - lOutCol;
                        ulNext  -= ulCount;
                        lOutCol += ulCount;

                        pjSrc += (ulCount >> 1);

                    // Force the Source Run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource =  *pjSrc++;
                            pjDst[lOutCol] =
                                     (BYTE) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right Side Clipping.

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, ajColours, BYTE,
                                             pulXlate);
                        pjDst[lOutCol]   = ajColours[0];
                        pjDst[lOutCol+1] = ajColours[1];
                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for a partial source byte in the run

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        pjDst[lOutCol] =
                                (BYTE) pulXlate[GetHighNybble(jSource)];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Pad so the run ends on a WORD boundary

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {

            // Left Side Clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    ulCount     -= ulClipMargin;
                    lOutCol     += ulClipMargin;
                }

            // Right Side Clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Setup for the run

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);

            // Write it

                while (ulCount)
                {
                    pjDst[lOutCol]   = ajColours[0];
                    pjDst[lOutCol+1] = ajColours[1];
                    lOutCol += 2;
                    ulCount--;
                }

                /* Write the extra byte from an odd run length */

                if (bExtraByte)
                {
                    pjDst[lOutCol] = ajColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.  Adjust our x output position */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D8 */

/********************************Public*Routine****************************\
* bSrcCopySRLE4D1
*
* Secure RLE blting to a 1 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*       Added clip support.
*  22 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* Local Macros ***********************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        These writes look unpleasant because we have to mask
 *        current destination contents onto the working byte when
 *        it is written.  To such an end, the below macro...
 */

#define RLE4to1_WritePartial(DstPtr, OutByte, OutColumn, WritePos)            \
    if (RLE_RowVisible && (jBitPos = (BYTE) (OutColumn) & 7))                              \
    {                                                                         \
        if (RLE_ColVisible(OutColumn))                                        \
            DstPtr[WritePos] = OutByte |                                      \
                 ((~ajBits[jBitPos]) & DstPtr[WritePos]);         \
        else                                                                  \
            if (RLE_PastRightEdge(OutColumn))                                 \
        DstPtr[ulRightWritePos] =  OutByte |                  \
                (DstPtr[ulRightWritePos] &  jRightMask);      \
    }                                                                         \

/* Converts an output column to a bitnumber in the working byte */
#define ColToBitPos(col) (7 - (BYTE)((col) & 7))

/* Lookup tables for bit patterns *****************************************/

static BYTE
ajPosMask[] =    // The i'th entry contains a byte with the i'th bit set
{
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80, 0x00
};

static BYTE
ajBits[] =       // The i'th entry contains a byte with the high i bits set
{
    0x00, 0x80, 0xC0, 0xE0, 0xF0,
          0xF8, 0xFC, 0xFE, 0xFF
};

static BYTE
ajBitPatterns[] = // The four possible full byte bit patterns of a packed colour
{
    0x00, 0x55, 0xAA, 0xFF
};

/* And now the function ***************************************************/

BOOL
bSrcCopySRLE4D1(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol,
                 pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.
// Extra Variables

    BYTE  jWorking;      // Hold area to build a byte for output
    ULONG ulWritePos;    // Write position off <pjDst> into the destination

    ULONG ulLeftWritePos; // Leftmost write position
    BYTE  jLeftMask;      // Bitmask for taking bytes off the left edge

    ULONG ulRightWritePos; // Rightmost write position
    BYTE  jRightMask;      // Bitmask for taking bytes off the right edge

    BYTE  jBitPos;       // Bit number of the next write into <jWorking>
    BYTE  jBitPosMask;   // Bitmask with the <jBitPos>th bit set.

    ULONG ulCompBytes;   // Number of full bytes in an Encoded run.
    ULONG ulClipMargin;  // Number of bytes clipped off the right side of a run

    BYTE jSource;        // Packed RLE 4 colour code
    BYTE ajColours[2];   // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;     // TRUE when an absolute run ends with a partial byte

    UINT i=0, j=0;

// Our Initialization

    ulLeftWritePos = (ULONG)(ulDstLeft >> 3);
    jLeftMask = ajBits[ulDstLeft % 8];
    ulRightWritePos = (ULONG) (ulDstRight >> 3);
    jRightMask = ~ajBits[(ulDstRight % 8)];

/* Fetch first working byte from the source.  Yes, this is ugly.
 * We cannot assume we are at a left edge because the complex clipping
 * case could resume an RLE in the middle of its bitmap.  We cannot do
 * a simple bounds check like RLE 8 to 4 because of bitmasking.  Argh.
 */

    ulWritePos = lOutCol >> 3;

    if (RLE_RowVisible)
    {
        if (RLE_ColVisible(lOutCol))
            jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
        else
        {
            if (RLE_PastRightEdge(lOutCol))
                jWorking = pjDst[ulRightWritePos];
            else
                jWorking = pjDst[ulLeftWritePos] & jLeftMask;
        }
    }

// Diddle the translation table

    for (i = 1, j = 1; i < 16; i+=1, j ^= 1) pulXlate[i] = j;

// Main Process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        ulWritePos = lOutCol >> 3;

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

            case 0:

            // New Line.

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            case 1:

            // End of the bitmap.

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

            // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Fetch a new working byte off the destination

                ulWritePos = lOutCol >> 3;
                if (RLE_ColVisible(lOutCol))
                    jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
                else
                    if (RLE_PastRightEdge(lOutCol))
                        jWorking = pjDst[ulRightWritePos];
                    else
                        jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            default:

            /* Absolute Mode.
                 * The run length is stored in <ulNext>, <ulCount> is used to
                 * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount     = ulDstLeft - lOutCol;
                        ulNext     -= ulCount;
                        lOutCol    += ulCount;
                        ulWritePos  = lOutCol >> 3;

                        pjSrc += (ulCount >> 1);

                        jBitPos = (BYTE) ColToBitPos(lOutCol);
                        jBitPosMask = ajPosMask[jBitPos]; // Always non-zero.

                    // Force the source to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE)
                                         pulXlate[GetLowNybble(*pjSrc++)];
                            if (jSource)
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            lOutCol++;
                            ulNext--;
                        }

                    }
                    else
                    {
                        jBitPos = (BYTE) ColToBitPos(lOutCol);
                        jBitPosMask = ajPosMask[jBitPos]; // Always non-zero.
                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Run Initialization

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    lOutCol += ulNext;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    i = 0;  // Source read toggle.
                    do {

                    // Fill the working byte

                        while(jBitPosMask && ulNext)
                        {
                            if (!i)
                            {
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                            }
                            if (ajColours[i])
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            ulNext--;
                            i ^= 1;
                        }

                    // Write it

                        if (!(jBitPosMask))
                        {
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            jBitPosMask = 0x80;
                            jWorking = 0;
                        }

                    } while (ulNext);

                // Adjust for the right side clipping.

                    pjSrc += bExtraByte ? (ulCount >> 1) :
                                         ((ulCount  + 1) >> 1);
                    lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */
                    lOutCol += ulNext;
                    pjSrc += ((ulNext + 1) >> 1);

                } /* if */

            // Fix up if this run was not WORD aligned.
                RLE4_FixAlignment(pjSrc);

            } /* switch */

        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */
            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                    ulCount      -= ulClipMargin;
                    lOutCol   += ulClipMargin;
                    ulWritePos = lOutCol >> 3;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Initialize for the run

                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);
                jSource  = ajBitPatterns[2*ajColours[0] + ajColours[1]];

//                jSource  |= ((jSource << 2) |
//                                (jSource << 4) |
//                                (jSource << 6));

                jBitPos   = (BYTE) ColToBitPos(lOutCol);
                jBitPosMask = ajPosMask[jBitPos];
                ulCompBytes = (ulCount < (ULONG)jBitPos + 1) ? 0 :
                            ((BYTE)ulCount - jBitPos - 1) >> 3;

                lOutCol += ulCount;

                ulCount -= (ulCompBytes << 3);

            // Deal with a partial byte on the left

                if (jBitPos >= (LONG) ulCount)
                {
                // Will not fill the working byte

                    jSource &= ajBits[ulCount];
                    jWorking |= (BYTE)(jSource >> (7-jBitPos));
                    jBitPos -= (BYTE)ulCount;
                    ulCount = 0;
                }
                else
                {
                // Will fill the working byte

                    jWorking |= (jSource & ajBits[jBitPos + 1])
                                    >> (7-jBitPos);
                    pjDst[ulWritePos] = jWorking;
                    if (!bIsOdd(jBitPos))
                        jSource = RollLeft(jSource);
                    ulWritePos++;
                    jWorking = 0;
                    ulCount    -= (jBitPos + 1);
                    jBitPos   = 7;
                }

            // Deal with complete byte output

                if (ulCompBytes)
                {
                    for (i = 0; i < ulCompBytes; i++)
                        pjDst[ulWritePos + i] = jSource;
                    ulWritePos += ulCompBytes;
                    jBitPos = 7;
                    jWorking = 0;

                }

            // Deal with the right side partial byte

                if (ulCount)
                    jWorking |= (ajBits[ulCount] & jSource);


            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position and source pointer.
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE4D1 */

/******************************Public*Routine*****************************
** bSrcCopySRLE4D4
*
* Secure RLE blting to a 4 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*     Added clip support.
*
*  24 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        To this end, the below macro...
 */

#define RLE4to4_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible)                                                      \
    {                                                                        \
        if (RLE_ColVisible(OutColumn) && bIsOdd(OutColumn))                  \
        {                                                                    \
            SetLowNybble(OutByte, DstPtr[WritePos]);                         \
            DstPtr[WritePos] = OutByte;                                      \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (bRightPartial && RLE_PastRightEdge(OutColumn))               \
            {                                                                \
                SetLowNybble(OutByte, DstPtr[ulRightWritePos]);              \
                DstPtr[ulRightWritePos] = OutByte;                           \
            }                                                                \
        }                                                                    \
    }                                                                        \

BOOL
bSrcCopySRLE4D4(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BOOL  bRightPartial;   // TRUE when a visible row ends in a partial byte
    BYTE  jWorking;        // Hold area to build a byte for output
    ULONG ulWritePos;      // Write position off <pjDst> into the destination
    ULONG ulLeftWritePos;  // Leftmost write position
    ULONG ulRightWritePos; // Rightmost write position

    BYTE jSource;          // Packed RLE 4 colour code
    BYTE ajColours[2];     // Destination for unpacking an RLE 4 code

// Our Initialization

    ulLeftWritePos     = ulDstLeft  >> 1;
    ulRightWritePos    = ulDstRight >> 1;
    bRightPartial = (BOOL) bIsOdd(ulDstRight);

// Fetch our inital working byte

    ulWritePos = lOutCol >> 1;
    if (RLE_RowVisible)
        jWorking = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                     ulWritePos)];

// Main processing loop

    LOOP_FOREVER
    {
        ulWritePos = lOutCol >> 1;

    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode.

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos];

                break;

            case 1:

            // End of bitmap

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                return(FALSE);

            case 2:

            // Positional Delta

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Read initial working byte

                ulWritePos = lOutCol >> 1;
                jWorking =
                      pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                        ulWritePos)];

                break;

            default:

                // Absolute Mode

                // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                // Left Side Clipping.  Lots 'o stuff happenin'

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;

                        lOutCol    = ulDstLeft;
                        ulWritePos = ulDstLeft >> 1;

                        ulNext -= ulCount;
                        pjSrc  += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) pulXlate[GetLowNybble(*pjSrc++)];

                            if (bIsOdd(lOutCol))
                            {
                                SetLowNybble(jWorking, jSource);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                            }
                            else
                                SetHighNybble(jWorking, jSource);
                            lOutCol++;
                            ulNext--;

                        // Deal with the special case only one byte is visible

                            if (!ulNext)
                            {
                                RLE4_FixAlignment(pjSrc);
                                continue;
                            }
                        }

                    }

                // Right Side Clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext  = ulDstRight - lOutCol;
                    }
                    else
                        ulCount = 0;

                // Write the Run

                    ASSERTGDI(lOutCol < (LONG) ulDstRight,
                                "No longer visible\n");

                    if (ulNext != 0)
                    {
                        if (bIsOdd(lOutCol))
                        {
                        // Case 1:  Source & Dest misaligned w.r.t. bytes

                            lOutCol += ulNext;
                            jSource = *pjSrc++;
                            RLE4_MakeColourBlock(jSource, ajColours,
                                                 BYTE, pulXlate);
                            SetLowNybble(jWorking, ajColours[0]);
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            ulNext--;
                            ulNext >>= 1;

                            while (ulNext)
                            {
                                SetHighNybble(jWorking, ajColours[1]);
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                                SetLowNybble(jWorking, ajColours[0]);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                                ulNext--;

                            } /* while */

                        /* Account for the right side partial byte
                         * and do the right clip adjustment on the source
                         */

                            if (bIsOdd(lOutCol))
                            {
                                SetHighNybble(jWorking, ajColours[1]);
                                pjSrc += ((ulCount + 1) >> 1);

                            }
                            else
                            {
                                pjSrc += (ulCount >> 1);
                            }

                        }
                        else
                        {
                        // Case 2:  Source & Dest aligned on byte boundaries

                            lOutCol += ulNext;
                            ulNext >>= 1;

                            while (ulNext)
                            {
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                                jWorking = BuildByte(ajColours[0], ajColours[1]);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                                ulNext--;
                            } /* while */

                        /* Account for the right side partial byte
                         * and do the right clip adjustment on the source
                         */

                            if (bIsOdd(lOutCol))
                            {
                                jSource = GetHighNybble(*pjSrc++);
                                SetHighNybble(jWorking,
                                              (BYTE)pulXlate[(ULONG)jSource]);
                                pjSrc += (ulCount >> 1);
                            }
                            else
                            {
                                pjSrc += ((ulCount + 1) >> 1);
                            }

                        }
                    }
                    else
                    {
                    /* Do the right clip adjustment on the source
                     */

                        pjSrc += ((ulCount + 1) >> 1);
                    }

                    lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc += ((ulNext + 1) >> 1);

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc);

            } /* switch */
        }
        else
        {
        // Encoded Mode

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol    = ulDstLeft;
                    ulWritePos = ulDstLeft >> 1;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount      = ulDstRight - lOutCol;
                }
                else
                    ulClipMargin = 0;


                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);

            // Align the destination to a byte boundary

                if (bIsOdd(lOutCol))
                {
                    SetLowNybble(jWorking, ajColours[0]);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    lOutCol++;
                    ulCount--;
                    SwapValues(ajColours[0], ajColours[1]);
                }

                lOutCol += ulCount;

            // Run initialization

                ulCount >>= 1;

                jWorking = BuildByte(ajColours[0], ajColours[1]);

            // Write complete bytes

                while(ulCount)
                {
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    ulCount--;
                }

            // Account for writing a partial byte on the right side

                if (bIsOdd(lOutCol))
                    SetHighNybble(jWorking, ajColours[0]);

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

                lOutCol += ulCount;

            } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE4D4 */

/******************************Public*Routine******************************\
* bSrcCopySRLE4D16
*
* Secure RLE blting to a 16 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/
BOOL
bSrcCopySRLE4D16(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pwDst, PWORD, ulCount, ulNext, lOutCol,
                 pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BYTE jSource;       // Packed RLE 4 colour code
    WORD awColours[2];  // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;    // TRUE when an absolute run ends with a partial byte

// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);
        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE_NextLine(PWORD, pwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap.

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;

                        pjSrc += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) *pjSrc++;
                            pwDst[lOutCol] =
                                   (WORD) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Deal with complete source bytes

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, awColours, WORD,
                                             pulXlate);
                        pwDst[lOutCol]   = awColours[0];
                        pwDst[lOutCol+1] = awColours[1];

                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for right partial byte in the source */

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, awColours, WORD,
                                             pulXlate);
                        pwDst[lOutCol] = awColours[0];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
            /* Encoded Mode
             * The run length is stored in <ulCount>, <ulClipMargin> is used
             * to  hold left and right clip amounts.
             */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run initialization

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, awColours, WORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    pwDst[lOutCol]   = awColours[0];
                    pwDst[lOutCol+1] = awColours[1];
                    lOutCol += 2;
                    ulCount --;
                }

            // ... and an extra byte for an odd run length

                if (bExtraByte)
                {
                    pwDst[lOutCol] = awColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D16 */


/******************************Public*Routine*****************************
** bSrcCopySRLE4D24
*
* Secure RLE blting to a 24 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

#define RLE_24BitWrite(DstPtr, BytePos, Colour)                               \
    DstPtr[BytePos]   = (BYTE)Colour;                                         \
    DstPtr[BytePos+1] = (BYTE)(Colour >> 8);                                  \
    DstPtr[BytePos+2] = (BYTE)(Colour >> 16);                                 \
    BytePos += 3;                                                            \

BOOL
bSrcCopySRLE4D24(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    ULONG ulWritePos;    // Write position off <pjDst> into the destination
    BYTE jSource;        // Packed RLE 4 colour code
    DWORD adwColours[2]; // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;     // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin;  // Number of bytes clipped off an Encoded run

// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;
                        ulWritePos = 3*lOutCol;

                        pjSrc += (ulCount >> 1);

                    // Align the Source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            adwColours[0] = pulXlate[GetLowNybble(*pjSrc++)];
                            RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                            lOutCol++;
                            ulNext--;
                        }

                    }
                    else
                        ulWritePos = 3*lOutCol;

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Run Initialization.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    lOutCol += ulNext;
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[1]);
                        ulNext--;
                    }

                // Account for a right partial byte in the source

                    if (bExtraByte)
                    {
                        adwColours[0] = pulXlate[GetHighNybble(*pjSrc++)];
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }


            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run initialization

                ulWritePos = 3*lOutCol;
                lOutCol += ulCount;
                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;

                RLE4_MakeColourBlock(ulNext, adwColours, DWORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[1]);
                    ulCount --;
                }

            // Write the extra byte from an odd run length

                if (bExtraByte)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D24 */

/******************************Public*Routine*****************************
** bSrcCopySRLE4D32
*
* Secure RLE blting to a 32 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE4D32(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pdwDst, PDWORD, ulCount, ulNext,
                      lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BYTE  jSource;       // Packed RLE 4 colour code
    DWORD adwColours[2]; // Destination for unpacking an RLE 4 code
    BOOL  bExtraByte;    // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin;  // Number of bytes clipped off an Encoded run


// Main processing loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE_NextLine(PDWORD, pdwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */
            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pdwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;

                        pjSrc += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) *pjSrc++;
                            pdwDst[lOutCol] =
                                   (DWORD) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        pdwDst[lOutCol]   = adwColours[0];
                        pdwDst[lOutCol+1] = adwColours[1];

                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for a right partial byte in the source

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        pdwDst[lOutCol] = adwColours[0];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc);

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run Initialization.

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, adwColours, DWORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    pdwDst[lOutCol]   = adwColours[0];
                    pdwDst[lOutCol+1] = adwColours[1];
                    lOutCol += 2;
                    ulCount --;
                }

            // Write the extra byte from an odd run length

                if (bExtraByte)
                {
                    pdwDst[lOutCol] = adwColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D32 */




/*******************************Public*Routine*****************************\
* WriteEncoded4
*
* A helper function for EncodeRLE4.  Writes a run of bytes in encoded format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteEncoded4( BYTE bValue, BYTE *pbTarget, UINT uiLength,
                   BYTE *pbEndOfBuffer )
{

    if( pbTarget == NULL )
        return(2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = (BYTE) uiLength;
    *pbTarget++ = bValue;
    return(2);
}



/*******************************Public*Routine*****************************\
* WriteAbsolute4
*
* A helper function for EncodeRLE4.  Writes a run of bytes in absolute format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteAbsolute4( BYTE *pbRunStart, BYTE *pbTarget, int cRunLength,
                    BYTE *pbEndOfBuffer )
{
    int iRet;


    if( cRunLength < 3 )
    {
        iRet = 2;
    }
    else
    {

        if( ( cRunLength + 1 ) & 0x02 )
        {
            iRet = (( cRunLength + 1 ) >> 1) + 3;
        }
        else
        {
            iRet = (( cRunLength + 1 ) >> 1) + 2;
        }
    }

    if( pbTarget == NULL )
        return(iRet);

    if( pbTarget + iRet > pbEndOfBuffer )
        return(0);

    if( cRunLength < 3  )
    {
        *pbTarget++ = (BYTE) cRunLength;
        *pbTarget = *pbRunStart;
        return(2);

    }

    *pbTarget++ = 0;
    *pbTarget++ = (BYTE) cRunLength;

    RtlMoveMemory( pbTarget, pbRunStart, ( cRunLength + 1 ) >> 1 );

    pbTarget +=  ( cRunLength + 1 ) >> 1;

    if( ( cRunLength + 1 ) & 0x02 )
    {
        *pbTarget++ = 0;
        return( iRet );
    }
    else
        return( iRet  );

}



/*******************************Public*Routine*****************************\
* EncodeRLE4
*
* Encodes a bitmap into RLE4 format and returns the length of the of the
* encoded format.  If the source is NULL it just returns the length of
* the format.  If the encoded output turns out to be longer than cBufferSize
* the functions stops encoding.
*
* History:
*  28 Oct 1992 Gerrit van Wingerden [gerritv] : creation
*  15 Mar 1993 Stephan J. Zachwieja [szach] : return 0 if buffer too small
*
\**************************************************************************/




int EncodeRLE4( BYTE *pbSource, BYTE *pbTarget, UINT uiWidth, UINT cNumLines,
                UINT cBufferSize )
{

    UINT cLineCount, uiLineWidth;
    BYTE bLastByte,bCurChar;
    BYTE *pbRunStart;
    BYTE *pbLineEnd;
    BYTE *pbEndOfBuffer;
    BYTE *pbCurPos;
    INT  cCurrentRunLength;
    INT  iMode, cTemp;
    UINT cTotal = 0;

    pbEndOfBuffer = pbTarget + cBufferSize;

// Compute width of line in bytes rounded to a DWORD boundary

    uiLineWidth = ( ( uiWidth + 7 ) >> 3 ) << 2 ;

    for( cLineCount = 0; cLineCount < cNumLines; cLineCount ++ )
    {
        pbRunStart = pbSource + uiLineWidth * cLineCount;
        bLastByte = *pbRunStart;
        pbLineEnd = pbRunStart + ( ( uiWidth + 1 ) >> 1 );
        iMode = RLE_START;
        cCurrentRunLength = 2;

        for(pbCurPos = pbRunStart+1;pbCurPos <= pbLineEnd; pbCurPos += 1)
        {

            // We won't really encode the value at *pbLineEnd since it points
            // past the end of the scan so it doesn't matter what value we use.
            // However, it is important not to reference it since it may point
            // past the end of the buffer which can be uncommited memory.

            if( pbCurPos == pbLineEnd )
            {
                bCurChar = 0xFF;
            }
            else
            {
                bCurChar = *pbCurPos;
            }


            switch( iMode )
            {
            case RLE_START:
                iMode = ( bCurChar == bLastByte ) ? RLE_ENCODED : RLE_ABSOLUTE;
                bLastByte = bCurChar;
                break;
            case RLE_ABSOLUTE:

// There are two ways that this run could be over.  We could have exceeded the
// maximum length 0xFE ( since this algorithm works with bytes ), or there
// could be a switch into absolute mode.

                if( ( bCurChar == bLastByte ) ||
                    ( cCurrentRunLength == 0xFE ) )

                {
                    int iOffset;

                    if( cCurrentRunLength == 0xFE )
                    {
// If this is the end of the line and there is and odd line length, ignore the
// last nibble of the the final byte.

                        if( (pbCurPos == pbLineEnd ) && ( uiWidth & 0x01 ))
                            iOffset = 1;
                        else
                            iOffset = 0;

                        iMode = RLE_START;
                    }
                    else
                    {
                        iOffset = 2;
                        iMode = RLE_ENCODED;
                    }

                    cTemp = WriteAbsolute4(pbRunStart, pbTarget,
                       cCurrentRunLength - iOffset, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if(pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                       pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = iOffset;
                }

                bLastByte = bCurChar;
                break;

            case RLE_ENCODED:
                if( ( bCurChar != bLastByte ) ||
                    ( cCurrentRunLength == 0xFE ) )

                {
// Don't include last nibble if the width of the scan line is odd and this
// this is the last byte.

                    if( (pbCurPos == pbLineEnd ) && ( uiWidth & 0x01 ))
                         cCurrentRunLength -= 1;

                    cTemp = WriteEncoded4(bLastByte,
                       pbTarget, cCurrentRunLength, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if(pbTarget != NULL) {
                        if (cTemp == 0) return(0);
                        pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    bLastByte = bCurChar;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = 0;
                    iMode =  RLE_START ;
                }

            }
            cCurrentRunLength += 2;
        }

        if( cCurrentRunLength > 3 )
        {
// Don't include last nibble if the width of the scan line is odd and this
// this is the last byte.

            if(  uiWidth & 0x01 )
                cCurrentRunLength -= 1;


         // if pbTarget is not NULL and cTemp is zero then
         // the buffer is too small to hold  encoded  data

            if(iMode == RLE_ABSOLUTE)
               cTemp = WriteAbsolute4(pbRunStart, pbTarget,
                  cCurrentRunLength - 2, pbEndOfBuffer);
            else {
               cTemp = WriteEncoded4(bLastByte, pbTarget,
                  cCurrentRunLength - 2, pbEndOfBuffer);
            }

            if (pbTarget != NULL) {
               if (cTemp == 0) return(0);
               pbTarget += cTemp;
            }

            cTotal += cTemp;
        }

        if( pbTarget <= pbEndOfBuffer )
            cTotal += 2;

        if( pbTarget != NULL )
        {
            *((WORD *) pbTarget) = 0;
            pbTarget += 2;
        }

    }
// Write "End of bitmap" at the end so we're win31 compatible.

    if( pbTarget == NULL )
        return(cTotal + 2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = 0;
    *pbTarget++ = 1;
    return(cTotal + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\solid.cxx ===
/******************************Module*Header*******************************\
* Module Name: solid.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with solid colors.
*
* Created: 03-Mar-1991 22:01:14
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Array of masks for blting

ULONG aulMsk[] =
{
    0xFFFFFFFF,
    0xFFFFFF7F,
    0xFFFFFF3F,
    0xFFFFFF1F,
    0xFFFFFF0F,
    0xFFFFFF07,
    0xFFFFFF03,
    0xFFFFFF01,
    0xFFFFFF00,
    0xFFFF7F00,
    0xFFFF3F00,
    0xFFFF1F00,
    0xFFFF0F00,
    0xFFFF0700,
    0xFFFF0300,
    0xFFFF0100,
    0xFFFF0000,
    0xFF7F0000,
    0xFF3F0000,
    0xFF1F0000,
    0xFF0F0000,
    0xFF070000,
    0xFF030000,
    0xFF010000,
    0xFF000000,
    0x7F000000,
    0x3F000000,
    0x1F000000,
    0x0F000000,
    0x07000000,
    0x03000000,
    0x01000000,
};

#define DBG_SOLID 0

#if DBG_SOLID
ULONG   DbgSolid = 0;
#endif

/******************************Public*Routine******************************\
* vSolidFillRect1
*
* Does a solid blt to a DIB of 1, 4, 8, 16 or 32 bpp.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to work on list of rectangles.
*       Change center loop to call RtlFillMemory only for wide
*       scan lines
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidFillRect1(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    ULONG   ulMskLeft;
    ULONG   ulMskRight;
    ULONG   cLeft;
    ULONG   cRight;
    ULONG   cxDword;
    ULONG   yRow;
    ULONG   ulColor;
    PULONG  pulTmp;
    PULONG  pulDst;
    ULONG   cx;
    ULONG   cy;
    ULONG   xDstStart;

    #if DBG_SOLID
        if (DbgSolid >= 1) {
            DbgPrint("SolidFillRect1:\n");
            DbgPrint("  pjDst     = 0x%08lx\n",pjDst);

            if (DbgSolid >= 2) {
                DbgPrint("  prcl      = 0x%08lx\n",prcl);
                DbgPrint("  cRcl      = %li\n",cRcl);
                DbgPrint("  lDeltaDst =  %li\n",lDeltaDst);
                DbgPrint("  iColor    = 0x%08lx\n",iColor);
                DbgPrint("  cShift    = %li\n",cShift);
            }
        }
    #endif

    //
    // loop through each rectangle
    //

    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        //
        // make sure rectangle is well ordered
        //

        ASSERTGDI(prcl != NULL,"ERROR: prcl = NULL");
        ASSERTGDI(prcl->right  >  prcl->left,"ERROR: left >= right");
        ASSERTGDI(prcl->bottom >  prcl->top, "ERROR: top >= bottom");

        #if DBG_SOLID

            if (DbgSolid >= 1) {
                DbgPrint("  Rect:   %li,%li to %li,%li\n",
                    prcl->left,prcl->top,
                    prcl->right,prcl->bottom);
            }

        #endif

        pulDst = (PULONG)(pjDst + prcl->top * lDeltaDst);

        cy = prcl->bottom - prcl->top;

        //
        // cx is the number of bits in the scan line to fill
        //

        cx = (prcl->right - prcl->left) << cShift;

        //
        // Starting bit
        //

        xDstStart = prcl->left << cShift;

        //
        // starting and ending DWORD offset
        //

        cLeft  = xDstStart >> 5;
        cRight = (xDstStart + cx) >> 5;

        //
        // generate left and right bit masks
        //

        ulMskLeft  = aulMsk[xDstStart      & 0x1f];
        ulMskRight = aulMsk[(xDstStart+cx) & 0x1f];

        //
        // if cLeft equals cRight then onyl 1 DWORD needs to be modified,
        // combine left and right masks. Do entire strip.
        //

        if (cLeft == cRight) {
            ulMskLeft &= ~ulMskRight;
            ulColor = iColor & ulMskLeft;
            ulMskLeft = ~ulMskLeft;
            pulTmp    = pulDst + cLeft;

            while (cy--) {
                *pulTmp = (*pulTmp & ulMskLeft) | ulColor;
                pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
            }

        } else {

            //
            // do solid fill in three portions,
            //
            // left edge  (partial DWORD)
            // center     (full DWORD)
            // right edge (partial DWORD)
            //

            //
            // left strip
            //

            if (ulMskLeft != ~0) {
                pulTmp = pulDst + cLeft;
                ulColor = iColor & ulMskLeft;
                ulMskLeft = ~ulMskLeft;
                yRow = cy;

                while (yRow--) {
                    *pulTmp = (*pulTmp & ulMskLeft) | ulColor;
                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }

                cLeft++;
            }

            //
            // center calc number of DWORDS
            //

            cxDword = cRight - cLeft;
            pulTmp  = pulDst + cLeft;
            if (cxDword != 0) {

                yRow = cy;

                while (yRow--) {

                    switch (cxDword) {
                    case 7:
                        *(pulTmp+6) = iColor;
                    case 6:
                        *(pulTmp+5) = iColor;
                    case 5:
                        *(pulTmp+4) = iColor;
                    case 4:
                        *(pulTmp+3) = iColor;
                    case 3:
                        *(pulTmp+2) = iColor;
                    case 2:
                        *(pulTmp+1) = iColor;
                    case 1:
                        *(pulTmp)   = iColor;
                        break;
                    default:
                        RtlFillMemoryUlong((PVOID)pulTmp,cxDword<<2,iColor);
                    }

                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }

            }

            //
            // right edge
            //

            if (ulMskRight != ~0) {
                pulTmp   = pulDst + cRight;
                ulColor  = iColor & ~ulMskRight;


                while (cy--) {
                    *pulTmp = (*pulTmp & ulMskRight) | ulColor;
                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }
            }

        }



    }
}

/******************************Public*Routine******************************\
* vSolidFillRect24
*
* Does a solid blt to a 24 bpp DIB.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to list of rects
*
*  02-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidFillRect24(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    PBYTE   pjDstRow;
    BYTE    jRed,jGreen,jBlue;
    ULONG   cxTemp;
    ULONG   cx;
    ULONG   cy;
    LONG    lDelta;

    DONTUSE(cShift);

    //
    // place any asserts here
    //


    jRed   = (BYTE)iColor;
    jGreen = (BYTE)(iColor >> 8);
    jBlue  = (BYTE)(iColor >> 16);


    //
    // loop through each rectangle
    //

    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        pjDstRow = pjDst + (prcl->top * lDeltaDst) + 3 * prcl->left;

        cy = prcl->bottom  - prcl->top;
        cx = prcl->right - prcl->left;

        //
        // lDelta is adjusted to go from the end of one scan
        // line to the start of the next.
        //

        lDelta = lDeltaDst - 3*cx;

        while (cy--) {

            cxTemp = cx;

            while (cxTemp--) {

                *(pjDstRow)   = jRed;
                *(pjDstRow+1) = jGreen;
                *(pjDstRow+2) = jBlue;

                pjDstRow += 3;
            }

            pjDstRow += lDelta;

        }
    }
}


/******************************Public*Routine******************************\
* vSolidXorRect1
*
* Does an xor blt to a DIB or 1, 4, 8, 16 or 32 bpp.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to list of rects
*
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidXorRect1(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    ULONG   ulMskLeft;
    ULONG   ulMskRight;
    ULONG   iLeft;
    ULONG   iRight;
    ULONG   cLeft;
    ULONG   cRight;
    ULONG   culFill;
    ULONG   yRow;
    PULONG  pulTmp;
    PULONG  pulDst;
    ULONG   cx;
    ULONG   cy;
    ULONG   xDstStart;
    BOOL    bSimple;

    #if DBG_SOLID

        if (DbgSolid >= 1) {
            DbgPrint("SolidXorRect1:\n");
            DbgPrint("  pjDst     = 0x%08lx\n",pjDst);

            if (DbgSolid >= 2) {
                DbgPrint("  prcl      = 0x%08lx\n",prcl);
                DbgPrint("  cRcl      = %li\n",cRcl);
                DbgPrint("  lDeltaDst =  %li\n",lDeltaDst);
                DbgPrint("  iColor    = 0x%08lx\n",iColor);
                DbgPrint("  cShift    = %li\n",cShift);
            }
        }

    #endif

    //
    // loop through each rectangle
    //

    for ( ; cRcl > 0;cRcl--, prcl++ )
    {
        //
        // init rect params
        //

        ASSERTGDI(prcl != NULL,"ERROR: prcl = NULL");
        ASSERTGDI(prcl->right  >  prcl->left,"ERROR: left >= right");
        ASSERTGDI(prcl->bottom >  prcl->top, "ERROR: top >= bottom");

        pulDst = (PULONG)(pjDst + prcl->top * lDeltaDst);

        cx     = (prcl->right - prcl->left) << cShift;

        cy     = prcl->bottom - prcl->top;

        xDstStart = (prcl->left << cShift);

        //
        // calc index of leftmost and rightmost DWORDS
        //

        cLeft = xDstStart >> 5;
        cRight = (xDstStart + cx) >> 5;

        //
        // calc number of bits used in leftmost and rightmost DWORDs
        //

        iLeft = xDstStart & 31;
        iRight = (xDstStart + cx) & 31;

        //
        // generate DWORD store masks
        //

        ulMskLeft  =  aulMsk[iLeft];
        ulMskRight = ~aulMsk[iRight];

        //
        // If the leftmost and rightmost DWORDs are the same, then only one
        // strip is needed.  Merge the two masks together and note this.
        //

        bSimple = FALSE;

        if (cLeft == cRight)
        {
            ulMskLeft &= ulMskRight;
            bSimple = TRUE;
        }


        #if DBG_SOLID

            if (DbgSolid >= 1) {
                DbgPrint("  Rect:   %li,%li to %li,%li\n",
                    prcl->left,prcl->top,
                    prcl->right,prcl->bottom);
            }

        #endif


        //
        // Lay down the left edge, if needed.
        //

        if (bSimple || (iLeft != 0))
        {
            pulTmp = pulDst + cLeft;
            ulMskLeft &= iColor;

            for (yRow = 0; yRow != cy; yRow++)
            {
                *pulTmp ^= ulMskLeft;
                pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
            }

            cLeft++;
        }

        if (!bSimple) {

            //
            // Lay down the center strip, if needed.
            //

            culFill = cRight - cLeft;

            if (culFill != 0)
            {
                pulTmp = pulDst + cLeft;
                for (yRow = 0; yRow != cy; yRow++)
                {
                    cx = culFill;
                    while (cx--)
                    *pulTmp++ ^= iColor;

                    pulTmp -= culFill;
                    pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
                }
            }

            //
            // Lay down the right edge, if needed.
            //

            if (iRight != 0)
            {
                pulTmp = pulDst + cRight;
                ulMskRight &= iColor;

                for (yRow = 0; yRow != cy; yRow++)
                {
                    *pulTmp ^= ulMskRight;
                    pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
                }
            }

        }

    }
}

/******************************Public*Routine******************************\
* vSolidXorRect24
*
* Does a solid blt to a 24 bpp DIB.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomes [jimt]
*   change call to list of rects
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  02-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidXorRect24(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    PBYTE pjDstTmp;
    BYTE  jRed, jGreen, jBlue;
    ULONG cxTemp;
    ULONG cx;
    ULONG cy;
    LONG  lDelta;

    DONTUSE(cShift);

    //
    // lDelta is adjusted to go from the end of one scan
    // line to the start of the next.
    //


    jRed = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue = (BYTE) (iColor >> 16);


    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        //
        // init rect params
        //

        pjDstTmp = pjDst + prcl->top * lDeltaDst + prcl->left * 3;

        cx    = prcl->right - prcl->left;
        cy    = prcl->bottom - prcl->top;

        lDelta = lDeltaDst - (3 * cx);

        ASSERTGDI(cx != 0, "ERROR vDibSolidBlt32");
        ASSERTGDI(cy != 0, "ERROR vDibSolidBlt32");

        while(cy--)
        {
            cxTemp = cx;

            while(cxTemp--)
            {
                *(pjDstTmp)   ^= jRed;
                *(pjDstTmp+1) ^= jGreen;
                *(pjDstTmp+2) ^= jBlue;

                pjDstTmp += 3;

            }

            pjDstTmp = pjDstTmp + lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vSolidFillRow1
*
*   Blt a list of adjacent rows to a DIB of of 1, 4, 8, 16 or 32 bpp.
*
* History:
*  11-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidFillRow1(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        ULONG *pulDst = (PULONG)pjBits;

        LONG  cx        = (prow->right - prow->left) << cShift;
        ULONG xDstStart = prow->left << cShift;

        BOOL  bSimple = FALSE;

        ULONG cLeft = xDstStart >> 5;                 // Index of leftmost DWORD
        ULONG cRght = (xDstStart + cx) >> 5;          // Index of rightmost DWORD

        ULONG iLeft = xDstStart & 31;                 // Bits used in leftmost DWORD
        ULONG iRght = (xDstStart + cx) & 31;          // Bits used in rightmost DWORD

        ULONG ulMskLeft =  aulMsk[iLeft];
        ULONG ulMskRght = ~aulMsk[iRght];

    // If the leftmost and rightmost DWORDs are the same, then only one
    // strip is needed.  Merge the two masks together and note this.

        if (cLeft == cRght)
        {
            ulMskLeft &= ulMskRght;
            bSimple = TRUE;
        }

    // Lay down the left edge, if needed.

        if (bSimple || (iLeft != 0))
        {
            pulDst[cLeft] = (pulDst[cLeft] & ~ulMskLeft) | (iColor & ulMskLeft);

            if (bSimple)
                continue;

            cLeft++;
        }

    // Lay down the center strip, if needed.

        ULONG cjFill = (cRght - cLeft) << 2;

        if (cjFill != 0)
            RtlFillMemoryUlong((PVOID) (pulDst+cLeft), cjFill, iColor);

    // Lay down the right edge, if needed.

        if (iRght != 0)
            pulDst[cRght] = (pulDst[cRght] & ~ulMskRght) | (iColor & ulMskRght);
    }
}

/******************************Public*Routine******************************\
* vSolidFillRow24
*
*   Blt a list of adjacent rows to a 24 bpp DIB.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidFillRow24(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    BYTE  jRed, jGreen, jBlue;

    jRed   = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue  = (BYTE) (iColor >> 16);

    pjBits += (yTop * lDelta);

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        LONG   cx        = (prow->right - prow->left) << cShift;
        ULONG  xDstStart = prow->left << cShift;
        BYTE*  pjDst     = pjBits + (3 * xDstStart);

        ULONG cxTemp = cx;

        while(cxTemp--)
        {
            *(pjDst++) = jRed;
            *(pjDst++) = jGreen;
            *(pjDst++) = jBlue;
        }
    }
}

/******************************Public*Routine******************************\
* vSolidXorRow1
*
* Does an xor blt of a list of adjacent rows to a DIB or 1, 4, 8, 16 or 32 bpp.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidXorRow1(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++,pjBits += lDelta)
    {
        ULONG*  pulDst    = (ULONG *) pjBits;
        LONG    cx        = (prow->right - prow->left) << cShift;
        ULONG   xDstStart = prow->left << cShift;

        ULONG   ulMskLeft;
        ULONG   ulMskRght;
        ULONG   iLeft;
        ULONG   iRght;
        ULONG   cLeft;
        ULONG   cRght;
        ULONG   culFill;
        BOOL    bSimple = FALSE;

        cLeft = xDstStart >> 5;                 // Index of leftmost DWORD
        cRght = (xDstStart + cx) >> 5;          // Index of rightmost DWORD

        iLeft = xDstStart & 31;                 // Bits used in leftmost DWORD
        iRght = (xDstStart + cx) & 31;          // Bits used in rightmost DWORD

        ulMskLeft =  aulMsk[iLeft];
        ulMskRght = ~aulMsk[iRght];

    // If the leftmost and rightmost DWORDs are the same, then only one
    // strip is needed.  Merge the two masks together and note this.

        if (cLeft == cRght)
        {
            ulMskLeft &= ulMskRght;
            bSimple = TRUE;
        }

    // Lay down the left edge, if needed.

        if (bSimple || (iLeft != 0))
        {
            ulMskLeft &= iColor;

            pulDst[cLeft] ^= ulMskLeft;

            if (bSimple)
                continue;

            cLeft++;
        }

    // Lay down the center strip, if needed.

        culFill = cRght - cLeft;

        if (culFill != 0)
        {
            PULONG pulTmp = pulDst + cLeft;
            cx = culFill;
            while (cx--)
                *pulTmp++ ^= iColor;
        }

    // Lay down the right edge, if needed.

        if (iRght != 0)
        {
            ulMskRght &= iColor;

            pulDst[cRght] ^= ulMskRght;
        }
    }
}



/******************************Public*Routine******************************\
* vSolidXorRow24
*
* Does a solid blt with a list of adjacent rows to a 24 bpp DIB.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidXorRow24(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    BYTE  jRed, jGreen, jBlue;

    jRed   = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue  = (BYTE) (iColor >> 16);
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        LONG   cx        = (prow->right - prow->left) << cShift;
        ULONG  xDstStart = prow->left << cShift;
        BYTE*  pjDst     = pjBits + (3 * xDstStart);

        ULONG cxTemp = cx;

        while(cxTemp--)
        {
            *(pjDst++) ^= jRed;
            *(pjDst++) ^= jGreen;
            *(pjDst++) ^= jBlue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\solline.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*   solline.cxx
*
* Abstract
*
*   This module draws solid color, single pixel wide, non-styled, trivial or
*   rectangularly clipped lines to a DIB.
*
* Author:
*
*   Mark Enstrom    (marke) 12-1-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

#define DBG_LINE 0


#if DBG_LINE
    ULONG   DbgLine = 0;
#endif

//
// horizontal line accelerators
//

PFN_HORZ   gapfnHorizontal[6] =
    {
        vHorizontalLine1,vHorizontalLine4,vHorizontalLine8,
        vHorizontalLine16,vHorizontalLine24,vHorizontalLine32
    };


//
// line DDA routines for each DIB format
//

PFN_OCTANT gapfnOctant[6][8] =
    {
        {
            vLine1Octant07,vLine1Octant16,vLine1Octant07,vLine1Octant16,
            vLine1Octant34,vLine1Octant25,vLine1Octant34,vLine1Octant25
        },
        {
            vLine4Octant07,vLine4Octant16,vLine4Octant07,vLine4Octant16,
            vLine4Octant34,vLine4Octant25,vLine4Octant34,vLine4Octant25
        },
        {
            vLine8Octant07,vLine8Octant16,vLine8Octant07,vLine8Octant16,
            vLine8Octant34,vLine8Octant25,vLine8Octant34,vLine8Octant25
        },
        {
            vLine16Octant07,vLine16Octant16,vLine16Octant07,vLine16Octant16,
            vLine16Octant34,vLine16Octant25,vLine16Octant34,vLine16Octant25
        },
        {
            vLine24Octant07,vLine24Octant16,vLine24Octant07,vLine24Octant16,
            vLine24Octant34,vLine24Octant25,vLine24Octant34,vLine24Octant25
        },
        {
            vLine32Octant07,vLine32Octant16,vLine32Octant07,vLine32Octant16,
            vLine32Octant34,vLine32Octant25,vLine32Octant34,vLine32Octant25
        }

    };

//
// mask for 4bpp pixels
//

UCHAR PixelLineMask4[2] = {0x0f,0xf0};


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSolidLine
*
* Routine Description:
*
*   Extract line end points from path object and call lower lever drawing
*   routine
*
* Arguments:
*
*   pso             - destination surface object
*   ppo             - path object
*   pptfx           - line coordinates if 'ppo' is NULL
*   pco             - clip object
*   iSolidColor     - solid color to draw
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
vSolidLine (
    SURFACE *pSurf,
    PATHOBJ *ppo,
    POINTFIX*pptfx,
    CLIPOBJ *pco,
    ULONG   iSolidColor
)
{

    PATHDATA    pd;
    BOOL        bMore;
    ULONG       cptfx;
    POINTFIX    ptfxStartFigure;
    POINTFIX    ptfxLast;
    POINTFIX*   pptfxFirst;
    POINTFIX*   pptfxBuf;
    ULONG       ulFormat;
    LONG        lDelta;
    PBYTE       pjDst;
    RECTL       arclClip[4];
    PRECTL      prclClip = (PRECTL) NULL;

    //
    // check out params
    //

    ASSERTGDI((pco == NULL) || (pco->iDComplexity != DC_COMPLEX),
              "Routine does not handle complex clipping");

    ulFormat       = pSurf->iFormat();
    lDelta         = pSurf->lDelta();
    pjDst          = (PUCHAR)(pSurf->pvScan0());

    //
    // determine format and routines
    //

    switch (ulFormat)
    {
    case BMF_1BPP:
        iSolidColor = iSolidColor ? 0xffffffff : 0x00000000;
        break;

        //
        // rest fall through
        //

    case BMF_4BPP:
        iSolidColor |= (iSolidColor << 4);
    case BMF_8BPP:
        iSolidColor |= (iSolidColor << 8);
    case BMF_16BPP:
        iSolidColor |= (iSolidColor << 16);
    case BMF_24BPP:
    case BMF_32BPP:
    break;
    default:
        RIP("Invalid bitmap format");
    }

    //
    //  get clipping rectangle if needed, copy the rectangle into several
    //  formats for use by the GIQ clipping routine
    //

    if ((pco != NULL) && (pco->iDComplexity == DC_RECT))
    {
        //
        // assign temp rectangles to clipping bounds
        //

        arclClip[0]        =  pco->rclBounds;

        #if DBG_LINE
            if (DbgLine >= 2) {
                DbgPrint("Clipping rect = %li,%li to %li,%li\n",
                            arclClip[0].left,
                            arclClip[0].top,
                            arclClip[0].right,
                            arclClip[0].bottom);
            }
        #endif

        //
        // generate clipping rect variants for use in
        // GIQ line routines
        //

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[3].top    =  pco->rclBounds.left;

        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[3].right  = arclClip[2].bottom;

        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[2].right  =  pco->rclBounds.right;
        arclClip[3].bottom =  pco->rclBounds.right;

        arclClip[1].right  =  pco->rclBounds.bottom;
        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[3].left   = arclClip[2].top;

        prclClip = arclClip;

    }

    //
    // subtract 1 from ulFormat to use as array index
    //

    ulFormat --;

    //
    // if the path pointer 'ppo' is NULL, then we must use the vertice
    // pointer 'pptfx':
    //

    if (ppo == NULL)
    {
        vDrawLine(pptfx,pptfx + 1,pjDst,lDelta,iSolidColor,prclClip,ulFormat);
    }
    else
        {
        //
        // Enumerate the paths and send line segments to
        // vDrawLine
        //
        //
        // start enumeration of lines
        //

        pd.flags = 0;

        ((EPATHOBJ*) ppo)->vEnumStart();

        //
        // enumerate each set
        //

        do
        {
            bMore = ((EPATHOBJ*) ppo)->bEnum(&pd);

            cptfx = pd.count;

            //
            // Should not get to here with empty path
            //

            if (cptfx == 0)
            {
                ASSERTGDI(!bMore, "Empty path record in non-empty path");
                break;
            }

            //
            // if BEGINSUBPATH, save the starting point for the
            // figure
            //

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;

            } else {

                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;

            }


            //
            // draw line segments
            //

            if (cptfx > 0)
            {
                //
                // draw line segment
                //

                while (cptfx --) {

                    vDrawLine(pptfxFirst,pptfxBuf,pjDst,lDelta,iSolidColor,prclClip,ulFormat);

                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;

                }

            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {

                //
                // draw closure line segment
                //

                vDrawLine(&ptfxLast,&ptfxStartFigure,pjDst,lDelta,iSolidColor,prclClip,ulFormat);

            }

        } while (bMore);
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDrawLine
*
* Routine Description:
*
*   This routine is passed end points of a line segment, either integer or
*   GIQ. The DDA equation for the line is determined then specific routines
*   are called to run the line DDA and draw the pixels for each bitmap format
*
*
* Arguments:
*
*   pptfx0          - end point 0
*   pptfx1          - end point 1
*   pjDst           - pointer to dst
*   lDelta          - byte scan line increment for dst
*   iSolidColor     - draw color expnaded to 32 bits
*   prclClip        - clip rectangles
*   FormatIndex     - look up for dst bitmap format
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
vDrawLine (
    POINTFIX    *pptfx0,
    POINTFIX    *pptfx1,
    PUCHAR      pjDst,
    LONG        lDelta,
    ULONG       iSolidColor,
    PRECTL      prclClip,
    ULONG       FormatIndex
)
{
    LONG        x0;
    LONG        y0;
    LONG        x1;
    LONG        y1;
    LONG        dx;
    LONG        dy;
    ULONG       ulTmp;
    PFN_OCTANT  pfnOctant;
    LONG        DeltaDst = lDelta;
    DDALINE     DDALine;
    LONG        Reduce;

    DDALine.ulFlags = 0;

    //
    // check for GIQ lines
    //

    ulTmp = (   (ULONG)pptfx0->x |
                (ULONG)pptfx0->y |
                (ULONG)pptfx1->x |
                (ULONG)pptfx1->y
            ) & 0x0F;


    //
    // check for integer lines
    //

    if (ulTmp == 0)
    {

        //
        // check for no clipping rectangle or trivial
        // accept/reject of each line with the clipping
        // rectangle
        //

        x0 = pptfx0->x >> 4;
        y0 = pptfx0->y >> 4;
        x1 = pptfx1->x >> 4;
        y1 = pptfx1->y >> 4;
        DDALine.ptlStart.x = x0;
        DDALine.ptlStart.y = y0;

        //
        // order x0,x1 and y0,y1 for clip check and slope calculation
        //

        if (x1  < x0) {
            ULONG   Tmp = x1;
            x1 = x0;
            x0 = Tmp;
            DDALine.ulFlags |= FL_SOL_FLIP_H;
        }

        if (y1  < y0) {
            ULONG   Tmp = y1;
            y1 = y0;
            y0 = Tmp;
            DDALine.ulFlags |= FL_SOL_FLIP_V;
        }

        if (prclClip != (PRECTL) NULL)
        {

            //
            // check for a line totally outside clip rect
            //

            if  (
                 (x1 <  prclClip->left)  ||
                 (x0 >= prclClip->right) ||
                 (y1 <  prclClip->top)   ||
                 (y0 >= prclClip->bottom)
                )
            {
                //
                // line is totally clipped out
                //

                #if DBG_LINE
                    if (DbgLine >= 1) {
                        DbgPrint("Trivial reject line %li,%li to %li,%li\n",x0,y0,x1,y1);
                        DbgPrint("Clipping rect:      %li,%li to %li,%li\n",
                            prclClip->left,
                            prclClip->top,
                            prclClip->right,
                            prclClip->bottom);
                    }
                #endif

                return;

            }

            //
            // check for line that is not totally inside clip rect,
            // if not then call GIQ routine which has rectangular
            // clipping.
            //

            if
              (
               (x0 <  prclClip->left)  ||
               (x1 >= prclClip->right) ||
               (y0 <  prclClip->top)   ||
               (y1 >= prclClip->bottom)
              )
            {
                goto calc_GIQ_line;
            }

        }

        //
        // transform line to the first octant and calculate
        // terms and flags
        //

        //
        // find out if line is x major or y major
        //

        dx = x1 - x0;
        dy = y1 - y0;

        //
        // check for x-major or y-major lines
        //

        if (dx >= dy) {

            //
            // check for horizontal line
            //

            if (dy == 0)
            {

                PFN_HORZ pfnHorz = gapfnHorizontal[FormatIndex];
                pjDst = pjDst + (DDALine.ptlStart.y * lDelta);

                //
                // must check to see if end points have been
                // swapped due to exclusive line drawing
                //

                if (DDALine.ulFlags & FL_SOL_FLIP_H)
                {
                   x0++;
                   x1++;
                }

                (*pfnHorz)(pjDst,x0,x1,iSolidColor);
                return;
            }

            //
            // check for zero length
            //

            if (dx == 0) {
                return;
            }

            Reduce = -1;

            //
            // x major line
            //

            DDALine.dMajor = dx;
            DDALine.dMinor = dy;

            //
            // see if y has been flipped
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_V)
            {
                DeltaDst = -DeltaDst;
                Reduce   = 0;
            }

            //
            //  Bresenham term except lErrorTerm is normally dy - dx/2 or
            //  2x which is 2*dy - dx. In this case the 2*2y is not added to
            //  the error term until the start of the inner loop routine so that
            //  the x86 can immediately use the flag register to determine the sign
            //  of the error term after the addition of 2*dy.
            //

            DDALine.cPels      = DDALine.dMajor;
            DDALine.lErrorTerm = -DDALine.dMajor;
            DDALine.dMajor     = 2 * DDALine.dMajor;
            DDALine.dMinor     = 2 * DDALine.dMinor;

            //
            // if FL_SOL_FLIP_V then lError term must be reduced by one to
            // compensate for the rounding convention
            //

            DDALine.lErrorTerm += Reduce;

        } else {

            //
            // check for 0 length
            //

            if (dy == 0) {
                return;
            }

            Reduce = -1;

            //
            // y major line, swap the meaning of dMajor and dMinor
            //

            DDALine.dMajor = dy;
            DDALine.dMinor = dx;

            DDALine.ulFlags |= FL_SOL_FLIP_D;

            DDALine.xInc = 1;

            //
            // check for flipped x
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_H) {

                //
                // compensate for negative x in y major line
                //

                Reduce = 0;
            }

            //
            // + or - y
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_V) {
                DeltaDst = -DeltaDst;
            }

            //
            //  Bresenham term except lErrorTerm is normally dy - dx/2 or
            //  2x which is 2*dy - dx. In this case the 2*2y is not added to
            //  the error term until the start of the inner loop routine so that
            //  the x86 can immediately use the flag register to determine the sign
            //  of the error term after the addition of 2*dy.
            //

            DDALine.cPels      = DDALine.dMajor;
            DDALine.lErrorTerm = -DDALine.dMajor;
            DDALine.dMajor     =   2 * DDALine.dMajor;
            DDALine.dMinor     =   2 * DDALine.dMinor;

            //
            // if FL_SOL_FLIP_H then lError term must be reduced by one to
            // compensate for the rounding convention
            //

            DDALine.lErrorTerm += Reduce;

        }

        #if DBG_LINE

            if (DbgLine >= 2) {
                DbgPrint("Integer line:\n");
                DbgPrint("x0 = %li, y0 = %li\n",x0,y0);
                DbgPrint("Error term  = %li\n",DDALine.lErrorTerm);
                DbgPrint("dMajor      = %li\n",DDALine.dMajor);
                DbgPrint("dMinor      = %li\n",DDALine.dMinor);
                DbgPrint("Pixel Count = %li\n",DDALine.cPels);
                DbgPrint("ulFlags     = 0x%08lx\n\n",DDALine.ulFlags);
            }

        #endif

    } else {

        calc_GIQ_line:

        //
        // caclulate GIQ parameters
        //


        if (!bGIQtoIntegerLine(pptfx0,pptfx1,prclClip,&DDALine)) {
            return;
        }

        //
        // check for 0 length
        //

        if (DDALine.cPels <= 0) {
            return;
        }

        if (DDALine.ulFlags & FL_SOL_FLIP_V)
        {
            DeltaDst = -DeltaDst;
        }

        #if DBG_LINE
            if (DbgLine >= 2) {
                DbgPrint("GIQ line:\n");
                DbgPrint("x0          = %li\n",DDALine.ptlStart.x);
                DbgPrint("y0          = %li\n",DDALine.ptlStart.y);
                DbgPrint("Error term  = %li\n",DDALine.lErrorTerm);
                DbgPrint("dMajor      = %li\n",DDALine.dMajor);
                DbgPrint("dMinor      = %li\n",DDALine.dMinor);
                DbgPrint("Pixel Count = %li\n",DDALine.cPels);
                DbgPrint("DeltaDst    = %li\n",DeltaDst);
                DbgPrint("xInc        = %li\n",DDALine.xInc);
                DbgPrint("ulFlags     = 0x%08lx\n\n",DDALine.ulFlags);
            }
        #endif
    }

    //
    // select drawing routine based on format and octant
    //

    pfnOctant = gapfnOctant[FormatIndex][DDALine.ulFlags & 0x07];

    pjDst = pjDst + (DDALine.ptlStart.y * lDelta);

    (*pfnOctant)(&DDALine,pjDst,DeltaDst,iSolidColor);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 8bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vLine8Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        if (--PixelCount == 0) {
            return;
        }

        pjDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;
        }

    }

}

VOID
vLine8Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += pDDALine->ptlStart.x;


    //
    // integer line
    //

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        if (--PixelCount == 0) {
            return;
        }

        pjDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }
}


VOID
vLine8Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive/negative
    //  y - positive
    //

    pjDst += pDDALine->ptlStart.x;


    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst     ++;
        }
    }
}

VOID
vLine8Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - positive/negative
    //  y - negative
    //

    pjDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst     --;
        }
    }
}
#endif

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 16 bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine16Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);

        }
    }
}


VOID
vLine16Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);

        }
    }
}


VOID
vLine16Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pusDst    ++;
        }
    }
}

VOID
vLine16Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - negative
    //  y - positive/ negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pusDst    --;
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 24bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine24Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += (3 * pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += 3;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
    }
}


VOID
vLine24Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += (3 * pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst -= 3;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
    }
}


VOID
vLine24Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 1,2
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += (3*pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst+=3;
        }
    }
}

VOID
vLine24Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += (3*pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst-=3;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 32 bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine32Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);

        }
    }
}


VOID
vLine32Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);

        }
    }
}


VOID
vLine32Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive/negative
    //  y - positive
    //

    pulDst += pDDALine->ptlStart.x;


    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pulDst++;
        }

        *pulDst = iSolidColor;
    }
}

VOID
vLine32Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - positive/negative
    //  y - negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pulDst--;
        }

        *pulDst = iSolidColor;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 1bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vLine1Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask >> 1);

            if (!(Mask)) {
                Mask = 0x80;
                pjDst++;
            }


            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst += lDeltaDst;

            }
        }

    } else {

        //
        // loop for storing '0' pixels
        //

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask >> 1);

            if (!(Mask)) {
                Mask = 0x80;
                pjDst++;
            }


            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }
    }

}

VOID
vLine1Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 3,4
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask << 1);

            if (!(Mask)) {
                Mask = 0x01;
                pjDst--;
            }

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask << 1);

            if (!(Mask)) {
                Mask = 0x01;
                pjDst--;
            }

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }
    }
}

VOID
vLine1Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 1,6
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask >> 1);

                if (!(Mask)) {
                    Mask = 0x80;
                    pjDst++;
                }

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask >> 1);

                if (!(Mask)) {
                    Mask = 0x80;
                    pjDst++;
                }

            }
        }
    }

}

VOID
vLine1Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;

    //
    //  octant 2,5
    //
    //  y major
    //
    //  x - negative
    //  y - negative/positive
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask << 1);

                if (!(Mask)) {
                    Mask = 0x01;
                    pjDst--;
                }

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask << 1);

                if (!(Mask)) {
                    Mask = 0x01;
                    pjDst--;
                }

            }
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 4bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vLine4Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;
    PUCHAR  PixelAddr;


    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);

        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        Pixel++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }
}


VOID
vLine4Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);

        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        Pixel--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }

}


VOID
vLine4Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 1,6
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);
        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            Pixel     ++;
        }
    }
}

VOID
vLine4Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 2,5
    //
    //  y major
    //
    //  x - negative
    //  y - psoitive\negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);
        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            Pixel     --;
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vHorizontalLineN
*
* Routine Description:
*
*   Accelerator for horizontal lines
*
* Arguments:
*
*   pjDst       - Scan line dst address
*   x0          - Starting pixel location
*   x1          - Ending pixel location (exclusive)
*   iSolidColor - Solid Color replicated to 32 bits if needed
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vHorizontalLine1(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG  Count;
    ULONG  Alignment;

    //
    // count = number of pixels to write, make sure it is not 0
    //

    Count = x1 - x0;

    if (Count) {

        pjDst += (x0 >> 3);

        Alignment = x0 & 0x07;

        //
        // alignment Start bits
        //

        if ((Alignment) && ((ULONG)Count >= (8 - Alignment)))
        {
            //
            // partial byte
            //

            *pjDst = (UCHAR)((*pjDst & (~(0xFF >> Alignment))) |
                             (iSolidColor & (0xFF >> Alignment)));

            pjDst ++;
            Count -= ( 8 - Alignment);
            Alignment = 0;

        }

        //
        // byte loop
        //

        if (Alignment == 0) {

            //
            // full byte stores
            //

            ULONG   NumBytes = Count >> 3;

            if (NumBytes > 0) {
                RtlFillMemory((PVOID)pjDst,NumBytes,(UCHAR)iSolidColor);
                pjDst += NumBytes;
                Count = (Count & 0x07);
            }

            //
            // last store
            //

            if (Count > 0) {
                *pjDst = (UCHAR)((*pjDst & (0xFF >> Count)) |
                                 (iSolidColor & (~(0xFF >> Count))));
            }

            return;
        }

        //
        // do whats left, partial of 1 byte with
        // start bit = alignment, number of bits = Count
        //
        //
        //   bit
        //  
        //  76543210
        //  
        //
        //   pixel
        //  
        //  01234567
        //  

        {
            UCHAR DstMask = (UCHAR)(0xff >> Alignment);
            UCHAR AndMask = (UCHAR)(0xff << (8 - (Count + Alignment)));

            DstMask &= AndMask;

            *pjDst = (UCHAR)((*pjDst & (~DstMask)) | (iSolidColor & DstMask));

        }
    }

}

VOID
vHorizontalLine4(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG  Count;
    ULONG  Alignment;
    ULONG  NumBytes;


    Count = x1 - x0;

    if (Count) {

        pjDst += (x0 >> 1);

        //
        // alignment Start nibble
        //

        Alignment = x0 & 0x01;

        if (Alignment)
        {
            *pjDst = (UCHAR)((*pjDst      & 0xf0) |
                             (iSolidColor & 0x0f));
            Count--;
            pjDst++;
        }

        //
        // aligned to byte boundary
        //

        NumBytes = Count >> 1;

        if (NumBytes) {

            RtlFillMemory((PVOID)pjDst,NumBytes,(BYTE)iSolidColor);

            pjDst += NumBytes;
            Count = Count & 0x01;
        }

        //
        // end alignment if needed
        //

        if (Count) {
            *pjDst = (UCHAR)((*pjDst      & 0x0f) |
                             (iSolidColor & 0xf0));
        }

    }
}

VOID
vHorizontalLine8(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG   Count;
    UCHAR   Align;

    //
    // increment pjDst to x0 address
    //

    pjDst += x0;

    //
    // if byte count is less then 7, then just quickly do
    // the bytes
    //

    Count = x1 - x0;

    if (Count <= 6) {

        while (Count--) {
            *pjDst++ = (UCHAR)iSolidColor;
        }

        return;
    }

    //
    // large scan line that at least covers 1 full DWORD,
    // first do partial bytes if needed
    //

    //
    // do partial bytes, count is gaurenteed to be
    // greater than max of 3 alignment bytes
    //

    Align = (UCHAR)(x0 & 0x03);

    switch (Align) {
    case 1:
        *pjDst++ = (UCHAR)iSolidColor;
        Count--;
    case 2:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        pjDst += 2;
        Count -= 2;
        break;
    case 3:
        *pjDst++ = (UCHAR)iSolidColor;
        Count--;
    }

    ULONG NumBytes = Count & (~0x03);

    //
    // fill Dwords
    //

    RtlFillMemoryUlong((PVOID)pjDst,NumBytes,iSolidColor);
    pjDst += NumBytes;

    //
    // fill last partial bytes
    //

    switch (Count & 0x03)  {
    case 1:
        *pjDst = (UCHAR)iSolidColor;
        break;
    case 2:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        break;
    case 3:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        *(pjDst+2) = (UCHAR)iSolidColor;
    }

}

VOID
vHorizontalLine16(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    PUSHORT pusDst = (PUSHORT)pjDst + x0;
    ULONG   Count = x1 - x0;

    if (Count) {

        //
        // do starting alignment
        //

        if (x0 & 0x01) {
            *pusDst++ = (USHORT)iSolidColor;
            Count--;
        }

        //
        // fill dwords
        //

        ULONG NumDwords = Count >> 1;

        if (NumDwords) {
            RtlFillMemoryUlong((PVOID)pusDst,NumDwords << 2,iSolidColor);
        }

        //
        // fill last 16 if needed
        //

        if (Count & 0x01) {

            //
            //  add Number of USHORTS stored in RtlFillMemoryUlong to pusDst
            //  then store final USHORT
            //

            pusDst += NumDwords << 1;

            *pusDst = (USHORT)iSolidColor;
        }
    }
}

VOID
vHorizontalLine24(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    UCHAR   Red   = (UCHAR)iSolidColor;
    UCHAR   Green = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue  = (UCHAR)(iSolidColor >> 16);
    PUCHAR  pjEnd = pjDst + 3*x1;

    pjDst += 3*x0;

    while (pjDst < pjEnd) {
        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
        pjDst += 3;
    }
}

VOID
vHorizontalLine32(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{

    //
    // incremnet pjDst x0 DWORDs
    //

    pjDst += (x0 << 2);

    //
    // fill
    //

    if (x1 != x0) {
        RtlFillMemoryUlong((PVOID)pjDst,(x1 - x0) << 2,iSolidColor);
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   bGIQtoIntegerLine
*
* Routine Description:
*
*   This routine takes GIQ endpoints and calculates the correct integer
*   endpoints, error term and flags.
*
* Arguments:
*
*   pptfxStart  -   GIQ point 0
*   pptfxEnd    -   GIQ point 1
*   prclClip    -   clip rectangles
*   pDDALine    -   Interger line params
*
* Return Value:
*
*   True if this line can be drawn with 32 bit arithmatic and
*   all params are calculated, otherwise false
*
\**************************************************************************/

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

BOOL bGIQtoIntegerLine(
    POINTFIX* pptfxStart,
    POINTFIX* pptfxEnd,
    PRECTL    prclClip,
    DDALINE*  pDDALine)

{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start Pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start Pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end Pixel (inclusive)
    LONG  lGamma; // Possibly overflowing Bresenham error term at origin
    LONGLONG eqGamma;// Non-overflowing Bresenham error term at origin
    BOOL  bReturn = FALSE;


/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/


    #if DBG_LINE

        if (DbgLine >= 2) {
            DbgPrint("\nCalculate GIQ parameters for line:\n");
            DbgPrint("pptfxStart    = %li.%li, %li.%li\n",
                            pptfxStart->x >> 4,
                            pptfxStart->x & 0x0f,
                            pptfxStart->y >> 4,
                            pptfxStart->y & 0x0f);

            DbgPrint("pptxEnd      = %li.%li, %li.%li\n\n",
                            pptfxEnd->x >> 4,
                            pptfxEnd->x & 0x0f,
                            pptfxEnd->y >> 4,
                            pptfxEnd->y & 0x0f);
        }

    #endif

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
        //
        // Line runs from right to left, so flip across x = 0:
        //

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= FL_SOL_FLIP_H;
    }

    //
    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but the engine never actually
    // checks its transforms.  Check for that case and simply refuse to draw
    // the line:
    //

    dM -= M0;
    if ((LONG) dM < 0)
    {
        goto GIQEnd;
    }

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {

        //
        // Line runs from bottom to top, so flip across y = 0
        //

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= FL_SOL_FLIP_V;
    }

    //
    // Compute the delta dy
    //

    dN -= N0;
    if ((LONG) dN < 0)
    {
        goto GIQEnd;
    }

    //
    // check for y-major lines and lines with
    // slope = 1
    //

    if (dN >= dM)
    {
        if (dN == dM)
        {

            //
            // Have to special case slopes of one:
            //

            fl |= FL_SOL_FLIP_SLOPE_ONE;
        }
        else
        {
            //
            // Since line has slope greater than 1, flip across x = y:
            //

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= FL_SOL_FLIP_D;
        }
    }

    //
    //  look up rounding for this line from the table
    //

    fl |= gaflHardwareRound[fl];

    //
    //  Calculate the error term at Pixel 0
    //

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);


    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

    #if DBG_LINE

        if (DbgLine >= 2) {
            DbgPrint("Calc x  = %li\n",x);
            DbgPrint("Calc y  = %li\n",y);
            DbgPrint("Calc M0 = %li\n",M0);
            DbgPrint("Calc N0 = %li\n",N0);
        }

    #endif

    //
    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
    // that M0 and N0 have at most 4 bits of significance (and if the
    // arguments are properly ordered, on a 486 each multiply would be no
    // more than 13 cycles):
    //

    //
    // For the sake of speed, we're only going to do 32-bit multiplies
    // in this routine.  If the line is long enough though, we may
    // need 38 bits for this calculation.  Since at this point
    // dM >= dN >= 0, and 0 <= N0 < 16, we'll just need to have 6 bits
    // unused in 'dM':
    //

    if (dM <= (LONG_MAX >> 6))
    {
        lGamma = (N0 + F/2) * dM - M0 * dN;

        if (fl & HW_Y_ROUND_DOWN)
            lGamma--;

        lGamma >>= FLOG2;

        eqGamma = lGamma;
    }
    else
    {
        LONGLONG eq;

        //
        // Ugh, use safe 64-bit multiply code (cut and pasted from
        // 'engline.cxx'):
        //

        eqGamma = Int32x32To64(N0 + F/2, dM);
        eq      = Int32x32To64(M0, dN);

        eqGamma -= eq;

        if (fl & FL_V_ROUND_DOWN)
            eqGamma -= 1;              // Adjust so y = 1/2 rounds down

        eqGamma >>= FLOG2;
    }

    //
    //  Figure out which Pixels are at the ends of the line.
    //

    //
    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'
    // when an x value of 1/2 is supposed to round up in value.
    //
    //
    // Calculate x0, x1:
    //

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

    //
    // Line runs left-to-right
    //
    //
    // Compute x1
    //

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (FL_SOL_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (FL_SOL_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {

        //
        // Have to special-case diagonal lines going through our
        // the point exactly equidistant between two horizontal
        // Pixels, if we're supposed to round x=1/2 down:
        //

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

    //
    // Compute x0:
    //

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:


    //**********************************************************************
    // Calculate the start Pixel.
    //***********************************************************************

    //
    // We now compute y0 and adjust the error term.  We know x0, and we know
    // the current formula for the Pixels to be lit on the line:
    //
    //                     dN * x + eqGamma
    //       y(x) = floor( ---------------- )
    //                           dM
    //
    // The remainder of this expression is the new error term at (x0, y0).
    // Since x0 is going to be either 0 or 1, we don't actually have to do a
    // multiply or divide to compute y0.  Finally, we subtract dM from the
    // new error term so that it is in the range [-dM, 0).
    //

    y0 = 0;

    if ((eqGamma >= 0) &&
        (eqGamma >= (dM - (dN & (-(LONG) x0)))))
    {
        y0 = 1;
    }

    //
    // check to see if the line is NULL, this should only happen
    // with a line of slope = 1.
    //

    if (x1 < x0) {
        pDDALine->cPels = 0;
        bReturn = TRUE;
        goto GIQEnd;
    }


    //*******************************************************************
    //
    // Must perform rectangular clipping
    //
    //*******************************************************************

    if (prclClip != (PRECTL) NULL)
    {
        ULONG y1;
        LONG  xRight;
        LONG  xLeft;
        LONG  yBottom;
        LONG  yTop;
        LONGLONG euq;
        LONGLONG eq;
        LONGLONG eqBeta;
        RECTL rclClip;

        //
        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.
        //

        RECTL* prcl = &prclClip[(fl & FL_SOL_RECTLCLIP_MASK)];

        //
        // take flip_h into account
        //

        if (fl & FL_SOL_FLIP_H) {

            if (fl & FL_SOL_FLIP_D) {

                rclClip.top    = -prcl->bottom + 1;
                rclClip.bottom = -prcl->top    + 1;
                rclClip.left   = prcl->left;
                rclClip.right  = prcl->right;

            } else {

                rclClip.left   = -prcl->right + 1;
                rclClip.right  = -prcl->left  + 1;
                rclClip.top    = prcl->top;
                rclClip.bottom = prcl->bottom;

            }

        } else {

            rclClip.left   = prcl->left;
            rclClip.right  = prcl->right;
            rclClip.top    = prcl->top;
            rclClip.bottom = prcl->bottom;

        }

        //
        // Normalize to the same point we've normalized for the DDA
        // calculations:
        //

        xRight  = rclClip.right  - x;
        xLeft   = rclClip.left   - x;
        yBottom = rclClip.bottom - y;
        yTop    = rclClip.top    - y;

        #if DBG_LINE

            if (DbgLine >= 2) {

                DbgPrint("Clipping line to rect %li,%li to %li,%li\n",
                                rclClip.left,
                                rclClip.top,
                                rclClip.right,
                                rclClip.bottom);

                DbgPrint("Clipping Parameters:  xLeft %li xRight %li yBottom %li yTop %li\n",
                                xLeft,
                                xRight,
                                yBottom,
                                yTop);


                DbgPrint("normalized line before clip,  x = %li, y = %li, x0 = %li, x1 = %li,  y0 = %li\n",
                                x,y,x0,x1,y0);

                DbgPrint("Line Params:  dM = %li,   dN = %li,   eqGamma = %lx\n",dM,dN,(ULONG)eqGamma);
            }

        #endif

        if (yBottom <= (LONG) y0 ||
            xRight  <= (LONG) x0 ||
            xLeft   >  (LONG) x1)
        {
            Totally_Clipped:

            #if DBG_LINE

                if (DbgLine >= 2) {
                    DbgPrint("Line is totally clipped\n");
                }

            #endif

            pDDALine->cPels = 0;
            bReturn = TRUE;
            goto GIQEnd;
        }

        if ((LONG) x1 >= xRight)
        {
            x1 = xRight - 1;

            #if DBG_LINE

                if (DbgLine >= 2) {
                    DbgPrint("Line clip x1 to %li\n",x1);
                }

            #endif
        }

        //
        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).
        //

        eqBeta = ~eqGamma;
        euq = Int32x32To64(x1, dN);
        euq += eqGamma;

        y1 = DIV(euq, dM);

        #if DBG_LINE

            if (DbgLine >= 2) {

                DbgPrint("Clipping: calculated y1 = %li   eqBeta = 0x%lx 0x%lx\n",y1,(LONG)(eqBeta>>32),(ULONG)eqBeta);

            }

        #endif

        //
        // check for y1 less than the top of the clip rect
        //

        if (yTop > (LONG) y1)
            goto Totally_Clipped;

        //
        // check for y1 > the bottom of the clip rect, clip if true
        //

        if (yBottom <= (LONG) y1)
        {
            y1 = yBottom;

            euq = Int32x32To64(y1, dM);
            euq += eqBeta;
            x1 = DIV(euq,dN);

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped y1 to %li, x1 = %li\n",y1,x1);

                }

            #endif
        }

        //
        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:
        //

        if (xLeft > (LONG) x0)
        {
            x0 = xLeft;

            euq = Int32x32To64(x0, dN);
            euq += eqGamma;
            y0 = DIV(euq, dM);

            if (yBottom <= (LONG) y0)
                goto Totally_Clipped;

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped x0 to %li, y0 = %li\n",x0,y0);

                }

            #endif

        }

        //
        // check for y0 less than the top of the clip rect, clip if true
        //

        if (yTop > (LONG) y0)
        {
            y0 = yTop;

            euq = Int32x32To64(y0, dM);
            euq += eqBeta;
            x0 = DIV(euq, dN) + 1;

            if (xRight <= (LONG) x0)
                goto Totally_Clipped;

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped y0 to %li, x0 = %li\n",y0,x0);

                }

            #endif
        }

        euq = Int32x32To64(x0,dN);
        eq  = Int32x32To64(y0,dM);

        euq -= eq;

        eqGamma += euq;

        eqGamma -= dM;

        #if DBG_LINE

            if (DbgLine >= 2) {
                DbgPrint("Clipped  line: x0 = %li,  x1 = %li,  y0 = %li, y1 = %li\n",
                                x0,
                                x1,
                                y0,
                                y1);

                DbgPrint("eqGamma = %lx\n",eqGamma);
            }

            if (x0 > x1) {
                DbgPrint("Clip Error: x0 > x1\n");

                DbgPrint(" pptxStart    = %li.%li, %li.%li\n",
                                pptfxStart->x >> 4,
                                pptfxStart->x & 0x0f,
                                pptfxStart->y >> 4,
                                pptfxStart->y & 0x0f);

                DbgPrint(" pptxEnd      = %li.%li, %li.%li\n",
                                pptfxEnd->x >> 4,
                                pptfxEnd->x & 0x0f,
                                pptfxEnd->y >> 4,
                                pptfxEnd->y & 0x0f);


                DbgPrint("  prclClip = 0x%lx\n",prclClip);

                DbgPrint("  x0    = %li\n",x0);
                DbgPrint("  y0    = %li\n",y0);
                DbgPrint("  x1    = %li\n",x1);
                DbgPrint("  y1    = %li\n",y1);

                DbgPrint("  dM    = %li\n",dM);
                DbgPrint("  dN    = %li\n",dN);

                DbgPrint("  lGamma = %li\n",lGamma);

                DbgPrint("  Clipping line to rect %li,%li to %li,%li\n",
                                rclClip.left,
                                rclClip.top,
                                rclClip.right,
                                rclClip.bottom);

            }



        #endif



        ASSERTGDI(x0 <= x1, "Improper rectangle clip");

    } else {

        //
        // adjust lGamma
        //

        eqGamma += (dN & (-x0));
        eqGamma -= dM;

        if (eqGamma >= 0)
        {
            eqGamma -= dM;
        }
    }


    //
    // END of simple clipping
    //

    //
    // Undo our flips to get the start coordinate:
    //

    x += x0;
    y += y0;

    if (fl & FL_SOL_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & FL_SOL_FLIP_V)
    {
        y = -y;
    }

    if (fl & FL_SOL_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    //
    // check values
    //

    pDDALine->ulFlags    = fl;
    pDDALine->ptlStart.x = x;
    pDDALine->ptlStart.y = y;
    pDDALine->cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    pDDALine->dMajor     = dM;
    pDDALine->dMinor     = dN;
    pDDALine->lErrorTerm = (LONG) eqGamma;
    pDDALine->xInc       = 1;
    bReturn = TRUE;

    //
    // end routine
    //

GIQEnd:

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\rle8blt.cxx ===
/******************************Module*Header*******************************\
* Module Name: rleblt8.cxx
*
* This contains the bitmap simulation functions that blt from an 8 bit
* Run-Length Encoded (RLE) source to a DIB surface.  The DIB surface can be
* 1, 4, 8, 16, 24, or 32 bits/pel.
*
* The code is based on functions found in 'srcblt8.cxx', version 23,
* although now bears no resembalence to them at all.
*
* Notes:
*
*   1)  These functions return a BOOL value.  This value is TRUE if the
*       function ends before running out of data in the source RLE or before
*   hitting an End-of-Bitmap code.  Otherwise, we return FALSE.  This return
*   value is used by <EngCopyBits> in the complex clipping case to decide
*   if the blt is complete.
*
*   2)  Before exiting a function with a TRUE value, position information is
*       saved by the macro <RLE_SavePosition>.  This is used by <EngCopyBits>
*   to speed up the complex clipping case.
*
*   3)  The below functions use about twenty different macros.  This is
*       because they are all using the same basic algorithm to play an RLE
*   compression. The macros allow us to focus in on the nifty stuff of writing
*   the bytes out to the DIB.  Routine administrivia is handled by the macros.
*
*   The macros themselves are used to manage
*
*          - Source Access and data alignment
*          - Visability Checking
*          - Clipping
*          - Output position changes with Newline & Delta codes
*
*   The macro <RLE_InitVars> is used to define the varibles that relate to
*   the above information, and to define variables common to all RLE 4
*   blt functions.  Note that actual names of the common variables are passed
*   in as parameters to the macro.  Why?  Two reasons.  Firstly, they are
*   initialized by values taken of the BLTINFO structure passed into the blt
*   function.  Secondly, showing the variable names in the macro 'call' means
*   they don't just appear from nowhere into the function.  RLE_InitVars
*   is the one macro that you should think three times about before modifying.
*
*   One further note.  The variables 'ulDstLeft' and 'ulDstRight' appear to
*   come from nowhere.  This is not true.  They are in fact declared by the
*   macro <RLE_GetVisibleRect>.  However, showing these names in the macro
*   'call' tended to obscure the code.  Pretend you can see the declaration.
*
* Where can I find a macro definition?
*
*   Good question, glad you asked.  Look at the prefix:
*
*       RLE_<stuff> - lives in RLEBLT.H
*       RLE8_<blah> - lives in RLE8BLT.H
*
*   Anything else in here that looks like function call is not.  It's a macro.
*   Probably for bitwise manipulations.  Look for it in BITMANIP.H or in
*   the Miscellaneous section of RLEBLT.H

*  Added RLE Encoding functions: 10 Oct 92 @ 10:18
*   Gerrit van Wingerden [gerritv]
*
* Created: 19 Jan 92 @ 19:00
*  Author: Andrew Milton (w-andym)
*
* Copyright (c) 1990, 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* bSrcCopySRLE8D8
*
* Secure RLE blting that does clipping and won't die or write somewhere
* it shouldn't if given bad data.
*
* History:
*  19 Jan 1992 - Andrew Milton (w-andym):
*      Moved most of the initialization code back up to <EngCopyBits()> in
*      <trivblt.cxx>.  This way it is done once instead of once per call
*      of this function.
*
*      The rclDst field is now the visible rectangle of our bitmap, not the
*      target rectangle.  This cleans up the visible region checking.
*
*  24-Oct-1991 -by- Patrick Haluptzok patrickh
*      Updated, add clipping support
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
*      Wrote it.
\**************************************************************************/

BOOL
bSrcCopySRLE8D8(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Main Process Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // Newline

                RLE_NextLine(PBYTE, pjDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Position Delta.  Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
        RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

        // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pjDst[lOutCol] =
                                       (BYTE) pulXlate[(ULONG) *(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping.

                    pjSrc += ulCount;
            lOutCol += ulCount;

            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
                    pjSrc += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc)

            } /* switch */

        }
        else
        {

        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

        // Slap the bits on.

        while (ulCount--)
                {
            pjDst[lOutCol] = (BYTE) ulNext;
            lOutCol++;
        }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D8 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D1
*
* Secure RLE blting to a 1 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*       Added clip support.
*  22 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        These writes look unpleasant because we have to mask
 *        current destination contents onto the working byte when
 *        it is written.  To such an end, the below macro...
 */

#define RLE8to1_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible && (jBitPos = (BYTE) (OutColumn) & 7))                \
    {                                                                        \
        if (RLE_ColVisible(OutColumn))                                       \
            DstPtr[WritePos] = OutByte |                                     \
                 ((~ajBits[jBitPos]) & DstPtr[WritePos]);        \
        else                                                                 \
            if (RLE_PastRightEdge(OutColumn))                                \
        DstPtr[ulRightWritePos] = OutByte |              \
                 (DstPtr[ulRightWritePos] &  jRightMask);    \
    }


#define ColToBitPos(col) (7 - (BYTE) ((col) & 7) )

/* Lookup tables for bit patterns *****************************************/

static BYTE
ajPosMask[] =    // The i'th entry contains a byte with the i'th bit set
{
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80, 0x00
};

static BYTE
ajBits[] =       // The i'th entry contains a byte with the high i bits set
{
    0x00, 0x80, 0xC0, 0xE0, 0xF0,
          0xF8, 0xFC, 0xFE, 0xFF
};

/* And now the function ***************************************************/

BOOL
bSrcCopySRLE8D1(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    BYTE  jWorking;      // Hold area to build a byte for output
    ULONG ulWritePos;    // Write position off <pjDst> into the destination

    ULONG ulLeftWritePos; // Leftmost write position
    BYTE  jLeftMask;      // Bitmask for taking bytes off the left edge

    ULONG ulRightWritePos; // Rightmost write position
    BYTE  jRightMask;      // Bitmask for taking bytes off the right edge

    BYTE  jBitPos;       // Bit number of the next write into <jWorking>
    BYTE  jBitPosMask;   // Bitmask with the <jBitPos>th bit set.

    ULONG ulClipMargin;  // Number of bytes clipped off the right side of a run
    ULONG ulCompBytes;     // Number of complete bytes in an absolute run.

// Our Initialization

    ulLeftWritePos = (ULONG)(ulDstLeft >> 3);
    jLeftMask = ajBits[(ulDstLeft % 8)];

    ulRightWritePos = (ULONG) (ulDstRight >> 3);
    jRightMask = ~ajBits[(ulDstRight % 8)];

/* Fetch first working byte from the source.  Yes, this is ugly.
 * We cannot assume we are at a left edge because the complex clipping
 * case could resume an RLE in the middle of its bitmap.  We cannot do
 * a simple bounds check like RLE 8 to 4 because of bitmasking.  Argh.
 */

    ulWritePos = lOutCol >> 3;

    if (RLE_RowVisible)
    {
        if (RLE_ColVisible(lOutCol))
            jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
        else
        {
            if (RLE_PastRightEdge(lOutCol))
                jWorking = pjDst[ulRightWritePos];
            else
                jWorking = pjDst[ulLeftWritePos] & jLeftMask;
        }
    }
// Diddle the translation table

    int i, j;
    for (i = 1, j=1; i < 256; i+=1, j^= 1) pulXlate[i] = j;

    LOOP_FOREVER
    {

    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        ulWritePos = lOutCol >> 3;

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            case 1:

            // End of the bitmap

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Fetch a new working byte off the destination

                ulWritePos = lOutCol >> 3;
                if (RLE_RowVisible)
                {
                    if (RLE_ColVisible(lOutCol))
                        jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
                    else
                    {
                        if (RLE_PastRightEdge(lOutCol))
                            jWorking = pjDst[ulRightWritePos];
                        else
                            jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                    }
                }
                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

            // Output if we are on a visible scanline.

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount    = ulDstLeft - lOutCol;
                    ulNext    -= ulCount;
                    lOutCol   += ulCount;
                        ulWritePos = lOutCol >> 3;
                        pjSrc += ulCount;
                    }

                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                    jBitPos = (BYTE) ColToBitPos(lOutCol);
                    jBitPosMask = ajPosMask[jBitPos];
                    lOutCol += (LONG) ulNext;

                // Write the run

                    do {

                    // Fill the working byte

                        while(jBitPosMask && ulNext)
                        {
                            if (pulXlate[*pjSrc++])
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            ulNext--;
                        }

                    // Write it

                        if (!(jBitPosMask))
                        {
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            jBitPosMask = 0x80;
                            jWorking = 0;
                        }

                    } while (ulNext);

                // Adjust for the right side clipping.

            pjSrc      += ulCount;
            lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

            // Fix up if this run was not WORD aligned.

            RLE8_FixAlignment(pjSrc);

            } /* switch */

        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                ulCount      -= ulClipMargin;
                lOutCol      += ulClipMargin;
                    ulWritePos    = lOutCol >> 3;
                }

                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Initialize for the run.  Now we get funky-doodle

                jBitPos  = ColToBitPos(lOutCol);
                lOutCol += ulCount;
                ulNext   = pulXlate[ulNext];

            // Deal with the left side partial byte

                if (jBitPos >= (BYTE) ulCount)
                {
                // Will not fill the current working byte

                    ulCompBytes = 0;    // No Complete bytes.
                    if (ulNext)
                        jWorking |= (ajBits[ulCount] >> (7-jBitPos));
                    else
                        jWorking &= ~(ajBits[ulCount] >> (7-jBitPos));
                    jBitPos -= (BYTE)ulCount;
                    ulCount = 0;
                }
                else
                {
                /* Will fill the current working byte.
                 * We may have complete bytes to output.
                 */
                    ulCompBytes = ((BYTE)ulCount - jBitPos - 1) >> 3;

                    if (ulNext)
                        jWorking |= (~ajBits[7 - jBitPos]);
                    else
                        jWorking &= (ajBits[7 - jBitPos]);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    jWorking = 0;
                    ulCount -= (jBitPos + 1);
                    jBitPos  = 7;
                }

            // Deal with complete byte output

                if (ulCompBytes)
                {
                    UINT i;
                    jWorking = (ulNext) ? 0xFF : 0x00;
                    for (i = 0; i < ulCompBytes; i++)
                        pjDst[ulWritePos + i] = jWorking;
                    ulWritePos += ulCompBytes;
                    jBitPos  = 7;
                    jWorking = 0;
                    ulCount -= (ulCompBytes << 3);

                } /* if */

            // Deal with the right side partial byte

                if (ulCount)
                {
                    if (ulNext)
                        jWorking |= ajBits[ulCount];
                    else
                        jWorking = 0;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position and source pointer.
             */

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D1 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D4
*
* Secure RLE blting to a 4 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*     Added clip support.
*
*  24 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        To this end, the below macro...
 */

#define RLE8to4_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible)                                                      \
    {                                                                        \
        if (RLE_ColVisible(OutColumn) && bIsOdd(OutColumn))                  \
        {                                                                    \
            SetLowNybble(OutByte, DstPtr[WritePos]);                         \
            DstPtr[WritePos] = OutByte;                                      \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (bRightPartial && RLE_PastRightEdge(OutColumn))               \
            {                                                                \
                /*DbgBreakPoint();*/                                         \
                SetLowNybble(OutByte, DstPtr[ulRightWritePos]);                   \
                DstPtr[ulRightWritePos] = OutByte;                                \
            }                                                                \
        }                                                                    \
    }                                                                        \

BOOL
bSrcCopySRLE8D4(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    BOOL  bRightPartial;   // TRUE when a visible row ends in a partial byte
    BYTE  jWorking;        // Hold area to build a byte for output
    ULONG ulWritePos;      // Write position off <pjDst> into the destination
    ULONG ulLeftWritePos;  // Leftmost write position
    ULONG ulRightWritePos; // Rightmost write position
    ULONG ulClipMargin;    // Number of bytes clipped in an encoded run

// Our Initialization

    ulLeftWritePos  = ulDstLeft  >> 1;
    ulRightWritePos = ulDstRight >> 1;
    bRightPartial = (BOOL) bIsOdd(ulDstRight);

// Fetch our inital working byte

    ulWritePos = lOutCol >> 1;
    if (RLE_RowVisible)
        jWorking = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                     ulWritePos)];

// Main processing loop

    LOOP_FOREVER
    {
        ulWritePos = lOutCol >> 1;

    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

            case 0:

            // New line.

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos];

                break;

            case 1:

            // End of the bitmap.

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta  - Fetch and evaluate

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Read a new working byte off the destination

                ulWritePos = lOutCol >> 1;

                if (RLE_RowVisible)
                    jWorking   = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                                   ulWritePos)];

                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount     = ulDstLeft - lOutCol;
                    ulNext     -= ulCount;
                    lOutCol += ulCount;
                        ulWritePos = lOutCol >> 1;
                        pjSrc += ulCount;
                    }

                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Account for a right side partial byte

                    if (bIsOdd(lOutCol))
                    {
                        SetLowNybble(jWorking,
                                 (BYTE)(pulXlate[(ULONG) *pjSrc++]));
                        pjDst[ulWritePos] = jWorking;
                        lOutCol++;
                        ulWritePos++;
                        ulNext--;
                    }

                // Write the run

                    lOutCol += ulNext;
                    ulNext >>= 1;

                    while (ulNext)
                    {
                        jWorking = ((BYTE)pulXlate[(ULONG) *pjSrc++]) << 4;
                        SetLowNybble(jWorking,
                                    (BYTE)pulXlate[(ULONG) *pjSrc++]);
                        pjDst[ulWritePos] = jWorking;
                        ulWritePos++;
                        ulNext--;
                    }

                // Account for a left side partial byte

                    if (bIsOdd(lOutCol))
                        SetHighNybble(jWorking,
                                      (BYTE)pulXlate[(ULONG) *pjSrc++]);


                // Adjust for the right side clipping.

                    pjSrc      += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                pjSrc   += ulNext;
                lOutCol += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc);

            } /* switch */

        } else {

        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                ulCount      -= ulClipMargin;
                lOutCol      += ulClipMargin;
                    ulWritePos    = lOutCol >> 1;
                }

                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            ulNext = pulXlate[ulNext];

            // Account for a left side partial byte

                if (bIsOdd(lOutCol))
                {
                    SetLowNybble(jWorking, (BYTE)ulNext);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    lOutCol++;
                    ulCount--;
                }

            // Write complete bytes of the run

                lOutCol += ulCount;
                ulCount >>= 1;
                jWorking = BuildByte((BYTE)ulNext, (BYTE)ulNext);

                while(ulCount)
                {
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    ulCount--;
                }

            // Account for the partial byte on the right side

                if (bIsOdd(lOutCol))
                {
                    SetHighNybble(jWorking, (BYTE)ulNext);
                }

            // Adjust for the right side clipping.

        lOutCol    += ulClipMargin;
                ulWritePos  = lOutCol >> 1;
            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol    += ulCount;
                ulWritePos  = lOutCol >> 1;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D4 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D16
*
* Secure RLE blting to a 16 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE8D16(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pwDst, PWORD, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

    ULONG ulClipMargin = 0;

// Main Processing Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // Newline

                RLE_NextLine(PWORD, pwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta. -- Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);

        RLE_PosDelta(pwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pwDst[lOutCol] = (WORD)pulXlate[(ULONG)*(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping

                    pjSrc   += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
                    pjSrc   += ulNext;

        }

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Slap the bits on.

        while (ulCount--)
                {
            pwDst[lOutCol] = (WORD)ulNext;
            lOutCol++;
        }

        // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D16 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D24
*
* Secure RLE blting to a 24 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

#define RLE_24BitWrite(pjDst, BytePos, Colour)                               \
    pjDst[BytePos]   = (BYTE)Colour;                                         \
    pjDst[BytePos+1] = (BYTE)(Colour >> 8);                                  \
    pjDst[BytePos+2] = (BYTE)(Colour >> 16);                                 \
    BytePos += 3;                                                            \

BOOL
bSrcCopySRLE8D24(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    ULONG ulWritePos;
    ULONG ulNextColour;

// Main Processing Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // New line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta.  Fetch & Evaluate

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);

                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
        {
            RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
            ulWritePos = 3*lOutCol;

            RLE8_ClipRight(ulCount, ulNext, lOutCol);

        // Slap the bits on. -- this is the funky-doodle stuff.

        // Brute force & ignorance hard at work in this loop

            while (ulNext--)
            {
                ulNextColour = pulXlate[*pjSrc++];
                RLE_24BitWrite(pjDst, ulWritePos, ulNextColour);
                lOutCol += 1;
            }

        // Adjust for the right side clipping.

            pjSrc   += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

            // Fix up if this run was not WORD aligned.
        RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);
                ulWritePos = 3*lOutCol;
                lOutCol += ulCount;

            // Slap the bits on. -- Not very funky-doodle this time....

            // ...but more brute force and ignorance

                while (ulCount--)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, ulNext);
                }

            // Adjust for the right side clipping.

        lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D24 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D32
*
* Secure RLE blting to a 32 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE8D32(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pdwDst, PDWORD, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Main Process Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // New line

                RLE_NextLine(PDWORD, pdwDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta. -- Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
        RLE_PosDelta(pdwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

                RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pdwDst[lOutCol] = pulXlate[(ULONG) *(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping.

            lOutCol += ulCount;
            pjSrc   += ulCount;

            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

            RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Slap the bits on.

        while (ulCount--)
                {
            pdwDst[lOutCol] = ulNext;
            lOutCol++;
        }

        // Adjust for the right side clipping.

        lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE8D32 */



/*******************************Public*Routine*****************************\
* WriteEncoded8
*
* A helper function for EncodeRLE8.  Writes a run of bytes in encoded format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteEncoded8( BYTE bValue, BYTE *pbTarget, UINT uiLength,
                   BYTE *pbEndOfBuffer )
{
    if( pbTarget == NULL )
        return(2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = (BYTE) uiLength;
    *pbTarget++ = bValue;
    return(2);
}


/*******************************Public*Routine*****************************\
* WriteAbsolute8
*
* A helper function for EncodeRLE8.  Writes a run of bytes in absolute format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteAbsolute8( BYTE *pbRunStart, BYTE *pbTarget, int cRunLength,
                    BYTE *pbEndOfBuffer )
{
    int iRet;

    if( cRunLength == 1 )
    {
        iRet = 2;
    }
    else
    {
        if( cRunLength == 2 )
        {
            iRet = 4;
        }
        else
        {
            if( cRunLength & 0x01 )
            {
                iRet = cRunLength + 3;
            }
            else
            {
                iRet = cRunLength + 2;
            }
        }
    }

    if( pbTarget == NULL )
        return(iRet);

    if( pbTarget + iRet > pbEndOfBuffer )
        return(0);

    if( cRunLength == 1  )
    {
        *pbTarget++ = 0x01;
        *pbTarget = *pbRunStart;
        return(2);

    }

    if( cRunLength == 2 )
    {
        *pbTarget++ = 0x01;
        *pbTarget++ = *pbRunStart++;
        *pbTarget++ = 0x01;
        *pbTarget = *pbRunStart;
        return(4);
    }

    *pbTarget++ = 0;
    *pbTarget++ = (BYTE) cRunLength;

    RtlMoveMemory( pbTarget, pbRunStart, cRunLength );

    pbTarget += cRunLength;

    if( cRunLength & 0x01 )
    {
        *pbTarget++ = 0;
        return( iRet );
    }
    else
        return( iRet );

}



/*******************************Public*Routine*****************************\
* EncodeRLE8
*
* Encodes a bitmap into RLE8 format and returns the length of the of the
* encoded format.    If the target is NULL it just returns the length of
* the format. If there is a target and the encoded output is longer than
* cBufferSize then the function stops encoding and returns 0.
*
* History:
*  28 Oct 1992 Gerrit van Wingerden [gerritv] : creation
*  15 Mar 1993 Stephan J. Zachwieja [szach] : return 0 if buffer too small
*
\**************************************************************************/


int EncodeRLE8( BYTE *pbSource, BYTE *pbTarget, UINT uiWidth, UINT cNumLines,
                UINT cBufferSize )
{

    UINT cLineCount;
    BYTE bLastByte;
    BYTE *pbEndOfBuffer;
    BYTE *pbRunStart;
    BYTE *pbLineEnd;
    BYTE *pbCurPos;
    BYTE bCurChar;
    INT  cCurrentRunLength;
    INT  iMode, cTemp, uiLineWidth;
    UINT cTotal = 0;

    pbEndOfBuffer = pbTarget + cBufferSize;

    uiLineWidth = ( ( uiWidth + 3 ) >> 2 ) << 2;


    for( cLineCount = 0; cLineCount < cNumLines; cLineCount ++ )
    {
        pbRunStart = pbSource + uiLineWidth * cLineCount;
        bLastByte = *pbRunStart;
        pbLineEnd = pbRunStart + uiWidth;
        iMode = RLE_START;
        cCurrentRunLength = 1;

        for(pbCurPos = pbRunStart+1;pbCurPos <= pbLineEnd; pbCurPos += 1)
        {

            // We won't really encode the value at *pbLineEnd since it points
            // past the end of the scan so it doesn't matter what value we use.
            // However, it is important not to reference it since it may point
            // past the end of the buffer which can be uncommited memory.

            if( pbCurPos == pbLineEnd )
            {
                bCurChar = 0xFF;
            }
            else
            {
                bCurChar = *pbCurPos;
            }

            switch( iMode )
            {
            case RLE_START:
                iMode = (bCurChar == bLastByte) ? RLE_ENCODED : RLE_ABSOLUTE;
                bLastByte = bCurChar;
                break;

            case RLE_ABSOLUTE:
                if( ( bCurChar == bLastByte ) ||
                    ( cCurrentRunLength == 0xFF ) )

                {
                    int iOffset;

                    if( cCurrentRunLength == 0xFF )
                    {
                        iOffset = 0;
                        iMode = RLE_START;
                    }
                    else
                    {
                        iOffset = 1;
                        iMode = RLE_ENCODED;
                    }

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    cTemp = WriteAbsolute8(pbRunStart, pbTarget,
                        cCurrentRunLength - iOffset, pbEndOfBuffer);


                    if(pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                        pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = iOffset;
                }

                bLastByte = bCurChar;
                break;

            case RLE_ENCODED:
                if( ( bCurChar != bLastByte ) ||
                    ( cCurrentRunLength == 0xFF ) )

                {
                    cTemp = WriteEncoded8( bLastByte, pbTarget,
                       cCurrentRunLength, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if (pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                       pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    bLastByte = bCurChar;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = 0;
                    iMode =  RLE_START ;
                }

            }
            cCurrentRunLength += 1;
        }

        if( cCurrentRunLength > 1 )
        {
           if(iMode == RLE_ABSOLUTE)
              cTemp = WriteAbsolute8(pbRunStart, pbTarget,
                 cCurrentRunLength - 1, pbEndOfBuffer);
           else {
              cTemp = WriteEncoded8(bLastByte, pbTarget,
                 cCurrentRunLength - 1, pbEndOfBuffer);
           }

        // if pbTarget is not NULL and cTemp is zero then
        // the buffer is too small to hold  encoded  data

           if (pbTarget != NULL) {
              if (cTemp == 0) return(0);
              pbTarget += cTemp;
           }

           cTotal += cTemp;
        }

        if( pbTarget <= pbEndOfBuffer )
            cTotal += 2;

        if( pbTarget != NULL )
        {
            *((WORD *) pbTarget) = 0;
            pbTarget += 2;
        }

    }

// Write "End of bitmap" at the end so we're win31 compatible.

    if( pbTarget == NULL )
        return(cTotal + 2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = 0;
    *pbTarget++ = 1;
    return(cTotal + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\server.h ===
/******************************Module*Header*******************************\
* Module Name: server.h                                                    *
*                                                                          *
* Server side stubs for GDI functions.                                     *
*                                                                          *
* Created: 14-Jan-1992 11:04:08                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/


int APIENTRY GreSetDIBitsToDeviceInternal(
    HDC hdcDest,
    int xDst,
    int yDst,
    DWORD cx,
    DWORD cy,
    int xSrc,
    int ySrc,
    DWORD iStartScan,
    DWORD cNumScan,
    LPBYTE pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo,
    BOOL bTransformoordinates,
    HANDLE hcmXform);

BOOL
GreTransparentDIBits(
    HDC          hdcDst,
    LONG         xDst,
    LONG         yDst,
    LONG         cxDst,
    LONG         cyDst,
    LPBYTE       pInitBits,
    LPBITMAPINFO pInfoHeader,
    UINT         iUsage,
    LONG         xSrc,
    LONG         ySrc,
    LONG         cxSrc,
    LONG         cySrc,
    COLORREF     TransColor,
    ULONG        cjMaxInfo,
    ULONG        cjMaxBits,
    HANDLE hcmXform
    );

HBITMAP APIENTRY
GreCreateDIBitmapComp(
    HDC hdc,
    INT cx,
    INT cy,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    FLONG fl,
    HANDLE hcmXform);

HBITMAP APIENTRY
GreCreateDIBitmapReal(
    HDC hdc,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    HANDLE hSection,
    DWORD dwOffset,
    HANDLE hSecure,
    FLONG fl,
    ULONG_PTR dwClientColorSpace, //dwClientColorSpace used to pass pointer
    PVOID *ppvBits); 

HBITMAP APIENTRY GreCreateDIBitmapInternal(
    HDC hdc,
    LPBITMAPINFOHEADER pInfoHeader,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInfo,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    FLONG fl);

int APIENTRY GreSetDIBitsInternal(
    HDC hdc,
    HBITMAP hbm,
    UINT iStartScans,
    UINT cNumScans,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    UINT iUsage,
    UINT cjMaxInfo,
    UINT cjMaxBits,
    HANDLE hcmXform);

int APIENTRY GreStretchDIBitsInternal(
    HDC hdc,
    int xDest,
    int yDest,
    int cWidthDest,
    int cHeightDest,
    int xSrc,
    int ySrc,
    int cWidthSrc,
    int cHeightSrc,
    LPBYTE pjBits,
    LPBITMAPINFO lpBitsInfo,
    DWORD iUsage,
    DWORD Rop,
    UINT  cjMaxInfo,
    UINT  cjMaxBits,
    HANDLE hcmXform
    );

BOOL APIENTRY GrePolyPolygonInternal(
    HDC         hdc,
    LPPOINT     pptl,
    LPINT       pcptl,
    int         ccptl,
    UINT        cMaxPoints);

typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;

BOOL
GrePolyPatBlt(
    HDC         hdcDst,
    DWORD       rop4,
    PPOLYPATBLT pPolyPat,
    DWORD       Count,
    DWORD       Mode
);


BOOL APIENTRY GrePolyPolylineInternal(
    HDC         hdc,
    CONST POINT *pptl,
    PULONG      pcptl,
    ULONG       ccptl,
    UINT        cMaxPoints);

HRGN APIENTRY GreCreatePolyPolygonRgnInternal(
    CONST POINT *aptl,
    CONST INT   *acptl,
    int     cPoly,
    int     iFill,
    UINT    cMaxPoints);

BOOL GetFontResourceInfoInternalW(
    LPWSTR       lpPathname,
    ULONG        cwc,
    ULONG        cFiles,
    UINT         cjIn,
    PSIZE_T      lpBytes,
    LPVOID       lpBuffer,
    DWORD        iType);

HBRUSH GreCreateDIBBrush(PVOID pv, FLONG fl, UINT cjMax, BOOL b8X8, BOOL bPen, PVOID pClient);

HPALETTE APIENTRY GreCreatePaletteInternal(LPLOGPALETTE pLogPal, UINT cEntries);

ULONG  GreGetKerningPairs(HDC hdc, ULONG  cPairs, KERNINGPAIR *pkpDst);

BOOL GrePlayScript(
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulEnv,
    ULONG  cjEnv,
    PULONG pulOut,
    ULONG  cjOut,
    ULONG  cLimit);

BOOL GreXformUpdate( HDC, FLONG, LONG, LONG, LONG, LONG, LONG, PVOID );

BOOL GreArcInternal
(
    ARCTYPE     arctype,
    HDC         hdc,
    int         x1,
    int         y1,
    int         x2,
    int         y2,
    int         x3,
    int         y3,
    int         x4,
    int         y4
);

LONG GreGetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset);
LONG GreSetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset);
BOOL GreGetRasterizerCaps(LPRASTERIZER_STATUS praststat);

ULONG GreSetPolyFillMode(HDC hdc, int iPolyFillMode);
ULONG GreSetROP2(HDC hdc,int iROP);

HANDLE GreGetDCObject (HDC hdc, int itype);

HBRUSH GreCreateSolidBrushInternal(COLORREF clrr,BOOL bPen,HBRUSH hbr);
HBRUSH GreCreateHatchBrushInternal(ULONG iStyle, COLORREF clrr, BOOL bPen);
HBRUSH GreCreatePatternBrushInternal(HBITMAP hbm,BOOL bPen,BOOL b8X8);

ULONG  GreGetOutlineTextMetricsInternalW(
    HDC                  hdc,
    ULONG                cjotm,
    OUTLINETEXTMETRICW   *potmw,
    TMDIFF               *ptmd
    );

BOOL     APIENTRY GreDeleteObjectApp(HANDLE hobj);
NTSTATUS GdiServerDllInitialization(PVOID psrv);

BOOL bSyncBrushObj(
    HBRUSH hbr);

typedef struct _WIDTHDATA WIDTHDATA;

BOOL GreGetWidthTable
(
    HDC        hdc,
    ULONG      cSpecial,
    WCHAR     *pwc,
    ULONG      cwc,
    USHORT    *psWidth,
    WIDTHDATA *pwd,
    FLONG     *pflInfo
    );

HANDLE
APIENTRY
GreSelectObject(
    HDC    hdc,
    HANDLE h
    );




HDC hdcOpenDCW(
    PWSZ               pwszDevice,
    DEVMODEW          *pdriv,
    ULONG              iType,
    HANDLE             hspool,
    PREMOTETYPEONENODE prton,
    DRIVER_INFO_2W    *pDriverInfo,
    PVOID             pUMdhpdev
);


// WINBUG #83106 2-7-2000 bhouse Investigate moving prototypes to ntgdi.h
// Old Comment:
//    - This prototype should go in ntgdi.h

BOOL GreGetDCDword( HDC hdc, UINT u, DWORD *Result);
BOOL GreGetAndSetDCDword( HDC hdc, UINT u, DWORD value, DWORD *result );

BOOL APIENTRY GreGetDCPoint(HDC,UINT,PPOINTL);

BOOL APIENTRY GreScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
BOOL APIENTRY GreScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
BOOL APIENTRY GreSetVirtualResolution(HDC,int,int,int,int);
BOOL APIENTRY GreTransformPoints(HDC hdc,PPOINT pptIn,PPOINT pptOut,int c,int iMode);

BOOL   GreDeleteClientObj(HANDLE h);
HANDLE GreFixUpHandle(HANDLE h);

int  GreAddFontResourceWInternal(LPWSTR  pwszFileName, ULONG cwc, ULONG cFiles, FLONG fl, DWORD dwPidTid, DESIGNVECTOR *pdv, ULONG cjDV);
HANDLE GreAddFontMemResourceEx(PVOID pvBuffer, DWORD cjBuffer, DESIGNVECTOR *pdv, DWORD cjDV, DWORD *pNumFonts);
BOOL GreRemoveFontResourceW(LPWSTR pwszPath, ULONG cwc, ULONG cFiles, FLONG fl, DWORD dwPidTid, DESIGNVECTOR *pdv, ULONG cjDV);
BOOL GreRemoveFontMemResourceEx(HANDLE hMMFont);
LONG cCapString(WCHAR *pwcDst, const WCHAR *pwcSrc,INT cMax);

BOOL bGetPathName (
    PWCHAR awcPathName,
    LPWSTR pwszFileName
    );


HDC
GreGetDCforBitmap(
    HBITMAP hsurf
    );

BOOL
GreDoBanding( HDC hdc,BOOL bStart,POINTL *pptl );

BOOL
GreGetUFI( HDC hdc,
           PUNIVERSAL_FONT_ID pufi,
           DESIGNVECTOR *pdv,
           ULONG *pcjDV,
           ULONG *pulCheckSumDV,
           FLONG *pfl,
           VOID  **pfontID);

BOOL
GreForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi);

BOOL
GreGetUFIPathname(
    PUNIVERSAL_FONT_ID pufi,
    ULONG* pcwc,
    LPWSTR pwszPathname,
    ULONG* pcNumFiles,
    FLONG  fl,
    BOOL*  pbMemFont,
    ULONG* pcjView,
    PVOID  pvView,
    BOOL*  pbTTC,
    ULONG* iTTC
    );

ULONG  APIENTRY GreGetEmbedFonts();
BOOL   APIENTRY GreChangeGhostFont(VOID *fontID, BOOL bLoad);

DWORD  APIENTRY GreGetCharacterPlacementW(HDC, LPWSTR, DWORD, DWORD, LPGCP_RESULTSW, DWORD);

ULONG  GreGetGlyphOutlineInternal (
    HDC              hdc,
    WCHAR            wch,
    UINT             ulFormat,
    LPGLYPHMETRICS  lpgm,
    ULONG            cjBuffer,
    PVOID           pvBuffer,
    LPMAT2           lpmat2,
    BOOL            bIgnoreRotation
    );

BOOL GreResetDCInternal( HDC, DEVMODEW*, BOOL*, DRIVER_INFO_2W *, VOID * );

// It actually returns a handle
ULONG_PTR GreEnumFontOpen (
    HDC   hdc,
    ULONG iEnumType,
    FLONG flWin31Compat,
    ULONG cwchMax,
    PWSZ  pwszName,
    ULONG lfCharSet,
    ULONG *pulCount
    );

BOOL
GreSetupDCAttributes(
    HDC hdc
    );

BOOL
GreFreeDCAttributes(
    HDC hdc
    );

INT
GreQueryFonts(
    PUNIVERSAL_FONT_ID pufiFontList,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
    );

LPBITMAPINFO
pbmiConvertInfo(
    CONST BITMAPINFO *pbmi,
    ULONG iUsage);

BOOL bSetupBrushAttr (HBRUSH hbrush);

ULONG GreMakeFontDir(
    FLONG    flEmbed,       // mark file as "hidden"
    PBYTE    pjFontDir,     // pointer to structure to fill
    PWSZ     pwszPathname   // path of font file to use
    );

DWORD GreGetGlyphIndicesW (
    HDC     hdc,
    WCHAR  *pwc,
    DWORD   cwc,
    USHORT *pgi,
    DWORD   iMode,
    BOOL    bSubset
    );

DWORD GreGetFontUnicodeRanges(HDC, LPGLYPHSET);

#ifdef LANGPACK
BOOL GreGetRealizationInfo(HDC, PREALIZATION_INFO);
#endif

#define STRETCHBLT_ENABLE_ICM  0x0001

BOOL GreStretchBltInternal(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor,
FLONG   ulFlags
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\srcalign.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcalign.cxx
*
* This contains code that can be used to do source aligned reads. This
* will improve performance when reading from non cached video memory resisdent
* surfaces.
*
* Created: 04-May-1999
* Author: Pravin Santiago pravins. 
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

void vSrcAlignCopyMemory(PBYTE pjDst, PBYTE pjSrc, ULONG c)
{
    // If overlap use RtlMoveMemory()
    if(pjSrc < pjDst && pjDst < pjSrc + c)
    {
        RtlMoveMemory((PVOID)pjDst,(PVOID)pjSrc,c);
    }
    else
    {
        while(c != 0) 
        {
            // Do correctly aligned data reads from the source while
            // maximizing the number of QuadWord reads.

            if((((ULONG_PTR)pjSrc & 7) == 0) && (c >= 8)) // 8 byte aligned
            {
                // Maximize QuadWord reads of pjSrc. 
#if i386
                if(HasMMX)
                {
                    __asm
                    {
                        mov ecx, c 
                        mov esi, pjSrc
                        mov edi, pjDst
                    nextf:
                        movq mm0, [esi]
                        movq [edi], mm0
                        add esi, 8
                        add edi, 8
                        sub ecx, 8
                        cmp ecx, 8
                        jae nextf
                        mov pjSrc, esi
                        mov pjDst, edi
                        mov c,     ecx
                    }
                }
                else
#endif
                {
                    do
                    {

                        *UNALIGNED_QWORD_POINTER(pjDst) = *(volatile ULONGLONG *)pjSrc;
                        pjDst += 8; pjSrc += 8;
                        c -= 8;
                    } while(c >= 8);
                }
            }
            else if((((ULONG_PTR)pjSrc & 3) == 0) && (c >= 4))// 4 byte aligned
            {
                *UNALIGNED_DWORD_POINTER(pjDst) = *(volatile ULONG *)pjSrc;
                pjDst += 4; pjSrc += 4;
                c -= 4;
            }
            else if((((ULONG_PTR)pjSrc & 1) == 0) && (c >= 2))// 2 byte aligned
            {
                *UNALIGNED_WORD_POINTER(pjDst) = *(volatile USHORT *)pjSrc;
                pjDst += 2; pjSrc += 2;
                c -= 2;
            }
            else // odd byte aligned
            {
                *pjDst++ = *pjSrc++;
                c--;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\sprite.cxx ===
/******************************Module*Header*******************************\
* Module Name: sprite.cxx
*
* Contains all the drawing code for handling GDI sprites.
*
* Created: 16-Sep-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Notes
//
//  - EngAlphaBlend always calls 32BitfieldsToBGRA with identity pxlo
//  - pSprite->rclSrc no longer needed
//  - Fix vProfile for smart heap management

// Global variable that defines a (0, 0) offset:

POINTL gptlZero;
POINTL gptl00;

// Handy forward declarations:

VOID vSpComputeUnlockedRegion(SPRITESTATE*);
VOID vSpCheckForWndobjOverlap(SPRITESTATE*, RECTL*, RECTL*);

/******************************Public*Routine******************************\
* VOID vSpDirectDriverAccess
*
* If 'bEnable' is TRUE, this routine undoes any sprite modifications to
* the surface, in order to allow us to call the driver from within the
* sprite code.
*
* If 'bEnable' is FALSE, this routine redoes any sprite modifications to
* the surface that are needed for any drawing calls outside of this file,
* in order to be redirected through the sprite code as appropriate.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDirectDriverAccess(
SPRITESTATE*    pState,
BOOL            bEnable)
{
    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    if (bEnable)
    {
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                flags(pState->flOriginalSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                iType(pState->iOriginalType);

        pState->bInsideDriverCall = TRUE;
    }
    else
    {
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                flags(pState->flSpriteSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                iType(pState->iSpriteType);

        pState->bInsideDriverCall = FALSE;
    }
}


#if DEBUG_SPRITES
/******************************Debug*Routine*******************************\
* VOID vSpValidateVisibleSprites
*
* Walk visible spritelist and validates cVisible count equals number of
*  sprites in pListVisible.
*
*  08-May-2001 -by- Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

void vSpValidateVisibleSprites(
    SPRITESTATE *pState
    )
{
    ULONG   cVisible;
    SPRITE *pSprite;

    cVisible = pState->cVisible;
    for (pSprite = pState->pListVisible;
         pSprite != NULL;
         pSprite = pSprite->pNextVisible)
    {
        ASSERTGDI(cVisible != 0, "Invalid visible sprite list: list is longer than cVisible.\n");
        cVisible--;
        ASSERTGDI(pSprite->fl & SPRITE_FLAG_VISIBLE, "Invalid sprite visible state: invisible sprite in visible list.\n");
    }
    ASSERTGDI(cVisible == 0, "Invalid visible sprite list: list is missing a sprite or more.\n");

    cVisible = pState->cVisible;
    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
        {
            ASSERTGDI(cVisible != 0, "Invalid visible sprite count: cVisible is too small.\n");
            cVisible--;
        }
    }
    ASSERTGDI(cVisible == 0, "Invalid visible sprite count: cVisible is too big.\n");
}
#endif


/*********************************Class************************************\
* class SPRITELOCK
*
* This class is responsible for reseting whatever sprite state is
* necessary so that we can call the driver directly, bypassing any sprite
* code.
*
* Must be called with the DEVLOCK already held, because we're
* messing with the screen surface.
*
\***************************************************************************/

SPRITELOCK::SPRITELOCK(PDEVOBJ& po)
{
    pState = po.pSpriteState();

    po.vAssertDevLock();

    bWasAlreadyInsideDriverCall = pState->bInsideDriverCall;
    if (!bWasAlreadyInsideDriverCall)
    {
        vSpDirectDriverAccess(pState, TRUE);
    }

#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif
}

SPRITELOCK::~SPRITELOCK()
{
#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif

    if (!bWasAlreadyInsideDriverCall)
    {
        vSpDirectDriverAccess(pState, FALSE);
    }
}

/******************************Public*Routine******************************\
* VOID psoSpCreateSurface
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SURFOBJ* psoSpCreateSurface(
SPRITESTATE*    pState,
ULONG           iBitmapFormat,  // If zero, use same format as display
LONG            cx,
LONG            cy,
BOOL            bWantSystemMemory)  // TRUE if must be system memory, FALSE
                                    //   if can be in video memory
{
    HSURF       hsurf;
    SIZEL       sizl;
    SURFOBJ*    psoScreen;
    SURFOBJ*    psoRet;
    SURFACE*    psurf;

    PDEVOBJ po(pState->hdev);

    psoRet = NULL;

    sizl.cx = cx;
    sizl.cy = cy;

    psoScreen = pState->psoScreen;

    if (iBitmapFormat == 0)
    {
        iBitmapFormat = psoScreen->iBitmapFormat;
    }

    hsurf = 0;

    if ((!bWantSystemMemory) &&
        (PPFNVALID(po, CreateDeviceBitmap)) &&
        (iBitmapFormat == psoScreen->iBitmapFormat))
    {
        hsurf = (HSURF) (*PPFNDRV(po, CreateDeviceBitmap))
                            (psoScreen->dhpdev,
                             sizl,
                             iBitmapFormat);
    }
    if (hsurf == 0)
    {
        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        0,
                                        iBitmapFormat,
                                        BMF_TOPDOWN,
                                        NULL);
    }
    if (hsurf != 0)
    {
        psoRet = EngLockSurface(hsurf);
        ASSERTGDI(psoRet != NULL, "How could lock possibly fail?");

        // Mark the surface, so that it can be special-cased by
        // the dynamic mode change code:

        psurf = SURFOBJ_TO_SURFACE_NOT_NULL(psoRet);
        psurf->hdev(pState->hdev);
    }

    return(psoRet);
}

/******************************Public*Routine******************************\
* VOID vSpDeleteSurface
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteSurface(
SURFOBJ*    pso)
{
    HSURF   hsurf;

    // Note that EngDeleteSurface handles calling DrvDeleteDeviceBitmap
    // if it's a device format bitmap:

    if (pso != NULL)
    {
        hsurf = pso->hsurf;
        EngUnlockSurface(pso);
        EngDeleteSurface(hsurf);
    }
}

/**********************************Macros**********************************\
* OFFSET_POINTL, OFFSET_RECTL
*
* These little macros offset simple structures using a copy on the stack.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define OFFSET_POINTL(pptl, xOff, yOff)                 \
    POINTL ptlCopyOf##pptl;                             \
    POINTL* pptlOriginal##pptl;                         \
    if (pptl != NULL)                                   \
    {                                                   \
        ptlCopyOf##pptl.x = xOff + pptl->x;             \
        ptlCopyOf##pptl.y = yOff + pptl->y;             \
        pptlOriginal##pptl = pptl;                      \
        pptl = &ptlCopyOf##pptl;                        \
    }

#define OFFSET_RECTL(prcl, xOff, yOff)                  \
    RECTL rclCopyOf##prcl;                              \
    if (prcl != NULL)                                   \
    {                                                   \
        rclCopyOf##prcl.left   = xOff + prcl->left;     \
        rclCopyOf##prcl.right  = xOff + prcl->right;    \
        rclCopyOf##prcl.top    = yOff + prcl->top;      \
        rclCopyOf##prcl.bottom = yOff + prcl->bottom;   \
        prcl = &rclCopyOf##prcl;                        \
    }

#define OFFSET_POINTL_NOT_NULL(pptl, xOff, yOff)        \
    POINTL ptlCopyOf##pptl;                             \
    ptlCopyOf##pptl.x = xOff + pptl->x;                 \
    ptlCopyOf##pptl.y = yOff + pptl->y;                 \
    pptl = &ptlCopyOf##pptl;

#define OFFSET_RECTL_NOT_NULL(prcl, xOff, yOff)         \
    RECTL rclCopyOf##prcl;                              \
    rclCopyOf##prcl.left   = xOff + prcl->left;         \
    rclCopyOf##prcl.right  = xOff + prcl->right;        \
    rclCopyOf##prcl.top    = yOff + prcl->top;          \
    rclCopyOf##prcl.bottom = yOff + prcl->bottom;       \
    prcl = &rclCopyOf##prcl;

// The following little macro is here to catch any Drv or Eng functions
// that illegaly modify the value of 'pptlBrush'.  If you hit this assert,
// it means that the function we just called is a culprit.

#define ASSERT_BRUSH_ORIGIN(pptl, xOff, yOff)           \
    ASSERTGDI((pptl == NULL) ||                         \
              ((ptlCopyOf##pptl.x == xOff + pptlOriginal##pptl->x) && \
               (ptlCopyOf##pptl.y == yOff + pptlOriginal##pptl->y)),  \
        "Called function modified pptlBrush");

/******************************Public*Routine******************************\
* VOID CLIPOBJ_vOffset
*
* These are little in-line routines to handle offseting of complex
* structures that must remain in-place.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL CLIPOBJ_vOffset(
CLIPOBJ*    pco,
LONG        x,
LONG        y)
{
    POINTL ptlOffset;

    if (pco != NULL)
    {
        if ((x != 0) || (y != 0))
        {
            pco->rclBounds.left   += x;
            pco->rclBounds.right  += x;
            pco->rclBounds.top    += y;
            pco->rclBounds.bottom += y;

            if (pco->iDComplexity != DC_TRIVIAL)
            {
                ptlOffset.x = x;
                ptlOffset.y = y;

                ((XCLIPOBJ*) pco)->bOffset(&ptlOffset);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID STROBJ_vOffset
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL STROBJ_vOffset(
STROBJ* pstro,
LONG    x,
LONG    y)
{
    GLYPHPOS*   pgp;
    ULONG       cGlyphs;

    if ((x != 0) || (y != 0))
    {
        pstro->rclBkGround.left   += x;
        pstro->rclBkGround.right  += x;
        pstro->rclBkGround.top    += y;
        pstro->rclBkGround.bottom += y;

        // We are just offsetting positions, they are always computed,
        // unless;
        //
        // a) this is a fixed pitch font (ulCharInc != 0), in which case only
        //    first position in the batch is set.
        //
        // b) we are dealing with linked fonts.
        //
        // bEnum is just putting bits in the cache, that is independent
        // of computing positions.

        if (((ESTROBJ*)pstro)->flTO & TO_HIGHRESTEXT)
        {
            x <<= 4;
            y <<= 4;
        }

        pgp = ((ESTROBJ*)pstro)->pgpos;

        if(((ESTROBJ*)pstro)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
        {
            LONG *plFont;

            plFont  = ((ESTROBJ*)pstro)->plPartition;

            for (cGlyphs = pstro->cGlyphs ; cGlyphs != 0; pgp++, plFont++)
            {
                // only offset the glyphs that correspond to the current font:

                if (*plFont == ((ESTROBJ*)pstro)->lCurrentFont)
                {
                    cGlyphs--;
                    pgp->ptl.x += x;
                    pgp->ptl.y += y;
                }
            }
        }
        else
        {
            if (!pstro->ulCharInc)
            {
                cGlyphs = pstro->cGlyphs;

                for (; cGlyphs != 0; cGlyphs--, pgp++)
                {
                    pgp->ptl.x += x;
                    pgp->ptl.y += y;
                }
            }
            else
            {
                // fixed pitch, only fix the first position, the rest will be
                // computed during bEnum phase if necessary

                pgp->ptl.x += x;
                pgp->ptl.y += y;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID PATHOBJ_vOffset
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL PATHOBJ_vOffset(
PATHOBJ*    ppo,
LONG        x,
LONG        y)
{
    BOOL        bMore;
    PATHDATA    pd;
    POINTFIX*   pptfx;
    ULONG       cptfx;

    if ((x != 0) || (y != 0))
    {
        EPOINTL eptl(x, y);

        ((EPATHOBJ*) ppo)->vOffset(eptl);
    }
}

/*********************************Macro************************************\
* macro OFFBITBLT
*
* This handy little macro invokes OffBitBlt to call either EngBitBlt or
* DrvBitBlt, depending on whether the destination surface is owned by
* the device.
\**************************************************************************/

#define OFFBITBLT(pOffDst_, psoDst_, pOffSrc_, psoSrc_, psoMsk_, pco_,  \
                  pxlo_, prclDst_, pptlSrc_, pptlMsk_, pbo_, pptlBrush_,\
                  rop4_)                                                \
    OffBitBlt(PPFNDIRECT(psoDst_, BitBlt),                              \
     pOffDst_, psoDst_, pOffSrc_, psoSrc_, psoMsk_, pco_,               \
     pxlo_, prclDst_, pptlSrc_, pptlMsk_, pbo_, pptlBrush_, rop4_)

/*********************************Macro************************************\
* macro OFFCOPYBITS
*
* This handy little macro invokes OffCopyBits to call either EngCopyBits or
* DrvCopyBits, depending on whether either of the surfaces are owned by
* the device.
\**************************************************************************/

#define OFFCOPYBITS(pOffDst_, psoDst_, pOffSrc_, psoSrc_, pco_, pxlo_,  \
                    prclDst_, pptlSrc_)                                 \
    OffCopyBits(((!(SURFOBJ_TO_SURFACE_NOT_NULL((psoDst_))->flags() & HOOK_CopyBits)\
        && (psoSrc_->hdev))                                             \
        ? PPFNDIRECT(psoSrc_, CopyBits)                                 \
        : PPFNDIRECT(psoDst_, CopyBits)),                               \
    pOffDst_, psoDst_, pOffSrc_, psoSrc_, pco_, pxlo_, prclDst_,        \
    pptlSrc_)

/******************************Public*Routine******************************\
* BOOL Off*
*
* These routines handle the offseting of coordinates given to the driver,
* for the purposes of multi-monitor and sprite support.  Each of these
* routines correspond to a DDI drawing call, and offsets all drawing
* coordinates by the 'xOffset' and 'yOffset' values in the corresponding
* SURFOBJ.
*
* Some complex DDI data-structures such as PATHOBJs and TEXTOBJs must be
* modified in-place; they are always reset to their original values before
* returning.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

/******************************Public*Routine******************************\
* BOOL OffStrokePath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStrokePath(
PFN_DrvStrokePath   pfnStrokePath,
POINTL*             pOffset,
SURFOBJ*            pso,
PATHOBJ*            ppo,
CLIPOBJ*            pco,
XFORMOBJ*           pxo,
BRUSHOBJ*           pbo,
POINTL*             pptlBrush,
LINEATTRS*          pla,
MIX                 mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    if ((bRet == FALSE) &&
        ((pla->fl & LA_GEOMETRIC) || (ppo->fl & PO_BEZIERS)))
    {
        // When given a wideline, or given a line composed of bezier curves,
        // the driver can return FALSE from DrvStrokePath to indicate that
        // it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvStrokePath to a different area.
        // If we returned FALSE, GDI would pop through the DrvStrokePath
        // path and touch all the areas again, thus erasing the DrvStrokePath
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffFillPath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffFillPath(
PFN_DrvFillPath pfnFillPath,
POINTL*         pOffset,
SURFOBJ*        pso,
PATHOBJ*        ppo,
CLIPOBJ*        pco,
BRUSHOBJ*       pbo,
POINTL*         pptlBrush,
MIX             mix,
FLONG           flOptions)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    if (bRet == FALSE)
    {
        // The driver can return FALSE from DrvFillPath to indicate that
        // it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvFillPath to a different area.
        // If we returned FALSE, GDI would pop through the DrvFillPath
        // path and touch all the areas again, thus erasing the DrvFillPath
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStrokeAndFillPath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStrokeAndFillPath(
PFN_DrvStrokeAndFillPath    pfnStrokeAndFillPath,
POINTL*                     pOffset,
SURFOBJ*                    pso,
PATHOBJ*                    ppo,
CLIPOBJ*                    pco,
XFORMOBJ*                   pxo,
BRUSHOBJ*                   pboStroke,
LINEATTRS*                  pla,
BRUSHOBJ*                   pboFill,
POINTL*                     pptlBrush,
MIX                         mixFill,
FLONG                       flOptions)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, pla,
                                     pboFill, pptlBrush, mixFill, flOptions);
    if (bRet == FALSE)
    {
        // The driver can return FALSE from DrvStrokeAndFillPath to indicate
        // that it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvStrokeAndFillPath to a different
        // area.  If we returned FALSE, GDI would pop through the
        // DrvStrokeAndFillPath path and touch all the areas again, thus
        // erasing the DrvStrokeAndFillPath that is supposed to be drawn in
        // the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, pla,
                                    pboFill, pptlBrush, mixFill, flOptions);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffTextOut
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffTextOut(
PFN_DrvTextOut  pfnTextOut,
POINTL*         pOffset,
SURFOBJ*        pso,
STROBJ*         pstro,
FONTOBJ*        pfo,
CLIPOBJ*        pco,
RECTL*          prclExtra,    // Not used by display drivers
RECTL*          prclOpaque,
BRUSHOBJ*       pboFore,
BRUSHOBJ*       pboOpaque,
POINTL*         pptlOrg,      // Not used by display drivers
MIX             mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    ASSERTGDI(prclExtra == NULL, "Unexpected non-NULL prclExtra");

    // Must offset a copy of 'prclOpaque' first because GDI sometimes
    // points 'prclOpaque' to '&pstro->rclBkGround', and so we would
    // do the offset twice.

    OFFSET_RECTL(prclOpaque, x, y);
    STROBJ_vOffset(pstro, x, y);
    CLIPOBJ_vOffset(pco, x, y);

    BOOL bRet = pfnTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlOrg, mix);

    STROBJ_vOffset(pstro, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffLineTo
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffLineTo(
PFN_DrvLineTo   pfnLineTo,
POINTL*         pOffset,
SURFOBJ*        pso,
CLIPOBJ*        pco,
BRUSHOBJ*       pbo,
LONG            x1,
LONG            y1,
LONG            x2,
LONG            y2,
RECTL*          prclBounds,
MIX             mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    CLIPOBJ_vOffset(pco, x, y);
    x1 += x;
    x2 += x;
    y1 += y;
    y2 += y;
    OFFSET_RECTL(prclBounds, x, y);

    BOOL bRet = pfnLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    if (!bRet)
    {
        // The driver can return FALSE from DrvLineTo to indicate that
        // it would like to instead by called via DrvStrokePath.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvLineTo to a different area.
        // If we returned FALSE, GDI would pop through the DrvStrokePath
        // path and touch all the areas again, thus erasing the DrvLineTo
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }

    CLIPOBJ_vOffset(pco, -x, -y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffGradientFill
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffGradientFill(
PFN_DrvGradientFill pfnGradientFill,
POINTL*             pOffset,
SURFOBJ*            pso,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
TRIVERTEX*          pVertex,
ULONG               nVertex,
PVOID               pMesh,
ULONG               nMesh,
RECTL*              prclExtents,
POINTL*             pptlDitherOrg,
ULONG               ulMode)
{
    LONG        x;
    LONG        y;
    ULONG       i;
    TRIVERTEX*  pTmp;

    x = pOffset->x;
    y = pOffset->y;

    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_RECTL(prclExtents, x, y);

    // The offseting of the dither origin is different than that of the other
    // data structures.  The dither origin is defined to be the negative of
    // the offset of the window relative to the origin of the desktop surface.
    // The right value to pass to xxxGradientFill would be the negative of the
    // offset of the window relative to the origin of the sprite surface/
    // PDEV surface (for multimon).  This is computed by subtracting the
    // pOffset from pptlDitherOrg.
    //
    // From definition of dither origin:
    // pptlDitherOrg = (-xWin_surf, -yWin_surf)
    //
    // From surface to desktop coordinate conversion:
    // (xWin_surf, yWin_surf) = (xWin_desk-xSurf_desk, yWin_desk-ySurf_desk)
    // where (xSurf_Desk, ySurf_desk) is the surface origin relative to the
    // desktop (corresponds to -pOffset in this function).
    //
    // Putting the two together, we get:
    // pptlDitherOrg = (-(xWin_desk-xSurf_desk), -(yWin_desk-ySurf_desk))=
    //               = (-xWin_desk+xSurf_desk, -yWin_desk+ySurf_desk) =
    //               = (-xWin_desk, -yWin_desk) + (xSurf_desk, ySurf_desk) =
    //               = pptlDitherOrg_desk + (-pOffset)
    //               = pptlDitherOrg_desk - pOffset
    //

    OFFSET_POINTL(pptlDitherOrg, (-x), (-y));

    for (pTmp = pVertex, i = 0; i < nVertex; i++, pTmp++)
    {
        pTmp->x += x;
        pTmp->y += y;
    }

    BOOL bRet = pfnGradientFill(pso, pco, pxlo, pVertex, nVertex, pMesh,
                                nMesh, prclExtents, pptlDitherOrg, ulMode);

    CLIPOBJ_vOffset(pco, -x, -y);
    for (pTmp = pVertex, i = 0; i < nVertex; i++, pTmp++)
    {
        pTmp->x -= x;
        pTmp->y -= y;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffBitBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffBitBlt(
PFN_DrvBitBlt   pfnBitBlt,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
SURFOBJ*        psoMsk,
CLIPOBJ*        pco,
XLATEOBJ*       pxlo,
RECTL*          prclDst,
POINTL*         pptlSrc,
POINTL*         pptlMsk,
BRUSHOBJ*       pbo,
POINTL*         pptlBrush,
ROP4            rop